//! Tests for Chapter 36: Multithreaded Quicksort with Three Pivot Selection Strategies

#[cfg(test)]
mod TestChapter36 {
    use std::sync::Mutex;
    use apas_ai::Chapter36::Chapter36::*;
    use apas_ai::ArraySeqMtPer::ArraySeqMtPer::*;
    use apas_ai::Types::Types::*;

    #[test]
    fn test_quicksort_pivot_first_empty() {
        let empty: ArrayMtPerS<i32> = ArrayMtPerS::from_vec(vec![]);
        let result = quicksort_pivot_first(&empty);
        assert_eq!(result.length(), 0);
    }

    #[test]
    fn test_quicksort_pivot_first_single() {
        let single = ArrayMtPerS::from_vec(vec![42]);
        let result = quicksort_pivot_first(&single);
        assert_eq!(result.length(), 1);
        assert_eq!(*result.nth(0), 42);
    }

    #[test]
    fn test_quicksort_pivot_first_sorted() {
        let sorted = ArrayMtPerS::from_vec(vec![
            Mutex::new(1), Mutex::new(2), Mutex::new(3), Mutex::new(4), Mutex::new(5)
        ]);
        let result = quicksort_pivot_first(&sorted);
        assert_eq!(result.length(), 5);
        for i in 0..5 {
            assert_eq!(*result.nth(i).lock().unwrap(), i + 1);
        }
    }

    #[test]
    fn test_quicksort_pivot_first_reverse_sorted() {
        let reverse = ArrayMtPerS::from_vec(vec![
            Mutex::new(5), Mutex::new(4), Mutex::new(3), Mutex::new(2), Mutex::new(1)
        ]);
        let result = quicksort_pivot_first(&reverse);
        assert_eq!(result.length(), 5);
        for i in 0..5 {
            assert_eq!(*result.nth(i).lock().unwrap(), i + 1);
        }
    }

    #[test]
    fn test_quicksort_pivot_first_random() {
        let random = ArrayMtPerS::from_vec(vec![
            Mutex::new(3), Mutex::new(1), Mutex::new(4), Mutex::new(1), Mutex::new(5), 
            Mutex::new(9), Mutex::new(2), Mutex::new(6), Mutex::new(5)
        ]);
        let result = quicksort_pivot_first(&random);
        assert_eq!(result.length(), 9);
        
        // Verify sorted order
        for i in 1..result.length() {
            assert!(*result.nth(i-1).lock().unwrap() <= *result.nth(i).lock().unwrap());
        }
    }

    #[test]
    fn test_quicksort_pivot_median_of_three_empty() {
        let empty: ArrayMtPerS<i32> = ArrayMtPerS::from_vec(vec![]);
        let result = quicksort_pivot_median_of_three(&empty);
        assert_eq!(result.length(), 0);
    }

    #[test]
    fn test_quicksort_pivot_median_of_three_single() {
        let single = ArrayMtPerS::from_vec(vec![Mutex::new(42)]);
        let result = quicksort_pivot_median_of_three(&single);
        assert_eq!(result.length(), 1);
        assert_eq!(*result.nth(0).lock().unwrap(), 42);
    }

    #[test]
    fn test_quicksort_pivot_median_of_three_sorted() {
        let sorted = ArrayMtPerS::from_vec(vec![
            Mutex::new(1), Mutex::new(2), Mutex::new(3), Mutex::new(4), Mutex::new(5)
        ]);
        let result = quicksort_pivot_median_of_three(&sorted);
        assert_eq!(result.length(), 5);
        for i in 0..5 {
            assert_eq!(*result.nth(i).lock().unwrap(), i + 1);
        }
    }

    #[test]
    fn test_quicksort_pivot_median_of_three_reverse_sorted() {
        let reverse = ArrayMtPerS::from_vec(vec![
            Mutex::new(5), Mutex::new(4), Mutex::new(3), Mutex::new(2), Mutex::new(1)
        ]);
        let result = quicksort_pivot_median_of_three(&reverse);
        assert_eq!(result.length(), 5);
        for i in 0..5 {
            assert_eq!(*result.nth(i).lock().unwrap(), i + 1);
        }
    }

    #[test]
    fn test_quicksort_pivot_median_of_three_random() {
        let random = ArrayMtPerS::from_vec(vec![
            Mutex::new(7), Mutex::new(2), Mutex::new(9), Mutex::new(1), Mutex::new(8), 
            Mutex::new(3), Mutex::new(6), Mutex::new(4), Mutex::new(5)
        ]);
        let result = quicksort_pivot_median_of_three(&random);
        assert_eq!(result.length(), 9);
        
        // Verify sorted order
        for i in 1..result.length() {
            assert!(*result.nth(i-1).lock().unwrap() <= *result.nth(i).lock().unwrap());
        }
    }

    #[test]
    fn test_quicksort_pivot_random_empty() {
        let empty: ArrayMtPerS<i32> = ArrayMtPerS::from_vec(vec![]);
        let result = quicksort_pivot_random(&empty);
        assert_eq!(result.length(), 0);
    }

    #[test]
    fn test_quicksort_pivot_random_single() {
        let single = ArrayMtPerS::from_vec(vec![Mutex::new(42)]);
        let result = quicksort_pivot_random(&single);
        assert_eq!(result.length(), 1);
        assert_eq!(*result.nth(0).lock().unwrap(), 42);
    }

    #[test]
    fn test_quicksort_pivot_random_sorted() {
        let sorted = ArrayMtPerS::from_vec(vec![
            Mutex::new(1), Mutex::new(2), Mutex::new(3), Mutex::new(4), Mutex::new(5)
        ]);
        let result = quicksort_pivot_random(&sorted);
        assert_eq!(result.length(), 5);
        for i in 0..5 {
            assert_eq!(*result.nth(i).lock().unwrap(), i + 1);
        }
    }

    #[test]
    fn test_quicksort_pivot_random_reverse_sorted() {
        let reverse = ArrayMtPerS::from_vec(vec![
            Mutex::new(5), Mutex::new(4), Mutex::new(3), Mutex::new(2), Mutex::new(1)
        ]);
        let result = quicksort_pivot_random(&reverse);
        assert_eq!(result.length(), 5);
        for i in 0..5 {
            assert_eq!(*result.nth(i).lock().unwrap(), i + 1);
        }
    }

    #[test]
    fn test_quicksort_pivot_random_random_data() {
        let random = ArrayMtPerS::from_vec(vec![
            Mutex::new(15), Mutex::new(3), Mutex::new(12), Mutex::new(7), Mutex::new(1), 
            Mutex::new(20), Mutex::new(8), Mutex::new(11), Mutex::new(4), Mutex::new(18)
        ]);
        let result = quicksort_pivot_random(&random);
        assert_eq!(result.length(), 10);
        
        // Verify sorted order
        for i in 1..result.length() {
            assert!(*result.nth(i-1).lock().unwrap() <= *result.nth(i).lock().unwrap());
        }
    }

    #[test]
    fn test_quicksort_pivot_random_duplicates() {
        let duplicates = ArrayMtPerS::from_vec(vec![
            Mutex::new(3), Mutex::new(1), Mutex::new(3), Mutex::new(2), Mutex::new(1), 
            Mutex::new(2), Mutex::new(3), Mutex::new(1), Mutex::new(2)
        ]);
        let result = quicksort_pivot_random(&duplicates);
        assert_eq!(result.length(), 9);
        
        // Verify sorted order and count duplicates
        for i in 1..result.length() {
            assert!(*result.nth(i-1).lock().unwrap() <= *result.nth(i).lock().unwrap());
        }
        
        // Count occurrences
        let mut count_1 = 0;
        let mut count_2 = 0;
        let mut count_3 = 0;
        for i in 0..result.length() {
            match *result.nth(i).lock().unwrap() {
                1 => count_1 += 1,
                2 => count_2 += 1,
                3 => count_3 += 1,
                _ => panic!("Unexpected value"),
            }
        }
        assert_eq!(count_1, 3);
        assert_eq!(count_2, 3);
        assert_eq!(count_3, 3);
    }

    #[test]
    fn test_all_variants_produce_same_result() {
        let input = ArrayMtPerS::from_vec(vec![
            Mutex::new(6), Mutex::new(2), Mutex::new(8), Mutex::new(1), Mutex::new(9), 
            Mutex::new(3), Mutex::new(7), Mutex::new(4), Mutex::new(5)
        ]);
        
        let result_first = quicksort_pivot_first(&input);
        let result_median = quicksort_pivot_median_of_three(&input);
        let result_random = quicksort_pivot_random(&input);
        
        // All should have same length
        assert_eq!(result_first.length(), 9);
        assert_eq!(result_median.length(), 9);
        assert_eq!(result_random.length(), 9);
        
        // All should be sorted
        for i in 0..9 {
            assert_eq!(*result_first.nth(i).lock().unwrap(), i + 1);
            assert_eq!(*result_median.nth(i).lock().unwrap(), i + 1);
            assert_eq!(*result_random.nth(i).lock().unwrap(), i + 1);
        }
    }

    #[test]
    fn test_large_input_multithreaded() {
        // Test with larger input to ensure multithreading works
        let large_input: Vec<Mutex<i32>> = (0..1000).rev().map(|x| Mutex::new(x)).collect();
        let input = ArrayMtPerS::from_vec(large_input);
        
        let result = quicksort_pivot_random(&input);
        assert_eq!(result.length(), 1000);
        
        // Verify sorted order
        for i in 0..1000 {
            assert_eq!(*result.nth(i).lock().unwrap(), i as i32);
        }
    }
}
