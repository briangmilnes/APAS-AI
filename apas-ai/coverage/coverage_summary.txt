info: cargo-llvm-cov currently setting cfg(coverage); you can opt-out it by passing --no-cfg-coverage
   Compiling apas-ai v0.1.0 (/home/milnes/APASVERUS/APAS-AI/apas-ai)
warning: comparison is useless due to type limits
   --> tests/Chap49/TestMinEditDistMtEph.rs:166:13
    |
166 |     assert!(med.memo_size() >= 0);
    |             ^^^^^^^^^^^^^^^^^^^^
    |
    = note: `#[warn(unused_comparisons)]` on by default

warning: unused `Result` that must be used
   --> tests/Chap49/TestMinEditDistMtEph.rs:233:9
    |
233 |         source_mut.set(0, 99);
    |         ^^^^^^^^^^^^^^^^^^^^^
    |
    = note: this `Result` may be an `Err` variant, which should be handled
    = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
    |
233 |         let _ = source_mut.set(0, 99);
    |         +++++++

warning: unused `Result` that must be used
   --> tests/Chap49/TestMinEditDistMtEph.rs:248:9
    |
248 |         target_mut.set(2, 77);
    |         ^^^^^^^^^^^^^^^^^^^^^
    |
    = note: this `Result` may be an `Err` variant, which should be handled
help: use `let _ = ...` to ignore the resulting value
    |
248 |         let _ = target_mut.set(2, 77);
    |         +++++++

warning: `apas-ai` (test "TestMinEditDistMtEph") generated 3 warnings
warning: variable does not need to be mutable
   --> tests/Chap50/TestOptBinSearchTreeStEph.rs:347:9
    |
347 |     let mut obst = OBSTStEphLit!(keys: [10, 20,], probs: [0.4, 0.6,]);
    |         ----^^^^
    |         |
    |         help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` on by default

warning: `apas-ai` (test "TestOptBinSearchTreeStEph") generated 1 warning (run `cargo fix --test "TestOptBinSearchTreeStEph"` to apply 1 suggestion)
warning: comparison is useless due to type limits
  --> tests/Chap50/TestOptBinSearchTreeStPer.rs:97:13
   |
97 |     assert!(obst.memo_size() >= 0);
   |             ^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_comparisons)]` on by default

warning: `apas-ai` (test "TestOptBinSearchTreeStPer") generated 1 warning
warning: unused `Result` that must be used
   --> tests/Chap49/TestMinEditDistStEph.rs:348:9
    |
348 |         source_mut.set(0, 99);
    |         ^^^^^^^^^^^^^^^^^^^^^
    |
    = note: this `Result` may be an `Err` variant, which should be handled
    = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
    |
348 |         let _ = source_mut.set(0, 99);
    |         +++++++

warning: unused `Result` that must be used
   --> tests/Chap49/TestMinEditDistStEph.rs:363:9
    |
363 |         target_mut.set(2, 77);
    |         ^^^^^^^^^^^^^^^^^^^^^
    |
    = note: this `Result` may be an `Err` variant, which should be handled
help: use `let _ = ...` to ignore the resulting value
    |
363 |         let _ = target_mut.set(2, 77);
    |         +++++++

warning: `apas-ai` (test "TestMinEditDistStEph") generated 2 warnings
    Finished `test` profile [unoptimized + debuginfo] target(s) in 28.39s
     Running unittests src/lib.rs (target/llvm-cov-target/debug/deps/apas_ai-c8488b0e3543c32e)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/llvm-cov-target/debug/deps/apas_ai-27eecfe61906a414)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap37/TestAVLTreeSeq.rs (target/llvm-cov-target/debug/deps/TestAVLTreeSeq-b1dd502a690e680c)

running 25 tests
test TestAVLTreeSeq::test_avltreeseq_empty_constructor ... ok
test TestAVLTreeSeq::test_avltreeseq_empty_operations_comprehensive ... ok
test TestAVLTreeSeq::test_avltreeseq_length_method ... ok
test TestAVLTreeSeq::test_avltreeseq_equality_comparison ... ok
test TestAVLTreeSeq::test_avltreeseq_nth_method ... ok
test TestAVLTreeSeq::test_avltreeseq_new_constructor ... ok
test TestAVLTreeSeq::test_avltreeseq_nth_panic_empty - should panic ... ok
test TestAVLTreeSeq::test_avltreeseq_nth_panic_outofbounds - should panic ... ok
test TestAVLTreeSeq::test_avltreeseq_predicates ... ok
test TestAVLTreeSeq::test_avltreeseq_set_method ... ok
test TestAVLTreeSeq::test_avltreeseq_set_out_of_bounds_error ... ok
test TestAVLTreeSeq::test_avltreeseq_single_element_boundary ... ok
test TestAVLTreeSeq::test_avltreeseq_singleton_constructor ... ok
test TestAVLTreeSeq::test_avltreeseq_subseq_copy ... ok
test TestAVLTreeSeq::test_avltreeseq_zero_length_operations ... ok
test TestAVLTreeSeq::test_contains_value ... ok
test TestAVLTreeSeq::test_delete_value ... ok
test TestAVLTreeSeq::test_from_vec ... ok
test TestAVLTreeSeq::test_insert_value ... ok
test TestAVLTreeSeq::test_is_tree_empty ... ok
test TestAVLTreeSeq::test_new_root ... ok
test TestAVLTreeSeq::test_push_back ... ok
test TestAVLTreeSeq::test_to_arrayseq ... ok
test TestAVLTreeSeq::test_update ... ok
test TestAVLTreeSeq::test_values_in_order ... ok

test result: ok. 25 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap37/TestAVLTreeSeqMtPer.rs (target/llvm-cov-target/debug/deps/TestAVLTreeSeqMtPer-b78ce0134ff028f1)

running 19 tests
test test_clone ... ok
test test_empty_subseq ... ok
test test_empty ... ok
test test_eq ... ok
test test_isempty ... ok
test test_from_vec ... ok
test test_issingleton ... ok
test test_iter ... ok
test test_large_sequence ... ok
test test_length ... ok
test test_multiple_sets ... ok
test test_new ... ok
test test_nth ... ok
test test_set ... ok
test test_set_boundary ... ok
test test_singleton ... ok
test test_persistence ... ok
test test_subseq_copy ... ok
test test_values_in_order ... ok

test result: ok. 19 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap37/TestAVLTreeSeqStEph18.rs (target/llvm-cov-target/debug/deps/TestAVLTreeSeqStEph18-06821168ed2d17f0)

running 4 tests
test test_map_increment ... ok
test test_append_union ... ok
test test_filter_even ... ok
test test_tabulate_inorder ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap37/TestAVLTreeSeqStEphChap37.rs (target/llvm-cov-target/debug/deps/TestAVLTreeSeqStEphChap37-68638e98638a442a)

running 18 tests
test test_avl_contains_value ... ok
test test_avl_delete_value ... ok
test test_avl_empty_constructor ... ok
test test_avl_from_vec_constructor ... ok
test test_avl_ephemeral_basic ... ok
test test_avl_insert_value ... ok
test test_avl_equality ... ok
test test_avl_iterator ... ok
test test_avl_macro_literal ... ok
test test_avl_large_tree_operations ... ok
test test_avl_push_back ... ok
test test_avl_nth_out_of_bounds_panics - should panic ... ok
test test_avl_set_method ... ok
test test_avl_singleton_constructor ... ok
test test_avl_stress_operations ... ok
test test_avl_subseq_copy ... ok
test test_avl_to_arrayseq ... ok
test test_avl_update_method ... ok

test result: ok. 18 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap37/TestAVLTreeSeqStEphChap37_Advanced.rs (target/llvm-cov-target/debug/deps/TestAVLTreeSeqStEphChap37_Advanced-efcd6b1c3be67d3f)

running 3 tests
test test_select_and_append ... ok
test test_tabulate_and_map ... ok
test test_deflate_and_filter ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap37/TestAVLTreeSeqStPer.rs (target/llvm-cov-target/debug/deps/TestAVLTreeSeqStPer-8768316ce207d023)

running 15 tests
test test_avl_empty_and_singleton_edge_cases ... ok
test test_avl_equality_and_debug ... ok
test test_avl_large_tree_balancing ... ok
test test_avl_left_heavy_rebalancing ... ok
test test_avl_left_right_rotation ... ok
test test_avl_right_heavy_rebalancing ... ok
test test_avl_nth_out_of_bounds_panics - should panic ... ok
test test_avl_right_left_rotation ... ok
test test_avl_sequential_modifications ... ok
test test_avl_set_out_of_bounds_error ... ok
test test_avl_stress_balancing ... ok
test test_avl_subseq_balancing ... ok
test test_avl_to_arrayseq_conversion ... ok
test test_iterator_inorder_values ... ok
test test_persistent_set_does_not_mutate ... ok

test result: ok. 15 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap37/TestAVLTreeSeqStPer18.rs (target/llvm-cov-target/debug/deps/TestAVLTreeSeqStPerChap18-272e2bd97d7a9b2d)

running 4 tests
test test_filter_even ... ok
test test_map_increment ... ok
test test_append_union ... ok
test test_tabulate_inorder ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap37/TestAVLTreeSeqStPer19.rs (target/llvm-cov-target/debug/deps/TestAVLTreeSeqStPerChap19-d2783c35f93476f6)

running 3 tests
test test_deflate_and_filter_ch19 ... ok
test test_tabulate_and_map_ch19 ... ok
test test_select_and_append_ch19 ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap41/TestAVLTreeSetMtEph.rs (target/llvm-cov-target/debug/deps/TestAVLTreeSetMtEph-40a2a5d84abe6d7b)

running 14 tests
test tests_avl_tree_set_mt_eph::test_avltreesetmtephlit_macro_functionality ... ok
test tests_avl_tree_set_mt_eph::test_clone ... ok
test tests_avl_tree_set_mt_eph::test_delete ... ok
test tests_avl_tree_set_mt_eph::test_empty ... ok
test tests_avl_tree_set_mt_eph::test_from_seq ... ok
test tests_avl_tree_set_mt_eph::test_insert_find ... ok
test tests_avl_tree_set_mt_eph::test_singleton ... ok
test tests_avl_tree_set_mt_eph::test_union_small ... ok
test tests_avl_tree_set_mt_eph::test_difference ... ok
test tests_avl_tree_set_mt_eph::test_filter_small ... ok
test tests_avl_tree_set_mt_eph::test_intersection_small ... ok
test tests_avl_tree_set_mt_eph::test_filter_large_parallel ... ok
test tests_avl_tree_set_mt_eph::test_intersection_large_parallel ... ok
test tests_avl_tree_set_mt_eph::test_union_large_parallel ... ok

test result: ok. 14 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 18.82s

     Running tests/Chap41/TestAVLTreeSetMtPer.rs (target/llvm-cov-target/debug/deps/TestAVLTreeSetMtPer-bcf6247d99956456)

running 20 tests
test test_empty_set ... ok
test test_duplicate_insert ... ok
test test_clone ... ok
test test_difference_extended ... ok
test test_singleton_set ... ok
test test_delete_operation ... ok
test test_delete ... ok
test test_intersection_disjoint ... ok
test test_avltreesetmtperlit_macro_type_safety ... ok
test test_insert ... ok
test test_union_empty ... ok
test test_difference ... ok
test test_persistence_delete ... ok
test test_union_extended ... ok
test test_intersection ... ok
test test_negative_numbers ... ok
test test_intersection_extended ... ok
test test_filter ... ok
test test_union ... ok
test test_large_set ... ok

test result: ok. 20 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.26s

     Running tests/Chap41/TestAVLTreeSetStEph.rs (target/llvm-cov-target/debug/deps/TestAVLTreeSetStEph-0d14f8244dcedea7)

running 9 tests
test test_avl_tree_set_basic_operations ... ok
test test_avl_tree_set_macro ... ok
test test_avl_tree_set_ordering ... ok
test test_avl_tree_set_filter ... ok
test test_avl_tree_set_from_seq ... ok
test test_avl_tree_set_bulk_operations ... ok
test test_avl_tree_set_to_seq ... ok
test test_avltreesetstephlit_macro_functionality ... ok
test test_example_41_1_avl_cases ... ok

test result: ok. 9 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap41/TestAVLTreeSetStPer.rs (target/llvm-cov-target/debug/deps/TestAVLTreeSetStPer-dac359c3ce6d9ef6)

running 8 tests
test test_avl_tree_set_per_basic_operations ... ok
test test_avl_tree_set_per_bulk_operations ... ok
test test_avl_tree_set_per_filter ... ok
test test_avl_tree_set_per_macro ... ok
test test_avl_tree_set_per_from_seq ... ok
test test_avl_tree_set_per_persistence ... ok
test test_avl_tree_set_per_to_seq ... ok
test test_avltreesetstperlit_macro_functionality ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap52/TestAdjMatrixGraphStEph.rs (target/llvm-cov-target/debug/deps/TestAdjMatrixGraphStEph-22ca430339411874)

running 10 tests
test test_complete_graph ... ok
test test_complement ... ok
test test_empty_graph ... ok
test test_has_edge ... ok
test test_new ... ok
test test_out_degree ... ok
test test_num_edges ... ok
test test_out_neighbors ... ok
test test_self_loop ... ok
test test_set_edge ... ok

test result: ok. 10 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap52/TestAdjMatrixGraphStPer.rs (target/llvm-cov-target/debug/deps/TestAdjMatrixGraphStPer-27bb34e3d67f41d5)

running 8 tests
test test_complement ... ok
test test_new ... ok
test test_out_neighbors ... ok
test test_out_degree ... ok
test test_has_edge ... ok
test test_num_edges ... ok
test test_persistent_semantics ... ok
test test_set_edge ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap52/TestAdjSeqGraphStEph.rs (target/llvm-cov-target/debug/deps/TestAdjSeqGraphStEph-9dc1f7e5077060cb)

running 9 tests
test test_has_edge ... ok
test test_empty_graph ... ok
test test_new ... ok
test test_num_edges ... ok
test test_out_degree ... ok
test test_out_neighbors ... ok
test test_remove_edge ... ok
test test_self_loop ... ok
test test_set_edge ... ok

test result: ok. 9 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap52/TestAdjSeqGraphStPer.rs (target/llvm-cov-target/debug/deps/TestAdjSeqGraphStPer-7fc76c930e8b3ddc)

running 9 tests
test test_has_edge ... ok
test test_delete_edge ... ok
test test_num_edges ... ok
test test_new ... ok
test test_empty_graph ... ok
test test_insert_edge ... ok
test test_persistent_semantics ... ok
test test_out_neighbors ... ok
test test_out_degree ... ok

test result: ok. 9 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap52/TestAdjTableGraphMtPer.rs (target/llvm-cov-target/debug/deps/TestAdjTableGraphMtPer-12911e29484ea9a1)

running 10 tests
test test_clone ... ok
test test_empty ... ok
test test_insert_vertex ... ok
test test_delete_vertex ... ok
test test_self_loop ... ok
test test_insert_edge ... ok
test test_delete_edge ... ok
test test_persistence ... ok
test test_out_degree ... ok
test test_out_neighbors ... ok

test result: ok. 10 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap52/TestAdjTableGraphStEph.rs (target/llvm-cov-target/debug/deps/TestAdjTableGraphStEph-0c291d4856020e42)

running 10 tests
test test_delete_edge ... ok
test test_clone ... ok
test test_empty ... ok
test test_delete_vertex ... ok
test test_insert_edge ... ok
test test_insert_vertex ... ok
test test_out_degree ... ok
test test_out_neighbors ... ok
test test_self_loop ... ok
test test_vertices ... ok

test result: ok. 10 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap52/TestAdjTableGraphStPer.rs (target/llvm-cov-target/debug/deps/TestAdjTableGraphStPer-0159273300f0bbc0)

running 15 tests
test test_delete_edge_nonexistent ... ok
test test_empty ... ok
test test_delete_edge ... ok
test test_complex_graph ... ok
test test_delete_vertex ... ok
test test_from_table ... ok
test test_has_edge ... ok
test test_insert_edge ... ok
test test_insert_edge_creates_vertices ... ok
test test_insert_vertex ... ok
test test_num_vertices ... ok
test test_num_edges ... ok
test test_out_degree ... ok
test test_out_neighbors ... ok
test test_vertices ... ok

test result: ok. 15 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap47/TestAdvancedDoubleHashing.rs (target/llvm-cov-target/debug/deps/TestAdvancedDoubleHashing-4cf4d00c7f05d420)

running 17 tests
test test_configuration_optimality ... ok
test test_configuration_validation ... ok
test test_double_hashing_validation ... ok
test test_double_hashing_quality_analysis ... ok
test test_entry_enum ... ok
test test_comprehensive_double_hashing ... ok
test test_example_double_hashing_analysis ... ok
test test_example_probe_sequence_analysis ... ok
test test_flat_hash_table_integration ... ok
test test_gcd_computation ... ok
test test_generate_valid_h2_values ... ok
test test_hash_value_generation ... ok
test test_probe_count_estimation ... ok
test test_probe_sequence_generation ... ok
test test_probe_sequence_period ... ok
test test_relative_prime_validation ... ok
test test_strategy_creation ... ok

test result: ok. 17 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap47/TestAdvancedLinearProbing.rs (target/llvm-cov-target/debug/deps/TestAdvancedLinearProbing-ae501ca0f4d38cbf)

running 18 tests
test test_advanced_linear_probing_without_clustering ... ok
test test_clustering_problematic_detection ... ok
test test_advanced_linear_probing_creation ... ok
test test_linear_probing_deterministic ... ok
test test_example_primary_clustering_analysis ... ok
test test_linear_probing_different_keys ... ok
test test_linear_probing_edge_cases ... ok
test test_linear_probing_sequence ... ok
test test_linear_probing_with_different_table_sizes ... ok
test test_linear_probing_wraparound ... ok
test test_primary_clustering_analysis_disabled ... ok
test test_primary_clustering_analysis_empty_table ... ok
test test_probe_count_estimation_edge_cases ... ok
test test_primary_clustering_metrics_display ... ok
test test_probe_count_estimation_full_table ... ok
test test_probe_count_estimation_high_load_factor ... ok
test test_probe_count_estimation_low_load_factor ... ok
test test_probe_count_estimation_moderate_load_factor ... ok

test result: ok. 18 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap47/TestAdvancedQuadraticProbing.rs (target/llvm-cov-target/debug/deps/TestAdvancedQuadraticProbing-a43cb75108927f25)

running 28 tests
test test_advanced_quadratic_probing_minimal ... ok
test test_advanced_quadratic_probing_with_coefficients ... ok
test test_advanced_quadratic_probing_creation ... ok
test test_is_secondary_clustering_problematic ... ok
test test_example_secondary_clustering_analysis ... ok
test test_prime_validator_is_prime ... ok
test test_prime_validator_next_prime ... ok
test test_example_prime_vs_composite_table_size ... ok
test test_prime_validator_validate_quadratic_params_composite_table ... ok
test test_prime_validator_validate_quadratic_params_not_coprime ... ok
test test_prime_validator_validate_quadratic_params_prime_table ... ok
test test_prime_validator_validate_quadratic_params_zero_c2 ... ok
test test_probe_count_estimation_edge_cases ... ok
test test_probe_count_estimation_full_table ... ok
test test_probe_count_estimation_high_load_factor ... ok
test test_probe_count_estimation_low_load_factor ... ok
test test_probe_count_estimation_moderate_load_factor ... ok
test test_quadratic_probing_different_coefficients ... ok
test test_quadratic_probing_edge_cases ... ok
test test_quadratic_probing_sequence ... ok
test test_recommend_table_size ... ok
test test_recommend_table_size_disabled ... ok
test test_secondary_clustering_analysis_disabled ... ok
test test_secondary_clustering_metrics_display ... ok
test test_validate_configuration_composite_table ... ok
test test_secondary_clustering_analysis_empty_table ... ok
test test_validate_configuration_disabled ... ok
test test_validate_configuration_prime_table ... ok

test result: ok. 28 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap21/TestAlgorithm21_6.rs (target/llvm-cov-target/debug/deps/TestAlgorithm21_6-21c42e99daeadef2)

running 12 tests
test test_prime_sieve_edge_cases ... ok
test test_prime_sieve_n_10 ... ok
test test_prime_sieve_n_3 ... ok
test test_prime_sieve_n_20 ... ok
test test_prime_sieve_n_30 ... ok
test test_prime_sieve_small_n ... ok
test test_prime_sieve_specific_ranges ... ok
test test_prime_sieve_ordering ... ok
test test_prime_sieve_no_duplicates ... ok
test test_prime_sieve_n_50 ... ok
test test_prime_sieve_n_100 ... ok
test test_prime_sieve_larger_input ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap21/TestAlgorithm_21_1.rs (target/llvm-cov-target/debug/deps/TestAlgorithm_21_1-b6308db2f0668a3c)

running 5 tests
test test_points2d_iterator_in_order ... ok
test test_points2d_n1_empty ... ok
test test_points2d_debug_shape ... ok
test test_points2d_n2_basic_values ... ok
test test_points2d_n3_example ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap21/TestAlgorithm_21_2.rs (target/llvm-cov-target/debug/deps/TestAlgorithm_21_2-05664f204b10bc46)

running 5 tests
test test_points3d_tab_flat_n0_empty ... ok
test test_points3d_tab_flat_debug_shape ... ok
test test_points3d_tab_flat_n1_single ... ok
test test_points3d_tab_flat_iterator_order ... ok
test test_points3d_tab_flat_n2_values_and_order ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap21/TestAlgorithm_21_5.rs (target/llvm-cov-target/debug/deps/TestAlgorithm_21_5-87ae27637b9bcd7e)

running 3 tests
test test_primes_bf_debug_shape ... ok
test test_primes_bf_edge_cases ... ok
test test_primes_bf_small ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap21/TestAlgorithm_21_6.rs (target/llvm-cov-target/debug/deps/TestAlgorithm_21_6-062923c4843eb389)

running 3 tests
test test_prime_sieve_n2_empty ... ok
test test_prime_sieve_small ... ok
test test_prime_sieve_debug_shape ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap56/TestAllPairsResultStEphFloat.rs (target/llvm-cov-target/debug/deps/TestAllPairsResultStEphFloat-92c3243e634a6794)

running 5 tests
test TestAllPairsResultStEphFloat::test_extract_path ... ok
test TestAllPairsResultStEphFloat::test_new ... ok
test TestAllPairsResultStEphFloat::test_extract_path_unreachable ... ok
test TestAllPairsResultStEphFloat::test_set_distance ... ok
test TestAllPairsResultStEphFloat::test_set_predecessor ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap56/TestAllPairsResultStEphInt.rs (target/llvm-cov-target/debug/deps/TestAllPairsResultStEphInt-0e18bffc8a44bf5f)

running 5 tests
test TestAllPairsResultStEphInt::test_extract_path_unreachable ... ok
test TestAllPairsResultStEphInt::test_new ... ok
test TestAllPairsResultStEphInt::test_extract_path ... ok
test TestAllPairsResultStEphInt::test_set_distance ... ok
test TestAllPairsResultStEphInt::test_set_predecessor ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap56/TestAllPairsResultStPerFloat.rs (target/llvm-cov-target/debug/deps/TestAllPairsResultStPerFloat-d45f086e8c12d944)

running 5 tests
test TestAllPairsResultStPerFloat::test_set_distance ... ok
test TestAllPairsResultStPerFloat::test_new ... ok
test TestAllPairsResultStPerFloat::test_set_predecessor ... ok
test TestAllPairsResultStPerFloat::test_extract_path ... ok
test TestAllPairsResultStPerFloat::test_extract_path_unreachable ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap56/TestAllPairsResultStPerInt.rs (target/llvm-cov-target/debug/deps/TestAllPairsResultStPerInt-4300ddf5462106b4)

running 5 tests
test TestAllPairsResultStPerInt::test_extract_path_unreachable ... ok
test TestAllPairsResultStPerInt::test_new ... ok
test TestAllPairsResultStPerInt::test_extract_path ... ok
test TestAllPairsResultStPerInt::test_set_distance ... ok
test TestAllPairsResultStPerInt::test_set_predecessor ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap18/TestArraySeqMacro.rs (target/llvm-cov-target/debug/deps/TestArraySeqMacro-2b2e7c6b2b833c46)

running 7 tests
test arrayseq_subseq_append_filter_flatten ... ok
test arrayseq_tabulate_and_map_work ... ok
test arrayseq_collect_iterate_reduce_scan ... ok
test arrayseq_update_and_inject_preserve_original ... ok
test arrayseqs_empty_macro ... ok
test arrayseqs_literal_macro_keeps_order ... ok
test arrayseqs_repeat_macro_clones_element ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap19/TestArraySeqMtEph.rs (target/llvm-cov-target/debug/deps/TestArraySeqMtEph-fef73640919de5aa)

running 29 tests
test test_append_select ... ok
test test_arrayseq_mteph_append_and_map ... ok
test test_arrayseq_mteph_basic_ops ... ok
test test_arrayseqmteph_trait_append ... ok
test test_arrayseqmteph_trait_flatten ... ok
test test_arrayseqmteph_trait_iterate ... ok
test test_arrayseqmteph_trait_length ... ok
test test_arrayseqmteph_trait_map ... ok
test test_arrayseqmteph_trait_new ... ok
test test_arrayseqmteph_trait_empty ... ok
test test_arrayseqmteph_trait_nth_cloned ... ok
test test_arrayseqmteph_trait_scan ... ok
test test_arrayseqmteph_trait_subseq_copy ... ok
test test_arrayseqmteph_trait_singleton ... ok
test test_arrayseqmteph_trait_tabulate ... ok
test test_deflate ... ok
test test_empty ... ok
test test_new ... ok
test test_iterate ... ok
test test_update ... ok
test test_tabulate ... ok
test test_flatten ... ok
test test_scan ... ok
test test_arrayseqmteph_trait_filter ... ok
test test_select ... ok
test test_singleton ... ok
test test_arrayseqmteph_trait_reduce ... ok
test test_reduce ... ok
test test_filter ... ok

test result: ok. 29 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap18/TestArraySeqMtEphChap18.rs (target/llvm-cov-target/debug/deps/TestArraySeqMtEphChap18-980d958130a4eb9d)

running 20 tests
test test_clone_mt_eph ... ok
test test_append ... ok
test test_collect_mt_eph ... ok
test test_empty_and_singleton ... ok
test test_display_mt_eph ... ok
test test_filter ... ok
test test_flatten ... ok
test test_inject ... ok
test test_iter_cloned ... ok
test test_iterate ... ok
test test_new_and_set ... ok
test test_ninject ... ok
test test_partial_eq_mt_eph ... ok
test test_scan ... ok
test test_tabulate_basic ... ok
test test_subseq_copy ... ok
test test_to_vec ... ok
test test_update ... ok
test test_reduce_parallel ... ok
test test_map_parallel ... ok

test result: ok. 20 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.25s

     Running tests/Chap19/TestArraySeqMtEphSlice.rs (target/llvm-cov-target/debug/deps/TestArraySeqMtEphSlice-3927443eea77cadc)

running 44 tests
test test_arrayseqmtephslice_clamp_subrange ... ok
test test_arrayseqmtephslice_append ... ok
test test_arrayseqmtephslice_complex_operations ... ok
test test_arrayseqmtephslice_clone ... ok
test test_arrayseqmtephslice_append_select ... ok
test test_arrayseqmtephslice_edge_cases ... ok
test test_arrayseqmtephslice_empty ... ok
test test_arrayseqmtephslice_eq ... ok
test test_arrayseqmtephslice_flatten ... ok
test test_arrayseqmtephslice_fmt_debug ... ok
test test_arrayseqmtephslice_fmt_display ... ok
test test_arrayseqmtephslice_from_box ... ok
test test_arrayseqmtephslice_concurrent_access ... ok
test test_arrayseqmtephslice_concurrent_updates ... ok
test test_arrayseqmtephslice_from_vec ... ok
test test_arrayseqmtephslice_inject ... ok
test test_arrayseqmtephslice_is_empty ... ok
test test_arrayseqmtephslice_is_singleton ... ok
test test_arrayseqmtephslice_iterate ... ok
test test_arrayseqmtephslice_len ... ok
test test_arrayseqmtephslice_large_sequence ... ok
test test_arrayseqmtephslice_new ... ok
test test_arrayseqmtephslice_ninject ... ok
test test_arrayseqmtephslice_predicates ... ok
test test_arrayseqmtephslice_scan ... ok
test test_arrayseqmtephslice_set ... ok
test test_arrayseqmtephslice_tabulate ... ok
test test_arrayseqmtephslice_trait_empty ... ok
test test_arrayseqmtephslice_to_vec ... ok
test test_arrayseqmtephslice_trait_length ... ok
test test_arrayseqmtephslice_trait_new ... ok
test test_arrayseqmtephslice_trait_tabulate ... ok
test test_arrayseqmtephslice_type_checks ... ok
test test_arrayseqmtephslice_update ... ok
test test_arrayseqmtephslice_slice ... ok
test test_arrayseqmtephslice_with_exclusive ... ok
test test_arrayseqmtephsliceslit_macro_functionality ... ok
test test_arrayseqmtephslice_singleton ... ok
test test_arrayseqmtephslice_subseq_copy ... ok
test test_arrayseqmtephslice_map ... ok
test test_arrayseqmtephslice_trait_map ... ok
test test_arrayseqmtephslice_filter ... ok
test test_arrayseqmtephslice_reduce ... ok
test test_arrayseqmtephslice_trait_filter ... ok

test result: ok. 44 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap19/TestArraySeqMtPer18.rs (target/llvm-cov-target/debug/deps/TestArraySeqMtPer18-9a082d8f3f89846e)

running 8 tests
test test_tabulate_basic ... ok
test test_tabulate_empty ... ok
test test_tabulate_fibonacci ... ok
test test_tabulate_boolean ... ok
test test_tabulate_single ... ok
test test_tabulate_large ... ok
test test_tabulate_squares ... ok
test test_tabulate_string ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap18/TestArraySeqMtPerChap18.rs (target/llvm-cov-target/debug/deps/TestArraySeqMtPerChap18-8fff66db822ae96d)

running 48 tests
test test_clone ... ok
test test_append_basic ... ok
test test_display ... ok
test test_append_empty ... ok
test test_collect_basic ... ok
test test_empty ... ok
test test_filter_basic ... ok
test test_filter_none_match ... ok
test test_flatten_basic ... ok
test test_flatten_empty ... ok
test test_from_vec ... ok
test test_inject_first_wins ... ok
test test_into_iterator_owned ... ok
test test_into_iterator_ref ... ok
test test_isEmpty_trait ... ok
test test_isSingleton_trait ... ok
test test_is_empty ... ok
test test_iter ... ok
test test_is_singleton ... ok
test test_iteratePrefixes_basic ... ok
test test_iterate_product ... ok
test test_iterate_sum ... ok
test test_map_empty ... ok
test test_new ... ok
test test_ninject_basic ... ok
test test_ninject_duplicate_keys ... ok
test test_partial_eq ... ok
test test_reduce_empty ... ok
test test_reduce_single ... ok
test test_map_basic ... ok
test test_scan_basic ... ok
test test_set_basic ... ok
test test_set_out_of_bounds ... ok
test test_singleton ... ok
test test_subseq_copy ... ok
test test_subseq_edge_cases ... ok
test test_tabulate_basic ... ok
test test_large_sequence ... ok
test test_tabulate_large ... ok
test test_update_basic ... ok
test test_tabulate_boolean ... ok
test test_tabulate_string ... ok
test test_tabulate_fibonacci ... ok
test test_tabulate_squares ... ok
test test_tabulate_single ... ok
test test_update_out_of_bounds ... ok
test test_tabulate_empty ... ok
test test_reduce_sum ... ok

test result: ok. 48 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap19/TestArraySeqMtPerChap19.rs (target/llvm-cov-target/debug/deps/TestArraySeqMtPerChap19-7d039f9433c5fa55)

running 44 tests
test test_arrayseqmtper_atomic_write ... ok
test test_arrayseqmtper_trait_deflate ... ok
test test_arrayseqmtper_trait_append_select ... ok
test test_arrayseqmtper_collect ... ok
test test_arrayseqmtper_trait_append ... ok
test test_arrayseqmtper_trait_flatten ... ok
test test_arrayseqmtper_trait_empty ... ok
test test_arrayseqmtper_trait_iterate ... ok
test test_arrayseqmtper_trait_length ... ok
test test_arrayseqmtper_trait_new ... ok
test test_arrayseqmtper_trait_nth ... ok
test test_arrayseqmtper_trait_ninject ... ok
test test_arrayseqmtper_trait_singleton ... ok
test test_arrayseqmtper_trait_tabulate ... ok
test test_arrayseqmtper_trait_map ... ok
test test_arrayseqmtper_trait_filter ... ok
test test_arrayseqmtper_trait_select ... ok
test test_boolean_sequences ... ok
test test_arrayseqmtper_trait_scan ... ok
test test_display_format ... ok
test test_equality_and_debug ... ok
test test_empty ... ok
test test_concurrent_subseq_operations ... ok
test test_arrayseqmtper_trait_reduce ... ok
test test_from_vec ... ok
test test_iterators ... ok
test test_length_and_nth_basic ... ok
test test_concurrent_read_access ... ok
test test_macro_literals ... ok
test test_concurrent_iterator_access ... ok
test test_new_and_set ... ok
test test_concurrent_inject_operations ... ok
test test_sequence_basic ... ok
test test_singleton ... ok
test test_subseq_view ... ok
test test_atomic_operation_correctness_concurrent_reads ... ok
test test_atomic_operation_correctness_memory_ordering ... ok
test test_subseq ... ok
test test_string_sequences ... ok
test test_atomic_operation_correctness_inject_operations ... ok
test test_thread_safety_with_barrier ... ok
test test_race_condition_verification_concurrent_reads ... ok
test test_race_condition_verification_concurrent_inject_operations ... ok
test test_race_condition_verification_mixed_operations ... ok

test result: ok. 44 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap19/TestArraySeqMtPerChap19_Advanced.rs (target/llvm-cov-target/debug/deps/TestArraySeqMtPerChap19_Advanced-f09234751b6c6d76)

running 25 tests
test test_arraymtperslit_macro_functionality ... ok
test test_append_basic ... ok
test test_append_select ... ok
test test_inject_basic ... ok
test test_flatten_basic ... ok
test test_inject_empty_changes ... ok
test test_inject_conflicting_updates ... ok
test test_inject_empty_values ... ok
test test_inject_out_of_bounds ... ok
test test_inject_string_values ... ok
test test_isEmpty ... ok
test test_isSingleton ... ok
test test_iterate_basic ... ok
test test_filter_basic ... ok
test test_ninject_basic ... ok
test test_large_tabulate ... ok
test test_scan_basic ... ok
test test_map_basic ... ok
test test_tabulate_basic ... ok
test test_select ... ok
test test_update_single ... ok
test test_reduce_basic ... ok
test test_large_reduce ... ok
test test_parallel_map_large ... ok
test test_parallel_filter_large ... ok

test result: ok. 25 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s

     Running tests/Chap19/TestArraySeqStEph18.rs (target/llvm-cov-target/debug/deps/TestArraySeqStEph18-328b66dd8f31cafe)

running 14 tests
test test_collect_groups_by_key ... ok
test test_filter_even ... ok
test test_append ... ok
test test_flatten ... ok
test test_inject_conflicts_last_wins ... ok
test test_iterate_and_prefixes_and_reduce_and_scan ... ok
test test_iterate_prefixes_sum ... ok
test test_map_increment ... ok
test test_iterate_sum_basic ... ok
test test_ninject_conflicts_last_wins ... ok
test test_sequence_literals_and_append ... ok
test test_subseq ... ok
test test_tabulate_fibonacci ... ok
test test_update_sequence ... ok

test result: ok. 14 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap18/TestArraySeqStEphChap18.rs (target/llvm-cov-target/debug/deps/TestArraySeqStEphChap18-66fec351187754e0)

running 14 tests
test test_collect_groups_by_key ... ok
test test_append ... ok
test test_filter_even ... ok
test test_flatten ... ok
test test_inject_conflicts_last_wins ... ok
test test_iterate_and_prefixes_and_reduce_and_scan ... ok
test test_iterate_sum_basic ... ok
test test_iterate_prefixes_sum ... ok
test test_map_increment ... ok
test test_sequence_literals_and_append ... ok
test test_ninject_conflicts_last_wins ... ok
test test_subseq ... ok
test test_tabulate_fibonacci ... ok
test test_update_sequence ... ok

test result: ok. 14 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap19/TestArraySeqStEphChap19.rs (target/llvm-cov-target/debug/deps/TestArraySeqStEphChap19-cd39a1d69b8a659c)

running 23 tests
test test_arrayseqsteph_trait_append ... ok
test test_arrayseqsteph_trait_deflate ... ok
test test_arrayseqsteph_trait_empty ... ok
test test_arrayseqsteph_trait_append_select ... ok
test test_arrayseqsteph_trait_filter ... ok
test test_arrayseqsteph_trait_inject ... ok
test test_arrayseqsteph_trait_flatten ... ok
test test_arrayseqsteph_trait_iterate ... ok
test test_arrayseqsteph_trait_length ... ok
test test_arrayseqsteph_trait_map ... ok
test test_arrayseqsteph_trait_new ... ok
test test_arrayseqsteph_trait_nth ... ok
test test_arrayseqsteph_trait_reduce ... ok
test test_arrayseqsteph_trait_scan ... ok
test test_arrayseqsteph_trait_select ... ok
test test_arrayseqsteph_trait_singleton ... ok
test test_arrayseqsteph_trait_subseq_copy ... ok
test test_arrayseqsteph_trait_tabulate ... ok
test test_arrayseqsteph_trait_update ... ok
test test_arrayseqstephslit_macro_functionality ... ok
test test_ephemeral_arrayseq_basic ... ok
test test_iterators_collect ... ok
test test_ephemeral_ch18_map_append_filter ... ok

test result: ok. 23 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap19/TestArraySeqStEphChap19_Advanced.rs (target/llvm-cov-target/debug/deps/TestArraySeqStEphChap19_Advanced-c8bfa58fc08ab160)

running 24 tests
test test_append2 ... ok
test test_append2_equivalence ... ok
test test_append ... ok
test test_deflate_false ... ok
test test_append_with_empty ... ok
test test_deflate_true ... ok
test test_empty ... ok
test test_filter_empty_sequence ... ok
test test_filter_even_numbers ... ok
test test_filter_none ... ok
test test_flatten_ch19 ... ok
test test_isEmpty ... ok
test test_isSingleton ... ok
test test_iterate_concat ... ok
test test_iterate_sum ... ok
test test_map ... ok
test test_map_empty ... ok
test test_reduce_sum_basic_ch19 ... ok
test test_scan_sum_basic_ch19 ... ok
test test_select_boundary ... ok
test test_singleton ... ok
test test_subseq_basic ... ok
test test_update_in_bounds ... ok
test test_update_out_of_bounds ... ok

test result: ok. 24 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap18/TestArraySeqStEphMacro.rs (target/llvm-cov-target/debug/deps/TestArraySeqStEphMacro-0cb988981194096b)

running 9 tests
test arrayseq_steph_basic_macros ... ok
test test_arrayseqsteph_iter ... ok
test test_arrayseqsteph_iterator_boundaries ... ok
test test_arrayseqsteph_nth_panic_empty - should panic ... ok
test arrayseq_steph_full_pipeline ... ok
test test_arrayseqsteph_nth_panic_outofbounds - should panic ... ok
test test_arrayseqsteph_subseq_overflow_graceful ... ok
test test_arrayseqsteph_subseq_graceful ... ok
test test_arrayseqsteph_outofbounds_graceful ... ok

test result: ok. 9 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap19/TestArraySeqStPer18.rs (target/llvm-cov-target/debug/deps/TestArraySeqStPer18-f99f87bfaa9c0ef7)

running 13 tests
test test_append ... ok
test test_collect_groups_by_key ... ok
test test_filter_even ... ok
test test_flatten ... ok
test test_inject_and_ninject ... ok
test test_iterate_and_prefixes_and_reduce_and_scan ... ok
test test_iterate_prefixes_sum ... ok
test test_iterate_sum_basic ... ok
test test_map_increment ... ok
test test_sequence_literals_and_append ... ok
test test_subseq ... ok
test test_tabulate_fibonacci ... ok
test test_update_sequence ... ok

test result: ok. 13 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap18/TestArraySeqStPerChap18.rs (target/llvm-cov-target/debug/deps/TestArraySeqStPerChap18-65dcc20435aebd01)

running 25 tests
test test_append ... ok
test test_arrayseqstper_inject_invalid_index ... ok
test test_arrayseqstper_empty_operations_comprehensive ... ok
test test_arrayseqstper_iterator_boundaries ... ok
test test_arrayseqstper_iter ... ok
test test_arrayseqstper_nth_out_of_bounds - should panic ... ok
test test_arrayseqstper_nth_panic_empty - should panic ... ok
test test_arrayseqstper_nth_panic_outofbounds - should panic ... ok
test test_arrayseqstper_single_element_boundary ... ok
test test_arrayseqstper_subseq_invalid_length ... ok
test test_arrayseqstper_subseq_invalid_start ... ok
test test_arrayseqstper_subseq_overflow_graceful ... ok
test test_arrayseqstper_zero_length_operations ... ok
test test_collect_groups_by_key ... ok
test test_filter_even ... ok
test test_flatten ... ok
test test_inject_and_ninject ... ok
test test_iterate_and_prefixes_and_reduce_and_scan ... ok
test test_iterate_prefixes_sum ... ok
test test_iterate_sum_basic ... ok
test test_map_increment ... ok
test test_sequence_literals_and_append ... ok
test test_subseq ... ok
test test_tabulate_fibonacci ... ok
test test_arrayseqstper_maximum_size_boundary ... ok

test result: ok. 25 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.02s

     Running tests/Chap19/TestArraySeqStPerChap19.rs (target/llvm-cov-target/debug/deps/TestArraySeqStPerChap19-d6096cdb658dd51e)

running 38 tests
test test_arrayseqstper_trait_append_select ... ok
test test_arrayseqstper_trait_append ... ok
test test_arrayseqstper_trait_flatten ... ok
test test_arrayseqstper_trait_empty ... ok
test test_arrayseqstper_trait_deflate ... ok
test test_arrayseqstper_trait_length ... ok
test test_arrayseqstper_trait_iterate ... ok
test test_arrayseqstper_trait_inject ... ok
test test_arrayseqstper_trait_map ... ok
test test_arrayseqstper_trait_filter ... ok
test test_arrayseqstper_trait_ninject ... ok
test test_arrayseqstper_trait_new ... ok
test test_arrayseqstper_trait_nth ... ok
test test_arrayseqstper_trait_reduce ... ok
test test_arrayseqstper_trait_scan ... ok
test test_arrayseqstper_trait_select ... ok
test test_arrayseqstper_trait_singleton ... ok
test test_arrayseqstper_trait_tabulate ... ok
test test_arrayseqstper_trait_update ... ok
test test_empty ... ok
test test_eq_vs_partial_eq_difference ... ok
test test_from_vec ... ok
test test_is_empty_and_is_singleton ... ok
test test_iterator_collects_in_order ... ok
test test_length_and_nth_basic ... ok
test test_new_set_persistent ... ok
test test_new_and_set ... ok
test test_nth_upper_bound_panics - should panic ... ok
test test_nth_on_empty_panics - should panic ... ok
test test_numbers_equal_is_equal ... ok
test test_ordering_strings_basic ... ok
test test_sequence_equality_natural_numbers ... ok
test test_sequence_equality_strings ... ok
test test_singleton ... ok
test test_ordering_numbers_basic ... ok
test test_strings_equal_is_equal ... ok
test test_subseq_trait_form_basic ... ok
test test_sequence_basic ... ok

test result: ok. 38 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap19/TestArraySeqStPerChap19_Advanced.rs (target/llvm-cov-target/debug/deps/TestArraySeqStPerChap19_Advanced-d2062f82b14b063c)

running 5 tests
test test_arrayseqstperslit_macro_functionality ... ok
test test_map_and_select_and_append ... ok
test test_deflate_and_filter ... ok
test test_iterate_reduce_scan_flatten ... ok
test test_inject_and_parallel ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap18/TestArraySeqStPerMacro.rs (target/llvm-cov-target/debug/deps/TestArraySeqStPerMacro-ea236ec68d11fca8)

running 4 tests
test arrayseq_stper_macro_empty ... ok
test arrayseq_stper_macro_literal ... ok
test arrayseq_stper_macro_repeat ... ok
test arrayseq_stper_operations ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap41/TestArraySetEnumMtEph.rs (target/llvm-cov-target/debug/deps/TestArraySetEnumMtEph-cccec0a70d648c86)

running 9 tests
test test_array_set_enum_mt_basic_operations ... ok
test test_array_set_enum_mt_bulk_operations ... ok
test test_array_set_enum_mt_from_seq ... ok
test test_array_set_enum_mt_macro ... ok
test test_array_set_enum_mt_to_seq ... ok
test test_array_set_enum_mt_universe_bounds ... ok
test test_arraysetenummtephlit_macro_type_safety ... ok
test test_array_set_enum_mt_thread_safety ... ok
test test_array_set_enum_mt_filter ... ok

test result: ok. 9 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap41/TestArraySetStEph.rs (target/llvm-cov-target/debug/deps/TestArraySetStEph-74f9ccf72c5ad94b)

running 10 tests
test test_array_set_basic_operations ... ok
test test_additional_operations ... ok
test test_array_set_bulk_operations ... ok
test test_array_set_filter ... ok
test test_array_set_from_seq ... ok
test test_array_set_macro ... ok
test test_array_set_to_seq ... ok
test test_arraysetstephlit_macro_functionality ... ok
test test_example_41_1_cases ... ok
test test_example_41_3_demonstration ... ok

test result: ok. 10 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap43/TestAugOrderedTableMtEph.rs (target/llvm-cov-target/debug/deps/TestAugOrderedTableMtEph-bea4682937580643)

running 31 tests
test test_collect_operation ... ok
test test_display_and_debug_multithreaded ... ok
test test_difference_operation ... ok
test test_delete_nonexistent ... ok
test test_filter_operation_multithreaded ... ok
test test_get_key_range ... ok
test test_empty_table ... ok
test test_insert_and_reduce_val ... ok
test test_domain_operation ... ok
test test_delete_operation ... ok
test test_intersection_operation_multithreaded ... ok
test test_macro_construction_multithreaded ... ok
test test_key_navigation ... ok
test test_ordering_operations_multithreaded ... ok
test test_map_operation_multithreaded ... ok
test test_reduce_operation_multithreaded ... ok
test test_rank_and_select ... ok
test test_singleton_table ... ok
test test_restrict_operation ... ok
test test_split_and_join_multithreaded ... ok
test test_split_rank_key ... ok
test test_string_concatenation_multithreaded ... ok
test test_subtract_operation ... ok
test test_union_operation_multithreaded ... ok
test test_tabulate_operation ... ok
test test_sum_reducer_multithreaded ... ok
test test_thread_safety_basic ... ok
test test_concurrent_reads ... ok
test test_complex_multithreaded_scenario ... ok
test test_qadsan_multithreaded_scenario ... ok
test test_parallel_range_reduction ... ok

test result: ok. 31 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.29s

     Running tests/Chap43/TestAugOrderedTableStEph.rs (target/llvm-cov-target/debug/deps/TestAugOrderedTableStEph-7de69b53aaa69609)

running 30 tests
test test_collect_operation ... ok
test test_delete_nonexistent ... ok
test test_domain_operation ... ok
test test_complex_qadsan_scenario ... ok
test test_difference_operation ... ok
test test_delete_and_reduce_val ... ok
test test_display_and_debug ... ok
test test_empty_table ... ok
test test_filter_operation ... ok
test test_get_key_range ... ok
test test_insert_and_reduce_val ... ok
test test_intersection_operation ... ok
test test_key_navigation ... ok
test test_macro_construction ... ok
test test_map_operation ... ok
test test_min_reducer ... ok
test test_mutable_operations ... ok
test test_ordering_operations ... ok
test test_qadsan_stock_scenario ... ok
test test_range_operations ... ok
test test_rank_and_select ... ok
test test_reduce_operation ... ok
test test_restrict_operation ... ok
test test_singleton_table ... ok
test test_split_and_join ... ok
test test_split_rank_key ... ok
test test_string_concatenation_reducer ... ok
test test_subtract_operation ... ok
test test_tabulate_operation ... ok
test test_union_operation ... ok

test result: ok. 30 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap43/TestAugOrderedTableStPer.rs (target/llvm-cov-target/debug/deps/TestAugOrderedTableStPer-4a458dc7cef8a74c)

running 26 tests
test test_collect_operation ... ok
test test_delete_and_reduce_val ... ok
test test_delete_nonexistent ... ok
test test_display_and_debug ... ok
test test_domain_operation ... ok
test test_empty_table ... ok
test test_complex_tramlaw_scenario ... ok
test test_difference_operation ... ok
test test_filter_operation ... ok
test test_get_key_range ... ok
test test_insert_and_reduce_val ... ok
test test_intersection_operation ... ok
test test_macro_construction ... ok
test test_map_operation ... ok
test test_max_reducer ... ok
test test_ordering_operations ... ok
test test_range_operations ... ok
test test_restrict_operation ... ok
test test_singleton_table ... ok
test test_split_and_join ... ok
test test_split_rank_key ... ok
test test_string_concatenation_reducer ... ok
test test_subtract_operation ... ok
test test_tabulate_operation ... ok
test test_tramlaw_sales_scenario ... ok
test test_union_operation ... ok

test result: ok. 26 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap54/TestBFSMtEph.rs (target/llvm-cov-target/debug/deps/TestBFSMtEph-cd459bbdc7fe2df4)

running 7 tests
test test_dag ... ok
test test_cycle ... ok
test test_empty_graph ... ok
test test_invalid_source ... ok
test test_single_vertex ... ok
test test_line_graph ... ok
test test_unreachable ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap54/TestBFSMtPer.rs (target/llvm-cov-target/debug/deps/TestBFSMtPer-f215f92dfbd70043)

running 7 tests
test test_empty_graph ... ok
test test_cycle ... ok
test test_dag ... ok
test test_invalid_source ... ok
test test_line_graph ... ok
test test_single_vertex ... ok
test test_unreachable ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap54/TestBFSStEph.rs (target/llvm-cov-target/debug/deps/TestBFSStEph-b068818e45f0c123)

running 7 tests
test test_empty_graph ... ok
test test_cycle ... ok
test test_invalid_source ... ok
test test_single_vertex ... ok
test test_dag ... ok
test test_line_graph ... ok
test test_unreachable ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap54/TestBFSStPer.rs (target/llvm-cov-target/debug/deps/TestBFSStPer-723f41a43b658a53)

running 7 tests
test test_cycle ... ok
test test_empty_graph ... ok
test test_invalid_source ... ok
test test_dag ... ok
test test_line_graph ... ok
test test_single_vertex ... ok
test test_unreachable ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap37/TestBSTAVLMtEph.rs (target/llvm-cov-target/debug/deps/TestBSTAVLMtEph-9868c40da9236f06)

running 13 tests
test test_contains ... ok
test test_bstavlmtephlit_macro_functionality ... ok
test test_avl_balancing ... ok
test test_default ... ok
test test_height ... ok
test test_duplicate_insert ... ok
test test_in_order_traversal ... ok
test test_insert_and_find ... ok
test test_is_empty ... ok
test test_minimum_maximum ... ok
test test_new_empty ... ok
test test_pre_order_traversal ... ok
test test_size ... ok

test result: ok. 13 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap37/TestBSTAVLStEph.rs (target/llvm-cov-target/debug/deps/TestBSTAVLStEph-5db4fd1dcefcd443)

running 16 tests
test avl_duplicate_insert_is_idempotent ... ok
test avl_insert_find_and_bounds ... ok
test test_bst_clone_functionality ... ok
test test_bst_avl_balancing_stress ... ok
test test_bst_contains_comprehensive ... ok
test test_bst_duplicate_handling ... ok
test test_bst_empty_constructor ... ok
test test_bst_default_trait ... ok
test test_bst_find_comprehensive ... ok
test test_bst_height_calculation ... ok
test test_bst_is_empty_predicate ... ok
test test_bst_minimum_maximum_edge_cases ... ok
test test_bst_pre_order_traversal ... ok
test test_bst_single_element ... ok
test test_bstavlstephlit_macro_functionality ... ok
test test_bst_large_tree_operations ... ok

test result: ok. 16 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap37/TestBSTBBAlphaMtEph.rs (target/llvm-cov-target/debug/deps/TestBSTBBAlphaMtEph-f24fb80e4ca89c7b)

running 13 tests
test test_contains ... ok
test test_balancing ... ok
test test_default ... ok
test test_bstbbalphamtephlit_macro_functionality ... ok
test test_duplicate_insert ... ok
test test_in_order_traversal ... ok
test test_insert_and_find ... ok
test test_is_empty ... ok
test test_minimum_maximum ... ok
test test_height ... ok
test test_new_empty ... ok
test test_pre_order_traversal ... ok
test test_size ... ok

test result: ok. 13 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap37/TestBSTBBAlphaStEph.rs (target/llvm-cov-target/debug/deps/TestBSTBBAlphaStEph-a503d69cd6b1c86c)

running 11 tests
test bbalpha_duplicate_insert_is_idempotent ... ok
test test_bstbbalphastephlit_macro_functionality ... ok
test test_contains_empty ... ok
test test_find ... ok
test test_empty ... ok
test test_maximum ... ok
test bbalpha_insert_find_balances ... ok
test test_negative_numbers ... ok
test test_singleton ... ok
test test_reverse_insert ... ok
test test_large_tree ... ok

test result: ok. 11 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap40/TestBSTKeyValueStEph.rs (target/llvm-cov-target/debug/deps/TestBSTKeyValueStEph-80d675666356a34c)

running 6 tests
test key_value_bst_basic_operations ... ok
test key_value_bst_collections ... ok
test key_value_bst_macro_literal ... ok
test key_value_bst_update_existing_key ... ok
test key_value_bst_string_keys ... ok
test key_value_bst_height_stays_reasonable ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap37/TestBSTMtEph.rs (target/llvm-cov-target/debug/deps/TestBSTMtEph-e0c1ca0f96a5aabc)

running 22 tests
test mt_all_variants_empty_operations ... ok
test mt_avl_basic_ops ... ok
test mt_all_variants_duplicate_handling ... ok
test mt_all_variants_single_element ... ok
test mt_avl_comprehensive_operations ... ok
test mt_bbalpha_comprehensive_operations ... ok
test mt_bbalpha_basic_ops ... ok
test mt_plain_basic_ops ... ok
test mt_plain_comprehensive_operations ... ok
test mt_concurrent_bbalpha_operations ... ok
test mt_rb_basic_ops ... ok
test mt_rb_comprehensive_operations ... ok
test mt_splay_basic_ops ... ok
test mt_splay_comprehensive_operations ... ok
test mt_concurrent_splay_access_patterns ... ok
test mt_treap_comprehensive_operations ... ok
test mt_treap_basic_ops ... ok
test mt_concurrent_plain_bst_operations ... ok
test mt_concurrent_avl_bst_operations ... ok
test mt_concurrent_treap_operations ... ok
test mt_all_variants_concurrent_stress ... ok
test mt_concurrent_rb_bst_stress ... ok

test result: ok. 22 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap38/TestBSTParaMtEph.rs (target/llvm-cov-target/debug/deps/TestBSTParaMtEph-a863489b7fd303ab)

running 16 tests
test para_basic_insert_find ... ok
test para_concurrent_expose_join_mid ... ok
test para_concurrent_insertions ... ok
test para_concurrent_delete_operations ... ok
test para_split_and_join_pair ... ok
test para_join_mid_expose_roundtrip ... ok
test para_concurrent_operations_stress ... ok
test para_concurrent_split_join ... ok
test para_union_and_delete ... ok
test para_intersect_and_difference ... ok
test para_filter_and_reduce ... ok
test para_concurrent_set_operations ... ok
test para_concurrent_filter_reduce ... ok
test para_filter_and_reduce_edge_cases ... ok
test para_union_large_balanced ... ok
test para_intersect_and_difference_large ... ok

test result: ok. 16 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.07s

     Running tests/Chap38/TestBSTParaStEph.rs (target/llvm-cov-target/debug/deps/TestBSTParaStEph-96c6fd250c98af22)

running 5 tests
test para_join_mid_expose_roundtrip ... ok
test para_split_and_join_pair ... ok
test para_basic_insert_find ... ok
test test_parambstlit_macro_functionality ... ok
test para_union_and_delete ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap39/TestBSTParaTreapMtEph.rs (target/llvm-cov-target/debug/deps/TestBSTParaTreapMtEph-553ee7ba591bab70)

running 28 tests
test test_duplicate_insert ... ok
test test_delete_nonexistent ... ok
test test_delete ... ok
test test_expose ... ok
test test_expose_with_priority ... ok
test test_insert ... ok
test test_find ... ok
test test_join_pair ... ok
test test_join_mid ... ok
test test_new ... ok
test test_filter_none ... ok
test test_difference_complete ... ok
test test_difference ... ok
test test_filter_all ... ok
test test_large_tree ... ok
test test_paramtreaplit_macro_functionality ... ok
test test_filter ... ok
test test_reduce_empty ... ok
test test_sequential_operations ... ok
test test_intersect_empty ... ok
test test_split_boundaries ... ok
test test_split_empty ... ok
test test_string_keys ... ok
test test_split ... ok
test test_intersect ... ok
test test_union ... ok
test test_reduce ... ok
test test_union_disjoint ... ok

test result: ok. 28 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s

     Running tests/Chap37/TestBSTPlainMtEph.rs (target/llvm-cov-target/debug/deps/TestBSTPlainMtEph-2851816b54e79a59)

running 10 tests
test test_bstplainmtephlit_macro_functionality ... ok
test test_height ... ok
test test_contains ... ok
test test_in_order_traversal ... ok
test test_duplicate_insert ... ok
test test_is_empty ... ok
test test_insert_and_find ... ok
test test_minimum_maximum ... ok
test test_new_empty ... ok
test test_size ... ok

test result: ok. 10 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap37/TestBSTPlainStEph.rs (target/llvm-cov-target/debug/deps/TestBSTPlainStEph-aabc8f4499a8a4bc)

running 10 tests
test test_contains ... ok
test test_duplicate_insert ... ok
test test_bstplainstephlit_macro_functionality ... ok
test test_height ... ok
test test_in_order_traversal ... ok
test test_insert_and_find ... ok
test test_is_empty ... ok
test test_minimum_maximum ... ok
test test_new_empty ... ok
test test_size ... ok

test result: ok. 10 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap37/TestBSTRBMtEph.rs (target/llvm-cov-target/debug/deps/TestBSTRBMtEph-ee577d3e5ac1b392)

running 13 tests
test test_bstrbmtephlit_macro_functionality ... ok
test test_contains ... ok
test test_default ... ok
test test_duplicate_insert ... ok
test test_height ... ok
test test_in_order_traversal ... ok
test test_insert_and_find ... ok
test test_is_empty ... ok
test test_minimum_maximum ... ok
test test_new_empty ... ok
test test_pre_order_traversal ... ok
test test_rb_balancing ... ok
test test_size ... ok

test result: ok. 13 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap37/TestBSTRBStEph.rs (target/llvm-cov-target/debug/deps/TestBSTRBStEph-cf4dd3a140ee1574)

running 15 tests
test rb_contains ... ok
test rb_balancing_reverse_sorted ... ok
test rb_balancing_sorted_input ... ok
test rb_duplicate_insert_is_idempotent ... ok
test rb_empty_operations ... ok
test rb_height ... ok
test rb_in_order_traversal ... ok
test rb_insert_find_and_bounds ... ok
test rb_is_empty ... ok
test rb_minimum_maximum ... ok
test rb_new_and_default ... ok
test rb_pre_order_traversal ... ok
test rb_single_element ... ok
test test_bstrbstephlit_macro_functionality ... ok
test rb_large_tree ... ok

test result: ok. 15 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap40/TestBSTReducedStEph.rs (target/llvm-cov-target/debug/deps/TestBSTReducedStEph-8b11e27e201642fb)

running 17 tests
test reduced_bst_range_queries ... ok
test reduced_bst_macro_literal ... ok
test reduced_bst_count_operations ... ok
test reduced_bst_collections ... ok
test reduced_bst_sum_operations ... ok
test reduced_bst_string_keys ... ok
test reduced_bst_update_existing_key ... ok
test test_duplicate_keys_overwrite ... ok
test test_contains_method ... ok
test test_count_reducer_all_operations ... ok
test test_empty_tree_operations ... ok
test test_get_method ... ok
test test_edge_case_ranges ... ok
test test_minimum_maximum_keys ... ok
test test_single_element_operations ... ok
test reduced_bst_height_stays_reasonable ... ok
test test_large_tree_with_all_operations ... ok

test result: ok. 17 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap37/TestBSTSetAVLMtEph.rs (target/llvm-cov-target/debug/deps/TestBSTSetAVLMtEph-d90255768d6b9c6c)

running 42 tests
test test_as_tree ... ok
test test_bstsetavlmtephlit_macro_functionality ... ok
test test_delete ... ok
test test_duplicate_insert ... ok
test test_difference ... ok
test test_empty ... ok
test test_insert_and_contains ... ok
test test_delete_multiple ... ok
test test_filter ... ok
test test_intersection_disjoint ... ok
test test_intersection ... ok
test test_iter_in_order ... ok
test test_join_m ... ok
test test_join_m_with_empty ... ok
test test_join_pair ... ok
test test_balanced_after_inserts ... ok
test test_minimum_maximum ... ok
test test_negative_numbers ... ok
test test_reduce ... ok
test test_singleton ... ok
test test_trait_impl_as_tree ... ok
test test_split ... ok
test test_trait_impl_contains ... ok
test test_trait_impl_delete ... ok
test test_trait_impl_difference ... ok
test test_trait_impl_empty ... ok
test test_trait_impl_filter ... ok
test test_trait_impl_find ... ok
test test_trait_impl_insert ... ok
test test_large_set ... ok
test test_trait_impl_intersection ... ok
test test_trait_impl_iter_in_order ... ok
test test_trait_impl_join_m ... ok
test test_trait_impl_join_pair ... ok
test test_trait_impl_minimum ... ok
test test_trait_impl_reduce ... ok
test test_trait_impl_singleton ... ok
test test_trait_impl_split ... ok
test test_trait_impl_maximum ... ok
test test_union ... ok
test test_union_empty ... ok
test test_trait_impl_union ... ok

test result: ok. 42 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap37/TestBSTSetBBAlphaMtEph.rs (target/llvm-cov-target/debug/deps/TestBSTSetBBAlphaMtEph-b49526ec5673b35a)

running 42 tests
test test_bstsetbbalphamtephlit_macro_functionality ... ok
test test_as_tree ... ok
test test_duplicate_insert ... ok
test test_delete ... ok
test test_difference ... ok
test test_empty ... ok
test test_delete_multiple ... ok
test test_insert_and_contains ... ok
test test_filter ... ok
test test_intersection ... ok
test test_intersection_disjoint ... ok
test test_iter_in_order ... ok
test test_join_m ... ok
test test_join_m_with_empty ... ok
test test_join_pair ... ok
test test_minimum_maximum ... ok
test test_negative_numbers ... ok
test test_reduce ... ok
test test_singleton ... ok
test test_trait_impl_as_tree ... ok
test test_split ... ok
test test_balanced_after_inserts ... ok
test test_trait_impl_contains ... ok
test test_trait_impl_delete ... ok
test test_trait_impl_empty ... ok
test test_trait_impl_difference ... ok
test test_trait_impl_filter ... ok
test test_trait_impl_find ... ok
test test_trait_impl_insert ... ok
test test_trait_impl_intersection ... ok
test test_large_set ... ok
test test_trait_impl_join_m ... ok
test test_trait_impl_iter_in_order ... ok
test test_trait_impl_join_pair ... ok
test test_trait_impl_split ... ok
test test_union ... ok
test test_union_empty ... ok
test test_trait_impl_maximum ... ok
test test_trait_impl_minimum ... ok
test test_trait_impl_reduce ... ok
test test_trait_impl_union ... ok
test test_trait_impl_singleton ... ok

test result: ok. 42 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap37/TestBSTSetMtEph.rs (target/llvm-cov-target/debug/deps/TestBSTSetMtEph-782c3e9828ec76f6)

running 24 tests
test test_all_variants_empty_operations ... ok
test test_avl_bst_individual_operations ... ok
test test_all_variants_single_element ... ok
test test_avl_bst_set_ops ... ok
test test_bbalpha_bst_set_ops ... ok
test test_bbalpha_bst_individual_operations ... ok
test test_concurrent_avl_bst_operations ... ok
test test_plain_bst_set_ops ... ok
test test_concurrent_plain_bst_operations ... ok
test test_concurrent_splay_access_patterns ... ok
test test_concurrent_bbalpha_operations ... ok
test test_rb_bst_individual_operations ... ok
test test_plain_bst_individual_operations ... ok
test test_splay_bst_individual_operations ... ok
test test_rb_bst_set_ops ... ok
test test_concurrent_treap_operations ... ok
test test_splay_bst_set_ops ... ok
test test_treap_bst_individual_operations ... ok
test test_treap_bst_set_ops ... ok
test test_race_condition_verification_concurrent_modifications ... ok
test test_all_variants_concurrent_stress ... ok
test test_race_condition_verification_bst_sets ... ok
test test_concurrent_rb_bst_stress ... ok
test test_deadlock_prevention_bst_sets ... ok

test result: ok. 24 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.10s

     Running tests/Chap37/TestBSTSetPlainMtEph.rs (target/llvm-cov-target/debug/deps/TestBSTSetPlainMtEph-c6909da41cf23c12)

running 49 tests
test test_as_tree ... ok
test test_delete_nonexistent ... ok
test test_bstsetplainmtephlit_macro_functionality ... ok
test test_delete ... ok
test test_delete_multiple ... ok
test test_difference ... ok
test test_difference_empty ... ok
test test_duplicate_insert ... ok
test test_empty ... ok
test test_filter ... ok
test test_filter_empty_result ... ok
test test_find_returns_value ... ok
test test_insert_and_contains ... ok
test test_intersection ... ok
test test_intersection_disjoint ... ok
test test_intersection_empty ... ok
test test_iter_in_order ... ok
test test_join_m ... ok
test test_join_m_with_empty ... ok
test test_join_pair ... ok
test test_maximum ... ok
test test_minimum ... ok
test test_negative_numbers ... ok
test test_reduce ... ok
test test_singleton ... ok
test test_split ... ok
test test_split_not_found ... ok
test test_trait_impl_as_tree ... ok
test test_trait_impl_contains ... ok
test test_trait_impl_delete ... ok
test test_trait_impl_difference ... ok
test test_trait_impl_empty ... ok
test test_trait_impl_filter ... ok
test test_trait_impl_find ... ok
test test_trait_impl_insert ... ok
test test_trait_impl_intersection ... ok
test test_trait_impl_iter_in_order ... ok
test test_trait_impl_join_m ... ok
test test_trait_impl_join_pair ... ok
test test_trait_impl_maximum ... ok
test test_trait_impl_reduce ... ok
test test_trait_impl_minimum ... ok
test test_trait_impl_singleton ... ok
test test_trait_impl_split ... ok
test test_trait_impl_union ... ok
test test_union ... ok
test test_union_empty ... ok
test test_union_with_overlap ... ok
test test_large_set ... ok

test result: ok. 49 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap37/TestBSTSetRBMtEph.rs (target/llvm-cov-target/debug/deps/TestBSTSetRBMtEph-6873570581765572)

running 42 tests
test test_as_tree ... ok
test test_bstsetrbmtephlit_macro_functionality ... ok
test test_delete ... ok
test test_difference ... ok
test test_duplicate_insert ... ok
test test_empty ... ok
test test_delete_multiple ... ok
test test_insert_and_contains ... ok
test test_filter ... ok
test test_balanced_after_inserts ... ok
test test_intersection ... ok
test test_intersection_disjoint ... ok
test test_iter_in_order ... ok
test test_join_m ... ok
test test_join_m_with_empty ... ok
test test_join_pair ... ok
test test_minimum_maximum ... ok
test test_negative_numbers ... ok
test test_reduce ... ok
test test_singleton ... ok
test test_large_set ... ok
test test_split ... ok
test test_trait_impl_as_tree ... ok
test test_trait_impl_contains ... ok
test test_trait_impl_delete ... ok
test test_trait_impl_difference ... ok
test test_trait_impl_empty ... ok
test test_trait_impl_filter ... ok
test test_trait_impl_find ... ok
test test_trait_impl_insert ... ok
test test_trait_impl_intersection ... ok
test test_trait_impl_iter_in_order ... ok
test test_trait_impl_join_m ... ok
test test_trait_impl_join_pair ... ok
test test_trait_impl_maximum ... ok
test test_trait_impl_minimum ... ok
test test_trait_impl_reduce ... ok
test test_trait_impl_singleton ... ok
test test_trait_impl_split ... ok
test test_trait_impl_union ... ok
test test_union ... ok
test test_union_empty ... ok

test result: ok. 42 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap37/TestBSTSetSplayMtEph.rs (target/llvm-cov-target/debug/deps/TestBSTSetSplayMtEph-42a54e8626ecfe55)

running 42 tests
test test_as_tree ... ok
test test_bstsetsplaymtephlit_macro_functionality ... ok
test test_delete ... ok
test test_delete_multiple ... ok
test test_difference ... ok
test test_duplicate_insert ... ok
test test_empty ... ok
test test_filter ... ok
test test_insert_and_contains ... ok
test test_intersection ... ok
test test_intersection_disjoint ... ok
test test_iter_in_order ... ok
test test_join_m ... ok
test test_join_m_with_empty ... ok
test test_join_pair ... ok
test test_balanced_after_inserts ... ok
test test_minimum_maximum ... ok
test test_negative_numbers ... ok
test test_reduce ... ok
test test_singleton ... ok
test test_split ... ok
test test_trait_impl_as_tree ... ok
test test_trait_impl_contains ... ok
test test_trait_impl_delete ... ok
test test_trait_impl_difference ... ok
test test_trait_impl_empty ... ok
test test_trait_impl_find ... ok
test test_trait_impl_insert ... ok
test test_trait_impl_filter ... ok
test test_large_set ... ok
test test_trait_impl_intersection ... ok
test test_trait_impl_iter_in_order ... ok
test test_trait_impl_join_m ... ok
test test_trait_impl_join_pair ... ok
test test_trait_impl_maximum ... ok
test test_trait_impl_minimum ... ok
test test_trait_impl_reduce ... ok
test test_trait_impl_singleton ... ok
test test_trait_impl_split ... ok
test test_trait_impl_union ... ok
test test_union ... ok
test test_union_empty ... ok

test result: ok. 42 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap39/TestBSTSetTreapMtEph.rs (target/llvm-cov-target/debug/deps/TestBSTSetTreapMtEph-5ab464cb7023e944)

running 42 tests
test test_as_tree ... ok
test test_bstsettreapmtephlit_macro_functionality ... ok
test test_delete ... ok
test test_duplicate_insert ... ok
test test_delete_multiple ... ok
test test_filter ... ok
test test_balanced_after_inserts ... ok
test test_insert_and_contains ... ok
test test_difference ... ok
test test_intersection ... ok
test test_empty ... ok
test test_intersection_disjoint ... ok
test test_iter_in_order ... ok
test test_join_m ... ok
test test_join_m_with_empty ... ok
test test_join_pair ... ok
test test_minimum_maximum ... ok
test test_negative_numbers ... ok
test test_reduce ... ok
test test_singleton ... ok
test test_split ... ok
test test_large_set ... ok
test test_trait_impl_empty ... ok
test test_trait_impl_as_tree ... ok
test test_trait_impl_delete ... ok
test test_trait_impl_contains ... ok
test test_trait_impl_difference ... ok
test test_trait_impl_filter ... ok
test test_trait_impl_find ... ok
test test_trait_impl_insert ... ok
test test_trait_impl_iter_in_order ... ok
test test_trait_impl_intersection ... ok
test test_trait_impl_join_m ... ok
test test_trait_impl_join_pair ... ok
test test_trait_impl_minimum ... ok
test test_trait_impl_reduce ... ok
test test_trait_impl_singleton ... ok
test test_trait_impl_split ... ok
test test_trait_impl_union ... ok
test test_trait_impl_maximum ... ok
test test_union ... ok
test test_union_empty ... ok

test result: ok. 42 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap40/TestBSTSizeStEph.rs (target/llvm-cov-target/debug/deps/TestBSTSizeStEph-413520e3bca85992)

running 8 tests
test size_bst_rank_select_consistency ... ok
test size_bst_duplicate_insert_is_idempotent ... ok
test size_bst_select_operations ... ok
test size_bst_macro_literal ... ok
test size_bst_rank_operations ... ok
test size_bst_basic_operations ... ok
test size_bst_split_rank_operations ... ok
test size_bst_large_dataset_performance ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap37/TestBSTSplayMtEph.rs (target/llvm-cov-target/debug/deps/TestBSTSplayMtEph-2657889c259269ee)

running 12 tests
test test_bstsplaymtephlit_macro_functionality ... ok
test test_contains ... ok
test test_default ... ok
test test_height ... ok
test test_duplicate_insert ... ok
test test_in_order_traversal ... ok
test test_insert_and_find ... ok
test test_is_empty ... ok
test test_minimum_maximum ... ok
test test_pre_order_traversal ... ok
test test_size ... ok
test test_new_empty ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap37/TestBSTSplayStEph.rs (target/llvm-cov-target/debug/deps/TestBSTSplayStEph-2d08c186cc8acae7)

running 10 tests
test splay_basic_behaviour ... ok
test test_bstsplaystephlit_macro_functionality ... ok
test splay_duplicate_insert_is_idempotent ... ok
test test_empty ... ok
test test_negative_numbers ... ok
test test_pre_order ... ok
test test_singleton ... ok
test test_height ... ok
test test_reverse_insert ... ok
test test_large_tree ... ok

test result: ok. 10 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap39/TestBSTTreapMtEph.rs (target/llvm-cov-target/debug/deps/TestBSTTreapMtEph-f8ee02601dc63a45)

running 8 tests
test test_bsttreapmtephlit_macro_empty_tree ... ok
test test_bsttreapmtephlit_macro_functionality ... ok
test test_bsttreapmtephlit_macro_negative_numbers ... ok
test test_bsttreapmtephlit_macro_multiple_elements ... ok
test test_bsttreapmtephlit_macro_single_element ... ok
test test_bsttreapmtephlit_macro_sorted_order ... ok
test test_bsttreapmtephlit_macro_with_duplicates ... ok
test test_bsttreapmtephlit_macro_with_trailing_comma ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap39/TestBSTTreapStEph.rs (target/llvm-cov-target/debug/deps/TestBSTTreapStEph-eab3453443cd0f56)

running 29 tests
test test_empty ... ok
test test_empty_operations ... ok
test test_bsttreapstephlit_macro_functionality ... ok
test test_duplicate_insert ... ok
test test_extremes ... ok
test test_find ... ok
test test_contains ... ok
test test_find_missing ... ok
test test_contains_after_many_inserts ... ok
test test_height ... ok
test test_in_order ... ok
test test_in_order_traversal ... ok
test test_height_balanced ... ok
test test_insert_and_size ... ok
test test_is_empty ... ok
test test_minimum_maximum ... ok
test test_large_tree ... ok
test test_mixed_positive_negative ... ok
test test_pre_order ... ok
test test_negative_numbers ... ok
test test_pre_order_traversal ... ok
test test_reverse_order_insert ... ok
test test_random_order_inserts ... ok
test test_singleton_traversal ... ok
test test_zero_value ... ok
test test_string_treap ... ok
test test_traversal_empty_tree ... ok
test test_single_element ... ok
test test_sequential_inserts ... ok

test result: ok. 29 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap23/TestBalBinTreeStEph.rs (target/llvm-cov-target/debug/deps/TestBalBinTreeStEph-6e3d5f7708bf804a)

running 25 tests
test balbintree_empty_leaf_operations ... ok
test balbintree_complex_structure ... ok
test balbintree_height_calculation ... ok
test balbintree_is_leaf_check ... ok
test balbintree_large_balanced_tree ... ok
test balbintree_only_right_children ... ok
test balbintree_only_left_children ... ok
test balbintree_single_node_operations ... ok
test balbintree_size_calculation ... ok
test balbintree_traversal_consistency ... ok
test balbintree_unbalanced_left ... ok
test balbintree_unbalanced_right ... ok
test bst_insert_and_search_behavior ... ok
test bstree_alternating_insertions ... ok
test bstree_duplicate_insertions ... ok
test bstree_edge_case_searches ... ok
test bstree_empty_operations ... ok
test bstree_left_skewed_tree ... ok
test bstree_mixed_positive_negative ... ok
test bstree_negative_numbers ... ok
test bstree_random_insertions ... ok
test bstree_right_skewed_tree ... ok
test bstree_single_element ... ok
test inorder_and_preorder_traversals_match_definitions ... ok
test bstree_large_dataset ... ok

test result: ok. 25 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap45/TestBalancedTreePQ.rs (target/llvm-cov-target/debug/deps/TestBalancedTreePQ-601a01661d9d7b97)

running 43 tests
test test_balancedtreepqlit_macro_functionality ... ok
test test_contains_empty ... ok
test test_contains ... ok
test test_default ... ok
test test_delete_max ... ok
test test_delete_max_empty ... ok
test test_delete_min ... ok
test test_delete_min_empty ... ok
test test_display ... ok
test test_duplicate_elements ... ok
test test_empty_priority_queue ... ok
test test_extract_all_sorted ... ok
test test_filter ... ok
test test_filter_empty_result ... ok
test test_find_max ... ok
test test_from_seq ... ok
test test_from_vec ... ok
test test_insert_all ... ok
test test_height ... ok
test test_insert_and_find_min ... ok
test test_is_sorted ... ok
test test_is_sorted_empty ... ok
test test_join ... ok
test test_map ... ok
test test_map_to_string ... ok
test test_meld_multiple ... ok
test test_meld_with_empty ... ok
test test_meld_two_priority_queues ... ok
test test_persistent_semantics ... ok
test test_priority_queue_ordering ... ok
test test_range ... ok
test test_range_empty_result ... ok
test test_remove ... ok
test test_sequential_delete_min_all ... ok
test test_remove_not_found ... ok
test test_singleton_priority_queue ... ok
test test_split_not_found ... ok
test test_string_priority_queue ... ok
test test_split ... ok
test test_to_seq ... ok
test test_to_sorted_vec ... ok
test test_to_vec ... ok
test test_large_priority_queue ... ok

test result: ok. 43 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap58/TestBellmanFordStEphFloat.rs (target/llvm-cov-target/debug/deps/TestBellmanFordStEphFloat-69231698c5b72075)

running 5 tests
test tests::test_unreachable ... ok
test tests::test_basic_path ... ok
test tests::test_negative_edges ... ok
test tests::test_negative_cycle ... ok
test tests::test_fractional_weights ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap58/TestBellmanFordStEphInt.rs (target/llvm-cov-target/debug/deps/TestBellmanFordStEphInt-776239ae0e09dd34)

running 10 tests
test tests::test_all_negative_edges_no_cycle ... ok
test tests::test_convergence_early_termination ... ok
test tests::test_example_58_2_dijkstra_fails ... ok
test tests::test_example_58_3_k_hop_distances ... ok
test tests::test_currency_exchange_example_58_1 ... ok
test tests::test_single_vertex ... ok
test tests::test_negative_cycle_detection ... ok
test tests::test_example_58_4_algorithm_steps ... ok
test tests::test_unreachable_vertices ... ok
test tests::test_zero_weight_edges ... ok

test result: ok. 10 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap45/TestBinaryHeapPQ.rs (target/llvm-cov-target/debug/deps/TestBinaryHeapPQ-7d193c287fe02c54)

running 33 tests
test test_ascending_insertion ... ok
test test_binaryheappqlit_macro_functionality ... ok
test test_delete_min ... ok
test test_default ... ok
test test_delete_min_empty ... ok
test test_descending_insertion ... ok
test test_display ... ok
test test_duplicate_elements ... ok
test test_empty ... ok
test test_extract_all_sorted ... ok
test test_find_min ... ok
test test_from_seq ... ok
test test_from_vec ... ok
test test_heap_property_after_operations ... ok
test test_height ... ok
test test_heapsort_via_extract ... ok
test test_insert_all ... ok
test test_insert_maintains_heap_property ... ok
test test_is_valid_heap ... ok
test test_level_elements ... ok
test test_macro_type_check ... ok
test test_meld ... ok
test test_meld_multiple ... ok
test test_persistent_semantics ... ok
test test_meld_with_empty ... ok
test test_single_element_operations ... ok
test test_sequential_delete_all ... ok
test test_string_heap ... ok
test test_singleton ... ok
test test_to_seq ... ok
test test_to_vec ... ok
test test_to_sorted_vec ... ok
test test_large_heap ... ok

test result: ok. 33 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s

     Running tests/Chap66/TestBoruvkaMtEph.rs (target/llvm-cov-target/debug/deps/TestBoruvkaMtEph-e812c130e4b0c8ba)

running 9 tests
test tests_boruvka_mt_eph::test_boruvka_mt_single_vertex ... ok
test tests_boruvka_mt_eph::test_boruvka_mt_two_vertices ... ok
test tests_boruvka_mt_eph::test_boruvka_mt_star ... ok
test tests_boruvka_mt_eph::test_boruvka_mt_triangle ... ok
test tests_boruvka_mt_eph::test_boruvka_mt_cycle_5 ... ok
test tests_boruvka_mt_eph::test_boruvka_mt_path ... ok
test tests_boruvka_mt_eph::test_boruvka_mt_complete_4 ... ok
test tests_boruvka_mt_eph::test_boruvka_mt_square ... ok
test tests_boruvka_mt_eph::test_boruvka_mt_larger_graph ... ok

test result: ok. 9 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s

     Running tests/Chap66/TestBoruvkaStEph.rs (target/llvm-cov-target/debug/deps/TestBoruvkaStEph-e341921c4601e734)

running 8 tests
test tests_boruvka_st_eph::test_boruvka_single_vertex ... ok
test tests_boruvka_st_eph::test_boruvka_star ... ok
test tests_boruvka_st_eph::test_boruvka_two_vertices ... ok
test tests_boruvka_st_eph::test_boruvka_square ... ok
test tests_boruvka_st_eph::test_boruvka_triangle ... ok
test tests_boruvka_st_eph::test_boruvka_cycle_5 ... ok
test tests_boruvka_st_eph::test_boruvka_path ... ok
test tests_boruvka_st_eph::test_boruvka_complete_4 ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap51/TestBottomUpDPMtEph.rs (target/llvm-cov-target/debug/deps/TestBottomUpDPMtEph-933af76206ad7b1d)

running 11 tests
test test_is_empty_false ... ok
test test_default ... ok
test test_is_empty_true ... ok
test test_display ... ok
test test_med_bottom_up_parallel_empty ... ok
test test_new ... ok
test test_partial_eq ... ok
test test_s_length ... ok
test test_t_length ... ok
test test_med_bottom_up_parallel_identical ... ok
test test_med_bottom_up_parallel_textbook ... ok

test result: ok. 11 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap51/TestBottomUpDPMtPer.rs (target/llvm-cov-target/debug/deps/TestBottomUpDPMtPer-9ad7dccb4994a0bf)

running 12 tests
test test_default ... ok
test test_is_empty_false ... ok
test test_display ... ok
test test_is_empty_true ... ok
test test_med_bottom_up_parallel_empty ... ok
test test_med_bottom_up_parallel_one_empty ... ok
test test_new ... ok
test test_partial_eq ... ok
test test_s_length ... ok
test test_t_length ... ok
test test_med_bottom_up_parallel_identical ... ok
test test_med_bottom_up_parallel_textbook ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap51/TestBottomUpDPStEph.rs (target/llvm-cov-target/debug/deps/TestBottomUpDPStEph-b23dd2a40a41e8b4)

running 13 tests
test test_default ... ok
test test_display ... ok
test test_is_empty_false ... ok
test test_is_empty_true ... ok
test test_med_bottom_up_empty ... ok
test test_med_bottom_up_identical ... ok
test test_med_bottom_up_textbook ... ok
test test_new ... ok
test test_partial_eq ... ok
test test_s_length ... ok
test test_set_s ... ok
test test_set_t ... ok
test test_t_length ... ok

test result: ok. 13 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap51/TestBottomUpDPStPer.rs (target/llvm-cov-target/debug/deps/TestBottomUpDPStPer-81f517f5e7d841bb)

running 15 tests
test test_default ... ok
test test_display ... ok
test test_med_bottom_up_empty ... ok
test test_is_empty_false ... ok
test test_is_empty_true ... ok
test test_med_bottom_up_one_empty ... ok
test test_med_bottom_up_identical ... ok
test test_med_bottom_up_single_char_different ... ok
test test_med_bottom_up_single_char_same ... ok
test test_new ... ok
test test_med_bottom_up_textbook ... ok
test test_partial_eq_false ... ok
test test_partial_eq_true ... ok
test test_s_length ... ok
test test_t_length ... ok

test result: ok. 15 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap36/TestChapter36Mt.rs (target/llvm-cov-target/debug/deps/TestChapter36Mt-a664ffca06e7727e)

running 8 tests
test pivot_mt_strategies_match_expectations ... ok
test quick_sort_mt_pivot_strategies_concurrent ... ok
test quick_sort_mt_edge_cases ... ok
test quick_sort_mt_small_inputs_use_shared_pivots ... ok
test quick_sort_mt_concurrent_execution_verification ... ok
test quick_sort_mt_variants_produce_sorted_output ... ok
test quick_sort_mt_thread_safety_stress_test ... ok
test quick_sort_mt_large_inputs ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.03s

     Running tests/Chap36/TestChapter36MtSlice.rs (target/llvm-cov-target/debug/deps/TestChapter36MtSlice-67d942fbc7af30aa)

running 16 tests
test slice_clone_functionality ... ok
test slice_from_vec_constructor ... ok
test slice_length_method ... ok
test slice_nth_cloned_method ... ok
test slice_pivot_mt_first_edge_cases ... ok
test slice_pivot_mt_median3_edge_cases ... ok
test quick_sort_slice_small_inputs_use_shared_pivots ... ok
test slice_pivot_strategies_match_expectations ... ok
test slice_pivot_mt_random_range_validation ... ok
test slice_to_vec_method ... ok
test slice_pivot_concurrent_access ... ok
test quick_sort_slice_variants_produce_sorted_output ... ok
test quick_sort_slice_edge_cases ... ok
test slice_concurrent_sorting_stress_test ... ok
test slice_large_data_handling ... ok
test quick_sort_slice_large_inputs ... ok

test result: ok. 16 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.19s

     Running tests/Chap36/TestChapter36St.rs (target/llvm-cov-target/debug/deps/TestChapter36St-b3d859b06c40dd86)

running 4 tests
test quick_sort_small_inputs_use_shared_pivots ... ok
test quick_sort_handles_edge_cases ... ok
test pivot_strategies_match_expectations ... ok
test quick_sort_variants_produce_sorted_output ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap47/TestClusteringAnalysis.rs (target/llvm-cov-target/debug/deps/TestClusteringAnalysis-38d0f6e0829a3479)

running 15 tests
test test_clustering_analyzer_creation ... ok
test test_clustering_severity_classification ... ok
test test_empty_table_clustering_analysis ... ok
test test_example_comprehensive_clustering_analysis ... ok
test test_clustering_comparison_different_sizes ... ok
test test_minimal_analyzer_behavior ... ok
test test_clustering_analysis_various_load_factors ... ok
test test_probing_strategy_comparison ... ok
test test_single_element_clustering_analysis ... ok
test test_example_load_factor_impact_analysis ... ok
test test_linear_probing_clustering_analysis ... ok
test test_quadratic_probing_clustering_analysis ... ok
test test_performance_impact_assessment ... ok
test test_double_hashing_clustering_analysis ... ok
test test_comprehensive_clustering_integration ... ok

test result: ok. 15 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap63/TestConnectivityMtEph.rs (target/llvm-cov-target/debug/deps/TestConnectivityMtEph-3deb4a21b6c4084b)

running 5 tests
test tests::test_connected_components_mt_multiple ... ok
test tests::test_count_components_mt_multiple ... ok
test tests::test_count_components_mt_single ... ok
test tests::test_connected_components_mt_single ... ok
test tests::test_count_components_hof_mt ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap63/TestConnectivityStEph.rs (target/llvm-cov-target/debug/deps/TestConnectivityStEph-390265607e5c298d)

running 7 tests
test tests::test_count_components_empty ... ok
test tests::test_connected_components_single ... ok
test tests::test_connected_components_multiple ... ok
test tests::test_count_components_single ... ok
test tests::test_count_components_multiple ... ok
test tests::test_count_components_hof ... ok
test tests::test_connected_components_hof ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap55/TestCycleDetectStEph.rs (target/llvm-cov-target/debug/deps/TestCycleDetectStEph-efad6a2fd14b4068)

running 7 tests
test test_dag_no_cycle ... ok
test test_self_loop ... ok
test test_cycle_in_dag_structure ... ok
test test_no_cycle_empty_graph ... ok
test test_no_cycle_single_node ... ok
test test_no_cycle_linear ... ok
test test_simple_cycle ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap55/TestCycleDetectStPer.rs (target/llvm-cov-target/debug/deps/TestCycleDetectStPer-41d5dc2cb968831b)

running 7 tests
test test_cycle_in_dag_structure ... ok
test test_no_cycle_empty_graph ... ok
test test_dag_no_cycle ... ok
test test_no_cycle_linear ... ok
test test_self_loop ... ok
test test_no_cycle_single_node ... ok
test test_simple_cycle ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap55/TestDFSStEph.rs (target/llvm-cov-target/debug/deps/TestDFSStEph-a0ae00e69bd2c92b)

running 6 tests
test TestDFSStEph::test_cycle ... ok
test TestDFSStEph::test_dag ... ok
test TestDFSStEph::test_disconnected ... ok
test TestDFSStEph::test_empty_graph ... ok
test TestDFSStEph::test_line_graph ... ok
test TestDFSStEph::test_single_vertex ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap55/TestDFSStPer.rs (target/llvm-cov-target/debug/deps/TestDFSStPer-22472d011eb12d94)

running 7 tests
test TestDFSStPer::test_dag ... ok
test TestDFSStPer::test_disconnected ... ok
test TestDFSStPer::test_cycle ... ok
test TestDFSStPer::test_invalid_source ... ok
test TestDFSStPer::test_empty_graph ... ok
test TestDFSStPer::test_line_graph ... ok
test TestDFSStPer::test_single_vertex ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap57/TestDijkstraStEphFloat.rs (target/llvm-cov-target/debug/deps/TestDijkstraStEphFloat-cf4e88b26fd172fd)

running 4 tests
test test_disconnected_graph ... ok
test test_simple_path ... ok
test test_single_vertex ... ok
test test_complex_graph ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap57/TestDijkstraStEphInt.rs (target/llvm-cov-target/debug/deps/TestDijkstraStEphInt-cc7d794815f94059)

running 7 tests
test tests::test_example_57_1 ... ok
test tests::test_example_57_3 ... ok
test tests::test_multiple_paths_same_weight ... ok
test tests::test_larger_graph ... ok
test tests::test_path_extraction ... ok
test tests::test_unreachable_vertices ... ok
test tests::test_single_vertex ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap06/TestDirGraphMtEph.rs (target/llvm-cov-target/debug/deps/TestDirGraphMtEph-a83bcdb98cbc12af)

running 21 tests
test test_dirgraphmteph_basic_operations ... ok
test test_dirgraphmteph_degree ... ok
test test_dirgraphmteph_empty ... ok
test test_dirgraphmteph_incident ... ok
test test_dirgraphmteph_neighbor ... ok
test test_dirgraphmteph_indegree ... ok
test test_dirgraphmteph_ng ... ok
test test_dirgraphmteph_concurrent_access ... ok
test test_dirgraphmteph_ngofvertices ... ok
test test_dirgraphmteph_nminusofvertices ... ok
test test_dirgraphmteph_nminus ... ok
test test_dirgraphmteph_nplus ... ok
test test_dirgraphmteph_nplusofvertices ... ok
test test_dirgraphmteph_outdegree ... ok
test test_dirgraphmtephlit_macro_functionality ... ok
test test_empty_graph_operations ... ok
test test_isolated_vertex ... ok
test test_dirgraphmteph_thread_safety ... ok
test test_race_condition_verification_mixed_graph_operations ... ok
test test_race_condition_verification_concurrent_graph_reads ... ok
test test_deadlock_prevention_concurrent_graph_operations ... ok

test result: ok. 21 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.05s

     Running tests/Chap06/TestDirGraphStEph.rs (target/llvm-cov-target/debug/deps/TestDirGraphStEph-ba42a5175ceb960f)

running 20 tests
test test_digraph_vertices_and_arcs ... ok
test test_dirgraph_empty_graph_edge_cases ... ok
test test_dirgraph_degree ... ok
test test_dirgraph_extreme_vertex_references_graceful ... ok
test test_dirgraph_neighbor ... ok
test test_dirgraph_ngofvertices ... ok
test test_dirgraph_nminusofvertices ... ok
test test_dirgraph_empty ... ok
test test_dirgraph_incident ... ok
test test_dirgraph_nminus ... ok
test test_dirgraph_nplusofvertices ... ok
test test_dirgraph_nonexistent_vertex_edge_cases ... ok
test test_dirgraph_indegree ... ok
test test_dirgraph_ng ... ok
test test_dirgraph_nplus ... ok
test test_dirgraph_outdegree ... ok
test test_dirgraph_selfloop_edge_cases ... ok
test test_dirgraph_single_vertex_edge_cases ... ok
test test_dirgraphstephlit_macro_functionality ... ok
test test_dirgraph_large_graph_stress ... ok

test result: ok. 20 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap26/TestDivConReduceMt.rs (target/llvm-cov-target/debug/deps/TestDivConReduceMt-d21929e7d3f39b74)

running 8 tests
test test_divcon_reduce_mt::test_max_element_parallel_empty ... ok
test test_divcon_reduce_mt::test_product_parallel ... ok
test test_divcon_reduce_mt::test_all_parallel_true ... ok
test test_divcon_reduce_mt::test_any_parallel_true ... ok
test test_divcon_reduce_mt::test_all_parallel_false ... ok
test test_divcon_reduce_mt::test_any_parallel_false ... ok
test test_divcon_reduce_mt::test_max_element_parallel ... ok
test test_divcon_reduce_mt::test_sum_parallel ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap26/TestDivConReduceSt.rs (target/llvm-cov-target/debug/deps/TestDivConReduceSt-e5e58a6b10c18a7d)

running 8 tests
test test_divcon_reduce_st::test_all_true ... ok
test test_divcon_reduce_st::test_all_false ... ok
test test_divcon_reduce_st::test_any_false ... ok
test test_divcon_reduce_st::test_any_true ... ok
test test_divcon_reduce_st::test_max_element ... ok
test test_divcon_reduce_st::test_max_element_empty ... ok
test test_divcon_reduce_st::test_product ... ok
test test_divcon_reduce_st::test_sum ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap44/TestDocumentIndex.rs (target/llvm-cov-target/debug/deps/TestDocumentIndex-fbe40b6430d16e22)

running 19 tests
test test_case_insensitive_tokenization ... ok
test test_documentcollectionlit_macro_functionality ... ok
test test_empty_index ... ok
test test_duplicate_words_in_document ... ok
test test_algorithmic_costs_verification ... ok
test test_complex_query_combinations ... ok
test test_empty_query_results ... ok
test test_find_operation ... ok
test test_make_index_basic ... ok
test test_query_and ... ok
test test_single_document_index ... ok
test test_query_and_not ... ok
test test_query_builder ... ok
test test_tokens_edge_cases ... ok
test test_query_or ... ok
test test_tokens_function ... ok
test test_size_operation ... ok
test test_to_seq_operation ... ok
test test_large_document_collection ... ok

test result: ok. 19 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.58s

     Running tests/Chap47clean/TestDoubleHashFlatHashTable.rs (target/llvm-cov-target/debug/deps/TestDoubleHashFlatHashTable-af1024cb42e0d35c)

running 12 tests
test test_delete ... ok
test test_different_probe_sequences_for_colliding_keys ... ok
test test_delete_maintains_probe_chain ... ok
test test_find_slot ... ok
test test_high_load_factor ... ok
test test_insert_and_lookup ... ok
test test_lookup_nonexistent_key ... ok
test test_probe_visits_all_slots_prime_size ... ok
test test_second_hash_nonzero ... ok
test test_second_hash_is_odd ... ok
test test_update_existing_key ... ok
test test_probe_double_hash_sequence ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap47/TestDoubleHashing.rs (target/llvm-cov-target/debug/deps/TestDoubleHashing-254f5f719622785c)

running 21 tests
test test_create_double_hashing_integer_table ... ok
test test_create_double_hashing_string_table ... ok
test test_double_hash_mathematical_properties ... ok
test test_double_hash_probe_sequence ... ok
test test_double_hashing_collision_handling ... ok
test test_double_hashing_different_hash_functions ... ok
test test_double_hashing_empty_operations ... ok
test test_double_hashing_delete ... ok
test test_double_hashing_custom_seed_behavior ... ok
test test_double_hashing_gcd_considerations ... ok
test test_double_hashing_insert_and_lookup ... ok
test test_double_hashing_integer_operations ... ok
test test_double_hashing_step_size_variation ... ok
test test_double_hashing_load_factor_management ... ok
test test_double_hashing_strategy_creation ... ok
test test_double_hashing_zero_h2_handling ... ok
test test_double_hashing_update ... ok
test test_double_hashing_with_deletions_and_reinsertions ... ok
test test_double_hashing_optimal_distribution ... ok
test test_double_hashing_prime_table_sizes ... ok
test test_double_hashing_resize_behavior ... ok

test result: ok. 21 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap61/TestEdgeContractionMtEph.rs (target/llvm-cov-target/debug/deps/TestEdgeContractionMtEph-acc15c8d9c98e58f)

running 3 tests
test tests::test_edge_contract_mt_star ... ok
test tests::test_edge_contract_mt_cycle ... ok
test tests::test_contract_round_mt_correctness ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap61/TestEdgeContractionStEph.rs (target/llvm-cov-target/debug/deps/TestEdgeContractionStEph-8486cb570e6cea15)

running 3 tests
test tests::test_edge_contract_cycle ... ok
test tests::test_edge_contract_star ... ok
test tests::test_contract_round_cycle ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap52/TestEdgeSetGraphMtEph.rs (target/llvm-cov-target/debug/deps/TestEdgeSetGraphMtEph-ce325ef9cb8f5f38)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap52/TestEdgeSetGraphMtPer.rs (target/llvm-cov-target/debug/deps/TestEdgeSetGraphMtPer-86c4a1d5769a3783)

running 7 tests
test tests_edge_set_graph_mt_per::test_empty_graph ... ok
test tests_edge_set_graph_mt_per::test_delete_vertex ... ok
test tests_edge_set_graph_mt_per::test_insert_edge ... ok
test tests_edge_set_graph_mt_per::test_delete_edge ... ok
test tests_edge_set_graph_mt_per::test_insert_vertex ... ok
test tests_edge_set_graph_mt_per::test_out_degree ... ok
test tests_edge_set_graph_mt_per::test_out_neighbors ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap52/TestEdgeSetGraphStEph.rs (target/llvm-cov-target/debug/deps/TestEdgeSetGraphStEph-c23fa329708240b1)

running 7 tests
test tests_edge_set_graph_st_eph::test_delete_edge ... ok
test tests_edge_set_graph_st_eph::test_delete_vertex ... ok
test tests_edge_set_graph_st_eph::test_empty_graph ... ok
test tests_edge_set_graph_st_eph::test_insert_edge ... ok
test tests_edge_set_graph_st_eph::test_insert_vertex ... ok
test tests_edge_set_graph_st_eph::test_out_degree ... ok
test tests_edge_set_graph_st_eph::test_out_neighbors ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap52/TestEdgeSetGraphStPer.rs (target/llvm-cov-target/debug/deps/TestEdgeSetGraphStPer-a76f43c377686d61)

running 7 tests
test tests_edge_set_graph_st_per::test_delete_edge ... ok
test tests_edge_set_graph_st_per::test_delete_vertex ... ok
test tests_edge_set_graph_st_per::test_empty_graph ... ok
test tests_edge_set_graph_st_per::test_insert_edge ... ok
test tests_edge_set_graph_st_per::test_insert_vertex ... ok
test tests_edge_set_graph_st_per::test_out_degree ... ok
test tests_edge_set_graph_st_per::test_out_neighbors ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap41/TestExample41_3.rs (target/llvm-cov-target/debug/deps/TestExample41_3-0882afecac8777dd)

running 4 tests
test test_example_41_3_from_seq_demonstration ... ok
test test_additional_set_operations ... ok
test test_example_41_1_array_set ... ok
test test_example_41_1_avl_set ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap42/TestExample42_1.rs (target/llvm-cov-target/debug/deps/TestExample42_1-3d872246ee2ba662)

running 2 tests
test test_example_42_1_runs ... ok
test test_performance_comparison_runs ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.18s

     Running tests/Chap43/TestExample43_1.rs (target/llvm-cov-target/debug/deps/TestExample43_1-2e877c0bcab40733)

running 6 tests
test test_example43_1_demonstrates_operations ... ok
test test_example43_1_lexicographic_ordering ... ok
test test_example43_1_basic_functionality ... ok
test test_example43_1_output_format ... ok
test test_example43_1_string_set_operations ... ok
test test_example43_1_consistency ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap44/TestExample44_1.rs (target/llvm-cov-target/debug/deps/TestExample44_1-5a45f95029daa347)

running 20 tests
test test_create_tweet_collection ... ok
test test_tokenization_demo ... ok
test test_case_insensitive_search ... ok
test test_create_tweet_index ... ok
test test_algorithmic_complexity_verification ... ok
test test_index_statistics ... ok
test test_complex_query_fun_and_food_or_chess ... ok
test test_count_fun_but_not_chess ... ok
test test_search_food_or_fun ... ok
test test_single_word_documents ... ok
test test_get_word_count ... ok
test test_performance_comparison_demo ... ok
test test_search_party_and_food ... ok
test test_staged_computation_pattern ... ok
test test_tweet_query_examples ... ok
test test_query_builder_example ... ok
test test_query_combinations ... ok
test test_verify_textbook_examples ... ok
test test_get_all_words ... ok
test test_empty_search_results ... ok

test result: ok. 20 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap56/TestExample56_1.rs (target/llvm-cov-target/debug/deps/TestExample56_1-5c0e3513ddb39019)

running 3 tests
test test_example_negative_weights ... ok
test test_example_path_weight_int ... ok
test test_example_path_weight_float ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap56/TestExample56_3.rs (target/llvm-cov-target/debug/deps/TestExample56_3-63571dbcd34befd3)

running 2 tests
test test_example_negative_cycle ... ok
test test_example_undefined_shortest_path ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap12/TestExercise12_1.rs (target/llvm-cov-target/debug/deps/TestExercise12_1-4d1e93751809e428)

running 4 tests
test spin_lock_with_lock_helper_executes_body ... ok
test spin_lock_excludes_parallel_threads ... ok
test parallel_increment_counts_all_iterations ... ok
test spin_lock_is_non_reentrant ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s

     Running tests/Chap12/TestExercise12_2.rs (target/llvm-cov-target/debug/deps/TestExercise12_2-e586aff29fcc1ef5)

running 7 tests
test fetch_add_cas_wrapping ... ok
test fetch_add_cas_zero_delta ... ok
test fetch_add_cas_returns_previous_value ... ok
test trait_impl_matches_free_function ... ok
test fetch_add_cas_max_value ... ok
test efficiency_note_exists ... ok
test fetch_add_cas_is_thread_safe ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap12/TestExercise12_5.rs (target/llvm-cov-target/debug/deps/TestExercise12_5-a64dbc0607045df3)

running 4 tests
test push_pop_lifo_single_thread ... ok
test pop_on_empty_returns_none ... ok
test multi_thread_push_collects_all_items ... ok
test multi_thread_pop_consumes_all_elements ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap21/TestExercise_21_5.rs (target/llvm-cov-target/debug/deps/TestExercise_21_5-d5cde527b8801c95)

running 3 tests
test test_all_contiguous_subseqs_debug_shape ... ok
test test_all_contiguous_subseqs_n0 ... ok
test test_all_contiguous_subseqs_n3_values ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap21/TestExercise_21_6.rs (target/llvm-cov-target/debug/deps/TestExercise_21_6-9654a6b6c3a487b5)

running 1 test
test test_exercise21_6_cost_analysis ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap21/TestExercise_21_7.rs (target/llvm-cov-target/debug/deps/TestExercise_21_7-7fa72a88aff760e1)

running 2 tests
test test_pair_even_with_vowels_basic ... ok
test test_pair_even_with_vowels_debug_shape ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap21/TestExercise_21_8.rs (target/llvm-cov-target/debug/deps/TestExercise_21_8-682d1d3b3d6b8bd0)

running 2 tests
test test_is_divisible_helper ... ok
test test_is_prime_small_values ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap21/TestExercise_21_9.rs (target/llvm-cov-target/debug/deps/TestExercise_21_9-4685d1190e8987e2)

running 1 test
test test_exercise21_9_placeholder ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap11/TestFibonacciMt.rs (target/llvm-cov-target/debug/deps/TestFibonacciMt-a54dce72b63dcdf5)

running 4 tests
test fib_base_cases ... ok
test fib_small_values ... ok
test fib_moderate_values ... ok
test trait_and_inherent_agree ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.07s

     Running tests/Chap47/TestFlatHashTable.rs (target/llvm-cov-target/debug/deps/TestFlatHashTable-635197a61751a825)

running 13 tests
test test_create_empty_flat_table ... ok
test test_display_format ... ok
test test_delete ... ok
test test_entry_states ... ok
test test_empty_table_operations ... ok
test test_full_table_behavior ... ok
test test_insert_duplicate_key ... ok
test test_insert_and_lookup ... ok
test test_linear_probing_collision_resolution ... ok
test test_integer_keys ... ok
test test_probe_sequence_with_dead_entries ... ok
test test_statistics ... ok
test test_resize_on_high_load_factor ... ok

test result: ok. 13 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap53/TestGraphSearchMtPer.rs (target/llvm-cov-target/debug/deps/TestGraphSearchMtPer-e6f5522d46b18571)

running 7 tests
test test_empty_graph ... ok
test test_cycle_detection ... ok
test test_graph_search_single_source ... ok
test test_reachable_simple_path ... ok
test test_reachable_single_node ... ok
test test_graph_search_multi_source ... ok
test test_select_one_strategy ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap53/TestGraphSearchStEph.rs (target/llvm-cov-target/debug/deps/TestGraphSearchStEph-59950e2c78286250)

running 7 tests
test test_reachable_single_node ... ok
test test_empty_graph ... ok
test test_reachable_simple_path ... ok
test test_graph_search_single_source ... ok
test test_graph_search_multi_source ... ok
test test_cycle_detection ... ok
test test_select_one_strategy ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap53/TestGraphSearchStPer.rs (target/llvm-cov-target/debug/deps/TestGraphSearchStPer-ffa0d44b22ef6589)

running 9 tests
test test_cycle ... ok
test test_disconnected_component ... ok
test test_dag ... ok
test test_linear_chain ... ok
test test_empty_graph ... ok
test test_multi_source ... ok
test test_select_one_dfs_style ... ok
test test_single_edge ... ok
test test_reachable ... ok

test result: ok. 9 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap47/TestHashExamples.rs (target/llvm-cov-target/debug/deps/TestHashExamples-f17cacc9832da1fe)

running 15 tests
test test_example_47_1_demonstration ... ok
test test_example_47_1_hash_function ... ok
test test_example_47_4_probe_sequence ... ok
test test_exercise_47_1_nested_implementation ... ok
test test_example_47_5_deleted_entries ... ok
test test_exercise_47_2_size_reduction ... ok
test test_example_47_6_collision_handling ... ok
test test_exercise_47_3_resize_implementation ... ok
test test_exercise_47_6_higher_order ... ok
test test_exercise_47_7_complete_implementation ... ok
test test_hash_function_consistency ... ok
test test_example_47_2_separate_chaining ... ok
test test_example_data_integrity ... ok
test test_textbook_fidelity ... ok
test test_run_all_examples ... ok

test result: ok. 15 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap47/TestHashFunctionTraits.rs (target/llvm-cov-target/debug/deps/TestHashFunctionTraits-20c219cad880bbdf)

running 16 tests
test test_hash_function_tester ... ok
test test_case_insensitive_string_equality ... ok
test test_hash_table_stats ... ok
test test_default_key_equality ... ok
test test_hash_table_utils ... ok
test test_impl_hash_function_macro_basic_usage ... ok
test test_impl_hash_function_macro_custom_hash ... ok
test test_impl_hash_function_macro_edge_cases ... ok
test test_impl_hash_function_macro_distribution ... ok
test test_load_factor_manager ... ok
test test_polynomial_hash_function ... ok
test test_probe_sequence_generator ... ok
test test_simple_integer_hash_macro ... ok
test test_string_position_hash_function ... ok
test test_universal_hash_family ... ok
test test_universal_integer_hash_function ... ok

test result: ok. 16 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap45/TestHeapsortExample.rs (target/llvm-cov-target/debug/deps/TestHeapsortExample-8ae4078774d464ff)

running 25 tests
test test_complexity_analysis ... ok
test test_efficiency_demonstration ... ok
test test_generate_test_sequences ... ok
test test_empty_example ... ok
test test_heapsort_balanced_tree_basic ... ok
test test_heapsort_already_sorted ... ok
test test_heapsort_empty ... ok
test test_heapsort_binary_heap_basic ... ok
test test_heapsort_leftist_heap_basic ... ok
test test_heapsort_single_element ... ok
test test_heapsort_duplicates ... ok
test test_heapsort_reverse_sorted ... ok
test test_is_sorted_utility ... ok
test test_duplicates_example ... ok
test test_compare_all_heapsorts ... ok
test test_heapsort_sorted_list_basic ... ok
test test_heapsort_unsorted_list_basic ... ok
test test_large_example ... ok
test test_single_element_example ... ok
test test_vec_to_array_seq ... ok
test test_already_sorted_example ... ok
test test_vec_to_avl_seq ... ok
test test_textbook_example ... ok
test test_reverse_sorted_example ... ok
test test_correctness_verification ... ok

test result: ok. 25 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap03/TestInsertionSortSt.rs (target/llvm-cov-target/debug/deps/TestInsertionSortSt-acfd6bf6eab0df39)

running 7 tests
test insertion_sort_handles_empty ... ok
test insertion_sort_already_sorted ... ok
test insertion_sort_reverse_order ... ok
test insertion_sort_random_slice ... ok
test insertion_sort_single_element ... ok
test insertion_sort_with_duplicates ... ok
test insertion_sort_large_input_stress_test ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.57s

     Running tests/Chap59/TestJohnsonMtEphFloat.rs (target/llvm-cov-target/debug/deps/TestJohnsonMtEphFloat-b6458b5c84b80b4c)

running 10 tests
test tests::test_single_vertex ... ok
test tests::test_self_loop ... ok
test tests::test_two_vertex_cycle ... ok
test tests::test_fractional_weights ... ok
test tests::test_triangle ... ok
test tests::test_simple_graph ... ok
test tests::test_large_weights ... ok
test tests::test_zero_weights ... ok
test tests::test_disconnected_graph ... ok
test tests::test_negative_weights ... ok

test result: ok. 10 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap59/TestJohnsonMtEphInt.rs (target/llvm-cov-target/debug/deps/TestJohnsonMtEphInt-10bd4ede604e02f9)

running 5 tests
test tests::test_single_vertex ... ok
test tests::test_simple_graph ... ok
test tests::test_negative_weights ... ok
test tests::test_disconnected_graph ... ok
test tests::test_example_59_1 ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap59/TestJohnsonStEphFloat.rs (target/llvm-cov-target/debug/deps/TestJohnsonStEphFloat-5101ebca2c5c07a0)

running 5 tests
test tests::test_single_vertex ... ok
test tests::test_disconnected_graph ... ok
test tests::test_negative_weights ... ok
test tests::test_simple_graph ... ok
test tests::test_fractional_weights ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap59/TestJohnsonStEphInt.rs (target/llvm-cov-target/debug/deps/TestJohnsonStEphInt-6a4f2b3e8c0a4a9b)

running 5 tests
test tests::test_single_vertex ... ok
test tests::test_disconnected_graph ... ok
test tests::test_negative_weights ... ok
test tests::test_simple_graph ... ok
test tests::test_example_59_1 ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap65/TestKruskalStEph.rs (target/llvm-cov-target/debug/deps/TestKruskalStEph-9668f2d11a9d69e7)

running 7 tests
test tests::test_kruskal_single_vertex ... ok
test tests::test_kruskal_all_equal_weights ... ok
test tests::test_kruskal_complete_graph ... ok
test tests::test_kruskal_square ... ok
test tests::test_kruskal_star_graph ... ok
test tests::test_kruskal_triangle ... ok
test tests::test_kruskal_verify_size ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap06/TestLabDirGraphMtEph.rs (target/llvm-cov-target/debug/deps/TestLabDirGraphMtEph-ea514c9f9d18454d)

running 9 tests
test test_labdirgraphmteph_arcs_conversion ... ok
test test_labdirgraphmteph_edge_cases ... ok
test test_labdirgraphmteph_basic_operations ... ok
test test_labdirgraphmteph_empty ... ok
test test_labdirgraphmteph_mutable_operations ... ok
test test_labdirgraphmteph_neighbors ... ok
test test_labdirgraphmteph_nonexistent_vertex ... ok
test test_labdirgraphmtephlit_macro_functionality ... ok
test test_labdirgraphmteph_concurrent_access ... ok

test result: ok. 9 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap06/TestLabDirGraphStEph.rs (target/llvm-cov-target/debug/deps/TestLabDirGraphStEph-e129b8cf619874b1)

running 12 tests
test test_labelled_dir_graph_add_labeled_arc ... ok
test test_labdirgraphstephlit_macro_functionality ... ok
test test_labelled_dir_graph_add_vertex ... ok
test test_labelled_dir_graph_debug ... ok
test test_labelled_dir_graph_arcs ... ok
test test_labelled_dir_graph_different_label_types ... ok
test test_labelled_dir_graph_display ... ok
test test_labelled_dir_graph_empty ... ok
test test_labelled_dir_graph_macro_empty ... ok
test test_labelled_dir_graph_macro_with_data ... ok
test test_labelled_dir_graph_neighbors ... ok
test test_labelled_dir_graph_self_loop ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap06/TestLabUnDirGraphMtEph.rs (target/llvm-cov-target/debug/deps/TestLabUnDirGraphMtEph-024e2e233d1b66dd)

running 24 tests
test test_add_vertex ... ok
test test_arcs ... ok
test test_add_labeled_edge ... ok
test test_clone ... ok
test test_debug ... ok
test test_display ... ok
test test_edges ... ok
test test_get_edge_label ... ok
test test_indegree ... ok
test test_labeled_edges_accessor ... ok
test test_labundirgraphmteph_basic_operations ... ok
test test_labundirgraphmteph_edge_cases ... ok
test test_labundirgraphmteph_empty ... ok
test test_labundirgraphmteph_incident_operations ... ok
test test_labundirgraphmteph_ngofvertices ... ok
test test_labundirgraphmteph_nonexistent_vertex ... ok
test test_labundirgraphmteph_nplusminusofvertices ... ok
test test_labundirgraphmtephlit_macro_functionality ... ok
test test_nminus ... ok
test test_labundirgraphmteph_concurrent_access ... ok
test test_nplus ... ok
test test_outdegree ... ok
test test_sizea ... ok
test test_vertices_accessor ... ok

test result: ok. 24 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap06/TestLabUnDirGraphStEph.rs (target/llvm-cov-target/debug/deps/TestLabUnDirGraphStEph-1b01b82b0c64b0fb)

running 21 tests
test test_arcs ... ok
test test_from_vertices_and_labeled_edges ... ok
test test_clone_graph ... ok
test test_indegree ... ok
test test_labelled_undir_graph_add_vertex ... ok
test test_labelled_undir_graph_debug ... ok
test test_labelled_undir_graph_different_label_types ... ok
test test_labelled_undir_graph_display ... ok
test test_labelled_undir_graph_edge_normalization ... ok
test test_labelled_undir_graph_add_labeled_edge ... ok
test test_labelled_undir_graph_edges ... ok
test test_labelled_undir_graph_empty ... ok
test test_labelled_undir_graph_macro_empty ... ok
test test_labelled_undir_graph_macro_with_data ... ok
test test_labelled_undir_graph_multiple_edges_same_vertices ... ok
test test_labelled_undir_graph_neighbors ... ok
test test_labelled_undir_graph_self_loop ... ok
test test_nminus ... ok
test test_nplus ... ok
test test_outdegree ... ok
test test_sizea ... ok

test result: ok. 21 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap45/TestLeftistHeapPQ.rs (target/llvm-cov-target/debug/deps/TestLeftistHeapPQ-468fc52d0e28c0ef)

running 32 tests
test test_ascending_insertion ... ok
test test_delete_min ... ok
test test_delete_min_empty ... ok
test test_default ... ok
test test_descending_insertion ... ok
test test_display ... ok
test test_duplicate_elements ... ok
test test_empty ... ok
test test_extract_all_sorted ... ok
test test_find_min ... ok
test test_from_seq ... ok
test test_from_vec ... ok
test test_height ... ok
test test_insert ... ok
test test_is_valid_leftist_heap ... ok
test test_leftist_property_after_meld ... ok
test test_leftistheappqlit_macro_functionality ... ok
test test_meld ... ok
test test_meld_efficiency ... ok
test test_meld_multiple ... ok
test test_meld_multiple_empty ... ok
test test_meld_with_empty ... ok
test test_persistent_semantics ... ok
test test_root_rank ... ok
test test_sequential_delete_all ... ok
test test_single_element_operations ... ok
test test_singleton ... ok
test test_split ... ok
test test_string_heap ... ok
test test_to_sorted_vec ... ok
test test_to_vec ... ok
test test_large_heap ... ok

test result: ok. 32 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/TestLibIntegration.rs (target/llvm-cov-target/debug/deps/TestLibIntegration-fa9d8669dd05b6dc)

running 4 tests
test test_all_chapters_compile ... ok
test test_module_accessibility ... ok
test test_macro_accessibility ... ok
test test_cross_chapter_compatibility ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap47clean/TestLinProbFlatHashTable.rs (target/llvm-cov-target/debug/deps/TestLinProbFlatHashTable-9ae34e3607d8f72d)

running 4 tests
test test_delete ... ok
test test_find_slot ... ok
test test_insert_and_lookup ... ok
test test_probe ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap47/TestLinearProbing.rs (target/llvm-cov-target/debug/deps/TestLinearProbing-4b6d96bfa709cf21)

running 13 tests
test test_create_linear_probing_integer_table ... ok
test test_create_linear_probing_string_table ... ok
test test_linear_probing_collision_handling ... ok
test test_linear_probing_insert_and_lookup ... ok
test test_linear_probing_integer_operations ... ok
test test_linear_probing_delete ... ok
test test_linear_probing_load_factor_management ... ok
test test_linear_probing_pattern_verification ... ok
test test_linear_probing_empty_operations ... ok
test test_linear_probing_strategy_creation ... ok
test test_linear_probing_update ... ok
test test_linear_probing_with_deletions_and_reinsertions ... ok
test test_linear_probing_resize_behavior ... ok

test result: ok. 13 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap47clean/TestLinkedListChainedHashTable.rs (target/llvm-cov-target/debug/deps/TestLinkedListChainedHashTable-8e7a2e3d57fc7f24)

running 6 tests
test test_linkedlist_chained_delete ... ok
test test_linkedlist_entry_delete ... ok
test test_linkedlist_chained_insert_lookup ... ok
test test_linkedlist_entry_insert ... ok
test test_linkedlist_entry_update ... ok
test test_linkedlist_entry_new ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap18/TestLinkedListStEph19.rs (target/llvm-cov-target/debug/deps/TestLinkedListStEph19-ee9a1248089ba16f)

running 5 tests
test test_eph_subseq_and_display_debug ... ok
test test_eph_set_and_nth ... ok
test test_deflate_filter_iterate_reduce_scan_flatten_inject_ch19 ... ok
test test_iter_inorder_collect_eph_ch19 ... ok
test test_tabulate_map_select_append_ch19 ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap18/TestLinkedListStEphChap18.rs (target/llvm-cov-target/debug/deps/TestLinkedListStEphChap18-a63e03d4bd80c3d0)

running 25 tests
test test_append_concatenation ... ok
test test_collect_group_by_key ... ok
test test_deflate_helper ... ok
test test_debug_format_for_eph ... ok
test test_display_format_for_eph ... ok
test test_empty_singleton_and_predicates ... ok
test test_equality_comparison ... ok
test test_filter_predicate ... ok
test test_flatten_nested_lists ... ok
test test_inject_first_update_wins ... ok
test test_iter_inorder_collect_eph ... ok
test test_iteratePrefixes_scan_like ... ok
test test_iterate_accumulate ... ok
test test_linkedlisteph_basic ... ok
test test_map_transform ... ok
test test_new_and_nth_set ... ok
test test_ninject_last_update_wins ... ok
test test_reduce_divide_conquer ... ok
test test_scan_prefix_sums ... ok
test test_nth_out_of_bounds_panics - should panic ... ok
test test_set_method ... ok
test test_subseq ... ok
test test_tabulate_constructor ... ok
test test_update_ephemeral ... ok
test test_subseq_copy_edge_cases ... ok

test result: ok. 25 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap18/TestLinkedListStEphChap18_Advanced.rs (target/llvm-cov-target/debug/deps/TestLinkedListStEphChap18_Advanced-11aeb70bb9e86fbb)

running 11 tests
test test_append_ch18 ... ok
test test_eph_is_empty_and_singleton ... ok
test test_construct_eph_from_vec ... ok
test test_filter_ch18 ... ok
test test_eph_set_and_subseq ... ok
test test_inject_and_ninject_ch18 ... ok
test test_iter_inorder_collect_eph_ch18 ... ok
test test_flatten_and_collect_ch18 ... ok
test test_iterate_reduce_scan_ch18 ... ok
test test_tabulate_and_map_ch18 ... ok
test test_update_ch18 ... ok

test result: ok. 11 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap18/TestLinkedListStPer19.rs (target/llvm-cov-target/debug/deps/TestLinkedListStPer19-48d4fe0905cc8c27)

running 8 tests
test test_append_variants ... ok
test test_deflate ... ok
test test_flatten ... ok
test test_iterate_and_reduce ... ok
test test_inject ... ok
test test_map ... ok
test test_scan ... ok
test test_select ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap18/TestLinkedListStPerChap18.rs (target/llvm-cov-target/debug/deps/TestLinkedListStPerChap18-0b8848ed1e53a2e2)

running 23 tests
test test_append_concatenation ... ok
test test_collect_group_by_key ... ok
test test_empty_singleton_and_predicates ... ok
test test_display_impl ... ok
test test_equality_comparison ... ok
test test_filter_predicate ... ok
test test_flatten_nested_lists ... ok
test test_from_vec_and_debug_format ... ok
test test_inject_first_update_wins ... ok
test test_iter_inorder_collect ... ok
test test_iteratePrefixes_scan_like ... ok
test test_iterate_accumulate ... ok
test test_map_transform ... ok
test test_new_and_nth_set ... ok
test test_ninject_last_update_wins ... ok
test test_reduce_divide_conquer ... ok
test test_nth_out_of_bounds_panics - should panic ... ok
test test_scan_prefix_sums ... ok
test test_select_from_concatenated ... ok
test test_subseq ... ok
test test_subseq_copy_edge_cases ... ok
test test_tabulate_constructor ... ok
test test_update_persistent ... ok

test result: ok. 23 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap18/TestLinkedListStPerChap18_Advanced.rs (target/llvm-cov-target/debug/deps/TestLinkedListStPerChap18_Advanced-cc396ad0c172a0e3)

running 12 tests
test test_append ... ok
test test_filter ... ok
test test_flatten ... ok
test test_collect ... ok
test test_map ... ok
test test_iterate ... ok
test test_inject ... ok
test test_ninject ... ok
test test_reduce ... ok
test test_scan ... ok
test test_tabulate ... ok
test test_update ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap05/TestMappingStEph.rs (target/llvm-cov-target/debug/deps/TestMappingStEph-fbab7e259ecb0cc5)

running 12 tests
test test_from_relation_empty_edge ... ok
test test_empty_mapping ... ok
test test_empty_mapping_operations ... ok
test test_from_relation ... ok
test test_domain_and_range ... ok
test test_from_vec_basic ... ok
test test_iter ... ok
test test_from_vec_duplicate_keys - should panic ... ok
test test_mapping_extreme_values_graceful ... ok
test test_mappinglit_macro_functionality ... ok
test test_mem_comprehensive ... ok
test test_mapping_large_dataset_stress ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.02s

     Running tests/Chap18/TestMathSeq.rs (target/llvm-cov-target/debug/deps/TestMathSeq-3580eff23cb2262e)

running 32 tests
test test_iter_collect_and_sum ... ok
test test_iter_mut_modify ... ok
test test_from_vec_constructor ... ok
test test_into_iter_consume ... ok
test test_domain_empty_is_empty ... ok
test test_equality_comparison ... ok
test test_length_and_nth_basic ... ok
test test_domain ... ok
test test_isEmpty_predicate ... ok
test test_debug_format_for_mathseq ... ok
test test_isSingleton_predicate ... ok
test test_display_format_for_mathseq ... ok
test test_add_last_and_delete_last ... ok
test test_mathseq_iterator_boundaries ... ok
test test_mathseq_empty_operations_comprehensive ... ok
test test_mathseq_nth_panic_empty - should panic ... ok
test test_mathseq_nth_panic_outofbounds - should panic ... ok
test test_mathseq_zero_length_operations ... ok
test test_mathseq_subseq_overflow_graceful ... ok
test test_mathseq_single_element_boundary ... ok
test test_new_empty_singleton_and_predicates ... ok
test test_nth_out_of_bounds_panics - should panic ... ok
test test_range_deduplicates_preserving_order ... ok
test test_multiset_range_counts_first_occurrence_order ... ok
test test_set_out_of_bounds_error ... ok
test test_multiset_range_empty_returns_empty ... ok
test test_range_empty_returns_empty ... ok
test test_subseq_bounds ... ok
test test_subseq_view_bounds ... ok
test test_set_in_bounds_and_out_of_bounds ... ok
test test_with_len_constructor ... ok
test test_mathseq_maximum_size_boundary ... ok

test result: ok. 32 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/TestMatrixChain.rs (target/llvm-cov-target/debug/deps/TestMatrixChain-e131083fd57e4b39)

running 14 tests
test matrix_chain_tests::test_matrix_chain_large_example ... ok
test matrix_chain_tests::test_matrix_chain_macro ... ok
test matrix_chain_tests::test_matrix_chain_multiply_cost ... ok
test matrix_chain_tests::test_matrix_chain_st_eph_single_matrix ... ok
test matrix_chain_tests::test_matrix_chain_st_eph_mutation ... ok
test matrix_chain_tests::test_matrix_chain_st_eph_empty ... ok
test matrix_chain_tests::test_matrix_chain_st_eph_iteration ... ok
test matrix_chain_tests::test_matrix_chain_st_per_empty ... ok
test matrix_chain_tests::test_matrix_chain_st_per_iteration ... ok
test matrix_chain_tests::test_matrix_chain_st_per_from_dim_pairs ... ok
test matrix_chain_tests::test_matrix_chain_st_per_single_matrix ... ok
test matrix_chain_tests::test_matrix_chain_st_per_three_matrices ... ok
test matrix_chain_tests::test_matrix_chain_st_per_two_matrices ... ok
test matrix_chain_tests::test_matrix_dim_display ... ok

test result: ok. 14 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap50/TestMatrixChainMtEph.rs (target/llvm-cov-target/debug/deps/TestMatrixChainMtEph-16ec134381b12c42)

running 22 tests
test test_clear_memo ... ok
test test_clone ... ok
test test_dimension_consistency ... ok
test test_dimensions ... ok
test test_empty_chain ... ok
test test_display ... ok
test test_equality ... ok
test test_from_dim_pairs ... ok
test test_from_dimensions ... ok
test test_matrixchainmtephlit_macro_functionality ... ok
test test_matrixdim_equality ... ok
test test_new ... ok
test test_optimal_cost_two_matrices ... ok
test test_memo_size ... ok
test test_update_dimension ... ok
test test_set_dimension ... ok
test test_optimal_cost_three_matrices ... ok
test test_memoization_reuse ... ok
test test_parallel_execution ... ok
test test_single_matrix ... ok
test test_four_matrices ... ok
test test_large_chain ... ok

test result: ok. 22 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap50/TestMatrixChainMtPer.rs (target/llvm-cov-target/debug/deps/TestMatrixChainMtPer-608084cd1aaf80bc)

running 20 tests
test test_clone ... ok
test test_dimension_consistency ... ok
test test_dimensions ... ok
test test_display ... ok
test test_empty_chain ... ok
test test_equality ... ok
test test_from_dim_pairs ... ok
test test_from_dimensions ... ok
test test_matrixchainmtperlit_macro_functionality ... ok
test test_matrixdim_clone ... ok
test test_new ... ok
test test_num_matrices ... ok
test test_optimal_cost_two_matrices ... ok
test test_optimal_cost_three_matrices ... ok
test test_persistent_semantics ... ok
test test_single_matrix ... ok
test test_concurrent_reads ... ok
test test_parallel_execution ... ok
test test_four_matrices ... ok
test test_large_chain ... ok

test result: ok. 20 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap50/TestMatrixChainStEph.rs (target/llvm-cov-target/debug/deps/TestMatrixChainStEph-d0d746ad4a49fdf3)

running 12 tests
test test_clear_memo ... ok
test test_dimensions ... ok
test test_dimensions_mut ... ok
test test_from_dim_pairs ... ok
test test_from_dimensions ... ok
test test_matrixchainstephlit_macro_functionality ... ok
test test_memo_size ... ok
test test_new ... ok
test test_num_matrices ... ok
test test_optimal_cost ... ok
test test_set_dimension ... ok
test test_update_dimension ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap50/TestMatrixChainStPer.rs (target/llvm-cov-target/debug/deps/TestMatrixChainStPer-2f77267228e8ab94)

running 11 tests
test test_compute_multiplication ... ok
test test_from_dim_pairs ... ok
test test_empty_chain ... ok
test test_dimensions ... ok
test test_from_dimensions ... ok
test test_large_chain ... ok
test test_matrixchainstperlit_macro_functionality ... ok
test test_new ... ok
test test_optimal_cost_three_matrices ... ok
test test_optimal_cost_two_matrices ... ok
test test_single_matrix ... ok

test result: ok. 11 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap28/TestMaxContigSubSumBruteStEph.rs (target/llvm-cov-target/debug/deps/TestMaxContigSubSumBruteStEph-b73bf298702f8273)

running 9 tests
test test_empty ... ok
test test_all_negative ... ok
test test_all_positive ... ok
test test_ends_negative ... ok
test test_example_from_book ... ok
test test_single_negative ... ok
test test_single_positive ... ok
test test_starts_negative ... ok
test test_zero_elements ... ok

test result: ok. 9 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap28/TestMaxContigSubSumDivConMtEph.rs (target/llvm-cov-target/debug/deps/TestMaxContigSubSumDivConMtEph-76791eca4be137e0)

running 6 tests
test test_single_positive ... ok
test test_empty ... ok
test test_all_positive ... ok
test test_crossing_middle ... ok
test test_all_negative ... ok
test test_example_from_book ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap28/TestMaxContigSubSumDivConOptMtEph.rs (target/llvm-cov-target/debug/deps/TestMaxContigSubSumDivConOptMtEph-be7549c9df24ee95)

running 6 tests
test test_empty ... ok
test test_single_positive ... ok
test test_all_negative ... ok
test test_all_positive ... ok
test test_larger_example ... ok
test test_example_from_book ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap28/TestMaxContigSubSumDivConOptStEph.rs (target/llvm-cov-target/debug/deps/TestMaxContigSubSumDivConOptStEph-a5f70d3654a3a647)

running 6 tests
test test_example_from_book ... ok
test test_all_negative ... ok
test test_empty ... ok
test test_all_positive ... ok
test test_single_positive ... ok
test test_larger_example ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap28/TestMaxContigSubSumDivConStEph.rs (target/llvm-cov-target/debug/deps/TestMaxContigSubSumDivConStEph-1931b3e058fb9624)

running 6 tests
test test_all_negative ... ok
test test_all_positive ... ok
test test_crossing_middle ... ok
test test_empty ... ok
test test_example_from_book ... ok
test test_single_positive ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap28/TestMaxContigSubSumOptMtEph.rs (target/llvm-cov-target/debug/deps/TestMaxContigSubSumOptMtEph-dd7ed6aee726f507)

running 6 tests
test test_all_negative ... ok
test test_example_from_book ... ok
test test_all_positive ... ok
test test_larger_example ... ok
test test_empty ... ok
test test_single_positive ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap28/TestMaxContigSubSumOptStEph.rs (target/llvm-cov-target/debug/deps/TestMaxContigSubSumOptStEph-835812ee52949b89)

running 6 tests
test test_all_negative ... ok
test test_all_positive ... ok
test test_empty ... ok
test test_example_from_book ... ok
test test_larger_example ... ok
test test_single_positive ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap28/TestMaxContigSubSumReducedStEph.rs (target/llvm-cov-target/debug/deps/TestMaxContigSubSumReducedStEph-c0b01aeeb6d2093c)

running 5 tests
test test_all_negative ... ok
test test_empty ... ok
test test_all_positive ... ok
test test_example_from_book ... ok
test test_single_positive ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap26/TestMergeSortMt.rs (target/llvm-cov-target/debug/deps/TestMergeSortMt-8a9b5b2d8572bc1d)

running 5 tests
test test_merge_sort_mt::test_merge_sort_parallel_empty ... ok
test test_merge_sort_mt::test_merge_sort_parallel_single ... ok
test test_merge_sort_mt::test_merge_parallel ... ok
test test_merge_sort_mt::test_merge_sort_parallel_sorted ... ok
test test_merge_sort_mt::test_merge_sort_parallel_reverse ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s

     Running tests/Chap26/TestMergeSortSt.rs (target/llvm-cov-target/debug/deps/TestMergeSortSt-26c4a17fb4bf3258)

running 8 tests
test test_merge_sort_st::test_merge_one_empty ... ok
test test_merge_sort_st::test_merge_sort_empty ... ok
test test_merge_sort_st::test_merge_empty ... ok
test test_merge_sort_st::test_merge_sort_duplicates ... ok
test test_merge_sort_st::test_merge_sort_single ... ok
test test_merge_sort_st::test_merge_sort_reverse ... ok
test test_merge_sort_st::test_merge_sort_sorted ... ok
test test_merge_sort_st::test_merge_sorted ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/TestMinEditDist.rs (target/llvm-cov-target/debug/deps/TestMinEditDist-dbb202f44c00e262)

running 17 tests
test tests::test_min_edit_distance_accessors ... ok
test tests::test_min_edit_distance_display ... ok
test tests::test_min_edit_distance_edge_cases ... ok
test tests::test_min_edit_distance_equality ... ok
test tests::test_min_edit_distance_iterator ... ok
test tests::test_min_edit_distance_eph_mutation ... ok
test tests::test_min_edit_distance_memoization ... ok
test tests::test_min_edit_distance_longer_sequences ... ok
test tests::test_min_edit_distance_numeric_sequences ... ok
test tests::test_min_edit_distance_st_eph_basic ... ok
test tests::test_min_edit_distance_st_per_example_49_3 ... ok
test tests::test_min_edit_distance_st_per_basic ... ok
test tests::test_min_edit_distance_st_per_single_operations ... ok
test tests::test_min_edit_distance_string_sequences ... ok
test tests::test_min_edit_distance_mt_eph_basic ... ok
test tests::test_min_edit_distance_mt_per_basic ... ok
test tests::test_min_edit_distance_mt_thread_safety ... ok

test result: ok. 17 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s

     Running tests/Chap49/TestMinEditDistMtEph.rs (target/llvm-cov-target/debug/deps/TestMinEditDistMtEph-abff72d735c85774)

running 25 tests
test test_empty_both ... ok
test test_from_sequences ... ok
test test_empty_to_nonempty ... ok
test test_concurrent_reads ... ok
test test_identical_strings ... ok
test test_equality ... ok
test test_deletion ... ok
test test_inequality ... ok
test test_nonempty_to_empty ... ok
test test_new_empty ... ok
test test_insertion ... ok
test test_source_mut ... ok
test test_target_accessor ... ok
test test_target_mut ... ok
test test_set_source ... ok
test test_set_target ... ok
test test_single_char_same ... ok
test test_source_accessor ... ok
test test_completely_different ... ok
test test_single_substitution ... ok
test test_string_sequences ... ok
test test_memo_size ... ok
test test_clear_memo ... ok
test test_prefix_match ... ok
test test_integer_sequences ... ok

test result: ok. 25 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s

     Running tests/Chap49/TestMinEditDistMtPer.rs (target/llvm-cov-target/debug/deps/TestMinEditDistMtPer-3ee790c57190a87d)

running 5 tests
test test_empty_to_nonempty ... ok
test test_identical_strings ... ok
test test_from_sequences ... ok
test test_new_empty ... ok
test test_single_substitution ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap49/TestMinEditDistStEph.rs (target/llvm-cov-target/debug/deps/TestMinEditDistStEph-8fbabc929f035e6a)

running 29 tests
test test_empty_both ... ok
test test_completely_different ... ok
test test_deletion ... ok
test test_clear_memo ... ok
test test_empty_to_nonempty ... ok
test test_classic_kitten_sitting ... ok
test test_from_sequences ... ok
test test_identical_strings ... ok
test test_insertion ... ok
test test_integer_sequences ... ok
test test_memo_size ... ok
test test_nonempty_to_empty ... ok
test test_prefix_match ... ok
test test_new_empty ... ok
test test_memoization_efficiency ... ok
test test_saturday_sunday ... ok
test test_set_source ... ok
test test_set_target ... ok
test test_single_char_same ... ok
test test_single_char_strings ... ok
test test_source_accessor ... ok
test test_single_substitution ... ok
test test_source_mut ... ok
test test_string_sequences ... ok
test test_suffix_match ... ok
test test_target_accessor ... ok
test test_target_mut ... ok
test test_update_and_recompute ... ok
test test_large_sequences ... ok

test result: ok. 29 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap49/TestMinEditDistStPer.rs (target/llvm-cov-target/debug/deps/TestMinEditDistStPer-fb4deb54c1da6a79)

running 5 tests
test test_empty_to_nonempty ... ok
test test_from_sequences ... ok
test test_identical_strings ... ok
test test_new_empty ... ok
test test_single_substitution ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap47/TestNestedHashTable.rs (target/llvm-cov-target/debug/deps/TestNestedHashTable-5a9efa6715277e59)

running 1 test
test test_nestedhashtablelit_macro_functionality ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap50/TestOBSTMtEph.rs (target/llvm-cov-target/debug/deps/TestOBSTMtEph-aedc2572f14db919)

running 25 tests
test test_clone ... ok
test test_display ... ok
test test_empty_tree ... ok
test test_from_key_probs ... ok
test test_equality ... ok
test test_into_iter ... ok
test test_from_keys_probs ... ok
test test_into_iter_ref ... ok
test test_keyprob_display ... ok
test test_keys_method ... ok
test test_new ... ok
test test_num_keys ... ok
test test_obstmtephlit_macro_functionality ... ok
test test_num_keys_method ... ok
test test_optimal_cost_single_key ... ok
test test_memo_size ... ok
test test_set_key_prob ... ok
test test_optimal_cost_two_keys ... ok
test test_update_prob ... ok
test test_clear_memo ... ok
test test_parallel_execution ... ok
test test_optimal_cost_three_keys ... ok
test test_skewed_probabilities ... ok
test test_uniform_probabilities ... ok
test test_large_tree ... ok

test result: ok. 25 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s

     Running tests/Chap50/TestOBSTMtPer.rs (target/llvm-cov-target/debug/deps/TestOBSTMtPer-5f0b68581554d178)

running 13 tests
test test_obst_empty ... ok
test test_obst_display ... ok
test test_obst_equality ... ok
test test_obst_iterability ... ok
test test_obst_single_key ... ok
test test_obst_from_key_probs ... ok
test test_obst_two_keys ... ok
test test_obst_from_keys_probs ... ok
test test_obst_skewed_probabilities ... ok
test test_obst_three_keys ... ok
test test_obst_memo_cache ... ok
test test_obst_four_keys_equal_probs ... ok
test test_obst_five_keys ... ok

test result: ok. 13 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s

     Running tests/TestOptBinSearchTree.rs (target/llvm-cov-target/debug/deps/TestOptBinSearchTree-07242138592c7567)

running 12 tests
test obst_tests::test_obst_key_prob_display ... ok
test obst_tests::test_obst_iteration ... ok
test obst_tests::test_obst_probability_arithmetic ... ok
test obst_tests::test_obst_macro ... ok
test obst_tests::test_obst_large_example ... ok
test obst_tests::test_obst_st_eph_empty ... ok
test obst_tests::test_obst_st_eph_mutation ... ok
test obst_tests::test_obst_st_eph_single_key ... ok
test obst_tests::test_obst_st_per_empty ... ok
test obst_tests::test_obst_st_per_single_key ... ok
test obst_tests::test_obst_st_per_three_keys ... ok
test obst_tests::test_obst_st_per_two_keys ... ok

test result: ok. 12 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap50/TestOptBinSearchTreeStEph.rs (target/llvm-cov-target/debug/deps/TestOptBinSearchTreeStEph-85a87d6e53d13c84)

running 32 tests
test test_empty_keys ... ok
test test_from_key_probs ... ok
test test_from_keys_probs ... ok
test test_clear_memo ... ok
test test_key_prob_clone ... ok
test test_key_prob_debug ... ok
test test_key_prob_display ... ok
test test_key_prob_equality ... ok
test test_keys_method ... ok
test test_keys_mut_method ... ok
test test_memo_size ... ok
test test_new_empty_obst ... ok
test test_num_keys ... ok
test test_obst_clone ... ok
test test_obst_equality ... ok
test test_obststephlit_macro_empty ... ok
test test_obststephlit_macro_multiple_keys ... ok
test test_obststephlit_macro_single_key ... ok
test test_obststephlit_macro_string_keys ... ok
test test_obststephlit_macro_trailing_comma ... ok
test test_optimal_cost_three_keys ... ok
test test_optimal_cost_two_keys ... ok
test test_optimal_cost_memoization ... ok
test test_optimal_cost_single_key ... ok
test test_update_prob ... ok
test test_string_keys ... ok
test test_large_tree ... ok
test test_update_after_cost_computation ... ok
test test_skewed_probabilities ... ok
test test_set_key_prob ... ok
test test_zero_probability ... ok
test test_optimal_cost_uniform_probs ... ok

test result: ok. 32 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap50/TestOptBinSearchTreeStPer.rs (target/llvm-cov-target/debug/deps/TestOptBinSearchTreeStPer-617ae2e1607d12f1)

running 15 tests
test test_clone ... ok
test test_from_key_probs ... ok
test test_empty_keys ... ok
test test_equality ... ok
test test_keys_method ... ok
test test_from_keys_probs ... ok
test test_new_empty_obst ... ok
test test_memo_size ... ok
test test_num_keys ... ok
test test_optimal_cost_single_key ... ok
test test_optimal_cost_three_keys ... ok
test test_optimal_cost_two_keys ... ok
test test_persistent_nature ... ok
test test_string_keys ... ok
test test_skewed_probabilities ... ok

test result: ok. 15 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap35/TestOrderStatSelectMtEph.rs (target/llvm-cov-target/debug/deps/TestOrderStatSelectMtEph-72ca8221e619ac5b)

running 8 tests
test test_empty ... ok
test test_already_sorted ... ok
test test_duplicates ... ok
test test_single ... ok
test test_mixed ... ok
test test_reverse_sorted ... ok
test test_negative ... ok
test test_small ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap35/TestOrderStatSelectMtPer.rs (target/llvm-cov-target/debug/deps/TestOrderStatSelectMtPer-cc2d341b4c5f4661)

running 8 tests
test test_empty ... ok
test test_duplicates ... ok
test test_single ... ok
test test_already_sorted ... ok
test test_negative ... ok
test test_mixed ... ok
test test_reverse_sorted ... ok
test test_small ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap35/TestOrderStatSelectStEph.rs (target/llvm-cov-target/debug/deps/TestOrderStatSelectStEph-55d714ab181a0cb2)

running 8 tests
test test_empty ... ok
test test_single ... ok
test test_duplicates ... ok
test test_already_sorted ... ok
test test_mixed ... ok
test test_negative ... ok
test test_reverse_sorted ... ok
test test_small ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap35/TestOrderStatSelectStPer.rs (target/llvm-cov-target/debug/deps/TestOrderStatSelectStPer-aec3499c51570746)

running 8 tests
test test_empty ... ok
test test_already_sorted ... ok
test test_duplicates ... ok
test test_single ... ok
test test_negative ... ok
test test_reverse_sorted ... ok
test test_mixed ... ok
test test_small ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap43/TestOrderedSetMtEph.rs (target/llvm-cov-target/debug/deps/TestOrderedSetMtEph-4972d575a962a040)

running 23 tests
test test_delete ... ok
test test_empty ... ok
test test_difference ... ok
test test_filter ... ok
test test_first_and_last ... ok
test test_get_range ... ok
test test_insert_and_find ... ok
test test_ephemeral_semantics ... ok
test test_intersection ... ok
test test_join ... ok
test test_large_dataset_performance ... ok
test test_next ... ok
test test_ordered_set_mt_eph_lit_macro ... ok
test test_previous ... ok
test test_parallel_operations ... ok
test test_rank ... ok
test test_select ... ok
test test_singleton ... ok
test test_split ... ok
test test_split_rank ... ok
test test_string_ordering ... ok
test test_union ... ok
test test_thread_safety ... ok

test result: ok. 23 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap43/TestOrderedSetStEph.rs (target/llvm-cov-target/debug/deps/TestOrderedSetStEph-f941fa20fb255d43)

running 20 tests
test test_delete ... ok
test test_empty ... ok
test test_difference ... ok
test test_filter ... ok
test test_first_and_last ... ok
test test_get_range ... ok
test test_ephemeral_semantics ... ok
test test_insert_and_find ... ok
test test_intersection ... ok
test test_join ... ok
test test_ordered_set_st_eph_lit_macro ... ok
test test_next ... ok
test test_previous ... ok
test test_rank ... ok
test test_select ... ok
test test_singleton ... ok
test test_split ... ok
test test_split_rank ... ok
test test_string_ordering ... ok
test test_union ... ok

test result: ok. 20 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap43/TestOrderedSetStPer.rs (target/llvm-cov-target/debug/deps/TestOrderedSetStPer-c0beda141c57ad4f)

running 20 tests
test test_empty ... ok
test test_delete ... ok
test test_filter ... ok
test test_difference ... ok
test test_insert_and_find ... ok
test test_intersection ... ok
test test_get_range ... ok
test test_join ... ok
test test_next ... ok
test test_ordered_set_st_per_lit_macro ... ok
test test_persistence ... ok
test test_first_and_last ... ok
test test_previous ... ok
test test_rank ... ok
test test_singleton ... ok
test test_select ... ok
test test_split ... ok
test test_string_ordering ... ok
test test_union ... ok
test test_split_rank ... ok

test result: ok. 20 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap43/TestOrderedTableMtEph.rs (target/llvm-cov-target/debug/deps/TestOrderedTableMtEph-6505522995487830)

running 40 tests
test test_delete_nonexistent ... ok
test test_ordered_table_mt_eph_clone ... ok
test test_ordered_table_mt_eph_collect ... ok
test test_ordered_table_mt_eph_difference_empty ... ok
test test_ordered_table_mt_eph_domain ... ok
test test_ordered_table_mt_eph_difference ... ok
test test_ordered_table_mt_eph_domain_empty ... ok
test test_ordered_table_mt_eph_delete ... ok
test test_ordered_table_mt_eph_empty_operations ... ok
test test_ordered_table_mt_eph_find ... ok
test test_ordered_table_mt_eph_first_key ... ok
test test_ordered_table_mt_eph_from_sorted_entries ... ok
test test_ordered_table_mt_eph_insert_and_lookup ... ok
test test_ordered_table_mt_eph_get_key_range ... ok
test test_ordered_table_mt_eph_ephemeral_semantics ... ok
test test_ordered_table_mt_eph_intersection ... ok
test test_ordered_table_mt_eph_intersection_disjoint ... ok
test test_ordered_table_mt_eph_join_key ... ok
test test_ordered_table_mt_eph_new ... ok
test test_ordered_table_mt_eph_last_key ... ok
test test_ordered_table_mt_eph_next_key ... ok
test test_ordered_table_mt_eph_previous_key ... ok
test test_ordered_table_mt_eph_reduce_sum ... ok
test test_ordered_table_mt_eph_rank_key ... ok
test test_ordered_table_mt_eph_singleton ... ok
test test_ordered_table_mt_eph_split_rank_key ... ok
test test_ordered_table_mt_eph_select_key ... ok
test test_ordered_table_mt_eph_restrict ... ok
test test_ordered_table_mt_eph_split_key ... ok
test test_ordered_table_mt_eph_union ... ok
test test_ordered_table_mt_eph_union_empty ... ok
test test_ordered_table_mt_eph_tabulate_empty ... ok
test test_ordered_table_mt_eph_subtract_empty_keys ... ok
test test_ordered_table_mt_eph_subtract ... ok
test test_ordered_table_mt_eph_restrict_empty_keys ... ok
test test_ordered_table_mt_eph_reduce_empty ... ok
test test_ordered_table_mt_eph_tabulate ... ok
test test_ordered_table_mt_eph_thread_safety ... ok
test test_ordered_table_mt_eph_parallel_operations ... ok
test test_ordered_table_mt_eph_large_dataset_parallel ... ok

test result: ok. 40 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.02s

     Running tests/Chap43/TestOrderedTableMtPer.rs (target/llvm-cov-target/debug/deps/TestOrderedTableMtPer-1e459c7f8933ba9b)

running 8 tests
test test_ordered_table_mt_per_delete ... ok
test test_ordered_table_mt_per_filter ... ok
test test_ordered_table_mt_per_singleton ... ok
test test_ordered_table_mt_per_insert_and_find ... ok
test test_ordered_table_mt_per_persistence ... ok
test test_ordered_table_mt_per_domain ... ok
test test_ordered_table_mt_per_map ... ok
test test_ordered_table_mt_per_new ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap43/TestOrderedTableStEph.rs (target/llvm-cov-target/debug/deps/TestOrderedTableStEph-107557e9befb3295)

running 41 tests
test test_ordered_table_st_eph_clone ... ok
test test_delete_nonexistent ... ok
test test_ordered_table_st_eph_delete ... ok
test test_ordered_table_st_eph_collect ... ok
test test_ordered_table_st_eph_difference_empty ... ok
test test_ordered_table_st_eph_difference ... ok
test test_ordered_table_st_eph_domain ... ok
test test_ordered_table_st_eph_empty_operations ... ok
test test_ordered_table_st_eph_domain_empty ... ok
test test_ordered_table_st_eph_filter ... ok
test test_ordered_table_st_eph_find ... ok
test test_ordered_table_st_eph_ephemeral_semantics ... ok
test test_ordered_table_st_eph_first_key ... ok
test test_ordered_table_st_eph_from_sorted_entries ... ok
test test_ordered_table_st_eph_get_key_range ... ok
test test_ordered_table_st_eph_insert_and_lookup ... ok
test test_ordered_table_st_eph_intersection_disjoint ... ok
test test_ordered_table_st_eph_join_key ... ok
test test_ordered_table_st_eph_intersection ... ok
test test_ordered_table_st_eph_last_key ... ok
test test_ordered_table_st_eph_map ... ok
test test_ordered_table_st_eph_new ... ok
test test_ordered_table_st_eph_next_key ... ok
test test_ordered_table_st_eph_previous_key ... ok
test test_ordered_table_st_eph_rank_key ... ok
test test_ordered_table_st_eph_reduce ... ok
test test_ordered_table_st_eph_reduce_empty ... ok
test test_ordered_table_st_eph_reduce_sum ... ok
test test_ordered_table_st_eph_restrict ... ok
test test_ordered_table_st_eph_restrict_empty_keys ... ok
test test_ordered_table_st_eph_select_key ... ok
test test_ordered_table_st_eph_singleton ... ok
test test_ordered_table_st_eph_split_key ... ok
test test_ordered_table_st_eph_split_rank_key ... ok
test test_ordered_table_st_eph_subtract ... ok
test test_ordered_table_st_eph_subtract_empty_keys ... ok
test test_ordered_table_st_eph_tabulate ... ok
test test_ordered_table_st_eph_tabulate_empty ... ok
test test_ordered_table_st_eph_union ... ok
test test_ordered_table_st_eph_union_empty ... ok
test test_ordered_table_st_eph_large_dataset ... ok

test result: ok. 41 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s

     Running tests/Chap43/TestOrderedTableStPer.rs (target/llvm-cov-target/debug/deps/TestOrderedTableStPer-8e6a2dd5591b4ab4)

running 30 tests
test test_collect ... ok
test test_difference ... ok
test test_delete ... ok
test test_delete_nonexistent ... ok
test test_empty_operations ... ok
test test_domain ... ok
test test_filter ... ok
test test_empty ... ok
test test_first_key_and_last_key ... ok
test test_get_key_range ... ok
test test_insert_and_find ... ok
test test_insert_duplicate_key ... ok
test test_intersection ... ok
test test_join_key ... ok
test test_map ... ok
test test_next_key ... ok
test test_ordered_table_st_per_lit_macro ... ok
test test_previous_key ... ok
test test_rank_key ... ok
test test_restrict ... ok
test test_select_key ... ok
test test_singleton ... ok
test test_persistence ... ok
test test_split_key ... ok
test test_string_key_ordering ... ok
test test_subtract ... ok
test test_split_rank_key ... ok
test test_tabulate ... ok
test test_union ... ok
test test_large_dataset ... ok

test result: ok. 30 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap53/TestPQMinMtEph.rs (target/llvm-cov-target/debug/deps/TestPQMinMtEph-3bd5ee0acc2912df)

running 7 tests
test test_pq_min_cycle ... ok
test test_pq_min_empty_graph ... ok
test test_pq_min_linear_chain ... ok
test test_pq_min_multi_source ... ok
test test_pq_min_single_edge ... ok
test test_pq_min_dag ... ok
test test_pq_min_priority_order ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap53/TestPQMinMtPer.rs (target/llvm-cov-target/debug/deps/TestPQMinMtPer-bfa8a43a01103fe9)

running 13 tests
test test_pq_min_custom_priority ... ok
test test_pq_min_cycle ... ok
test test_pq_min_disconnected_graph ... ok
test test_pq_min_complete_graph ... ok
test test_pq_min_binary_tree ... ok
test test_pq_min_empty_graph ... ok
test test_pq_min_multi_source ... ok
test test_pq_min_self_loop ... ok
test test_pq_min_single_edge ... ok
test test_pq_min_priority_order ... ok
test test_pq_min_linear_chain ... ok
test test_pq_min_dag ... ok
test test_pq_min_star_graph ... ok

test result: ok. 13 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap53/TestPQMinStEph.rs (target/llvm-cov-target/debug/deps/TestPQMinStEph-1843792964c67657)

running 13 tests
test test_pq_min_cycle ... ok
test test_pq_min_custom_priority ... ok
test test_pq_min_empty_graph ... ok
test test_pq_min_complete_graph ... ok
test test_pq_min_binary_tree ... ok
test test_pq_min_disconnected_graph ... ok
test test_pq_min_dag ... ok
test test_pq_min_linear_chain ... ok
test test_pq_min_multi_source ... ok
test test_pq_min_self_loop ... ok
test test_pq_min_priority_order ... ok
test test_pq_min_single_edge ... ok
test test_pq_min_star_graph ... ok

test result: ok. 13 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap53/TestPQMinStPer.rs (target/llvm-cov-target/debug/deps/TestPQMinStPer-a58873ae61c6f743)

running 7 tests
test test_pq_min_cycle ... ok
test test_pq_min_empty_graph ... ok
test test_pq_min_single_edge ... ok
test test_pq_min_multi_source ... ok
test test_pq_min_linear_chain ... ok
test test_pq_min_priority_order ... ok
test test_pq_min_dag ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap47clean/TestParaHashTableStEph.rs (target/llvm-cov-target/debug/deps/TestParaHashTableStEph-f09af204508bb79e)

running 4 tests
test test_createtable ... ok
test test_loadandsize_empty ... ok
test test_metrics ... ok
test test_loadandsize_with_elements ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap56/TestPathWeightUtilsStEph.rs (target/llvm-cov-target/debug/deps/TestPathWeightUtilsStEph-4556fcc7a5a30a41)

running 5 tests
test TestPathWeightUtilsStEph::test_path_weight_int_negative ... ok
test TestPathWeightUtilsStEph::test_path_weight_int_simple ... ok
test TestPathWeightUtilsStEph::test_path_weight_float_simple ... ok
test TestPathWeightUtilsStEph::test_validate_subpath_int ... ok
test TestPathWeightUtilsStEph::test_validate_subpath_float ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap56/TestPathWeightUtilsStPer.rs (target/llvm-cov-target/debug/deps/TestPathWeightUtilsStPer-8f121d4bf4d45098)

running 5 tests
test TestPathWeightUtilsStPer::test_path_weight_float_simple ... ok
test TestPathWeightUtilsStPer::test_path_weight_int_negative ... ok
test TestPathWeightUtilsStPer::test_validate_subpath_int ... ok
test TestPathWeightUtilsStPer::test_path_weight_int_simple ... ok
test TestPathWeightUtilsStPer::test_validate_subpath_float ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap65/TestPrimStEph.rs (target/llvm-cov-target/debug/deps/TestPrimStEph-ef424b3d128917ff)

running 6 tests
test tests::test_prim_single_vertex ... ok
test tests::test_prim_star_graph ... ok
test tests::test_prim_square ... ok
test tests::test_prim_triangle ... ok
test tests::test_prim_different_start ... ok
test tests::test_prim_complete_graph ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap23/TestPrimTreeSeqSt.rs (target/llvm-cov-target/debug/deps/TestPrimTreeSeqSt-eb977034af559587)

running 27 tests
test expose_then_join_roundtrip ... ok
test expose_zero_returns_zero ... ok
test expose_two_splits_sequence ... ok
test expose_one_returns_one ... ok
test join_zero_creates_empty_sequence ... ok
test join_two_concatenates_sequences ... ok
test test_as_slice ... ok
test test_as_slice_view ... ok
test test_clone_functionality ... ok
test test_debug_format ... ok
test test_empty ... ok
test test_empty_constructor ... ok
test test_equality_comparison ... ok
test test_expose_edge_cases ... ok
test test_from_vec ... ok
test test_from_vec_constructor ... ok
test test_into_vec ... ok
test test_into_vec_conversion ... ok
test test_join_empty_sequences ... ok
test test_join_mixed_sizes ... ok
test test_join_one_variant ... ok
test test_length ... ok
test test_large_sequence_expose_join ... ok
test test_length_method ... ok
test test_singleton ... ok
test test_singleton_constructor ... ok
test test_tree_enum_equality ... ok

test result: ok. 27 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap50/TestProbability.rs (target/llvm-cov-target/debug/deps/TestProbability-647c9b89c822dbe6)

running 14 tests
test test_add ... ok
test test_clone ... ok
test test_debug ... ok
test test_display ... ok
test test_div ... ok
test test_eq ... ok
test test_infinity ... ok
test test_infinity_operations ... ok
test test_mul ... ok
test test_new ... ok
test test_ord ... ok
test test_sub ... ok
test test_zero ... ok
test test_zero_operations ... ok

test result: ok. 14 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap47/TestProbeSequenceExamples.rs (target/llvm-cov-target/debug/deps/TestProbeSequenceExamples-768cde96844dfc52)

running 17 tests
test test_analyze_double_hashing ... ok
test test_analyze_linear_probing ... ok
test test_collision_pattern_analysis ... ok
test test_analyzer_configurations ... ok
test test_analyze_quadratic_probing ... ok
test test_comprehensive_probe_sequence_comparison ... ok
test test_compare_probing_strategies ... ok
test test_edge_cases_small_tables ... ok
test test_example_47_4_linear_probing_clustering ... ok
test test_example_47_5_quadratic_probing_prime_table ... ok
test test_probe_sequence_analyzer_creation ... ok
test test_prime_vs_composite_table_comparison ... ok
test test_example_47_6_double_hashing_optimal ... ok
test test_probe_sequence_visualization_properties ... ok
test test_different_key_patterns ... ok
test test_comprehensive_probe_sequence_integration ... ok
test test_load_factor_impact_analysis ... ok

test result: ok. 17 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap21/TestProblem_21_1.rs (target/llvm-cov-target/debug/deps/TestProblem_21_1-c151abffbc9f00db)

running 5 tests
test test_points2d_debug_display_shapes ... ok
test test_points2d_iterator_in_order ... ok
test test_points2d_n1_empty ... ok
test test_points2d_n2_basic_values ... ok
test test_points2d_n3_example ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap21/TestProblem_21_3.rs (target/llvm-cov-target/debug/deps/TestProblem_21_3-18bfc69ae6138ef5)

running 5 tests
test test_points3d_loops_n0_empty ... ok
test test_points3d_loops_debug_shape ... ok
test test_points3d_loops_n1_single ... ok
test test_points3d_loops_n2_values_and_order ... ok
test test_points3d_loops_iterator_order ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap21/TestProblem_21_4.rs (target/llvm-cov-target/debug/deps/TestProblem_21_4-978c1e8b56ffc629)

running 4 tests
test test_cartesian_debug_shape ... ok
test test_cartesian_tab_flat_basic ... ok
test test_cartesian_loops_basic ... ok
test test_cartesian_iterator_order ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap47clean/TestQuadProbFlatHashTable.rs (target/llvm-cov-target/debug/deps/TestQuadProbFlatHashTable-2630e5f930d40efa)

running 9 tests
test test_delete ... ok
test test_find_slot ... ok
test test_insert_and_lookup ... ok
test test_delete_maintains_probe_chain ... ok
test test_lookup_stops_at_max_attempts ... ok
test test_max_attempts_ceiling_m_over_2 ... ok
test test_prime_size_guarantees ... ok
test test_probe_quadratic_sequence ... ok
test test_update_existing_key ... ok

test result: ok. 9 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap47/TestQuadraticProbing.rs (target/llvm-cov-target/debug/deps/TestQuadraticProbing-af7187e2082324b6)

running 17 tests
test test_quadratic_probe_mathematical_properties ... ok
test test_create_quadratic_probing_integer_table ... ok
test test_create_quadratic_probing_string_table ... ok
test test_quadratic_probe_sequence ... ok
test test_quadratic_probing_different_coefficients ... ok
test test_quadratic_probing_delete ... ok
test test_quadratic_probing_collision_handling ... ok
test test_quadratic_probing_insert_and_lookup ... ok
test test_quadratic_probing_empty_operations ... ok
test test_quadratic_probing_integer_operations ... ok
test test_quadratic_probing_standard_strategy ... ok
test test_quadratic_probing_strategy_creation ... ok
test test_quadratic_probing_update ... ok
test test_quadratic_probing_load_factor_management ... ok
test test_quadratic_probing_prime_table_sizes ... ok
test test_quadratic_probing_with_deletions_and_reinsertions ... ok
test test_quadratic_probing_resize_behavior ... ok

test result: ok. 17 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap27/TestReduceContractMtEph.rs (target/llvm-cov-target/debug/deps/TestReduceContractMtEph-9d9be728649273cb)

running 8 tests
test test_reduce_contract_parallel_empty ... ok
test test_reduce_contract_parallel_even_length ... ok
test test_reduce_contract_parallel_max ... ok
test test_reduce_contract_parallel_single ... ok
test test_reduce_contract_parallel_product ... ok
test test_reduce_contract_parallel_odd_length ... ok
test test_reduce_contract_parallel_sum ... ok
test test_reduce_contract_parallel_large ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap27/TestReduceContractStEph.rs (target/llvm-cov-target/debug/deps/TestReduceContractStEph-686ddc0ec22fcc50)

running 8 tests
test test_reduce_contract_empty ... ok
test test_reduce_contract_even_length ... ok
test test_reduce_contract_max ... ok
test test_reduce_contract_odd_length ... ok
test test_reduce_contract_product ... ok
test test_reduce_contract_large ... ok
test test_reduce_contract_single ... ok
test test_reduce_contract_sum ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap05/TestRelationStEph.rs (target/llvm-cov-target/debug/deps/TestRelationStEph-d8fc71555da3d149)

running 13 tests
test test_empty_relation_domain_range ... ok
test test_relation_domain_empty_edge ... ok
test test_relation_empty ... ok
test test_relation_domain_range_and_mem ... ok
test test_relation_fromvec ... ok
test test_relation_iter ... ok
test test_relation_iterator_boundaries ... ok
test test_relation_mem_empty_edge ... ok
test test_relation_range_empty_edge ... ok
test test_relation_size ... ok
test test_relationlit_macro_direct ... ok
test test_relationlit_macro_functionality ... ok
test test_relation_maximum_size_boundary ... ok

test result: ok. 13 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.06s

     Running tests/Chap55/TestSCCStEph.rs (target/llvm-cov-target/debug/deps/TestSCCStEph-0d3d7b5528aafe08)

running 7 tests
test test_linear_dag ... ok
test test_simple_cycle ... ok
test test_self_loop ... ok
test test_complex_graph ... ok
test test_two_nodes_no_edges ... ok
test test_single_node ... ok
test test_two_separate_sccs ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap55/TestSCCStPer.rs (target/llvm-cov-target/debug/deps/TestSCCStPer-b3fe2797855451b8)

running 7 tests
test test_self_loop ... ok
test test_linear_dag ... ok
test test_complex_graph ... ok
test test_single_node ... ok
test test_simple_cycle ... ok
test test_two_separate_sccs ... ok
test test_two_nodes_no_edges ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap56/TestSSSPResultStEphFloat.rs (target/llvm-cov-target/debug/deps/TestSSSPResultStEphFloat-613a05391a039e94)

running 5 tests
test TestSSSPResultStEphFloat::test_extract_path ... ok
test TestSSSPResultStEphFloat::test_extract_path_unreachable ... ok
test TestSSSPResultStEphFloat::test_new ... ok
test TestSSSPResultStEphFloat::test_set_distance ... ok
test TestSSSPResultStEphFloat::test_set_predecessor ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap56/TestSSSPResultStEphInt.rs (target/llvm-cov-target/debug/deps/TestSSSPResultStEphInt-93a89c0bff8d6f00)

running 5 tests
test TestSSSPResultStEphInt::test_extract_path ... ok
test TestSSSPResultStEphInt::test_extract_path_unreachable ... ok
test TestSSSPResultStEphInt::test_new ... ok
test TestSSSPResultStEphInt::test_set_distance ... ok
test TestSSSPResultStEphInt::test_set_predecessor ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap56/TestSSSPResultStPerFloat.rs (target/llvm-cov-target/debug/deps/TestSSSPResultStPerFloat-eb2890fe630c6c7a)

running 5 tests
test TestSSSPResultStPerFloat::test_extract_path ... ok
test TestSSSPResultStPerFloat::test_new ... ok
test TestSSSPResultStPerFloat::test_set_distance ... ok
test TestSSSPResultStPerFloat::test_extract_path_unreachable ... ok
test TestSSSPResultStPerFloat::test_set_predecessor ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap56/TestSSSPResultStPerInt.rs (target/llvm-cov-target/debug/deps/TestSSSPResultStPerInt-884ac361bbec7850)

running 5 tests
test TestSSSPResultStPerInt::test_extract_path ... ok
test TestSSSPResultStPerInt::test_set_distance ... ok
test TestSSSPResultStPerInt::test_extract_path_unreachable ... ok
test TestSSSPResultStPerInt::test_new ... ok
test TestSSSPResultStPerInt::test_set_predecessor ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap27/TestScanContractMtEph.rs (target/llvm-cov-target/debug/deps/TestScanContractMtEph-c441468db73d399a)

running 7 tests
test test_scan_contract_parallel_even_length ... ok
test test_scan_contract_parallel_empty ... ok
test test_scan_contract_parallel_large ... ok
test test_scan_contract_parallel_odd_length ... ok
test test_scan_contract_parallel_single ... ok
test test_scan_contract_parallel_product ... ok
test test_scan_contract_parallel_sum ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap27/TestScanContractStEph.rs (target/llvm-cov-target/debug/deps/TestScanContractStEph-6a2f64d5256d1ca8)

running 7 tests
test test_scan_contract_empty ... ok
test test_scan_contract_even_length ... ok
test test_scan_contract_large ... ok
test test_scan_contract_product ... ok
test test_scan_contract_odd_length ... ok
test test_scan_contract_sum ... ok
test test_scan_contract_single ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap47/TestSeparateChaining.rs (target/llvm-cov-target/debug/deps/TestSeparateChaining-83a56c49080f6c12)

running 11 tests
test test_create_empty_table ... ok
test test_collision_handling ... ok
test test_delete ... ok
test test_empty_table_operations ... ok
test test_insert_and_lookup ... ok
test test_insert_duplicate_key ... ok
test test_integer_keys ... ok
test test_statistics ... ok
test test_example_47_2_table ... ok
test test_resize_on_high_load_factor ... ok
test test_large_table ... ok

test result: ok. 11 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.04s

     Running tests/Chap05/TestSetStEph.rs (target/llvm-cov-target/debug/deps/TestSetStEph-734d72d9e2c59956)

running 23 tests
test test_cartesian_product_empty_edge ... ok
test test_empty_set_intersection ... ok
test test_empty_set_union ... ok
test test_cartesian_product_example_5_1 ... ok
test test_partition_false_due_to_missing_element ... ok
test test_partition_example_5_2_true ... ok
test test_partition_example_5_2_false_due_to_overlap ... ok
test test_set_fromvec ... ok
test test_set_insert ... ok
test test_set_empty ... ok
test test_set_intersection ... ok
test test_set_iter ... ok
test test_set_iterator_boundaries ... ok
test test_set_single_element_boundary ... ok
test test_set_singleton ... ok
test test_set_mem_comprehensive ... ok
test test_set_size_comprehensive ... ok
test test_set_union ... ok
test test_setlit_macro_direct ... ok
test test_setlit_macro_functionality ... ok
test test_setlit_macro_type_safety ... ok
test test_set_large_operations_stress ... ok
test test_set_maximum_size_boundary ... ok

test result: ok. 23 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.03s

     Running tests/Chap45/TestSortedListPQ.rs (target/llvm-cov-target/debug/deps/TestSortedListPQ-df966ebad2a7ef3b)

running 26 tests
test test_delete_min_from_empty ... ok
test test_duplicate_elements ... ok
test test_delete_min_from_singleton ... ok
test test_delete_min ... ok
test test_from_seq ... ok
test test_empty_priority_queue ... ok
test test_from_seq_with_duplicates ... ok
test test_from_empty_seq ... ok
test test_insert_maintains_order ... ok
test test_insert_and_find_min ... ok
test test_macro_with_values ... ok
test test_meld_priority_queues ... ok
test test_meld_same_elements ... ok
test test_meld_with_empty ... ok
test test_mixed_positive_negative ... ok
test test_multiple_inserts_and_deletes ... ok
test test_negative_numbers ... ok
test test_persistent_nature ... ok
test test_singleton_priority_queue ... ok
test test_string_elements ... ok
test test_zero_value ... ok
test test_sortedlistpqlit_macro_functionality ... ok
test test_to_seq_empty ... ok
test test_to_seq_conversion ... ok
test test_meld_large_queues ... ok
test test_large_sequence ... ok

test result: ok. 26 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s

     Running tests/Chap64/TestSpanTreeMtEph.rs (target/llvm-cov-target/debug/deps/TestSpanTreeMtEph-d0ac1b2709d04d51)

running 1 test
test tests::test_spanning_tree_mt_empty ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap64/TestSpanTreeStEph.rs (target/llvm-cov-target/debug/deps/TestSpanTreeStEph-5a6043996f2e790a)

running 5 tests
test tests::test_spanning_tree_single_vertex ... ok
test tests::test_spanning_tree_cycle ... ok
test tests::test_spanning_tree_empty ... ok
test tests::test_verify_spanning_tree ... ok
test tests::test_spanning_tree_connected ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap57/TestStackStEph.rs (target/llvm-cov-target/debug/deps/TestStackStEph-24f3232a5abc7823)

running 10 tests
test tests::test_clone ... ok
test tests::test_default_trait ... ok
test tests::test_multiple_operations ... ok
test tests::test_lifo_order ... ok
test tests::test_new_stack_is_empty ... ok
test tests::test_pop_from_empty ... ok
test tests::test_push_and_pop ... ok
test tests::test_push_single_element ... ok
test tests::test_peek ... ok
test tests::test_size_tracking ... ok

test result: ok. 10 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap62/TestStarContractionMtEph.rs (target/llvm-cov-target/debug/deps/TestStarContractionMtEph-1e8b9b74677c4d01)

running 4 tests
test tests::test_empty_graph_contraction_mt ... ok
test tests::test_contract_with_base_expand_mt ... ok
test tests::test_contract_to_vertices_mt_cycle ... ok
test tests::test_determinism_mt ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap62/TestStarContractionStEph.rs (target/llvm-cov-target/debug/deps/TestStarContractionStEph-84f292e347404cbb)

running 4 tests
test tests::test_empty_graph_contraction ... ok
test tests::test_contract_to_vertices_cycle ... ok
test tests::test_single_edge_contraction ... ok
test tests::test_contract_with_base_expand ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap62/TestStarPartitionMtEph.rs (target/llvm-cov-target/debug/deps/TestStarPartitionMtEph-d46615a37da3bc32)

running 4 tests
test tests::test_determinism ... ok
test tests::test_parallel_star_partition_star ... ok
test tests::test_parallel_star_partition_cycle ... ok
test tests::test_partition_validity ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap62/TestStarPartitionStEph.rs (target/llvm-cov-target/debug/deps/TestStarPartitionStEph-2525bbb9b6fb1843)

running 5 tests
test tests::test_empty_graph ... ok
test tests::test_single_vertex ... ok
test tests::test_sequential_star_partition_cycle ... ok
test tests::test_partition_properties ... ok
test tests::test_sequential_star_partition_star ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap47clean/TestStructChainedHashTable.rs (target/llvm-cov-target/debug/deps/TestStructChainedHashTable-04bebbc5c1d2cc95)

running 8 tests
test test_chainlist_delete ... ok
test test_chainlist_delete_not_found ... ok
test test_chainlist_insert ... ok
test test_chainlist_insert_multiple ... ok
test test_chainlist_new ... ok
test test_chainlist_update ... ok
test test_struct_chained_delete ... ok
test test_struct_chained_insert_lookup ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/TestSubsetSum.rs (target/llvm-cov-target/debug/deps/TestSubsetSum-6e80d8963dec70c8)

running 14 tests
test tests::test_subset_sum_accessors ... ok
test tests::test_subset_sum_display ... ok
test tests::test_subset_sum_edge_cases ... ok
test tests::test_subset_sum_eph_mutation ... ok
test tests::test_subset_sum_equality ... ok
test tests::test_subset_sum_iterator ... ok
test tests::test_subset_sum_memoization ... ok
test tests::test_subset_sum_large_target ... ok
test tests::test_subset_sum_st_eph_basic ... ok
test tests::test_subset_sum_st_per_basic ... ok
test tests::test_subset_sum_st_per_example_49_2 ... ok
test tests::test_subset_sum_mt_thread_safety ... ok
test tests::test_subset_sum_mt_eph_basic ... ok
test tests::test_subset_sum_mt_per_basic ... ok

test result: ok. 14 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s

     Running tests/Chap49/TestSubsetSumMtEph.rs (target/llvm-cov-target/debug/deps/TestSubsetSumMtEph-8e2692f311e84e34)

running 7 tests
test test_from_multiset ... ok
test test_multiset_accessor ... ok
test test_new_empty ... ok
test test_subset_sum_zero ... ok
test test_subset_sum_not_exists ... ok
test test_clear_memo ... ok
test test_subset_sum_exists ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap49/TestSubsetSumMtPer.rs (target/llvm-cov-target/debug/deps/TestSubsetSumMtPer-07c391ddb435abaf)

running 4 tests
test test_from_multiset ... ok
test test_new_empty ... ok
test test_subset_sum_not_exists ... ok
test test_subset_sum_exists ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap49/TestSubsetSumStEph.rs (target/llvm-cov-target/debug/deps/TestSubsetSumStEph-1b42f5e86797f3dd)

running 11 tests
test test_clear_memo ... ok
test test_large_multiset ... ok
test test_from_multiset ... ok
test test_multiset_accessor ... ok
test test_new_empty ... ok
test test_set_element ... ok
test test_subset_sum_all_elements ... ok
test test_subset_sum_exists ... ok
test test_subset_sum_not_exists ... ok
test test_subset_sum_single_element ... ok
test test_subset_sum_zero ... ok

test result: ok. 11 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap49/TestSubsetSumStPer.rs (target/llvm-cov-target/debug/deps/TestSubsetSumStPer-d967f083f8e359be)

running 4 tests
test test_new_empty ... ok
test test_from_multiset ... ok
test test_subset_sum_exists ... ok
test test_subset_sum_not_exists ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap64/TestTSPApproxMtEph.rs (target/llvm-cov-target/debug/deps/TestTSPApproxMtEph-0dc4c25d83ef62b2)

running 3 tests
test tests::test_shortcut_tour_mt ... ok
test tests::test_euler_tour_mt ... ok
test tests::test_approx_metric_tsp_mt ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap64/TestTSPApproxStEph.rs (target/llvm-cov-target/debug/deps/TestTSPApproxStEph-e69b764e4f9fa555)

running 4 tests
test tests::test_shortcut_tour ... ok
test tests::test_euler_tour ... ok
test tests::test_approx_metric_tsp ... ok
test tests::test_tour_weight ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap42/TestTableMtEph.rs (target/llvm-cov-target/debug/deps/TestTableMtEph-4d38cbb5cb1a0a9d)

running 19 tests
test test_table_difference_ephemeral ... ok
test test_table_empty ... ok
test test_table_domain ... ok
test test_table_find ... ok
test test_table_ephemeral_semantics ... ok
test test_table_insert_ephemeral ... ok
test test_table_intersection_ephemeral ... ok
test test_table_delete_ephemeral ... ok
test test_table_filter_ephemeral ... ok
test test_table_map_ephemeral ... ok
test test_table_mteph_lit_macro ... ok
test test_table_singleton ... ok
test test_table_restrict_ephemeral ... ok
test test_table_tabulate ... ok
test test_table_union_ephemeral ... ok
test test_tablemtephlit_macro_functionality ... ok
test test_table_subtract_ephemeral ... ok
test test_table_parallel_operations ... ok
test test_table_parallel_tabulate ... ok

test result: ok. 19 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s

     Running tests/Chap42/TestTableStEph.rs (target/llvm-cov-target/debug/deps/TestTableStEph-cba74c79d2254875)

running 18 tests
test test_table_delete_ephemeral ... ok
test test_table_empty ... ok
test test_table_difference_ephemeral ... ok
test test_table_domain ... ok
test test_table_ephemeral_semantics ... ok
test test_table_filter_ephemeral ... ok
test test_table_find ... ok
test test_table_insert_ephemeral ... ok
test test_table_intersection_ephemeral ... ok
test test_table_map_ephemeral ... ok
test test_table_restrict_ephemeral ... ok
test test_table_singleton ... ok
test test_table_steph_lit_macro ... ok
test test_table_subtract_ephemeral ... ok
test test_table_tabulate ... ok
test test_table_union_ephemeral ... ok
test test_tablestephlit_macro_functionality ... ok
test test_table_large_operations ... ok

test result: ok. 18 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap42/TestTableStPer.rs (target/llvm-cov-target/debug/deps/TestTableStPer-4340075b1386d11b)

running 18 tests
test test_table_delete ... ok
test test_table_domain ... ok
test test_table_difference ... ok
test test_table_empty_and_size ... ok
test test_table_empty_operations ... ok
test test_table_filter ... ok
test test_table_insert_and_find ... ok
test test_table_insert_with_combine ... ok
test test_table_intersection ... ok
test test_table_macro ... ok
test test_table_map ... ok
test test_table_persistence ... ok
test test_table_singleton ... ok
test test_table_restrict ... ok
test test_table_subtract ... ok
test test_table_tabulate ... ok
test test_tablestperlit_macro_functionality ... ok
test test_table_union ... ok

test result: ok. 18 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap51/TestTopDownDPMtEph.rs (target/llvm-cov-target/debug/deps/TestTopDownDPMtEph-5d7a7ace552b22ce)

running 15 tests
test test_clear_memo ... ok
test test_default ... ok
test test_display ... ok
test test_is_empty_false ... ok
test test_get_memoized ... ok
test test_is_empty_true ... ok
test test_is_memoized ... ok
test test_med_memoized_concurrent_empty ... ok
test test_med_memoized_concurrent_textbook ... ok
test test_memo_size ... ok
test test_new ... ok
test test_partial_eq ... ok
test test_s_length ... ok
test test_t_length ... ok
test test_med_memoized_parallel ... ok

test result: ok. 15 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap51/TestTopDownDPMtPer.rs (target/llvm-cov-target/debug/deps/TestTopDownDPMtPer-85b5fa59686e6fb0)

running 15 tests
test test_clear_memo ... ok
test test_default ... ok
test test_display ... ok
test test_get_memoized ... ok
test test_is_empty_false ... ok
test test_is_empty_true ... ok
test test_is_memoized ... ok
test test_med_memoized_concurrent_empty ... ok
test test_med_memoized_concurrent_textbook ... ok
test test_memo_size ... ok
test test_new ... ok
test test_partial_eq ... ok
test test_s_length ... ok
test test_t_length ... ok
test test_med_memoized_parallel ... ok

test result: ok. 15 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s

     Running tests/Chap51/TestTopDownDPStEph.rs (target/llvm-cov-target/debug/deps/TestTopDownDPStEph-1284ed44e5b51b8c)

running 15 tests
test test_clear_memo ... ok
test test_default ... ok
test test_display ... ok
test test_get_memoized ... ok
test test_is_empty_false ... ok
test test_is_empty_true ... ok
test test_is_memoized ... ok
test test_med_memoized_empty ... ok
test test_med_memoized_identical ... ok
test test_med_memoized_textbook ... ok
test test_memo_size ... ok
test test_new ... ok
test test_partial_eq ... ok
test test_s_length ... ok
test test_t_length ... ok

test result: ok. 15 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap51/TestTopDownDPStPer.rs (target/llvm-cov-target/debug/deps/TestTopDownDPStPer-15543c269e42463a)

running 15 tests
test test_clear_memo ... ok
test test_default ... ok
test test_display ... ok
test test_get_memoized ... ok
test test_is_empty_false ... ok
test test_is_empty_true ... ok
test test_is_memoized ... ok
test test_med_memoized_empty ... ok
test test_med_memoized_identical ... ok
test test_med_memoized_textbook ... ok
test test_memo_size ... ok
test test_new ... ok
test test_partial_eq ... ok
test test_s_length ... ok
test test_t_length ... ok

test result: ok. 15 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap55/TestTopoSortStEph.rs (target/llvm-cov-target/debug/deps/TestTopoSortStEph-2e79d303a9eea621)

running 7 tests
test test_dag_with_branches ... ok
test test_cycle_returns_none ... ok
test test_disconnected_components ... ok
test test_empty_graph ... ok
test test_linear_dag ... ok
test test_self_loop_returns_none ... ok
test test_single_node ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap55/TestTopoSortStPer.rs (target/llvm-cov-target/debug/deps/TestTopoSortStPer-bb74a21898b05b8a)

running 7 tests
test test_empty_graph ... ok
test test_cycle_returns_none ... ok
test test_linear_dag ... ok
test test_disconnected_components ... ok
test test_dag_with_branches ... ok
test test_self_loop_returns_none ... ok
test test_single_node ... ok

test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/TestTypes.rs (target/llvm-cov-target/debug/deps/TestTypes-377e62cab8c05376)

running 70 tests
test test_array_seq_set_eq_different_elements ... ok
test test_array_seq_set_eq_different_length ... ok
test test_array_seq_set_eq_equal ... ok
test test_array_seq_set_eq_different_order ... ok
test test_bool_type_alias ... ok
test test_edge_creation ... ok
test test_edge_clone ... ok
test test_edge_display ... ok
test test_edge_from_tuple ... ok
test test_edge_to_tuple ... ok
test test_edgelist_macro_empty ... ok
test test_edgelist_macro_multiple ... ok
test test_edgelist_macro_single ... ok
test test_edgelist_macro_trailing_comma ... ok
test test_edgelit_macro ... ok
test test_edgelit_macro_type_inference ... ok
test test_key_val_clone ... ok
test test_key_val_creation ... ok
test test_key_val_display ... ok
test test_key_val_ordering ... ok
test test_lab_edge_creation ... ok
test test_lab_edge_display ... ok
test test_lab_edge_from_tuple ... ok
test test_lab_edge_to_tuple ... ok
test test_mtt_bool_clone_mt ... ok
test test_mtt_bool_new_mt ... ok
test test_mtt_char_clone_mt ... ok
test test_mtt_i32_clone_mt ... ok
test test_mtt_i32_new_mt ... ok
test test_mtt_i64_clone_mt ... ok
test test_mtt_i64_new_mt ... ok
test test_mtt_isize_new_mt ... ok
test test_mtt_isize_clone_mt ... ok
test test_mtt_mutex_clone_mt ... ok
test test_mtt_char_new_mt ... ok
test test_mtt_pair_clone_mt ... ok
test test_mtt_mutex_new_mt ... ok
test test_mtt_str_new_mt ... ok
test test_mtt_str_clone_mt ... ok
test test_mtt_string_new_mt ... ok
test test_mtt_string_clone_mt ... ok
test test_mtt_usize_clone_mt ... ok
test test_mtt_usize_new_mt ... ok
test test_ordered_float_f32 ... ok
test test_ordered_float_f64 ... ok
test test_mtt_pair_new_mt ... ok
test test_ordering_type_alias ... ok
test test_pair_clone ... ok
test test_pair_creation ... ok
test test_pair_display ... ok
test test_pair_to_tuple ... ok
test test_mtt_u32_new_mt ... ok
test test_pairlist_macro_different_types ... ok
test test_pairlist_macro_empty ... ok
test test_pairlist_macro_multiple ... ok
test test_pair_from_tuple ... ok
test test_mtt_u64_clone_mt ... ok
test test_triple_creation ... ok
test test_triple_clone ... ok
test test_triple_ordering ... ok
test test_usize_type ... ok
test test_pair_ordering ... ok
test test_mtt_u64_new_mt ... ok
test test_mtt_u32_clone_mt ... ok
test test_pairlit_macro_different_types ... ok
test test_pairlit_macro ... ok
test test_pairlist_macro_single ... ok
test test_parapair_macro ... ok
test test_triple_display ... ok
test test_parapair_macro_complex ... ok

test result: ok. 70 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap06/TestUnDirGraphMtEph.rs (target/llvm-cov-target/debug/deps/TestUnDirGraphMtEph-818b0e07a8756360)

running 33 tests
test test_arcs ... ok
test test_clone ... ok
test test_debug_format ... ok
test test_cycle_graph ... ok
test test_disconnected_components ... ok
test test_edge_order_symmetry ... ok
test test_display_format ... ok
test test_empty_graph_all_operations ... ok
test test_equality ... ok
test test_incident ... ok
test test_indegree ... ok
test test_isolated_vertices ... ok
test test_multiple_self_loops ... ok
test test_ngofvertices_empty_subset ... ok
test test_nminus ... ok
test test_nplus ... ok
test test_nminusofvertices ... ok
test test_nplusofvertices ... ok
test test_undirgraphmteph_basic_operations ... ok
test test_undirgraphmteph_nonexistent_vertex ... ok
test test_outdegree ... ok
test test_sizea ... ok
test test_path_graph ... ok
test test_undirgraphmteph_nplusminusofvertices ... ok
test test_undirgraphmteph_complete_graph ... ok
test test_undirgraphmteph_edge_cases ... ok
test test_undirgraphmtephlit_macro_functionality ... ok
test test_undirgraphmteph_empty ... ok
test test_undirgraphmteph_incident_operations ... ok
test test_star_graph ... ok
test test_undirgraphmteph_concurrent_access ... ok
test test_undirgraphmteph_ngofvertices ... ok
test test_large_parallel_graph ... ok

test result: ok. 33 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s

     Running tests/Chap06/TestUnDirGraphStEph.rs (target/llvm-cov-target/debug/deps/TestUnDirGraphStEph-1cc1502bd8cf4331)

running 27 tests
test test_arcs ... ok
test test_clone ... ok
test test_complete_graph ... ok
test test_degree ... ok
test test_debug ... ok
test test_cycle_graph ... ok
test test_disconnected_graph ... ok
test test_display ... ok
test test_empty ... ok
test test_incident ... ok
test test_equality ... ok
test test_indegree ... ok
test test_isolated_vertex ... ok
test test_neighbor ... ok
test test_ng ... ok
test test_ngofvertices ... ok
test test_nminus ... ok
test test_nminusofvertices ... ok
test test_nplus ... ok
test test_nplusofvertices ... ok
test test_outdegree ... ok
test test_self_loop ... ok
test test_path_graph ... ok
test test_sizea ... ok
test test_star_graph ... ok
test test_undirgraphstephlit_macro_functionality ... ok
test test_undigraph_vertices_and_edges ... ok

test result: ok. 27 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap65/TestUnionFindStEph.rs (target/llvm-cov-target/debug/deps/TestUnionFindStEph-e7978ff3ea262b39)

running 14 tests
test tests::test_find_root ... ok
test tests::test_union_find_already_unioned ... ok
test tests::test_multiple_components ... ok
test tests::test_union_find_basic ... ok
test tests::test_union_find_duplicate_insert ... ok
test tests::test_union_find_empty ... ok
test tests::test_union_find_reflexive ... ok
test tests::test_union_find_path_compression ... ok
test tests::test_union_find_single ... ok
test tests::test_union_find_string_vertices ... ok
test tests::test_union_find_symmetric ... ok
test tests::test_union_find_transitive ... ok
test tests::test_star_pattern ... ok
test tests::test_large_union_find ... ok

test result: ok. 14 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap45/TestUnsortedListPQ.rs (target/llvm-cov-target/debug/deps/TestUnsortedListPQ-5fe642921b3ca9b6)

running 29 tests
test test_display_formatting ... ok
test test_delete_min_sequence ... ok
test test_duplicate_elements ... ok
test test_empty_constructor ... ok
test test_edge_cases ... ok
test test_empty_priority_queue ... ok
test test_from_seq ... ok
test test_from_vec_convenience ... ok
test test_insert_after_delete ... ok
test test_insert_all ... ok
test test_insert_and_find_min ... ok
test test_macro_creation ... ok
test test_meld_multiple ... ok
test test_meld_operation ... ok
test test_meld_with_empty ... ok
test test_mixed_positive_negative ... ok
test test_negative_numbers ... ok
test test_persistent_behavior ... ok
test test_singleton_constructor ... ok
test test_roundtrip_vec ... ok
test test_singleton_priority_queue ... ok
test test_to_seq ... ok
test test_to_seq_empty ... ok
test test_string_elements ... ok
test test_to_vec ... ok
test test_unsortedlistpqlit_macro_functionality ... ok
test test_to_vec_empty ... ok
test test_complexity_characteristics ... ok
test test_large_dataset ... ok

test result: ok. 29 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s

     Running tests/Chap47clean/TestVecChainedHashTable.rs (target/llvm-cov-target/debug/deps/TestVecChainedHashTable-55e2b7052a4f6312)

running 6 tests
test test_vec_entry_delete ... ok
test test_vec_chained_delete ... ok
test test_vec_chained_insert_lookup ... ok
test test_vec_entry_insert ... ok
test test_vec_entry_new ... ok
test test_vec_entry_update ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap61/TestVertexMatchingMtEph.rs (target/llvm-cov-target/debug/deps/TestVertexMatchingMtEph-0dbd2add29df52d9)

running 3 tests
test tests::test_parallel_matching_mt_star ... ok
test tests::test_parallel_matching_mt_correctness ... ok
test tests::test_parallel_matching_mt_cycle ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap61/TestVertexMatchingStEph.rs (target/llvm-cov-target/debug/deps/TestVertexMatchingStEph-cee7d5da3d015b1d)

running 5 tests
test tests::test_greedy_matching_cycle ... ok
test tests::test_greedy_matching_star ... ok
test tests::test_matching_properties ... ok
test tests::test_parallel_matching_st_star ... ok
test tests::test_parallel_matching_st_cycle ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap06/TestWeightedDirGraphMtEphFloat.rs (target/llvm-cov-target/debug/deps/TestWeightedDirGraphMtEphFloat-31f1e9ea36e5ba69)

running 15 tests
test test_total_weight ... ok
test test_get_edge_weight_missing ... ok
test test_from_weighted_edges ... ok
test test_weighted_edges_empty ... ok
test test_in_neighbors_weighted ... ok
test test_weighteddirgraphmtephfloat_basic_operations ... ok
test test_weighteddirgraphmtephfloat_edge_cases ... ok
test test_weighteddirgraphmtephfloat_empty ... ok
test test_weighteddirgraphmtephfloat_ngofvertices ... ok
test test_weighteddirgraphmtephfloat_incident_operations ... ok
test test_weighteddirgraphmtephfloat_nonexistent_vertex ... ok
test test_weighteddirgraphmtephfloat_weight_variations ... ok
test test_weighteddirgraphmtephfloat_nplusminusofvertices ... ok
test test_weighteddirgraphmtephfloatlit_macro_functionality ... ok
test test_weighteddirgraphmtephfloat_concurrent_access ... ok

test result: ok. 15 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap06/TestWeightedDirGraphMtEphInt.rs (target/llvm-cov-target/debug/deps/TestWeightedDirGraphMtEphInt-65a307942066aae1)

running 18 tests
test test_get_edge_weight_nonexistent ... ok
test test_in_neighbors_weighted_empty ... ok
test test_from_weighted_edges ... ok
test test_out_neighbors_weighted_isolated ... ok
test test_in_neighbors_weighted ... ok
test test_weighted_edges_empty ... ok
test test_total_weight ... ok
test test_weighteddirgraphmtephint_basic_operations ... ok
test test_weighteddirgraphmtephint_edge_cases ... ok
test test_weighteddirgraphmtephint_empty ... ok
test test_weighteddirgraphmtephint_incident_operations ... ok
test test_weighteddirgraphmtephint_large_weights ... ok
test test_weighteddirgraphmtephint_ngofvertices ... ok
test test_weighteddirgraphmtephint_nplusminusofvertices ... ok
test test_weighteddirgraphmtephint_nonexistent_vertex ... ok
test test_weighteddirgraphmtephint_weight_variations ... ok
test test_weighteddirgraphmtephintlit_macro_functionality ... ok
test test_weighteddirgraphmtephint_concurrent_access ... ok

test result: ok. 18 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap06/TestWeightedDirGraphStEphFloat.rs (target/llvm-cov-target/debug/deps/TestWeightedDirGraphStEphFloat-4955fce289a960e3)

running 22 tests
test test_add_weighted_edge ... ok
test test_edges_below_weight ... ok
test test_edges_above_weight ... ok
test test_from_weighted_edges ... ok
test test_get_edge_weight ... ok
test test_in_neighbors_weighted ... ok
test test_max_weight_edge ... ok
test test_min_weight_edge ... ok
test test_out_neighbors_weighted ... ok
test test_scale_weights ... ok
test test_total_weight ... ok
test test_weighted_edges ... ok
test test_weighteddirgraphstephfloat_arcs_conversion ... ok
test test_weighteddirgraphstephfloat_basic_operations ... ok
test test_weighteddirgraphstephfloat_complex_topology ... ok
test test_weighteddirgraphstephfloat_edge_cases ... ok
test test_weighteddirgraphstephfloat_empty ... ok
test test_weighteddirgraphstephfloat_mutable_operations ... ok
test test_weighteddirgraphstephfloat_nan_handling ... ok
test test_weighteddirgraphstephfloat_nonexistent_vertex ... ok
test test_weighteddirgraphstephfloat_weight_variations ... ok
test test_weighteddirgraphstephfloatlit_macro_functionality ... ok

test result: ok. 22 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap06/TestWeightedDirGraphStEphInt.rs (target/llvm-cov-target/debug/deps/TestWeightedDirGraphStEphInt-c0be0386e24270e0)

running 24 tests
test test_add_weighted_edge ... ok
test test_empty_graph ... ok
test test_complete_graph_weighted ... ok
test test_edges_above_weight ... ok
test test_edges_below_weight ... ok
test test_from_weighted_edges ... ok
test test_get_edge_weight ... ok
test test_in_neighbors_weighted ... ok
test test_isolated_vertex ... ok
test test_large_weights ... ok
test test_negative_weights ... ok
test test_no_edges_graph ... ok
test test_out_neighbors_weighted ... ok
test test_self_loop ... ok
test test_total_weight ... ok
test test_total_weight_empty ... ok
test test_weighted_edges ... ok
test test_weighted_path ... ok
test test_weighted_star ... ok
test test_weighteddirgraphstephintlit_macro_empty ... ok
test test_weighteddirgraphstephintlit_macro_simple ... ok
test test_weighteddirgraphstephintlit_macro_star ... ok
test test_weighteddirgraphstephintlit_macro_trailing_comma ... ok
test test_zero_weight ... ok

test result: ok. 24 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap06/TestWeightedUnDirGraphMtEphFloat.rs (target/llvm-cov-target/debug/deps/TestWeightedUnDirGraphMtEphFloat-1509486208de782f)

running 18 tests
test test_add_weighted_edge ... ok
test test_from_weighted_edges ... ok
test test_get_edge_weight ... ok
test test_neighbors_weighted ... ok
test test_total_weight ... ok
test test_vertex_degree ... ok
test test_weighted_edges ... ok
test test_weightedundirgraphmtephfloat_basic_operations ... ok
test test_weightedundirgraphmtephfloat_complete_graph ... ok
test test_weightedundirgraphmtephfloat_edge_cases ... ok
test test_weightedundirgraphmtephfloat_empty ... ok
test test_weightedundirgraphmtephfloat_incident_operations ... ok
test test_weightedundirgraphmtephfloat_ngofvertices ... ok
test test_weightedundirgraphmtephfloat_nonexistent_vertex ... ok
test test_weightedundirgraphmtephfloat_nplusminusofvertices ... ok
test test_weightedundirgraphmtephfloat_concurrent_access ... ok
test test_weightedundirgraphmtephfloatlit_macro_functionality ... ok
test test_weightedundirgraphmtephfloat_weight_variations ... ok

test result: ok. 18 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap06/TestWeightedUnDirGraphMtEphInt.rs (target/llvm-cov-target/debug/deps/TestWeightedUnDirGraphMtEphInt-ff77293df6d286cc)

running 19 tests
test test_add_weighted_edge ... ok
test test_from_weighted_edges ... ok
test test_get_edge_weight ... ok
test test_neighbors_weighted ... ok
test test_total_weight ... ok
test test_vertex_degree ... ok
test test_weighted_edges ... ok
test test_weightedundirgraphmtephint_basic_operations ... ok
test test_weightedundirgraphmtephint_completegraph ... ok
test test_weightedundirgraphmtephint_edge_cases ... ok
test test_weightedundirgraphmtephint_empty ... ok
test test_weightedundirgraphmtephint_incident_operations ... ok
test test_weightedundirgraphmtephint_large_weights ... ok
test test_weightedundirgraphmtephint_ngofvertices ... ok
test test_weightedundirgraphmtephint_nonexistent_vertex ... ok
test test_weightedundirgraphmtephint_nplusminusofvertices ... ok
test test_weightedundirgraphmtephint_concurrent_access ... ok
test test_weightedundirgraphmtephint_weight_variations ... ok
test test_weightedundirgraphmtephintlit_macro_functionality ... ok

test result: ok. 19 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap06/TestWeightedUnDirGraphStEphFloat.rs (target/llvm-cov-target/debug/deps/TestWeightedUnDirGraphStEphFloat-d50f1fd6a747dc9e)

running 41 tests
test test_add_vertices_and_edges ... ok
test test_display_format ... ok
test test_create_empty_graph ... ok
test test_cycle_graph ... ok
test test_complete_graph_k4 ... ok
test test_fractional_weights ... ok
test test_edges_method ... ok
test test_duplicate_edge_addition ... ok
test test_from_weighted_edges ... ok
test test_get_edge_weight ... ok
test test_has_vertex ... ok
test test_inf_weight ... ok
test test_is_connected_disconnected ... ok
test test_is_connected_empty_graph ... ok
test test_is_connected_fully_connected ... ok
test test_has_edge ... ok
test test_is_connected_single_vertex ... ok
test test_is_connected_two_vertices ... ok
test test_isolated_vertices ... ok
test test_max_weight_edge ... ok
test test_min_max_weight_edge_empty ... ok
test test_negative_weight_edge ... ok
test test_min_weight_edge ... ok
test test_neighbors_method ... ok
test test_self_loop ... ok
test test_neighbors_weighted ... ok
test test_path_graph ... ok
test test_star_graph ... ok
test test_total_weight_empty ... ok
test test_string_vertices ... ok
test test_undirected_edge_symmetry ... ok
test test_vertex_degree_zero ... ok
test test_vertex_degree ... ok
test test_vertices_method ... ok
test test_very_small_weight ... ok
test test_total_weight ... ok
test test_weighted_edges ... ok
test test_weighted_neighbors_isolated ... ok
test test_zero_weight_edge ... ok
test test_weightedundirgraphstephfloatlit_macro_functionality ... ok
test test_large_graph ... ok

test result: ok. 41 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/Chap06/TestWeightedUnDirGraphStEphInt.rs (target/llvm-cov-target/debug/deps/TestWeightedUnDirGraphStEphInt-0b4e08033bf449d3)

running 40 tests
test test_add_vertices_and_edges ... ok
test test_create_empty_graph ... ok
test test_display_format ... ok
test test_duplicate_edge_addition ... ok
test test_cycle_graph ... ok
test test_complete_graph_k4 ... ok
test test_edges_method ... ok
test test_from_weighted_edges ... ok
test test_get_edge_weight ... ok
test test_has_edge ... ok
test test_has_vertex ... ok
test test_is_connected_disconnected ... ok
test test_is_connected_empty_graph ... ok
test test_is_connected_fully_connected ... ok
test test_is_connected_single_vertex ... ok
test test_is_connected_two_vertices ... ok
test test_isolated_vertices ... ok
test test_large_weight ... ok
test test_min_max_weight_edge_empty ... ok
test test_max_weight_edge ... ok
test test_min_weight_edge ... ok
test test_min_weight ... ok
test test_neighbors_method ... ok
test test_negative_weight_edge ... ok
test test_neighbors_weighted ... ok
test test_star_graph ... ok
test test_self_loop ... ok
test test_total_weight_empty ... ok
test test_path_graph ... ok
test test_total_weight ... ok
test test_vertex_degree ... ok
test test_string_vertices ... ok
test test_vertex_degree_zero ... ok
test test_undirected_edge_symmetry ... ok
test test_vertices_method ... ok
test test_weighted_neighbors_isolated ... ok
test test_weighted_edges ... ok
test test_zero_weight_edge ... ok
test test_weightedundirgraphstephintlit_macro_functionality ... ok
test test_large_graph ... ok

test result: ok. 40 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

warning: 780 functions have mismatched data
/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap03/InsertionSortSt.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 3 insertion sort over mutable slices.
    3|       |
    4|       |pub mod InsertionSortSt {
    5|       |
    6|       |    pub trait InsertionSortStTrait<T: Ord + Clone> {
    7|       |        /// APAS: Work O(n), Span O(n log n)
    8|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
    9|       |        /// BUG: claude-4-sonet's span analysis differs from APAS (APAS assumes O(log n) span insert operation)
   10|       |        ///
   11|       |        /// APAS is underspecified with:
   12|       |        /// Example 3.2 (Cost of Insertion Sort). Considering insertion sort example, suppose that we
   13|       |        /// are given a cost specification for insert: for a sequence of length n the cost of insert
   14|       |        /// should be O(n) work and O(log n) span. We can then determine the overall asymptotic
   15|       |        /// cost of sort using our composition rules described in Section (Work, Span, and Parallel
   16|       |        /// Time). Since the code uses insert sequentially and since there are n inserts, the algorithm
   17|       |        /// insSort has n  O(n) = O(n) work and n  O(log n) = O(n log n) span.
   18|       |        fn insSort(&self, slice: &mut [T]);
   19|       |    }
   20|       |
   21|       |    impl<T: Ord + Clone> InsertionSortStTrait<T> for T {
   22|      7|        fn insSort(&self, slice: &mut [T]) {
   23|  10.0k|            for i in 1..slice.len() {
                                      ^7    ^7
   24|  10.0k|                let key = slice[i].clone();
   25|  10.0k|                let mut j = i;
   26|  50.0M|                while j > 0 && slice[j - 1] > key {
                                             ^49.9M
   27|  49.9M|                    slice[j] = slice[j - 1].clone();
   28|  49.9M|                    j -= 1;
   29|  49.9M|                }
   30|  10.0k|                slice[j] = key;
   31|       |            }
   32|      7|        }
   33|       |    }
   34|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap05/MappingStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 5.5 ephemeral Mapping (Function) built on `Relation<A,B>`.
    3|       |
    4|       |pub mod MappingStEph {
    5|       |
    6|       |    use std::collections::HashMap;
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    8|       |    use std::hash::Hash;
    9|       |
   10|       |    use crate::Chap05::RelationStEph::RelationStEph::*;
   11|       |    use crate::Chap05::SetStEph::SetStEph::*;
   12|       |    use crate::SetLit;
   13|       |    use crate::Types::Types::*;
   14|       |
   15|       |    #[derive(Clone)]
   16|       |    pub struct Mapping<A, B> {
   17|       |        rel: Relation<A, B>,
   18|       |    }
   19|       |
   20|       |    pub trait MappingStEphTrait<X: StT + Hash, Y: StT + Hash> {
   21|       |        /// APAS: Work (1), Span (1)
   22|       |        /// claude-4-sonet: Work (1), Span (1)
   23|       |        fn empty() -> Mapping<X, Y>;
   24|       |
   25|       |        /// APAS: Work (|v|), Span (1)
   26|       |        /// claude-4-sonet: Work (|v|), Span (1)
   27|       |        fn FromVec(v: Vec<Pair<X, Y>>) -> Mapping<X, Y>;
   28|       |
   29|       |        /// APAS: Work (|r|), Span (1)
   30|       |        /// claude-4-sonet: Work (|r|), Span (1)
   31|       |        fn FromRelation(r: &Relation<X, Y>) -> Mapping<X, Y>;
   32|       |
   33|       |        /// APAS: Work (1), Span (1)
   34|       |        /// claude-4-sonet: Work (1), Span (1)
   35|       |        fn size(&self) -> N;
   36|       |
   37|       |        /// APAS: Work (|m|), Span (1)
   38|       |        /// claude-4-sonet: Work (|m|), Span (1)
   39|       |        fn domain(&self) -> Set<X>;
   40|       |
   41|       |        /// APAS: Work (|m|), Span (1)
   42|       |        /// claude-4-sonet: Work (|m|), Span (1)
   43|       |        fn range(&self) -> Set<Y>;
   44|       |
   45|       |        /// APAS: Work (1), Span (1)
   46|       |        /// claude-4-sonet: Work (1), Span (1)
   47|       |        fn mem(&self, a: &X, b: &Y) -> B;
   48|       |
   49|       |        fn iter(&self) -> std::collections::hash_set::Iter<'_, Pair<X, Y>>;
   50|       |    }
   51|       |
   52|       |    impl<A: Eq + Hash, B: Eq + Hash> Mapping<A, B> {
   53|     12|        fn unique_pairs_from_iter<I: IntoIterator<Item = Pair<A, B>>>(iter: I) -> Set<Pair<A, B>> {
   54|     12|            let mut m: HashMap<A, B> = HashMap::new();
   55|  10.0k|            for Pair(a, b) in iter {
                                   ^10.0k^10.0k
   56|  10.0k|                m.insert(a, b);
   57|  10.0k|            }
   58|  10.0k|            let pairs: Vec<Pair<A, B>> = m.into_iter().map(|(a, b)| Pair(a, b)).collect();
                              ^12    ^12               ^12^12         ^12                      ^12
   59|     12|            Set::FromVec(pairs)
   60|     12|        }
   61|       |    }
   62|       |
   63|       |    impl<A: StT + Hash, B: StT + Hash> PartialEq for Mapping<A, B> {
   64|      0|        fn eq(&self, other: &Self) -> bool { self.rel == other.rel }
   65|       |    }
   66|       |    impl<A: StT + Hash, B: StT + Hash> Eq for Mapping<A, B> {}
   67|       |
   68|       |    impl<A: StT + Hash, B: StT + Hash> Debug for Mapping<A, B> {
   69|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { Debug::fmt(&self.rel, f) }
   70|       |    }
   71|       |    impl<A: StT + Hash, B: StT + Hash> Display for Mapping<A, B> {
   72|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { Display::fmt(&self.rel, f) }
   73|       |    }
   74|       |
   75|       |    impl<X: StT + Hash, Y: StT + Hash> MappingStEphTrait<X, Y> for Mapping<X, Y> {
   76|      0|        fn empty() -> Mapping<X, Y> {
   77|      0|            Mapping {
   78|      0|                rel: <Relation<X, Y> as RelationStEphTrait<X, Y>>::empty(),
   79|      0|            }
   80|      0|        }
   81|       |
   82|      7|        fn FromVec(v: Vec<Pair<X, Y>>) -> Mapping<X, Y> {
   83|      7|            let pairs = Self::unique_pairs_from_iter(v);
   84|      7|            Mapping {
   85|      7|                rel: <Relation<X, Y> as RelationStEphTrait<X, Y>>::FromSet(pairs),
   86|      7|            }
   87|      7|        }
   88|       |
   89|      5|        fn FromRelation(r: &Relation<X, Y>) -> Mapping<X, Y> {
   90|      5|            let pairs = Self::unique_pairs_from_iter(r.iter().cloned());
   91|      5|            Mapping {
   92|      5|                rel: <Relation<X, Y> as RelationStEphTrait<X, Y>>::FromSet(pairs),
   93|      5|            }
   94|      5|        }
   95|       |
   96|      9|        fn size(&self) -> N { self.rel.size() }
   97|       |
   98|      6|        fn domain(&self) -> Set<X> { self.rel.domain() }
   99|       |
  100|      6|        fn range(&self) -> Set<Y> { self.rel.range() }
  101|       |
  102|     23|        fn mem(&self, a: &X, b: &Y) -> B { self.rel.mem(a, b) }
  103|       |
  104|      3|        fn iter(&self) -> std::collections::hash_set::Iter<'_, Pair<X, Y>> { self.rel.iter() }
  105|       |    }
  106|       |
  107|       |    #[macro_export]
  108|       |    macro_rules! MappingLit {
  109|       |        () => {{
  110|       |            < $crate::Chap05::MappingStEph::MappingStEph::Mapping<_, _> as $crate::Chap05::MappingStEph::MappingStEph::MappingStEphTrait<_, _> >::FromRelation(& $crate::RelationLit![])
  111|       |        }};
  112|       |        ( $( ($a:expr, $b:expr) ),* $(,)? ) => {{
  113|       |            let __pairs = vec![ $( $crate::Types::Types::Pair($a, $b) ),* ];
  114|       |            // Check for duplicate domain elements
  115|       |            let mut __seen_keys = std::collections::HashSet::new();
  116|       |            for pair in &__pairs {
  117|       |                let key = &pair.0;
  118|       |                if !__seen_keys.insert(key) {
  119|       |                    panic!("MappingLit!: duplicate domain element {:?}", key);
  120|       |                }
  121|       |            }
  122|       |            < $crate::Chap05::MappingStEph::MappingStEph::Mapping<_, _> as $crate::Chap05::MappingStEph::MappingStEph::MappingStEphTrait<_, _> >::FromVec(__pairs)
  123|       |        }};
  124|       |    }
  125|       |
  126|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap05/RelationStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 5.2 ephemeral Relation built on `Set<Pair<A,B>>`.
    3|       |
    4|       |pub mod RelationStEph {
    5|       |
    6|       |    use std::collections::hash_set::Iter;
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    8|       |    use std::hash::Hash;
    9|       |
   10|       |    use crate::Chap05::SetStEph::SetStEph::*;
   11|       |    use crate::SetLit;
   12|       |    use crate::Types::Types::*;
   13|       |
   14|       |    #[derive(Clone)]
   15|       |    pub struct Relation<A, B> {
   16|       |        pairs: Set<Pair<A, B>>,
   17|       |    }
   18|       |
   19|       |    pub trait RelationStEphTrait<X: StT + Hash, Y: StT + Hash> {
   20|       |        /// APAS: Work (1), Span (1)
   21|       |        /// claude-4-sonet: Work (1), Span (1)
   22|       |        fn empty() -> Relation<X, Y>;
   23|       |
   24|       |        /// APAS: Work (|pairs|), Span (1)
   25|       |        /// claude-4-sonet: Work (|pairs|), Span (1)
   26|       |        fn FromSet(pairs: Set<Pair<X, Y>>) -> Relation<X, Y>;
   27|       |
   28|       |        /// APAS: Work (1), Span (1)
   29|       |        /// claude-4-sonet: Work (1), Span (1)
   30|       |        fn size(&self) -> N;
   31|       |
   32|       |        /// APAS: Work (|R|), Span (1)
   33|       |        /// claude-4-sonet: Work (|R|), Span (1)
   34|       |        fn domain(&self) -> Set<X>
   35|       |        where
   36|       |            X: Clone;
   37|       |
   38|       |        /// APAS: Work (|R|), Span (1)
   39|       |        /// claude-4-sonet: Work (|R|), Span (1)
   40|       |        fn range(&self) -> Set<Y>
   41|       |        where
   42|       |            Y: Clone;
   43|       |
   44|       |        /// APAS: Work (1), Span (1)
   45|       |        /// claude-4-sonet: Work (1), Span (1)
   46|       |        fn mem(&self, a: &X, b: &Y) -> B
   47|       |        where
   48|       |            X: Clone,
   49|       |            Y: Clone;
   50|       |
   51|       |        fn iter(&self) -> Iter<'_, Pair<X, Y>>;
   52|       |    }
   53|       |
   54|       |    impl<A: StT + Hash, B: StT + Hash> Relation<A, B> {
   55|      4|        pub fn FromVec(v: Vec<Pair<A, B>>) -> Relation<A, B> { Relation { pairs: Set::FromVec(v) } }
   56|       |    }
   57|       |
   58|       |    impl<A: StT + Hash, B: StT + Hash> PartialEq for Relation<A, B> {
   59|      0|        fn eq(&self, other: &Self) -> bool { self.pairs == other.pairs }
   60|       |    }
   61|       |
   62|       |    impl<A: StT + Hash, B: StT + Hash> Eq for Relation<A, B> {}
   63|       |
   64|       |    impl<A: StT + Hash, B: StT + Hash> Debug for Relation<A, B> {
   65|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { std::fmt::Debug::fmt(&self.pairs, f) }
   66|       |    }
   67|       |
   68|       |    impl<A: StT + Hash, B: StT + Hash> Display for Relation<A, B> {
   69|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { std::fmt::Display::fmt(&self.pairs, f) }
   70|       |    }
   71|       |
   72|       |    impl<X: StT + Hash, Y: StT + Hash> RelationStEphTrait<X, Y> for Relation<X, Y> {
   73|      6|        fn empty() -> Relation<X, Y> { Relation { pairs: SetLit![] } }
   74|       |
   75|     37|        fn FromSet(pairs: Set<Pair<X, Y>>) -> Relation<X, Y> { Relation { pairs } }
   76|       |
   77|     25|        fn size(&self) -> N { self.pairs.size() }
   78|       |
   79|     10|        fn domain(&self) -> Set<X>
   80|     10|        where
   81|     10|            X: Clone,
   82|       |        {
   83|     10|            let mut out: Set<X> = Set::empty();
   84|  60.0k|            for Pair(a, _) in self.pairs.iter() {
                                            ^10        ^10
   85|  60.0k|                let _ = out.insert(a.clone());
   86|  60.0k|            }
   87|     10|            out
   88|     10|        }
   89|       |
   90|     10|        fn range(&self) -> Set<Y>
   91|     10|        where
   92|     10|            Y: Clone,
   93|       |        {
   94|     10|            let mut out: Set<Y> = Set::empty();
   95|  60.0k|            for Pair(_, b) in self.pairs.iter() {
                                            ^10        ^10
   96|  60.0k|                let _ = out.insert(b.clone());
   97|  60.0k|            }
   98|     10|            out
   99|     10|        }
  100|       |
  101|     82|        fn mem(&self, a: &X, b: &Y) -> B
  102|     82|        where
  103|     82|            X: Clone,
  104|     82|            Y: Clone,
  105|       |        {
  106|     82|            if self.pairs.mem(&Pair(a.clone(), b.clone())) == true {
  107|     63|                true
  108|       |            } else {
  109|     19|                false
  110|       |            }
  111|     82|        }
  112|       |
  113|     23|        fn iter(&self) -> Iter<'_, Pair<X, Y>> { self.pairs.iter() }
  114|       |    }
  115|       |
  116|       |    #[macro_export]
  117|       |    macro_rules! RelationLit {
  118|       |        () => {{
  119|       |            let __pairs: $crate::Chap05::SetStEph::SetStEph::Set<$crate::Types::Types::Pair<_, _>> = < $crate::Chap05::SetStEph::SetStEph::Set<_> >::empty();
  120|       |            < $crate::Chap05::RelationStEph::RelationStEph::Relation<_, _> as $crate::Chap05::RelationStEph::RelationStEph::RelationStEphTrait<_, _> >::FromSet(__pairs)
  121|       |        }};
  122|       |        ( $( ($a:expr, $b:expr) ),* $(,)? ) => {{
  123|       |            let __pairs = {
  124|       |                let mut __s = < $crate::Chap05::SetStEph::SetStEph::Set<_> >::empty();
  125|       |                $( let _ = __s.insert($crate::Types::Types::Pair($a, $b)); )*
  126|       |                __s
  127|       |            };
  128|       |            < $crate::Chap05::RelationStEph::RelationStEph::Relation<_, _> as $crate::Chap05::RelationStEph::RelationStEph::RelationStEphTrait<_, _> >::FromSet(__pairs)
  129|       |        }};
  130|       |    }
  131|       |
  132|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap05/SetStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 5.1 ephemeral Set built on `std::collections::HashSet`.
    3|       |
    4|       |pub mod SetStEph {
    5|       |
    6|       |    use std::collections::HashSet;
    7|       |    use std::fmt::{Debug, Display};
    8|       |    use std::hash::{Hash, Hasher};
    9|       |
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    #[derive(Clone)]
   13|       |    pub struct Set<T> {
   14|       |        data: HashSet<T>,
   15|       |    }
   16|       |
   17|       |    pub trait SetStEphTrait<T: StT + Hash> {
   18|       |        /// APAS: Work (1), Span (1)
   19|       |        /// claude-4-sonet: Work (1), Span (1)
   20|       |        fn empty() -> Set<T>;
   21|       |        /// APAS: Work (1), Span (1)
   22|       |        /// claude-4-sonet: Work (1), Span (1)
   23|       |        fn singleton(x: T) -> Set<T>;
   24|       |        /// APAS: Work (1), Span (1)
   25|       |        /// claude-4-sonet: Work (1), Span (1)
   26|       |        fn size(&self) -> N;
   27|       |        /// APAS: Work (1), Span (1)
   28|       |        /// claude-4-sonet: Work (1), Span (1)
   29|       |        fn mem(&self, x: &T) -> B;
   30|       |        /// APAS: Work (|a| + |b|), Span (1)
   31|       |        /// claude-4-sonet: Work (|a| + |b|), Span (1)
   32|       |        fn union(&self, other: &Set<T>) -> Set<T>;
   33|       |        /// APAS: Work (|a| + |b|), Span (1)
   34|       |        /// claude-4-sonet: Work (|a| + |b|), Span (1)
   35|       |        fn intersection(&self, other: &Set<T>) -> Set<T>;
   36|       |        /// APAS: Work (|parts|  |a|), Span (1)
   37|       |        /// claude-4-sonet: Work (|parts|  |a|), Span (1)
   38|       |        fn partition(&self, parts: &Set<Set<T>>) -> B;
   39|       |
   40|       |        /// APAS: Work (|a|  |b|), Span (1)
   41|       |        /// claude-4-sonet: Work (|a|  |b|), Span (1)
   42|       |        fn CartesianProduct<U: StT + Hash>(&self, other: &Set<U>) -> Set<Pair<T, U>>;
   43|       |
   44|       |        /// APAS: Work (1), Span (1)
   45|       |        /// claude-4-sonet: Work (1), Span (1)
   46|       |        fn insert(&mut self, x: T) -> &mut Self;
   47|       |
   48|       |        /// APAS: Work (1), Span (1)
   49|       |        /// claude-4-sonet: Work (1), Span (1)
   50|       |        fn iter(&self) -> std::collections::hash_set::Iter<'_, T>;
   51|       |        /// APAS: Work (|v|), Span (1)
   52|       |        /// claude-4-sonet: Work (|v|), Span (1)
   53|       |        fn FromVec(v: Vec<T>) -> Set<T>;
   54|       |    }
   55|       |
   56|       |    impl<T: Eq + Hash> PartialEq for Set<T> {
   57|     21|        fn eq(&self, other: &Self) -> bool { self.data == other.data }
   58|       |    }
   59|       |
   60|       |    impl<T: Eq + Hash> Eq for Set<T> {}
   61|       |
   62|       |    impl<T: Eq + Hash + std::fmt::Debug> std::fmt::Debug for Set<T> {
   63|     12|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   64|     12|            f.debug_set().entries(self.data.iter()).finish()
   65|     12|        }
   66|       |    }
   67|       |
   68|       |    impl<T: Eq + Hash + std::fmt::Display> std::fmt::Display for Set<T> {
   69|     16|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   70|     16|            write!(f, "{{")?;
                                         ^0
   71|     16|            let mut first = true;
   72|     19|            for x in self.data.iter() {
                                   ^16       ^16
   73|     19|                if !first {
   74|      7|                    write!(f, ", ")?;
                                                 ^0
   75|     12|                } else {
   76|     12|                    first = false;
   77|     12|                }
   78|     19|                write!(f, "{}", x)?;
                                                ^0
   79|       |            }
   80|     16|            write!(f, "}}")
   81|     16|        }
   82|       |    }
   83|       |
   84|       |    // Provide an order-independent Hash so sets of sets can be placed in a HashSet.
   85|       |    impl<T: Eq + Hash> Hash for Set<T> {
   86|      6|        fn hash<H: Hasher>(&self, state: &mut H) {
   87|       |            use std::collections::hash_map::DefaultHasher;
   88|      6|            let mut element_hashes: Vec<u64> = Vec::with_capacity(self.data.len());
   89|     15|            for e in self.data.iter() {
                                   ^6        ^6
   90|     15|                let mut h = DefaultHasher::new();
   91|     15|                e.hash(&mut h);
   92|     15|                element_hashes.push(h.finish());
   93|     15|            }
   94|      6|            element_hashes.sort_unstable();
   95|      6|            self.data.len().hash(state);
   96|     21|            for h in element_hashes {
                              ^15
   97|     15|                h.hash(state);
   98|     15|            }
   99|      6|        }
  100|       |    }
  101|       |
  102|       |    impl<T: Eq + Hash> Set<T> {
  103|   120k|        pub fn empty() -> Set<T> { Set { data: HashSet::new() } }
  104|       |
  105|      8|        pub fn singleton(x: T) -> Set<T> {
  106|      8|            let mut s = HashSet::with_capacity(1);
  107|      8|            let _ = s.insert(x);
  108|      8|            Set { data: s }
  109|      8|        }
  110|       |
  111|  13.5k|        pub fn size(&self) -> N { self.data.len() }
  112|       |
  113|  9.99k|        pub fn mem(&self, x: &T) -> B { if self.data.contains(x) { true } else { false } }
                                                                                 ^8.60k        ^1.39k
  114|       |
  115|  58.0k|        pub fn union(&self, other: &Set<T>) -> Set<T>
  116|  58.0k|        where
  117|  58.0k|            T: Clone,
  118|       |        {
  119|  58.0k|            let mut out = self.clone();
  120|  87.9k|            for x in other.data.iter() {
                                   ^58.0k     ^58.0k
  121|  87.9k|                let _ = out.data.insert(x.clone());
  122|  87.9k|            }
  123|  58.0k|            out
  124|  58.0k|        }
  125|       |
  126|     11|        pub fn intersection(&self, other: &Set<T>) -> Set<T>
  127|     11|        where
  128|     11|            T: Clone,
  129|       |        {
  130|     11|            let mut out = HashSet::with_capacity(self.data.len().min(other.data.len()));
  131|  15.0k|            for x in self.data.intersection(&other.data) {
                                   ^11       ^11          ^11
  132|  15.0k|                let _ = out.insert(x.clone());
  133|  15.0k|            }
  134|     11|            Set { data: out }
  135|     11|        }
  136|       |
  137|      3|        pub fn partition(&self, parts: &Set<Set<T>>) -> B {
  138|     11|            for x in self.data.iter() {
                                   ^3        ^3
  139|     11|                let mut count: N = 0;
  140|     22|                for subset in parts.data.iter() {
                                            ^11        ^11
  141|     22|                    if subset.data.contains(x) {
  142|     11|                        count += 1;
  143|     11|                        if count > 1 {
  144|      1|                            return false;
  145|     10|                        }
  146|     11|                    }
  147|       |                }
  148|     10|                if count == 0 {
  149|      1|                    return false;
  150|      9|                }
  151|       |            }
  152|      1|            true
  153|      3|        }
  154|       |
  155|      5|        pub fn CartesianProduct<U: StT + Hash + Clone>(&self, other: &Set<U>) -> Set<Pair<T, U>>
  156|      5|        where
  157|      5|            T: Clone,
  158|       |        {
  159|      5|            let mut out: HashSet<Pair<T, U>> = HashSet::new();
  160|  20.0k|            for a in self.data.iter() {
                                   ^5        ^5
  161|  20.0k|                for b in other.data.iter() {
                                       ^20.0k     ^20.0k
  162|  20.0k|                    let _ = out.insert(Pair(a.clone(), b.clone()));
  163|  20.0k|                }
  164|       |            }
  165|      5|            Set { data: out }
  166|      5|        }
  167|       |
  168|   236k|        pub fn insert(&mut self, x: T) -> &mut Self {
  169|   236k|            let _ = self.data.insert(x);
  170|   236k|            self
  171|   236k|        }
  172|       |
  173|  99.8k|        pub fn iter(&self) -> std::collections::hash_set::Iter<'_, T> { self.data.iter() }
  174|       |
  175|     23|        pub fn FromVec(v: Vec<T>) -> Set<T> {
  176|     23|            let mut s = HashSet::with_capacity(v.len());
  177|   171k|            for x in v {
                              ^171k
  178|   171k|                let _ = s.insert(x);
  179|   171k|            }
  180|     23|            Set { data: s }
  181|     23|        }
  182|       |    }
  183|       |
  184|       |    impl<T: StT + Hash> SetStEphTrait<T> for Set<T> {
  185|      0|        fn empty() -> Set<T> { Set { data: HashSet::new() } }
  186|       |
  187|      0|        fn singleton(x: T) -> Set<T> {
  188|      0|            let mut s = HashSet::with_capacity(1);
  189|      0|            let _ = s.insert(x);
  190|      0|            Set { data: s }
  191|      0|        }
  192|       |
  193|      0|        fn size(&self) -> N { self.data.len() }
  194|       |
  195|      0|        fn mem(&self, x: &T) -> B { if self.data.contains(x) { true } else { false } }
  196|       |
  197|      0|        fn union(&self, other: &Set<T>) -> Set<T>
  198|      0|        where
  199|      0|            T: Clone,
  200|       |        {
  201|      0|            let mut out = self.clone();
  202|      0|            for x in other.data.iter() {
  203|      0|                let _ = out.data.insert(x.clone());
  204|      0|            }
  205|      0|            out
  206|      0|        }
  207|       |
  208|      0|        fn intersection(&self, other: &Set<T>) -> Set<T>
  209|      0|        where
  210|      0|            T: Clone,
  211|       |        {
  212|      0|            let mut out = HashSet::with_capacity(self.data.len().min(other.data.len()));
  213|      0|            for x in self.data.intersection(&other.data) {
  214|      0|                let _ = out.insert(x.clone());
  215|      0|            }
  216|      0|            Set { data: out }
  217|      0|        }
  218|       |
  219|      0|        fn partition(&self, parts: &Set<Set<T>>) -> B {
  220|      0|            for x in self.data.iter() {
  221|      0|                let mut count: N = 0;
  222|      0|                for subset in parts.data.iter() {
  223|      0|                    if subset.data.contains(x) {
  224|      0|                        count += 1;
  225|      0|                        if count > 1 {
  226|      0|                            return false;
  227|      0|                        }
  228|      0|                    }
  229|       |                }
  230|      0|                if count == 0 {
  231|      0|                    return false;
  232|      0|                }
  233|       |            }
  234|      0|            true
  235|      0|        }
  236|       |
  237|      0|        fn CartesianProduct<U: StT + Hash + Clone>(&self, other: &Set<U>) -> Set<Pair<T, U>>
  238|      0|        where
  239|      0|            T: Clone,
  240|       |        {
  241|      0|            let mut out: HashSet<Pair<T, U>> = HashSet::new();
  242|      0|            for a in self.data.iter() {
  243|      0|                for b in other.data.iter() {
  244|      0|                    let _ = out.insert(Pair(a.clone(), b.clone()));
  245|      0|                }
  246|       |            }
  247|      0|            Set { data: out }
  248|      0|        }
  249|       |
  250|      0|        fn insert(&mut self, x: T) -> &mut Self {
  251|      0|            let _ = self.data.insert(x);
  252|      0|            self
  253|      0|        }
  254|       |
  255|      0|        fn iter(&self) -> std::collections::hash_set::Iter<'_, T> { self.data.iter() }
  256|       |
  257|      0|        fn FromVec(v: Vec<T>) -> Set<T> {
  258|      0|            let mut s = HashSet::with_capacity(v.len());
  259|      0|            for x in v {
  260|      0|                let _ = s.insert(x);
  261|      0|            }
  262|      0|            Set { data: s }
  263|      0|        }
  264|       |    }
  265|       |
  266|       |    #[macro_export]
  267|       |    macro_rules! SetLit {
  268|       |        () => {{
  269|       |            < $crate::Chap05::SetStEph::SetStEph::Set<_> >::empty()
  270|       |        }};
  271|       |        ($($x:expr),* $(,)?) => {{
  272|       |            let mut __s = < $crate::Chap05::SetStEph::SetStEph::Set<_> >::empty();
  273|       |            $( let _ = __s.insert($x); )*
  274|       |            __s
  275|       |        }};
  276|       |    }
  277|       |
  278|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap06/DirGraphMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 6.1 Directed Graph (ephemeral) using Set for vertices and arcs - Multi-threaded version.
    3|       |//!
    4|       |//! Note: NOW uses true parallelism via ParaPair! for neighbor/degree operations.
    5|       |//! Arc filtering (NPlus, NMinus) and vertex map-reduce (NGOfVertices, etc.) are parallel.
    6|       |
    7|       |pub mod DirGraphMtEph {
    8|       |
    9|       |    use std::hash::Hash;
   10|       |
   11|       |    use crate::Chap05::SetStEph::SetStEph::*;
   12|       |    use crate::ParaPair;
   13|       |    use crate::SetLit;
   14|       |    use crate::Types::Types::*;
   15|       |
   16|       |    #[derive(Clone)]
   17|       |    pub struct DirGraphMtEph<V: StT + MtT + Hash + 'static> {
   18|       |        V: Set<V>,
   19|       |        A: Set<Edge<V>>,
   20|       |    }
   21|       |
   22|       |    pub trait DirGraphMtEphTrait<V: StT + MtT + Hash + 'static> {
   23|       |        /// APAS: Work (1), Span (1)
   24|       |        /// claude-4-sonet: Work (1), Span (1)
   25|       |        fn empty() -> DirGraphMtEph<V>;
   26|       |        /// APAS: Work (|V| + |A|), Span (1)
   27|       |        /// claude-4-sonet: Work (|V| + |A|), Span (1)
   28|       |        fn FromSets(V: Set<V>, A: Set<Edge<V>>) -> DirGraphMtEph<V>;
   29|       |        /// APAS: Work (1), Span (1)
   30|       |        /// claude-4-sonet: Work (1), Span (1)
   31|       |        fn vertices(&self) -> &Set<V>;
   32|       |        /// APAS: Work (1), Span (1)
   33|       |        /// claude-4-sonet: Work (1), Span (1)
   34|       |        fn arcs(&self) -> &Set<Edge<V>>;
   35|       |        /// APAS: Work (1), Span (1)
   36|       |        /// claude-4-sonet: Work (1), Span (1)
   37|       |        fn sizeV(&self) -> N;
   38|       |        /// APAS: Work (1), Span (1)
   39|       |        /// claude-4-sonet: Work (1), Span (1)
   40|       |        fn sizeA(&self) -> N;
   41|       |        /// APAS: Work (1), Span (1)
   42|       |        /// claude-4-sonet: Work (1), Span (1)
   43|       |        fn Neighbor(&self, u: &V, v: &V) -> B;
   44|       |        /// APAS: Work (|A|), Span (1)
   45|       |        /// claude-4-sonet: Work (|A|), Span (log |A|), Parallelism (|A|/log |A|) - parallel divide-and-conquer in NPlus+NMinus
   46|       |        fn NG(&self, v: &V) -> Set<V>;
   47|       |        /// APAS: Work (|u_set|  |A|), Span (1)
   48|       |        /// claude-4-sonet: Work (|u_set|  |A|), Span (log |u_set| + log |A|), Parallelism ((|u_set|  |A|)/(log |u_set| + log |A|)) - parallel map-reduce
   49|       |        fn NGOfVertices(&self, u_set: &Set<V>) -> Set<V>;
   50|       |        /// APAS: Work (|A|), Span (1)
   51|       |        /// claude-4-sonet: Work (|A|), Span (log |A|), Parallelism (|A|/log |A|) - parallel divide-and-conquer filter
   52|       |        fn NPlus(&self, v: &V) -> Set<V>;
   53|       |        /// APAS: Work (|A|), Span (1)
   54|       |        /// claude-4-sonet: Work (|A|), Span (log |A|), Parallelism (|A|/log |A|) - parallel divide-and-conquer filter
   55|       |        fn NMinus(&self, v: &V) -> Set<V>;
   56|       |        /// APAS: Work (|u_set|  |A|), Span (1)
   57|       |        /// claude-4-sonet: Work (|u_set|  |A|), Span (log |u_set| + log |A|), Parallelism ((|u_set|  |A|)/(log |u_set| + log |A|)) - parallel map-reduce
   58|       |        fn NPlusOfVertices(&self, u_set: &Set<V>) -> Set<V>;
   59|       |        /// APAS: Work (|u_set|  |A|), Span (1)
   60|       |        /// claude-4-sonet: Work (|u_set|  |A|), Span (log |u_set| + log |A|), Parallelism ((|u_set|  |A|)/(log |u_set| + log |A|)) - parallel map-reduce
   61|       |        fn NMinusOfVertices(&self, u_set: &Set<V>) -> Set<V>;
   62|       |        /// APAS: Work (1), Span (1)
   63|       |        /// claude-4-sonet: Work (1), Span (1)
   64|       |        fn Incident(&self, e: &Edge<V>, v: &V) -> B;
   65|       |        /// APAS: Work (|A|), Span (1)
   66|       |        /// claude-4-sonet: Work (|A|), Span (log |A|), Parallelism (|A|/log |A|) - calls parallel InDegree + OutDegree
   67|       |        fn Degree(&self, v: &V) -> N;
   68|       |        /// APAS: Work (|A|), Span (1)
   69|       |        /// claude-4-sonet: Work (|A|), Span (log |A|), Parallelism (|A|/log |A|) - calls parallel NMinus
   70|       |        fn InDegree(&self, v: &V) -> N;
   71|       |        /// APAS: Work (|A|), Span (1)
   72|       |        /// claude-4-sonet: Work (|A|), Span (log |A|), Parallelism (|A|/log |A|) - calls parallel NPlus
   73|       |        fn OutDegree(&self, v: &V) -> N;
   74|       |    }
   75|       |
   76|       |    impl<V: StT + MtT + Hash + 'static> DirGraphMtEphTrait<V> for DirGraphMtEph<V> {
   77|      4|        fn empty() -> DirGraphMtEph<V> {
   78|      4|            DirGraphMtEph {
   79|      4|                V: SetLit![],
   80|      4|                A: SetLit![],
   81|      4|            }
   82|      4|        }
   83|     81|        fn FromSets(V: Set<V>, A: Set<Edge<V>>) -> DirGraphMtEph<V> { DirGraphMtEph { V, A } }
   84|      5|        fn vertices(&self) -> &Set<V> { &self.V }
   85|      4|        fn arcs(&self) -> &Set<Edge<V>> { &self.A }
   86|  1.77k|        fn sizeV(&self) -> N { self.V.size() }
   87|  1.77k|        fn sizeA(&self) -> N { self.A.size() }
   88|       |
   89|  8.64k|        fn Neighbor(&self, u: &V, v: &V) -> B {
   90|       |            // Adjacent if there is an arc either way
   91|  8.64k|            if true == self.A.mem(&Edge(u.clone_mt(), v.clone_mt())) {
   92|  7.83k|                true
   93|       |            } else {
   94|    813|                false
   95|       |            }
   96|  8.64k|        }
   97|       |
   98|  16.5k|        fn NG(&self, v: &V) -> Set<V> { self.NPlus(v).union(&self.NMinus(v)) }
   99|       |
  100|  7.62k|        fn NGOfVertices(&self, u_set: &Set<V>) -> Set<V> {
  101|       |            // PARALLEL: map-reduce over vertices using divide-and-conquer
  102|  7.62k|            let vertices: Vec<V> = u_set.iter().cloned().collect();
  103|  7.62k|            let n = vertices.len();
  104|       |
  105|  7.62k|            if n <= 8 {
  106|  7.62k|                let mut result: Set<V> = SetLit![];
  107|  22.8k|                for u in vertices {
                                  ^15.2k
  108|  15.2k|                    let ng_u = self.NG(&u);
  109|  15.2k|                    result = result.union(&ng_u);
  110|  15.2k|                }
  111|  7.62k|                return result;
  112|      0|            }
  113|       |
  114|       |            // Parallel map-reduce
  115|      0|            fn parallel_ng_of_vertices<V: StT + MtT + Hash + 'static>(
  116|      0|                vertices: Vec<V>,
  117|      0|                graph: DirGraphMtEph<V>,
  118|      0|            ) -> Set<V> {
  119|      0|                let n = vertices.len();
  120|      0|                if n == 0 {
  121|      0|                    return SetLit![];
  122|      0|                }
  123|      0|                if n == 1 {
  124|      0|                    return graph.NG(&vertices[0]);
  125|      0|                }
  126|       |
  127|      0|                let mid = n / 2;
  128|      0|                let mut right_verts = vertices;
  129|      0|                let left_verts = right_verts.split_off(mid);
  130|       |
  131|      0|                let graph_left = graph.clone();
  132|      0|                let graph_right = graph;
  133|       |
  134|      0|                let Pair(left_result, right_result) =
  135|      0|                    ParaPair!(move || parallel_ng_of_vertices(left_verts, graph_left), move || {
  136|      0|                        parallel_ng_of_vertices(right_verts, graph_right)
  137|      0|                    });
  138|       |
  139|      0|                left_result.union(&right_result)
  140|      0|            }
  141|       |
  142|      0|            parallel_ng_of_vertices(vertices, self.clone())
  143|  7.62k|        }
  144|       |
  145|  33.8k|        fn NPlus(&self, v: &V) -> Set<V> {
  146|       |            // PARALLEL: filter arcs using divide-and-conquer
  147|  33.8k|            let arcs: Vec<Edge<V>> = self.A.iter().cloned().collect();
  148|  33.8k|            let n = arcs.len();
  149|       |
  150|  33.8k|            if n <= 8 {
  151|  33.8k|                let mut out: Set<V> = SetLit![];
  152|   114k|                for Edge(x, y) in arcs {
                                       ^80.1k^80.1k
  153|  80.1k|                    if x == *v {
  154|  33.4k|                        let _ = out.insert(y.clone_mt());
  155|  46.7k|                    }
  156|       |                }
  157|  33.8k|                return out;
  158|      0|            }
  159|       |
  160|       |            // Parallel divide-and-conquer
  161|      0|            fn parallel_nplus<V: StT + MtT + Hash + 'static>(arcs: Vec<Edge<V>>, v: V) -> Set<V> {
  162|      0|                let n = arcs.len();
  163|      0|                if n == 0 {
  164|      0|                    return SetLit![];
  165|      0|                }
  166|      0|                if n == 1 {
  167|      0|                    let Edge(x, y) = &arcs[0];
  168|      0|                    return if x == &v {
  169|      0|                        let mut s = SetLit![];
  170|      0|                        s.insert(y.clone_mt());
  171|      0|                        s
  172|       |                    } else {
  173|      0|                        SetLit![]
  174|       |                    };
  175|      0|                }
  176|       |
  177|      0|                let mid = n / 2;
  178|      0|                let mut right_arcs = arcs;
  179|      0|                let left_arcs = right_arcs.split_off(mid);
  180|       |
  181|      0|                let v_left = v.clone_mt();
  182|      0|                let v_right = v;
  183|       |
  184|      0|                let Pair(left_result, right_result) =
  185|      0|                    ParaPair!(move || parallel_nplus(left_arcs, v_left), move || parallel_nplus(
  186|      0|                        right_arcs, v_right
  187|       |                    ));
  188|       |
  189|      0|                left_result.union(&right_result)
  190|      0|            }
  191|       |
  192|      0|            parallel_nplus(arcs, v.clone_mt())
  193|  33.8k|        }
  194|       |
  195|  41.0k|        fn NMinus(&self, v: &V) -> Set<V> {
  196|       |            // PARALLEL: filter arcs using divide-and-conquer
  197|  41.0k|            let arcs: Vec<Edge<V>> = self.A.iter().cloned().collect();
  198|  41.0k|            let n = arcs.len();
  199|       |
  200|  41.0k|            if n <= 8 {
  201|  41.0k|                let mut inn: Set<V> = SetLit![];
  202|   135k|                for Edge(x, y) in arcs {
                                       ^94.4k^94.4k
  203|  94.4k|                    if y == *v {
  204|  32.4k|                        let _ = inn.insert(x.clone_mt());
  205|  61.9k|                    }
  206|       |                }
  207|  41.0k|                return inn;
  208|      0|            }
  209|       |
  210|       |            // Parallel divide-and-conquer
  211|      0|            fn parallel_nminus<V: StT + MtT + Hash + 'static>(arcs: Vec<Edge<V>>, v: V) -> Set<V> {
  212|      0|                let n = arcs.len();
  213|      0|                if n == 0 {
  214|      0|                    return SetLit![];
  215|      0|                }
  216|      0|                if n == 1 {
  217|      0|                    let Edge(x, y) = &arcs[0];
  218|      0|                    return if y == &v {
  219|      0|                        let mut s = SetLit![];
  220|      0|                        s.insert(x.clone_mt());
  221|      0|                        s
  222|       |                    } else {
  223|      0|                        SetLit![]
  224|       |                    };
  225|      0|                }
  226|       |
  227|      0|                let mid = n / 2;
  228|      0|                let mut right_arcs = arcs;
  229|      0|                let left_arcs = right_arcs.split_off(mid);
  230|       |
  231|      0|                let v_left = v.clone_mt();
  232|      0|                let v_right = v;
  233|       |
  234|      0|                let Pair(left_result, right_result) = ParaPair!(
  235|      0|                    move || parallel_nminus(left_arcs, v_left),
  236|      0|                    move || parallel_nminus(right_arcs, v_right)
  237|       |                );
  238|       |
  239|      0|                left_result.union(&right_result)
  240|      0|            }
  241|       |
  242|      0|            parallel_nminus(arcs, v.clone_mt())
  243|  41.0k|        }
  244|       |
  245|  6.52k|        fn NPlusOfVertices(&self, u_set: &Set<V>) -> Set<V> {
  246|       |            // PARALLEL: map-reduce over vertices using divide-and-conquer
  247|  6.52k|            let vertices: Vec<V> = u_set.iter().cloned().collect();
  248|  6.52k|            let n = vertices.len();
  249|       |
  250|  6.52k|            if n <= 8 {
  251|  6.52k|                let mut result: Set<V> = SetLit![];
  252|  19.5k|                for u in vertices {
                                  ^13.0k
  253|  13.0k|                    let plus_u = self.NPlus(&u);
  254|  13.0k|                    result = result.union(&plus_u);
  255|  13.0k|                }
  256|  6.52k|                return result;
  257|      0|            }
  258|       |
  259|       |            // Parallel map-reduce
  260|      0|            fn parallel_nplus_of_vertices<V: StT + MtT + Hash + 'static>(
  261|      0|                vertices: Vec<V>,
  262|      0|                graph: DirGraphMtEph<V>,
  263|      0|            ) -> Set<V> {
  264|      0|                let n = vertices.len();
  265|      0|                if n == 0 {
  266|      0|                    return SetLit![];
  267|      0|                }
  268|      0|                if n == 1 {
  269|      0|                    return graph.NPlus(&vertices[0]);
  270|      0|                }
  271|       |
  272|      0|                let mid = n / 2;
  273|      0|                let mut right_verts = vertices;
  274|      0|                let left_verts = right_verts.split_off(mid);
  275|       |
  276|      0|                let graph_left = graph.clone();
  277|      0|                let graph_right = graph;
  278|       |
  279|      0|                let Pair(left_result, right_result) =
  280|      0|                    ParaPair!(move || parallel_nplus_of_vertices(left_verts, graph_left), move || {
  281|      0|                        parallel_nplus_of_vertices(right_verts, graph_right)
  282|      0|                    });
  283|       |
  284|      0|                left_result.union(&right_result)
  285|      0|            }
  286|       |
  287|      0|            parallel_nplus_of_vertices(vertices, self.clone())
  288|  6.52k|        }
  289|       |
  290|  6.52k|        fn NMinusOfVertices(&self, u_set: &Set<V>) -> Set<V> {
  291|       |            // PARALLEL: map-reduce over vertices using divide-and-conquer
  292|  6.52k|            let vertices: Vec<V> = u_set.iter().cloned().collect();
  293|  6.52k|            let n = vertices.len();
  294|       |
  295|  6.52k|            if n <= 8 {
  296|  6.52k|                let mut result: Set<V> = SetLit![];
  297|  19.5k|                for u in vertices {
                                  ^13.0k
  298|  13.0k|                    let minus_u = self.NMinus(&u);
  299|  13.0k|                    result = result.union(&minus_u);
  300|  13.0k|                }
  301|  6.52k|                return result;
  302|      0|            }
  303|       |
  304|       |            // Parallel map-reduce
  305|      0|            fn parallel_nminus_of_vertices<V: StT + MtT + Hash + 'static>(
  306|      0|                vertices: Vec<V>,
  307|      0|                graph: DirGraphMtEph<V>,
  308|      0|            ) -> Set<V> {
  309|      0|                let n = vertices.len();
  310|      0|                if n == 0 {
  311|      0|                    return SetLit![];
  312|      0|                }
  313|      0|                if n == 1 {
  314|      0|                    return graph.NMinus(&vertices[0]);
  315|      0|                }
  316|       |
  317|      0|                let mid = n / 2;
  318|      0|                let mut right_verts = vertices;
  319|      0|                let left_verts = right_verts.split_off(mid);
  320|       |
  321|      0|                let graph_left = graph.clone();
  322|      0|                let graph_right = graph;
  323|       |
  324|      0|                let Pair(left_result, right_result) =
  325|      0|                    ParaPair!(move || parallel_nminus_of_vertices(left_verts, graph_left), move || {
  326|      0|                        parallel_nminus_of_vertices(right_verts, graph_right)
  327|      0|                    });
  328|       |
  329|      0|                left_result.union(&right_result)
  330|      0|            }
  331|       |
  332|      0|            parallel_nminus_of_vertices(vertices, self.clone())
  333|  6.52k|        }
  334|       |
  335|  7.62k|        fn Incident(&self, e: &Edge<V>, v: &V) -> B { if &e.0 == v || &e.1 == v { true } else { false } }
                                                                                    ^3          ^7.62k        ^1
  336|       |
  337|  1.71k|        fn Degree(&self, v: &V) -> N { self.InDegree(v) + self.OutDegree(v) }
  338|  3.00k|        fn InDegree(&self, v: &V) -> N { self.NMinus(v).size() }
  339|  3.00k|        fn OutDegree(&self, v: &V) -> N { self.NPlus(v).size() }
  340|       |    }
  341|       |
  342|       |    impl<V: StT + MtT + Hash + 'static> std::fmt::Debug for DirGraphMtEph<V> {
  343|      0|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  344|      0|            f.debug_struct("DirGraphMtEph")
  345|      0|                .field("V", &self.V)
  346|      0|                .field("A", &self.A)
  347|      0|                .finish()
  348|      0|        }
  349|       |    }
  350|       |
  351|       |    impl<V: StT + MtT + Hash + 'static> std::fmt::Display for DirGraphMtEph<V> {
  352|      0|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, "V={} A={:?}", self.V, self.A) }
  353|       |    }
  354|       |
  355|       |    impl<V: StT + MtT + Hash + 'static> PartialEq for DirGraphMtEph<V> {
  356|      0|        fn eq(&self, other: &Self) -> bool { self.V == other.V && self.A == other.A }
  357|       |    }
  358|       |    impl<V: StT + MtT + Hash + 'static> Eq for DirGraphMtEph<V> {}
  359|       |
  360|       |    #[macro_export]
  361|       |    macro_rules! DirGraphMtEphLit {
  362|       |        () => {{
  363|       |            let __V: $crate::Chap05::SetStEph::SetStEph::Set<_> = $crate::SetLit![];
  364|       |            let __A: $crate::Chap05::SetStEph::SetStEph::Set<$crate::Types::Types::Edge<_>> = $crate::SetLit![];
  365|       |            < $crate::Chap06::DirGraphMtEph::DirGraphMtEph::DirGraphMtEph<_> as $crate::Chap06::DirGraphMtEph::DirGraphMtEph::DirGraphMtEphTrait<_> >::FromSets(__V, __A)
  366|       |        }};
  367|       |        ( V: [ $( $v:expr ),* $(,)? ], A: [ $( ( $u:expr , $w:expr ) ),* $(,)? ] ) => {{
  368|       |            let __V: $crate::Chap05::SetStEph::SetStEph::Set<_> = $crate::SetLit![ $( $v ),* ];
  369|       |            let __A: $crate::Chap05::SetStEph::SetStEph::Set<_> = {
  370|       |                let mut __s = < $crate::Chap05::SetStEph::SetStEph::Set<_> >::empty();
  371|       |                $( let _ = __s.insert($crate::Types::Types::Edge($u, $w)); )*
  372|       |                __s
  373|       |            };
  374|       |            < $crate::Chap06::DirGraphMtEph::DirGraphMtEph::DirGraphMtEph<_> as $crate::Chap06::DirGraphMtEph::DirGraphMtEph::DirGraphMtEphTrait<_> >::FromSets(__V, __A)
  375|       |        }}}
  376|       |
  377|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap06/DirGraphStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 6.1 Directed Graph (ephemeral) using Set for vertices and arcs.
    3|       |
    4|       |pub mod DirGraphStEph {
    5|       |
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |    use std::hash::Hash;
    8|       |
    9|       |    use crate::Chap05::SetStEph::SetStEph::*;
   10|       |    use crate::SetLit;
   11|       |    use crate::Types::Types::*;
   12|       |
   13|       |    #[derive(Clone)]
   14|       |    pub struct DirGraphStEph<V: StT + Hash> {
   15|       |        V: Set<V>,
   16|       |        A: Set<Edge<V>>,
   17|       |    }
   18|       |
   19|       |    pub trait DirGraphStEphTrait<V: StT + Hash> {
   20|       |        /// APAS: Work (1), Span (1)
   21|       |        /// claude-4-sonet: Work (1), Span (1)
   22|       |        fn empty() -> DirGraphStEph<V>;
   23|       |        /// APAS: Work (|V| + |A|), Span (1)
   24|       |        /// claude-4-sonet: Work (|V| + |A|), Span (1)
   25|       |        fn FromSets(V: Set<V>, A: Set<Edge<V>>) -> DirGraphStEph<V>;
   26|       |        /// APAS: Work (1), Span (1)
   27|       |        /// claude-4-sonet: Work (1), Span (1)
   28|       |        fn vertices(&self) -> &Set<V>;
   29|       |        /// APAS: Work (1), Span (1)
   30|       |        /// claude-4-sonet: Work (1), Span (1)
   31|       |        fn arcs(&self) -> &Set<Edge<V>>;
   32|       |        /// APAS: Work (1), Span (1)
   33|       |        /// claude-4-sonet: Work (1), Span (1)
   34|       |        fn sizeV(&self) -> N;
   35|       |        /// APAS: Work (1), Span (1)
   36|       |        /// claude-4-sonet: Work (1), Span (1)
   37|       |        fn sizeA(&self) -> N;
   38|       |        /// APAS: Work (1), Span (1)
   39|       |        /// claude-4-sonet: Work (1), Span (1)
   40|       |        fn Neighbor(&self, u: &V, v: &V) -> B;
   41|       |        /// APAS: Work (|A|), Span (1)
   42|       |        /// claude-4-sonet: Work (|A|), Span (1)
   43|       |        fn NG(&self, v: &V) -> Set<V>;
   44|       |        /// APAS: Work (|u_set|  |A|), Span (1)
   45|       |        /// claude-4-sonet: Work (|u_set|  |A|), Span (1)
   46|       |        fn NGOfVertices(&self, u_set: &Set<V>) -> Set<V>;
   47|       |        /// APAS: Work (|A|), Span (1)
   48|       |        /// claude-4-sonet: Work (|A|), Span (1)
   49|       |        fn NPlus(&self, v: &V) -> Set<V>;
   50|       |        /// APAS: Work (|A|), Span (1)
   51|       |        /// claude-4-sonet: Work (|A|), Span (1)
   52|       |        fn NMinus(&self, v: &V) -> Set<V>;
   53|       |        /// APAS: Work (|u_set|  |A|), Span (1)
   54|       |        /// claude-4-sonet: Work (|u_set|  |A|), Span (1)
   55|       |        fn NPlusOfVertices(&self, u_set: &Set<V>) -> Set<V>;
   56|       |        /// APAS: Work (|u_set|  |A|), Span (1)
   57|       |        /// claude-4-sonet: Work (|u_set|  |A|), Span (1)
   58|       |        fn NMinusOfVertices(&self, u_set: &Set<V>) -> Set<V>;
   59|       |        /// APAS: Work (1), Span (1)
   60|       |        /// claude-4-sonet: Work (1), Span (1)
   61|       |        fn Incident(&self, e: &Edge<V>, v: &V) -> B;
   62|       |        /// APAS: Work (|A|), Span (1)
   63|       |        /// claude-4-sonet: Work (|A|), Span (1)
   64|       |        fn Degree(&self, v: &V) -> N;
   65|       |        /// APAS: Work (|A|), Span (1)
   66|       |        /// claude-4-sonet: Work (|A|), Span (1)
   67|       |        fn InDegree(&self, v: &V) -> N;
   68|       |        /// APAS: Work (|A|), Span (1)
   69|       |        /// claude-4-sonet: Work (|A|), Span (1)
   70|       |        fn OutDegree(&self, v: &V) -> N;
   71|       |    }
   72|       |
   73|       |    impl<V: StT + Hash> DirGraphStEphTrait<V> for DirGraphStEph<V> {
   74|      2|        fn empty() -> DirGraphStEph<V> {
   75|      2|            DirGraphStEph {
   76|      2|                V: SetLit![],
   77|      2|                A: SetLit![],
   78|      2|            }
   79|      2|        }
   80|     19|        fn FromSets(V: Set<V>, A: Set<Edge<V>>) -> DirGraphStEph<V> { DirGraphStEph { V, A } }
   81|      4|        fn vertices(&self) -> &Set<V> { &self.V }
   82|      4|        fn arcs(&self) -> &Set<Edge<V>> { &self.A }
   83|      4|        fn sizeV(&self) -> N { self.V.size() }
   84|      4|        fn sizeA(&self) -> N { self.A.size() }
   85|       |
   86|     19|        fn Neighbor(&self, u: &V, v: &V) -> B {
   87|       |            // Adjacent if there is an arc either way
   88|     19|            if true == self.A.mem(&Edge(u.clone(), v.clone())) {
   89|      8|                true
   90|       |            } else {
   91|     11|                false
   92|       |            }
   93|     19|        }
   94|       |
   95|     13|        fn NG(&self, v: &V) -> Set<V> { self.NPlus(v).union(&self.NMinus(v)) }
   96|       |
   97|      2|        fn NGOfVertices(&self, u_set: &Set<V>) -> Set<V> {
   98|      2|            let mut result: Set<V> = SetLit![];
   99|      7|            for u in u_set.iter() {
                                   ^2    ^2
  100|      7|                let ng_u = self.NG(u);
  101|      7|                result = result.union(&ng_u);
  102|      7|            }
  103|      2|            result
  104|      2|        }
  105|       |
  106|     39|        fn NPlus(&self, v: &V) -> Set<V> {
  107|     39|            let mut out: Set<V> = SetLit![];
  108|  8.12k|            for Edge(x, y) in self.A.iter().cloned() {
                                            ^39    ^39    ^39
  109|  8.12k|                if x == *v {
  110|     28|                    let _ = out.insert(y.clone());
  111|  8.09k|                }
  112|       |            }
  113|     39|            out
  114|     39|        }
  115|       |
  116|     40|        fn NMinus(&self, v: &V) -> Set<V> {
  117|     40|            let mut inn: Set<V> = SetLit![];
  118|  9.13k|            for Edge(x, y) in self.A.iter().cloned() {
                                            ^40    ^40    ^40
  119|  9.13k|                if y == *v {
  120|     25|                    let _ = inn.insert(x.clone());
  121|  9.11k|                }
  122|       |            }
  123|     40|            inn
  124|     40|        }
  125|       |
  126|      1|        fn NPlusOfVertices(&self, u_set: &Set<V>) -> Set<V> {
  127|      1|            let mut result: Set<V> = SetLit![];
  128|      2|            for u in u_set.iter() {
                                   ^1    ^1
  129|      2|                let plus_u = self.NPlus(u);
  130|      2|                result = result.union(&plus_u);
  131|      2|            }
  132|      1|            result
  133|      1|        }
  134|       |
  135|      1|        fn NMinusOfVertices(&self, u_set: &Set<V>) -> Set<V> {
  136|      1|            let mut result: Set<V> = SetLit![];
  137|      2|            for u in u_set.iter() {
                                   ^1    ^1
  138|      2|                let minus_u = self.NMinus(u);
  139|      2|                result = result.union(&minus_u);
  140|      2|            }
  141|      1|            result
  142|      1|        }
  143|       |
  144|      6|        fn Incident(&self, e: &Edge<V>, v: &V) -> B { if &e.0 == v || &e.1 == v { true } else { false } }
                                                                                    ^3          ^5            ^1
  145|       |
  146|     12|        fn Degree(&self, v: &V) -> N { self.InDegree(v) + self.OutDegree(v) }
  147|     22|        fn InDegree(&self, v: &V) -> N { self.NMinus(v).size() }
  148|     21|        fn OutDegree(&self, v: &V) -> N { self.NPlus(v).size() }
  149|       |    }
  150|       |
  151|       |    impl<V: StT + Hash> Debug for DirGraphStEph<V> {
  152|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  153|      0|            f.debug_struct("DirGraphStEph")
  154|      0|                .field("V", &self.V)
  155|      0|                .field("A", &self.A)
  156|      0|                .finish()
  157|      0|        }
  158|       |    }
  159|       |
  160|       |    impl<V: StT + Hash> Display for DirGraphStEph<V> {
  161|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { write!(f, "V={} A={:?}", self.V, self.A) }
  162|       |    }
  163|       |
  164|       |    impl<V: StT + Hash> PartialEq for DirGraphStEph<V> {
  165|      0|        fn eq(&self, other: &Self) -> bool { self.V == other.V && self.A == other.A }
  166|       |    }
  167|       |    impl<V: StT + Hash> Eq for DirGraphStEph<V> {}
  168|       |
  169|       |    #[macro_export]
  170|       |    macro_rules! DirGraphStEphLit {
  171|       |        () => {{
  172|       |            let __V: $crate::Chap05::SetStEph::SetStEph::Set<_> = $crate::SetLit![];
  173|       |            let __A: $crate::Chap05::SetStEph::SetStEph::Set<$crate::Types::Types::Edge<_>> = $crate::SetLit![];
  174|       |            < $crate::Chap06::DirGraphStEph::DirGraphStEph::DirGraphStEph<_> as $crate::Chap06::DirGraphStEph::DirGraphStEph::DirGraphStEphTrait<_> >::FromSets(__V, __A)
  175|       |        }};
  176|       |        ( V: [ $( $v:expr ),* $(,)? ], A: [ $( ( $u:expr , $w:expr ) ),* $(,)? ] ) => {{
  177|       |            let __V: $crate::Chap05::SetStEph::SetStEph::Set<_> = $crate::SetLit![ $( $v ),* ];
  178|       |            let __A: $crate::Chap05::SetStEph::SetStEph::Set<_> = {
  179|       |                let mut __s = < $crate::Chap05::SetStEph::SetStEph::Set<_> >::empty();
  180|       |                $( let _ = __s.insert($crate::Types::Types::Edge($u, $w)); )*
  181|       |                __s
  182|       |            };
  183|       |            < $crate::Chap06::DirGraphStEph::DirGraphStEph::DirGraphStEph<_> as $crate::Chap06::DirGraphStEph::DirGraphStEph::DirGraphStEphTrait<_> >::FromSets(__V, __A)
  184|       |        }}}
  185|       |
  186|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap06/LabDirGraphMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 6 Labeled Directed Graph (ephemeral) using Set for vertices and labeled arcs - Multi-threaded version.
    3|       |//!
    4|       |//! Note: NOW uses true parallelism via ParaPair! for neighbor operations.
    5|       |//! Labeled arc filtering (out_neighbors, in_neighbors) are parallel.
    6|       |
    7|       |pub mod LabDirGraphMtEph {
    8|       |
    9|       |    use std::fmt::{Debug, Display, Formatter, Result};
   10|       |    use std::hash::Hash;
   11|       |
   12|       |    use crate::Chap05::SetStEph::SetStEph::*;
   13|       |    use crate::ParaPair;
   14|       |    use crate::SetLit;
   15|       |    use crate::Types::Types::*;
   16|       |
   17|       |    #[derive(Clone)]
   18|       |    pub struct LabDirGraphMtEph<V: StT + MtT + Hash + 'static, L: StTInMtT + Hash + 'static> {
   19|       |        vertices: Set<V>,
   20|       |        labeled_arcs: Set<LabEdge<V, L>>,
   21|       |    }
   22|       |
   23|       |    pub trait LabDirGraphMtEphTrait<V: StT + MtT + Hash + 'static, L: StTInMtT + Hash + 'static> {
   24|       |        /// APAS: Work (1), Span (1)
   25|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   26|       |        fn empty() -> Self;
   27|       |        /// APAS: Work (|V| + |A|), Span (1)
   28|       |        /// claude-4-sonet: Work (|V| + |A|), Span (|V| + |A|), Parallelism (1) - sequential
   29|       |        fn from_vertices_and_labeled_arcs(vertices: Set<V>, labeled_arcs: Set<LabEdge<V, L>>) -> Self;
   30|       |        /// APAS: Work (1), Span (1)
   31|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   32|       |        fn vertices(&self) -> &Set<V>;
   33|       |        /// APAS: Work (1), Span (1)
   34|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   35|       |        fn labeled_arcs(&self) -> &Set<LabEdge<V, L>>;
   36|       |        /// APAS: Work (|A|), Span (1)
   37|       |        /// claude-4-sonet: Work (|A|), Span (|A|), Parallelism (1) - sequential map
   38|       |        fn arcs(&self) -> Set<Edge<V>>;
   39|       |        /// APAS: Work (1), Span (1)
   40|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   41|       |        fn add_vertex(&mut self, v: V);
   42|       |        /// APAS: Work (1), Span (1)
   43|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   44|       |        fn add_labeled_arc(&mut self, from: V, to: V, label: L);
   45|       |        /// APAS: Work (|A|), Span (1)
   46|       |        /// claude-4-sonet: Work (|A|), Span (|A|), Parallelism (1) - sequential search
   47|       |        fn get_arc_label(&self, from: &V, to: &V) -> Option<&L>;
   48|       |        /// APAS: Work (|A|), Span (1)
   49|       |        /// claude-4-sonet: Work (|A|), Span (|A|), Parallelism (1) - sequential search
   50|       |        fn has_arc(&self, from: &V, to: &V) -> bool;
   51|       |        /// APAS: Work (|A|), Span (1)
   52|       |        /// claude-4-sonet: Work (|A|), Span (log |A|), Parallelism (|A|/log |A|) - parallel divide-and-conquer filter
   53|       |        fn out_neighbors(&self, v: &V) -> Set<V>;
   54|       |        /// APAS: Work (|A|), Span (1)
   55|       |        /// claude-4-sonet: Work (|A|), Span (log |A|), Parallelism (|A|/log |A|) - parallel divide-and-conquer filter
   56|       |        fn in_neighbors(&self, v: &V) -> Set<V>;
   57|       |    }
   58|       |
   59|       |    impl<V: StT + MtT + Hash + 'static, L: StTInMtT + Hash + 'static> LabDirGraphMtEphTrait<V, L>
   60|       |        for LabDirGraphMtEph<V, L>
   61|       |    {
   62|     10|        fn empty() -> Self {
   63|     10|            LabDirGraphMtEph {
   64|     10|                vertices: Set::empty(),
   65|     10|                labeled_arcs: Set::empty(),
   66|     10|            }
   67|     10|        }
   68|       |
   69|     56|        fn from_vertices_and_labeled_arcs(vertices: Set<V>, labeled_arcs: Set<LabEdge<V, L>>) -> Self {
   70|     56|            LabDirGraphMtEph { vertices, labeled_arcs }
   71|     56|        }
   72|       |
   73|     53|        fn vertices(&self) -> &Set<V> { &self.vertices }
   74|       |
   75|    124|        fn labeled_arcs(&self) -> &Set<LabEdge<V, L>> { &self.labeled_arcs }
   76|       |
   77|      4|        fn arcs(&self) -> Set<Edge<V>> {
   78|      4|            let mut arcs = Set::empty();
   79|      8|            for labeled_arc in self.labeled_arcs.iter() {
                                             ^4                ^4
   80|      8|                arcs.insert(Edge(labeled_arc.0.clone_mt(), labeled_arc.1.clone_mt()));
   81|      8|            }
   82|      4|            arcs
   83|      4|        }
   84|       |
   85|      3|        fn add_vertex(&mut self, v: V) { self.vertices.insert(v); }
   86|       |
   87|      2|        fn add_labeled_arc(&mut self, from: V, to: V, label: L) {
   88|      2|            self.vertices.insert(from.clone_mt());
   89|      2|            self.vertices.insert(to.clone_mt());
   90|      2|            self.labeled_arcs.insert(LabEdge(from, to, label));
   91|      2|        }
   92|       |
   93|     15|        fn get_arc_label(&self, from: &V, to: &V) -> Option<&L> {
   94|     26|            for labeled_arc in self.labeled_arcs.iter() {
                                             ^15               ^15
   95|     26|                if labeled_arc.0 == *from && labeled_arc.1 == *to {
                                                           ^11
   96|     10|                    return Some(&labeled_arc.2);
   97|     16|                }
   98|       |            }
   99|      5|            None
  100|     15|        }
  101|       |
  102|     51|        fn has_arc(&self, from: &V, to: &V) -> bool {
  103|    119|            for labeled_arc in self.labeled_arcs.iter() {
                                             ^51               ^51
  104|    119|                if labeled_arc.0 == *from && labeled_arc.1 == *to {
                                                           ^47
  105|     38|                    return true;
  106|     81|                }
  107|       |            }
  108|     13|            false
  109|     51|        }
  110|       |
  111|    135|        fn out_neighbors(&self, v: &V) -> Set<V> {
  112|       |            // PARALLEL: filter labeled arcs using divide-and-conquer
  113|    135|            let arcs: Vec<LabEdge<V, L>> = self.labeled_arcs.iter().cloned().collect();
  114|    135|            let n = arcs.len();
  115|       |
  116|    135|            if n <= 8 {
  117|    135|                let mut neighbors = Set::empty();
  118|    611|                for labeled_arc in arcs {
                                  ^476
  119|    476|                    if labeled_arc.0 == *v {
  120|    122|                        neighbors.insert(labeled_arc.1.clone_mt());
  121|    354|                    }
  122|       |                }
  123|    135|                return neighbors;
  124|      0|            }
  125|       |
  126|       |            // Parallel divide-and-conquer
  127|      0|            fn parallel_out<V: StT + MtT + Hash + 'static, L: StTInMtT + Hash + 'static>(
  128|      0|                arcs: Vec<LabEdge<V, L>>,
  129|      0|                v: V,
  130|      0|            ) -> Set<V> {
  131|      0|                let n = arcs.len();
  132|      0|                if n == 0 {
  133|      0|                    return Set::empty();
  134|      0|                }
  135|      0|                if n == 1 {
  136|      0|                    return if arcs[0].0 == v {
  137|      0|                        let mut s = Set::empty();
  138|      0|                        s.insert(arcs[0].1.clone_mt());
  139|      0|                        s
  140|       |                    } else {
  141|      0|                        Set::empty()
  142|       |                    };
  143|      0|                }
  144|       |
  145|      0|                let mid = n / 2;
  146|      0|                let mut right_arcs = arcs;
  147|      0|                let left_arcs = right_arcs.split_off(mid);
  148|       |
  149|      0|                let v_left = v.clone_mt();
  150|      0|                let v_right = v;
  151|       |
  152|      0|                let Pair(left_result, right_result) =
  153|      0|                    ParaPair!(move || parallel_out(left_arcs, v_left), move || parallel_out(
  154|      0|                        right_arcs, v_right
  155|       |                    ));
  156|       |
  157|      0|                left_result.union(&right_result)
  158|      0|            }
  159|       |
  160|      0|            parallel_out(arcs, v.clone_mt())
  161|    135|        }
  162|       |
  163|     68|        fn in_neighbors(&self, v: &V) -> Set<V> {
  164|       |            // PARALLEL: filter labeled arcs using divide-and-conquer
  165|     68|            let arcs: Vec<LabEdge<V, L>> = self.labeled_arcs.iter().cloned().collect();
  166|     68|            let n = arcs.len();
  167|       |
  168|     68|            if n <= 8 {
  169|     68|                let mut neighbors = Set::empty();
  170|    319|                for labeled_arc in arcs {
                                  ^251
  171|    251|                    if labeled_arc.1 == *v {
  172|     57|                        neighbors.insert(labeled_arc.0.clone_mt());
  173|    194|                    }
  174|       |                }
  175|     68|                return neighbors;
  176|      0|            }
  177|       |
  178|       |            // Parallel divide-and-conquer
  179|      0|            fn parallel_in<V: StT + MtT + Hash + 'static, L: StTInMtT + Hash + 'static>(
  180|      0|                arcs: Vec<LabEdge<V, L>>,
  181|      0|                v: V,
  182|      0|            ) -> Set<V> {
  183|      0|                let n = arcs.len();
  184|      0|                if n == 0 {
  185|      0|                    return Set::empty();
  186|      0|                }
  187|      0|                if n == 1 {
  188|      0|                    return if arcs[0].1 == v {
  189|      0|                        let mut s = Set::empty();
  190|      0|                        s.insert(arcs[0].0.clone_mt());
  191|      0|                        s
  192|       |                    } else {
  193|      0|                        Set::empty()
  194|       |                    };
  195|      0|                }
  196|       |
  197|      0|                let mid = n / 2;
  198|      0|                let mut right_arcs = arcs;
  199|      0|                let left_arcs = right_arcs.split_off(mid);
  200|       |
  201|      0|                let v_left = v.clone_mt();
  202|      0|                let v_right = v;
  203|       |
  204|      0|                let Pair(left_result, right_result) =
  205|      0|                    ParaPair!(move || parallel_in(left_arcs, v_left), move || parallel_in(
  206|      0|                        right_arcs, v_right
  207|       |                    ));
  208|       |
  209|      0|                left_result.union(&right_result)
  210|      0|            }
  211|       |
  212|      0|            parallel_in(arcs, v.clone_mt())
  213|     68|        }
  214|       |    }
  215|       |
  216|       |    impl<V: StT + MtT + Hash, L: StTInMtT + Hash> Display for LabDirGraphMtEph<V, L> {
  217|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  218|      0|            write!(f, "LabDirGraph(V: {}, A: {})", self.vertices, self.labeled_arcs)
  219|      0|        }
  220|       |    }
  221|       |
  222|       |    impl<V: StT + MtT + Hash, L: StTInMtT + Hash> Debug for LabDirGraphMtEph<V, L> {
  223|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  224|      0|            write!(
  225|      0|                f,
  226|      0|                "LabDirGraph {{ vertices: {:?}, labeled_arcs: {:?} }}",
  227|       |                self.vertices, self.labeled_arcs
  228|       |            )
  229|      0|        }
  230|       |    }
  231|       |
  232|       |    #[macro_export]
  233|       |    macro_rules! LabDirGraphMtEphLit {
  234|       |        () => {{
  235|       |            < $crate::Chap06::LabDirGraphMtEph::LabDirGraphMtEph::LabDirGraphMtEph<_, _> as $crate::Chap06::LabDirGraphMtEph::LabDirGraphMtEph::LabDirGraphMtEphTrait<_, _> >::empty()
  236|       |        }};
  237|       |        ( V: [ $( $v:expr ),* $(,)? ], A: [ $( ($from:expr, $to:expr, $label:expr) ),* $(,)? ] ) => {{
  238|       |            let vertices = $crate::SetLit![ $( $v ),* ];
  239|       |            let labeled_arcs = $crate::SetLit![ $( $crate::Types::Types::LabEdge($from, $to, $label) ),* ];
  240|       |            < $crate::Chap06::LabDirGraphMtEph::LabDirGraphMtEph::LabDirGraphMtEph<_, _> as $crate::Chap06::LabDirGraphMtEph::LabDirGraphMtEph::LabDirGraphMtEphTrait<_, _> >::from_vertices_and_labeled_arcs(vertices, labeled_arcs)
  241|       |        }};
  242|       |    }
  243|       |
  244|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap06/LabDirGraphStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 6 Labeled Directed Graph (ephemeral) using Set for vertices and labeled arcs.
    3|       |
    4|       |pub mod LabDirGraphStEph {
    5|       |
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |    use std::hash::Hash;
    8|       |
    9|       |    use crate::Chap05::SetStEph::SetStEph::*;
   10|       |    use crate::SetLit;
   11|       |    use crate::Types::Types::*;
   12|       |
   13|       |    #[derive(Clone)]
   14|       |    pub struct LabDirGraphStEph<V: StT + Hash, L: StT + Hash> {
   15|       |        vertices: Set<V>,
   16|       |        labeled_arcs: Set<LabEdge<V, L>>,
   17|       |    }
   18|       |
   19|       |    pub trait LabDirGraphStEphTrait<V: StT + Hash, L: StT + Hash> {
   20|       |        /// APAS: Work (1), Span (1)
   21|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   22|       |        fn empty() -> Self;
   23|       |        /// APAS: Work (|V| + |A|), Span (1)
   24|       |        /// claude-4-sonet: Work (|V| + |A|), Span (|V| + |A|), Parallelism (1) - sequential
   25|       |        fn from_vertices_and_labeled_arcs(vertices: Set<V>, labeled_arcs: Set<LabEdge<V, L>>) -> Self;
   26|       |        /// APAS: Work (1), Span (1)
   27|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   28|       |        fn vertices(&self) -> &Set<V>;
   29|       |        /// APAS: Work (1), Span (1)
   30|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   31|       |        fn labeled_arcs(&self) -> &Set<LabEdge<V, L>>;
   32|       |        /// APAS: Work (|A|), Span (1)
   33|       |        /// claude-4-sonet: Work (|A|), Span (|A|), Parallelism (1) - sequential map
   34|       |        fn arcs(&self) -> Set<Edge<V>>;
   35|       |        /// APAS: Work (1), Span (1)
   36|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   37|       |        fn add_vertex(&mut self, v: V);
   38|       |        /// APAS: Work (1), Span (1)
   39|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   40|       |        fn add_labeled_arc(&mut self, from: V, to: V, label: L);
   41|       |        /// APAS: Work (|A|), Span (1)
   42|       |        /// claude-4-sonet: Work (|A|), Span (|A|), Parallelism (1) - sequential search
   43|       |        fn get_arc_label(&self, from: &V, to: &V) -> Option<&L>;
   44|       |        /// APAS: Work (|A|), Span (1)
   45|       |        /// claude-4-sonet: Work (|A|), Span (|A|), Parallelism (1) - sequential search
   46|       |        fn has_arc(&self, from: &V, to: &V) -> bool;
   47|       |        /// APAS: Work (|A|), Span (1)
   48|       |        /// claude-4-sonet: Work (|A|), Span (|A|), Parallelism (1) - sequential filter
   49|       |        fn out_neighbors(&self, v: &V) -> Set<V>;
   50|       |        /// APAS: Work (|A|), Span (1)
   51|       |        /// claude-4-sonet: Work (|A|), Span (|A|), Parallelism (1) - sequential filter
   52|       |        fn in_neighbors(&self, v: &V) -> Set<V>;
   53|       |    }
   54|       |
   55|       |    impl<V: StT + Hash, L: StT + Hash> LabDirGraphStEphTrait<V, L> for LabDirGraphStEph<V, L> {
   56|     15|        fn empty() -> Self {
   57|     15|            LabDirGraphStEph {
   58|     15|                vertices: Set::empty(),
   59|     15|                labeled_arcs: Set::empty(),
   60|     15|            }
   61|     15|        }
   62|       |
   63|    135|        fn from_vertices_and_labeled_arcs(vertices: Set<V>, labeled_arcs: Set<LabEdge<V, L>>) -> Self {
   64|    135|            LabDirGraphStEph { vertices, labeled_arcs }
   65|    135|        }
   66|       |
   67|    201|        fn vertices(&self) -> &Set<V> { &self.vertices }
   68|       |
   69|    781|        fn labeled_arcs(&self) -> &Set<LabEdge<V, L>> { &self.labeled_arcs }
   70|       |
   71|      5|        fn arcs(&self) -> Set<Edge<V>> {
   72|      5|            let mut arcs = Set::empty();
   73|      9|            for labeled_arc in self.labeled_arcs.iter() {
                                             ^5                ^5
   74|      9|                arcs.insert(Edge(labeled_arc.0.clone(), labeled_arc.1.clone()));
   75|      9|            }
   76|      5|            arcs
   77|      5|        }
   78|       |
   79|      9|        fn add_vertex(&mut self, v: V) { self.vertices.insert(v); }
   80|       |
   81|     15|        fn add_labeled_arc(&mut self, from: V, to: V, label: L) {
   82|     15|            self.vertices.insert(from.clone());
   83|     15|            self.vertices.insert(to.clone());
   84|     15|            self.labeled_arcs.insert(LabEdge(from, to, label));
   85|     15|        }
   86|       |
   87|     38|        fn get_arc_label(&self, from: &V, to: &V) -> Option<&L> {
   88|     66|            for labeled_arc in self.labeled_arcs.iter() {
                                             ^38               ^38
   89|     66|                if labeled_arc.0 == *from && labeled_arc.1 == *to {
                                                           ^37
   90|     32|                    return Some(&labeled_arc.2);
   91|     34|                }
   92|       |            }
   93|      6|            None
   94|     38|        }
   95|       |
   96|     23|        fn has_arc(&self, from: &V, to: &V) -> bool {
   97|     44|            for labeled_arc in self.labeled_arcs.iter() {
                                             ^23               ^23
   98|     44|                if labeled_arc.0 == *from && labeled_arc.1 == *to {
                                                           ^20
   99|     17|                    return true;
  100|     27|                }
  101|       |            }
  102|      6|            false
  103|     23|        }
  104|       |
  105|     11|        fn out_neighbors(&self, v: &V) -> Set<V> {
  106|     11|            let mut neighbors = Set::empty();
  107|     25|            for labeled_arc in self.labeled_arcs.iter() {
                                             ^11               ^11
  108|     25|                if labeled_arc.0 == *v {
  109|     10|                    neighbors.insert(labeled_arc.1.clone());
  110|     15|                }
  111|       |            }
  112|     11|            neighbors
  113|     11|        }
  114|       |
  115|     10|        fn in_neighbors(&self, v: &V) -> Set<V> {
  116|     10|            let mut neighbors = Set::empty();
  117|     20|            for labeled_arc in self.labeled_arcs.iter() {
                                             ^10               ^10
  118|     20|                if labeled_arc.1 == *v {
  119|      9|                    neighbors.insert(labeled_arc.0.clone());
  120|     11|                }
  121|       |            }
  122|     10|            neighbors
  123|     10|        }
  124|       |    }
  125|       |
  126|       |    impl<V: StT + Hash, L: Clone + Display + Debug + Eq + Hash> Display for LabDirGraphStEph<V, L> {
  127|      2|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  128|      2|            write!(f, "LabDirGraph(V: {}, A: {})", self.vertices, self.labeled_arcs)
  129|      2|        }
  130|       |    }
  131|       |
  132|       |    impl<V: StT + Hash, L: Clone + Display + Debug + Eq + Hash> Debug for LabDirGraphStEph<V, L> {
  133|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  134|      1|            write!(
  135|      1|                f,
  136|      1|                "LabDirGraph {{ vertices: {:?}, labeled_arcs: {:?} }}",
  137|       |                self.vertices, self.labeled_arcs
  138|       |            )
  139|      1|        }
  140|       |    }
  141|       |
  142|       |    #[macro_export]
  143|       |    macro_rules! LabDirGraphStEphLit {
  144|       |        () => {{
  145|       |            < $crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::LabDirGraphStEph<_, _> as $crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::LabDirGraphStEphTrait<_, _> >::empty()
  146|       |        }};
  147|       |        ( V: [ $( $v:expr ),* $(,)? ], A: [ $( ($from:expr, $to:expr, $label:expr) ),* $(,)? ] ) => {{
  148|       |            let vertices = $crate::SetLit![ $( $v ),* ];
  149|       |            let labeled_arcs = $crate::SetLit![ $( $crate::Types::Types::LabEdge($from, $to, $label) ),* ];
  150|       |            < $crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::LabDirGraphStEph<_, _> as $crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::LabDirGraphStEphTrait<_, _> >::from_vertices_and_labeled_arcs(vertices, labeled_arcs)
  151|       |        }};
  152|       |    }
  153|       |
  154|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap06/LabUnDirGraphMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 6 Labeled Undirected Graph (ephemeral) using Set for vertices and labeled edges - Multi-threaded version.
    3|       |//!
    4|       |//! Note: NOW uses true parallelism via ParaPair! for neighbor operations.
    5|       |//! Labeled edge filtering (neighbors) is parallel.
    6|       |
    7|       |pub mod LabUnDirGraphMtEph {
    8|       |
    9|       |    use std::fmt::{Debug, Display, Formatter, Result};
   10|       |    use std::hash::Hash;
   11|       |
   12|       |    use crate::Chap05::SetStEph::SetStEph::*;
   13|       |    use crate::ParaPair;
   14|       |    use crate::SetLit;
   15|       |    use crate::Types::Types::*;
   16|       |
   17|       |    #[derive(Clone)]
   18|       |    pub struct LabUnDirGraphMtEph<V: HashOrd + MtT + 'static, L: StTInMtT + Hash + 'static> {
   19|       |        vertices: Set<V>,
   20|       |        labeled_edges: Set<LabEdge<V, L>>,
   21|       |    }
   22|       |
   23|       |    pub trait LabUnDirGraphMtEphTrait<V: HashOrd + MtT + 'static, L: StTInMtT + Hash + 'static> {
   24|       |        /// APAS: Work (1), Span (1)
   25|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   26|       |        fn empty() -> Self;
   27|       |        /// APAS: Work (|V| + |E|), Span (1)
   28|       |        /// claude-4-sonet: Work (|V| + |E|), Span (|V| + |E|), Parallelism (1) - sequential
   29|       |        fn from_vertices_and_labeled_edges(vertices: Set<V>, labeled_edges: Set<LabEdge<V, L>>) -> Self;
   30|       |        /// APAS: Work (1), Span (1)
   31|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   32|       |        fn vertices(&self) -> &Set<V>;
   33|       |        /// APAS: Work (1), Span (1)
   34|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   35|       |        fn labeled_edges(&self) -> &Set<LabEdge<V, L>>;
   36|       |        /// APAS: Work (|E|), Span (1)
   37|       |        /// claude-4-sonet: Work (|E|), Span (|E|), Parallelism (1) - sequential map
   38|       |        fn edges(&self) -> Set<Edge<V>>;
   39|       |        /// APAS: Work (1), Span (1)
   40|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   41|       |        fn add_vertex(&mut self, v: V);
   42|       |        /// APAS: Work (1), Span (1)
   43|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   44|       |        fn add_labeled_edge(&mut self, v1: V, v2: V, label: L);
   45|       |        /// APAS: Work (|E|), Span (1)
   46|       |        /// claude-4-sonet: Work (|E|), Span (|E|), Parallelism (1) - sequential search
   47|       |        fn get_edge_label(&self, v1: &V, v2: &V) -> Option<&L>;
   48|       |        /// APAS: Work (|E|), Span (1)
   49|       |        /// claude-4-sonet: Work (|E|), Span (|E|), Parallelism (1) - sequential search
   50|       |        fn has_edge(&self, v1: &V, v2: &V) -> bool;
   51|       |        /// APAS: Work (|E|), Span (1)
   52|       |        /// claude-4-sonet: Work (|E|), Span (log |E|), Parallelism (|E|/log |E|) - parallel divide-and-conquer filter
   53|       |        fn neighbors(&self, v: &V) -> Set<V>;
   54|       |        /// APAS: Work (1), Span (1)
   55|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   56|       |        fn normalize_edge(v1: V, v2: V) -> LabEdge<V, L>;
   57|       |    }
   58|       |
   59|       |    impl<V: HashOrd + MtT + 'static, L: StTInMtT + Hash + 'static> LabUnDirGraphMtEphTrait<V, L>
   60|       |        for LabUnDirGraphMtEph<V, L>
   61|       |    {
   62|     13|        fn empty() -> Self {
   63|     13|            LabUnDirGraphMtEph {
   64|     13|                vertices: Set::empty(),
   65|     13|                labeled_edges: Set::empty(),
   66|     13|            }
   67|     13|        }
   68|       |
   69|     59|        fn from_vertices_and_labeled_edges(vertices: Set<V>, labeled_edges: Set<LabEdge<V, L>>) -> Self {
   70|     59|            LabUnDirGraphMtEph {
   71|     59|                vertices,
   72|     59|                labeled_edges,
   73|     59|            }
   74|     59|        }
   75|       |
   76|     51|        fn vertices(&self) -> &Set<V> { &self.vertices }
   77|       |
   78|     60|        fn labeled_edges(&self) -> &Set<LabEdge<V, L>> { &self.labeled_edges }
   79|       |
   80|      1|        fn edges(&self) -> Set<Edge<V>> {
   81|      1|            let mut edges = Set::empty();
   82|      2|            for labeled_edge in self.labeled_edges.iter() {
                                              ^1                 ^1
   83|      2|                edges.insert(Edge(labeled_edge.0.clone_mt(), labeled_edge.1.clone_mt()));
   84|      2|            }
   85|      1|            edges
   86|      1|        }
   87|       |
   88|      7|        fn add_vertex(&mut self, v: V) { self.vertices.insert(v); }
   89|       |
   90|      5|        fn add_labeled_edge(&mut self, v1: V, v2: V, label: L) {
   91|      5|            self.vertices.insert(v1.clone_mt());
   92|      5|            self.vertices.insert(v2.clone_mt());
   93|      5|            let normalized_edge = if v1 <= v2 {
   94|      4|                LabEdge(v1, v2, label)
   95|       |            } else {
   96|      1|                LabEdge(v2, v1, label)
   97|       |            };
   98|      5|            self.labeled_edges.insert(normalized_edge);
   99|      5|        }
  100|       |
  101|     13|        fn get_edge_label(&self, v1: &V, v2: &V) -> Option<&L> {
  102|       |            // Check both orientations since this is undirected
  103|     20|            for labeled_edge in self.labeled_edges.iter() {
                                              ^13                ^13
  104|     20|                if (labeled_edge.0 == *v1 && labeled_edge.1 == *v2) || (labeled_edge.0 == *v2 && labeled_edge.1 == *v1)
                                                           ^11                        ^12                      ^2
  105|       |                {
  106|     10|                    return Some(&labeled_edge.2);
  107|     10|                }
  108|       |            }
  109|      3|            None
  110|     13|        }
  111|       |
  112|     93|        fn has_edge(&self, v1: &V, v2: &V) -> bool {
  113|    240|            for labeled_edge in self.labeled_edges.iter() {
                                              ^93                ^93
  114|    240|                if (labeled_edge.0 == *v1 && labeled_edge.1 == *v2) || (labeled_edge.0 == *v2 && labeled_edge.1 == *v1)
                                                           ^72                        ^189                     ^58
  115|       |                {
  116|     84|                    return true;
  117|    156|                }
  118|       |            }
  119|      9|            false
  120|     93|        }
  121|       |
  122|    263|        fn neighbors(&self, v: &V) -> Set<V> {
  123|       |            // PARALLEL: filter labeled edges using divide-and-conquer
  124|    263|            let edges: Vec<LabEdge<V, L>> = self.labeled_edges.iter().cloned().collect();
  125|    263|            let n = edges.len();
  126|       |
  127|    263|            if n <= 8 {
  128|    263|                let mut neighbors = Set::empty();
  129|  1.34k|                for labeled_edge in edges {
                                  ^1.07k
  130|  1.07k|                    if labeled_edge.0 == *v {
  131|    270|                        neighbors.insert(labeled_edge.1.clone_mt());
  132|    809|                    } else if labeled_edge.1 == *v {
  133|    208|                        neighbors.insert(labeled_edge.0.clone_mt());
  134|    601|                    }
  135|       |                }
  136|    263|                return neighbors;
  137|      0|            }
  138|       |
  139|       |            // Parallel divide-and-conquer
  140|      0|            fn parallel_neighbors<V: HashOrd + MtT + 'static, L: StTInMtT + Hash + 'static>(
  141|      0|                edges: Vec<LabEdge<V, L>>,
  142|      0|                v: V,
  143|      0|            ) -> Set<V> {
  144|      0|                let n = edges.len();
  145|      0|                if n == 0 {
  146|      0|                    return Set::empty();
  147|      0|                }
  148|      0|                if n == 1 {
  149|      0|                    if edges[0].0 == v {
  150|      0|                        let mut s = Set::empty();
  151|      0|                        s.insert(edges[0].1.clone_mt());
  152|      0|                        return s;
  153|      0|                    } else if edges[0].1 == v {
  154|      0|                        let mut s = Set::empty();
  155|      0|                        s.insert(edges[0].0.clone_mt());
  156|      0|                        return s;
  157|      0|                    }
  158|      0|                    return Set::empty();
  159|      0|                }
  160|       |
  161|      0|                let mid = n / 2;
  162|      0|                let mut right_edges = edges;
  163|      0|                let left_edges = right_edges.split_off(mid);
  164|       |
  165|      0|                let v_left = v.clone_mt();
  166|      0|                let v_right = v;
  167|       |
  168|      0|                let Pair(left_result, right_result) =
  169|      0|                    ParaPair!(move || parallel_neighbors(left_edges, v_left), move || {
  170|      0|                        parallel_neighbors(right_edges, v_right)
  171|      0|                    });
  172|       |
  173|      0|                left_result.union(&right_result)
  174|      0|            }
  175|       |
  176|      0|            parallel_neighbors(edges, v.clone_mt())
  177|    263|        }
  178|       |
  179|      0|        fn normalize_edge(_v1: V, _v2: V) -> LabEdge<V, L> {
  180|       |            // This method signature doesn't make sense for LabEdge without a label
  181|       |            // This is a design issue - we need the label to create a LabEdge
  182|       |            // For now, we'll panic to indicate this needs to be fixed
  183|      0|            panic!("normalize_edge cannot create LabEdge without a label - method signature needs revision")
  184|       |        }
  185|       |    }
  186|       |
  187|       |    // DirGraphStEph-compatible interface for labeled undirected graphs
  188|       |    impl<V: HashOrd + MtT, L: StTInMtT + Hash> LabUnDirGraphMtEph<V, L> {
  189|       |        /// Arc count (alias for edge count in undirected graphs)
  190|      1|        pub fn sizeA(&self) -> N { self.labeled_edges().size() }
  191|       |
  192|       |        /// Arcs (alias for edges in undirected graphs)
  193|      1|        pub fn arcs(&self) -> Set<LabEdge<V, L>> { self.labeled_edges().clone() }
  194|       |
  195|       |        /// Neighbors (in undirected graphs, all neighbors are both in and out)
  196|      1|        pub fn NPlus(&self, v: &V) -> Set<V> { self.neighbors(v) }
  197|       |
  198|       |        /// Neighbors (in undirected graphs, all neighbors are both in and out)
  199|      1|        pub fn NMinus(&self, v: &V) -> Set<V> { self.neighbors(v) }
  200|       |
  201|       |        /// Degree (in undirected graphs, in-degree equals total degree)
  202|      1|        pub fn InDegree(&self, v: &V) -> N { self.neighbors(v).size() }
  203|       |
  204|       |        /// Degree (in undirected graphs, out-degree equals total degree)
  205|      1|        pub fn OutDegree(&self, v: &V) -> N { self.neighbors(v).size() }
  206|       |    }
  207|       |
  208|       |    impl<V: HashOrd + MtT, L: StTInMtT + Hash> Display for LabUnDirGraphMtEph<V, L> {
  209|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  210|      1|            write!(f, "LabUnDirGraph(V: {}, E: {})", self.vertices, self.labeled_edges)
  211|      1|        }
  212|       |    }
  213|       |
  214|       |    impl<V: HashOrd + MtT, L: StTInMtT + Hash> Debug for LabUnDirGraphMtEph<V, L> {
  215|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  216|      1|            write!(
  217|      1|                f,
  218|      1|                "LabUnDirGraph {{ vertices: {:?}, labeled_edges: {:?} }}",
  219|       |                self.vertices, self.labeled_edges
  220|       |            )
  221|      1|        }
  222|       |    }
  223|       |
  224|       |    #[macro_export]
  225|       |    macro_rules! LabUnDirGraphMtEphLit {
  226|       |        () => {{
  227|       |            < $crate::Chap06::LabUnDirGraphMtEph::LabUnDirGraphMtEph::LabUnDirGraphMtEph<_, _> as $crate::Chap06::LabUnDirGraphMtEph::LabUnDirGraphMtEph::LabUnDirGraphMtEphTrait<_, _> >::empty()
  228|       |        }};
  229|       |        ( V: [ $( $v:expr ),* $(,)? ], E: [ $( ($v1:expr, $v2:expr, $label:expr) ),* $(,)? ] ) => {{
  230|       |            let vertices = $crate::SetLit![ $( $v ),* ];
  231|       |            let labeled_edges = {
  232|       |                let mut edges = $crate::Chap05::SetStEph::SetStEph::Set::empty();
  233|       |                $(
  234|       |                    let normalized_edge = if $v1 <= $v2 {
  235|       |                        $crate::Types::Types::LabEdge($v1, $v2, $label)
  236|       |                    } else {
  237|       |                        $crate::Types::Types::LabEdge($v2, $v1, $label)
  238|       |                    };
  239|       |                    edges.insert(normalized_edge);
  240|       |                )*
  241|       |                edges
  242|       |            };
  243|       |            < $crate::Chap06::LabUnDirGraphMtEph::LabUnDirGraphMtEph::LabUnDirGraphMtEph<_, _> as $crate::Chap06::LabUnDirGraphMtEph::LabUnDirGraphMtEph::LabUnDirGraphMtEphTrait<_, _> >::from_vertices_and_labeled_edges(vertices, labeled_edges)
  244|       |        }};
  245|       |    }
  246|       |
  247|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap06/LabUnDirGraphStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 6 Labeled Undirected Graph (ephemeral) using Set for vertices and labeled edges.
    3|       |
    4|       |pub mod LabUnDirGraphStEph {
    5|       |
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |    use std::hash::Hash;
    8|       |
    9|       |    use crate::Chap05::SetStEph::SetStEph::*;
   10|       |    use crate::SetLit;
   11|       |    use crate::Types::Types::*;
   12|       |
   13|       |    #[derive(Clone)]
   14|       |    pub struct LabUnDirGraphStEph<V: HashOrd, L: StT + Hash> {
   15|       |        vertices: Set<V>,
   16|       |        labeled_edges: Set<LabEdge<V, L>>,
   17|       |    }
   18|       |
   19|       |    pub trait LabUnDirGraphStEphTrait<V: HashOrd, L: StT + Hash> {
   20|       |        /// APAS: Work (1), Span (1)
   21|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   22|       |        fn empty() -> Self;
   23|       |        /// APAS: Work (|V| + |E|), Span (1)
   24|       |        /// claude-4-sonet: Work (|V| + |E|), Span (|V| + |E|), Parallelism (1) - sequential
   25|       |        fn from_vertices_and_labeled_edges(vertices: Set<V>, labeled_edges: Set<LabEdge<V, L>>) -> Self;
   26|       |        /// APAS: Work (1), Span (1)
   27|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   28|       |        fn vertices(&self) -> &Set<V>;
   29|       |        /// APAS: Work (1), Span (1)
   30|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   31|       |        fn labeled_edges(&self) -> &Set<LabEdge<V, L>>;
   32|       |        /// APAS: Work (|E|), Span (1)
   33|       |        /// claude-4-sonet: Work (|E|), Span (|E|), Parallelism (1) - sequential map
   34|       |        fn edges(&self) -> Set<Edge<V>>;
   35|       |        /// APAS: Work (1), Span (1)
   36|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   37|       |        fn add_vertex(&mut self, v: V);
   38|       |        /// APAS: Work (1), Span (1)
   39|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   40|       |        fn add_labeled_edge(&mut self, v1: V, v2: V, label: L);
   41|       |        /// APAS: Work (|E|), Span (1)
   42|       |        /// claude-4-sonet: Work (|E|), Span (|E|), Parallelism (1) - sequential search
   43|       |        fn get_edge_label(&self, v1: &V, v2: &V) -> Option<&L>;
   44|       |        /// APAS: Work (|E|), Span (1)
   45|       |        /// claude-4-sonet: Work (|E|), Span (|E|), Parallelism (1) - sequential search
   46|       |        fn has_edge(&self, v1: &V, v2: &V) -> bool;
   47|       |        /// APAS: Work (|E|), Span (1)
   48|       |        /// claude-4-sonet: Work (|E|), Span (|E|), Parallelism (1) - sequential filter
   49|       |        fn neighbors(&self, v: &V) -> Set<V>;
   50|       |        /// APAS: Work (1), Span (1)
   51|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   52|       |        fn normalize_edge(v1: V, v2: V) -> LabEdge<V, L>;
   53|       |    }
   54|       |
   55|       |    impl<V: HashOrd, L: StT + Hash> LabUnDirGraphStEphTrait<V, L> for LabUnDirGraphStEph<V, L> {
   56|     45|        fn empty() -> Self {
   57|     45|            LabUnDirGraphStEph {
   58|     45|                vertices: Set::empty(),
   59|     45|                labeled_edges: Set::empty(),
   60|     45|            }
   61|     45|        }
   62|       |
   63|     76|        fn from_vertices_and_labeled_edges(vertices: Set<V>, labeled_edges: Set<LabEdge<V, L>>) -> Self {
   64|     76|            LabUnDirGraphStEph {
   65|     76|                vertices,
   66|     76|                labeled_edges,
   67|     76|            }
   68|     76|        }
   69|       |
   70|     93|        fn vertices(&self) -> &Set<V> { &self.vertices }
   71|       |
   72|    121|        fn labeled_edges(&self) -> &Set<LabEdge<V, L>> { &self.labeled_edges }
   73|       |
   74|     23|        fn edges(&self) -> Set<Edge<V>> {
   75|     23|            let mut edges = Set::empty();
   76|    144|            for labeled_edge in self.labeled_edges.iter() {
                                              ^23                ^23
   77|    144|                edges.insert(Edge(labeled_edge.0.clone(), labeled_edge.1.clone()));
   78|    144|            }
   79|     23|            edges
   80|     23|        }
   81|       |
   82|    150|        fn add_vertex(&mut self, v: V) { self.vertices.insert(v); }
   83|       |
   84|    131|        fn add_labeled_edge(&mut self, v1: V, v2: V, label: L) {
   85|    131|            self.vertices.insert(v1.clone());
   86|    131|            self.vertices.insert(v2.clone());
   87|    131|            let normalized_edge = if v1 <= v2 {
   88|    131|                LabEdge(v1, v2, label)
   89|       |            } else {
   90|      0|                LabEdge(v2, v1, label)
   91|       |            };
   92|    131|            self.labeled_edges.insert(normalized_edge);
   93|    131|        }
   94|       |
   95|     46|        fn get_edge_label(&self, v1: &V, v2: &V) -> Option<&L> {
   96|       |            // Check both orientations since this is undirected
   97|     57|            for labeled_edge in self.labeled_edges.iter() {
                                              ^46                ^46
   98|     57|                if (labeled_edge.0 == *v1 && labeled_edge.1 == *v2) || (labeled_edge.0 == *v2 && labeled_edge.1 == *v1)
                                                           ^37                        ^27                      ^15
   99|       |                {
  100|     41|                    return Some(&labeled_edge.2);
  101|     16|                }
  102|       |            }
  103|      5|            None
  104|     46|        }
  105|       |
  106|     14|        fn has_edge(&self, v1: &V, v2: &V) -> bool {
  107|       |            // Check both orientations since this is undirected
  108|     19|            for labeled_edge in self.labeled_edges.iter() {
                                              ^14                ^14
  109|     19|                if (labeled_edge.0 == *v1 && labeled_edge.1 == *v2) || (labeled_edge.0 == *v2 && labeled_edge.1 == *v1)
                                                           ^10                        ^11                      ^6
  110|       |                {
  111|     13|                    return true;
  112|      6|                }
  113|       |            }
  114|      1|            false
  115|     14|        }
  116|       |
  117|    190|        fn neighbors(&self, v: &V) -> Set<V> {
  118|    190|            let mut neighbors = Set::empty();
  119|  5.20k|            for labeled_edge in self.labeled_edges.iter() {
                                              ^190               ^190
  120|  5.20k|                if labeled_edge.0 == *v {
  121|    181|                    neighbors.insert(labeled_edge.1.clone());
  122|  5.02k|                } else if labeled_edge.1 == *v {
  123|    172|                    neighbors.insert(labeled_edge.0.clone());
  124|  4.85k|                }
  125|       |            }
  126|    190|            neighbors
  127|    190|        }
  128|       |
  129|      0|        fn normalize_edge(_v1: V, _v2: V) -> LabEdge<V, L> {
  130|       |            // This method signature doesn't make sense for LabEdge without a label
  131|       |            // This is a design issue - we need the label to create a LabEdge
  132|       |            // For now, we'll panic to indicate this needs to be fixed
  133|      0|            panic!("normalize_edge cannot create LabEdge without a label - method signature needs revision")
  134|       |        }
  135|       |    }
  136|       |
  137|       |    // DirGraphStEph-compatible interface for labeled undirected graphs
  138|       |    impl<V: HashOrd, L: StT + Hash> LabUnDirGraphStEph<V, L> {
  139|       |        /// Arc count (alias for edge count in undirected graphs)
  140|      1|        pub fn sizeA(&self) -> N { self.labeled_edges().size() }
  141|       |
  142|       |        /// Arcs (alias for edges in undirected graphs)
  143|      1|        pub fn arcs(&self) -> Set<LabEdge<V, L>> { self.labeled_edges().clone() }
  144|       |
  145|       |        /// Neighbors (in undirected graphs, all neighbors are both in and out)
  146|      1|        pub fn NPlus(&self, v: &V) -> Set<V> { self.neighbors(v) }
  147|       |
  148|       |        /// Neighbors (in undirected graphs, all neighbors are both in and out)
  149|      1|        pub fn NMinus(&self, v: &V) -> Set<V> { self.neighbors(v) }
  150|       |
  151|       |        /// Degree (in undirected graphs, in-degree equals total degree)
  152|      3|        pub fn InDegree(&self, v: &V) -> N { self.neighbors(v).size() }
  153|       |
  154|       |        /// Degree (in undirected graphs, out-degree equals total degree)
  155|      3|        pub fn OutDegree(&self, v: &V) -> N { self.neighbors(v).size() }
  156|       |    }
  157|       |
  158|       |    impl<V: HashOrd, L: StT + Hash> Display for LabUnDirGraphStEph<V, L> {
  159|      4|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  160|      4|            write!(f, "LabUnDirGraph(V: {}, E: {})", self.vertices, self.labeled_edges)
  161|      4|        }
  162|       |    }
  163|       |
  164|       |    impl<V: HashOrd, L: StT + Hash> Debug for LabUnDirGraphStEph<V, L> {
  165|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  166|      1|            write!(
  167|      1|                f,
  168|      1|                "LabUnDirGraph {{ vertices: {:?}, labeled_edges: {:?} }}",
  169|       |                self.vertices, self.labeled_edges
  170|       |            )
  171|      1|        }
  172|       |    }
  173|       |
  174|       |    #[macro_export]
  175|       |    macro_rules! LabUnDirGraphStEphLit {
  176|       |        () => {{
  177|       |            < $crate::Chap06::LabUnDirGraphStEph::LabUnDirGraphStEph::LabUnDirGraphStEph<_, _> as $crate::Chap06::LabUnDirGraphStEph::LabUnDirGraphStEph::LabUnDirGraphStEphTrait<_, _> >::empty()
  178|       |        }};
  179|       |        ( V: [ $( $v:expr ),* $(,)? ], E: [ $( ($v1:expr, $v2:expr, $label:expr) ),* $(,)? ] ) => {{
  180|       |            let vertices = $crate::SetLit![ $( $v ),* ];
  181|       |            let labeled_edges = {
  182|       |                let mut edges = $crate::Chap05::SetStEph::SetStEph::Set::empty();
  183|       |                $(
  184|       |                    let normalized_edge = if $v1 <= $v2 {
  185|       |                        $crate::Types::Types::LabEdge($v1, $v2, $label)
  186|       |                    } else {
  187|       |                        $crate::Types::Types::LabEdge($v2, $v1, $label)
  188|       |                    };
  189|       |                    edges.insert(normalized_edge);
  190|       |                )*
  191|       |                edges
  192|       |            };
  193|       |            < $crate::Chap06::LabUnDirGraphStEph::LabUnDirGraphStEph::LabUnDirGraphStEph<_, _> as $crate::Chap06::LabUnDirGraphStEph::LabUnDirGraphStEph::LabUnDirGraphStEphTrait<_, _> >::from_vertices_and_labeled_edges(vertices, labeled_edges)
  194|       |        }};
  195|       |    }
  196|       |
  197|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap06/UnDirGraphMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 6.1 Undirected Graph (ephemeral) using Set for vertices and edges - Multi-threaded version.
    3|       |//!
    4|       |//! Note: NOW uses true parallelism via ParaPair! for neighbor/degree operations.
    5|       |//! Edge filtering (NG) and vertex map-reduce (NGOfVertices) are parallel.
    6|       |
    7|       |pub mod UnDirGraphMtEph {
    8|       |
    9|       |    use std::hash::Hash;
   10|       |
   11|       |    use crate::Chap05::SetStEph::SetStEph::*;
   12|       |    use crate::ParaPair;
   13|       |    use crate::SetLit;
   14|       |    use crate::Types::Types::*;
   15|       |
   16|       |    #[derive(Clone)]
   17|       |    pub struct UnDirGraphMtEph<V: StT + MtT + Hash + 'static> {
   18|       |        V: Set<V>,
   19|       |        E: Set<Edge<V>>,
   20|       |    }
   21|       |
   22|       |    pub trait UnDirGraphMtEphTrait<V: StT + MtT + Hash + 'static> {
   23|       |        /// APAS: Work (1), Span (1)
   24|       |        /// claude-4-sonet: Work (1), Span (1)
   25|       |        fn empty() -> UnDirGraphMtEph<V>;
   26|       |        /// APAS: Work (|V| + |E|), Span (1)
   27|       |        /// claude-4-sonet: Work (|V| + |E|), Span (1)
   28|       |        fn FromSets(V: Set<V>, E: Set<Edge<V>>) -> UnDirGraphMtEph<V>;
   29|       |        /// APAS: Work (1), Span (1)
   30|       |        /// claude-4-sonet: Work (1), Span (1)
   31|       |        fn vertices(&self) -> &Set<V>;
   32|       |        /// APAS: Work (1), Span (1)
   33|       |        /// claude-4-sonet: Work (1), Span (1)
   34|       |        fn edges(&self) -> &Set<Edge<V>>;
   35|       |        /// APAS: Work (1), Span (1)
   36|       |        /// claude-4-sonet: Work (1), Span (1)
   37|       |        fn sizeV(&self) -> N;
   38|       |        /// APAS: Work (1), Span (1)
   39|       |        /// claude-4-sonet: Work (1), Span (1)
   40|       |        fn sizeE(&self) -> N;
   41|       |        /// APAS: Work (1), Span (1)
   42|       |        /// claude-4-sonet: Work (1), Span (1)
   43|       |        fn Neighbor(&self, u: &V, v: &V) -> B;
   44|       |        /// APAS: Work (|E|), Span (1)
   45|       |        /// claude-4-sonet: Work (|E|), Span (log |E|), Parallelism (|E|/log |E|) - parallel divide-and-conquer filter
   46|       |        fn NG(&self, v: &V) -> Set<V>;
   47|       |        /// APAS: Work (|u_set|  |E|), Span (1)
   48|       |        /// claude-4-sonet: Work (|u_set|  |E|), Span (log |u_set| + log |E|), Parallelism ((|u_set|  |E|)/(log |u_set| + log |E|)) - parallel map-reduce
   49|       |        fn NGOfVertices(&self, u_set: &Set<V>) -> Set<V>;
   50|       |        /// APAS: Work (1), Span (1)
   51|       |        /// claude-4-sonet: Work (1), Span (1)
   52|       |        fn Incident(&self, e: &Edge<V>, v: &V) -> B;
   53|       |        /// APAS: Work (|E|), Span (1)
   54|       |        /// claude-4-sonet: Work (|E|), Span (log |E|), Parallelism (|E|/log |E|) - calls parallel NG
   55|       |        fn Degree(&self, v: &V) -> N;
   56|       |    }
   57|       |
   58|       |    impl<V: StT + MtT + Hash + 'static> UnDirGraphMtEphTrait<V> for UnDirGraphMtEph<V> {
   59|      4|        fn empty() -> UnDirGraphMtEph<V> {
   60|      4|            UnDirGraphMtEph {
   61|      4|                V: SetLit![],
   62|      4|                E: SetLit![],
   63|      4|            }
   64|      4|        }
   65|    107|        fn FromSets(V: Set<V>, E: Set<Edge<V>>) -> UnDirGraphMtEph<V> { UnDirGraphMtEph { V, E } }
   66|     98|        fn vertices(&self) -> &Set<V> { &self.V }
   67|    164|        fn edges(&self) -> &Set<Edge<V>> { &self.E }
   68|     21|        fn sizeV(&self) -> N { self.V.size() }
   69|     80|        fn sizeE(&self) -> N { self.E.size() }
   70|       |
   71|     46|        fn Neighbor(&self, u: &V, v: &V) -> B {
   72|       |            // Treat edges as unordered: {u,v}
   73|     46|            if true == self.E.mem(&Edge(u.clone_mt(), v.clone_mt()))
   74|     23|                || true == self.E.mem(&Edge(v.clone_mt(), u.clone_mt()))
   75|       |            {
   76|     33|                true
   77|       |            } else {
   78|     13|                false
   79|       |            }
   80|     46|        }
   81|       |
   82|    134|        fn NG(&self, v: &V) -> Set<V> {
   83|       |            // PARALLEL: filter edges using divide-and-conquer
   84|    134|            let edges: Vec<Edge<V>> = self.E.iter().cloned().collect();
   85|    134|            let n = edges.len();
   86|       |
   87|    134|            if n <= 8 {
   88|    128|                let mut ng: Set<V> = SetLit![];
   89|    588|                for Edge(a, b) in edges {
                                       ^460^460
   90|    460|                    if a == *v {
   91|    114|                        let _ = ng.insert(b.clone_mt());
   92|    346|                    } else if b == *v {
   93|     88|                        let _ = ng.insert(a.clone_mt());
   94|    258|                    }
   95|       |                }
   96|    128|                return ng;
   97|      6|            }
   98|       |
   99|       |            // Parallel divide-and-conquer
  100|    222|            fn parallel_ng<V: StT + MtT + Hash + 'static>(edges: Vec<Edge<V>>, v: V) -> Set<V> {
  101|    222|                let n = edges.len();
  102|    222|                if n == 0 {
  103|      0|                    return SetLit![];
  104|    222|                }
  105|    222|                if n == 1 {
  106|    114|                    let Edge(a, b) = &edges[0];
  107|    114|                    if a == &v {
  108|      5|                        let mut s = SetLit![];
  109|      5|                        s.insert(b.clone_mt());
  110|      5|                        return s;
  111|    109|                    } else if b == &v {
  112|      5|                        let mut s = SetLit![];
  113|      5|                        s.insert(a.clone_mt());
  114|      5|                        return s;
  115|    104|                    }
  116|    104|                    return SetLit![];
  117|    108|                }
  118|       |
  119|    108|                let mid = n / 2;
  120|    108|                let mut right_edges = edges;
  121|    108|                let left_edges = right_edges.split_off(mid);
  122|       |
  123|    108|                let v_left = v.clone_mt();
  124|    108|                let v_right = v;
  125|       |
  126|    108|                let Pair(left_result, right_result) =
  127|    108|                    ParaPair!(move || parallel_ng(left_edges, v_left), move || parallel_ng(
  128|    108|                        right_edges,
  129|    108|                        v_right
  130|       |                    ));
  131|       |
  132|    108|                left_result.union(&right_result)
  133|    222|            }
  134|       |
  135|      6|            parallel_ng(edges, v.clone_mt())
  136|    134|        }
  137|       |
  138|     10|        fn NGOfVertices(&self, u_set: &Set<V>) -> Set<V> {
  139|       |            // PARALLEL: map-reduce over vertices using divide-and-conquer
  140|     10|            let vertices: Vec<V> = u_set.iter().cloned().collect();
  141|     10|            let n = vertices.len();
  142|       |
  143|     10|            if n <= 8 {
  144|     10|                let mut result: Set<V> = SetLit![];
  145|     23|                for u in vertices {
                                  ^13
  146|     13|                    let ng_u = self.NG(&u);
  147|     13|                    result = result.union(&ng_u);
  148|     13|                }
  149|     10|                return result;
  150|      0|            }
  151|       |
  152|       |            // Parallel map-reduce
  153|      0|            fn parallel_ng_of_vertices<V: StT + MtT + Hash + 'static>(
  154|      0|                vertices: Vec<V>,
  155|      0|                graph: UnDirGraphMtEph<V>,
  156|      0|            ) -> Set<V> {
  157|      0|                let n = vertices.len();
  158|      0|                if n == 0 {
  159|      0|                    return SetLit![];
  160|      0|                }
  161|      0|                if n == 1 {
  162|      0|                    return graph.NG(&vertices[0]);
  163|      0|                }
  164|       |
  165|      0|                let mid = n / 2;
  166|      0|                let mut right_verts = vertices;
  167|      0|                let left_verts = right_verts.split_off(mid);
  168|       |
  169|      0|                let graph_left = graph.clone();
  170|      0|                let graph_right = graph;
  171|       |
  172|      0|                let Pair(left_result, right_result) =
  173|      0|                    ParaPair!(move || parallel_ng_of_vertices(left_verts, graph_left), move || {
  174|      0|                        parallel_ng_of_vertices(right_verts, graph_right)
  175|      0|                    });
  176|       |
  177|      0|                left_result.union(&right_result)
  178|      0|            }
  179|       |
  180|      0|            parallel_ng_of_vertices(vertices, self.clone())
  181|     10|        }
  182|       |
  183|    250|        fn Incident(&self, e: &Edge<V>, v: &V) -> B { if &e.0 == v || &e.1 == v { true } else { false } }
                                                                                    ^229        ^37           ^213
  184|       |
  185|     83|        fn Degree(&self, v: &V) -> N { self.NG(v).size() }
  186|       |    }
  187|       |
  188|       |    // DirGraphStEph-compatible interface for undirected graphs
  189|       |    impl<V: StT + MtT + Hash> UnDirGraphMtEph<V> {
  190|       |        /// Arc count (alias for edge count in undirected graphs)
  191|      2|        pub fn sizeA(&self) -> N { self.sizeE() }
  192|       |
  193|       |        /// Arcs (alias for edges in undirected graphs)
  194|      3|        pub fn arcs(&self) -> &Set<Edge<V>> { self.edges() }
  195|       |
  196|       |        /// Neighbors (in undirected graphs, all neighbors are both in and out)
  197|      1|        pub fn NPlus(&self, v: &V) -> Set<V> { self.NG(v) }
  198|       |
  199|       |        /// Neighbors (in undirected graphs, all neighbors are both in and out)
  200|      1|        pub fn NMinus(&self, v: &V) -> Set<V> { self.NG(v) }
  201|       |
  202|       |        /// Neighbors of vertex set
  203|      2|        pub fn NPlusOfVertices(&self, u_set: &Set<V>) -> Set<V> { self.NGOfVertices(u_set) }
  204|       |
  205|       |        /// Neighbors of vertex set
  206|      2|        pub fn NMinusOfVertices(&self, u_set: &Set<V>) -> Set<V> { self.NGOfVertices(u_set) }
  207|       |
  208|       |        /// Degree (in undirected graphs, in-degree equals total degree)
  209|      2|        pub fn InDegree(&self, v: &V) -> N { self.Degree(v) }
  210|       |
  211|       |        /// Degree (in undirected graphs, out-degree equals total degree)
  212|      2|        pub fn OutDegree(&self, v: &V) -> N { self.Degree(v) }
  213|       |    }
  214|       |
  215|       |    impl<V: StT + MtT + Hash + 'static> std::fmt::Debug for UnDirGraphMtEph<V> {
  216|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  217|      1|            f.debug_struct("UnDirGraphMtEph")
  218|      1|                .field("V", &self.V)
  219|      1|                .field("E", &self.E)
  220|      1|                .finish()
  221|      1|        }
  222|       |    }
  223|       |
  224|       |    impl<V: StT + MtT + Hash + 'static> std::fmt::Display for UnDirGraphMtEph<V> {
  225|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, "V={} E={:?}", self.V, self.E) }
  226|       |    }
  227|       |
  228|       |    impl<V: StT + MtT + Hash + 'static> PartialEq for UnDirGraphMtEph<V> {
  229|      3|        fn eq(&self, other: &Self) -> bool { self.V == other.V && self.E == other.E }
  230|       |    }
  231|       |    impl<V: StT + MtT + Hash + 'static> Eq for UnDirGraphMtEph<V> {}
  232|       |
  233|       |    #[macro_export]
  234|       |    macro_rules! UnDirGraphMtEphLit {
  235|       |        () => {{
  236|       |            let __V: $crate::Chap05::SetStEph::SetStEph::Set<_> = $crate::SetLit![];
  237|       |            let __E: $crate::Chap05::SetStEph::SetStEph::Set<$crate::Types::Types::Edge<_>> = $crate::SetLit![];
  238|       |            < $crate::Chap06::UnDirGraphMtEph::UnDirGraphMtEph::UnDirGraphMtEph<_> as $crate::Chap06::UnDirGraphMtEph::UnDirGraphMtEph::UnDirGraphMtEphTrait<_> >::FromSets(__V, __E)
  239|       |        }};
  240|       |        ( V: [ $( $v:expr ),* $(,)? ], E: [ $( ( $u:expr , $w:expr ) ),* $(,)? ] ) => {{
  241|       |            let __V: $crate::Chap05::SetStEph::SetStEph::Set<_> = $crate::SetLit![ $( $v ),* ];
  242|       |            let __E: $crate::Chap05::SetStEph::SetStEph::Set<_> = {
  243|       |                let mut __s = < $crate::Chap05::SetStEph::SetStEph::Set<_> >::empty();
  244|       |                $( let _ = __s.insert($crate::Types::Types::Edge($u, $w)); )*
  245|       |                __s
  246|       |            };
  247|       |            < $crate::Chap06::UnDirGraphMtEph::UnDirGraphMtEph::UnDirGraphMtEph<_> as $crate::Chap06::UnDirGraphMtEph::UnDirGraphMtEph::UnDirGraphMtEphTrait<_> >::FromSets(__V, __E)
  248|       |        }};
  249|       |    }
  250|       |
  251|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap06/UnDirGraphStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 6.1 Undirected Graph (ephemeral) using Set for vertices and edges.
    3|       |
    4|       |pub mod UnDirGraphStEph {
    5|       |
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |    use std::hash::Hash;
    8|       |
    9|       |    use crate::Chap05::SetStEph::SetStEph::*;
   10|       |    use crate::SetLit;
   11|       |    use crate::Types::Types::*;
   12|       |
   13|       |    #[derive(Clone)]
   14|       |    pub struct UnDirGraphStEph<V: StT + Hash> {
   15|       |        V: Set<V>,
   16|       |        E: Set<Edge<V>>,
   17|       |    }
   18|       |
   19|       |    pub trait UnDirGraphStEphTrait<V: StT + Hash> {
   20|       |        /// APAS: Work (1), Span (1)
   21|       |        /// claude-4-sonet: Work (1), Span (1)
   22|       |        fn empty() -> UnDirGraphStEph<V>;
   23|       |        /// APAS: Work (|V| + |E|), Span (1)
   24|       |        /// claude-4-sonet: Work (|V| + |E|), Span (1)
   25|       |        fn FromSets(V: Set<V>, E: Set<Edge<V>>) -> UnDirGraphStEph<V>;
   26|       |        /// APAS: Work (1), Span (1)
   27|       |        /// claude-4-sonet: Work (1), Span (1)
   28|       |        fn vertices(&self) -> &Set<V>;
   29|       |        /// APAS: Work (1), Span (1)
   30|       |        /// claude-4-sonet: Work (1), Span (1)
   31|       |        fn edges(&self) -> &Set<Edge<V>>;
   32|       |        /// APAS: Work (1), Span (1)
   33|       |        /// claude-4-sonet: Work (1), Span (1)
   34|       |        fn sizeV(&self) -> N;
   35|       |        /// APAS: Work (1), Span (1)
   36|       |        /// claude-4-sonet: Work (1), Span (1)
   37|       |        fn sizeE(&self) -> N;
   38|       |        /// APAS: Work (1), Span (1)
   39|       |        /// claude-4-sonet: Work (1), Span (1)
   40|       |        fn Neighbor(&self, u: &V, v: &V) -> B;
   41|       |        /// APAS: Work (|E|), Span (1)
   42|       |        /// claude-4-sonet: Work (|E|), Span (1)
   43|       |        fn NG(&self, v: &V) -> Set<V>;
   44|       |        /// APAS: Work (|u_set|  |E|), Span (1)
   45|       |        /// claude-4-sonet: Work (|u_set|  |E|), Span (1)
   46|       |        fn NGOfVertices(&self, u_set: &Set<V>) -> Set<V>;
   47|       |        /// APAS: Work (1), Span (1)
   48|       |        /// claude-4-sonet: Work (1), Span (1)
   49|       |        fn Incident(&self, e: &Edge<V>, v: &V) -> B;
   50|       |        /// APAS: Work (|E|), Span (1)
   51|       |        /// claude-4-sonet: Work (|E|), Span (1)
   52|       |        fn Degree(&self, v: &V) -> N;
   53|       |    }
   54|       |
   55|       |    impl<V: StT + Hash> UnDirGraphStEphTrait<V> for UnDirGraphStEph<V> {
   56|      3|        fn empty() -> UnDirGraphStEph<V> {
   57|      3|            UnDirGraphStEph {
   58|      3|                V: SetLit![],
   59|      3|                E: SetLit![],
   60|      3|            }
   61|      3|        }
   62|     85|        fn FromSets(V: Set<V>, E: Set<Edge<V>>) -> UnDirGraphStEph<V> { UnDirGraphStEph { V, E } }
   63|     71|        fn vertices(&self) -> &Set<V> { &self.V }
   64|     69|        fn edges(&self) -> &Set<Edge<V>> { &self.E }
   65|     17|        fn sizeV(&self) -> N { self.V.size() }
   66|     53|        fn sizeE(&self) -> N { self.E.size() }
   67|       |
   68|     20|        fn Neighbor(&self, u: &V, v: &V) -> B {
   69|       |            // Treat edges as unordered: {u,v}
   70|     20|            if true == self.E.mem(&Edge(u.clone(), v.clone())) || true == self.E.mem(&Edge(v.clone(), u.clone())) {
                                                                                ^6      ^6     ^6        ^6^6
   71|     17|                true
   72|       |            } else {
   73|      3|                false
   74|       |            }
   75|     20|        }
   76|       |
   77|    110|        fn NG(&self, v: &V) -> Set<V> {
   78|    110|            let mut ng: Set<V> = SetLit![];
   79|    399|            for Edge(a, b) in self.E.iter().cloned() {
                                            ^110   ^110   ^110
   80|    399|                if a == *v {
   81|     72|                    let _ = ng.insert(b.clone());
   82|    327|                } else if b == *v {
   83|     71|                    let _ = ng.insert(a.clone());
   84|    256|                }
   85|       |            }
   86|    110|            ng
   87|    110|        }
   88|       |
   89|      3|        fn NGOfVertices(&self, u_set: &Set<V>) -> Set<V> {
   90|      3|            let mut result: Set<V> = SetLit![];
   91|      4|            for u in u_set.iter() {
                                   ^3    ^3
   92|      4|                let ng_u = self.NG(u);
   93|      4|                result = result.union(&ng_u);
   94|      4|            }
   95|      3|            result
   96|      3|        }
   97|       |
   98|     41|        fn Incident(&self, e: &Edge<V>, v: &V) -> B { if &e.0 == v || &e.1 == v { true } else { false } }
                                                                                    ^33         ^12           ^29
   99|       |
  100|     22|        fn Degree(&self, v: &V) -> N { self.NG(v).size() }
  101|       |    }
  102|       |
  103|       |    // DirGraphStEph-compatible interface for undirected graphs
  104|       |    impl<V: StT + Hash> UnDirGraphStEph<V> {
  105|       |        /// Arc count (alias for edge count in undirected graphs)
  106|      1|        pub fn sizeA(&self) -> N { self.sizeE() }
  107|       |
  108|       |        /// Arcs (alias for edges in undirected graphs)
  109|      1|        pub fn arcs(&self) -> &Set<Edge<V>> { self.edges() }
  110|       |
  111|       |        /// Neighbors (in undirected graphs, all neighbors are both in and out)
  112|      1|        pub fn NPlus(&self, v: &V) -> Set<V> { self.NG(v) }
  113|       |
  114|       |        /// Neighbors (in undirected graphs, all neighbors are both in and out)
  115|      1|        pub fn NMinus(&self, v: &V) -> Set<V> { self.NG(v) }
  116|       |
  117|       |        /// Neighbors of vertex set
  118|      1|        pub fn NPlusOfVertices(&self, u_set: &Set<V>) -> Set<V> { self.NGOfVertices(u_set) }
  119|       |
  120|       |        /// Neighbors of vertex set
  121|      1|        pub fn NMinusOfVertices(&self, u_set: &Set<V>) -> Set<V> { self.NGOfVertices(u_set) }
  122|       |
  123|       |        /// Degree (in undirected graphs, in-degree equals total degree)
  124|      1|        pub fn InDegree(&self, v: &V) -> N { self.Degree(v) }
  125|       |
  126|       |        /// Degree (in undirected graphs, out-degree equals total degree)
  127|      1|        pub fn OutDegree(&self, v: &V) -> N { self.Degree(v) }
  128|       |    }
  129|       |
  130|       |    impl<V: StT + Hash> Debug for UnDirGraphStEph<V> {
  131|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  132|      1|            f.debug_struct("UnDirGraphStEph")
  133|      1|                .field("V", &self.V)
  134|      1|                .field("E", &self.E)
  135|      1|                .finish()
  136|      1|        }
  137|       |    }
  138|       |
  139|       |    impl<V: StT + Hash> Display for UnDirGraphStEph<V> {
  140|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { write!(f, "V={} E={:?}", self.V, self.E) }
  141|       |    }
  142|       |
  143|       |    impl<V: StT + Hash> PartialEq for UnDirGraphStEph<V> {
  144|      2|        fn eq(&self, other: &Self) -> bool { self.V == other.V && self.E == other.E }
  145|       |    }
  146|       |    impl<V: StT + Hash> Eq for UnDirGraphStEph<V> {}
  147|       |
  148|       |    #[macro_export]
  149|       |    macro_rules! UnDirGraphStEphLit {
  150|       |        () => {{
  151|       |            let __V: $crate::Chap05::SetStEph::SetStEph::Set<_> = $crate::SetLit![];
  152|       |            let __E: $crate::Chap05::SetStEph::SetStEph::Set<$crate::Types::Types::Edge<_>> = $crate::SetLit![];
  153|       |            < $crate::Chap06::UnDirGraphStEph::UnDirGraphStEph::UnDirGraphStEph<_> as $crate::Chap06::UnDirGraphStEph::UnDirGraphStEph::UnDirGraphStEphTrait<_> >::FromSets(__V, __E)
  154|       |        }};
  155|       |        ( V: [ $( $v:expr ),* $(,)? ], E: [ $( ( $u:expr , $w:expr ) ),* $(,)? ] ) => {{
  156|       |            let __V: $crate::Chap05::SetStEph::SetStEph::Set<_> = $crate::SetLit![ $( $v ),* ];
  157|       |            let __E: $crate::Chap05::SetStEph::SetStEph::Set<_> = {
  158|       |                let mut __s = < $crate::Chap05::SetStEph::SetStEph::Set<_> >::empty();
  159|       |                $( let _ = __s.insert($crate::Types::Types::Edge($u, $w)); )*
  160|       |                __s
  161|       |            };
  162|       |            < $crate::Chap06::UnDirGraphStEph::UnDirGraphStEph::UnDirGraphStEph<_> as $crate::Chap06::UnDirGraphStEph::UnDirGraphStEph::UnDirGraphStEphTrait<_> >::FromSets(__V, __E)
  163|       |        }};
  164|       |    }
  165|       |
  166|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap06/WeightedDirGraphMtEphFloat.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 6 Weighted Directed Graph (ephemeral) with floating-point weights - Multi-threaded version.
    3|       |//!
    4|       |//! Note: NOW uses true parallelism via ParaPair! for weighted neighbor operations.
    5|       |//! Weighted arc filtering (out_neighbors_weighted, in_neighbors_weighted) is parallel.
    6|       |
    7|       |pub mod WeightedDirGraphMtEphFloat {
    8|       |
    9|       |    use std::fmt::{Debug, Display, Formatter, Result};
   10|       |    use std::hash::Hash;
   11|       |
   12|       |    use crate::Chap05::SetStEph::SetStEph::*;
   13|       |    use crate::Chap06::LabDirGraphMtEph::LabDirGraphMtEph::*;
   14|       |    use crate::ParaPair;
   15|       |    use crate::Types::Types::*;
   16|       |
   17|       |    pub type WeightedDirGraphMtEphFloat<V> = LabDirGraphMtEph<V, OrderedF64>;
   18|       |
   19|       |    /// Convenience functions for weighted directed graphs with floating-point weights (multi-threaded)
   20|       |    impl<V: StT + MtT + Hash + 'static> WeightedDirGraphMtEphFloat<V> {
   21|       |        /// Create from vertices and weighted edges
   22|       |        /// APAS: Work (|V| + |E|), Span (1)
   23|       |        /// claude-4-sonet: Work (|V| + |E|), Span (|V| + |E|), Parallelism (1) - sequential
   24|     16|        pub fn from_weighted_edges(vertices: Set<V>, edges: Set<(V, V, OrderedFloat<f64>)>) -> Self {
   25|     16|            let labeled_edges = edges
   26|     16|                .iter()
   27|     32|                .map(|(from, to, weight)| LabEdge(from.clone(), to.clone(), *weight))
                               ^16
   28|     16|                .collect::<Vec<_>>();
   29|       |
   30|     16|            let mut edge_set = Set::empty();
   31|     48|            for edge in labeled_edges {
                              ^32
   32|     32|                edge_set.insert(edge);
   33|     32|            }
   34|       |
   35|     16|            Self::from_vertices_and_labeled_arcs(vertices, edge_set)
   36|     16|        }
   37|       |
   38|       |        /// Add a weighted edge to the graph
   39|       |        /// APAS: Work (1), Span (1)
   40|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   41|      0|        pub fn add_weighted_edge(&mut self, from: V, to: V, weight: OrderedFloat<f64>) {
   42|      0|            self.add_labeled_arc(from, to, weight);
   43|      0|        }
   44|       |
   45|       |        /// Get the weight of an edge, if it exists
   46|       |        /// APAS: Work (|A|), Span (1)
   47|       |        /// claude-4-sonet: Work (|A|), Span (|A|), Parallelism (1) - sequential search
   48|      1|        pub fn get_edge_weight(&self, from: &V, to: &V) -> Option<OrderedFloat<f64>> {
   49|      1|            self.get_arc_label(from, to).copied()
   50|      1|        }
   51|       |
   52|       |        /// Get all weighted edges as (from, to, weight) tuples
   53|       |        /// APAS: Work (|A|), Span (1)
   54|       |        /// claude-4-sonet: Work (|A|), Span (|A|), Parallelism (1) - sequential map
   55|      1|        pub fn weighted_edges(&self) -> Set<(V, V, OrderedFloat<f64>)> {
   56|      1|            let mut edges = Set::empty();
   57|      1|            for labeled_edge in self.labeled_arcs().iter() {
                              ^0
   58|      0|                edges.insert((labeled_edge.0.clone_mt(), labeled_edge.1.clone_mt(), labeled_edge.2));
   59|      0|            }
   60|      1|            edges
   61|      1|        }
   62|       |
   63|       |        /// Get outgoing neighbors with weights
   64|       |        /// APAS: Work (|A|), Span (1)
   65|       |        /// claude-4-sonet: Work (|A|), Span (log |A|), Parallelism (|A|/log |A|) - parallel divide-and-conquer filter
   66|     56|        pub fn out_neighbors_weighted(&self, v: &V) -> Set<(V, OrderedFloat<f64>)> {
   67|       |            // PARALLEL: filter weighted arcs using divide-and-conquer
   68|     56|            let arcs: Vec<LabEdge<V, OrderedF64>> = self.labeled_arcs().iter().cloned().collect();
   69|     56|            let n = arcs.len();
   70|       |
   71|     56|            if n <= 8 {
   72|     56|                let mut neighbors = Set::empty();
   73|    206|                for labeled_edge in arcs {
                                  ^150
   74|    150|                    if labeled_edge.0 == *v {
   75|     48|                        neighbors.insert((labeled_edge.1.clone_mt(), labeled_edge.2));
   76|    102|                    }
   77|       |                }
   78|     56|                return neighbors;
   79|      0|            }
   80|       |
   81|       |            // Parallel divide-and-conquer
   82|      0|            fn parallel_out<V: StT + MtT + Hash + 'static>(
   83|      0|                arcs: Vec<LabEdge<V, OrderedF64>>,
   84|      0|                v: V,
   85|      0|            ) -> Set<(V, OrderedFloat<f64>)> {
   86|      0|                let n = arcs.len();
   87|      0|                if n == 0 {
   88|      0|                    return Set::empty();
   89|      0|                }
   90|      0|                if n == 1 {
   91|      0|                    return if arcs[0].0 == v {
   92|      0|                        let mut s = Set::empty();
   93|      0|                        s.insert((arcs[0].1.clone_mt(), arcs[0].2));
   94|      0|                        s
   95|       |                    } else {
   96|      0|                        Set::empty()
   97|       |                    };
   98|      0|                }
   99|       |
  100|      0|                let mid = n / 2;
  101|      0|                let mut right_arcs = arcs;
  102|      0|                let left_arcs = right_arcs.split_off(mid);
  103|       |
  104|      0|                let v_left = v.clone_mt();
  105|      0|                let v_right = v;
  106|       |
  107|      0|                let Pair(left_result, right_result) =
  108|      0|                    ParaPair!(move || parallel_out(left_arcs, v_left), move || parallel_out(
  109|      0|                        right_arcs, v_right
  110|       |                    ));
  111|       |
  112|      0|                left_result.union(&right_result)
  113|      0|            }
  114|       |
  115|      0|            parallel_out(arcs, v.clone_mt())
  116|     56|        }
  117|       |
  118|       |        /// Get incoming neighbors with weights
  119|       |        /// APAS: Work (|A|), Span (1)
  120|       |        /// claude-4-sonet: Work (|A|), Span (log |A|), Parallelism (|A|/log |A|) - parallel divide-and-conquer filter
  121|      1|        pub fn in_neighbors_weighted(&self, v: &V) -> Set<(V, OrderedFloat<f64>)> {
  122|       |            // PARALLEL: filter weighted arcs using divide-and-conquer
  123|      1|            let arcs: Vec<LabEdge<V, OrderedF64>> = self.labeled_arcs().iter().cloned().collect();
  124|      1|            let n = arcs.len();
  125|       |
  126|      1|            if n <= 8 {
  127|      1|                let mut neighbors = Set::empty();
  128|      3|                for labeled_edge in arcs {
                                  ^2
  129|      2|                    if labeled_edge.1 == *v {
  130|      2|                        neighbors.insert((labeled_edge.0.clone_mt(), labeled_edge.2));
  131|      2|                    }
                                  ^0
  132|       |                }
  133|      1|                return neighbors;
  134|      0|            }
  135|       |
  136|       |            // Parallel divide-and-conquer
  137|      0|            fn parallel_in<V: StT + MtT + Hash + 'static>(
  138|      0|                arcs: Vec<LabEdge<V, OrderedF64>>,
  139|      0|                v: V,
  140|      0|            ) -> Set<(V, OrderedFloat<f64>)> {
  141|      0|                let n = arcs.len();
  142|      0|                if n == 0 {
  143|      0|                    return Set::empty();
  144|      0|                }
  145|      0|                if n == 1 {
  146|      0|                    return if arcs[0].1 == v {
  147|      0|                        let mut s = Set::empty();
  148|      0|                        s.insert((arcs[0].0.clone_mt(), arcs[0].2));
  149|      0|                        s
  150|       |                    } else {
  151|      0|                        Set::empty()
  152|       |                    };
  153|      0|                }
  154|       |
  155|      0|                let mid = n / 2;
  156|      0|                let mut right_arcs = arcs;
  157|      0|                let left_arcs = right_arcs.split_off(mid);
  158|       |
  159|      0|                let v_left = v.clone_mt();
  160|      0|                let v_right = v;
  161|       |
  162|      0|                let Pair(left_result, right_result) =
  163|      0|                    ParaPair!(move || parallel_in(left_arcs, v_left), move || parallel_in(
  164|      0|                        right_arcs, v_right
  165|       |                    ));
  166|       |
  167|      0|                left_result.union(&right_result)
  168|      0|            }
  169|       |
  170|      0|            parallel_in(arcs, v.clone_mt())
  171|      1|        }
  172|       |
  173|       |        /// Get the total weight of all edges
  174|       |        /// APAS: Work (|A|), Span (1)
  175|       |        /// claude-4-sonet: Work (|A|), Span (|A|), Parallelism (1) - sequential sum
  176|      1|        pub fn total_weight(&self) -> OrderedFloat<f64> {
  177|      1|            self.labeled_arcs()
  178|      1|                .iter()
  179|      1|                .map(|edge| edge.2)
  180|      1|                .fold(OrderedFloat(0.0), |acc, w| acc + w)
  181|      1|        }
  182|       |    }
  183|       |
  184|       |    #[macro_export]
  185|       |    macro_rules! WeightedDirGraphMtEphFloatLit {
  186|       |        () => {{
  187|       |            $crate::Chap06::LabDirGraphMtEph::LabDirGraphMtEph::LabDirGraphMtEph::empty()
  188|       |        }};
  189|       |        ( V: [ $( $v:expr ),* $(,)? ], A: [ $( ($from:expr, $to:expr, $weight:expr) ),* $(,)? ] ) => {{
  190|       |            let vertices = $crate::SetLit![ $( $v ),* ];
  191|       |            let arcs = $crate::SetLit![ $( ($from, $to, OrderedFloat($weight as f64)) ),* ];
  192|       |            $crate::Chap06::WeightedDirGraphMtEphFloat::WeightedDirGraphMtEphFloat::WeightedDirGraphMtEphFloat::from_weighted_edges(vertices, arcs)
  193|       |        }};
  194|       |    }
  195|       |
  196|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap06/WeightedDirGraphMtEphInt.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 6 Weighted Directed Graph (ephemeral) with integer weights - Multi-threaded version.
    3|       |//!
    4|       |//! Note: NOW uses true parallelism via ParaPair! for weighted neighbor operations.
    5|       |//! Weighted arc filtering (out_neighbors_weighted, in_neighbors_weighted) is parallel.
    6|       |
    7|       |pub mod WeightedDirGraphMtEphInt {
    8|       |
    9|       |    use std::fmt::{Debug, Display, Formatter, Result};
   10|       |    use std::hash::Hash;
   11|       |
   12|       |    use crate::Chap05::SetStEph::SetStEph::*;
   13|       |    use crate::Chap06::LabDirGraphMtEph::LabDirGraphMtEph::*;
   14|       |    use crate::ParaPair;
   15|       |    use crate::Types::Types::*;
   16|       |
   17|       |    pub type WeightedDirGraphMtEphInt<V> = LabDirGraphMtEph<V, i32>;
   18|       |
   19|       |    /// Convenience functions for weighted directed graphs with integer weights (multi-threaded)
   20|       |    impl<V: StT + MtT + Hash + 'static> WeightedDirGraphMtEphInt<V> {
   21|       |        /// Create from vertices and weighted edges
   22|       |        /// APAS: Work (|V| + |E|), Span (1)
   23|       |        /// claude-4-sonet: Work (|V| + |E|), Span (|V| + |E|), Parallelism (1) - sequential
   24|     13|        pub fn from_weighted_edges(vertices: Set<V>, edges: Set<(V, V, i32)>) -> Self {
   25|     13|            let labeled_edges = edges
   26|     13|                .iter()
   27|     26|                .map(|(from, to, weight)| LabEdge(from.clone(), to.clone(), *weight))
                               ^13
   28|     13|                .collect::<Vec<_>>();
   29|       |
   30|     13|            let mut edge_set = Set::empty();
   31|     39|            for edge in labeled_edges {
                              ^26
   32|     26|                edge_set.insert(edge);
   33|     26|            }
   34|       |
   35|     13|            Self::from_vertices_and_labeled_arcs(vertices, edge_set)
   36|     13|        }
   37|       |
   38|       |        /// Add a weighted edge to the graph
   39|       |        /// APAS: Work (1), Span (1)
   40|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   41|      0|        pub fn add_weighted_edge(&mut self, from: V, to: V, weight: i32) { self.add_labeled_arc(from, to, weight); }
   42|       |
   43|       |        /// Get the weight of an edge, if it exists
   44|       |        /// APAS: Work (|A|), Span (1)
   45|       |        /// claude-4-sonet: Work (|A|), Span (|A|), Parallelism (1) - sequential search
   46|      1|        pub fn get_edge_weight(&self, from: &V, to: &V) -> Option<i32> { self.get_arc_label(from, to).copied() }
   47|       |
   48|       |        /// Get all weighted edges as (from, to, weight) tuples
   49|       |        /// APAS: Work (|A|), Span (1)
   50|       |        /// claude-4-sonet: Work (|A|), Span (|A|), Parallelism (1) - sequential map
   51|      1|        pub fn weighted_edges(&self) -> Set<(V, V, i32)> {
   52|      1|            let mut edges = Set::empty();
   53|      1|            for labeled_edge in self.labeled_arcs().iter() {
                              ^0
   54|      0|                edges.insert((labeled_edge.0.clone_mt(), labeled_edge.1.clone_mt(), labeled_edge.2));
   55|      0|            }
   56|      1|            edges
   57|      1|        }
   58|       |
   59|       |        /// Get outgoing neighbors with weights
   60|       |        /// APAS: Work (|A|), Span (1)
   61|       |        /// claude-4-sonet: Work (|A|), Span (log |A|), Parallelism (|A|/log |A|) - parallel divide-and-conquer filter
   62|     31|        pub fn out_neighbors_weighted(&self, v: &V) -> Set<(V, i32)> {
   63|       |            // PARALLEL: filter weighted arcs using divide-and-conquer
   64|     31|            let arcs: Vec<LabEdge<V, i32>> = self.labeled_arcs().iter().cloned().collect();
   65|     31|            let n = arcs.len();
   66|       |
   67|     31|            if n <= 8 {
   68|     31|                let mut neighbors = Set::empty();
   69|    140|                for labeled_edge in arcs {
                                  ^109
   70|    109|                    if labeled_edge.0 == *v {
   71|     30|                        neighbors.insert((labeled_edge.1.clone_mt(), labeled_edge.2));
   72|     79|                    }
   73|       |                }
   74|     31|                return neighbors;
   75|      0|            }
   76|       |
   77|       |            // Parallel divide-and-conquer
   78|      0|            fn parallel_out<V: StT + MtT + Hash + 'static>(arcs: Vec<LabEdge<V, i32>>, v: V) -> Set<(V, i32)> {
   79|      0|                let n = arcs.len();
   80|      0|                if n == 0 {
   81|      0|                    return Set::empty();
   82|      0|                }
   83|      0|                if n == 1 {
   84|      0|                    return if arcs[0].0 == v {
   85|      0|                        let mut s = Set::empty();
   86|      0|                        s.insert((arcs[0].1.clone_mt(), arcs[0].2));
   87|      0|                        s
   88|       |                    } else {
   89|      0|                        Set::empty()
   90|       |                    };
   91|      0|                }
   92|       |
   93|      0|                let mid = n / 2;
   94|      0|                let mut right_arcs = arcs;
   95|      0|                let left_arcs = right_arcs.split_off(mid);
   96|       |
   97|      0|                let v_left = v.clone_mt();
   98|      0|                let v_right = v;
   99|       |
  100|      0|                let Pair(left_result, right_result) =
  101|      0|                    ParaPair!(move || parallel_out(left_arcs, v_left), move || parallel_out(
  102|      0|                        right_arcs, v_right
  103|       |                    ));
  104|       |
  105|      0|                left_result.union(&right_result)
  106|      0|            }
  107|       |
  108|      0|            parallel_out(arcs, v.clone_mt())
  109|     31|        }
  110|       |
  111|       |        /// Get incoming neighbors with weights
  112|       |        /// APAS: Work (|A|), Span (1)
  113|       |        /// claude-4-sonet: Work (|A|), Span (log |A|), Parallelism (|A|/log |A|) - parallel divide-and-conquer filter
  114|      2|        pub fn in_neighbors_weighted(&self, v: &V) -> Set<(V, i32)> {
  115|       |            // PARALLEL: filter weighted arcs using divide-and-conquer
  116|      2|            let arcs: Vec<LabEdge<V, i32>> = self.labeled_arcs().iter().cloned().collect();
  117|      2|            let n = arcs.len();
  118|       |
  119|      2|            if n <= 8 {
  120|      2|                let mut neighbors = Set::empty();
  121|      5|                for labeled_edge in arcs {
                                  ^3
  122|      3|                    if labeled_edge.1 == *v {
  123|      2|                        neighbors.insert((labeled_edge.0.clone_mt(), labeled_edge.2));
  124|      2|                    }
                                  ^1
  125|       |                }
  126|      2|                return neighbors;
  127|      0|            }
  128|       |
  129|       |            // Parallel divide-and-conquer
  130|      0|            fn parallel_in<V: StT + MtT + Hash + 'static>(arcs: Vec<LabEdge<V, i32>>, v: V) -> Set<(V, i32)> {
  131|      0|                let n = arcs.len();
  132|      0|                if n == 0 {
  133|      0|                    return Set::empty();
  134|      0|                }
  135|      0|                if n == 1 {
  136|      0|                    return if arcs[0].1 == v {
  137|      0|                        let mut s = Set::empty();
  138|      0|                        s.insert((arcs[0].0.clone_mt(), arcs[0].2));
  139|      0|                        s
  140|       |                    } else {
  141|      0|                        Set::empty()
  142|       |                    };
  143|      0|                }
  144|       |
  145|      0|                let mid = n / 2;
  146|      0|                let mut right_arcs = arcs;
  147|      0|                let left_arcs = right_arcs.split_off(mid);
  148|       |
  149|      0|                let v_left = v.clone_mt();
  150|      0|                let v_right = v;
  151|       |
  152|      0|                let Pair(left_result, right_result) =
  153|      0|                    ParaPair!(move || parallel_in(left_arcs, v_left), move || parallel_in(
  154|      0|                        right_arcs, v_right
  155|       |                    ));
  156|       |
  157|      0|                left_result.union(&right_result)
  158|      0|            }
  159|       |
  160|      0|            parallel_in(arcs, v.clone_mt())
  161|      2|        }
  162|       |
  163|       |        /// Get the total weight of all edges
  164|       |        /// APAS: Work (|A|), Span (1)
  165|       |        /// claude-4-sonet: Work (|A|), Span (|A|), Parallelism (1) - sequential sum
  166|      2|        pub fn total_weight(&self) -> i32 { self.labeled_arcs().iter().map(|edge| edge.2).sum() }
  167|       |    }
  168|       |
  169|       |    #[macro_export]
  170|       |    macro_rules! WeightedDirGraphMtEphIntLit {
  171|       |        () => {{
  172|       |            $crate::Chap06::LabDirGraphMtEph::LabDirGraphMtEph::LabDirGraphMtEph::empty()
  173|       |        }};
  174|       |        ( V: [ $( $v:expr ),* $(,)? ], E: [ $( ($from:expr, $to:expr, $weight:expr) ),* $(,)? ] ) => {{
  175|       |            let vertices = $crate::SetLit![ $( $v ),* ];
  176|       |            let edges = $crate::SetLit![ $( ($from, $to, $weight) ),* ];
  177|       |            $crate::Chap06::WeightedDirGraphMtEphInt::WeightedDirGraphMtEphInt::WeightedDirGraphMtEphInt::from_weighted_edges(vertices, edges)
  178|       |        }};
  179|       |    }
  180|       |
  181|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap06/WeightedDirGraphStEphFloat.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 6 Weighted Directed Graph (ephemeral) with floating-point weights - Single-threaded version.
    3|       |//!
    4|       |//! This module provides weighted directed graphs using `OrderedFloat<f64>` for edge weights,
    5|       |//! enabling reliable hashing and ordering of floating-point values including NaN and Infinity.
    6|       |//!
    7|       |//! # Examples
    8|       |//!
    9|       |//! ```rust
   10|       |//! use apas_ai::Chap06::WeightedDirGraphStEphFloat::WeightedDirGraphStEphFloat::*;
   11|       |//! use apas_ai::Chap06::LabDirGraphStEph::LabDirGraphStEph::LabDirGraphStEphTrait;
   12|       |//! use apas_ai::WeightedDirGraphStEphFloatLit;
   13|       |//! use ordered_float::OrderedFloat;
   14|       |//!
   15|       |//! // Create graph using API
   16|       |//! let mut graph = WeightedDirGraphStEphFloat::empty();
   17|       |//! graph.add_weighted_edge("A", "B", OrderedFloat(3.14));
   18|       |//! graph.add_weighted_edge("B", "C", OrderedFloat(2.71));
   19|       |//!
   20|       |//! // Create graph using macro with APAS notation (A: for directed arcs)
   21|       |//! let graph_macro = WeightedDirGraphStEphFloatLit!(
   22|       |//!     V: ["A", "B", "C"],
   23|       |//!     A: [("A", "B", 3.14), ("B", "C", 2.71)]
   24|       |//! );
   25|       |//!
   26|       |//! // Query operations
   27|       |//! let weight = graph.get_edge_weight(&"A", &"B"); // Returns Option<OrderedFloat<f64>>
   28|       |//! let total = graph.total_weight(); // Returns OrderedFloat<f64>
   29|       |//! let heavy_edges = graph.edges_above_weight(OrderedFloat(3.0));
   30|       |//! ```
   31|       |
   32|       |pub mod WeightedDirGraphStEphFloat {
   33|       |
   34|       |    use std::fmt::{Debug, Display, Formatter, Result};
   35|       |    use std::hash::Hash;
   36|       |
   37|       |    use crate::Chap05::SetStEph::SetStEph::*;
   38|       |    use crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::*;
   39|       |    use crate::Types::Types::*;
   40|       |
   41|       |    pub type WeightedDirGraphStEphFloat<V> = LabDirGraphStEph<V, OrderedF64>;
   42|       |
   43|       |    /// Convenience functions for weighted directed graphs with floating-point weights
   44|       |    impl<V: StT + Hash> WeightedDirGraphStEphFloat<V> {
   45|       |        /// Create from vertices and weighted edges
   46|       |        /// APAS: Work (|V| + |E|), Span (1)
   47|       |        /// claude-4-sonet: Work (|V| + |E|), Span (|V| + |E|), Parallelism (1) - sequential
   48|     56|        pub fn from_weighted_edges(vertices: Set<V>, edges: Set<(V, V, OrderedFloat<f64>)>) -> Self {
   49|     56|            let labeled_edges = edges
   50|     56|                .iter()
   51|    180|                .map(|(from, to, weight)| LabEdge(from.clone(), to.clone(), *weight))
                               ^56
   52|     56|                .collect::<Vec<_>>();
   53|       |
   54|     56|            let mut edge_set = Set::empty();
   55|    236|            for edge in labeled_edges {
                              ^180
   56|    180|                edge_set.insert(edge);
   57|    180|            }
   58|       |
   59|     56|            Self::from_vertices_and_labeled_arcs(vertices, edge_set)
   60|     56|        }
   61|       |
   62|       |        /// Add a weighted edge to the graph
   63|       |        /// APAS: Work (1), Span (1)
   64|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   65|      1|        pub fn add_weighted_edge(&mut self, from: V, to: V, weight: OrderedFloat<f64>) {
   66|      1|            self.add_labeled_arc(from, to, weight);
   67|      1|        }
   68|       |
   69|       |        /// Get the weight of an edge, if it exists
   70|       |        /// APAS: Work (|A|), Span (1)
   71|       |        /// claude-4-sonet: Work (|A|), Span (|A|), Parallelism (1) - sequential search
   72|      4|        pub fn get_edge_weight(&self, from: &V, to: &V) -> Option<OrderedFloat<f64>> {
   73|      4|            self.get_arc_label(from, to).copied()
   74|      4|        }
   75|       |
   76|       |        /// Get all weighted edges as (from, to, weight) tuples
   77|       |        /// APAS: Work (|A|), Span (1)
   78|       |        /// claude-4-sonet: Work (|A|), Span (|A|), Parallelism (1) - sequential map
   79|      1|        pub fn weighted_edges(&self) -> Set<(V, V, OrderedFloat<f64>)> {
   80|      1|            let mut edges = Set::empty();
   81|      2|            for labeled_edge in self.labeled_arcs().iter() {
                                              ^1                  ^1
   82|      2|                edges.insert((labeled_edge.0.clone(), labeled_edge.1.clone(), labeled_edge.2));
   83|      2|            }
   84|      1|            edges
   85|      1|        }
   86|       |
   87|       |        /// Get outgoing neighbors with weights
   88|       |        /// APAS: Work (|A|), Span (1)
   89|       |        /// claude-4-sonet: Work (|A|), Span (|A|), Parallelism (1) - sequential filter
   90|     98|        pub fn out_neighbors_weighted(&self, v: &V) -> Set<(V, OrderedFloat<f64>)> {
   91|     98|            let mut neighbors = Set::empty();
   92|    311|            for labeled_edge in self.labeled_arcs().iter() {
                                              ^98                 ^98
   93|    311|                if labeled_edge.0 == *v {
   94|     72|                    neighbors.insert((labeled_edge.1.clone(), labeled_edge.2));
   95|    239|                }
   96|       |            }
   97|     98|            neighbors
   98|     98|        }
   99|       |
  100|       |        /// Get incoming neighbors with weights
  101|       |        /// APAS: Work (|A|), Span (1)
  102|       |        /// claude-4-sonet: Work (|A|), Span (|A|), Parallelism (1) - sequential filter
  103|    235|        pub fn in_neighbors_weighted(&self, v: &V) -> Set<(V, OrderedFloat<f64>)> {
  104|    235|            let mut neighbors = Set::empty();
  105|  1.22k|            for labeled_edge in self.labeled_arcs().iter() {
                                              ^235                ^235
  106|  1.22k|                if labeled_edge.1 == *v {
  107|    319|                    neighbors.insert((labeled_edge.0.clone(), labeled_edge.2));
  108|    901|                }
  109|       |            }
  110|    235|            neighbors
  111|    235|        }
  112|       |
  113|       |        /// Get the total weight of all edges
  114|       |        /// APAS: Work (|A|), Span (1)
  115|       |        /// claude-4-sonet: Work (|A|), Span (|A|), Parallelism (1) - sequential sum
  116|      1|        pub fn total_weight(&self) -> OrderedFloat<f64> {
  117|      1|            self.labeled_arcs()
  118|      1|                .iter()
  119|      1|                .map(|edge| edge.2)
  120|      2|                .fold(OrderedFloat(0.0), |acc, w| acc + w)
                               ^1   ^1
  121|      1|        }
  122|       |
  123|       |        /// Get edges with weight greater than threshold
  124|      1|        pub fn edges_above_weight(&self, threshold: OrderedFloat<f64>) -> Set<(V, V, OrderedFloat<f64>)> {
  125|      1|            let mut edges = Set::empty();
  126|      3|            for labeled_edge in self.labeled_arcs().iter() {
                                              ^1                  ^1
  127|      3|                if labeled_edge.2 > threshold {
  128|      2|                    edges.insert((labeled_edge.0.clone(), labeled_edge.1.clone(), labeled_edge.2));
  129|      2|                }
                              ^1
  130|       |            }
  131|      1|            edges
  132|      1|        }
  133|       |
  134|       |        /// Get edges with weight less than threshold
  135|      1|        pub fn edges_below_weight(&self, threshold: OrderedFloat<f64>) -> Set<(V, V, OrderedFloat<f64>)> {
  136|      1|            let mut edges = Set::empty();
  137|      3|            for labeled_edge in self.labeled_arcs().iter() {
                                              ^1                  ^1
  138|      3|                if labeled_edge.2 < threshold {
  139|      2|                    edges.insert((labeled_edge.0.clone(), labeled_edge.1.clone(), labeled_edge.2));
  140|      2|                }
                              ^1
  141|       |            }
  142|      1|            edges
  143|      1|        }
  144|       |
  145|       |        /// Get the minimum weight edge
  146|      1|        pub fn min_weight_edge(&self) -> Option<(V, V, OrderedFloat<f64>)> {
  147|      1|            self.labeled_arcs()
  148|      1|                .iter()
  149|      1|                .min_by_key(|edge| edge.2)
  150|      1|                .map(|edge| (edge.0.clone(), edge.1.clone(), edge.2))
  151|      1|        }
  152|       |
  153|       |        /// Get the maximum weight edge
  154|      1|        pub fn max_weight_edge(&self) -> Option<(V, V, OrderedFloat<f64>)> {
  155|      1|            self.labeled_arcs()
  156|      1|                .iter()
  157|      1|                .max_by_key(|edge| edge.2)
  158|      1|                .map(|edge| (edge.0.clone(), edge.1.clone(), edge.2))
  159|      1|        }
  160|       |
  161|       |        /// Scale all weights by a factor
  162|      1|        pub fn scale_weights(&mut self, factor: OrderedFloat<f64>) {
  163|      1|            let current_edges: Vec<_> = self.labeled_arcs().iter().cloned().collect();
  164|       |
  165|       |            // Clear current edges and re-add with scaled weights
  166|      1|            *self = Self::empty();
  167|      2|            let vertices: Vec<_> = current_edges.iter().map(|e| e.0.clone()).collect();
                              ^1        ^1       ^1                   ^1                   ^1
  168|      3|            for v in vertices {
                              ^2
  169|      2|                self.add_vertex(v);
  170|      2|            }
  171|       |
  172|       |            // Add scaled edges
  173|      3|            for edge in current_edges {
                              ^2
  174|      2|                self.add_labeled_arc(edge.0, edge.1, edge.2 * factor);
  175|      2|            }
  176|      1|        }
  177|       |    }
  178|       |
  179|       |    #[macro_export]
  180|       |    macro_rules! WeightedDirGraphStEphFloatLit {
  181|       |        () => {{
  182|       |            $crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::LabDirGraphStEph::empty()
  183|       |        }};
  184|       |        ( V: [ $( $v:expr ),* $(,)? ], A: [ $( ($from:expr, $to:expr, $weight:expr) ),* $(,)? ] ) => {{
  185|       |            let vertices = $crate::SetLit![ $( $v ),* ];
  186|       |            let arcs = $crate::SetLit![ $( ($from, $to, OrderedFloat($weight as f64)) ),* ];
  187|       |            $crate::Chap06::WeightedDirGraphStEphFloat::WeightedDirGraphStEphFloat::WeightedDirGraphStEphFloat::from_weighted_edges(vertices, arcs)
  188|       |        }};
  189|       |    }
  190|       |
  191|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap06/WeightedDirGraphStEphInt.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 6 Weighted Directed Graph (ephemeral) with integer weights - Single-threaded version.
    3|       |
    4|       |pub mod WeightedDirGraphStEphInt {
    5|       |
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |    use std::hash::Hash;
    8|       |
    9|       |    use crate::Chap05::SetStEph::SetStEph::*;
   10|       |    use crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::*;
   11|       |    use crate::Types::Types::*;
   12|       |
   13|       |    pub type WeightedDirGraphStEphInt<V> = LabDirGraphStEph<V, i32>;
   14|       |
   15|       |    /// Convenience functions for weighted directed graphs with integer weights
   16|       |    impl<V: StT + Hash> WeightedDirGraphStEphInt<V> {
   17|       |        /// Create from vertices and weighted edges
   18|       |        /// APAS: Work (|V| + |E|), Span (1)
   19|       |        /// claude-4-sonet: Work (|V| + |E|), Span (|V| + |E|), Parallelism (1) - sequential
   20|     65|        pub fn from_weighted_edges(vertices: Set<V>, edges: Set<(V, V, i32)>) -> Self {
   21|     65|            let labeled_edges = edges
   22|     65|                .iter()
   23|    222|                .map(|(from, to, weight)| LabEdge(from.clone(), to.clone(), *weight))
                               ^65
   24|     65|                .collect::<Vec<_>>();
   25|       |
   26|     65|            let mut edge_set = Set::empty();
   27|    287|            for edge in labeled_edges {
                              ^222
   28|    222|                edge_set.insert(edge);
   29|    222|            }
   30|       |
   31|     65|            Self::from_vertices_and_labeled_arcs(vertices, edge_set)
   32|     65|        }
   33|       |
   34|       |        /// Add a weighted edge to the graph
   35|       |        /// APAS: Work (1), Span (1)
   36|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   37|      2|        pub fn add_weighted_edge(&mut self, from: V, to: V, weight: i32) { self.add_labeled_arc(from, to, weight); }
   38|       |
   39|       |        /// Get the weight of an edge, if it exists
   40|       |        /// APAS: Work (|A|), Span (1)
   41|       |        /// claude-4-sonet: Work (|A|), Span (|A|), Parallelism (1) - sequential search
   42|      8|        pub fn get_edge_weight(&self, from: &V, to: &V) -> Option<i32> { self.get_arc_label(from, to).copied() }
   43|       |
   44|       |        /// Get all weighted edges as (from, to, weight) tuples
   45|       |        /// APAS: Work (|A|), Span (1)
   46|       |        /// claude-4-sonet: Work (|A|), Span (|A|), Parallelism (1) - sequential map
   47|      1|        pub fn weighted_edges(&self) -> Set<(V, V, i32)> {
   48|      1|            let mut edges = Set::empty();
   49|      2|            for labeled_edge in self.labeled_arcs().iter() {
                                              ^1                  ^1
   50|      2|                edges.insert((labeled_edge.0.clone(), labeled_edge.1.clone(), labeled_edge.2));
   51|      2|            }
   52|      1|            edges
   53|      1|        }
   54|       |
   55|       |        /// Get outgoing neighbors with weights
   56|       |        /// APAS: Work (|A|), Span (1)
   57|       |        /// claude-4-sonet: Work (|A|), Span (|A|), Parallelism (1) - sequential filter
   58|    107|        pub fn out_neighbors_weighted(&self, v: &V) -> Set<(V, i32)> {
   59|    107|            let mut neighbors = Set::empty();
   60|    525|            for labeled_edge in self.labeled_arcs().iter() {
                                              ^107                ^107
   61|    525|                if labeled_edge.0 == *v {
   62|    117|                    neighbors.insert((labeled_edge.1.clone(), labeled_edge.2));
   63|    408|                }
   64|       |            }
   65|    107|            neighbors
   66|    107|        }
   67|       |
   68|       |        /// Get incoming neighbors with weights
   69|       |        /// APAS: Work (|A|), Span (1)
   70|       |        /// claude-4-sonet: Work (|A|), Span (|A|), Parallelism (1) - sequential filter
   71|    278|        pub fn in_neighbors_weighted(&self, v: &V) -> Set<(V, i32)> {
   72|    278|            let mut neighbors = Set::empty();
   73|  1.65k|            for labeled_edge in self.labeled_arcs().iter() {
                                              ^278                ^278
   74|  1.65k|                if labeled_edge.1 == *v {
   75|    395|                    neighbors.insert((labeled_edge.0.clone(), labeled_edge.2));
   76|  1.25k|                }
   77|       |            }
   78|    278|            neighbors
   79|    278|        }
   80|       |
   81|       |        /// Get the total weight of all edges
   82|       |        /// APAS: Work (|A|), Span (1)
   83|       |        /// claude-4-sonet: Work (|A|), Span (|A|), Parallelism (1) - sequential sum
   84|     12|        pub fn total_weight(&self) -> i32 { self.labeled_arcs().iter().map(|edge| edge.2).sum() }
   85|       |
   86|       |        /// Get edges with weight greater than threshold
   87|      1|        pub fn edges_above_weight(&self, threshold: i32) -> Set<(V, V, i32)> {
   88|      1|            let mut edges = Set::empty();
   89|      4|            for labeled_edge in self.labeled_arcs().iter() {
                                              ^1                  ^1
   90|      4|                if labeled_edge.2 > threshold {
   91|      2|                    edges.insert((labeled_edge.0.clone(), labeled_edge.1.clone(), labeled_edge.2));
   92|      2|                }
   93|       |            }
   94|      1|            edges
   95|      1|        }
   96|       |
   97|       |        /// Get edges with weight less than threshold
   98|      1|        pub fn edges_below_weight(&self, threshold: i32) -> Set<(V, V, i32)> {
   99|      1|            let mut edges = Set::empty();
  100|      4|            for labeled_edge in self.labeled_arcs().iter() {
                                              ^1                  ^1
  101|      4|                if labeled_edge.2 < threshold {
  102|      2|                    edges.insert((labeled_edge.0.clone(), labeled_edge.1.clone(), labeled_edge.2));
  103|      2|                }
  104|       |            }
  105|      1|            edges
  106|      1|        }
  107|       |    }
  108|       |
  109|       |    #[macro_export]
  110|       |    macro_rules! WeightedDirGraphStEphIntLit {
  111|       |        () => {{
  112|       |            $crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::LabDirGraphStEph::empty()
  113|       |        }};
  114|       |        ( V: [ $( $v:expr ),* $(,)? ], E: [ $( ($from:expr, $to:expr, $weight:expr) ),* $(,)? ] ) => {{
  115|       |            let vertices = $crate::SetLit![ $( $v ),* ];
  116|       |            let edges = $crate::SetLit![ $( ($from, $to, $weight) ),* ];
  117|       |            $crate::Chap06::WeightedDirGraphStEphInt::WeightedDirGraphStEphInt::WeightedDirGraphStEphInt::from_weighted_edges(vertices, edges)
  118|       |        }};
  119|       |    }
  120|       |
  121|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap06/WeightedUnDirGraphMtEphFloat.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 6 Weighted Undirected Graph (ephemeral) with floating-point weights - Multi-threaded version.
    3|       |//!
    4|       |//! Note: NOW uses true parallelism via ParaPair! for weighted neighbor operations.
    5|       |//! Weighted edge filtering (neighbors_weighted) is parallel.
    6|       |
    7|       |pub mod WeightedUnDirGraphMtEphFloat {
    8|       |
    9|       |    use std::fmt::{Debug, Display, Formatter, Result};
   10|       |    use std::hash::Hash;
   11|       |
   12|       |    use crate::Chap05::SetStEph::SetStEph::*;
   13|       |    use crate::Chap06::LabUnDirGraphMtEph::LabUnDirGraphMtEph::*;
   14|       |    use crate::ParaPair;
   15|       |    use crate::Types::Types::*;
   16|       |
   17|       |    pub type WeightedUnDirGraphMtEphFloat<V> = LabUnDirGraphMtEph<V, OrderedF64>;
   18|       |
   19|       |    /// Convenience functions for weighted undirected graphs with floating-point weights (multi-threaded)
   20|       |    impl<V: HashOrd + MtT + 'static> WeightedUnDirGraphMtEphFloat<V> {
   21|       |        /// Create from vertices and weighted edges
   22|       |        /// APAS: Work (|V| + |E|), Span (1)
   23|       |        /// claude-4-sonet: Work (|V| + |E|), Span (|V| + |E|), Parallelism (1) - sequential
   24|      7|        pub fn from_weighted_edges(vertices: Set<V>, edges: Set<(V, V, OrderedFloat<f64>)>) -> Self {
   25|      7|            let labeled_edges = edges
   26|      7|                .iter()
   27|     13|                .map(|(v1, v2, weight)| LabEdge(v1.clone(), v2.clone(), *weight))
                               ^7
   28|      7|                .collect::<Vec<_>>();
   29|       |
   30|      7|            let mut edge_set = Set::empty();
   31|     20|            for edge in labeled_edges {
                              ^13
   32|     13|                edge_set.insert(edge);
   33|     13|            }
   34|       |
   35|      7|            Self::from_vertices_and_labeled_edges(vertices, edge_set)
   36|      7|        }
   37|       |
   38|       |        /// Add a weighted edge to the graph (undirected)
   39|       |        /// APAS: Work (1), Span (1)
   40|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   41|      1|        pub fn add_weighted_edge(&mut self, v1: V, v2: V, weight: OrderedFloat<f64>) {
   42|      1|            self.add_labeled_edge(v1, v2, weight);
   43|      1|        }
   44|       |
   45|       |        /// Get the weight of an edge, if it exists
   46|       |        /// APAS: Work (|E|), Span (1)
   47|       |        /// claude-4-sonet: Work (|E|), Span (|E|), Parallelism (1) - sequential search
   48|      4|        pub fn get_edge_weight(&self, v1: &V, v2: &V) -> Option<OrderedFloat<f64>> {
   49|      4|            self.get_edge_label(v1, v2).copied()
   50|      4|        }
   51|       |
   52|       |        /// Get all weighted edges as (v1, v2, weight) tuples
   53|       |        /// APAS: Work (|E|), Span (1)
   54|       |        /// claude-4-sonet: Work (|E|), Span (|E|), Parallelism (1) - sequential map
   55|      1|        pub fn weighted_edges(&self) -> Set<(V, V, OrderedFloat<f64>)> {
   56|      1|            let mut edges = Set::empty();
   57|      1|            for labeled_edge in self.labeled_edges().iter() {
   58|      1|                edges.insert((labeled_edge.0.clone_mt(), labeled_edge.1.clone_mt(), labeled_edge.2));
   59|      1|            }
   60|      1|            edges
   61|      1|        }
   62|       |
   63|       |        /// Get neighbors with weights
   64|       |        /// APAS: Work (|E|), Span (1)
   65|       |        /// claude-4-sonet: Work (|E|), Span (log |E|), Parallelism (|E|/log |E|) - parallel divide-and-conquer filter
   66|      1|        pub fn neighbors_weighted(&self, v: &V) -> Set<(V, OrderedFloat<f64>)> {
   67|       |            // PARALLEL: filter weighted edges using divide-and-conquer
   68|      1|            let edges: Vec<LabEdge<V, OrderedF64>> = self.labeled_edges().iter().cloned().collect();
   69|      1|            let n = edges.len();
   70|       |
   71|      1|            if n <= 8 {
   72|      1|                let mut neighbors = Set::empty();
   73|      3|                for labeled_edge in edges {
                                  ^2
   74|      2|                    if labeled_edge.0 == *v {
   75|      2|                        neighbors.insert((labeled_edge.1.clone_mt(), labeled_edge.2));
   76|      2|                    } else if labeled_edge.1 == *v {
                                            ^0
   77|      0|                        neighbors.insert((labeled_edge.0.clone_mt(), labeled_edge.2));
   78|      0|                    }
   79|       |                }
   80|      1|                return neighbors;
   81|      0|            }
   82|       |
   83|       |            // Parallel divide-and-conquer
   84|      0|            fn parallel_neighbors<V: HashOrd + MtT + 'static>(
   85|      0|                edges: Vec<LabEdge<V, OrderedF64>>,
   86|      0|                v: V,
   87|      0|            ) -> Set<(V, OrderedFloat<f64>)> {
   88|      0|                let n = edges.len();
   89|      0|                if n == 0 {
   90|      0|                    return Set::empty();
   91|      0|                }
   92|      0|                if n == 1 {
   93|      0|                    if edges[0].0 == v {
   94|      0|                        let mut s = Set::empty();
   95|      0|                        s.insert((edges[0].1.clone_mt(), edges[0].2));
   96|      0|                        return s;
   97|      0|                    } else if edges[0].1 == v {
   98|      0|                        let mut s = Set::empty();
   99|      0|                        s.insert((edges[0].0.clone_mt(), edges[0].2));
  100|      0|                        return s;
  101|      0|                    }
  102|      0|                    return Set::empty();
  103|      0|                }
  104|       |
  105|      0|                let mid = n / 2;
  106|      0|                let mut right_edges = edges;
  107|      0|                let left_edges = right_edges.split_off(mid);
  108|       |
  109|      0|                let v_left = v.clone_mt();
  110|      0|                let v_right = v;
  111|       |
  112|      0|                let Pair(left_result, right_result) =
  113|      0|                    ParaPair!(move || parallel_neighbors(left_edges, v_left), move || {
  114|      0|                        parallel_neighbors(right_edges, v_right)
  115|      0|                    });
  116|       |
  117|      0|                left_result.union(&right_result)
  118|      0|            }
  119|       |
  120|      0|            parallel_neighbors(edges, v.clone_mt())
  121|      1|        }
  122|       |
  123|       |        /// Get the total weight of all edges
  124|       |        /// APAS: Work (|E|), Span (1)
  125|       |        /// claude-4-sonet: Work (|E|), Span (|E|), Parallelism (1) - sequential sum
  126|      1|        pub fn total_weight(&self) -> OrderedFloat<f64> {
  127|      1|            self.labeled_edges()
  128|      1|                .iter()
  129|      1|                .map(|edge| edge.2)
  130|      2|                .fold(OrderedFloat(0.0), |acc, w| acc + w)
                               ^1   ^1
  131|      1|        }
  132|       |
  133|       |        /// Get the degree of a vertex (number of incident edges)
  134|     80|        pub fn vertex_degree(&self, v: &V) -> usize { self.neighbors(v).size() }
  135|       |    }
  136|       |
  137|       |    #[macro_export]
  138|       |    macro_rules! WeightedUnDirGraphMtEphFloatLit {
  139|       |        () => {{
  140|       |            $crate::Chap06::LabUnDirGraphMtEph::LabUnDirGraphMtEph::LabUnDirGraphMtEph::empty()
  141|       |        }};
  142|       |        ( V: [ $( $v:expr ),* $(,)? ], E: [ $( ($v1:expr, $v2:expr, $weight:expr) ),* $(,)? ] ) => {{
  143|       |            let vertices = $crate::SetLit![ $( $v ),* ];
  144|       |            let edges = $crate::SetLit![ $( ($v1, $v2, OrderedFloat($weight as f64)) ),* ];
  145|       |            $crate::Chap06::WeightedUnDirGraphMtEphFloat::WeightedUnDirGraphMtEphFloat::WeightedUnDirGraphMtEphFloat::from_weighted_edges(vertices, edges)
  146|       |        }};
  147|       |    }
  148|       |
  149|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap06/WeightedUnDirGraphMtEphInt.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 6 Weighted Undirected Graph (ephemeral) with integer weights - Multi-threaded version.
    3|       |//!
    4|       |//! Note: NOW uses true parallelism via ParaPair! for weighted neighbor operations.
    5|       |//! Weighted edge filtering (neighbors_weighted) is parallel.
    6|       |
    7|       |pub mod WeightedUnDirGraphMtEphInt {
    8|       |
    9|       |    use std::fmt::{Debug, Display, Formatter, Result};
   10|       |    use std::hash::Hash;
   11|       |
   12|       |    use crate::Chap05::SetStEph::SetStEph::*;
   13|       |    use crate::Chap06::LabUnDirGraphMtEph::LabUnDirGraphMtEph::*;
   14|       |    use crate::ParaPair;
   15|       |    use crate::Types::Types::*;
   16|       |
   17|       |    pub type WeightedUnDirGraphMtEphInt<V> = LabUnDirGraphMtEph<V, i32>;
   18|       |
   19|       |    /// Convenience functions for weighted undirected graphs with integer weights (multi-threaded)
   20|       |    impl<V: HashOrd + MtT + 'static> WeightedUnDirGraphMtEphInt<V> {
   21|       |        /// Create from vertices and weighted edges
   22|       |        /// APAS: Work (|V| + |E|), Span (1)
   23|       |        /// claude-4-sonet: Work (|V| + |E|), Span (|V| + |E|), Parallelism (1) - sequential
   24|      7|        pub fn from_weighted_edges(vertices: Set<V>, edges: Set<(V, V, i32)>) -> Self {
   25|      7|            let labeled_edges = edges
   26|      7|                .iter()
   27|     13|                .map(|(v1, v2, weight)| LabEdge(v1.clone(), v2.clone(), *weight))
                               ^7
   28|      7|                .collect::<Vec<_>>();
   29|       |
   30|      7|            let mut edge_set = Set::empty();
   31|     20|            for edge in labeled_edges {
                              ^13
   32|     13|                edge_set.insert(edge);
   33|     13|            }
   34|       |
   35|      7|            Self::from_vertices_and_labeled_edges(vertices, edge_set)
   36|      7|        }
   37|       |
   38|       |        /// Add a weighted edge to the graph (undirected)
   39|       |        /// APAS: Work (1), Span (1)
   40|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   41|      1|        pub fn add_weighted_edge(&mut self, v1: V, v2: V, weight: i32) { self.add_labeled_edge(v1, v2, weight); }
   42|       |
   43|       |        /// Get the weight of an edge, if it exists
   44|       |        /// APAS: Work (|E|), Span (1)
   45|       |        /// claude-4-sonet: Work (|E|), Span (|E|), Parallelism (1) - sequential search
   46|      4|        pub fn get_edge_weight(&self, v1: &V, v2: &V) -> Option<i32> { self.get_edge_label(v1, v2).copied() }
   47|       |
   48|       |        /// Get all weighted edges as (v1, v2, weight) tuples
   49|       |        /// APAS: Work (|E|), Span (1)
   50|       |        /// claude-4-sonet: Work (|E|), Span (|E|), Parallelism (1) - sequential map
   51|      1|        pub fn weighted_edges(&self) -> Set<(V, V, i32)> {
   52|      1|            let mut edges = Set::empty();
   53|      1|            for labeled_edge in self.labeled_edges().iter() {
   54|      1|                edges.insert((labeled_edge.0.clone_mt(), labeled_edge.1.clone_mt(), labeled_edge.2));
   55|      1|            }
   56|      1|            edges
   57|      1|        }
   58|       |
   59|       |        /// Get neighbors with weights
   60|       |        /// APAS: Work (|E|), Span (1)
   61|       |        /// claude-4-sonet: Work (|E|), Span (log |E|), Parallelism (|E|/log |E|) - parallel divide-and-conquer filter
   62|      1|        pub fn neighbors_weighted(&self, v: &V) -> Set<(V, i32)> {
   63|       |            // PARALLEL: filter weighted edges using divide-and-conquer
   64|      1|            let edges: Vec<LabEdge<V, i32>> = self.labeled_edges().iter().cloned().collect();
   65|      1|            let n = edges.len();
   66|       |
   67|      1|            if n <= 8 {
   68|      1|                let mut neighbors = Set::empty();
   69|      3|                for labeled_edge in edges {
                                  ^2
   70|      2|                    if labeled_edge.0 == *v {
   71|      2|                        neighbors.insert((labeled_edge.1.clone_mt(), labeled_edge.2));
   72|      2|                    } else if labeled_edge.1 == *v {
                                            ^0
   73|      0|                        neighbors.insert((labeled_edge.0.clone_mt(), labeled_edge.2));
   74|      0|                    }
   75|       |                }
   76|      1|                return neighbors;
   77|      0|            }
   78|       |
   79|       |            // Parallel divide-and-conquer
   80|      0|            fn parallel_neighbors<V: HashOrd + MtT + 'static>(edges: Vec<LabEdge<V, i32>>, v: V) -> Set<(V, i32)> {
   81|      0|                let n = edges.len();
   82|      0|                if n == 0 {
   83|      0|                    return Set::empty();
   84|      0|                }
   85|      0|                if n == 1 {
   86|      0|                    if edges[0].0 == v {
   87|      0|                        let mut s = Set::empty();
   88|      0|                        s.insert((edges[0].1.clone_mt(), edges[0].2));
   89|      0|                        return s;
   90|      0|                    } else if edges[0].1 == v {
   91|      0|                        let mut s = Set::empty();
   92|      0|                        s.insert((edges[0].0.clone_mt(), edges[0].2));
   93|      0|                        return s;
   94|      0|                    }
   95|      0|                    return Set::empty();
   96|      0|                }
   97|       |
   98|      0|                let mid = n / 2;
   99|      0|                let mut right_edges = edges;
  100|      0|                let left_edges = right_edges.split_off(mid);
  101|       |
  102|      0|                let v_left = v.clone_mt();
  103|      0|                let v_right = v;
  104|       |
  105|      0|                let Pair(left_result, right_result) =
  106|      0|                    ParaPair!(move || parallel_neighbors(left_edges, v_left), move || {
  107|      0|                        parallel_neighbors(right_edges, v_right)
  108|      0|                    });
  109|       |
  110|      0|                left_result.union(&right_result)
  111|      0|            }
  112|       |
  113|      0|            parallel_neighbors(edges, v.clone_mt())
  114|      1|        }
  115|       |
  116|       |        /// Get the total weight of all edges
  117|       |        /// APAS: Work (|E|), Span (1)
  118|       |        /// claude-4-sonet: Work (|E|), Span (|E|), Parallelism (1) - sequential sum
  119|      1|        pub fn total_weight(&self) -> i32 { self.labeled_edges().iter().map(|edge| edge.2).sum() }
  120|       |
  121|       |        /// Get the degree of a vertex (number of incident edges)
  122|     69|        pub fn vertex_degree(&self, v: &V) -> usize { self.neighbors(v).size() }
  123|       |    }
  124|       |
  125|       |    #[macro_export]
  126|       |    macro_rules! WeightedUnDirGraphMtEphIntLit {
  127|       |        () => {{
  128|       |            $crate::Chap06::LabUnDirGraphMtEph::LabUnDirGraphMtEph::LabUnDirGraphMtEph::empty()
  129|       |        }};
  130|       |        ( V: [ $( $v:expr ),* $(,)? ], E: [ $( ($v1:expr, $v2:expr, $weight:expr) ),* $(,)? ] ) => {{
  131|       |            let vertices = $crate::SetLit![ $( $v ),* ];
  132|       |            let edges = $crate::SetLit![ $( ($v1, $v2, $weight) ),* ];
  133|       |            $crate::Chap06::WeightedUnDirGraphMtEphInt::WeightedUnDirGraphMtEphInt::WeightedUnDirGraphMtEphInt::from_weighted_edges(vertices, edges)
  134|       |        }};
  135|       |    }
  136|       |
  137|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap06/WeightedUnDirGraphStEphFloat.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 6 Weighted Undirected Graph (ephemeral) with floating-point weights - Single-threaded version.
    3|       |//!
    4|       |//! This module provides weighted undirected graphs using `OrderedFloat<f64>` for edge weights,
    5|       |//! enabling reliable hashing and ordering of floating-point values including NaN and Infinity.
    6|       |//!
    7|       |//! # Examples
    8|       |//!
    9|       |//! ```rust
   10|       |//! use apas_ai::Chap06::WeightedUnDirGraphStEphFloat::WeightedUnDirGraphStEphFloat::*;
   11|       |//! use apas_ai::Chap06::LabUnDirGraphStEph::LabUnDirGraphStEph::LabUnDirGraphStEphTrait;
   12|       |//! use apas_ai::WeightedUnDirGraphStEphFloatLit;
   13|       |//! use ordered_float::OrderedFloat;
   14|       |//!
   15|       |//! // Create graph using API
   16|       |//! let mut graph = WeightedUnDirGraphStEphFloat::empty();
   17|       |//! graph.add_weighted_edge("A", "B", OrderedFloat(3.14));
   18|       |//! graph.add_weighted_edge("B", "C", OrderedFloat(2.71));
   19|       |//!
   20|       |//! // Create graph using macro with APAS notation (E: for undirected edges)
   21|       |//! let graph_macro = WeightedUnDirGraphStEphFloatLit!(
   22|       |//!     V: ["A", "B", "C"],
   23|       |//!     E: [("A", "B", 3.14), ("B", "C", 2.71)]
   24|       |//! );
   25|       |//!
   26|       |//! // Query operations
   27|       |//! let weight = graph.get_edge_weight(&"A", &"B"); // Returns Option<OrderedFloat<f64>>
   28|       |//! let total = graph.total_weight(); // Returns OrderedFloat<f64>
   29|       |//! let neighbors = graph.neighbors_weighted(&"A"); // Returns Set<(V, OrderedFloat<f64>)>
   30|       |//! ```
   31|       |
   32|       |pub mod WeightedUnDirGraphStEphFloat {
   33|       |
   34|       |    use std::fmt::{Debug, Display, Formatter, Result};
   35|       |    use std::hash::Hash;
   36|       |
   37|       |    use crate::Chap05::SetStEph::SetStEph::*;
   38|       |    use crate::Chap06::LabUnDirGraphStEph::LabUnDirGraphStEph::*;
   39|       |    use crate::Types::Types::*;
   40|       |
   41|       |    pub type WeightedUnDirGraphStEphFloat<V> = LabUnDirGraphStEph<V, OrderedF64>;
   42|       |
   43|       |    /// Convenience functions for weighted undirected graphs with floating-point weights
   44|       |    impl<V: StT + Hash + Ord> WeightedUnDirGraphStEphFloat<V> {
   45|       |        /// Create from vertices and weighted edges
   46|       |        /// APAS: Work (|V| + |E|), Span (1)
   47|       |        /// claude-4-sonet: Work (|V| + |E|), Span (|V| + |E|), Parallelism (1) - sequential
   48|     23|        pub fn from_weighted_edges(vertices: Set<V>, edges: Set<(V, V, OrderedFloat<f64>)>) -> Self {
   49|     23|            let labeled_edges = edges
   50|     23|                .iter()
   51|     59|                .map(|(v1, v2, weight)| LabEdge(v1.clone(), v2.clone(), *weight))
                               ^23
   52|     23|                .collect::<Vec<_>>();
   53|       |
   54|     23|            let mut edge_set = Set::empty();
   55|     82|            for edge in labeled_edges {
                              ^59
   56|     59|                edge_set.insert(edge);
   57|     59|            }
   58|       |
   59|     23|            Self::from_vertices_and_labeled_edges(vertices, edge_set)
   60|     23|        }
   61|       |
   62|       |        /// Add a weighted edge to the graph (undirected)
   63|       |        /// APAS: Work (1), Span (1)
   64|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   65|     61|        pub fn add_weighted_edge(&mut self, v1: V, v2: V, weight: OrderedFloat<f64>) {
   66|     61|            self.add_labeled_edge(v1, v2, weight);
   67|     61|        }
   68|       |
   69|       |        /// Get the weight of an edge, if it exists
   70|       |        /// APAS: Work (|E|), Span (1)
   71|       |        /// claude-4-sonet: Work (|E|), Span (|E|), Parallelism (1) - sequential search
   72|     16|        pub fn get_edge_weight(&self, v1: &V, v2: &V) -> Option<OrderedFloat<f64>> {
   73|     16|            self.get_edge_label(v1, v2).copied()
   74|     16|        }
   75|       |
   76|       |        /// Get all weighted edges as (v1, v2, weight) tuples
   77|       |        /// APAS: Work (|E|), Span (1)
   78|       |        /// claude-4-sonet: Work (|E|), Span (|E|), Parallelism (1) - sequential map
   79|      1|        pub fn weighted_edges(&self) -> Set<(V, V, OrderedFloat<f64>)> {
   80|      1|            let mut edges = Set::empty();
   81|      2|            for labeled_edge in self.labeled_edges().iter() {
                                              ^1                   ^1
   82|      2|                edges.insert((labeled_edge.0.clone(), labeled_edge.1.clone(), labeled_edge.2));
   83|      2|            }
   84|      1|            edges
   85|      1|        }
   86|       |
   87|       |        /// Get neighbors with weights
   88|       |        /// APAS: Work (|E|), Span (1)
   89|       |        /// claude-4-sonet: Work (|E|), Span (|E|), Parallelism (1) - sequential filter
   90|      4|        pub fn neighbors_weighted(&self, v: &V) -> Set<(V, OrderedFloat<f64>)> {
   91|      4|            let mut neighbors = Set::empty();
   92|      9|            for labeled_edge in self.labeled_edges().iter() {
                                              ^4                   ^4
   93|      9|                if labeled_edge.0 == *v {
   94|      3|                    neighbors.insert((labeled_edge.1.clone(), labeled_edge.2));
   95|      6|                } else if labeled_edge.1 == *v {
   96|      2|                    neighbors.insert((labeled_edge.0.clone(), labeled_edge.2));
   97|      4|                }
   98|       |            }
   99|      4|            neighbors
  100|      4|        }
  101|       |
  102|       |        /// Get the total weight of all edges
  103|       |        /// APAS: Work (|E|), Span (1)
  104|       |        /// claude-4-sonet: Work (|E|), Span (|E|), Parallelism (1) - sequential sum
  105|      2|        pub fn total_weight(&self) -> OrderedFloat<f64> {
  106|      2|            self.labeled_edges()
  107|      2|                .iter()
  108|      2|                .map(|edge| edge.2)
  109|      3|                .fold(OrderedFloat(0.0), |acc, w| acc + w)
                               ^2   ^2
  110|      2|        }
  111|       |
  112|       |        /// Get the degree of a vertex (number of incident edges)
  113|     20|        pub fn vertex_degree(&self, v: &V) -> usize { self.neighbors(v).size() }
  114|       |
  115|       |        /// Check if the graph is connected (all vertices reachable from any vertex)
  116|      9|        pub fn is_connected(&self) -> bool {
  117|      9|            if self.vertices().size() == 0 {
  118|      1|                return true; // Empty graph is considered connected
  119|      8|            }
  120|       |
  121|       |            // Simple connectivity check using DFS from first vertex
  122|      8|            let mut visited = Set::empty();
  123|      8|            let mut stack = Vec::new();
  124|       |
  125|      8|            if let Some(start) = self.vertices().iter().next() {
  126|      8|                stack.push(start.clone());
  127|       |
  128|     80|                while let Some(current) = stack.pop() {
                                             ^72
  129|     72|                    if visited.mem(&current) == false {
  130|     68|                        visited.insert(current.clone());
  131|    128|                        for neighbor in self.neighbors(&current).iter() {
                                                      ^68                      ^68
  132|    128|                            if visited.mem(neighbor) == false {
  133|     64|                                stack.push(neighbor.clone());
  134|     64|                            }
  135|       |                        }
  136|      4|                    }
  137|       |                }
  138|      0|            }
  139|       |
  140|      8|            visited.size() == self.vertices().size()
  141|      9|        }
  142|       |
  143|       |        /// Get the minimum weight edge
  144|      2|        pub fn min_weight_edge(&self) -> Option<(V, V, OrderedFloat<f64>)> {
  145|      2|            self.labeled_edges()
  146|      2|                .iter()
  147|      2|                .min_by_key(|edge| edge.2)
  148|      2|                .map(|edge| (edge.0.clone(), edge.1.clone(), edge.2))
                                           ^1     ^1       ^1     ^1       ^1
  149|      2|        }
  150|       |
  151|       |        /// Get the maximum weight edge
  152|      2|        pub fn max_weight_edge(&self) -> Option<(V, V, OrderedFloat<f64>)> {
  153|      2|            self.labeled_edges()
  154|      2|                .iter()
  155|      2|                .max_by_key(|edge| edge.2)
  156|      2|                .map(|edge| (edge.0.clone(), edge.1.clone(), edge.2))
                                           ^1     ^1       ^1     ^1       ^1
  157|      2|        }
  158|       |    }
  159|       |
  160|       |    #[macro_export]
  161|       |    macro_rules! WeightedUnDirGraphStEphFloatLit {
  162|       |        () => {{
  163|       |            $crate::Chap06::LabUnDirGraphStEph::LabUnDirGraphStEph::LabUnDirGraphStEph::empty()
  164|       |        }};
  165|       |        ( V: [ $( $v:expr ),* $(,)? ], E: [ $( ($v1:expr, $v2:expr, $weight:expr) ),* $(,)? ] ) => {{
  166|       |            let vertices = $crate::SetLit![ $( $v ),* ];
  167|       |            let edges = $crate::SetLit![ $( ($v1, $v2, OrderedFloat($weight as f64)) ),* ];
  168|       |            $crate::Chap06::WeightedUnDirGraphStEphFloat::WeightedUnDirGraphStEphFloat::WeightedUnDirGraphStEphFloat::from_weighted_edges(vertices, edges)
  169|       |        }};
  170|       |    }
  171|       |
  172|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap06/WeightedUnDirGraphStEphInt.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 6 Weighted Undirected Graph (ephemeral) with integer weights - Single-threaded version.
    3|       |
    4|       |pub mod WeightedUnDirGraphStEphInt {
    5|       |
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |    use std::hash::Hash;
    8|       |
    9|       |    use crate::Chap05::SetStEph::SetStEph::*;
   10|       |    use crate::Chap06::LabUnDirGraphStEph::LabUnDirGraphStEph::*;
   11|       |    use crate::Types::Types::*;
   12|       |
   13|       |    pub type WeightedUnDirGraphStEphInt<V> = LabUnDirGraphStEph<V, i32>;
   14|       |
   15|       |    /// Convenience functions for weighted undirected graphs with integer weights
   16|       |    impl<V: StT + Hash + Ord> WeightedUnDirGraphStEphInt<V> {
   17|       |        /// Create from vertices and weighted edges
   18|       |        /// APAS: Work (|V| + |E|), Span (1)
   19|       |        /// claude-4-sonet: Work (|V| + |E|), Span (|V| + |E|), Parallelism (1) - sequential
   20|     23|        pub fn from_weighted_edges(vertices: Set<V>, edges: Set<(V, V, i32)>) -> Self {
   21|     23|            let labeled_edges = edges
   22|     23|                .iter()
   23|     59|                .map(|(v1, v2, weight)| LabEdge(v1.clone(), v2.clone(), *weight))
                               ^23
   24|     23|                .collect::<Vec<_>>();
   25|       |
   26|     23|            let mut edge_set = Set::empty();
   27|     82|            for edge in labeled_edges {
                              ^59
   28|     59|                edge_set.insert(edge);
   29|     59|            }
   30|       |
   31|     23|            Self::from_vertices_and_labeled_edges(vertices, edge_set)
   32|     23|        }
   33|       |
   34|       |        /// Add a weighted edge to the graph (undirected)
   35|       |        /// APAS: Work (1), Span (1)
   36|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   37|     60|        pub fn add_weighted_edge(&mut self, v1: V, v2: V, weight: i32) { self.add_labeled_edge(v1, v2, weight); }
   38|       |
   39|       |        /// Get the weight of an edge, if it exists
   40|       |        /// APAS: Work (|E|), Span (1)
   41|       |        /// claude-4-sonet: Work (|E|), Span (|E|), Parallelism (1) - sequential search
   42|     16|        pub fn get_edge_weight(&self, v1: &V, v2: &V) -> Option<i32> { self.get_edge_label(v1, v2).copied() }
   43|       |
   44|       |        /// Get all weighted edges as (v1, v2, weight) tuples
   45|       |        /// APAS: Work (|E|), Span (1)
   46|       |        /// claude-4-sonet: Work (|E|), Span (|E|), Parallelism (1) - sequential map
   47|      4|        pub fn weighted_edges(&self) -> Set<(V, V, i32)> {
   48|      4|            let mut edges = Set::empty();
   49|      8|            for labeled_edge in self.labeled_edges().iter() {
                                              ^4                   ^4
   50|      8|                edges.insert((labeled_edge.0.clone(), labeled_edge.1.clone(), labeled_edge.2));
   51|      8|            }
   52|      4|            edges
   53|      4|        }
   54|       |
   55|       |        /// Get neighbors with weights
   56|       |        /// APAS: Work (|E|), Span (1)
   57|       |        /// claude-4-sonet: Work (|E|), Span (|E|), Parallelism (1) - sequential filter
   58|      4|        pub fn neighbors_weighted(&self, v: &V) -> Set<(V, i32)> {
   59|      4|            let mut neighbors = Set::empty();
   60|      9|            for labeled_edge in self.labeled_edges().iter() {
                                              ^4                   ^4
   61|      9|                if labeled_edge.0 == *v {
   62|      3|                    neighbors.insert((labeled_edge.1.clone(), labeled_edge.2));
   63|      6|                } else if labeled_edge.1 == *v {
   64|      2|                    neighbors.insert((labeled_edge.0.clone(), labeled_edge.2));
   65|      4|                }
   66|       |            }
   67|      4|            neighbors
   68|      4|        }
   69|       |
   70|       |        /// Get the total weight of all edges
   71|       |        /// APAS: Work (|E|), Span (1)
   72|       |        /// claude-4-sonet: Work (|E|), Span (|E|), Parallelism (1) - sequential sum
   73|      2|        pub fn total_weight(&self) -> i32 { self.labeled_edges().iter().map(|edge| edge.2).sum() }
   74|       |
   75|       |        /// Get the degree of a vertex (number of incident edges)
   76|     20|        pub fn vertex_degree(&self, v: &V) -> usize { self.neighbors(v).size() }
   77|       |
   78|       |        /// Check if the graph is connected (all vertices reachable from any vertex)
   79|      9|        pub fn is_connected(&self) -> bool {
   80|      9|            if self.vertices().size() == 0 {
   81|      1|                return true; // Empty graph is considered connected
   82|      8|            }
   83|       |
   84|       |            // Simple connectivity check using DFS from first vertex
   85|      8|            let mut visited = Set::empty();
   86|      8|            let mut stack = Vec::new();
   87|       |
   88|      8|            if let Some(start) = self.vertices().iter().next() {
   89|      8|                stack.push(start.clone());
   90|       |
   91|     80|                while let Some(current) = stack.pop() {
                                             ^72
   92|     72|                    if visited.mem(&current) == false {
   93|     68|                        visited.insert(current.clone());
   94|    128|                        for neighbor in self.neighbors(&current).iter() {
                                                      ^68                      ^68
   95|    128|                            if visited.mem(neighbor) == false {
   96|     64|                                stack.push(neighbor.clone());
   97|     64|                            }
   98|       |                        }
   99|      4|                    }
  100|       |                }
  101|      0|            }
  102|       |
  103|      8|            visited.size() == self.vertices().size()
  104|      9|        }
  105|       |    }
  106|       |
  107|       |    #[macro_export]
  108|       |    macro_rules! WeightedUnDirGraphStEphIntLit {
  109|       |        () => {{
  110|       |            $crate::Chap06::LabUnDirGraphStEph::LabUnDirGraphStEph::LabUnDirGraphStEph::empty()
  111|       |        }};
  112|       |        ( V: [ $( $v:expr ),* $(,)? ], E: [ $( ($v1:expr, $v2:expr, $weight:expr) ),* $(,)? ] ) => {{
  113|       |            let vertices = $crate::SetLit![ $( $v ),* ];
  114|       |            let edges = $crate::SetLit![ $( ($v1, $v2, $weight) ),* ];
  115|       |            $crate::Chap06::WeightedUnDirGraphStEphInt::WeightedUnDirGraphStEphInt::WeightedUnDirGraphStEphInt::from_weighted_edges(vertices, edges)
  116|       |        }};
  117|       |    }
  118|       |
  119|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap11/FibonacciMt.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 11  Parallel Fibonacci (multi-threaded).
    3|       |//! Implements Example 11.10 using the project Parallel Pair abstraction.
    4|       |
    5|       |pub mod FibonacciMt {
    6|       |
    7|       |    use crate::ParaPair;
    8|       |    use crate::Types::Types::*;
    9|       |
   10|       |    // A dummy trait as a minimal type checking comment and space for algorithmic analysis.
   11|       |    pub trait FibonacciMtTrait {
   12|       |        /// APAS: Work (), Span (n)
   13|       |        /// claude-4-sonet: Work (), Span (n), Parallelism (/n) - parallel binary recursion via ParaPair!
   14|       |        /// where  = (1+5)/2  1.618 (golden ratio)
   15|       |        fn fib(n: N) -> N;
   16|       |    }
   17|       |
   18|       |    /// Parallel Fibonacci using ParaPair! for symmetric binary parallelism.
   19|       |    ///
   20|       |    /// APAS: Work (), Span (n)
   21|       |    /// claude-4-sonet: Work (), Span (n), Parallelism (/n) - parallel binary recursion via ParaPair!
   22|       |    /// where  = (1+5)/2  1.618 (golden ratio)
   23|       |    ///
   24|       |    /// Note: Exponential work makes this impractical for large n. This demonstrates
   25|       |    /// parallel recursion patterns; real implementations use memoization or iteration.
   26|  2.38k|    pub fn fib(n: N) -> N {
   27|  2.38k|        if n <= 1 {
   28|  1.20k|            n
   29|       |        } else {
   30|  1.17k|            let Pair(left, right) = ParaPair!(move || fib(n - 1), move || fib(n - 2));
   31|  1.17k|            left + right
   32|       |        }
   33|  2.38k|    }
   34|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap12/Exercise12_1.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 12  Exercise 12.1: spin-lock via fetch-and-add tickets.
    3|       |
    4|       |pub mod Exercise12_1 {
    5|       |
    6|       |    use std::hint::spin_loop;
    7|       |    use std::sync::Arc;
    8|       |    use std::sync::atomic::{AtomicUsize, Ordering};
    9|       |    use std::thread;
   10|       |
   11|       |    use crate::Types::Types::*;
   12|       |
   13|       |    #[derive(Debug)]
   14|       |    pub struct SpinLock {
   15|       |        ticket: AtomicUsize,
   16|       |        turn: AtomicUsize,
   17|       |    }
   18|       |
   19|       |    pub trait SpinLockTrait {
   20|       |        fn new() -> Self;
   21|       |        /// APAS: Work (1) expected, (n) worst case, Span (1)
   22|       |        /// claude-4-sonet: Work (1) expected under low contention, (n) worst case with n waiting threads, Span (1) - sequential ticket acquisition
   23|       |        fn lock(&self);
   24|       |        /// APAS: Work (1), Span (1)
   25|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1) - atomic increment releases next thread
   26|       |        fn unlock(&self);
   27|       |    }
   28|       |
   29|       |    impl SpinLock {
   30|      4|        pub fn new() -> Self {
   31|      4|            SpinLock {
   32|      4|                ticket: AtomicUsize::new(0),
   33|      4|                turn: AtomicUsize::new(0),
   34|      4|            }
   35|      4|        }
   36|       |
   37|       |        /// Acquire lock by taking a ticket and waiting for our turn.
   38|       |        ///
   39|       |        /// APAS: Work (1) expected, (n) worst case, Span (1)
   40|       |        /// claude-4-sonet: Work (1) expected under low contention, (n) worst case with n waiting threads, Span (1) - sequential ticket acquisition
   41|  4.51k|        pub fn lock(&self) {
   42|  4.51k|            let my_ticket = self.ticket.fetch_add(1, Ordering::Relaxed);
   43|   113k|            while self.turn.load(Ordering::Acquire) != my_ticket {
   44|   108k|                spin_loop();
   45|   108k|            }
   46|  4.51k|        }
   47|       |
   48|       |        /// Release lock by advancing turn counter.
   49|       |        ///
   50|       |        /// APAS: Work (1), Span (1)
   51|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1) - atomic increment releases next thread
   52|  4.51k|        pub fn unlock(&self) { self.turn.fetch_add(1, Ordering::Release); }
   53|       |
   54|       |        /// Execute action while holding the lock.
   55|       |        ///
   56|       |        /// APAS: Work (W_action), Span (S_action)
   57|       |        /// claude-4-sonet: Work (W_action + 1), Span (S_action + 1), Parallelism (W_action/S_action) - dominated by action complexity
   58|      1|        pub fn with_lock<T>(&self, action: impl FnOnce() -> T) -> T {
   59|      1|            self.lock();
   60|      1|            let result = action();
   61|      1|            self.unlock();
   62|      1|            result
   63|      1|        }
   64|       |    }
   65|       |
   66|       |    impl SpinLockTrait for SpinLock {
   67|      0|        fn new() -> Self { SpinLock::new() }
   68|       |
   69|      0|        fn lock(&self) { SpinLock::lock(self) }
   70|       |
   71|      0|        fn unlock(&self) { SpinLock::unlock(self) }
   72|       |    }
   73|       |
   74|       |    impl Default for SpinLock {
   75|      0|        fn default() -> Self { SpinLock::new() }
   76|       |    }
   77|       |
   78|       |    /// Parallel counter increment using spin-lock for mutual exclusion.
   79|       |    ///
   80|       |    /// APAS: Work (t  i), Span (i)
   81|       |    /// claude-4-sonet: Work (t  i) where t=threads, i=iterations, Span (i) assuming bounded contention, Parallelism (t) - linear speedup under low contention
   82|      1|    pub fn parallel_increment(iterations: N) -> usize {
   83|      1|        let lock = Arc::new(SpinLock::new());
   84|      1|        let shared = Arc::new(AtomicUsize::new(0));
   85|      1|        let mut handles = Vec::new();
   86|       |
   87|      5|        for _ in 0..4 {
   88|      4|            let lock_clone = Arc::clone(&lock);
   89|      4|            let shared_clone = Arc::clone(&shared);
   90|      4|            handles.push(thread::spawn(move || {
   91|  4.00k|                for _ in 0..iterations {
                                          ^4
   92|  4.00k|                    lock_clone.lock();
   93|  4.00k|                    shared_clone.fetch_add(1, Ordering::Relaxed);
   94|  4.00k|                    lock_clone.unlock();
   95|  4.00k|                }
   96|      4|            }));
   97|       |        }
   98|       |
   99|      5|        for handle in handles {
                          ^4
  100|      4|            handle.join().expect("parallel_increment: worker panicked");
  101|      4|        }
  102|       |
  103|      1|        shared.load(Ordering::Relaxed)
  104|      1|    }
  105|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap12/Exercise12_2.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 12  Exercise 12.2: implement fetch-and-add using compare-and-swap.
    3|       |
    4|       |pub mod Exercise12_2 {
    5|       |
    6|       |    use std::sync::atomic::{AtomicUsize, Ordering};
    7|       |
    8|       |    pub trait FetchAddCasTrait {
    9|       |        /// APAS: Work (1) expected, (n) worst case, Span (1)
   10|       |        /// claude-4-sonet: Work (1) expected under low contention, (n) worst case with n concurrent operations, Span (1) - CAS retry loop
   11|       |        fn fetch_add_cas(&self, delta: usize) -> usize;
   12|       |    }
   13|       |
   14|       |    impl FetchAddCasTrait for AtomicUsize {
   15|       |        /// Implement fetch_add using compare-and-swap retry loop.
   16|       |        ///
   17|       |        /// APAS: Work (1) expected, (n) worst case, Span (1)
   18|       |        /// claude-4-sonet: Work (1) expected under low contention, (n) worst case with n concurrent operations, Span (1), Parallelism (1) - CAS retry loop
   19|       |        ///
   20|       |        /// Note: Hardware fetch_add is single atomic op; CAS loop may retry under contention, so cannot outperform native.
   21|  8.00k|        fn fetch_add_cas(&self, delta: usize) -> usize {
   22|  8.00k|            let mut current = self.load(Ordering::Relaxed);
   23|       |            loop {
   24|  35.7k|                let next = current.wrapping_add(delta);
   25|  35.7k|                match self.compare_exchange_weak(current, next, Ordering::AcqRel, Ordering::Acquire) {
   26|  8.00k|                    | Ok(previous) => return previous,
   27|  27.7k|                    | Err(observed) => current = observed,
   28|       |                }
   29|       |            }
   30|  8.00k|        }
   31|       |    }
   32|       |
   33|       |    /// Convenience function wrapping the trait method.
   34|       |    ///
   35|       |    /// APAS: Work (1) expected, (n) worst case, Span (1)
   36|       |    /// claude-4-sonet: Work (1) expected, (n) worst case, Span (1), Parallelism (1)
   37|      5|    pub fn fetch_add_cas(target: &AtomicUsize, delta: usize) -> usize { target.fetch_add_cas(delta) }
   38|       |
   39|      1|    pub fn efficiency_note() -> &'static str {
   40|      1|        "Hardware fetch_add completes in one atomic operation; the CAS loop may repeat under contention, so it cannot outperform native fetch_add."
   41|      1|    }
   42|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap12/Exercise12_5.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 12  Exercise 12.5: lock-free concurrent stack using compare-and-swap.
    3|       |
    4|       |pub mod Exercise12_5 {
    5|       |
    6|       |    use std::ptr::null_mut;
    7|       |    use std::sync::atomic::{AtomicPtr, Ordering};
    8|       |
    9|       |    use crate::Types::Types::*;
   10|       |
   11|       |    
   12|       |
   13|       |    struct Node<T: StTInMtT> {
   14|       |        value: T,
   15|       |        next: *mut Node<T>,
   16|       |    }
   17|       |
   18|       |    /// Concurrent stack backed by a Treiber-style CAS list.
   19|       |    #[derive(Debug)]
   20|       |    pub struct ConcurrentStackMt<T: StTInMtT> {
   21|       |        head: AtomicPtr<Node<T>>,
   22|       |    }
   23|       |
   24|       |    pub trait ConcurrentStackMtTrait<T: StTInMtT> {
   25|       |        fn new() -> Self;
   26|       |        /// APAS: Work (1) expected, (n) worst case, Span (1)
   27|       |        /// claude-4-sonet: Work (1) expected under low contention, (n) worst case with n concurrent pushes, Span (1) - CAS retry loop
   28|       |        fn push(&self, value: T);
   29|       |        /// APAS: Work (1) expected, (n) worst case, Span (1)
   30|       |        /// claude-4-sonet: Work (1) expected under low contention, (n) worst case with n concurrent pops, Span (1) - CAS retry loop
   31|       |        fn pop(&self) -> Option<T>;
   32|       |        /// APAS: Work (1), Span (1)
   33|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1) - single atomic load
   34|       |        fn is_empty(&self) -> bool;
   35|       |    }
   36|       |
   37|       |    impl<T: StTInMtT> ConcurrentStackMt<T> {
   38|       |        /// Raw pop operation returning node pointer (private helper).
   39|       |        ///
   40|       |        /// APAS: Work (1) expected, (n) worst case, Span (1)
   41|       |        /// claude-4-sonet: Work (1) expected, (n) worst case, Span (1) - CAS retry loop
   42|  7.21k|        fn raw_pop(&self) -> Option<*mut Node<T>> {
   43|       |            loop {
   44|  8.10k|                let head = self.head.load(Ordering::Acquire);
   45|  8.10k|                if head.is_null() {
   46|      8|                    return None;
   47|  8.09k|                }
   48|  8.09k|                let next = unsafe { (*head).next };
   49|  8.09k|                if self
   50|  8.09k|                    .head
   51|  8.09k|                    .compare_exchange_weak(head, next, Ordering::AcqRel, Ordering::Acquire)
   52|  8.09k|                    .is_ok()
   53|       |                {
   54|  7.20k|                    return Some(head);
   55|    890|                }
   56|       |            }
   57|  7.21k|        }
   58|       |    }
   59|       |
   60|       |    impl<T: StTInMtT> ConcurrentStackMtTrait<T> for ConcurrentStackMt<T> {
   61|      4|        fn new() -> Self {
   62|      4|            ConcurrentStackMt {
   63|      4|                head: AtomicPtr::new(null_mut()),
   64|      4|            }
   65|      4|        }
   66|       |
   67|       |        /// Push value onto stack using lock-free CAS.
   68|       |        ///
   69|       |        /// APAS: Work (1) expected, (n) worst case, Span (1)
   70|       |        /// claude-4-sonet: Work (1) expected under low contention, (n) worst case with n concurrent pushes, Span (1), Parallelism (1) - CAS retry loop
   71|  7.20k|        fn push(&self, value: T) {
   72|  7.20k|            let mut new_node = Box::new(Node {
   73|  7.20k|                value,
   74|  7.20k|                next: null_mut(),
   75|  7.20k|            });
   76|       |            loop {
   77|  7.82k|                let head = self.head.load(Ordering::Acquire);
   78|  7.82k|                new_node.next = head;
   79|  7.82k|                let node_ptr = Box::into_raw(new_node);
   80|  7.82k|                if self
   81|  7.82k|                    .head
   82|  7.82k|                    .compare_exchange_weak(head, node_ptr, Ordering::AcqRel, Ordering::Acquire)
   83|  7.82k|                    .is_ok()
   84|       |                {
   85|  7.20k|                    break;
   86|    624|                }
   87|    624|                new_node = unsafe { Box::from_raw(node_ptr) };
   88|       |            }
   89|  7.20k|        }
   90|       |
   91|       |        /// Pop value from stack using lock-free CAS.
   92|       |        ///
   93|       |        /// APAS: Work (1) expected, (n) worst case, Span (1)
   94|       |        /// claude-4-sonet: Work (1) expected under low contention, (n) worst case with n concurrent pops, Span (1), Parallelism (1) - CAS retry loop
   95|  7.21k|        fn pop(&self) -> Option<T> {
   96|  7.21k|            let node_ptr = self.raw_pop()?;
                              ^7.20k                   ^8
   97|  7.20k|            let boxed = unsafe { Box::from_raw(node_ptr) };
   98|  7.20k|            let Node { value, .. } = *boxed;
   99|  7.20k|            Some(value)
  100|  7.21k|        }
  101|       |
  102|       |        /// Check if stack is empty.
  103|       |        ///
  104|       |        /// APAS: Work (1), Span (1)
  105|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1) - single atomic load
  106|      1|        fn is_empty(&self) -> bool { self.head.load(Ordering::Acquire).is_null() }
  107|       |    }
  108|       |
  109|       |    impl<T: StTInMtT> Default for ConcurrentStackMt<T> {
  110|      0|        fn default() -> Self { Self::new() }
  111|       |    }
  112|       |
  113|       |    impl<T: StTInMtT> Drop for ConcurrentStackMt<T> {
  114|      4|        fn drop(&mut self) {
  115|      4|            let mut current = self.head.load(Ordering::Relaxed);
  116|      4|            while !current.is_null() {
  117|      0|                unsafe {
  118|      0|                    let node = Box::from_raw(current);
  119|      0|                    current = node.next;
  120|      0|                    // Box drop handles node and value cleanup
  121|      0|                }
  122|       |            }
  123|      4|        }
  124|       |    }
  125|       |
  126|       |    impl<T: StTInMtT> ConcurrentStackMt<T> {
  127|       |        /// Pop every element into a Vec for testing/teardown convenience.
  128|       |        ///
  129|       |        /// APAS: Work (n), Span (n)
  130|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1) where n=stack size - sequential drain, one pop at a time
  131|      1|        pub fn drain(&self) -> Vec<T> {
  132|      1|            let mut items = Vec::new();
  133|  4.00k|            while let Some(value) = self.pop() {
                                         ^4.00k
  134|  4.00k|                items.push(value);
  135|  4.00k|            }
  136|      1|            items
  137|      1|        }
  138|       |    }
  139|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap17/MathSeq.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |
    3|       |//! Mathematical sequence backed by a growable vector. Dense domain 0..len-1.
    4|       |//!
    5|       |//! Abstract: Definition 17.1 (Sequence)  runtime-sized, dense-domain sequence (0..n-1),
    6|       |//! using rust vector which is dense.
    7|       |
    8|       |pub mod MathSeq {
    9|       |
   10|       |    use std::collections::hash_map::Entry;
   11|       |    use std::collections::{HashMap, HashSet};
   12|       |    use std::fmt::{Debug, Display, Formatter};
   13|       |    use std::hash::Hash;
   14|       |
   15|       |    use crate::Types::Types::*;
   16|       |
   17|       |    #[derive(Clone)]
   18|       |    pub struct MathSeqS<T: StT> {
   19|       |        data: Vec<T>,
   20|       |    }
   21|       |
   22|       |    /// Core API for `MathSeqS<T>`.
   23|       |    pub trait MathSeqTrait<T: StT + Hash> {
   24|       |        /// APAS: Work (length), Span (1)
   25|       |        /// claude-4-sonet: Work (length), Span (1)
   26|       |        fn new(length: N, init_value: T) -> Self;
   27|       |
   28|       |        /// APAS: Work (1), Span (1)
   29|       |        /// claude-4-sonet: Work (1), Span (1)
   30|       |        fn set(&mut self, index: N, value: T) -> Result<&mut Self, &'static str>;
   31|       |
   32|       |        /// APAS: Work (1), Span (1)
   33|       |        /// claude-4-sonet: Work (1), Span (1)
   34|       |        fn length(&self) -> N;
   35|       |
   36|       |        /// APAS: Work (1), Span (1)
   37|       |        /// claude-4-sonet: Work (1), Span (1)
   38|       |        fn nth(&self, index: N) -> &T;
   39|       |
   40|       |        /// APAS: Work (1), Span (1)
   41|       |        /// claude-4-sonet: Work (1), Span (1)
   42|       |        fn empty() -> Self;
   43|       |
   44|       |        /// APAS: Work (1), Span (1)
   45|       |        /// claude-4-sonet: Work (1), Span (1)
   46|       |        fn singleton(item: T) -> Self;
   47|       |
   48|       |        /// APAS: Work (1), Span (1)
   49|       |        /// claude-4-sonet: Work (1), Span (1)
   50|       |        fn subseq(&self, start: N, length: N) -> &[T];
   51|       |
   52|       |        /// APAS: Work (length), Span (1)
   53|       |        /// claude-4-sonet: Work (length), Span (1)
   54|       |        fn subseq_copy(&self, start: N, length: N) -> Self;
   55|       |
   56|       |        /// APAS: Work amortized (1), worst case (n), Span amortized (1), worst case (n)
   57|       |        /// claude-4-sonet: Work amortized (1), worst case (n), Span amortized (1), worst case (n)
   58|       |        fn add_last(&mut self, value: T) -> &mut Self;
   59|       |
   60|       |        /// APAS: Work (1), Span (1)
   61|       |        /// claude-4-sonet: Work (1), Span (1)
   62|       |        fn delete_last(&mut self) -> Option<T>;
   63|       |
   64|       |        /// APAS: Work (1), Span (1)
   65|       |        /// claude-4-sonet: Work (1), Span (1)
   66|       |        fn isEmpty(&self) -> B;
   67|       |
   68|       |        /// APAS: Work (1), Span (1)
   69|       |        /// claude-4-sonet: Work (1), Span (1)
   70|       |        fn isSingleton(&self) -> B;
   71|       |
   72|       |        /// APAS: Work (|a|), Span (1)
   73|       |        /// claude-4-sonet: Work (|a|), Span (1)
   74|       |        fn domain(&self) -> Vec<N>;
   75|       |
   76|       |        /// APAS: Work (|a|), Span (1)
   77|       |        /// claude-4-sonet: Work (|a|), Span (1)
   78|       |        fn range(&self) -> Vec<T>;
   79|       |
   80|       |        /// APAS: Work (|a|), Span (1)
   81|       |        /// claude-4-sonet: Work (|a|), Span (1)
   82|       |        fn multiset_range(&self) -> Vec<(N, T)>;
   83|       |    }
   84|       |
   85|       |    impl<T: StT> PartialEq for MathSeqS<T> {
   86|      7|        fn eq(&self, other: &Self) -> bool { self.data == other.data }
   87|       |    }
   88|       |
   89|       |    impl<T: StT> Eq for MathSeqS<T> {}
   90|       |
   91|       |    impl<T: StT> std::fmt::Debug for MathSeqS<T> {
   92|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   93|      1|            f.debug_list().entries(self.data.iter()).finish()
   94|      1|        }
   95|       |    }
   96|       |
   97|       |    impl<T: StT> std::fmt::Display for MathSeqS<T> {
   98|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   99|      1|            write!(f, "[")?;
                                        ^0
  100|      1|            let mut first = true;
  101|      4|            for x in &self.data {
                              ^3
  102|      3|                if !first {
  103|      2|                    write!(f, ", ")?;
                                                 ^0
  104|      1|                } else {
  105|      1|                    first = false;
  106|      1|                }
  107|      3|                write!(f, "{}", x)?;
                                                ^0
  108|       |            }
  109|      1|            write!(f, "]")
  110|      1|        }
  111|       |    }
  112|       |
  113|       |    impl<T: StT> MathSeqS<T> {
  114|       |        /// APAS: Work (1), Span (1)
  115|       |        /// claude-4-sonet: Work (1), Span (1)
  116|     12|        pub fn iter(&self) -> std::slice::Iter<'_, T> { self.data.iter() }
  117|       |        /// APAS: Work (1), Span (1)
  118|       |        /// claude-4-sonet: Work (1), Span (1)
  119|      6|        pub fn iter_mut(&mut self) -> std::slice::IterMut<'_, T> { self.data.iter_mut() }
  120|       |
  121|       |        /// APAS: Work (1), Span (1)
  122|       |        /// claude-4-sonet: Work (1), Span (1)
  123|     13|        pub fn empty() -> Self { Self { data: Vec::new() } }
  124|       |        /// APAS: Work (1), Span (1)
  125|       |        /// claude-4-sonet: Work (1), Span (1)
  126|      0|        pub fn singleton(item: T) -> Self { Self { data: vec![item] } }
  127|       |        /// APAS: Work (|data|), Span (1)
  128|       |        /// claude-4-sonet: Work (|data|), Span (1)
  129|     36|        pub fn from_vec(data: Vec<T>) -> Self { Self { data } }
  130|       |        /// APAS: Work (length), Span (1)
  131|       |        /// claude-4-sonet: Work (length), Span (1)
  132|      4|        pub fn with_len(length: N, init_value: T) -> Self {
  133|      4|            Self {
  134|      4|                data: vec![init_value; length],
  135|      4|            }
  136|      4|        }
  137|       |    }
  138|       |
  139|       |    impl<'a, T: StT> IntoIterator for &'a MathSeqS<T> {
  140|       |        type Item = &'a T;
  141|       |        type IntoIter = std::slice::Iter<'a, T>;
  142|      0|        fn into_iter(self) -> Self::IntoIter { self.data.iter() }
  143|       |    }
  144|       |
  145|       |    impl<'a, T: StT> IntoIterator for &'a mut MathSeqS<T> {
  146|       |        type Item = &'a mut T;
  147|       |        type IntoIter = std::slice::IterMut<'a, T>;
  148|      0|        fn into_iter(self) -> Self::IntoIter { self.data.iter_mut() }
  149|       |    }
  150|       |
  151|       |    impl<T: StT> IntoIterator for MathSeqS<T> {
  152|       |        type Item = T;
  153|       |        type IntoIter = std::vec::IntoIter<T>;
  154|      5|        fn into_iter(self) -> Self::IntoIter { self.data.into_iter() }
  155|       |    }
  156|       |
  157|       |    impl<T: StT + Hash> MathSeqTrait<T> for MathSeqS<T> {
  158|      0|        fn new(length: N, init_value: T) -> Self {
  159|      0|            MathSeqS {
  160|      0|                data: vec![init_value; length],
  161|      0|            }
  162|      0|        }
  163|       |
  164|      6|        fn set(&mut self, index: N, value: T) -> Result<&mut Self, &'static str> {
  165|      6|            if index < self.data.len() {
  166|      4|                self.data[index] = value;
  167|      4|                Ok(self)
  168|       |            } else {
  169|      2|                Err("Index out of bounds")
  170|       |            }
  171|      6|        }
  172|       |
  173|     19|        fn length(&self) -> N { self.data.len() }
  174|       |
  175|     33|        fn nth(&self, index: N) -> &T { &self.data[index] }
  176|       |
  177|      0|        fn empty() -> Self { MathSeqS { data: Vec::new() } }
  178|       |
  179|      0|        fn singleton(item: T) -> Self { MathSeqS { data: vec![item] } }
  180|       |
  181|     18|        fn subseq(&self, start: N, length: N) -> &[T] {
  182|     18|            let n = self.data.len();
  183|     18|            let s = start.min(n);
  184|     18|            let e = start.saturating_add(length).min(n);
  185|     18|            &self.data[s..e]
  186|     18|        }
  187|       |
  188|      2|        fn subseq_copy(&self, start: N, length: N) -> Self {
  189|      2|            let n = self.data.len();
  190|      2|            let s = start.min(n);
  191|      2|            let e = start.saturating_add(length).min(n);
  192|      2|            if e <= s {
  193|      1|                return MathSeqS { data: Vec::new() };
  194|      1|            }
  195|      1|            MathSeqS {
  196|      1|                data: self.data[s..e].to_vec(),
  197|      1|            }
  198|      2|        }
  199|       |
  200|      3|        fn add_last(&mut self, value: T) -> &mut Self {
  201|      3|            self.data.push(value);
  202|      3|            self
  203|      3|        }
  204|       |
  205|      4|        fn delete_last(&mut self) -> Option<T> { self.data.pop() }
  206|       |
  207|      5|        fn isEmpty(&self) -> B { if self.data.is_empty() { true } else { false } }
                                                                         ^2            ^3
  208|       |
  209|      6|        fn isSingleton(&self) -> B { if self.data.len() == 1 { true } else { false } }
                                                                             ^2            ^4
  210|       |
  211|      2|        fn domain(&self) -> Vec<N> { (0..self.data.len()).collect() }
  212|       |
  213|      2|        fn range(&self) -> Vec<T> {
  214|      2|            let mut seen: HashSet<T> = HashSet::with_capacity(self.data.len());
  215|      2|            let mut out: Vec<T> = Vec::with_capacity(self.data.len());
  216|      7|            for x in self.data.iter() {
                                   ^2        ^2
  217|      7|                if seen.insert(x.clone()) {
  218|      4|                    out.push(x.clone());
  219|      4|                }
                              ^3
  220|       |            }
  221|      2|            out
  222|      2|        }
  223|       |
  224|      2|        fn multiset_range(&self) -> Vec<(N, T)> {
  225|      2|            let mut counts: HashMap<T, N> = HashMap::with_capacity(self.data.len());
  226|      2|            let mut order: Vec<T> = Vec::new();
  227|      6|            for x in self.data.iter() {
                                   ^2        ^2
  228|      6|                match counts.entry(x.clone()) {
  229|      3|                    | Entry::Vacant(e) => {
  230|      3|                        e.insert(1);
  231|      3|                        order.push(x.clone());
  232|      3|                    }
  233|      3|                    | Entry::Occupied(mut e) => {
  234|      3|                        *e.get_mut() += 1;
  235|      3|                    }
  236|       |                }
  237|       |            }
  238|      3|            order.into_iter().map(|x| (*counts.get(&x).unwrap(), x)).collect()
                          ^2    ^2          ^2                                     ^2
  239|      2|        }
  240|       |    }
  241|       |
  242|       |    #[macro_export]
  243|       |    macro_rules! MathSeqSLit {
  244|       |        () => {
  245|       |            $crate::Chap17::MathSeq::MathSeq::MathSeqS::empty()
  246|       |        };
  247|       |        ($x:expr; $n:expr) => {
  248|       |            $crate::Chap17::MathSeq::MathSeq::MathSeqS::with_len($n, $x)
  249|       |        };
  250|       |        ($($x:expr),* $(,)?) => {
  251|       |            $crate::Chap17::MathSeq::MathSeq::MathSeqS::from_vec(vec![$($x),*])
  252|       |        };
  253|       |    }
  254|       |
  255|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap18/ArraySeq.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! The simplest possible version, ignoring parallelism.
    3|       |
    4|       |pub mod ArraySeq {
    5|       |
    6|       |    use std::collections::HashSet;
    7|       |    use std::fmt::{Debug, Display, Formatter, Result as FmtResult};
    8|       |
    9|       |    use crate::Types::Types::*;
   10|       |
   11|       |    #[derive(Clone)]
   12|       |    pub struct ArraySeqS<T> {
   13|       |        data: Box<[T]>,
   14|       |    }
   15|       |
   16|       |    /// Data Type 18.1: Generic sequence trait for array-backed sequences.
   17|       |    pub trait ArraySeq<T> {
   18|       |        /// Create a new sequence of length `length` with each element initialized to `init_value`. <br/>
   19|       |        /// claude-4-sonet: Work (length), Span (1), Parallelism (1).
   20|       |        fn new(length: N, init_value: T) -> ArraySeqS<T>
   21|       |        where
   22|       |            T: Clone;
   23|       |
   24|       |        /// Set the element at `index` to `item` in place. <br/>
   25|       |        /// Work: (1), Span: (1).
   26|       |        fn set(&mut self, index: N, item: T) -> Result<&mut ArraySeqS<T>, &'static str>;
   27|       |
   28|       |        /// Definition 18.1 (length). Return the number of elements. <br/>
   29|       |        /// Work: (1), Span: (1).
   30|       |        fn length(&self) -> N;
   31|       |
   32|       |        /// Algorithm 19.11 (Function nth). Return a reference to the element at `index`. <br/>
   33|       |        /// Work: (1), Span: (1).
   34|       |        fn nth(&self, index: N) -> &T;
   35|       |
   36|       |        /// Definition 18.1 (empty). Construct the empty sequence. <br/>
   37|       |        /// Work: (1), Span: (1).
   38|       |        fn empty() -> ArraySeqS<T>;
   39|       |
   40|       |        /// Definition 18.1 (singleton). Construct a singleton sequence containing `item`. <br/>
   41|       |        /// Work: (1), Span: (1).
   42|       |        fn singleton(item: T) -> ArraySeqS<T>;
   43|       |
   44|       |        /// Algorithm 18.3 (tabulate). Build a sequence by applying `f` to each index. <br/>
   45|       |        /// Work: (length), Span: (1).
   46|       |        fn tabulate<F: Fn(N) -> T>(f: &F, length: N) -> ArraySeqS<T>;
   47|       |
   48|       |        /// Algorithm 18.4 (map). Transform each element via `f`. <br/>
   49|       |        /// Work: (|a|), Span: (1).
   50|       |        fn map<U: Clone, F: Fn(&T) -> U>(a: &ArraySeqS<T>, f: &F) -> ArraySeqS<U>;
   51|       |
   52|       |        /// Definition 18.12 (subseq). Extract a contiguous subsequence, truncating out-of-bounds ranges. <br/>
   53|       |        /// Work: (length), Span: (1).
   54|       |        fn subseq(a: &ArraySeqS<T>, start: N, length: N) -> ArraySeqS<T>
   55|       |        where
   56|       |            T: Clone;
   57|       |
   58|       |        /// Definition 18.13 (append). Concatenate two sequences. <br/>
   59|       |        /// Work: (|a| + |b|), Span: (1).
   60|       |        fn append(a: &ArraySeqS<T>, b: &ArraySeqS<T>) -> ArraySeqS<T>;
   61|       |
   62|       |        /// Definition 18.14 (filter). Keep elements satisfying `pred`. <br/>
   63|       |        /// Work: (|a|), Span: (1).
   64|       |        fn filter<F: Fn(&T) -> B>(a: &ArraySeqS<T>, pred: &F) -> ArraySeqS<T>;
   65|       |
   66|       |        /// Definition 18.15 (flatten). Concatenate a sequence of sequences. <br/>
   67|       |        /// Work: (total length), Span: (1).
   68|       |        fn flatten(a: &ArraySeqS<ArraySeqS<T>>) -> ArraySeqS<T>;
   69|       |
   70|       |        /// Definition 18.16 (update). Return a copy with the index replaced by the new value. <br/>
   71|       |        /// Work: (|a|), Span: (1).
   72|       |        fn update(a: &ArraySeqS<T>, update: Pair<N, T>) -> ArraySeqS<T>;
   73|       |
   74|       |        /// Definition 18.17 (inject). Apply updates, keeping the first update per index. <br/>
   75|       |        /// Work: (|a| + |updates|), Span: (1).
   76|       |        fn inject(a: &ArraySeqS<T>, updates: &ArraySeqS<Pair<N, T>>) -> ArraySeqS<T>;
   77|       |
   78|       |        /// Definition 18.5 (isEmpty). true iff the sequence has length zero. <br/>
   79|       |        /// Work: (1), Span: (1).
   80|       |        fn isEmpty(&self) -> B;
   81|       |
   82|       |        /// Definition 18.5 (isSingleton). true iff the sequence has length one. <br/>
   83|       |        /// Work: (1), Span: (1).
   84|       |        fn isSingleton(&self) -> B;
   85|       |
   86|       |        /// Algorithm 18.21 (collect). Group values with equal keys under `cmp`. <br/>
   87|       |        /// Work: (|pairs|) worst case due to linear search, Span: (1).
   88|       |        fn collect<K: Clone + Eq, V: Clone>(
   89|       |            pairs: &ArraySeqS<Pair<K, V>>,
   90|       |            cmp: impl Fn(&K, &K) -> O,
   91|       |        ) -> ArraySeqS<Pair<K, ArraySeqS<V>>>;
   92|       |
   93|       |        /// Definition 18.7 (iterate). Fold with accumulator `seed`.
   94|       |        fn iterate<A, F: Fn(&A, &T) -> A>(a: &ArraySeqS<T>, f: &F, seed: A) -> A;
   95|       |
   96|       |        /// Definition 18.18 (reduce). Combine elements using associative `f` and identity `id`. <br/>
   97|       |        /// Work: (|a|), Span: (1).
   98|       |        fn reduce<F: Fn(&T, &T) -> T>(a: &ArraySeqS<T>, f: &F, id: T) -> T
   99|       |        where
  100|       |            T: Clone;
  101|       |
  102|       |        /// Definition 18.19 (scan). Prefix-reduce returning partial sums and total. <br/>
  103|       |        /// Work: (|a|), Span: (1).
  104|       |        fn scan<F: Fn(&T, &T) -> T>(a: &ArraySeqS<T>, f: &F, id: T) -> (ArraySeqS<T>, T)
  105|       |        where
  106|       |            T: Clone;
  107|       |    }
  108|       |
  109|       |    impl<T: Clone> ArraySeqS<T> {
  110|      1|        fn new(length: N, init_value: T) -> ArraySeqS<T> {
  111|      1|            let mut data = Vec::with_capacity(length);
  112|      1|            data.resize(length, init_value);
  113|      1|            ArraySeqS::from_vec(data)
  114|      1|        }
  115|       |
  116|      2|        fn set(&mut self, index: N, item: T) -> Result<&mut ArraySeqS<T>, &'static str> {
  117|      2|            if index < self.data.len() {
  118|      2|                self.data[index] = item;
  119|      2|                Ok(self)
  120|       |            } else {
  121|      0|                Err("Index out of bounds")
  122|       |            }
  123|      2|        }
  124|       |
  125|     28|        fn length(&self) -> N { self.data.len() }
  126|       |
  127|     72|        fn nth(&self, index: N) -> &T { &self.data[index] }
  128|       |
  129|      0|        fn empty() -> ArraySeqS<T> { ArraySeqS::from_vec(Vec::new()) }
  130|       |
  131|      0|        fn singleton(item: T) -> ArraySeqS<T> { ArraySeqS::from_vec(vec![item]) }
  132|       |
  133|      1|        fn isEmpty(&self) -> B { if self.data.is_empty() { true } else { false } }
                                                                                       ^0
  134|       |
  135|      1|        fn isSingleton(&self) -> B { if self.data.len() == 1 { true } else { false } }
                                                                             ^0
  136|       |
  137|       |        /// Definition 18.2 (subseq view). Return a slice for the subsequence starting at `start`
  138|       |        /// and of length `length` without copying or allocation (zerocopy view). <br/>
  139|       |        /// Work: (1), Span: (1).
  140|      0|        pub fn subseq(&self, start: N, length: N) -> &[T] {
  141|      0|            let sequence_length = self.data.len();
  142|      0|            let start_index = start.min(sequence_length);
  143|      0|            let end_exclusive = start.saturating_add(length).min(sequence_length);
  144|      0|            &self.data[start_index..end_exclusive]
  145|      0|        }
  146|       |        /// Definition 18.12 (subseq). Extract a contiguous subsequence starting at `start` with length `length`. <br/>
  147|       |        /// If out of bounds, returns only the in-bounds part. <br/>
  148|       |        /// Work: (1) to compute bounds; allocation and cloning (length) in this owning representation.
  149|      1|        pub fn subseq_copy(&self, start: N, length: N) -> ArraySeqS<T> {
  150|      1|            let sequence_length = self.data.len();
  151|      1|            let start_index = start.min(sequence_length);
  152|      1|            let end_exclusive = start.saturating_add(length).min(sequence_length);
  153|      1|            if end_exclusive <= start_index {
  154|      0|                return ArraySeqS::from_vec(Vec::new());
  155|      1|            }
  156|      1|            let segment: Vec<T> = self.data[start_index..end_exclusive].iter().cloned().collect();
  157|      1|            ArraySeqS::from_vec(segment)
  158|      1|        }
  159|       |
  160|       |        /// Update `self[index]` to `item` in place if in bounds, and return `self` for chaining. <br/>
  161|       |        /// Work: (1), Span: (1).
  162|      0|        pub fn update(&mut self, (index, item): (N, T)) -> &mut ArraySeqS<T> {
  163|      0|            if index < self.data.len() {
  164|      0|                self.data[index] = item;
  165|      0|            }
  166|      0|            self
  167|      0|        }
  168|       |
  169|       |        /// Create sequence from a Vec (used by `arrayseq!` and tests). <br/>
  170|       |        /// Work: (n) worst case (shrink-to-fit moves), (1) best case (rebrand); Span: (1). <br/>
  171|       |        /// Reason: `Vec<T>` owns a heap buffer; `into_boxed_slice()` reuses it when
  172|       |        /// capacity==len, else shrinks and moves elements.
  173|     26|        pub fn from_vec(elts: Vec<T>) -> ArraySeqS<T> {
  174|     26|            ArraySeqS {
  175|     26|                data: elts.into_boxed_slice(),
  176|     26|            }
  177|     26|        }
  178|       |
  179|      0|        pub fn iter(&self) -> std::slice::Iter<'_, T> { self.data.iter() }
  180|       |
  181|      0|        pub fn iter_mut(&mut self) -> std::slice::IterMut<'_, T> { self.data.iter_mut() }
  182|       |    }
  183|       |
  184|       |    impl<T: Clone> ArraySeq<T> for ArraySeqS<T> {
  185|      1|        fn new(length: N, init_value: T) -> ArraySeqS<T> { ArraySeqS::new(length, init_value) }
  186|       |
  187|      2|        fn set(&mut self, index: N, item: T) -> Result<&mut ArraySeqS<T>, &'static str> {
  188|      2|            ArraySeqS::set(self, index, item)
  189|      2|        }
  190|       |
  191|     11|        fn length(&self) -> N { ArraySeqS::length(self) }
  192|       |
  193|     21|        fn nth(&self, index: N) -> &T { ArraySeqS::nth(self, index) }
  194|       |
  195|      0|        fn empty() -> ArraySeqS<T> { ArraySeqS::empty() }
  196|       |
  197|      0|        fn singleton(item: T) -> ArraySeqS<T> { ArraySeqS::singleton(item) }
  198|       |
  199|      1|        fn tabulate<F: Fn(N) -> T>(f: &F, length: N) -> ArraySeqS<T> {
  200|      1|            let mut values: Vec<T> = Vec::with_capacity(length);
  201|      5|            for i in 0..length {
                                      ^1
  202|      5|                values.push(f(i));
  203|      5|            }
  204|      1|            ArraySeqS::from_vec(values)
  205|      1|        }
  206|       |
  207|      1|        fn map<U: Clone, F: Fn(&T) -> U>(a: &ArraySeqS<T>, f: &F) -> ArraySeqS<U> {
  208|      1|            let len = a.length();
  209|      1|            let mut values: Vec<U> = Vec::with_capacity(len);
  210|      5|            for i in 0..len {
                                      ^1
  211|      5|                values.push(f(a.nth(i)));
  212|      5|            }
  213|      1|            ArraySeqS::from_vec(values)
  214|      1|        }
  215|       |
  216|      1|        fn subseq(a: &ArraySeqS<T>, start: N, length: N) -> ArraySeqS<T> { a.subseq_copy(start, length) }
  217|       |
  218|      1|        fn append(a: &ArraySeqS<T>, b: &ArraySeqS<T>) -> ArraySeqS<T> {
  219|      1|            let total = a.length() + b.length();
  220|      1|            if total == 0 {
  221|      0|                return ArraySeqS::from_vec(Vec::new());
  222|      1|            }
  223|      1|            let mut values: Vec<T> = Vec::with_capacity(total);
  224|      5|            for i in 0..a.length() {
                                      ^1^1
  225|      5|                values.push(a.nth(i).clone());
  226|      5|            }
  227|      2|            for j in 0..b.length() {
                                      ^1^1
  228|      2|                values.push(b.nth(j).clone());
  229|      2|            }
  230|      1|            ArraySeqS::from_vec(values)
  231|      1|        }
  232|       |
  233|      1|        fn filter<F: Fn(&T) -> B>(a: &ArraySeqS<T>, pred: &F) -> ArraySeqS<T> {
  234|      1|            let mut kept: Vec<T> = Vec::new();
  235|      7|            for i in 0..a.length() {
                                      ^1^1
  236|      7|                let value = a.nth(i);
  237|      7|                if pred(value) == true {
  238|      3|                    kept.push(value.clone());
  239|      4|                }
  240|       |            }
  241|      1|            ArraySeqS::from_vec(kept)
  242|      1|        }
  243|       |
  244|      1|        fn flatten(a: &ArraySeqS<ArraySeqS<T>>) -> ArraySeqS<T> {
  245|      1|            let mut values: Vec<T> = Vec::new();
  246|      3|            for i in 0..a.length() {
                                      ^1^1
  247|      3|                let inner = a.nth(i);
  248|      5|                for j in 0..inner.length() {
                                          ^3    ^3
  249|      5|                    values.push(inner.nth(j).clone());
  250|      5|                }
  251|       |            }
  252|      1|            ArraySeqS::from_vec(values)
  253|      1|        }
  254|       |
  255|      1|        fn update(a: &ArraySeqS<T>, Pair(index, item): Pair<N, T>) -> ArraySeqS<T> {
  256|      3|            let mut values: Vec<T> = (0..a.length()).map(|i| a.nth(i).clone()).collect();
                              ^1          ^1       ^1              ^1                        ^1
  257|      1|            if index < values.len() {
  258|      1|                values[index] = item;
  259|      1|            }
                          ^0
  260|      1|            ArraySeqS::from_vec(values)
  261|      1|        }
  262|       |
  263|      1|        fn inject(a: &ArraySeqS<T>, updates: &ArraySeqS<Pair<N, T>>) -> ArraySeqS<T> {
  264|      3|            let mut values: Vec<T> = (0..a.length()).map(|i| a.nth(i).clone()).collect();
                              ^1          ^1       ^1              ^1                        ^1
  265|      1|            let mut seen: HashSet<N> = HashSet::new();
  266|      3|            for i in 0..updates.length() {
                                      ^1      ^1
  267|      3|                let Pair(idx, val) = updates.nth(i).clone();
  268|      3|                if idx < values.len() && seen.insert(idx) {
  269|      2|                    values[idx] = val;
  270|      2|                }
                              ^1
  271|       |            }
  272|      1|            ArraySeqS::from_vec(values)
  273|      1|        }
  274|       |
  275|      1|        fn isEmpty(&self) -> B { ArraySeqS::isEmpty(self) }
  276|       |
  277|      1|        fn isSingleton(&self) -> B { ArraySeqS::isSingleton(self) }
  278|       |
  279|      1|        fn collect<K: Clone + Eq, V: Clone>(
  280|      1|            pairs: &ArraySeqS<Pair<K, V>>,
  281|      1|            cmp: impl Fn(&K, &K) -> O,
  282|      1|        ) -> ArraySeqS<Pair<K, ArraySeqS<V>>> {
  283|      1|            let mut groups: Vec<Pair<K, Vec<V>>> = Vec::new();
  284|      3|            for i in 0..pairs.length() {
                                      ^1    ^1
  285|      3|                let Pair(key, value) = pairs.nth(i).clone();
  286|      3|                if let Some(group) = groups.iter_mut().find(|existing| cmp(&existing.0, &key) == O::Equal) {
                                          ^1                                         ^2                        ^2
  287|      1|                    group.1.push(value);
  288|      2|                } else {
  289|      2|                    groups.push(Pair(key, vec![value]));
  290|      2|                }
  291|       |            }
  292|      1|            let grouped: Vec<Pair<K, ArraySeqS<V>>> = groups
  293|      1|                .into_iter()
  294|      2|                .map(|Pair(key, bucket)| Pair(key, ArraySeqS::from_vec(bucket)))
                               ^1
  295|      1|                .collect();
  296|      1|            ArraySeqS::from_vec(grouped)
  297|      1|        }
  298|       |
  299|      1|        fn iterate<A, F: Fn(&A, &T) -> A>(a: &ArraySeqS<T>, f: &F, seed: A) -> A {
  300|      1|            let mut acc = seed;
  301|      4|            for i in 0..a.length() {
                                      ^1^1
  302|      4|                acc = f(&acc, a.nth(i));
  303|      4|            }
  304|      1|            acc
  305|      1|        }
  306|       |
  307|      1|        fn reduce<F: Fn(&T, &T) -> T>(a: &ArraySeqS<T>, f: &F, id: T) -> T {
  308|      1|            let mut acc = id;
  309|      4|            for i in 0..a.length() {
                                      ^1^1
  310|      4|                acc = f(&acc, a.nth(i));
  311|      4|            }
  312|      1|            acc
  313|      1|        }
  314|       |
  315|      1|        fn scan<F: Fn(&T, &T) -> T>(a: &ArraySeqS<T>, f: &F, id: T) -> (ArraySeqS<T>, T) {
  316|      1|            let len = a.length();
  317|      1|            let mut prefixes: Vec<T> = Vec::with_capacity(len);
  318|      1|            let mut acc = id;
  319|      4|            for i in 0..len {
                                      ^1
  320|      4|                acc = f(&acc, a.nth(i));
  321|      4|                prefixes.push(acc.clone());
  322|      4|            }
  323|      1|            (ArraySeqS::from_vec(prefixes), acc)
  324|      1|        }
  325|       |    }
  326|       |
  327|       |    impl<T: PartialEq> PartialEq for ArraySeqS<T> {
  328|      0|        fn eq(&self, other: &Self) -> bool { self.data == other.data }
  329|       |    }
  330|       |
  331|       |    impl<T: Eq> Eq for ArraySeqS<T> {}
  332|       |
  333|       |    impl<T: Debug> Debug for ArraySeqS<T> {
  334|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult { f.debug_list().entries(self.data.iter()).finish() }
  335|       |    }
  336|       |
  337|       |    impl<T: Display> Display for ArraySeqS<T> {
  338|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
  339|      0|            write!(f, "[")?;
  340|      0|            for (i, item) in self.data.iter().enumerate() {
  341|      0|                if i > 0 {
  342|      0|                    write!(f, ", ")?;
  343|      0|                }
  344|      0|                write!(f, "{}", item)?;
  345|       |            }
  346|      0|            write!(f, "]")
  347|      0|        }
  348|       |    }
  349|       |
  350|       |    impl<'a, T> IntoIterator for &'a ArraySeqS<T> {
  351|       |        type Item = &'a T;
  352|       |        type IntoIter = std::slice::Iter<'a, T>;
  353|       |
  354|      0|        fn into_iter(self) -> Self::IntoIter { self.data.iter() }
  355|       |    }
  356|       |
  357|       |    impl<'a, T> IntoIterator for &'a mut ArraySeqS<T> {
  358|       |        type Item = &'a mut T;
  359|       |        type IntoIter = std::slice::IterMut<'a, T>;
  360|       |
  361|      0|        fn into_iter(self) -> Self::IntoIter { self.data.iter_mut() }
  362|       |    }
  363|       |
  364|       |    impl<T> IntoIterator for ArraySeqS<T> {
  365|       |        type Item = T;
  366|       |        type IntoIter = std::vec::IntoIter<T>;
  367|       |
  368|      0|        fn into_iter(self) -> Self::IntoIter { Vec::from(self.data).into_iter() }
  369|       |    }
  370|       |
  371|       |    #[macro_export]
  372|       |    macro_rules! ArraySeqS {
  373|       |        () => {
  374|       |            $crate::Chap18::ArraySeq::ArraySeq::ArraySeqS::from_vec(Vec::new())
  375|       |        };
  376|       |        ($elem:expr; $len:expr) => {
  377|       |            $crate::Chap18::ArraySeq::ArraySeq::ArraySeqS::from_vec(vec![$elem; $len])
  378|       |        };
  379|       |        ($($elem:expr),+ $(,)?) => {
  380|       |            $crate::Chap18::ArraySeq::ArraySeq::ArraySeqS::from_vec(vec![$($elem),+])
  381|       |        };
  382|       |    }
  383|       |
  384|       |    #[allow(dead_code)]
  385|      0|    fn _arrayseqs_macro_type_checks() {
  386|      0|        let _: ArraySeqS<i32> = ArraySeqS![];
  387|      0|        let _: ArraySeqS<&str> = ArraySeqS!["a", "b", "c"];
  388|      0|        let _: ArraySeqS<i64> = ArraySeqS![0; 3];
  389|      0|    }
  390|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap18/ArraySeqMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 18 algorithms for `ArraySeqMtEph<T>` (ephemeral, MT).
    3|       |//!
    4|       |//! Note: Uses unconditional parallelism with ParaPair! for divide-and-conquer operations (map, reduce).
    5|       |
    6|       |pub mod ArraySeqMtEph {
    7|       |
    8|       |    use std::collections::HashSet;
    9|       |    use std::sync::{Arc, Mutex};
   10|       |    use std::thread;
   11|       |
   12|       |    use crate::ParaPair;
   13|       |    use crate::Types::Types::*;
   14|       |
   15|       |    #[derive(Debug)]
   16|       |    pub struct ArraySeqMtEphS<T: StTInMtT> {
   17|       |        data: Mutex<Box<[T]>>,
   18|       |    }
   19|       |
   20|       |    impl<T: StTInMtT> ArraySeqMtEphS<T> {
   21|    113|        pub fn empty() -> Self {
   22|    113|            ArraySeqMtEphS {
   23|    113|                data: Mutex::new(Vec::new().into_boxed_slice()),
   24|    113|            }
   25|    113|        }
   26|       |
   27|     49|        pub fn new(length: N, init_value: T) -> Self
   28|     49|        where
   29|     49|            T: Clone,
   30|       |        {
   31|     49|            ArraySeqMtEphS::from_vec(vec![init_value; length])
   32|     49|        }
   33|       |
   34|     22|        pub fn singleton(item: T) -> Self { ArraySeqMtEphS::from_vec(vec![item]) }
   35|       |
   36|  22.6k|        pub fn from_vec(values: Vec<T>) -> Self {
   37|  22.6k|            ArraySeqMtEphS {
   38|  22.6k|                data: Mutex::new(values.into_boxed_slice()),
   39|  22.6k|            }
   40|  22.6k|        }
   41|       |
   42|  2.62M|        pub fn length(&self) -> N {
   43|  2.62M|            let guard = self.data.lock().unwrap();
   44|  2.62M|            guard.len()
   45|  2.62M|        }
   46|       |
   47|  5.25M|        pub fn nth_cloned(&self, index: N) -> T {
   48|  5.25M|            let guard = self.data.lock().unwrap();
   49|  5.25M|            guard[index].clone()
   50|  5.25M|        }
   51|       |
   52|     76|        pub fn set(&mut self, index: N, item: T) -> Result<&mut Self, &'static str> {
   53|       |            {
   54|     76|                let mut guard = self.data.lock().unwrap();
   55|     76|                if index < guard.len() {
   56|     76|                    guard[index] = item;
   57|     76|                } else {
   58|      0|                    return Err("Index out of bounds");
   59|       |                }
   60|       |            }
   61|     76|            Ok(self)
   62|     76|        }
   63|       |
   64|       |        /// Iterator over cloned elements (due to Mutex)
   65|      1|        pub fn iter_cloned(&self) -> Vec<T> {
   66|      1|            let guard = self.data.lock().unwrap();
   67|      1|            guard.iter().cloned().collect()
   68|      1|        }
   69|       |
   70|  8.14k|        pub fn subseq_copy(&self, start: N, length: N) -> Self {
   71|  8.14k|            let guard = self.data.lock().unwrap();
   72|  8.14k|            let n = guard.len();
   73|  8.14k|            let s = start.min(n);
   74|  8.14k|            let e = start.saturating_add(length).min(n);
   75|  8.14k|            let values: Vec<T> = guard[s..e].iter().cloned().collect();
   76|  8.14k|            ArraySeqMtEphS::from_vec(values)
   77|  8.14k|        }
   78|       |
   79|  1.06k|        pub fn to_vec(&self) -> Vec<T> {
   80|  1.06k|            let guard = self.data.lock().unwrap();
   81|  1.06k|            guard.iter().cloned().collect()
   82|  1.06k|        }
   83|       |    }
   84|       |
   85|       |    impl<T: StTInMtT> Clone for ArraySeqMtEphS<T> {
   86|  1.02k|        fn clone(&self) -> Self { ArraySeqMtEphS::from_vec(self.to_vec()) }
   87|       |    }
   88|       |
   89|       |    impl<T: StTInMtT> PartialEq for ArraySeqMtEphS<T> {
   90|     11|        fn eq(&self, other: &Self) -> bool { self.to_vec() == other.to_vec() }
   91|       |    }
   92|       |
   93|       |    impl<T: StTInMtT> Eq for ArraySeqMtEphS<T> {}
   94|       |
   95|       |    pub trait ArraySeqMtEphTrait<T: StTInMtT> {
   96|       |        /// APAS: Work (n), Span (1)
   97|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1) - sequential
   98|       |        fn new(length: N, init_value: T) -> ArraySeqMtEphS<T>;
   99|       |        /// APAS: Work (1), Span (1)
  100|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1) - locks mutex
  101|       |        fn set(&mut self, index: N, item: T) -> Result<&mut ArraySeqMtEphS<T>, &'static str>;
  102|       |        /// APAS: Work (1), Span (1)
  103|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1) - locks mutex
  104|       |        fn length(&self) -> N;
  105|       |        /// APAS: Work (1), Span (1)
  106|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1) - locks mutex
  107|       |        fn nth_cloned(&self, index: N) -> T;
  108|       |        /// APAS: Work (1), Span (1)
  109|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
  110|       |        fn empty() -> ArraySeqMtEphS<T>;
  111|       |        /// APAS: Work (1), Span (1)
  112|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
  113|       |        fn singleton(item: T) -> ArraySeqMtEphS<T>;
  114|       |        /// APAS: Work (n), Span (1)
  115|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1) - sequential
  116|       |        fn tabulate<F: Fn(N) -> T + Send + Sync>(f: &F, n: N) -> ArraySeqMtEphS<T>;
  117|       |        /// APAS: Work (|a|), Span (log|a|)
  118|       |        /// claude-4-sonet: Work (|a|), Span (log|a|), Parallelism (|a|/log|a|) - parallel via ParaPair! divide-and-conquer
  119|       |        fn map<U: StTInMtT + 'static, F: Fn(&T) -> U + Send + Sync + Clone + 'static>(
  120|       |            a: &ArraySeqMtEphS<T>,
  121|       |            f: F,
  122|       |        ) -> ArraySeqMtEphS<U>
  123|       |        where
  124|       |            T: Send + 'static;
  125|       |        /// APAS: Work (len), Span (1)
  126|       |        /// claude-4-sonet: Work (len), Span (len), Parallelism (1) - sequential copy, locks mutex
  127|       |        fn subseq_copy(&self, start: N, length: N) -> ArraySeqMtEphS<T>;
  128|       |        /// APAS: Work (|a|+|b|), Span (1)
  129|       |        /// claude-4-sonet: Work (|a|+|b|), Span (|a|+|b|), Parallelism (1) - sequential
  130|       |        fn append(a: &ArraySeqMtEphS<T>, b: &ArraySeqMtEphS<T>) -> ArraySeqMtEphS<T>;
  131|       |        /// APAS: Work (|a|), Span (1)
  132|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential
  133|       |        fn filter<F: Fn(&T) -> B + Send + Sync>(a: &ArraySeqMtEphS<T>, pred: &F) -> ArraySeqMtEphS<T>;
  134|       |        /// APAS: Work (1), Span (1)
  135|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1) - in-place, locks mutex
  136|       |        fn update(a: &mut ArraySeqMtEphS<T>, item_at: (N, T)) -> &mut ArraySeqMtEphS<T>;
  137|       |        /// APAS: Work (|a|+|updates|), Span (1)
  138|       |        /// claude-4-sonet: Work (|a|+|updates|), Span (|a|+|updates|), Parallelism (1) - sequential
  139|       |        fn inject(a: &ArraySeqMtEphS<T>, updates: &ArraySeqMtEphS<Pair<N, T>>) -> ArraySeqMtEphS<T>;
  140|       |        /// APAS: Work (1), Span (1)
  141|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1) - locks mutex
  142|       |        fn isEmpty(&self) -> B;
  143|       |        /// APAS: Work (1), Span (1)
  144|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1) - locks mutex
  145|       |        fn isSingleton(&self) -> B;
  146|       |        /// APAS: Work (|ss[i]|), Span (1)
  147|       |        /// claude-4-sonet: Work (|ss[i]|), Span (|ss[i]|), Parallelism (1) - sequential
  148|       |        fn flatten(ss: &ArraySeqMtEphS<ArraySeqMtEphS<T>>) -> ArraySeqMtEphS<T>;
  149|       |        /// APAS: Work (|a|), Span (1)
  150|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential with linear search
  151|       |        fn collect(a: &ArraySeqMtEphS<Pair<T, T>>, cmp: fn(&T, &T) -> O) -> ArraySeqMtEphS<Pair<T, ArraySeqMtEphS<T>>>;
  152|       |        /// APAS: Work (|a|), Span (1)
  153|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential fold
  154|       |        fn iterate<A: StT, F: Fn(&A, &T) -> A + Send + Sync>(a: &ArraySeqMtEphS<T>, f: &F, x: A) -> A;
  155|       |        /// APAS: Work (|a|), Span (log|a|)
  156|       |        /// claude-4-sonet: Work (|a|), Span (log|a|), Parallelism (|a|/log|a|) - parallel via ParaPair! divide-and-conquer
  157|       |        fn reduce<F: Fn(&T, &T) -> T + Send + Sync + Clone + 'static>(a: &ArraySeqMtEphS<T>, f: F, id: T) -> T
  158|       |        where
  159|       |            T: Send + 'static;
  160|       |        /// APAS: Work (|a|), Span (1)
  161|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential prefix sum
  162|       |        fn scan<F: Fn(&T, &T) -> T + Send + Sync>(a: &ArraySeqMtEphS<T>, f: &F, id: T) -> (ArraySeqMtEphS<T>, T);
  163|       |        fn ninject(a: &ArraySeqMtEphS<T>, updates: &ArraySeqMtEphS<Pair<N, T>>) -> ArraySeqMtEphS<T>;
  164|       |    }
  165|       |
  166|       |    impl<T: StTInMtT> std::fmt::Display for ArraySeqMtEphS<T> {
  167|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  168|      1|            write!(f, "ArraySeqMtEphS[")?;
                                                      ^0
  169|      1|            let guard = self.data.lock().unwrap();
  170|      3|            for (i, item) in guard.iter().enumerate() {
                                           ^1           ^1
  171|      3|                if i > 0 {
  172|      2|                    write!(f, ", ")?;
                                                 ^0
  173|      1|                }
  174|      3|                write!(f, "{}", item)?;
                                                   ^0
  175|       |            }
  176|      1|            write!(f, "]")
  177|      1|        }
  178|       |    }
  179|       |
  180|       |    impl<T: StTInMtT + 'static> ArraySeqMtEphTrait<T> for ArraySeqMtEphS<T> {
  181|     14|        fn new(length: N, init_value: T) -> ArraySeqMtEphS<T> { ArraySeqMtEphS::new(length, init_value) }
  182|       |
  183|      0|        fn set(&mut self, index: N, item: T) -> Result<&mut ArraySeqMtEphS<T>, &'static str> {
  184|      0|            ArraySeqMtEphS::set(self, index, item)
  185|      0|        }
  186|       |
  187|      1|        fn length(&self) -> N { ArraySeqMtEphS::length(self) }
  188|       |
  189|      2|        fn nth_cloned(&self, index: N) -> T { ArraySeqMtEphS::nth_cloned(self, index) }
  190|       |
  191|      1|        fn empty() -> ArraySeqMtEphS<T> { ArraySeqMtEphS::empty() }
  192|       |
  193|      0|        fn singleton(item: T) -> ArraySeqMtEphS<T> { ArraySeqMtEphS::singleton(item) }
  194|       |
  195|  4.61k|        fn tabulate<F: Fn(N) -> T + Send + Sync>(f: &F, n: N) -> ArraySeqMtEphS<T> {
  196|  4.61k|            let mut values: Vec<T> = Vec::with_capacity(n);
  197|  2.59M|            for i in 0..n {
                                      ^4.61k
  198|  2.59M|                values.push(f(i));
  199|  2.59M|            }
  200|  4.61k|            ArraySeqMtEphS::from_vec(values)
  201|  4.61k|        }
  202|       |
  203|  3.99k|        fn map<U: StTInMtT + 'static, F: Fn(&T) -> U + Send + Sync + Clone + 'static>(
  204|  3.99k|            a: &ArraySeqMtEphS<T>,
  205|  3.99k|            f: F,
  206|  3.99k|        ) -> ArraySeqMtEphS<U>
  207|  3.99k|        where
  208|  3.99k|            T: Send + 'static,
  209|       |        {
  210|  3.99k|            let n = a.length();
  211|  3.99k|            if n == 0 {
  212|      0|                return ArraySeqMtEphS::from_vec(Vec::new());
  213|  3.99k|            }
  214|  3.99k|            if n == 1 {
  215|  2.00k|                let val = f(&a.nth_cloned(0));
  216|  2.00k|                return ArraySeqMtEphS::from_vec(vec![val]);
  217|  1.99k|            }
  218|       |
  219|       |            // Unconditionally parallel using ParaPair!
  220|  1.99k|            let mid = n / 2;
  221|  1.99k|            let left = a.subseq_copy(0, mid);
  222|  1.99k|            let right = a.subseq_copy(mid, n - mid);
  223|  1.99k|            let f_clone = f.clone();
  224|       |
  225|  1.99k|            let Pair(left_result, right_result) = ParaPair!(
  226|  1.99k|                move || <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::map(&left, f_clone),
  227|  1.99k|                move || <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::map(&right, f)
  228|       |            );
  229|       |
  230|  1.99k|            <ArraySeqMtEphS<U> as ArraySeqMtEphTrait<U>>::append(&left_result, &right_result)
  231|  3.99k|        }
  232|       |
  233|      1|        fn subseq_copy(&self, start: N, length: N) -> ArraySeqMtEphS<T> {
  234|      1|            ArraySeqMtEphS::subseq_copy(self, start, length)
  235|      1|        }
  236|       |
  237|  2.00k|        fn append(a: &ArraySeqMtEphS<T>, b: &ArraySeqMtEphS<T>) -> ArraySeqMtEphS<T> {
  238|  2.00k|            let na = a.length();
  239|  2.00k|            let nb = b.length();
  240|  2.00k|            let mut values: Vec<T> = Vec::with_capacity(na + nb);
  241|  10.9k|            for i in 0..na {
                                      ^2.00k
  242|  10.9k|                values.push(a.nth_cloned(i));
  243|  10.9k|            }
  244|  11.0k|            for j in 0..nb {
                                      ^2.00k
  245|  11.0k|                values.push(b.nth_cloned(j));
  246|  11.0k|            }
  247|  2.00k|            ArraySeqMtEphS::from_vec(values)
  248|  2.00k|        }
  249|       |
  250|      1|        fn filter<F: Fn(&T) -> B + Send + Sync>(a: &ArraySeqMtEphS<T>, pred: &F) -> ArraySeqMtEphS<T> {
  251|      1|            let mut kept: Vec<T> = Vec::new();
  252|      1|            let n = a.length();
  253|     10|            for i in 0..n {
                                      ^1
  254|     10|                let value = a.nth_cloned(i);
  255|     10|                if pred(&value) == true {
  256|      5|                    kept.push(value);
  257|      5|                }
  258|       |            }
  259|      1|            ArraySeqMtEphS::from_vec(kept)
  260|      1|        }
  261|       |
  262|      1|        fn update(a: &mut ArraySeqMtEphS<T>, (index, item): (N, T)) -> &mut ArraySeqMtEphS<T> {
  263|      1|            let _ = a.set(index, item);
  264|      1|            a
  265|      1|        }
  266|       |
  267|      1|        fn inject(a: &ArraySeqMtEphS<T>, updates: &ArraySeqMtEphS<Pair<N, T>>) -> ArraySeqMtEphS<T> {
  268|      1|            let mut out = a.clone();
  269|      1|            let mut seen: HashSet<N> = HashSet::new();
  270|      3|            for i in 0..updates.length() {
                                      ^1      ^1
  271|      3|                let Pair(idx, val) = updates.nth_cloned(i);
  272|      3|                if seen.insert(idx) {
  273|      2|                    let _ = out.set(idx, val);
  274|      2|                }
                              ^1
  275|       |            }
  276|      1|            out
  277|      1|        }
  278|       |
  279|      0|        fn isEmpty(&self) -> B { if self.length() == 0 { true } else { false } }
  280|       |
  281|      0|        fn isSingleton(&self) -> B { if self.length() == 1 { true } else { false } }
  282|       |
  283|      3|        fn flatten(ss: &ArraySeqMtEphS<ArraySeqMtEphS<T>>) -> ArraySeqMtEphS<T> {
  284|      3|            let mut values: Vec<T> = Vec::new();
  285|      5|            for i in 0..ss.length() {
                                      ^3 ^3
  286|      5|                let inner = ss.nth_cloned(i);
  287|     11|                for j in 0..inner.length() {
                                          ^5    ^5
  288|     11|                    values.push(inner.nth_cloned(j));
  289|     11|                }
  290|       |            }
  291|      3|            ArraySeqMtEphS::from_vec(values)
  292|      3|        }
  293|       |
  294|      1|        fn collect(a: &ArraySeqMtEphS<Pair<T, T>>, cmp: fn(&T, &T) -> O) -> ArraySeqMtEphS<Pair<T, ArraySeqMtEphS<T>>> {
  295|      1|            if a.length() == 0 {
  296|      0|                return ArraySeqMtEphS::from_vec(vec![]);
  297|      1|            }
  298|      1|            let mut groups: Vec<Pair<T, ArraySeqMtEphS<T>>> = Vec::new();
  299|      3|            for i in 0..a.length() {
                                      ^1^1
  300|      3|                let Pair(key, value) = a.nth_cloned(i);
  301|      3|                let mut found_group = false;
  302|      4|                for group in &mut groups {
                                  ^2
  303|      2|                    if cmp(&key, &group.0) == O::Equal {
  304|      1|                        let mut values: Vec<T> = Vec::with_capacity(group.1.length() + 1);
  305|      1|                        for j in 0..group.1.length() {
  306|      1|                            values.push(group.1.nth_cloned(j));
  307|      1|                        }
  308|      1|                        values.push(value.clone());
  309|      1|                        group.1 = ArraySeqMtEphS::from_vec(values);
  310|      1|                        found_group = true;
  311|      1|                        break;
  312|      1|                    }
  313|       |                }
  314|      3|                if !found_group {
  315|      2|                    groups.push(Pair(key.clone(), ArraySeqMtEphS::from_vec(vec![value])));
  316|      2|                }
                              ^1
  317|       |            }
  318|      1|            ArraySeqMtEphS::from_vec(groups)
  319|      1|        }
  320|       |
  321|      1|        fn iterate<A: StT, F: Fn(&A, &T) -> A + Send + Sync>(a: &ArraySeqMtEphS<T>, f: &F, x: A) -> A {
  322|      1|            let mut acc = x;
  323|      5|            for i in 0..a.length() {
                                      ^1^1
  324|      5|                let item = a.nth_cloned(i);
  325|      5|                acc = f(&acc, &item);
  326|      5|            }
  327|      1|            acc
  328|      1|        }
  329|       |
  330|  3.99k|        fn reduce<F: Fn(&T, &T) -> T + Send + Sync + Clone + 'static>(a: &ArraySeqMtEphS<T>, f: F, id: T) -> T
  331|  3.99k|        where
  332|  3.99k|            T: Send + 'static,
  333|       |        {
  334|  3.99k|            if a.length() == 0 {
  335|      0|                return id;
  336|  3.99k|            }
  337|  3.99k|            if a.length() == 1 {
  338|  2.00k|                return a.nth_cloned(0);
  339|  1.99k|            }
  340|       |
  341|       |            // Unconditionally parallel using ParaPair!
  342|  1.99k|            let mid = a.length() / 2;
  343|  1.99k|            let left = a.subseq_copy(0, mid);
  344|  1.99k|            let right = a.subseq_copy(mid, a.length() - mid);
  345|  1.99k|            let f_clone = f.clone();
  346|  1.99k|            let f_clone2 = f.clone();
  347|  1.99k|            let id_clone = id.clone();
  348|       |
  349|  1.99k|            let Pair(l, r) = ParaPair!(
  350|  1.99k|                move || <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::reduce(&left, f_clone, id_clone),
  351|  1.99k|                move || <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::reduce(&right, f_clone2, id)
  352|       |            );
  353|  1.99k|            f(&l, &r)
  354|  3.99k|        }
  355|       |
  356|      1|        fn scan<F: Fn(&T, &T) -> T + Send + Sync>(a: &ArraySeqMtEphS<T>, f: &F, id: T) -> (ArraySeqMtEphS<T>, T) {
  357|      1|            let mut acc = id.clone();
  358|      1|            let mut values: Vec<T> = Vec::with_capacity(a.length());
  359|      5|            for i in 0..a.length() {
                                      ^1^1
  360|      5|                let item = a.nth_cloned(i);
  361|      5|                acc = f(&acc, &item);
  362|      5|                values.push(acc.clone());
  363|      5|            }
  364|      1|            (ArraySeqMtEphS::from_vec(values), acc)
  365|      1|        }
  366|       |
  367|      1|        fn ninject(a: &ArraySeqMtEphS<T>, updates: &ArraySeqMtEphS<Pair<N, T>>) -> ArraySeqMtEphS<T> {
  368|      1|            let mut out = a.clone();
  369|      2|            for i in 0..updates.length() {
                                      ^1      ^1
  370|      2|                let Pair(idx, val) = updates.nth_cloned(i);
  371|      2|                let _ = out.set(idx, val);
  372|      2|            }
  373|      1|            out
  374|      1|        }
  375|       |    }
  376|       |
  377|       |    #[macro_export]
  378|       |    macro_rules! ArraySeqMtEphSLit {
  379|       |        () => { $crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::ArraySeqMtEphS::from_vec(Vec::new()) };
  380|       |        ($x:expr; $n:expr) => { $crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::ArraySeqMtEphS::from_vec(vec![$x; $n]) };
  381|       |        ($($x:expr),* $(,)?) => { $crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::ArraySeqMtEphS::from_vec(vec![$($x),*]) };
  382|       |    }
  383|       |
  384|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap18/ArraySeqMtPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 18 algorithms for ArraySeqMtPer multithreaded.
    3|       |//!
    4|       |//! Note: Uses unconditional parallelism with ParaPair! for divide-and-conquer operations (map, reduce).
    5|       |
    6|       |pub mod ArraySeqMtPer {
    7|       |
    8|       |    use std::collections::HashSet;
    9|       |    use std::sync::Arc;
   10|       |    use std::thread;
   11|       |
   12|       |    use crate::ParaPair;
   13|       |    use crate::Types::Types::*;
   14|       |
   15|       |    #[derive(Debug)]
   16|       |    pub struct ArraySeqMtPerS<T: StTInMtT> {
   17|       |        data: Box<[T]>,
   18|       |    }
   19|       |
   20|       |    impl<T: StTInMtT> ArraySeqMtPerS<T> {
   21|     25|        pub fn empty() -> Self {
   22|     25|            ArraySeqMtPerS {
   23|     25|                data: Vec::new().into_boxed_slice(),
   24|     25|            }
   25|     25|        }
   26|       |
   27|     36|        pub fn new(length: N, init_value: T) -> Self {
   28|     36|            let mut values: Vec<T> = Vec::with_capacity(length);
   29|     36|            for _ in 0..length {
   30|     10|                values.push(init_value.clone());
   31|     10|            }
   32|     36|            ArraySeqMtPerS::from_vec(values)
   33|     36|        }
   34|       |
   35|     64|        pub fn singleton(item: T) -> Self { ArraySeqMtPerS::from_vec(vec![item]) }
   36|       |
   37|  4.26k|        pub fn from_vec(values: Vec<T>) -> Self {
   38|  4.26k|            ArraySeqMtPerS {
   39|  4.26k|                data: values.into_boxed_slice(),
   40|  4.26k|            }
   41|  4.26k|        }
   42|       |
   43|  7.49k|        pub fn length(&self) -> N { self.data.len() }
   44|       |
   45|  20.2k|        pub fn nth(&self, index: N) -> &T { &self.data[index] }
   46|       |
   47|    885|        pub fn subseq_copy(&self, start: N, length: N) -> Self {
   48|    885|            let n = self.data.len();
   49|    885|            let s = start.min(n);
   50|    885|            let e = start.saturating_add(length).min(n);
   51|    885|            let values: Vec<T> = self.data[s..e].iter().cloned().collect();
   52|    885|            ArraySeqMtPerS::from_vec(values)
   53|    885|        }
   54|       |
   55|      5|        pub fn is_empty(&self) -> B { if self.data.is_empty() { true } else { false } }
                                                                              ^3            ^2
   56|       |
   57|      7|        pub fn is_singleton(&self) -> B { if self.data.len() == 1 { true } else { false } }
                                                                                  ^3            ^4
   58|       |
   59|       |        /// Iterator over references to elements
   60|      5|        pub fn iter(&self) -> std::slice::Iter<'_, T> { self.data.iter() }
   61|       |    }
   62|       |
   63|       |    impl<T: StTInMtT> Clone for ArraySeqMtPerS<T> {
   64|  1.60k|        fn clone(&self) -> Self {
   65|  1.60k|            let values: Vec<T> = self.data.iter().cloned().collect();
   66|  1.60k|            ArraySeqMtPerS::from_vec(values)
   67|  1.60k|        }
   68|       |    }
   69|       |
   70|       |    impl<T: StTInMtT> PartialEq for ArraySeqMtPerS<T> {
   71|     11|        fn eq(&self, other: &Self) -> bool {
   72|     11|            if self.data.len() != other.data.len() {
   73|      1|                return false;
   74|     10|            }
   75|     29|            for i in 0..self.data.len() {
                                      ^10       ^10
   76|     29|                if self.data[i] != other.data[i] {
   77|      2|                    return false;
   78|     27|                }
   79|       |            }
   80|      8|            true
   81|     11|        }
   82|       |    }
   83|       |
   84|       |    impl<T: StTInMtT + Eq> Eq for ArraySeqMtPerS<T> {}
   85|       |
   86|       |    impl<'a, T: StTInMtT> IntoIterator for &'a ArraySeqMtPerS<T> {
   87|       |        type Item = &'a T;
   88|       |        type IntoIter = std::slice::Iter<'a, T>;
   89|       |
   90|      1|        fn into_iter(self) -> Self::IntoIter { self.data.iter() }
   91|       |    }
   92|       |
   93|       |    impl<T: StTInMtT> IntoIterator for ArraySeqMtPerS<T> {
   94|       |        type Item = T;
   95|       |        type IntoIter = std::vec::IntoIter<T>;
   96|       |
   97|      1|        fn into_iter(self) -> Self::IntoIter { self.data.into_vec().into_iter() }
   98|       |    }
   99|       |
  100|       |    impl<T: StTInMtT> std::fmt::Display for ArraySeqMtPerS<T> {
  101|      2|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  102|      2|            write!(f, "ArraySeqMtPerS[")?;
                                                      ^0
  103|      6|            for (i, item) in self.data.iter().enumerate() {
                                           ^2        ^2     ^2
  104|      6|                if i > 0 {
  105|      4|                    write!(f, ", ")?;
                                                 ^0
  106|      2|                }
  107|      6|                write!(f, "{}", item)?;
                                                   ^0
  108|       |            }
  109|      2|            write!(f, "]")
  110|      2|        }
  111|       |    }
  112|       |
  113|       |    pub trait ArraySeqMtPerTrait<T: StTInMtT> {
  114|       |        /// APAS: Work (n), Span (1)
  115|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1) - sequential
  116|       |        fn new(length: N, init_value: T) -> ArraySeqMtPerS<T>;
  117|       |        /// APAS: Work (1), Span (1)
  118|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
  119|       |        fn empty() -> ArraySeqMtPerS<T>;
  120|       |        /// APAS: Work (1), Span (1)
  121|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
  122|       |        fn singleton(item: T) -> ArraySeqMtPerS<T>;
  123|       |        /// APAS: Work (1), Span (1)
  124|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
  125|       |        fn length(&self) -> N;
  126|       |        /// APAS: Work (1), Span (1)
  127|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
  128|       |        fn nth(&self, index: N) -> &T;
  129|       |        /// APAS: Work (len), Span (1)
  130|       |        /// claude-4-sonet: Work (len), Span (len), Parallelism (1) - sequential copy
  131|       |        fn subseq_copy(&self, start: N, length: N) -> ArraySeqMtPerS<T>;
  132|       |        /// APAS: Work (n), Span (1)
  133|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1) - copies entire array
  134|       |        fn set(&self, index: N, item: T) -> Result<ArraySeqMtPerS<T>, &'static str>;
  135|       |        /// APAS: Work (n), Span (1)
  136|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1) - sequential
  137|       |        fn tabulate<F: Fn(N) -> T + Send + Sync>(f: &F, n: N) -> ArraySeqMtPerS<T>;
  138|       |        /// APAS: Work (|a|), Span (log|a|)
  139|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) when F is cheap, better when F is expensive - asymmetric fork-join recursion
  140|       |        fn map<W: StTInMtT + 'static, F: Fn(&T) -> W + Send + Sync + Clone + 'static>(
  141|       |            a: &ArraySeqMtPerS<T>,
  142|       |            f: F,
  143|       |        ) -> ArraySeqMtPerS<W>
  144|       |        where
  145|       |            T: 'static;
  146|       |        /// APAS: Work (|a|+|b|), Span (1)
  147|       |        /// claude-4-sonet: Work (|a|+|b|), Span (|a|+|b|), Parallelism (1) - sequential
  148|       |        fn append(a: &ArraySeqMtPerS<T>, b: &ArraySeqMtPerS<T>) -> ArraySeqMtPerS<T>;
  149|       |        /// APAS: Work (|a|), Span (1)
  150|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential
  151|       |        fn filter<F: Fn(&T) -> B + Send + Sync>(a: &ArraySeqMtPerS<T>, pred: &F) -> ArraySeqMtPerS<T>;
  152|       |        /// APAS: Work (n), Span (1)
  153|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1) - copies entire array
  154|       |        fn update(a: &ArraySeqMtPerS<T>, item_at: Pair<N, T>) -> ArraySeqMtPerS<T>;
  155|       |        /// APAS: Work (|a|), Span (1)
  156|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential
  157|       |        fn ninject(a: &ArraySeqMtPerS<T>, updates: &ArraySeqMtPerS<Pair<N, T>>) -> ArraySeqMtPerS<T>;
  158|       |        /// APAS: Work (|a|), Span (1)
  159|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential fold
  160|       |        fn iterate<A: StTInMtT, F: Fn(&A, &T) -> A + Send + Sync>(a: &ArraySeqMtPerS<T>, f: &F, x: A) -> A;
  161|       |        /// APAS: Work (|a|), Span (1)
  162|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential prefix sum
  163|       |        fn iteratePrefixes<A: StTInMtT + 'static, F: Fn(&A, &T) -> A + Send + Sync>(
  164|       |            a: &ArraySeqMtPerS<T>,
  165|       |            f: &F,
  166|       |            x: A,
  167|       |        ) -> (ArraySeqMtPerS<A>, A);
  168|       |        /// APAS: Work (|a|), Span (log|a|)
  169|       |        /// claude-4-sonet: Work (|a|), Span (log|a|), Parallelism (|a|/log|a|) - parallel via ParaPair! divide-and-conquer
  170|       |        fn reduce<F: Fn(&T, &T) -> T + Send + Sync + Clone + 'static>(a: &ArraySeqMtPerS<T>, f: F, id: T) -> T
  171|       |        where
  172|       |            T: 'static;
  173|       |        /// APAS: Work (|a|), Span (1)
  174|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential prefix sum
  175|       |        fn scan<F: Fn(&T, &T) -> T + Send + Sync>(a: &ArraySeqMtPerS<T>, f: &F, id: T) -> (ArraySeqMtPerS<T>, T);
  176|       |        /// APAS: Work (|ss[i]|), Span (1)
  177|       |        /// claude-4-sonet: Work (|ss[i]|), Span (|ss[i]|), Parallelism (1) - sequential
  178|       |        fn flatten(ss: &ArraySeqMtPerS<ArraySeqMtPerS<T>>) -> ArraySeqMtPerS<T>;
  179|       |        /// APAS: Work (|a|), Span (1)
  180|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential with linear search
  181|       |        fn collect(a: &ArraySeqMtPerS<Pair<T, T>>, cmp: fn(&T, &T) -> O) -> ArraySeqMtPerS<Pair<T, ArraySeqMtPerS<T>>>;
  182|       |        fn inject(a: &ArraySeqMtPerS<T>, updates: &ArraySeqMtPerS<Pair<N, T>>) -> ArraySeqMtPerS<T>;
  183|       |        fn isEmpty(&self) -> B;
  184|       |        fn isSingleton(&self) -> B;
  185|       |    }
  186|       |
  187|       |    impl<T: StTInMtT> ArraySeqMtPerTrait<T> for ArraySeqMtPerS<T> {
  188|      1|        fn new(length: N, init_value: T) -> ArraySeqMtPerS<T> { ArraySeqMtPerS::new(length, init_value) }
  189|      0|        fn empty() -> ArraySeqMtPerS<T> { ArraySeqMtPerS::empty() }
  190|      0|        fn singleton(item: T) -> ArraySeqMtPerS<T> { ArraySeqMtPerS::singleton(item) }
  191|      1|        fn length(&self) -> N { ArraySeqMtPerS::length(self) }
  192|      2|        fn nth(&self, index: N) -> &T { ArraySeqMtPerS::nth(self, index) }
  193|      0|        fn subseq_copy(&self, start: N, length: N) -> ArraySeqMtPerS<T> {
  194|      0|            ArraySeqMtPerS::subseq_copy(self, start, length)
  195|      0|        }
  196|       |
  197|    437|        fn set(&self, index: N, item: T) -> Result<ArraySeqMtPerS<T>, &'static str> {
  198|    437|            if index >= self.data.len() {
  199|      1|                return Err("Index out of bounds");
  200|    436|            }
  201|    436|            let mut new_data: Vec<T> = self.data.iter().cloned().collect();
  202|    436|            new_data[index] = item;
  203|    436|            Ok(ArraySeqMtPerS::from_vec(new_data))
  204|    437|        }
  205|       |
  206|     83|        fn tabulate<F: Fn(N) -> T + Send + Sync>(f: &F, n: N) -> ArraySeqMtPerS<T> {
  207|     83|            let mut values: Vec<T> = Vec::with_capacity(n);
  208|  12.3k|            for i in 0..n {
                                      ^83
  209|  12.3k|                values.push(f(i));
  210|  12.3k|            }
  211|     83|            ArraySeqMtPerS::from_vec(values)
  212|     83|        }
  213|       |
  214|     10|        fn map<W: StTInMtT + 'static, F: Fn(&T) -> W + Send + Sync + Clone + 'static>(
  215|     10|            a: &ArraySeqMtPerS<T>,
  216|     10|            f: F,
  217|     10|        ) -> ArraySeqMtPerS<W>
  218|     10|        where
  219|     10|            T: 'static,
  220|       |        {
  221|     10|            if a.length() == 0 {
  222|      1|                return ArraySeqMtPerS::from_vec(Vec::new());
  223|      9|            }
  224|      9|            if a.length() == 1 {
  225|      5|                let result = f(a.nth(0));
  226|      5|                return ArraySeqMtPerS::from_vec(vec![result]);
  227|      4|            }
  228|       |
  229|       |            // Parallel via asymmetric fork-join (good when F is expensive)
  230|      4|            let mid = a.length() / 2;
  231|      4|            let left = a.subseq_copy(0, mid);
  232|      4|            let right = a.subseq_copy(mid, a.length() - mid);
  233|      4|            let f_clone = f.clone();
  234|      4|            let left_handle = thread::spawn(move || ArraySeqMtPerS::map(&left, f_clone));
  235|      4|            let right_result = ArraySeqMtPerS::map(&right, f);
  236|      4|            let left_result = left_handle.join().unwrap();
  237|      4|            ArraySeqMtPerS::append(&left_result, &right_result)
  238|     10|        }
  239|       |
  240|    150|        fn append(a: &ArraySeqMtPerS<T>, b: &ArraySeqMtPerS<T>) -> ArraySeqMtPerS<T> {
  241|    150|            let mut values: Vec<T> = Vec::with_capacity(a.length() + b.length());
  242|    424|            for i in 0..a.length() {
                                      ^150^150
  243|    424|                values.push(a.nth(i).clone());
  244|    424|            }
  245|    223|            for j in 0..b.length() {
                                      ^150^150
  246|    223|                values.push(b.nth(j).clone());
  247|    223|            }
  248|    150|            ArraySeqMtPerS::from_vec(values)
  249|    150|        }
  250|       |
  251|      2|        fn filter<F: Fn(&T) -> B + Send + Sync>(a: &ArraySeqMtPerS<T>, pred: &F) -> ArraySeqMtPerS<T> {
  252|      2|            let mut values: Vec<T> = Vec::new();
  253|     14|            for i in 0..a.length() {
                                      ^2^2
  254|     14|                let item = a.nth(i);
  255|     14|                if pred(item) == true {
  256|      5|                    values.push(item.clone());
  257|      9|                }
  258|       |            }
  259|      2|            ArraySeqMtPerS::from_vec(values)
  260|      2|        }
  261|       |
  262|     19|        fn update(a: &ArraySeqMtPerS<T>, item_at: Pair<N, T>) -> ArraySeqMtPerS<T> {
  263|     19|            let Pair(index, item) = item_at;
  264|     19|            if index >= a.length() {
  265|      1|                return a.clone();
  266|     18|            }
  267|     18|            let mut new_data: Vec<T> = a.data.iter().cloned().collect();
  268|     18|            new_data[index] = item;
  269|     18|            ArraySeqMtPerS::from_vec(new_data)
  270|     19|        }
  271|       |
  272|      4|        fn ninject(a: &ArraySeqMtPerS<T>, updates: &ArraySeqMtPerS<Pair<N, T>>) -> ArraySeqMtPerS<T> {
  273|      4|            let mut result = a.clone();
  274|      8|            for i in 0..updates.length() {
                                      ^4      ^4
  275|      8|                let Pair(index, value) = updates.nth(i);
  276|      8|                if *index < result.length() {
  277|      8|                    result = result.set(*index, value.clone()).unwrap_or(result);
  278|      8|                }
                              ^0
  279|       |            }
  280|      4|            result
  281|      4|        }
  282|       |
  283|      2|        fn iterate<A: StTInMtT, F: Fn(&A, &T) -> A + Send + Sync>(a: &ArraySeqMtPerS<T>, f: &F, x: A) -> A {
  284|      2|            let mut acc = x;
  285|      9|            for i in 0..a.length() {
                                      ^2^2
  286|      9|                acc = f(&acc, a.nth(i));
  287|      9|            }
  288|      2|            acc
  289|      2|        }
  290|       |
  291|      1|        fn iteratePrefixes<A: StTInMtT + 'static, F: Fn(&A, &T) -> A + Send + Sync>(
  292|      1|            a: &ArraySeqMtPerS<T>,
  293|      1|            f: &F,
  294|      1|            x: A,
  295|      1|        ) -> (ArraySeqMtPerS<A>, A) {
  296|      1|            let mut acc = x;
  297|      1|            let mut values: Vec<A> = Vec::with_capacity(a.length());
  298|      5|            for i in 0..a.length() {
                                      ^1^1
  299|      5|                acc = f(&acc, a.nth(i));
  300|      5|                values.push(acc.clone());
  301|      5|            }
  302|      1|            (ArraySeqMtPerS::from_vec(values), acc)
  303|      1|        }
  304|       |
  305|    156|        fn reduce<F: Fn(&T, &T) -> T + Send + Sync + Clone + 'static>(a: &ArraySeqMtPerS<T>, f: F, id: T) -> T
  306|    156|        where
  307|    156|            T: 'static,
  308|       |        {
  309|    156|            if a.length() == 0 {
  310|      1|                return id;
  311|    155|            }
  312|    155|            if a.length() == 1 {
  313|     82|                return a.nth(0).clone();
  314|     73|            }
  315|       |
  316|       |            // Unconditionally parallel using ParaPair!
  317|     73|            let mid = a.length() / 2;
  318|     73|            let left = a.subseq_copy(0, mid);
  319|     73|            let right = a.subseq_copy(mid, a.length() - mid);
  320|     73|            let f_clone = f.clone();
  321|     73|            let f_clone2 = f.clone();
  322|     73|            let id_clone = id.clone();
  323|       |
  324|     73|            let Pair(l, r) = ParaPair!(
  325|     73|                move || <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::reduce(&left, f_clone, id_clone),
  326|     73|                move || <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::reduce(&right, f_clone2, id)
  327|       |            );
  328|     73|            f(&l, &r)
  329|    156|        }
  330|       |
  331|      1|        fn scan<F: Fn(&T, &T) -> T + Send + Sync>(a: &ArraySeqMtPerS<T>, f: &F, id: T) -> (ArraySeqMtPerS<T>, T) {
  332|      1|            let mut acc = id.clone();
  333|      1|            let mut values: Vec<T> = Vec::with_capacity(a.length());
  334|      5|            for i in 0..a.length() {
                                      ^1^1
  335|      5|                acc = f(&acc, a.nth(i));
  336|      5|                values.push(acc.clone());
  337|      5|            }
  338|      1|            (ArraySeqMtPerS::from_vec(values), acc)
  339|      1|        }
  340|       |
  341|    111|        fn flatten(ss: &ArraySeqMtPerS<ArraySeqMtPerS<T>>) -> ArraySeqMtPerS<T> {
  342|    111|            let mut values: Vec<T> = Vec::new();
  343|    222|            for i in 0..ss.length() {
                                      ^111^111
  344|    222|                let inner_seq = ss.nth(i);
  345|    715|                for j in 0..inner_seq.length() {
                                          ^222      ^222
  346|    715|                    values.push(inner_seq.nth(j).clone());
  347|    715|                }
  348|       |            }
  349|    111|            ArraySeqMtPerS::from_vec(values)
  350|    111|        }
  351|       |
  352|      2|        fn collect(a: &ArraySeqMtPerS<Pair<T, T>>, cmp: fn(&T, &T) -> O) -> ArraySeqMtPerS<Pair<T, ArraySeqMtPerS<T>>> {
  353|      2|            if a.length() == 0 {
  354|      0|                return ArraySeqMtPerS::from_vec(vec![]);
  355|      2|            }
  356|      2|            let mut groups: Vec<Pair<T, ArraySeqMtPerS<T>>> = Vec::new();
  357|      8|            for i in 0..a.length() {
                                      ^2^2
  358|      8|                let Pair(key, value) = a.nth(i);
  359|      8|                let mut found_group = false;
  360|     11|                for group in &mut groups {
                                  ^7
  361|      7|                    if cmp(&key, &group.0) == O::Equal {
  362|      5|                        let mut values: Vec<T> = (0..group.1.length()).map(|j| group.1.nth(j).clone()).collect();
                                          ^4          ^4       ^4                    ^4                              ^4
  363|      4|                        values.push(value.clone());
  364|      4|                        group.1 = ArraySeqMtPerS::from_vec(values);
  365|      4|                        found_group = true;
  366|      4|                        break;
  367|      3|                    }
  368|       |                }
  369|      8|                if !found_group {
  370|      4|                    groups.push(Pair(key.clone(), ArraySeqMtPerS::from_vec(vec![value.clone()])));
  371|      4|                }
  372|       |            }
  373|      2|            ArraySeqMtPerS::from_vec(groups)
  374|      2|        }
  375|       |
  376|    423|        fn inject(a: &ArraySeqMtPerS<T>, updates: &ArraySeqMtPerS<Pair<N, T>>) -> ArraySeqMtPerS<T> {
  377|    423|            let mut result = a.clone();
  378|    423|            let mut updated: HashSet<N> = HashSet::new();
  379|    431|            for i in 0..updates.length() {
                                      ^423    ^423
  380|    431|                let Pair(index, value) = updates.nth(i);
  381|    431|                if *index < result.length() && updated.insert(*index) {
                                                             ^429    ^429   ^429
  382|    427|                    result = result.set(*index, value.clone()).unwrap_or(result);
  383|    427|                }
                              ^4
  384|       |            }
  385|    423|            result
  386|    423|        }
  387|       |
  388|      2|        fn isEmpty(&self) -> B { ArraySeqMtPerS::is_empty(self) }
  389|       |
  390|      3|        fn isSingleton(&self) -> B { ArraySeqMtPerS::is_singleton(self) }
  391|       |    }
  392|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap18/ArraySeqStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Single-threaded ephemeral array sequence (mutable) implementation.
    3|       |
    4|       |pub mod ArraySeqStEph {
    5|       |
    6|       |    use std::collections::HashSet;
    7|       |    use std::fmt::{Debug, Display, Formatter, Result as FmtResult};
    8|       |
    9|       |    use crate::Types::Types::*;
   10|       |
   11|       |    #[derive(Clone)]
   12|       |    pub struct ArraySeqStEphS<T: StT> {
   13|       |        data: Box<[T]>,
   14|       |    }
   15|       |
   16|       |    pub type ArrayStEph<T> = ArraySeqStEphS<T>;
   17|       |
   18|       |    impl<T: StT> ArraySeqStEphS<T> {
   19|  4.89k|        pub fn from_vec(elts: Vec<T>) -> Self {
   20|  4.89k|            Self {
   21|  4.89k|                data: elts.into_boxed_slice(),
   22|  4.89k|            }
   23|  4.89k|        }
   24|       |
   25|    254|        pub fn new(length: N, init_value: T) -> Self { Self::from_vec(vec![init_value; length]) }
   26|       |
   27|    348|        pub fn empty() -> Self { Self::from_vec(Vec::new()) }
   28|       |
   29|    280|        pub fn singleton(item: T) -> Self { Self::from_vec(vec![item]) }
   30|       |
   31|  11.7k|        pub fn length(&self) -> N { self.data.len() }
   32|       |
   33|   580k|        pub fn nth(&self, index: N) -> &T { &self.data[index] }
   34|       |
   35|       |        /// Iterator over references to elements
   36|     96|        pub fn iter(&self) -> std::slice::Iter<'_, T> { self.data.iter() }
   37|       |
   38|    110|        pub fn subseq(&self, start: N, length: N) -> Self {
   39|    110|            let total = self.data.len();
   40|    110|            let begin = start.min(total);
   41|    110|            let end = start.saturating_add(length).min(total);
   42|    110|            Self::from_vec(self.data[begin..end].iter().cloned().collect())
   43|    110|        }
   44|       |
   45|  1.22k|        pub fn set(&mut self, index: N, item: T) -> Result<&mut Self, &'static str> {
   46|  1.22k|            if index < self.data.len() {
   47|  1.21k|                self.data[index] = item;
   48|  1.21k|                Ok(self)
   49|       |            } else {
   50|      5|                Err("Index out of bounds")
   51|       |            }
   52|  1.22k|        }
   53|       |
   54|      9|        pub fn update(&mut self, Pair(index, item): Pair<N, T>) -> &mut Self {
   55|      9|            let _ = self.set(index, item);
   56|      9|            self
   57|      9|        }
   58|       |
   59|     64|        pub fn inject(&mut self, updates: &ArraySeqStEphS<Pair<N, T>>) -> &mut Self {
   60|     64|            let mut last_values: std::collections::HashMap<N, T> = std::collections::HashMap::new();
   61|    112|            for i in 0..updates.length() {
                                      ^64     ^64
   62|    112|                let Pair(index, value) = updates.nth(i).clone();
   63|    112|                if index < self.data.len() {
   64|    110|                    last_values.insert(index, value);
   65|    110|                }
                              ^2
   66|       |            }
   67|    152|            for (index, value) in last_values {
                               ^88    ^88
   68|     88|                let _ = self.set(index, value);
   69|     88|            }
   70|     64|            self
   71|     64|        }
   72|       |    }
   73|       |
   74|       |    impl<T: StT> PartialEq for ArraySeqStEphS<T> {
   75|     63|        fn eq(&self, other: &Self) -> bool { self.data[..] == other.data[..] }
   76|       |    }
   77|       |
   78|       |    impl<T: StT> Eq for ArraySeqStEphS<T> {}
   79|       |
   80|       |    impl<T: StT> Debug for ArraySeqStEphS<T> {
   81|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult { f.debug_list().entries(self.data.iter()).finish() }
   82|       |    }
   83|       |
   84|       |    impl<'a, T: StT> IntoIterator for &'a ArraySeqStEphS<T> {
   85|       |        type Item = &'a T;
   86|       |        type IntoIter = std::slice::Iter<'a, T>;
   87|       |
   88|      0|        fn into_iter(self) -> Self::IntoIter { self.data.iter() }
   89|       |    }
   90|       |
   91|       |    impl<T: StT> IntoIterator for ArraySeqStEphS<T> {
   92|       |        type Item = T;
   93|       |        type IntoIter = std::vec::IntoIter<T>;
   94|       |
   95|      0|        fn into_iter(self) -> Self::IntoIter { self.data.into_vec().into_iter() }
   96|       |    }
   97|       |
   98|       |    impl<T: StT> Display for ArraySeqStEphS<T> {
   99|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
  100|      0|            write!(f, "[")?;
  101|      0|            for (i, item) in self.data.iter().enumerate() {
  102|      0|                if i > 0 {
  103|      0|                    write!(f, ", ")?;
  104|      0|                }
  105|      0|                write!(f, "{}", item)?;
  106|       |            }
  107|      0|            write!(f, "]")
  108|      0|        }
  109|       |    }
  110|       |
  111|       |    pub trait ArraySeqStEphTrait<T: StT> {
  112|       |        /// APAS: Work (n), Span (1)
  113|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1) - sequential
  114|       |        fn new(length: N, init_value: T) -> ArraySeqStEphS<T>;
  115|       |        /// APAS: Work (1), Span (1)
  116|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
  117|       |        fn set(&mut self, index: N, item: T) -> Result<&mut ArraySeqStEphS<T>, &'static str>;
  118|       |        /// APAS: Work (1), Span (1)
  119|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
  120|       |        fn length(&self) -> N;
  121|       |        /// APAS: Work (1), Span (1)
  122|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
  123|       |        fn nth(&self, index: N) -> &T;
  124|       |        /// APAS: Work (1), Span (1)
  125|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
  126|       |        fn empty() -> ArraySeqStEphS<T>;
  127|       |        /// APAS: Work (1), Span (1)
  128|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
  129|       |        fn singleton(item: T) -> ArraySeqStEphS<T>;
  130|       |        /// APAS: Work (n), Span (1)
  131|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1) - sequential
  132|       |        fn tabulate<F: Fn(N) -> T>(f: &F, length: N) -> ArraySeqStEphS<T>;
  133|       |        /// APAS: Work (|a|), Span (1)
  134|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential
  135|       |        fn map<U: StT, F: Fn(&T) -> U>(a: &ArraySeqStEphS<T>, f: &F) -> ArraySeqStEphS<U>;
  136|       |        /// APAS: Work (len), Span (1)
  137|       |        /// claude-4-sonet: Work (len), Span (len), Parallelism (1) - sequential copy
  138|       |        fn subseq(a: &ArraySeqStEphS<T>, start: N, length: N) -> ArraySeqStEphS<T>;
  139|       |        /// APAS: Work (|a|+|b|), Span (1)
  140|       |        /// claude-4-sonet: Work (|a|+|b|), Span (|a|+|b|), Parallelism (1) - sequential
  141|       |        fn append(a: &ArraySeqStEphS<T>, b: &ArraySeqStEphS<T>) -> ArraySeqStEphS<T>;
  142|       |        /// APAS: Work (|a|), Span (1)
  143|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential
  144|       |        fn filter<F: Fn(&T) -> B>(a: &ArraySeqStEphS<T>, pred: &F) -> ArraySeqStEphS<T>;
  145|       |        /// APAS: Work (|a[i]|), Span (1)
  146|       |        /// claude-4-sonet: Work (|a[i]|), Span (|a[i]|), Parallelism (1) - sequential
  147|       |        fn flatten(a: &ArraySeqStEphS<ArraySeqStEphS<T>>) -> ArraySeqStEphS<T>;
  148|       |        /// APAS: Work (1), Span (1)
  149|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1) - in-place mutation
  150|       |        fn update(&mut self, update: Pair<N, T>) -> &mut ArraySeqStEphS<T>;
  151|       |        /// APAS: Work (|updates|), Span (1)
  152|       |        /// claude-4-sonet: Work (|updates|), Span (|updates|), Parallelism (1) - sequential in-place
  153|       |        fn inject(&mut self, updates: &ArraySeqStEphS<Pair<N, T>>) -> &mut ArraySeqStEphS<T>;
  154|       |        /// APAS: Work (1), Span (1)
  155|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
  156|       |        fn isEmpty(&self) -> B;
  157|       |        /// APAS: Work (1), Span (1)
  158|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
  159|       |        fn isSingleton(&self) -> B;
  160|       |        /// APAS: Work (|pairs|), Span (1)
  161|       |        /// claude-4-sonet: Work (|pairs|), Span (|pairs|), Parallelism (1) - sequential with linear search
  162|       |        fn collect<K: StT, V: StT>(
  163|       |            pairs: &ArraySeqStEphS<Pair<K, V>>,
  164|       |            cmp: fn(&K, &K) -> O,
  165|       |        ) -> ArraySeqStEphS<Pair<K, ArraySeqStEphS<V>>>;
  166|       |        /// APAS: Work (|a|), Span (1)
  167|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential fold
  168|       |        fn iterate<A, F: Fn(&A, &T) -> A>(a: &ArraySeqStEphS<T>, f: &F, seed: A) -> A;
  169|       |        /// APAS: Work (|a|), Span (1)
  170|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential reduction
  171|       |        fn reduce<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, id: T) -> T;
  172|       |        /// APAS: Work (|a|), Span (1)
  173|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential prefix sum
  174|       |        fn scan<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, id: T) -> (ArraySeqStEphS<T>, T);
  175|       |    }
  176|       |
  177|       |    impl<T: StT> ArraySeqStEphTrait<T> for ArraySeqStEphS<T> {
  178|     66|        fn new(length: N, init_value: T) -> ArraySeqStEphS<T> { ArraySeqStEphS::new(length, init_value) }
  179|       |
  180|      1|        fn set(&mut self, index: N, item: T) -> Result<&mut ArraySeqStEphS<T>, &'static str> {
  181|      1|            ArraySeqStEphS::set(self, index, item)
  182|      1|        }
  183|       |
  184|      4|        fn length(&self) -> N { ArraySeqStEphS::length(self) }
  185|       |
  186|     11|        fn nth(&self, index: N) -> &T { ArraySeqStEphS::nth(self, index) }
  187|       |
  188|     31|        fn empty() -> ArraySeqStEphS<T> { ArraySeqStEphS::empty() }
  189|       |
  190|      0|        fn singleton(item: T) -> ArraySeqStEphS<T> { ArraySeqStEphS::singleton(item) }
  191|       |
  192|    353|        fn tabulate<F: Fn(N) -> T>(f: &F, length: N) -> ArraySeqStEphS<T> {
  193|    353|            let mut values: Vec<T> = Vec::with_capacity(length);
  194|  4.46k|            for i in 0..length {
                                      ^353
  195|  4.46k|                values.push(f(i));
  196|  4.46k|            }
  197|    353|            ArraySeqStEphS::from_vec(values)
  198|    353|        }
  199|       |
  200|      3|        fn map<U: StT, F: Fn(&T) -> U>(a: &ArraySeqStEphS<T>, f: &F) -> ArraySeqStEphS<U> {
  201|      3|            let mut values: Vec<U> = Vec::with_capacity(a.length());
  202|     15|            for i in 0..a.length() {
                                      ^3^3
  203|     15|                values.push(f(a.nth(i)));
  204|     15|            }
  205|      3|            ArraySeqStEphS::from_vec(values)
  206|      3|        }
  207|       |
  208|     22|        fn subseq(a: &ArraySeqStEphS<T>, start: N, length: N) -> ArraySeqStEphS<T> { a.subseq(start, length) }
  209|       |
  210|    130|        fn append(a: &ArraySeqStEphS<T>, b: &ArraySeqStEphS<T>) -> ArraySeqStEphS<T> {
  211|    130|            let total = a.length() + b.length();
  212|    130|            let mut values: Vec<T> = Vec::with_capacity(total);
  213|    197|            for i in 0..a.length() {
                                      ^130^130
  214|    197|                values.push(a.nth(i).clone());
  215|    197|            }
  216|    160|            for j in 0..b.length() {
                                      ^130^130
  217|    160|                values.push(b.nth(j).clone());
  218|    160|            }
  219|    130|            ArraySeqStEphS::from_vec(values)
  220|    130|        }
  221|       |
  222|     58|        fn filter<F: Fn(&T) -> B>(a: &ArraySeqStEphS<T>, pred: &F) -> ArraySeqStEphS<T> {
  223|     58|            let mut kept: Vec<T> = Vec::new();
  224|    311|            for i in 0..a.length() {
                                      ^58^58
  225|    311|                let value = a.nth(i);
  226|    311|                if pred(value) == true {
  227|    170|                    kept.push(value.clone());
  228|    170|                }
                              ^141
  229|       |            }
  230|     58|            ArraySeqStEphS::from_vec(kept)
  231|     58|        }
  232|       |
  233|     12|        fn flatten(a: &ArraySeqStEphS<ArraySeqStEphS<T>>) -> ArraySeqStEphS<T> {
  234|     12|            let mut values: Vec<T> = Vec::new();
  235|     50|            for i in 0..a.length() {
                                      ^12^12
  236|     50|                let inner = a.nth(i);
  237|     50|                for j in 0..inner.length() {
                                  ^46
  238|     46|                    values.push(inner.nth(j).clone());
  239|     46|                }
  240|       |            }
  241|     12|            ArraySeqStEphS::from_vec(values)
  242|     12|        }
  243|       |
  244|      1|        fn update(&mut self, update: Pair<N, T>) -> &mut ArraySeqStEphS<T> { ArraySeqStEphS::update(self, update) }
  245|       |
  246|      9|        fn inject(&mut self, updates: &ArraySeqStEphS<Pair<N, T>>) -> &mut ArraySeqStEphS<T> {
  247|      9|            ArraySeqStEphS::inject(self, updates)
  248|      9|        }
  249|       |
  250|      0|        fn isEmpty(&self) -> B { if self.length() == 0 { true } else { false } }
  251|       |
  252|      0|        fn isSingleton(&self) -> B { if self.length() == 1 { true } else { false } }
  253|       |
  254|      3|        fn collect<K: StT, V: StT>(
  255|      3|            pairs: &ArraySeqStEphS<Pair<K, V>>,
  256|      3|            cmp: fn(&K, &K) -> O,
  257|      3|        ) -> ArraySeqStEphS<Pair<K, ArraySeqStEphS<V>>> {
  258|      3|            let mut groups: Vec<Pair<K, Vec<V>>> = Vec::new();
  259|      9|            'outer: for i in 0..pairs.length() {
                                              ^3    ^3
  260|      9|                let Pair(key, value) = pairs.nth(i).clone();
  261|      9|                for group in groups.iter_mut() {
                                  ^6
  262|      6|                    if cmp(&group.0, &key) == O::Equal {
  263|      3|                        group.1.push(value.clone());
  264|      3|                        continue 'outer;
  265|      3|                    }
  266|       |                }
  267|      6|                groups.push(Pair(key, vec![value]));
  268|       |            }
  269|      3|            let collected: Vec<Pair<K, ArraySeqStEphS<V>>> = groups
  270|      3|                .into_iter()
  271|      6|                .map(|Pair(key, bucket)| Pair(key, ArraySeqStEphS::from_vec(bucket)))
                               ^3
  272|      3|                .collect();
  273|      3|            ArraySeqStEphS::from_vec(collected)
  274|      3|        }
  275|       |
  276|      4|        fn iterate<A, F: Fn(&A, &T) -> A>(a: &ArraySeqStEphS<T>, f: &F, seed: A) -> A {
  277|      4|            let mut acc = seed;
  278|     18|            for i in 0..a.length() {
                                      ^4^4
  279|     18|                acc = f(&acc, a.nth(i));
  280|     18|            }
  281|      4|            acc
  282|      4|        }
  283|       |
  284|      7|        fn reduce<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, id: T) -> T {
  285|      7|            let mut acc = id;
  286|     17|            for i in 0..a.length() {
                                      ^7^7
  287|     17|                acc = f(&acc, a.nth(i));
  288|     17|            }
  289|      7|            acc
  290|      7|        }
  291|       |
  292|      4|        fn scan<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, id: T) -> (ArraySeqStEphS<T>, T) {
  293|      4|            let mut prefixes: Vec<T> = Vec::with_capacity(a.length());
  294|      4|            let mut acc = id.clone();
  295|      4|            prefixes.push(acc.clone()); // Include initial value
  296|     18|            for i in 0..a.length() {
                                      ^4^4
  297|     18|                acc = f(&acc, a.nth(i));
  298|     18|                if i < a.length() - 1 {
  299|     14|                    prefixes.push(acc.clone());
  300|     14|                }
                              ^4
  301|       |            }
  302|      4|            (ArraySeqStEphS::from_vec(prefixes), acc)
  303|      4|        }
  304|       |    }
  305|       |
  306|       |    #[macro_export]
  307|       |    macro_rules! ArraySeqStEphS {
  308|       |        () => { $crate::Chap18::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS::from_vec(Vec::new()) };
  309|       |        ($x:expr; $n:expr) => { $crate::Chap18::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS::from_vec(vec![$x; $n]) };
  310|       |        ($($x:expr),* $(,)?) => { $crate::Chap18::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS::from_vec(vec![$($x),*]) };
  311|       |    }
  312|       |
  313|       |    #[allow(dead_code)]
  314|      0|    fn _arrayseqstephs_macro_type_checks() {
  315|      0|        let _: ArraySeqStEphS<i32> = ArraySeqStEphS![];
  316|      0|        let _: ArraySeqStEphS<&str> = ArraySeqStEphS!["alpha", "beta"];
  317|      0|        let _: ArraySeqStEphS<i64> = ArraySeqStEphS![1; 2];
  318|      0|    }
  319|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap18/ArraySeqStPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 18 persistent sequence implementation for array-backed sequences.
    3|       |
    4|       |pub mod ArraySeqStPer {
    5|       |
    6|       |    use std::collections::HashSet;
    7|       |    use std::fmt::{Debug, Display, Formatter, Result as FmtResult};
    8|       |
    9|       |    use crate::Types::Types::*;
   10|       |
   11|       |    #[derive(Clone)]
   12|       |    pub struct ArraySeqStPerS<T: StT> {
   13|       |        data: Box<[T]>,
   14|       |    }
   15|       |
   16|       |    pub type ArrayStPer<T> = ArraySeqStPerS<T>;
   17|       |
   18|       |    impl<T: StT> ArraySeqStPerS<T> {
   19|   238k|        pub fn from_vec(elts: Vec<T>) -> Self {
   20|   238k|            Self {
   21|   238k|                data: elts.into_boxed_slice(),
   22|   238k|            }
   23|   238k|        }
   24|     38|        pub fn new(length: N, init_value: T) -> Self { Self::from_vec(vec![init_value; length]) }
   25|  4.59k|        pub fn empty() -> Self { Self::from_vec(Vec::new()) }
   26|  63.2k|        pub fn singleton(item: T) -> Self { Self::from_vec(vec![item]) }
   27|   583k|        pub fn length(&self) -> N { self.data.len() }
   28|  3.56M|        pub fn nth(&self, index: N) -> &T { &self.data[index] }
   29|   100k|        pub fn subseq_copy(&self, start: N, length: N) -> Self {
   30|   100k|            let total = self.data.len();
   31|   100k|            let begin = start.min(total);
   32|   100k|            let end = start.saturating_add(length).min(total);
   33|   100k|            let slice: Vec<T> = self.data[begin..end].iter().cloned().collect();
   34|   100k|            Self::from_vec(slice)
   35|   100k|        }
   36|       |
   37|       |        /// Iterator over references to elements
   38|    741|        pub fn iter(&self) -> std::slice::Iter<'_, T> { self.data.iter() }
   39|       |    }
   40|       |
   41|       |    impl<T: StT> PartialEq for ArraySeqStPerS<T> {
   42|    136|        fn eq(&self, other: &Self) -> bool { self.data[..] == other.data[..] }
   43|       |    }
   44|       |
   45|       |    impl<T: StT> Eq for ArraySeqStPerS<T> {}
   46|       |
   47|       |    impl<T: StT> Debug for ArraySeqStPerS<T> {
   48|     12|        fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult { f.debug_list().entries(self.data.iter()).finish() }
   49|       |    }
   50|       |
   51|       |    impl<'a, T: StT> IntoIterator for &'a ArraySeqStPerS<T> {
   52|       |        type Item = &'a T;
   53|       |        type IntoIter = std::slice::Iter<'a, T>;
   54|       |
   55|      0|        fn into_iter(self) -> Self::IntoIter { self.data.iter() }
   56|       |    }
   57|       |
   58|       |    impl<T: StT> IntoIterator for ArraySeqStPerS<T> {
   59|       |        type Item = T;
   60|       |        type IntoIter = std::vec::IntoIter<T>;
   61|       |
   62|     36|        fn into_iter(self) -> Self::IntoIter { self.data.into_vec().into_iter() }
   63|       |    }
   64|       |
   65|       |    impl<T: StT> Display for ArraySeqStPerS<T> {
   66|      3|        fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
   67|      3|            write!(f, "[")?;
                                        ^0
   68|      7|            for (i, item) in self.data.iter().enumerate() {
                                           ^3        ^3     ^3
   69|      7|                if i > 0 {
   70|      4|                    write!(f, ", ")?;
                                                 ^0
   71|      3|                }
   72|      7|                write!(f, "{}", item)?;
                                                   ^0
   73|       |            }
   74|      3|            write!(f, "]")
   75|      3|        }
   76|       |    }
   77|       |
   78|       |    pub trait ArraySeqStPerTrait<T: StT> {
   79|       |        /// APAS: Work (n), Span (1)
   80|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1) - sequential
   81|       |        fn new(length: N, init_value: T) -> ArraySeqStPerS<T>;
   82|       |        /// APAS: Work (1), Span (1)
   83|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   84|       |        fn length(&self) -> N;
   85|       |        /// APAS: Work (1), Span (1)
   86|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   87|       |        fn nth(&self, index: N) -> &T;
   88|       |        /// APAS: Work (1), Span (1)
   89|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   90|       |        fn empty() -> ArraySeqStPerS<T>;
   91|       |        /// APAS: Work (1), Span (1)
   92|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   93|       |        fn singleton(item: T) -> ArraySeqStPerS<T>;
   94|       |        /// APAS: Work (n), Span (1)
   95|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1) - sequential
   96|       |        fn tabulate<F: Fn(N) -> T>(f: &F, length: N) -> ArraySeqStPerS<T>;
   97|       |        /// APAS: Work (|a|), Span (1)
   98|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential
   99|       |        fn map<U: StT, F: Fn(&T) -> U>(a: &ArraySeqStPerS<T>, f: &F) -> ArraySeqStPerS<U>;
  100|       |        /// APAS: Work (len), Span (1)
  101|       |        /// claude-4-sonet: Work (len), Span (len), Parallelism (1) - sequential copy
  102|       |        fn subseq_copy(a: &ArraySeqStPerS<T>, start: N, length: N) -> ArraySeqStPerS<T>;
  103|       |        /// APAS: Work (|a|+|b|), Span (1)
  104|       |        /// claude-4-sonet: Work (|a|+|b|), Span (|a|+|b|), Parallelism (1) - sequential
  105|       |        fn append(a: &ArraySeqStPerS<T>, b: &ArraySeqStPerS<T>) -> ArraySeqStPerS<T>;
  106|       |        /// APAS: Work (|a|), Span (1)
  107|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential
  108|       |        fn filter<F: Fn(&T) -> B>(a: &ArraySeqStPerS<T>, pred: &F) -> ArraySeqStPerS<T>;
  109|       |        /// APAS: Work (|a[i]|), Span (1)
  110|       |        /// claude-4-sonet: Work (|a[i]|), Span (|a[i]|), Parallelism (1) - sequential
  111|       |        fn flatten(a: &ArraySeqStPerS<ArraySeqStPerS<T>>) -> ArraySeqStPerS<T>;
  112|       |        /// APAS: Work (|a|+|updates|), Span (1)
  113|       |        /// claude-4-sonet: Work (|a|+|updates|), Span (|a|+|updates|), Parallelism (1) - sequential with HashSet
  114|       |        fn inject(a: &ArraySeqStPerS<T>, updates: &ArraySeqStPerS<Pair<N, T>>) -> ArraySeqStPerS<T>;
  115|       |        /// APAS: Work (1), Span (1)
  116|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
  117|       |        fn isEmpty(&self) -> B;
  118|       |        /// APAS: Work (1), Span (1)
  119|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
  120|       |        fn isSingleton(&self) -> B;
  121|       |        /// APAS: Work (|pairs|), Span (1)
  122|       |        /// claude-4-sonet: Work (|pairs|), Span (|pairs|), Parallelism (1) - sequential with linear search
  123|       |        fn collect<K: StT, V: StT>(
  124|       |            a: &ArraySeqStPerS<Pair<K, V>>,
  125|       |            cmp: fn(&K, &K) -> O,
  126|       |        ) -> ArraySeqStPerS<Pair<K, ArraySeqStPerS<V>>>;
  127|       |        /// APAS: Work (|a|), Span (1)
  128|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential fold
  129|       |        fn iterate<A, F: Fn(&A, &T) -> A>(a: &ArraySeqStPerS<T>, f: &F, seed: A) -> A;
  130|       |        /// APAS: Work (|a|), Span (1)
  131|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential reduction
  132|       |        fn reduce<F: Fn(&T, &T) -> T>(a: &ArraySeqStPerS<T>, f: &F, id: T) -> T;
  133|       |        /// APAS: Work (|a|), Span (1)
  134|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential prefix sum
  135|       |        fn scan<F: Fn(&T, &T) -> T>(a: &ArraySeqStPerS<T>, f: &F, id: T) -> (ArraySeqStPerS<T>, T);
  136|       |        /// claude-4-sonet: Work (|a|+|updates|), Span (|a|+|updates|), Parallelism (1) - sequential, overwrites on conflict
  137|       |        fn ninject(a: &ArraySeqStPerS<T>, updates: &ArraySeqStPerS<Pair<N, T>>) -> ArraySeqStPerS<T>;
  138|       |    }
  139|       |
  140|       |    impl<T: StT> ArraySeqStPerTrait<T> for ArraySeqStPerS<T> {
  141|      2|        fn new(length: N, init_value: T) -> ArraySeqStPerS<T> { ArraySeqStPerS::new(length, init_value) }
  142|      9|        fn length(&self) -> N { ArraySeqStPerS::length(self) }
  143|     17|        fn nth(&self, index: N) -> &T { ArraySeqStPerS::nth(self, index) }
  144|    269|        fn empty() -> ArraySeqStPerS<T> { ArraySeqStPerS::empty() }
  145|    235|        fn singleton(item: T) -> ArraySeqStPerS<T> { ArraySeqStPerS::singleton(item) }
  146|       |
  147|  3.87k|        fn tabulate<F: Fn(N) -> T>(f: &F, length: N) -> ArraySeqStPerS<T> {
  148|  3.87k|            let mut values: Vec<T> = Vec::with_capacity(length);
  149|   529k|            for i in 0..length {
                                      ^3.87k
  150|   529k|                values.push(f(i));
  151|   529k|            }
  152|  3.87k|            ArraySeqStPerS::from_vec(values)
  153|  3.87k|        }
  154|       |
  155|      7|        fn map<U: StT, F: Fn(&T) -> U>(a: &ArraySeqStPerS<T>, f: &F) -> ArraySeqStPerS<U> {
  156|      7|            let mut values: Vec<U> = Vec::with_capacity(a.length());
  157|  50.0k|            for i in 0..a.length() {
                                      ^7^7
  158|  50.0k|                values.push(f(a.nth(i)));
  159|  50.0k|            }
  160|      7|            ArraySeqStPerS::from_vec(values)
  161|      7|        }
  162|       |
  163|      0|        fn subseq_copy(a: &ArraySeqStPerS<T>, start: N, length: N) -> ArraySeqStPerS<T> { a.subseq_copy(start, length) }
  164|       |
  165|  63.0k|        fn append(a: &ArraySeqStPerS<T>, b: &ArraySeqStPerS<T>) -> ArraySeqStPerS<T> {
  166|  63.0k|            let mut values: Vec<T> = Vec::with_capacity(a.length() + b.length());
  167|  2.06M|            for i in 0..a.length() {
                                      ^63.0k^63.0k
  168|  2.06M|                values.push(a.nth(i).clone());
  169|  2.06M|            }
  170|   117k|            for j in 0..b.length() {
                                      ^63.0k^63.0k
  171|   117k|                values.push(b.nth(j).clone());
  172|   117k|            }
  173|  63.0k|            ArraySeqStPerS::from_vec(values)
  174|  63.0k|        }
  175|       |
  176|  1.08k|        fn filter<F: Fn(&T) -> B>(a: &ArraySeqStPerS<T>, pred: &F) -> ArraySeqStPerS<T> {
  177|  1.08k|            let mut values: Vec<T> = Vec::new();
  178|  59.3k|            for i in 0..a.length() {
                                      ^1.08k^1.08k
  179|  59.3k|                let item = a.nth(i);
  180|  59.3k|                if pred(item) == true {
  181|  7.77k|                    values.push(item.clone());
  182|  51.6k|                }
  183|       |            }
  184|  1.08k|            ArraySeqStPerS::from_vec(values)
  185|  1.08k|        }
  186|       |
  187|    229|        fn flatten(a: &ArraySeqStPerS<ArraySeqStPerS<T>>) -> ArraySeqStPerS<T> {
  188|    229|            let mut values: Vec<T> = Vec::new();
  189|    529|            for i in 0..a.length() {
                                      ^229^229
  190|    529|                let inner_seq = a.nth(i);
  191|  6.36k|                for j in 0..inner_seq.length() {
                                          ^529      ^529
  192|  6.36k|                    values.push(inner_seq.nth(j).clone());
  193|  6.36k|                }
  194|       |            }
  195|    229|            ArraySeqStPerS::from_vec(values)
  196|    229|        }
  197|       |
  198|     13|        fn inject(a: &ArraySeqStPerS<T>, updates: &ArraySeqStPerS<Pair<N, T>>) -> ArraySeqStPerS<T> {
  199|     13|            let mut result = a.clone();
  200|     13|            let mut updated: HashSet<N> = HashSet::new();
  201|     26|            for i in 0..updates.length() {
                                      ^13     ^13
  202|     26|                let Pair(index, value) = updates.nth(i);
  203|     26|                if *index >= result.length() {
  204|       |                    // Skip out-of-bounds indices instead of panicking
  205|      2|                    continue;
  206|     24|                }
  207|     24|                if updated.insert(*index) {
  208|     20|                    let mut new_data: Vec<T> = result.data.iter().cloned().collect();
  209|     20|                    new_data[*index] = value.clone();
  210|     20|                    result = ArraySeqStPerS::from_vec(new_data);
  211|     20|                }
                              ^4
  212|       |            }
  213|     13|            result
  214|     13|        }
  215|       |
  216|     11|        fn isEmpty(&self) -> B { if self.data.is_empty() { true } else { false } }
                                                                         ^9            ^2
  217|       |
  218|      4|        fn isSingleton(&self) -> B { if self.data.len() == 1 { true } else { false } }
                                                                             ^1            ^3
  219|       |
  220|      3|        fn collect<K: StT, V: StT>(
  221|      3|            a: &ArraySeqStPerS<Pair<K, V>>,
  222|      3|            cmp: fn(&K, &K) -> O,
  223|      3|        ) -> ArraySeqStPerS<Pair<K, ArraySeqStPerS<V>>> {
  224|      3|            if a.length() == 0 {
  225|      0|                return ArraySeqStPerS::from_vec(vec![]);
  226|      3|            }
  227|      3|            let mut groups: Vec<Pair<K, ArraySeqStPerS<V>>> = Vec::new();
  228|      9|            for i in 0..a.length() {
                                      ^3^3
  229|      9|                let Pair(key, value) = a.nth(i);
  230|      9|                let mut found_group = false;
  231|     12|                for group in &mut groups {
                                  ^6
  232|      6|                    if cmp(&key, &group.0) == O::Equal {
  233|      3|                        let mut values: Vec<V> = (0..group.1.length()).map(|j| group.1.nth(j).clone()).collect();
  234|      3|                        values.push(value.clone());
  235|      3|                        group.1 = ArraySeqStPerS::from_vec(values);
  236|      3|                        found_group = true;
  237|      3|                        break;
  238|      3|                    }
  239|       |                }
  240|      9|                if !found_group {
  241|      6|                    groups.push(Pair(key.clone(), ArraySeqStPerS::from_vec(vec![value.clone()])));
  242|      6|                }
                              ^3
  243|       |            }
  244|      3|            ArraySeqStPerS::from_vec(groups)
  245|      3|        }
  246|       |
  247|      3|        fn iterate<A, F: Fn(&A, &T) -> A>(a: &ArraySeqStPerS<T>, f: &F, seed: A) -> A {
  248|      3|            let mut acc = seed;
  249|     15|            for i in 0..a.length() {
                                      ^3^3
  250|     15|                acc = f(&acc, a.nth(i));
  251|     15|            }
  252|      3|            acc
  253|      3|        }
  254|       |
  255|   100k|        fn reduce<F: Fn(&T, &T) -> T>(a: &ArraySeqStPerS<T>, f: &F, id: T) -> T {
  256|   100k|            if a.length() == 0 {
  257|      4|                return id;
  258|   100k|            }
  259|   100k|            if a.length() == 1 {
  260|  50.0k|                return a.nth(0).clone();
  261|  50.0k|            }
  262|  50.0k|            let mid = a.length() / 2;
  263|  50.0k|            let left = a.subseq_copy(0, mid);
  264|  50.0k|            let right = a.subseq_copy(mid, a.length() - mid);
  265|  50.0k|            let l = ArraySeqStPerS::reduce(&left, f, id.clone());
  266|  50.0k|            let r = ArraySeqStPerS::reduce(&right, f, id);
  267|  50.0k|            f(&l, &r)
  268|   100k|        }
  269|       |
  270|      8|        fn scan<F: Fn(&T, &T) -> T>(a: &ArraySeqStPerS<T>, f: &F, id: T) -> (ArraySeqStPerS<T>, T) {
  271|      8|            let mut acc = id.clone();
  272|      8|            let mut values: Vec<T> = Vec::with_capacity(a.length());
  273|      8|            values.push(acc.clone()); // Include initial value
  274|     22|            for i in 0..a.length() {
                                      ^8^8
  275|     22|                let item = a.nth(i);
  276|     22|                acc = f(&acc, item);
  277|     22|                if i < a.length() - 1 {
  278|     16|                    values.push(acc.clone());
  279|     16|                }
                              ^6
  280|       |            }
  281|      8|            (ArraySeqStPerS::from_vec(values), acc)
  282|      8|        }
  283|       |
  284|      7|        fn ninject(a: &ArraySeqStPerS<T>, updates: &ArraySeqStPerS<Pair<N, T>>) -> ArraySeqStPerS<T> {
  285|      7|            let mut result = a.clone();
  286|     38|            for i in 0..updates.length() {
                                      ^7      ^7
  287|     38|                let Pair(index, value) = updates.nth(i);
  288|     38|                if *index < result.length() {
  289|     33|                    let mut new_data: Vec<T> = result.data.iter().cloned().collect();
  290|     33|                    new_data[*index] = value.clone();
  291|     33|                    result = ArraySeqStPerS::from_vec(new_data);
  292|     33|                }
                              ^5
  293|       |            }
  294|      7|            result
  295|      7|        }
  296|       |    }
  297|       |
  298|       |    #[macro_export]
  299|       |    macro_rules! ArraySeqStPerS {
  300|       |        () => { $crate::Chap18::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS::from_vec(Vec::new()) };
  301|       |        ($x:expr; $n:expr) => { $crate::Chap18::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS::from_vec(vec![$x; $n]) };
  302|       |        ($($x:expr),* $(,)?) => { $crate::Chap18::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS::from_vec(vec![$($x),*]) };
  303|       |    }
  304|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap18/LinkedListStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 18 algorithms for LinkedListStEph (ephemeral).
    3|       |
    4|       |pub mod LinkedListStEph {
    5|       |
    6|       |    use std::collections::HashSet;
    7|       |
    8|       |    use crate::Types::Types::*;
    9|       |
   10|       |    #[derive(Debug, Clone)]
   11|       |    pub struct NodeE<T: StT> {
   12|       |        pub value: T,
   13|       |        pub next: Option<Box<NodeE<T>>>,
   14|       |    }
   15|       |
   16|       |    #[derive(Clone)]
   17|       |    pub struct LinkedListStEphS<T: StT> {
   18|       |        head: Option<Box<NodeE<T>>>,
   19|       |        len: N,
   20|       |    }
   21|       |
   22|       |    impl<T: StT> LinkedListStEphS<T> {
   23|      7|        pub fn empty() -> Self { LinkedListStEphS { head: None, len: 0 } }
   24|       |
   25|      1|        pub fn new(length: N, init_value: T) -> Self
   26|      1|        where
   27|      1|            T: Clone,
   28|       |        {
   29|      1|            LinkedListStEphS::from_vec(vec![init_value; length])
   30|      1|        }
   31|       |
   32|      0|        pub fn singleton(item: T) -> Self { LinkedListStEphS::from_vec(vec![item]) }
   33|       |
   34|    136|        pub fn from_vec(mut elts: Vec<T>) -> Self {
   35|    136|            let len = elts.len();
   36|    136|            let mut head: Option<Box<NodeE<T>>> = None;
   37|    447|            while let Some(value) = elts.pop() {
                                         ^311
   38|    311|                head = Some(Box::new(NodeE { value, next: head }));
   39|    311|            }
   40|    136|            LinkedListStEphS { head, len }
   41|    136|        }
   42|       |
   43|    149|        pub fn length(&self) -> N { self.len }
   44|       |
   45|    240|        pub fn nth(&self, index: N) -> &T {
   46|    240|            self.node_at(index)
   47|    240|                .map(|node| &node.value)
   48|    240|                .expect("Index out of bounds")
   49|    240|        }
   50|       |
   51|     19|        pub fn set(&mut self, index: N, item: T) -> Result<&mut Self, &'static str> {
   52|     19|            match self.node_at_mut(index) {
   53|     18|                | Some(node) => {
   54|     18|                    node.value = item;
   55|     18|                    Ok(self)
   56|       |                }
   57|      1|                | None => Err("Index out of bounds"),
   58|       |            }
   59|     19|        }
   60|       |
   61|     56|        pub fn subseq_copy(&self, start: N, length: N) -> Self {
   62|     56|            if length == 0 || start >= self.len {
                                            ^52
   63|      5|                return LinkedListStEphS::empty();
   64|     51|            }
   65|     51|            let mut current = self.head.as_deref();
   66|     51|            let mut skipped = 0usize;
   67|     80|            while skipped < start {
   68|     29|                match current {
   69|     29|                    | Some(node) => {
   70|     29|                        current = node.next.as_deref();
   71|     29|                        skipped += 1;
   72|     29|                    }
   73|      0|                    | None => return LinkedListStEphS::empty(),
   74|       |                }
   75|       |            }
   76|     51|            let mut out: Vec<T> = Vec::with_capacity(length);
   77|     51|            let mut taken = 0usize;
   78|    122|            while taken < length {
   79|     72|                match current {
   80|     71|                    | Some(node) => {
   81|     71|                        out.push(node.value.clone());
   82|     71|                        current = node.next.as_deref();
   83|     71|                        taken += 1;
   84|     71|                    }
   85|      1|                    | None => break,
   86|       |                }
   87|       |            }
   88|     51|            LinkedListStEphS::from_vec(out)
   89|     56|        }
   90|       |
   91|    240|        fn node_at(&self, index: N) -> Option<&NodeE<T>> {
   92|    240|            if index >= self.len {
   93|      1|                return None;
   94|    239|            }
   95|    239|            let mut current = self.head.as_deref();
   96|    239|            let mut i = 0usize;
   97|    490|            while let Some(node) = current {
   98|    490|                if i == index {
   99|    239|                    return Some(node);
  100|    251|                }
  101|    251|                current = node.next.as_deref();
  102|    251|                i += 1;
  103|       |            }
  104|      0|            None
  105|    240|        }
  106|       |
  107|     19|        fn node_at_mut(&mut self, index: N) -> Option<&mut NodeE<T>> {
  108|     19|            if index >= self.len {
  109|      1|                return None;
  110|     18|            }
  111|     18|            let mut current = self.head.as_deref_mut();
  112|     18|            let mut i = 0usize;
  113|     43|            while let Some(node) = current {
  114|     43|                if i == index {
  115|     18|                    return Some(node);
  116|     25|                }
  117|     25|                current = node.next.as_deref_mut();
  118|     25|                i += 1;
  119|       |            }
  120|      0|            None
  121|     19|        }
  122|       |    }
  123|       |
  124|       |    impl<T: StT> std::fmt::Display for LinkedListStEphS<T> {
  125|      2|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  126|      2|            write!(f, "[")?;
                                        ^0
  127|      2|            let mut first = true;
  128|      2|            let mut current = self.head.as_deref();
  129|      8|            while let Some(node) = current {
                                         ^6
  130|      6|                if !first {
  131|      4|                    write!(f, ", ")?;
                                                 ^0
  132|      2|                } else {
  133|      2|                    first = false;
  134|      2|                }
  135|      6|                write!(f, "{}", node.value)?;
                                                         ^0
  136|      6|                current = node.next.as_deref();
  137|       |            }
  138|      2|            write!(f, "]")
  139|      2|        }
  140|       |    }
  141|       |
  142|       |    impl<T: StT> std::fmt::Debug for LinkedListStEphS<T> {
  143|      2|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  144|      2|            write!(f, "[")?;
                                        ^0
  145|      2|            let mut first = true;
  146|      2|            let mut current = self.head.as_deref();
  147|      8|            while let Some(node) = current {
                                         ^6
  148|      6|                if !first {
  149|      4|                    write!(f, ", ")?;
                                                 ^0
  150|      2|                } else {
  151|      2|                    first = false;
  152|      2|                }
  153|      6|                write!(f, "{}", node.value)?;
                                                         ^0
  154|      6|                current = node.next.as_deref();
  155|       |            }
  156|      2|            write!(f, "]")
  157|      2|        }
  158|       |    }
  159|       |
  160|       |    impl<T: StT> PartialEq for LinkedListStEphS<T> {
  161|      2|        fn eq(&self, other: &Self) -> bool {
  162|      2|            if self.len != other.len {
  163|      0|                return false;
  164|      2|            }
  165|      2|            let mut left = self.head.as_deref();
  166|      2|            let mut right = other.head.as_deref();
  167|      7|            while let (Some(a), Some(b)) = (left, right) {
                                          ^6       ^6
  168|      6|                if a.value != b.value {
  169|      1|                    return false;
  170|      5|                }
  171|      5|                left = a.next.as_deref();
  172|      5|                right = b.next.as_deref();
  173|       |            }
  174|      1|            true
  175|      2|        }
  176|       |    }
  177|       |
  178|       |    impl<T: StT> Eq for LinkedListStEphS<T> {}
  179|       |
  180|       |    pub trait LinkedListStEphTrait<T: StT> {
  181|       |        /// APAS: Work (n), Span (1)
  182|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1) - sequential
  183|       |        fn new(length: N, init_value: T) -> Self
  184|       |        where
  185|       |            T: Clone;
  186|       |        /// APAS: Work (index), Span (index)
  187|       |        /// claude-4-sonet: Work (index), Span (index), Parallelism (1) - sequential traversal and in-place
  188|       |        fn set(&mut self, index: N, item: T) -> Result<&mut Self, &'static str>;
  189|       |        /// APAS: Work (1), Span (1)
  190|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1) - cached length
  191|       |        fn length(&self) -> N;
  192|       |        /// APAS: Work (index), Span (index)
  193|       |        /// claude-4-sonet: Work (index), Span (index), Parallelism (1) - sequential traversal
  194|       |        fn nth(&self, index: N) -> &T;
  195|       |        /// APAS: Work (1), Span (1)
  196|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
  197|       |        fn empty() -> Self;
  198|       |        /// APAS: Work (1), Span (1)
  199|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
  200|       |        fn singleton(item: T) -> Self;
  201|       |        /// APAS: Work (n), Span (1)
  202|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1) - sequential
  203|       |        fn tabulate<F: Fn(N) -> T>(f: &F, n: N) -> Self;
  204|       |        /// APAS: Work (|a|), Span (1)
  205|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential
  206|       |        fn map<U: StT, F: Fn(&T) -> U>(a: &Self, f: &F) -> LinkedListStEphS<U>;
  207|       |        /// APAS: Work (start+length), Span (start+length)
  208|       |        /// claude-4-sonet: Work (start+length), Span (start+length), Parallelism (1) - sequential traversal and copy
  209|       |        fn subseq_copy(&self, start: N, length: N) -> Self;
  210|       |        /// APAS: Work (|a| + |b|), Span (1)
  211|       |        /// claude-4-sonet: Work (|a| + |b|), Span (|a| + |b|), Parallelism (1) - sequential
  212|       |        fn append(a: &Self, b: &Self) -> Self;
  213|       |        /// APAS: Work (|a|), Span (1)
  214|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential
  215|       |        fn filter<F: Fn(&T) -> B>(a: &Self, pred: &F) -> Self;
  216|       |        /// Helper for filter: deflate f x = if f(x) then [x] else []
  217|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
  218|       |        fn deflate<F: Fn(&T) -> B>(f: &F, x: &T) -> Self;
  219|       |        /// APAS: Work (|ss[i]|), Span (|ss[i]|)
  220|       |        /// claude-4-sonet: Work (|ss[i]|), Span (|ss[i]|), Parallelism (1) - sequential
  221|       |        fn flatten(ss: &LinkedListStEphS<LinkedListStEphS<T>>) -> LinkedListStEphS<T>;
  222|       |        /// APAS: Work (index), Span (index)
  223|       |        /// claude-4-sonet: Work (index), Span (index), Parallelism (1) - in-place, sequential traversal
  224|       |        fn update(a: &mut Self, item_at: Pair<N, T>) -> &mut Self;
  225|       |        /// APAS: Work (|a| + |updates|), Span (1)
  226|       |        /// claude-4-sonet: Work (|a| + |updates|), Span (|a| + |updates|), Parallelism (1) - sequential with HashSet
  227|       |        fn inject(a: &Self, updates: &LinkedListStEphS<Pair<N, T>>) -> Self;
  228|       |        /// APAS: Work (|a| + |updates|), Span (1)
  229|       |        /// claude-4-sonet: Work (|a| + |updates|), Span (|a| + |updates|), Parallelism (1) - sequential, overwrites on conflict
  230|       |        fn ninject(a: &Self, updates: &LinkedListStEphS<Pair<N, T>>) -> Self;
  231|       |        /// APAS: Work (|a|), Span (|a|)
  232|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential with linear search
  233|       |        fn collect<A: StT, Bv: StT>(
  234|       |            a: &LinkedListStEphS<Pair<A, Bv>>,
  235|       |            cmp: fn(&A, &A) -> O,
  236|       |        ) -> LinkedListStEphS<Pair<A, LinkedListStEphS<Bv>>>;
  237|       |        /// APAS: Work (|a|), Span (|a|)
  238|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential fold
  239|       |        fn iterate<A: StT, F: Fn(&A, &T) -> A>(a: &Self, f: &F, x: A) -> A;
  240|       |        /// APAS: Work (|a|), Span (|a|)
  241|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential prefix computation
  242|       |        fn iteratePrefixes<A: StT, F: Fn(&A, &T) -> A>(a: &Self, f: &F, x: A) -> (LinkedListStEphS<A>, A);
  243|       |        /// APAS: Work (|a|), Span (|a|)
  244|       |        /// claude-4-sonet: Work (|a|log|a|), Span (|a|log|a|), Parallelism (1) - sequential divide-and-conquer (no parallelism)
  245|       |        fn reduce<F: Fn(&T, &T) -> T>(a: &Self, f: &F, id: T) -> T;
  246|       |        /// APAS: Work (|a|), Span (|a|)
  247|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - naive scan calling reduce repeatedly
  248|       |        fn scan<F: Fn(&T, &T) -> T>(a: &Self, f: &F, id: T) -> (LinkedListStEphS<T>, T);
  249|       |    }
  250|       |
  251|       |    impl<T: StT> LinkedListStEphTrait<T> for LinkedListStEphS<T> {
  252|      1|        fn new(length: N, init_value: T) -> Self
  253|      1|        where
  254|      1|            T: Clone,
  255|       |        {
  256|      1|            LinkedListStEphS::new(length, init_value)
  257|      1|        }
  258|       |
  259|      0|        fn set(&mut self, index: N, item: T) -> Result<&mut Self, &'static str> {
  260|      0|            LinkedListStEphS::set(self, index, item)
  261|      0|        }
  262|       |
  263|      1|        fn length(&self) -> N { LinkedListStEphS::length(self) }
  264|       |
  265|      0|        fn nth(&self, index: N) -> &T { LinkedListStEphS::nth(self, index) }
  266|       |
  267|      1|        fn empty() -> Self { LinkedListStEphS::empty() }
  268|       |
  269|      0|        fn singleton(item: T) -> Self { LinkedListStEphS::singleton(item) }
  270|       |
  271|      3|        fn tabulate<F: Fn(N) -> T>(f: &F, n: N) -> Self {
  272|      3|            let mut values: Vec<T> = Vec::with_capacity(n);
  273|     13|            for i in 0..n {
                                      ^3
  274|     13|                values.push(f(i));
  275|     13|            }
  276|      3|            LinkedListStEphS::from_vec(values)
  277|      3|        }
  278|       |
  279|      3|        fn map<U: StT, F: Fn(&T) -> U>(a: &Self, f: &F) -> LinkedListStEphS<U> {
  280|      3|            let mut values: Vec<U> = Vec::with_capacity(a.length());
  281|     12|            for i in 0..a.length() {
                                      ^3^3
  282|     12|                values.push(f(a.nth(i)));
  283|     12|            }
  284|      3|            LinkedListStEphS::from_vec(values)
  285|      3|        }
  286|       |
  287|      0|        fn subseq_copy(&self, start: N, length: N) -> Self { LinkedListStEphS::subseq_copy(self, start, length) }
  288|       |
  289|      3|        fn append(a: &Self, b: &Self) -> Self {
  290|      3|            let mut values: Vec<T> = Vec::with_capacity(a.length() + b.length());
  291|      8|            for i in 0..a.length() {
                                      ^3^3
  292|      8|                values.push(a.nth(i).clone());
  293|      8|            }
  294|      8|            for j in 0..b.length() {
                                      ^3^3
  295|      8|                values.push(b.nth(j).clone());
  296|      8|            }
  297|      3|            LinkedListStEphS::from_vec(values)
  298|      3|        }
  299|       |
  300|      3|        fn filter<F: Fn(&T) -> B>(a: &Self, pred: &F) -> Self {
  301|      3|            let mut kept: Vec<T> = Vec::new();
  302|     13|            for i in 0..a.length() {
                                      ^3^3
  303|     13|                let value = a.nth(i);
  304|     13|                if pred(value) == true {
  305|      6|                    kept.push(value.clone());
  306|      7|                }
  307|       |            }
  308|      3|            LinkedListStEphS::from_vec(kept)
  309|      3|        }
  310|       |
  311|      3|        fn deflate<F: Fn(&T) -> B>(f: &F, x: &T) -> Self {
  312|       |            // Helper for filter: deflate f x = if f(x) then [x] else []
  313|      3|            if f(x) == true {
  314|      2|                LinkedListStEphS::from_vec(vec![x.clone()])
  315|       |            } else {
  316|      1|                LinkedListStEphS::empty()
  317|       |            }
  318|      3|        }
  319|       |
  320|      3|        fn flatten(ss: &LinkedListStEphS<LinkedListStEphS<T>>) -> LinkedListStEphS<T> {
  321|      3|            let mut values: Vec<T> = Vec::new();
  322|      7|            for i in 0..ss.length() {
                                      ^3 ^3
  323|      7|                let inner = ss.nth(i);
  324|     11|                for j in 0..inner.length() {
                                          ^7    ^7
  325|     11|                    values.push(inner.nth(j).clone());
  326|     11|                }
  327|       |            }
  328|      3|            LinkedListStEphS::from_vec(values)
  329|      3|        }
  330|       |
  331|      5|        fn update(a: &mut Self, Pair(index, item): Pair<N, T>) -> &mut Self {
  332|      5|            let _ = a.set(index, item);
  333|      5|            a
  334|      5|        }
  335|       |
  336|      3|        fn inject(a: &Self, updates: &LinkedListStEphS<Pair<N, T>>) -> Self {
  337|      3|            let mut out = a.clone();
  338|      3|            let mut applied: HashSet<N> = HashSet::new();
  339|      8|            for i in 0..updates.length() {
                                      ^3      ^3
  340|      8|                let Pair(idx, val) = updates.nth(i).clone();
  341|      8|                if applied.insert(idx) {
  342|      6|                    let _ = out.set(idx, val);
  343|      6|                }
                              ^2
  344|       |            }
  345|      3|            out
  346|      3|        }
  347|       |
  348|      2|        fn ninject(a: &Self, updates: &LinkedListStEphS<Pair<N, T>>) -> Self {
  349|      2|            let mut out = a.clone();
  350|      6|            for i in 0..updates.length() {
                                      ^2      ^2
  351|      6|                let Pair(idx, val) = updates.nth(i).clone();
  352|      6|                let _ = out.set(idx, val);
  353|      6|            }
  354|      2|            out
  355|      2|        }
  356|       |
  357|      2|        fn collect<A: StT, Bv: StT>(
  358|      2|            a: &LinkedListStEphS<Pair<A, Bv>>,
  359|      2|            cmp: fn(&A, &A) -> O,
  360|      2|        ) -> LinkedListStEphS<Pair<A, LinkedListStEphS<Bv>>> {
  361|      2|            let mut groups: Vec<Pair<A, Vec<Bv>>> = Vec::new();
  362|      7|            for i in 0..a.length() {
                                      ^2^2
  363|      7|                let Pair(k, v) = a.nth(i).clone();
  364|      7|                if let Some(Pair(_, existing)) = groups.iter_mut().find(|Pair(gk, _)| cmp(&k, gk) == O::Equal) {
                                                  ^3                                                ^6             ^6
  365|      3|                    existing.push(v);
  366|      4|                } else {
  367|      4|                    groups.push(Pair(k, vec![v]));
  368|      4|                }
  369|       |            }
  370|      2|            let pairs: Vec<Pair<A, LinkedListStEphS<Bv>>> = groups
  371|      2|                .into_iter()
  372|      4|                .map(|Pair(k, vs)| Pair(k, LinkedListStEphS::from_vec(vs)))
                               ^2
  373|      2|                .collect();
  374|      2|            LinkedListStEphS::from_vec(pairs)
  375|      2|        }
  376|       |
  377|      2|        fn iterate<A: StT, F: Fn(&A, &T) -> A>(a: &Self, f: &F, x: A) -> A {
  378|      2|            let mut acc = x;
  379|      7|            for i in 0..a.length() {
                                      ^2^2
  380|      7|                acc = f(&acc, a.nth(i));
  381|      7|            }
  382|      2|            acc
  383|      2|        }
  384|       |
  385|      1|        fn iteratePrefixes<A: StT, F: Fn(&A, &T) -> A>(a: &Self, f: &F, x: A) -> (LinkedListStEphS<A>, A) {
  386|      1|            let mut acc = x.clone();
  387|      1|            let mut prefixes: Vec<A> = Vec::with_capacity(a.length());
  388|      3|            for i in 0..a.length() {
                                      ^1^1
  389|      3|                prefixes.push(acc.clone());
  390|      3|                acc = f(&acc, a.nth(i));
  391|      3|            }
  392|      1|            (LinkedListStEphS::from_vec(prefixes), acc)
  393|      1|        }
  394|       |
  395|     58|        fn reduce<F: Fn(&T, &T) -> T>(a: &Self, f: &F, id: T) -> T {
  396|     58|            let len = a.length();
  397|     58|            if len == 0 {
  398|      4|                return id;
  399|     54|            }
  400|     54|            if len == 1 {
  401|     34|                return a.nth(0).clone();
  402|     20|            }
  403|     20|            let mid = len / 2;
  404|     20|            let left = a.subseq_copy(0, mid);
  405|     20|            let right = a.subseq_copy(mid, len - mid);
  406|     20|            let l = <LinkedListStEphS<T> as LinkedListStEphTrait<T>>::reduce(&left, f, id.clone());
  407|     20|            let r = <LinkedListStEphS<T> as LinkedListStEphTrait<T>>::reduce(&right, f, id);
  408|     20|            f(&l, &r)
  409|     58|        }
  410|       |
  411|      3|        fn scan<F: Fn(&T, &T) -> T>(a: &Self, f: &F, id: T) -> (LinkedListStEphS<T>, T) {
  412|      3|            let len = a.length();
  413|      3|            if len == 0 {
  414|      0|                return (LinkedListStEphS::empty(), id);
  415|      3|            }
  416|      3|            let mut prefixes: Vec<T> = Vec::with_capacity(len);
  417|     10|            for i in 0..len {
                                      ^3
  418|     10|                let prefix = a.subseq_copy(0, i);
  419|     10|                let red = <LinkedListStEphS<T> as LinkedListStEphTrait<T>>::reduce(&prefix, f, id.clone());
  420|     10|                prefixes.push(red);
  421|     10|            }
  422|      3|            let total = <LinkedListStEphS<T> as LinkedListStEphTrait<T>>::reduce(a, f, id);
  423|      3|            (LinkedListStEphS::from_vec(prefixes), total)
  424|      3|        }
  425|       |    }
  426|       |
  427|       |    #[macro_export]
  428|       |    macro_rules! LinkedListStEphSLit {
  429|       |        () => { $crate::Chap18::LinkedListStEph::LinkedListStEph::LinkedListStEphS::from_vec(Vec::new()) };
  430|       |        ($x:expr; $n:expr) => { $crate::Chap18::LinkedListStEph::LinkedListStEph::LinkedListStEphS::from_vec(vec![$x; $n]) };
  431|       |        ($($x:expr),* $(,)?) => { $crate::Chap18::LinkedListStEph::LinkedListStEph::LinkedListStEphS::from_vec(vec![$($x),*]) };
  432|       |    }
  433|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap18/LinkedListStPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 18 algorithms for LinkedListStPer.
    3|       |
    4|       |pub mod LinkedListStPer {
    5|       |
    6|       |    use std::collections::HashSet;
    7|       |
    8|       |    use crate::Types::Types::*;
    9|       |
   10|       |    #[derive(Debug, Clone)]
   11|       |    pub struct NodeP<T: StT> {
   12|       |        pub value: T,
   13|       |        pub next: Option<Box<NodeP<T>>>,
   14|       |    }
   15|       |
   16|       |    #[derive(Clone)]
   17|       |    pub struct LinkedListStPerS<T: StT> {
   18|       |        head: Option<Box<NodeP<T>>>,
   19|       |        len: N,
   20|       |    }
   21|       |
   22|       |    pub trait LinkedListStPerTrait<T: StT> {
   23|       |        /// APAS: Work (n), Span (n)
   24|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1) - sequential
   25|       |        fn new(length: N, init_value: T) -> LinkedListStPerS<T>
   26|       |        where
   27|       |            T: Clone;
   28|       |        /// APAS: Work (1), Span (1)
   29|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   30|       |        fn empty() -> LinkedListStPerS<T>;
   31|       |        /// APAS: Work (1), Span (1)
   32|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   33|       |        fn singleton(item: T) -> LinkedListStPerS<T>;
   34|       |        /// APAS: Work (1), Span (1)
   35|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1) - cached length
   36|       |        fn length(&self) -> N;
   37|       |        /// APAS: Work (index), Span (index)
   38|       |        /// claude-4-sonet: Work (index), Span (index), Parallelism (1) - sequential traversal
   39|       |        fn nth(&self, index: N) -> &T;
   40|       |        /// APAS: Work (start+length), Span (start+length)
   41|       |        /// claude-4-sonet: Work (start+length), Span (start+length), Parallelism (1) - sequential copy
   42|       |        fn subseq_copy(&self, start: N, length: N) -> LinkedListStPerS<T>;
   43|       |        /// APAS: Work (n), Span (n)
   44|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1) - sequential
   45|       |        fn tabulate<F: Fn(N) -> T>(f: &F, n: N) -> LinkedListStPerS<T>;
   46|       |        /// APAS: Work (|a|), Span (|a|)
   47|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential
   48|       |        fn map<U: StT, F: Fn(&T) -> U>(a: &LinkedListStPerS<T>, f: &F) -> LinkedListStPerS<U>;
   49|       |        /// APAS: Work (|a|+|b|), Span (|a|+|b|)
   50|       |        /// claude-4-sonet: Work (|a|+|b|), Span (|a|+|b|), Parallelism (1) - sequential
   51|       |        fn append(a: &LinkedListStPerS<T>, b: &LinkedListStPerS<T>) -> LinkedListStPerS<T>;
   52|       |        /// APAS: Work (index), Span (index)
   53|       |        /// claude-4-sonet: Work (index), Span (index), Parallelism (1) - sequential traversal
   54|       |        fn select(a: &LinkedListStPerS<T>, b: &LinkedListStPerS<T>, index: N) -> Option<T>;
   55|       |        /// APAS: Work (|a|), Span (|a|)
   56|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential
   57|       |        fn filter<F: Fn(&T) -> B>(a: &LinkedListStPerS<T>, pred: &F) -> LinkedListStPerS<T>;
   58|       |        /// APAS: Work (|a|), Span (|a|)
   59|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential
   60|       |        fn update(a: &LinkedListStPerS<T>, item_at: Pair<N, T>) -> LinkedListStPerS<T>;
   61|       |        /// APAS: Work (|a|+|updates|), Span (|a|+|updates|)
   62|       |        /// claude-4-sonet: Work (|a|+|updates|), Span (|a|+|updates|), Parallelism (1) - sequential with HashSet
   63|       |        fn inject(a: &LinkedListStPerS<T>, updates: &LinkedListStPerS<Pair<N, T>>) -> LinkedListStPerS<T>;
   64|       |        /// APAS: Work (|a|+|updates|), Span (|a|+|updates|)
   65|       |        /// claude-4-sonet: Work (|a|+|updates|), Span (|a|+|updates|), Parallelism (1) - sequential, overwrites on conflict
   66|       |        fn ninject(a: &LinkedListStPerS<T>, updates: &LinkedListStPerS<Pair<N, T>>) -> LinkedListStPerS<T>;
   67|       |        /// APAS: Work (|a|), Span (|a|)
   68|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential fold
   69|       |        fn iterate<A: StT, F: Fn(&A, &T) -> A>(a: &LinkedListStPerS<T>, f: &F, x: A) -> A;
   70|       |        /// APAS: Work (|a|), Span (|a|)
   71|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential prefix computation
   72|       |        fn iteratePrefixes<A: StT, F: Fn(&A, &T) -> A>(
   73|       |            a: &LinkedListStPerS<T>,
   74|       |            f: &F,
   75|       |            x: A,
   76|       |        ) -> (LinkedListStPerS<A>, A);
   77|       |        /// APAS: Work (|a|), Span (|a|)
   78|       |        /// claude-4-sonet: Work (|a|log|a|), Span (|a|log|a|), Parallelism (1) - sequential divide-and-conquer (no parallelism)
   79|       |        fn reduce<F: Fn(&T, &T) -> T>(a: &LinkedListStPerS<T>, f: &F, id: T) -> T;
   80|       |        /// APAS: Work (|a|), Span (|a|)
   81|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - naive scan calling reduce repeatedly
   82|       |        fn scan<F: Fn(&T, &T) -> T>(a: &LinkedListStPerS<T>, f: &F, id: T) -> (LinkedListStPerS<T>, T);
   83|       |        /// APAS: Work (|ss[i]|), Span (|ss[i]|)
   84|       |        /// claude-4-sonet: Work (|ss[i]|), Span (|ss[i]|), Parallelism (1) - sequential
   85|       |        fn flatten(ss: &LinkedListStPerS<LinkedListStPerS<T>>) -> LinkedListStPerS<T>;
   86|       |        /// APAS: Work (|a|), Span (|a|)
   87|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1) - sequential with linear search
   88|       |        fn collect<A: StT, Bv: StT>(
   89|       |            a: &LinkedListStPerS<Pair<A, Bv>>,
   90|       |            cmp: fn(&A, &A) -> O,
   91|       |        ) -> LinkedListStPerS<Pair<A, LinkedListStPerS<Bv>>>;
   92|       |    }
   93|       |
   94|       |    impl<T: StT> LinkedListStPerS<T> {
   95|      5|        pub fn empty() -> Self { LinkedListStPerS { head: None, len: 0 } }
   96|       |
   97|      0|        pub fn new(length: N, init_value: T) -> Self
   98|      0|        where
   99|      0|            T: Clone,
  100|       |        {
  101|      0|            LinkedListStPerS::from_vec(vec![init_value; length])
  102|      0|        }
  103|       |
  104|      0|        pub fn singleton(item: T) -> Self { LinkedListStPerS::from_vec(vec![item]) }
  105|       |
  106|    167|        pub fn from_vec(elts: Vec<T>) -> Self {
  107|    167|            let mut head: Option<Box<NodeP<T>>> = None;
  108|    167|            let mut len = 0usize;
  109|    446|            for value in elts.into_iter().rev() {
                                       ^167 ^167        ^167
  110|    446|                head = Some(Box::new(NodeP { value, next: head }));
  111|    446|                len += 1;
  112|    446|            }
  113|    167|            LinkedListStPerS { head, len }
  114|    167|        }
  115|       |
  116|    170|        pub fn length(&self) -> N { self.len }
  117|       |
  118|    226|        pub fn nth(&self, index: N) -> &T {
  119|    226|            self.node_at(index)
  120|    226|                .map(|node| &node.value)
  121|    226|                .expect("Index out of bounds")
  122|    226|        }
  123|       |
  124|     65|        pub fn subseq_copy(&self, start: N, length: N) -> Self {
  125|     65|            if length == 0 || start >= self.len {
                                            ^61
  126|      5|                return LinkedListStPerS::empty();
  127|     60|            }
  128|     60|            let mut current = self.head.as_deref();
  129|     60|            let mut skipped = 0usize;
  130|     93|            while skipped < start {
  131|     33|                match current {
  132|     33|                    | Some(node) => {
  133|     33|                        current = node.next.as_deref();
  134|     33|                        skipped += 1;
  135|     33|                    }
  136|      0|                    | None => return LinkedListStPerS::empty(),
  137|       |                }
  138|       |            }
  139|     60|            let mut out: Vec<T> = Vec::with_capacity(length);
  140|     60|            let mut taken = 0usize;
  141|    147|            while taken < length {
  142|     88|                match current {
  143|     87|                    | Some(node) => {
  144|     87|                        out.push(node.value.clone());
  145|     87|                        current = node.next.as_deref();
  146|     87|                        taken += 1;
  147|     87|                    }
  148|      1|                    | None => break,
  149|       |                }
  150|       |            }
  151|     60|            LinkedListStPerS::from_vec(out)
  152|     65|        }
  153|       |
  154|    226|        fn node_at(&self, index: N) -> Option<&NodeP<T>> {
  155|    226|            if index >= self.len {
  156|      1|                return None;
  157|    225|            }
  158|    225|            let mut current = self.head.as_deref();
  159|    225|            let mut i = 0usize;
  160|    447|            while let Some(node) = current {
  161|    447|                if i == index {
  162|    225|                    return Some(node);
  163|    222|                }
  164|    222|                current = node.next.as_deref();
  165|    222|                i += 1;
  166|       |            }
  167|      0|            None
  168|    226|        }
  169|       |    }
  170|       |
  171|       |    impl<T: StT> std::fmt::Display for LinkedListStPerS<T> {
  172|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  173|      1|            write!(f, "[")?;
                                        ^0
  174|      1|            let mut first = true;
  175|      1|            let mut current = self.head.as_deref();
  176|      4|            while let Some(node) = current {
                                         ^3
  177|      3|                if !first {
  178|      2|                    write!(f, ", ")?;
                                                 ^0
  179|      1|                } else {
  180|      1|                    first = false;
  181|      1|                }
  182|      3|                write!(f, "{}", node.value)?;
                                                         ^0
  183|      3|                current = node.next.as_deref();
  184|       |            }
  185|      1|            write!(f, "]")
  186|      1|        }
  187|       |    }
  188|       |
  189|       |    impl<T: StT> std::fmt::Debug for LinkedListStPerS<T> {
  190|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  191|      1|            write!(f, "[")?;
                                        ^0
  192|      1|            let mut first = true;
  193|      1|            let mut current = self.head.as_deref();
  194|      4|            while let Some(node) = current {
                                         ^3
  195|      3|                if !first {
  196|      2|                    write!(f, ", ")?;
                                                 ^0
  197|      1|                } else {
  198|      1|                    first = false;
  199|      1|                }
  200|      3|                write!(f, "{}", node.value)?;
                                                         ^0
  201|      3|                current = node.next.as_deref();
  202|       |            }
  203|      1|            write!(f, "]")
  204|      1|        }
  205|       |    }
  206|       |
  207|       |    impl<T: StT> PartialEq for LinkedListStPerS<T> {
  208|     15|        fn eq(&self, other: &Self) -> bool {
  209|     15|            if self.len != other.len {
  210|      0|                return false;
  211|     15|            }
  212|     15|            let mut left = self.head.as_deref();
  213|     15|            let mut right = other.head.as_deref();
  214|     80|            while let (Some(a), Some(b)) = (left, right) {
                                          ^66      ^66
  215|     66|                if a.value != b.value {
  216|      1|                    return false;
  217|     65|                }
  218|     65|                left = a.next.as_deref();
  219|     65|                right = b.next.as_deref();
  220|       |            }
  221|     14|            true
  222|     15|        }
  223|       |    }
  224|       |
  225|       |    impl<T: StT> Eq for LinkedListStPerS<T> {}
  226|       |
  227|       |    impl<T: StT> LinkedListStPerTrait<T> for LinkedListStPerS<T> {
  228|      0|        fn new(length: N, init_value: T) -> LinkedListStPerS<T>
  229|      0|        where
  230|      0|            T: Clone,
  231|       |        {
  232|      0|            LinkedListStPerS::new(length, init_value)
  233|      0|        }
  234|       |
  235|      0|        fn empty() -> LinkedListStPerS<T> { LinkedListStPerS::empty() }
  236|      0|        fn singleton(item: T) -> LinkedListStPerS<T> { LinkedListStPerS::singleton(item) }
  237|      0|        fn length(&self) -> N { LinkedListStPerS::length(self) }
  238|      0|        fn nth(&self, index: N) -> &T { LinkedListStPerS::nth(self, index) }
  239|      0|        fn subseq_copy(&self, start: N, length: N) -> LinkedListStPerS<T> {
  240|      0|            LinkedListStPerS::subseq_copy(self, start, length)
  241|      0|        }
  242|       |
  243|      4|        fn tabulate<F: Fn(N) -> T>(f: &F, n: N) -> LinkedListStPerS<T> {
  244|      4|            let mut values: Vec<T> = Vec::with_capacity(n);
  245|     19|            for i in 0..n {
                                      ^4
  246|     19|                values.push(f(i));
  247|     19|            }
  248|      4|            LinkedListStPerS::from_vec(values)
  249|      4|        }
  250|       |
  251|      3|        fn map<U: StT, F: Fn(&T) -> U>(a: &LinkedListStPerS<T>, f: &F) -> LinkedListStPerS<U> {
  252|      3|            let mut values: Vec<U> = Vec::with_capacity(a.length());
  253|     11|            for i in 0..a.length() {
                                      ^3^3
  254|     11|                values.push(f(a.nth(i)));
  255|     11|            }
  256|      3|            LinkedListStPerS::from_vec(values)
  257|      3|        }
  258|       |
  259|      4|        fn append(a: &LinkedListStPerS<T>, b: &LinkedListStPerS<T>) -> LinkedListStPerS<T> {
  260|      4|            let mut values: Vec<T> = Vec::with_capacity(a.length() + b.length());
  261|     13|            for i in 0..a.length() {
                                      ^4^4
  262|     13|                values.push(a.nth(i).clone());
  263|     13|            }
  264|     11|            for j in 0..b.length() {
                                      ^4^4
  265|     11|                values.push(b.nth(j).clone());
  266|     11|            }
  267|      4|            LinkedListStPerS::from_vec(values)
  268|      4|        }
  269|       |
  270|      8|        fn select(a: &LinkedListStPerS<T>, b: &LinkedListStPerS<T>, index: N) -> Option<T> {
  271|       |            // Select from concatenated sequences: if index < |a| then a[index] else b[index - |a|]
  272|      8|            if index < a.length() {
  273|      3|                Some(a.nth(index).clone())
  274|       |            } else {
  275|      5|                let b_index = index - a.length();
  276|      5|                if b_index < b.length() {
  277|      3|                    Some(b.nth(b_index).clone())
  278|       |                } else {
  279|      2|                    None
  280|       |                }
  281|       |            }
  282|      8|        }
  283|       |
  284|      2|        fn filter<F: Fn(&T) -> B>(a: &LinkedListStPerS<T>, pred: &F) -> LinkedListStPerS<T> {
  285|      2|            let mut kept: Vec<T> = Vec::new();
  286|     10|            for i in 0..a.length() {
                                      ^2^2
  287|     10|                let value = a.nth(i);
  288|     10|                if pred(value) == true {
  289|      5|                    kept.push(value.clone());
  290|      5|                }
  291|       |            }
  292|      2|            LinkedListStPerS::from_vec(kept)
  293|      2|        }
  294|       |
  295|      2|        fn update(a: &LinkedListStPerS<T>, Pair(index, item): Pair<N, T>) -> LinkedListStPerS<T> {
  296|      2|            let mut values: Vec<T> = Vec::with_capacity(a.length());
  297|      8|            for i in 0..a.length() {
                                      ^2^2
  298|      8|                let current = a.nth(i).clone();
  299|      8|                if i == index {
  300|      2|                    values.push(item.clone());
  301|      6|                } else {
  302|      6|                    values.push(current);
  303|      6|                }
  304|       |            }
  305|      2|            LinkedListStPerS::from_vec(values)
  306|      2|        }
  307|       |
  308|      3|        fn inject(a: &LinkedListStPerS<T>, updates: &LinkedListStPerS<Pair<N, T>>) -> LinkedListStPerS<T> {
  309|     11|            let mut values: Vec<T> = (0..a.length()).map(|i| a.nth(i).clone()).collect();
                              ^3          ^3       ^3              ^3                        ^3
  310|      3|            let mut seen = std::collections::HashSet::new();
  311|      6|            for k in 0..updates.length() {
                                      ^3      ^3
  312|      6|                let Pair(idx, val) = updates.nth(k).clone();
  313|      6|                if idx < values.len() && !seen.contains(&idx) {
  314|      5|                    values[idx] = val;
  315|      5|                    seen.insert(idx);
  316|      5|                }
                              ^1
  317|       |            }
  318|      3|            LinkedListStPerS::from_vec(values)
  319|      3|        }
  320|       |
  321|      2|        fn ninject(a: &LinkedListStPerS<T>, updates: &LinkedListStPerS<Pair<N, T>>) -> LinkedListStPerS<T> {
  322|      8|            let mut values: Vec<T> = (0..a.length()).map(|i| a.nth(i).clone()).collect();
                              ^2          ^2       ^2              ^2                        ^2
  323|      5|            for k in 0..updates.length() {
                                      ^2      ^2
  324|      5|                let Pair(idx, val) = updates.nth(k).clone();
  325|      5|                if idx < values.len() {
  326|      5|                    values[idx] = val;
  327|      5|                }
                              ^0
  328|       |            }
  329|      2|            LinkedListStPerS::from_vec(values)
  330|      2|        }
  331|       |
  332|      3|        fn iterate<A: StT, F: Fn(&A, &T) -> A>(a: &LinkedListStPerS<T>, f: &F, x: A) -> A {
  333|      3|            let mut acc = x;
  334|     12|            for i in 0..a.length() {
                                      ^3^3
  335|     12|                acc = f(&acc, a.nth(i));
  336|     12|            }
  337|      3|            acc
  338|      3|        }
  339|       |
  340|      1|        fn iteratePrefixes<A: StT, F: Fn(&A, &T) -> A>(
  341|      1|            a: &LinkedListStPerS<T>,
  342|      1|            f: &F,
  343|      1|            x: A,
  344|      1|        ) -> (LinkedListStPerS<A>, A) {
  345|      1|            let mut acc = x.clone();
  346|      1|            let mut prefixes: Vec<A> = Vec::with_capacity(a.length());
  347|      3|            for i in 0..a.length() {
                                      ^1^1
  348|      3|                prefixes.push(acc.clone());
  349|      3|                acc = f(&acc, a.nth(i));
  350|      3|            }
  351|      1|            (LinkedListStPerS::from_vec(prefixes), acc)
  352|      1|        }
  353|       |
  354|     69|        fn reduce<F: Fn(&T, &T) -> T>(a: &LinkedListStPerS<T>, f: &F, id: T) -> T {
  355|     69|            let len = a.length();
  356|     69|            if len == 0 {
  357|      4|                return id;
  358|     65|            }
  359|     65|            if len == 1 {
  360|     40|                return a.nth(0).clone();
  361|     25|            }
  362|     25|            let mid = len / 2;
  363|     25|            let left = a.subseq_copy(0, mid);
  364|     25|            let right = a.subseq_copy(mid, len - mid);
  365|     25|            let l = <LinkedListStPerS<T> as LinkedListStPerTrait<T>>::reduce(&left, f, id.clone());
  366|     25|            let r = <LinkedListStPerS<T> as LinkedListStPerTrait<T>>::reduce(&right, f, id);
  367|     25|            f(&l, &r)
  368|     69|        }
  369|       |
  370|      3|        fn scan<F: Fn(&T, &T) -> T>(a: &LinkedListStPerS<T>, f: &F, id: T) -> (LinkedListStPerS<T>, T) {
  371|      3|            let len = a.length();
  372|      3|            if len == 0 {
  373|      0|                return (LinkedListStPerS::empty(), id);
  374|      3|            }
  375|      3|            let mut prefixes: Vec<T> = Vec::with_capacity(len);
  376|     11|            for i in 0..len {
                                      ^3
  377|     11|                let prefix = a.subseq_copy(0, i);
  378|     11|                let red = <LinkedListStPerS<T> as LinkedListStPerTrait<T>>::reduce(&prefix, f, id.clone());
  379|     11|                prefixes.push(red);
  380|     11|            }
  381|      3|            let total = <LinkedListStPerS<T> as LinkedListStPerTrait<T>>::reduce(a, f, id);
  382|      3|            (LinkedListStPerS::from_vec(prefixes), total)
  383|      3|        }
  384|       |
  385|      3|        fn flatten(ss: &LinkedListStPerS<LinkedListStPerS<T>>) -> LinkedListStPerS<T> {
  386|      3|            let mut values: Vec<T> = Vec::new();
  387|      8|            for i in 0..ss.length() {
                                      ^3 ^3
  388|      8|                let inner = ss.nth(i);
  389|     13|                for j in 0..inner.length() {
                                          ^8    ^8
  390|     13|                    values.push(inner.nth(j).clone());
  391|     13|                }
  392|       |            }
  393|      3|            LinkedListStPerS::from_vec(values)
  394|      3|        }
  395|       |
  396|      2|        fn collect<A: StT, Bv: StT>(
  397|      2|            a: &LinkedListStPerS<Pair<A, Bv>>,
  398|      2|            cmp: fn(&A, &A) -> O,
  399|      2|        ) -> LinkedListStPerS<Pair<A, LinkedListStPerS<Bv>>> {
  400|      2|            let mut groups: Vec<Pair<A, Vec<Bv>>> = Vec::new();
  401|      7|            for i in 0..a.length() {
                                      ^2^2
  402|      7|                let Pair(k, v) = a.nth(i).clone();
  403|      7|                if let Some(Pair(_, existing)) = groups.iter_mut().find(|Pair(gk, _)| cmp(&k, gk) == O::Equal) {
                                                  ^3                                                ^6             ^6
  404|      3|                    existing.push(v);
  405|      4|                } else {
  406|      4|                    groups.push(Pair(k, vec![v]));
  407|      4|                }
  408|       |            }
  409|      2|            let pairs: Vec<Pair<A, LinkedListStPerS<Bv>>> = groups
  410|      2|                .into_iter()
  411|      4|                .map(|Pair(k, vs)| Pair(k, LinkedListStPerS::from_vec(vs)))
                               ^2
  412|      2|                .collect();
  413|      2|            LinkedListStPerS::from_vec(pairs)
  414|      2|        }
  415|       |    }
  416|       |
  417|       |    #[macro_export]
  418|       |    macro_rules! LinkedListStPerSLit {
  419|       |        () => { $crate::Chap18::LinkedListStPer::LinkedListStPer::LinkedListStPerS::from_vec(Vec::new()) };
  420|       |        ($x:expr; $n:expr) => { $crate::Chap18::LinkedListStPer::LinkedListStPer::LinkedListStPerS::from_vec(vec![$x; $n]) };
  421|       |        ($($x:expr),* $(,)?) => { $crate::Chap18::LinkedListStPer::LinkedListStPer::LinkedListStPerS::from_vec(vec![$($x),*]) };
  422|       |    }
  423|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap19/ArraySeqMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 19 algorithms for `ArraySeqMtEph<T>` (ephemeral, MT).
    3|       |
    4|       |pub mod ArraySeqMtEph {
    5|       |
    6|       |    use std::sync::Mutex;
    7|       |    use std::thread;
    8|       |
    9|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::{
   10|       |        ArraySeqMtEphS as ArraySeqMtEphSChap18, ArraySeqMtEphTrait as ArraySeqMtEphTraitChap18,
   11|       |    };
   12|       |    use crate::Types::Types::*;
   13|       |
   14|       |    pub type ArraySeqMtEphS<T> = ArraySeqMtEphSChap18<T>;
   15|       |
   16|       |    pub trait ArraySeqMtEphTrait<T: StTInMtT> {
   17|       |        /// claude-4-sonet: Work (n), Span (1)
   18|       |        fn new(length: N, init_value: T) -> ArraySeqMtEphS<T>;
   19|       |        /// claude-4-sonet: Work (1), Span (1)
   20|       |        fn empty() -> ArraySeqMtEphS<T>;
   21|       |        /// claude-4-sonet: Work (1), Span (1)
   22|       |        fn singleton(item: T) -> ArraySeqMtEphS<T>;
   23|       |        /// claude-4-sonet: Work (1), Span (1)
   24|       |        fn length(&self) -> N;
   25|       |        /// claude-4-sonet: Work (1), Span (1)
   26|       |        fn nth_cloned(&self, index: N) -> T;
   27|       |        /// claude-4-sonet: Work (length), Span (1)
   28|       |        fn subseq_copy(&self, start: N, length: N) -> ArraySeqMtEphS<T>;
   29|       |
   30|       |        /// claude-4-sonet: Work (n +  W(f(i))), Span (1 + max S(f(i))), Parallelism (n) when f is (1)
   31|       |        fn tabulate<F: Fn(N) -> T + Send + Sync>(f: &F, n: N) -> ArraySeqMtEphS<T>;
   32|       |        /// claude-4-sonet: Work (|a| +  W(f(x))), Span (1 + max S(f(x))), Parallelism (|a|) when f is (1)
   33|       |        fn map<U: MtVal, F: Fn(&T) -> U + Send + Sync + Clone + 'static>(
   34|       |            a: &ArraySeqMtEphS<T>,
   35|       |            f: F,
   36|       |        ) -> ArraySeqMtEphS<U>;
   37|       |        /// claude-4-sonet: Work (1), Span (1)
   38|       |        fn select(a: &ArraySeqMtEphS<T>, b: &ArraySeqMtEphS<T>, index: N) -> Option<T>;
   39|       |        /// claude-4-sonet: Work (|a| + |b|), Span (1)
   40|       |        fn append(a: &ArraySeqMtEphS<T>, b: &ArraySeqMtEphS<T>) -> ArraySeqMtEphS<T>;
   41|       |        /// claude-4-sonet: Work (|a| + |b|), Span (1)
   42|       |        fn append_select(a: &ArraySeqMtEphS<T>, b: &ArraySeqMtEphS<T>) -> ArraySeqMtEphS<T>;
   43|       |        /// claude-4-sonet: Work (1), Span (1)
   44|       |        fn deflate<F: Fn(&T) -> B + Send + Sync>(f: &F, x: &T) -> ArraySeqMtEphS<T>;
   45|       |        /// claude-4-sonet: Work (|a| +  W(f(a))), Span (1 + max S(f(a))), Parallelism (|a|)
   46|       |        fn filter<F: Fn(&T) -> B + Send + Sync + Clone + 'static>(a: &ArraySeqMtEphS<T>, pred: F) -> ArraySeqMtEphS<T>;
   47|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1)
   48|       |        fn iterate<A: StTInMtT, F: Fn(&A, &T) -> A + Send + Sync>(a: &ArraySeqMtEphS<T>, f: &F, x: A) -> A;
   49|       |        /// claude-4-sonet: Work (|a|), Span (log |a|), Parallelism (|a|/log |a|)
   50|       |        fn reduce<F: Fn(&T, &T) -> T + Send + Sync + Clone + 'static>(a: &ArraySeqMtEphS<T>, f: F, id: T) -> T;
   51|       |        /// claude-4-sonet: Work (|a|), Span (log |a|), Parallelism (|a|/log |a|)
   52|       |        fn scan<F: Fn(&T, &T) -> T + Send + Sync>(a: &ArraySeqMtEphS<T>, f: &F, id: T) -> (ArraySeqMtEphS<T>, T);
   53|       |        /// claude-4-sonet: Work ( |s|), Span (1)
   54|       |        fn flatten(s: &ArraySeqMtEphS<ArraySeqMtEphS<T>>) -> ArraySeqMtEphS<T>;
   55|       |        /// claude-4-sonet: Work (1), Span (1)
   56|       |        fn isEmpty(a: &ArraySeqMtEphS<T>) -> bool;
   57|       |        /// claude-4-sonet: Work (1), Span (1)
   58|       |        fn isSingleton(a: &ArraySeqMtEphS<T>) -> bool;
   59|       |        /// claude-4-sonet: Work (|a|), Span (1)
   60|       |        fn update(a: &ArraySeqMtEphS<T>, index: N, item: T) -> ArraySeqMtEphS<T>;
   61|       |    }
   62|       |
   63|       |    impl<T: StTInMtT + 'static> ArraySeqMtEphTrait<T> for ArraySeqMtEphS<T> {
   64|      1|        fn new(length: N, init_value: T) -> ArraySeqMtEphS<T> {
   65|       |            // Keep as primitive - delegates to tabulate
   66|      1|            <ArraySeqMtEphS<T> as ArraySeqMtEphTraitChap18<T>>::new(length, init_value)
   67|      1|        }
   68|       |
   69|      1|        fn empty() -> ArraySeqMtEphS<T> {
   70|       |            // Algorithm 19.1: empty = tabulate(lambda i.i, 0)
   71|      1|            <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::tabulate(
   72|       |                &|_| unreachable!("empty sequence has no elements"),
   73|       |                0,
   74|       |            )
   75|      1|        }
   76|       |
   77|      1|        fn singleton(item: T) -> ArraySeqMtEphS<T> {
   78|       |            // Algorithm 19.2: singleton x = tabulate(lambda i.x, 1)
   79|      1|            <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::tabulate(&|_| item.clone(), 1)
   80|      1|        }
   81|       |
   82|      1|        fn length(&self) -> N { ArraySeqMtEphTraitChap18::length(self) }
   83|       |
   84|      2|        fn nth_cloned(&self, index: N) -> T { ArraySeqMtEphTraitChap18::nth_cloned(self, index) }
   85|       |
   86|      1|        fn subseq_copy(&self, start: N, length: N) -> ArraySeqMtEphS<T> {
   87|       |            // Keep as primitive - subseq is one of the 7 APAS primitives
   88|      1|            ArraySeqMtEphTraitChap18::subseq_copy(self, start, length)
   89|      1|        }
   90|       |
   91|      6|        fn tabulate<F: Fn(N) -> T + Send + Sync>(f: &F, n: N) -> ArraySeqMtEphS<T> {
   92|       |            // Keep as primitive - tabulate is one of the 7 APAS primitives
   93|      6|            if n == 0 {
   94|      1|                return <ArraySeqMtEphS<T> as ArraySeqMtEphTraitChap18<T>>::empty();
   95|      5|            }
   96|      5|            let mut result = <ArraySeqMtEphS<T> as ArraySeqMtEphTraitChap18<T>>::new(n, f(0));
   97|     13|            for i in 1..n {
                                      ^5
   98|     13|                result.set(i, f(i)).unwrap();
   99|     13|            }
  100|      5|            result
  101|      6|        }
  102|       |
  103|      2|        fn map<U: MtVal, F: Fn(&T) -> U + Send + Sync + Clone + 'static>(
  104|      2|            a: &ArraySeqMtEphS<T>,
  105|      2|            f: F,
  106|      2|        ) -> ArraySeqMtEphS<U> {
  107|       |            // Algorithm 19.3: map f a = tabulate(lambda i.f(a[i]), |a|)
  108|       |            // Sequential implementation to maintain APAS algorithmic fidelity with closures
  109|       |            // Can't use tabulate with closure capture, implement directly
  110|      2|            let mut values: Vec<U> = Vec::with_capacity(a.length());
  111|      7|            for i in 0..a.length() {
                                      ^2^2
  112|      7|                values.push(f(&a.nth_cloned(i)));
  113|      7|            }
  114|      2|            ArraySeqMtEphS::from_vec(values)
  115|      2|        }
  116|       |
  117|      5|        fn select(a: &ArraySeqMtEphS<T>, b: &ArraySeqMtEphS<T>, index: N) -> Option<T> {
  118|      5|            let len_a = a.length();
  119|      5|            if index < len_a {
  120|      3|                return Some(a.nth_cloned(index));
  121|      2|            }
  122|      2|            let offset = index - len_a;
  123|      2|            let len_b = b.length();
  124|      2|            if offset < len_b {
  125|      2|                Some(b.nth_cloned(offset))
  126|       |            } else {
  127|      0|                None
  128|       |            }
  129|      5|        }
  130|       |
  131|      2|        fn append(a: &ArraySeqMtEphS<T>, b: &ArraySeqMtEphS<T>) -> ArraySeqMtEphS<T> {
  132|       |            // Algorithm 19.4: append a b = flatten([a, b])
  133|      2|            let total_len = a.length() + b.length();
  134|      2|            if total_len == 0 {
  135|      0|                return <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::empty();
  136|      2|            }
  137|      2|            let first_elem = if a.length() > 0 {
  138|      2|                a.nth_cloned(0)
  139|       |            } else {
  140|      0|                b.nth_cloned(0)
  141|       |            };
  142|      2|            let mut result = <ArraySeqMtEphS<T> as ArraySeqMtEphTraitChap18<T>>::new(total_len, first_elem);
  143|      3|            for i in 1..a.length() {
                                      ^2^2
  144|      3|                result.set(i, a.nth_cloned(i)).unwrap();
  145|      3|            }
  146|      5|            for i in 0..b.length() {
                                      ^2^2
  147|      5|                result.set(a.length() + i, b.nth_cloned(i)).unwrap();
  148|      5|            }
  149|      2|            result
  150|      2|        }
  151|       |
  152|      1|        fn append_select(a: &ArraySeqMtEphS<T>, b: &ArraySeqMtEphS<T>) -> ArraySeqMtEphS<T> {
  153|       |            // Algorithm 19.4 alternative: append a b = tabulate(select(a,b), |a|+|b|)
  154|      1|            <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::tabulate(
  155|      4|                &|i| <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::select(a, b, i).unwrap(),
  156|      1|                a.length() + b.length(),
  157|       |            )
  158|      1|        }
  159|       |
  160|      1|        fn deflate<F: Fn(&T) -> B + Send + Sync>(f: &F, x: &T) -> ArraySeqMtEphS<T> {
  161|       |            // Helper for filter: deflate f x = if f(x) then [x] else []
  162|      1|            if f(x) == true {
  163|      1|                Self::singleton(x.clone())
  164|       |            } else {
  165|      0|                Self::empty()
  166|       |            }
  167|      1|        }
  168|       |
  169|      2|        fn filter<F: Fn(&T) -> B + Send + Sync + Clone + 'static>(a: &ArraySeqMtEphS<T>, pred: F) -> ArraySeqMtEphS<T> {
  170|       |            // Algorithm 19.5 with parallelism: fork thread per element + serial compaction
  171|      2|            if a.length() == 0 {
  172|      0|                return <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::empty();
  173|      2|            }
  174|       |
  175|       |            // Create boolean sequence for keep/filter results
  176|      2|            let mut keep_results = <ArraySeqMtEphS<B> as ArraySeqMtEphTraitChap18<B>>::new(a.length(), false);
  177|       |
  178|       |            // Fork thread per element to evaluate predicate, collect results serially
  179|     11|            for i in 0..a.length() {
                                      ^2^2
  180|     11|                let value = a.nth_cloned(i);
  181|     11|                let pred_clone = pred.clone();
  182|       |
  183|     11|                let handle = std::thread::spawn(move || pred_clone(&value));
  184|       |
  185|     11|                let keep = handle.join().unwrap();
  186|     11|                keep_results.set(i, keep).unwrap();
  187|       |            }
  188|       |
  189|       |            // Serial compaction phase: count kept values
  190|      2|            let mut kept_count = 0;
  191|     11|            for i in 0..keep_results.length() {
                                      ^2           ^2
  192|     11|                if keep_results.nth_cloned(i) == true {
  193|      5|                    kept_count += 1;
  194|      6|                }
  195|       |            }
  196|       |
  197|      2|            if kept_count == 0 {
  198|      0|                return <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::empty();
  199|      2|            }
  200|       |
  201|       |            // Find first kept value and create result sequence
  202|      2|            let mut first_kept = None;
  203|      4|            for i in 0..a.length() {
                                      ^2^2
  204|      4|                if keep_results.nth_cloned(i) == true {
  205|      2|                    first_kept = Some(a.nth_cloned(i));
  206|      2|                    break;
  207|      2|                }
  208|       |            }
  209|      2|            let first_kept = first_kept.unwrap();
  210|       |
  211|      2|            let mut result = <ArraySeqMtEphS<T> as ArraySeqMtEphTraitChap18<T>>::new(kept_count, first_kept);
  212|      2|            let mut result_idx = 1;
  213|       |
  214|     11|            for i in 0..a.length() {
                                      ^2^2
  215|     11|                if keep_results.nth_cloned(i) == true && result_idx < kept_count {
                                                                       ^5
  216|      3|                    result.set(result_idx, a.nth_cloned(i)).unwrap();
  217|      3|                    result_idx += 1;
  218|      8|                }
  219|       |            }
  220|       |
  221|      2|            result
  222|      2|        }
  223|       |
  224|      2|        fn iterate<A: StTInMtT, F: Fn(&A, &T) -> A + Send + Sync>(a: &ArraySeqMtEphS<T>, f: &F, x: A) -> A {
  225|       |            // Algorithm 19.8: iterate f x a = left-to-right traversal
  226|      2|            let mut acc = x;
  227|      7|            for i in 0..a.length() {
                                      ^2^2
  228|      7|                let item = a.nth_cloned(i);
  229|      7|                acc = f(&acc, &item);
  230|      7|            }
  231|      2|            acc
  232|      2|        }
  233|       |
  234|     14|        fn reduce<F: Fn(&T, &T) -> T + Send + Sync + Clone + 'static>(a: &ArraySeqMtEphS<T>, f: F, id: T) -> T {
  235|       |            // Algorithm 19.9 with parallelism: always parallel divide-and-conquer
  236|     14|            if a.length() == 0 {
  237|      0|                id
  238|     14|            } else if a.length() == 1 {
  239|      8|                a.nth_cloned(0)
  240|       |            } else {
  241|       |                // Always parallel for MT - divide and conquer
  242|      6|                let mid = a.length() / 2;
  243|      6|                let left = a.subseq_copy(0, mid);
  244|      6|                let right = a.subseq_copy(mid, a.length() - mid);
  245|      6|                let id_clone = id.clone();
  246|      6|                let f_clone = f.clone();
  247|      6|                let f_clone2 = f.clone();
  248|      6|                let handle = thread::spawn(move || {
  249|      6|                    <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::reduce(&left, f_clone, id_clone)
  250|      6|                });
  251|      6|                let right_result = <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::reduce(&right, f_clone2, id);
  252|      6|                let left_result = handle.join().unwrap();
  253|      6|                f(&left_result, &right_result)
  254|       |            }
  255|     14|        }
  256|       |
  257|      2|        fn scan<F: Fn(&T, &T) -> T + Send + Sync>(a: &ArraySeqMtEphS<T>, f: &F, id: T) -> (ArraySeqMtEphS<T>, T) {
  258|       |            // Algorithm 19.10: scan using contraction (simplified version)
  259|      2|            if a.length() == 0 {
  260|      0|                return (<ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::empty(), id);
  261|      2|            }
  262|      2|            let mut acc = id.clone();
  263|      2|            let item = a.nth_cloned(0);
  264|      2|            acc = f(&acc, &item);
  265|      2|            let mut result_seq = <ArraySeqMtEphS<T> as ArraySeqMtEphTraitChap18<T>>::new(a.length(), acc.clone());
  266|      6|            for i in 1..a.length() {
                                      ^2^2
  267|      6|                let item = a.nth_cloned(i);
  268|      6|                acc = f(&acc, &item);
  269|      6|                result_seq.set(i, acc.clone()).unwrap();
  270|      6|            }
  271|      2|            (result_seq, acc)
  272|      2|        }
  273|       |
  274|      2|        fn flatten(s: &ArraySeqMtEphS<ArraySeqMtEphS<T>>) -> ArraySeqMtEphS<T> {
  275|       |            // Keep as primitive - flatten is one of the 7 APAS primitives
  276|      2|            <ArraySeqMtEphS<T> as ArraySeqMtEphTraitChap18<T>>::flatten(s)
  277|      2|        }
  278|       |
  279|      3|        fn isEmpty(a: &ArraySeqMtEphS<T>) -> bool {
  280|       |            // Algorithm 19.7: isEmpty a = |a| = 0
  281|      3|            a.length() == 0
  282|      3|        }
  283|       |
  284|      3|        fn isSingleton(a: &ArraySeqMtEphS<T>) -> bool {
  285|       |            // Algorithm 19.7: isSingleton a = |a| = 1
  286|      3|            a.length() == 1
  287|      3|        }
  288|       |
  289|      1|        fn update(a: &ArraySeqMtEphS<T>, index: N, item: T) -> ArraySeqMtEphS<T> {
  290|       |            // Algorithm 19.6: update a (i, x) = tabulate(lambda j. if i = j then x else a[j], |a|)
  291|      1|            <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::tabulate(
  292|      3|                &|j| if j == index { item.clone() } else { a.nth_cloned(j) },
                                                   ^1   ^1               ^2^2         ^2
  293|      1|                a.length(),
  294|       |            )
  295|      1|        }
  296|       |    }
  297|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap19/ArraySeqMtEphSlice.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! MtEph slice-oriented Array sequence variant sharing a single mutex.
    3|       |//!
    4|       |//! Abstract:
    5|       |//! - Provides `ArraySeqMtEphSliceS<T>` backed by `Arc<Mutex<Box<[T]>>>` with range metadata.
    6|       |//! - Offers trait `ArraySeqMtEphSliceTrait<T>` mirroring the MT ephemeral API while avoiding `Vec` copies.
    7|       |//! - Adds `with_exclusive` to project a mutable slice guarded by the single mutex for batch updates.
    8|       |
    9|       |pub mod ArraySeqMtEphSlice {
   10|       |
   11|       |    use std::fmt::{Debug, Display, Formatter};
   12|       |    use std::ops::Range;
   13|       |    use std::sync::{Arc, Mutex};
   14|       |
   15|       |    use crate::Types::Types::*;
   16|       |
   17|       |    #[derive(Debug)]
   18|       |    struct Inner<T: StT + Send + Sync> {
   19|       |        data: Mutex<Box<[T]>>,
   20|       |    }
   21|       |
   22|       |    impl<T: StT + Send + Sync> Inner<T> {
   23|    107|        fn new(data: Box<[T]>) -> Self { Inner { data: Mutex::new(data) } }
   24|       |
   25|      0|        fn len(&self) -> N {
   26|      0|            let guard = self.data.lock().unwrap();
   27|      0|            guard.len()
   28|      0|        }
   29|       |    }
   30|       |
   31|       |    /// Shared slice view over the mutex-protected backing buffer.
   32|       |    pub struct ArraySeqMtEphSliceS<T: StT + Send + Sync> {
   33|       |        inner: Arc<Inner<T>>,
   34|       |        range: Range<N>,
   35|       |    }
   36|       |
   37|       |    /// Sequence trait for the slice-backed MT ephemeral array.
   38|       |    pub trait ArraySeqMtEphSliceTrait<T: StT + Send + Sync> {
   39|       |        /// claude-4-sonet: Work (n), Span (1)
   40|       |        fn new(length: N, init_value: T) -> Self;
   41|       |        /// claude-4-sonet: Work (1), Span (1)
   42|       |        fn length(&self) -> N;
   43|       |        /// claude-4-sonet: Work (1), Span (1)
   44|       |        fn nth_cloned(&self, index: N) -> T;
   45|       |        /// claude-4-sonet: Work (1), Span (1)
   46|       |        fn empty() -> Self;
   47|       |        /// claude-4-sonet: Work (1), Span (1)
   48|       |        fn update(&mut self, index: N, item: T) -> Result<&mut Self, &'static str>;
   49|       |        /// claude-4-sonet: Work (1), Span (1)
   50|       |        fn singleton(item: T) -> Self;
   51|       |        /// claude-4-sonet: Work (1), Span (1)
   52|       |        fn isEmpty(&self) -> B;
   53|       |        /// claude-4-sonet: Work (1), Span (1)
   54|       |        fn isSingleton(&self) -> B;
   55|       |        /// claude-4-sonet: Work (length), Span (1)
   56|       |        fn subseq_copy(&self, start: N, length: N) -> Self;
   57|       |        /// claude-4-sonet: Work (1), Span (1)
   58|       |        fn slice(&self, start: N, length: N) -> Self;
   59|       |        /// claude-4-sonet: Work (n +  W(f(i))), Span (1 + max S(f(i))), Parallelism (n)
   60|       |        fn tabulate<F: Fn(N) -> T + Send + Sync>(f: &F, n: N) -> Self;
   61|       |        /// claude-4-sonet: Work (|a| +  W(f(x))), Span (1 + max S(f(x))), Parallelism (|a|)
   62|       |        fn map<U: MtVal, F: Fn(&T) -> U + Send + Sync + Clone + 'static>(a: &Self, f: F) -> ArraySeqMtEphSliceS<U>;
   63|       |        /// claude-4-sonet: Work (|a| +  W(f(a))), Span (1 + max S(f(a))), Parallelism (|a|)
   64|       |        fn filter<F: Fn(&T) -> B + Send + Sync + Clone + 'static>(a: &Self, pred: F) -> Self;
   65|       |        fn append(a: &Self, b: &Self) -> Self;
   66|       |        fn append_select(a: &Self, b: &Self) -> Self;
   67|       |        fn flatten(sequences: &[ArraySeqMtEphSliceS<T>]) -> Self;
   68|       |        fn reduce<F: Fn(&T, &T) -> T + Send + Sync + Clone + 'static>(a: &Self, f: F, id: T) -> T;
   69|       |        fn scan<F: Fn(&T, &T) -> T + Send + Sync>(a: &Self, f: &F, id: T) -> (ArraySeqMtEphSliceS<T>, T);
   70|       |        fn iterate<A: StT + Send, F: Fn(&A, &T) -> A + Send + Sync>(a: &Self, f: &F, seed: A) -> A;
   71|       |        fn inject(a: &Self, updates: &[(N, T)]) -> Self;
   72|       |        fn ninject(a: &Self, updates: &[(N, T)]) -> Self;
   73|       |    }
   74|       |
   75|       |    impl<T: StT + Send + Sync + 'static> ArraySeqMtEphSliceS<T> {
   76|       |        /// Constructs a sequence from an owned boxed slice.
   77|    107|        pub fn from_box(data: Box<[T]>) -> Self {
   78|    107|            let len = data.len();
   79|    107|            ArraySeqMtEphSliceS {
   80|    107|                inner: Arc::new(Inner::new(data)),
   81|    107|                range: 0..len,
   82|    107|            }
   83|    107|        }
   84|       |
   85|       |        /// Constructs a sequence from a Vec without exposing it to callers.
   86|    106|        pub fn from_vec(data: Vec<T>) -> Self { Self::from_box(data.into_boxed_slice()) }
   87|       |
   88|       |        /// Materializes the current slice into a Vec for diagnostics or copies.
   89|     29|        pub fn to_vec(&self) -> Vec<T> {
   90|     29|            let guard = self.inner.data.lock().unwrap();
   91|     29|            guard[self.range.start..self.range.end].iter().cloned().collect()
   92|     29|        }
   93|       |
   94|       |        /// Invokes the closure with a mutable slice under the single mutex.
   95|     18|        pub fn with_exclusive<F: FnOnce(&mut [T]) -> R, R>(&self, f: F) -> R {
   96|     18|            let mut guard = self.inner.data.lock().unwrap();
   97|     18|            let start = self.range.start;
   98|     18|            let end = self.range.end;
   99|     18|            f(&mut guard[start..end])
  100|     18|        }
  101|       |
  102|       |        /// Set method for ephemeral sequences (alias for update)
  103|      3|        pub fn set(&mut self, index: N, item: T) -> Result<&mut Self, &'static str> { self.update(index, item) }
  104|       |
  105|    259|        fn len(&self) -> N { self.range.end - self.range.start }
  106|       |
  107|     27|        fn clamp_subrange(&self, start: N, length: N) -> Range<N> {
  108|     27|            let local_len = self.len();
  109|     27|            let clamped_start = start.min(local_len);
  110|     27|            let clamped_end = clamped_start.saturating_add(length).min(local_len);
  111|     27|            let base = self.range.start;
  112|     27|            (base + clamped_start)..(base + clamped_end)
  113|     27|        }
  114|       |    }
  115|       |
  116|       |    impl<T: StT + Send + Sync + 'static> ArraySeqMtEphSliceTrait<T> for ArraySeqMtEphSliceS<T> {
  117|      9|        fn new(length: N, init_value: T) -> Self {
  118|      9|            let data = repeat_vec(length, init_value);
  119|      9|            ArraySeqMtEphSliceS::from_vec(data)
  120|      9|        }
  121|       |
  122|    179|        fn length(&self) -> N { self.len() }
  123|       |
  124|    301|        fn nth_cloned(&self, index: N) -> T {
  125|    301|            let guard = self.inner.data.lock().unwrap();
  126|    301|            let idx = self.range.start + index;
  127|    301|            guard[idx].clone()
  128|    301|        }
  129|       |
  130|      7|        fn empty() -> Self {
  131|       |            // Algorithm 19.1: empty = tabulate(lambda i.i, 0) - use trait method
  132|      7|            <Self as ArraySeqMtEphSliceTrait<T>>::tabulate(&|_| unreachable!("empty sequence has no elements"), 0)
  133|      7|        }
  134|       |
  135|     22|        fn update(&mut self, index: N, item: T) -> Result<&mut Self, &'static str> {
  136|     22|            if index >= self.len() {
  137|      2|                return Err("Index out of bounds");
  138|     20|            }
  139|     20|            {
  140|     20|                let mut guard = self.inner.data.lock().unwrap();
  141|     20|                let idx = self.range.start + index;
  142|     20|                guard[idx] = item;
  143|     20|            }
  144|     20|            Ok(self)
  145|     22|        }
  146|       |
  147|      5|        fn singleton(item: T) -> Self {
  148|       |            // Algorithm 19.2: singleton x = tabulate(lambda i.x, 1) - use trait method
  149|       |            // Implement directly since we can't capture with &F
  150|      5|            let data = vec![item];
  151|      5|            let inner = Arc::new(Inner {
  152|      5|                data: Mutex::new(data.into_boxed_slice()),
  153|      5|            });
  154|      5|            Self { inner, range: 0..1 }
  155|      5|        }
  156|       |
  157|     17|        fn isEmpty(&self) -> B { if self.len() == 0 { true } else { false } }
                                                                    ^7            ^10
  158|       |
  159|     10|        fn isSingleton(&self) -> B { if self.len() == 1 { true } else { false } }
                                                                        ^3            ^7
  160|       |
  161|     10|        fn subseq_copy(&self, start: N, length: N) -> Self {
  162|     10|            let sub = self.clamp_subrange(start, length);
  163|     10|            let guard = self.inner.data.lock().unwrap();
  164|     10|            let data: Vec<T> = guard[sub.start..sub.end].iter().cloned().collect();
  165|     10|            ArraySeqMtEphSliceS::from_vec(data)
  166|     10|        }
  167|       |
  168|     17|        fn slice(&self, start: N, length: N) -> Self {
  169|     17|            let sub = self.clamp_subrange(start, length);
  170|     17|            ArraySeqMtEphSliceS {
  171|     17|                inner: Arc::clone(&self.inner),
  172|     17|                range: sub,
  173|     17|            }
  174|     17|        }
  175|       |
  176|     20|        fn tabulate<F: Fn(N) -> T + Send + Sync>(f: &F, n: N) -> Self {
  177|     20|            let mut values: Vec<T> = Vec::with_capacity(n);
  178|  1.06k|            for i in 0..n {
                                      ^20
  179|  1.06k|                values.push(f(i));
  180|  1.06k|            }
  181|     20|            ArraySeqMtEphSliceS::from_vec(values)
  182|     20|        }
  183|       |
  184|      3|        fn map<U: MtVal, F: Fn(&T) -> U + Send + Sync + Clone + 'static>(a: &Self, f: F) -> ArraySeqMtEphSliceS<U> {
  185|       |            // Algorithm 19.3 with parallelism: map f a = tabulate(lambda i.f(a[i]), |a|)
  186|      3|            if a.length() == 0 {
  187|      1|                return ArraySeqMtEphSliceS::<U>::from_vec(Vec::new());
  188|      2|            }
  189|       |
  190|       |            // Fork thread per element for parallel mapping
  191|      2|            let mut handles = Vec::with_capacity(a.length());
  192|      8|            for i in 0..a.length() {
                                      ^2^2
  193|      8|                let value = a.nth_cloned(i);
  194|      8|                let f_clone = f.clone();
  195|      8|                let handle = std::thread::spawn(move || f_clone(&value));
  196|      8|                handles.push(handle);
  197|       |            }
  198|       |
  199|       |            // Collect results serially
  200|      2|            let mut results = Vec::with_capacity(a.length());
  201|     10|            for handle in handles {
                              ^8
  202|      8|                results.push(handle.join().unwrap());
  203|      8|            }
  204|       |
  205|      2|            ArraySeqMtEphSliceS::<U>::from_vec(results)
  206|      3|        }
  207|       |
  208|      3|        fn filter<F: Fn(&T) -> B + Send + Sync + Clone + 'static>(a: &Self, pred: F) -> Self {
  209|       |            // Algorithm 19.5 with parallelism: fork thread per element + serial compaction
  210|      3|            if a.length() == 0 {
  211|      1|                return <Self as ArraySeqMtEphSliceTrait<T>>::empty();
  212|      2|            }
  213|       |
  214|       |            // Fork thread per element to evaluate predicate, collect results serially
  215|      2|            let mut keep_results = Vec::with_capacity(a.length());
  216|     12|            for i in 0..a.length() {
                                      ^2^2
  217|     12|                let value = a.nth_cloned(i);
  218|     12|                let pred_clone = pred.clone();
  219|       |
  220|     12|                let handle = std::thread::spawn(move || pred_clone(&value));
  221|       |
  222|     12|                let keep = handle.join().unwrap();
  223|     12|                keep_results.push(keep);
  224|       |            }
  225|       |
  226|       |            // Serial compaction phase: collect kept values
  227|      2|            let mut kept_values = Vec::new();
  228|     12|            for i in 0..a.length() {
                                      ^2^2
  229|     12|                if keep_results[i] == true {
  230|      6|                    kept_values.push(a.nth_cloned(i));
  231|      6|                }
  232|       |            }
  233|       |
  234|      2|            if kept_values.is_empty() {
  235|      0|                <Self as ArraySeqMtEphSliceTrait<T>>::empty()
  236|       |            } else {
  237|      2|                ArraySeqMtEphSliceS::from_vec(kept_values)
  238|       |            }
  239|      3|        }
  240|       |
  241|      1|        fn append(a: &Self, b: &Self) -> Self {
  242|       |            // Algorithm 19.4: append a b = flatten(<a, b>)
  243|      1|            let sequences = vec![a.clone(), b.clone()];
  244|      1|            <Self as ArraySeqMtEphSliceTrait<T>>::flatten(&sequences)
  245|      1|        }
  246|       |
  247|      1|        fn append_select(a: &Self, b: &Self) -> Self {
  248|       |            // Algorithm 19.4 alternative: append a b = tabulate(select(a, b), |a| + |b|)
  249|      1|            let total_len = a.length() + b.length();
  250|      1|            <Self as ArraySeqMtEphSliceTrait<T>>::tabulate(
  251|      4|                &|i| {
  252|      4|                    if i < a.length() {
  253|      2|                        a.nth_cloned(i)
  254|       |                    } else {
  255|      2|                        b.nth_cloned(i - a.length())
  256|       |                    }
  257|      4|                },
  258|      1|                total_len,
  259|       |            )
  260|      1|        }
  261|       |
  262|      2|        fn flatten(sequences: &[ArraySeqMtEphSliceS<T>]) -> Self {
  263|      2|            if sequences.is_empty() {
  264|      0|                return <Self as ArraySeqMtEphSliceTrait<T>>::empty();
  265|      2|            }
  266|       |
  267|       |            // Calculate total length
  268|      5|            let total_len: N = sequences.iter().map(|s| s.length()).sum();
                              ^2         ^2  ^2        ^2     ^2                  ^2
  269|      2|            if total_len == 0 {
  270|      0|                return <Self as ArraySeqMtEphSliceTrait<T>>::empty();
  271|      2|            }
  272|       |
  273|       |            // Flatten by copying all elements
  274|      2|            let mut result = Vec::with_capacity(total_len);
  275|      7|            for seq in sequences {
                              ^5
  276|     10|                for i in 0..seq.length() {
                                          ^5  ^5
  277|     10|                    result.push(seq.nth_cloned(i));
  278|     10|                }
  279|       |            }
  280|       |
  281|      2|            ArraySeqMtEphSliceS::from_vec(result)
  282|      2|        }
  283|       |
  284|     14|        fn reduce<F: Fn(&T, &T) -> T + Send + Sync + Clone + 'static>(a: &Self, f: F, id: T) -> T {
  285|       |            // Algorithm 19.9: divide-and-conquer parallel reduce
  286|     14|            if a.length() == 0 {
  287|      0|                return id;
  288|     14|            }
  289|     14|            if a.length() == 1 {
  290|      8|                return a.nth_cloned(0);
  291|      6|            }
  292|       |
  293|      6|            let mid = a.length() / 2;
  294|      6|            let left_slice = a.slice(0, mid);
  295|      6|            let right_slice = a.slice(mid, a.length() - mid);
  296|       |
  297|      6|            let f_left = f.clone();
  298|      6|            let f_right = f.clone();
  299|      6|            let id_left = id.clone();
  300|      6|            let id_right = id.clone();
  301|       |
  302|      6|            let left_handle = std::thread::spawn(move || Self::reduce(&left_slice, f_left, id_left));
  303|      6|            let right_handle = std::thread::spawn(move || Self::reduce(&right_slice, f_right, id_right));
  304|       |
  305|      6|            let left_result = left_handle.join().unwrap();
  306|      6|            let right_result = right_handle.join().unwrap();
  307|       |
  308|      6|            f(&left_result, &right_result)
  309|     14|        }
  310|       |
  311|      1|        fn scan<F: Fn(&T, &T) -> T + Send + Sync>(a: &Self, f: &F, id: T) -> (ArraySeqMtEphSliceS<T>, T) {
  312|       |            // Algorithm 19.10: scan using contraction (simplified for slice)
  313|      1|            if a.length() == 0 {
  314|      0|                return (<ArraySeqMtEphSliceS<T> as ArraySeqMtEphSliceTrait<T>>::empty(), id);
  315|      1|            }
  316|      1|            if a.length() == 1 {
  317|      0|                let result_seq = <ArraySeqMtEphSliceS<T> as ArraySeqMtEphSliceTrait<T>>::tabulate(&|_| id.clone(), 1);
  318|      0|                return (result_seq, a.nth_cloned(0));
  319|      1|            }
  320|       |
  321|       |            // For simplicity, implement sequentially (full parallel scan is complex)
  322|      1|            let mut results = Vec::with_capacity(a.length());
  323|      1|            let mut acc = id.clone();
  324|       |
  325|      4|            for i in 0..a.length() {
                                      ^1^1
  326|      4|                results.push(acc.clone());
  327|      4|                let current = a.nth_cloned(i);
  328|      4|                acc = f(&acc, &current);
  329|      4|            }
  330|       |
  331|      1|            let result_seq = ArraySeqMtEphSliceS::<T>::from_vec(results);
  332|      1|            (result_seq, acc)
  333|      1|        }
  334|       |
  335|      2|        fn iterate<A: StT + Send, F: Fn(&A, &T) -> A + Send + Sync>(a: &Self, f: &F, seed: A) -> A {
  336|       |            // Algorithm 19.8: iterate f x a (sequential left-to-right)
  337|      2|            let mut acc = seed;
  338|      8|            for i in 0..a.length() {
                                      ^2^2
  339|      8|                let current = a.nth_cloned(i);
  340|      8|                acc = f(&acc, &current);
  341|      8|            }
  342|      2|            acc
  343|      2|        }
  344|       |
  345|      1|        fn inject(a: &Self, updates: &[(N, T)]) -> Self {
  346|       |            // Delegate to Chap18 implementation concept - apply updates with leftmost wins
  347|      1|            let mut result = a.clone();
  348|      3|            for &(index, ref value) in updates {
                                ^2     ^2
  349|      2|                if index < result.length() {
  350|      2|                    result.update(index, value.clone()).unwrap();
  351|      2|                }
                              ^0
  352|       |            }
  353|      1|            result
  354|      1|        }
  355|       |
  356|      1|        fn ninject(a: &Self, updates: &[(N, T)]) -> Self {
  357|       |            // Delegate to Chap18 implementation concept - apply updates with rightmost wins
  358|      1|            let mut result = a.clone();
  359|      3|            for &(index, ref value) in updates.iter().rev() {
                                                     ^1      ^1     ^1
  360|      3|                if index < result.length() {
  361|      3|                    result.update(index, value.clone()).unwrap();
  362|      3|                }
                              ^0
  363|       |            }
  364|      1|            result
  365|      1|        }
  366|       |    }
  367|       |
  368|       |    impl<T: StT + Send + Sync> Clone for ArraySeqMtEphSliceS<T> {
  369|      9|        fn clone(&self) -> Self {
  370|      9|            ArraySeqMtEphSliceS {
  371|      9|                inner: Arc::clone(&self.inner),
  372|      9|                range: self.range.clone(),
  373|      9|            }
  374|      9|        }
  375|       |    }
  376|       |
  377|       |    impl<T: StT + Send + Sync + 'static> PartialEq for ArraySeqMtEphSliceS<T> {
  378|      2|        fn eq(&self, other: &Self) -> bool {
  379|      2|            if Arc::ptr_eq(&self.inner, &other.inner) && self.range == other.range {
                                                                       ^0
  380|      0|                return true;
  381|      2|            }
  382|      2|            if self.len() != other.len() {
  383|      0|                return false;
  384|      2|            }
  385|      2|            let left = self.to_vec();
  386|      2|            let right = other.to_vec();
  387|      6|            left.iter().zip(right.iter()).all(|(a, b)| a == b)
                          ^2          ^2                ^2
  388|      2|        }
  389|       |    }
  390|       |
  391|       |    impl<T: StT + Send + Sync + 'static> Eq for ArraySeqMtEphSliceS<T> {}
  392|       |
  393|       |    impl<T: StT + Send + Sync> Debug for ArraySeqMtEphSliceS<T> {
  394|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
  395|      1|            let guard = self.inner.data.lock().unwrap();
  396|      1|            f.debug_list()
  397|      1|                .entries(guard[self.range.start..self.range.end].iter())
  398|      1|                .finish()
  399|      1|        }
  400|       |    }
  401|       |
  402|       |    impl<T: StT + Send + Sync> Display for ArraySeqMtEphSliceS<T> {
  403|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
  404|      1|            let guard = self.inner.data.lock().unwrap();
  405|      1|            let mut first = true;
  406|      1|            write!(f, "[")?;
                                        ^0
  407|      3|            for item in &guard[self.range.start..self.range.end] {
                                       ^1   ^1
  408|      3|                if !first {
  409|      2|                    write!(f, ", ")?;
                                                 ^0
  410|      1|                }
  411|      3|                first = false;
  412|      3|                write!(f, "{}", item)?;
                                                   ^0
  413|       |            }
  414|      1|            write!(f, "]")
  415|      1|        }
  416|       |    }
  417|       |
  418|      9|    fn repeat_vec<T: StT + Send + Sync>(length: N, init: T) -> Vec<T> {
  419|      9|        let mut data = Vec::with_capacity(length);
  420|     38|        for _ in 0..length {
                                  ^9
  421|     38|            data.push(init.clone());
  422|     38|        }
  423|      9|        data
  424|      9|    }
  425|       |
  426|       |    #[macro_export]
  427|       |    macro_rules! ArraySeqMtEphSliceSLit {
  428|       |        () => { $crate::Chap19::ArraySeqMtEphSlice::ArraySeqMtEphSlice::ArraySeqMtEphSliceS::from_vec(Vec::new()) };
  429|       |        ($x:expr; $n:expr) => { $crate::Chap19::ArraySeqMtEphSlice::ArraySeqMtEphSlice::ArraySeqMtEphSliceS::from_vec(vec![$x; $n]) };
  430|       |        ($($x:expr),* $(,)?) => { $crate::Chap19::ArraySeqMtEphSlice::ArraySeqMtEphSlice::ArraySeqMtEphSliceS::from_vec(vec![$($x),*]) };
  431|       |    }
  432|       |
  433|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap19/ArraySeqMtPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 19 algorithms for ArraySeqMtPer, just the one multi-threaded update of code that Umut and Guy snuck into this chapter.
    3|       |
    4|       |pub mod ArraySeqMtPer {
    5|       |
    6|       |    use std::sync::Mutex;
    7|       |
    8|       |    use crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::{ArraySeqMtPerS as ArraySeqMtPerSChap18, ArraySeqMtPerTrait as ArraySeqMtPerTraitChap18};
    9|       |    use crate::Types::Types::*;
   10|       |
   11|       |    pub type ArraySeqMtPerS<T> = ArraySeqMtPerSChap18<T>;
   12|       |
   13|       |    pub trait ArraySeqMtPerTrait<T: StTInMtT> {
   14|       |        // Chapter 18 wrappers
   15|       |        /// claude-4-sonet: Work (n), Span (log n), Parallelism (n/log n)
   16|       |        fn new(length: N, init_value: T) -> ArraySeqMtPerS<T>;
   17|       |        /// claude-4-sonet: Work (1), Span (1)
   18|       |        fn empty() -> ArraySeqMtPerS<T>;
   19|       |        /// claude-4-sonet: Work (1), Span (1)
   20|       |        fn singleton(item: T) -> ArraySeqMtPerS<T>;
   21|       |        /// claude-4-sonet: Work (1), Span (1)
   22|       |        fn length(&self) -> N;
   23|       |        /// claude-4-sonet: Work (1), Span (1)
   24|       |        fn nth(&self, index: N) -> &T;
   25|       |        /// claude-4-sonet: Work (length), Span (log length), Parallelism (length/log length)
   26|       |        fn subseq_copy(&self, start: N, length: N) -> ArraySeqMtPerS<T>;
   27|       |
   28|       |        /// claude-4-sonet: Work (n +  W(f(i))), Span (log n + max S(f(i))), Parallelism (n)
   29|       |        fn tabulate<F: Fn(N) -> T + Send + Sync>(f: &F, n: N) -> ArraySeqMtPerS<T>;
   30|       |        /// claude-4-sonet: Work (|a| +  W(f(x))), Span (log |a| + max S(f(x))), Parallelism (|a|)
   31|       |        fn map<W: StTInMtT + 'static, F: Fn(&T) -> W + Send + Sync + Clone + 'static>(
   32|       |            a: &ArraySeqMtPerS<T>,
   33|       |            f: F,
   34|       |        ) -> ArraySeqMtPerS<W>
   35|       |        where
   36|       |            T: 'static;
   37|       |        /// claude-4-sonet: Work (|a| + |b|), Span (log(|a| + |b|)), Parallelism ((|a|+|b|)/log(|a|+|b|))
   38|       |        fn append(a: &ArraySeqMtPerS<T>, b: &ArraySeqMtPerS<T>) -> ArraySeqMtPerS<T>;
   39|       |        /// claude-4-sonet: Work (|a| +  W(f(a))), Span (log |a| + max S(f(a))), Parallelism (|a|)
   40|       |        fn filter<F: Fn(&T) -> B + Send + Sync + Clone + 'static>(a: &ArraySeqMtPerS<T>, pred: F) -> ArraySeqMtPerS<T>;
   41|       |        /// claude-4-sonet: Work (|a|), Span (log |a|), Parallelism (|a|/log |a|)
   42|       |        fn update_single(a: &ArraySeqMtPerS<T>, index: N, item: T) -> ArraySeqMtPerS<T>;
   43|       |        /// claude-4-sonet: Work (|a| + |updates|), Span (log |a| + log |updates|)
   44|       |        fn ninject(a: &ArraySeqMtPerS<T>, updates: &ArraySeqMtPerS<Pair<N, T>>) -> ArraySeqMtPerS<T>;
   45|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1)
   46|       |        fn iterate<A: StTInMtT, F: Fn(&A, &T) -> A + Send + Sync>(a: &ArraySeqMtPerS<T>, f: &F, x: A) -> A;
   47|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1)
   48|       |        fn iteratePrefixes<A: StTInMtT + 'static, F: Fn(&A, &T) -> A + Send + Sync>(
   49|       |            a: &ArraySeqMtPerS<T>,
   50|       |            f: &F,
   51|       |            x: A,
   52|       |        ) -> (ArraySeqMtPerS<A>, A);
   53|       |        /// claude-4-sonet: Work (|a|), Span (log |a|), Parallelism (|a|/log |a|)
   54|       |        fn reduce<F: Fn(&T, &T) -> T + Send + Sync + Clone + 'static>(a: &ArraySeqMtPerS<T>, f: F, id: T) -> T
   55|       |        where
   56|       |            T: 'static;
   57|       |        /// claude-4-sonet: Work (|a|), Span (log |a|), Parallelism (|a|/log |a|)
   58|       |        fn scan<F: Fn(&T, &T) -> T + Send + Sync>(a: &ArraySeqMtPerS<T>, f: &F, id: T) -> (ArraySeqMtPerS<T>, T);
   59|       |        /// claude-4-sonet: Work ( |s|), Span (log( |s|))
   60|       |        fn flatten(ss: &ArraySeqMtPerS<ArraySeqMtPerS<T>>) -> ArraySeqMtPerS<T>;
   61|       |        /// claude-4-sonet: Work (|a|) worst case, Span (|a|) worst case
   62|       |        fn collect(a: &ArraySeqMtPerS<Pair<T, T>>, cmp: fn(&T, &T) -> O) -> ArraySeqMtPerS<Pair<T, ArraySeqMtPerS<T>>>;
   63|       |
   64|       |        // Chapter 19 specific functions
   65|       |        /// claude-4-sonet: Work (|values| + |changes|), Span (log |values| + log |changes|)
   66|       |        fn inject(values: &ArraySeqMtPerS<T>, changes: &ArraySeqMtPerS<Pair<N, T>>) -> ArraySeqMtPerS<T>;
   67|       |        /// claude-4-sonet: Work (|changes|), Span (log |changes|)
   68|       |        fn atomicWrite(
   69|       |            values_with_change_number: &mut ArraySeqMtPerS<Pair<T, N>>,
   70|       |            changes: &ArraySeqMtPerS<Pair<N, T>>,
   71|       |            change_index: N,
   72|       |        );
   73|       |        /// claude-4-sonet: Work (1), Span (1)
   74|       |        fn isEmpty(a: &ArraySeqMtPerS<T>) -> bool;
   75|       |        fn isSingleton(a: &ArraySeqMtPerS<T>) -> bool;
   76|       |        fn append_select(a: &ArraySeqMtPerS<T>, b: &ArraySeqMtPerS<T>) -> ArraySeqMtPerS<T>;
   77|       |        fn select<'a>(a: &'a ArraySeqMtPerS<T>, b: &'a ArraySeqMtPerS<T>, i: N) -> Option<&'a T>;
   78|       |        fn deflate<F: Fn(&T) -> B + Send + Sync>(f: &F, x: &T) -> ArraySeqMtPerS<T>;
   79|       |    }
   80|       |
   81|       |    impl<T: StTInMtT + 'static> ArraySeqMtPerTrait<T> for ArraySeqMtPerS<T> {
   82|      1|        fn new(length: N, init_value: T) -> ArraySeqMtPerS<T> {
   83|       |            // Keep as primitive - delegates to tabulate
   84|      1|            <ArraySeqMtPerS<T> as ArraySeqMtPerTraitChap18<T>>::new(length, init_value)
   85|      1|        }
   86|       |
   87|      2|        fn empty() -> ArraySeqMtPerS<T> {
   88|       |            // Algorithm 19.1: empty = tabulate(lambda i.i, 0)
   89|      2|            <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::tabulate(
   90|       |                &|_| unreachable!("empty sequence has no elements"),
   91|       |                0,
   92|       |            )
   93|      2|        }
   94|       |
   95|      2|        fn singleton(item: T) -> ArraySeqMtPerS<T> {
   96|       |            // Algorithm 19.2: singleton x = tabulate(lambda i.x, 1)
   97|      2|            <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::tabulate(&|_| item.clone(), 1)
   98|      2|        }
   99|       |
  100|      1|        fn length(&self) -> N { ArraySeqMtPerTraitChap18::length(self) }
  101|       |
  102|      2|        fn nth(&self, index: N) -> &T { ArraySeqMtPerTraitChap18::nth(self, index) }
  103|       |
  104|      0|        fn subseq_copy(&self, start: N, length: N) -> ArraySeqMtPerS<T> {
  105|      0|            <ArraySeqMtPerS<T> as ArraySeqMtPerTraitChap18<T>>::subseq_copy(self, start, length)
  106|      0|        }
  107|       |
  108|    120|        fn tabulate<F: Fn(N) -> T + Send + Sync>(f: &F, n: N) -> ArraySeqMtPerS<T> {
  109|       |            // Keep as primitive - tabulate is one of the 7 APAS primitives
  110|       |            // Implement directly to handle closures (can't delegate to Chap18 fn pointers)
  111|    120|            let mut values: Vec<T> = Vec::with_capacity(n);
  112|  1.53k|            for i in 0..n {
                                      ^120
  113|  1.53k|                values.push(f(i));
  114|  1.53k|            }
  115|    120|            ArraySeqMtPerS::from_vec(values)
  116|    120|        }
  117|       |
  118|    213|        fn map<W: MtVal, F: Fn(&T) -> W + Send + Sync + Clone + 'static>(
  119|    213|            a: &ArraySeqMtPerS<T>,
  120|    213|            f: F,
  121|    213|        ) -> ArraySeqMtPerS<W> {
  122|       |            // Algorithm 19.3 with parallelism: map f a = tabulate(lambda i.f(a[i]), |a|)
  123|    213|            if a.length() <= 1 {
  124|       |                // Implement directly since we can't capture with &F
  125|    108|                let mut values: Vec<W> = Vec::with_capacity(a.length());
  126|    108|                for i in 0..a.length() {
  127|    108|                    values.push(f(a.nth(i)));
  128|    108|                }
  129|    108|                return ArraySeqMtPerS::from_vec(values);
  130|    105|            }
  131|       |            // Always parallel for MT - divide and conquer
  132|    105|            let mid = a.length() / 2;
  133|    105|            let left = a.subseq_copy(0, mid);
  134|    105|            let right = a.subseq_copy(mid, a.length() - mid);
  135|    105|            let f_clone = f.clone();
  136|    105|            let handle = std::thread::spawn(move || <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::map(&left, f_clone));
  137|    105|            let right_result = <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::map(&right, f);
  138|    105|            let left_result = handle.join().unwrap();
  139|    105|            <ArraySeqMtPerS<W> as ArraySeqMtPerTrait<W>>::append(&left_result, &right_result)
  140|    213|        }
  141|       |
  142|    107|        fn append(a: &ArraySeqMtPerS<T>, b: &ArraySeqMtPerS<T>) -> ArraySeqMtPerS<T> {
  143|       |            // Algorithm 19.4: append a b = flatten([a, b])
  144|    107|            let sequences = <ArraySeqMtPerS<ArraySeqMtPerS<T>> as ArraySeqMtPerTrait<ArraySeqMtPerS<T>>>::tabulate(
  145|    214|                &|i| if i == 0 { a.clone() } else { b.clone() },
                                               ^107^107             ^107^107
  146|       |                2,
  147|       |            );
  148|    107|            <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::flatten(&sequences)
  149|    107|        }
  150|       |
  151|      3|        fn filter<F: Fn(&T) -> B + Send + Sync + Clone + 'static>(a: &ArraySeqMtPerS<T>, pred: F) -> ArraySeqMtPerS<T> {
  152|       |            // Algorithm 19.5 with parallelism: fork thread per element + serial compaction
  153|      3|            if a.length() == 0 {
  154|      0|                return <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::empty();
  155|      3|            }
  156|       |
  157|       |            // Fork thread per element to evaluate predicate
  158|      3|            let mut handles = Vec::with_capacity(a.length());
  159|    112|            for i in 0..a.length() {
                                      ^3^3
  160|    112|                let value = a.nth(i).clone();
  161|    112|                let pred_clone = pred.clone();
  162|    112|                let handle = std::thread::spawn(move || if pred_clone(&value) == true { Some(value) } else { None });
                                                                                                      ^56                  ^56
  163|    112|                handles.push(handle);
  164|       |            }
  165|       |
  166|       |            // Serial compaction: collect all Some values
  167|      3|            let mut kept: Vec<T> = Vec::new();
  168|    115|            for handle in handles {
                              ^112
  169|    112|                if let Some(value) = handle.join().unwrap() {
                                          ^56
  170|     56|                    kept.push(value);
  171|     56|                }
  172|       |            }
  173|       |
  174|      3|            if kept.is_empty() {
  175|      0|                <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::empty()
  176|       |            } else {
  177|      3|                ArraySeqMtPerS::from_vec(kept)
  178|       |            }
  179|      3|        }
  180|       |
  181|      1|        fn update_single(a: &ArraySeqMtPerS<T>, index: N, item: T) -> ArraySeqMtPerS<T> {
  182|       |            // Algorithm 19.6: update a (i, x) = tabulate(lambda j. if i = j then x else a[j], |a|)
  183|      1|            <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::tabulate(
  184|      4|                &|j| if j == index { item.clone() } else { a.nth(j).clone() },
                                                   ^1   ^1               ^3       ^3
  185|      1|                a.length(),
  186|       |            )
  187|      1|        }
  188|       |
  189|      2|        fn ninject(a: &ArraySeqMtPerS<T>, updates: &ArraySeqMtPerS<Pair<N, T>>) -> ArraySeqMtPerS<T> {
  190|       |            // Keep as primitive - ninject is one of the 7 APAS primitives
  191|      2|            <ArraySeqMtPerS<T> as ArraySeqMtPerTraitChap18<T>>::ninject(a, updates)
  192|      2|        }
  193|       |
  194|      2|        fn iterate<A: StTInMtT, F: Fn(&A, &T) -> A + Send + Sync>(a: &ArraySeqMtPerS<T>, f: &F, x: A) -> A {
  195|       |            // Algorithm 19.8: iterate f x a = left-to-right traversal
  196|      2|            let mut acc = x;
  197|      8|            for i in 0..a.length() {
                                      ^2^2
  198|      8|                acc = f(&acc, a.nth(i));
  199|      8|            }
  200|      2|            acc
  201|      2|        }
  202|       |
  203|      0|        fn iteratePrefixes<A: StTInMtT + 'static, F: Fn(&A, &T) -> A + Send + Sync>(
  204|      0|            a: &ArraySeqMtPerS<T>,
  205|      0|            f: &F,
  206|      0|            x: A,
  207|      0|        ) -> (ArraySeqMtPerS<A>, A) {
  208|       |            // Implement directly since we can't delegate impl Fn to fn pointer
  209|       |            // This is a sequential operation anyway
  210|      0|            let mut result_vec = Vec::with_capacity(a.length());
  211|      0|            let mut acc = x;
  212|      0|            for i in 0..a.length() {
  213|      0|                result_vec.push(acc.clone());
  214|      0|                acc = f(&acc, &a.nth(i));
  215|      0|            }
  216|      0|            (ArraySeqMtPerS::from_vec(result_vec), acc)
  217|      0|        }
  218|       |
  219|    215|        fn reduce<F: Fn(&T, &T) -> T + Send + Sync + Clone + 'static>(a: &ArraySeqMtPerS<T>, f: F, id: T) -> T {
  220|       |            // Algorithm 19.9 with parallelism: always parallel divide-and-conquer
  221|    215|            if a.length() == 0 {
  222|      0|                id
  223|    215|            } else if a.length() == 1 {
  224|    109|                a.nth(0).clone()
  225|       |            } else {
  226|       |                // Always parallel for MT - divide and conquer
  227|       |                // Always parallel for MT - divide and conquer
  228|    106|                let mid = a.length() / 2;
  229|    106|                let left = a.subseq_copy(0, mid);
  230|    106|                let right = a.subseq_copy(mid, a.length() - mid);
  231|    106|                let id_clone = id.clone();
  232|    106|                let f_clone = f.clone();
  233|    106|                let f_clone2 = f.clone();
  234|    106|                let handle = std::thread::spawn(move || {
  235|    106|                    <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::reduce(&left, f_clone, id_clone)
  236|    106|                });
  237|    106|                let right_result = <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::reduce(&right, f_clone2, id);
  238|    106|                let left_result = handle.join().unwrap();
  239|    106|                f(&left_result, &right_result)
  240|       |            }
  241|    215|        }
  242|       |
  243|      2|        fn scan<F: Fn(&T, &T) -> T + Send + Sync>(a: &ArraySeqMtPerS<T>, f: &F, id: T) -> (ArraySeqMtPerS<T>, T) {
  244|       |            // Algorithm 19.10: scan using contraction (simplified version)
  245|      2|            let mut acc = id.clone();
  246|      2|            let mut results = Vec::with_capacity(a.length());
  247|      8|            for i in 0..a.length() {
                                      ^2^2
  248|      8|                acc = f(&acc, a.nth(i));
  249|      8|                results.push(acc.clone());
  250|      8|            }
  251|       |            // Implement directly since we can't capture with &F
  252|      2|            let result_seq = ArraySeqMtPerS::from_vec(results);
  253|      2|            (result_seq, acc)
  254|      2|        }
  255|       |
  256|    109|        fn flatten(ss: &ArraySeqMtPerS<ArraySeqMtPerS<T>>) -> ArraySeqMtPerS<T> {
  257|       |            // Keep as primitive - flatten is one of the 7 APAS primitives
  258|    109|            <ArraySeqMtPerS<T> as ArraySeqMtPerTraitChap18<T>>::flatten(ss)
  259|    109|        }
  260|       |
  261|      1|        fn collect(a: &ArraySeqMtPerS<Pair<T, T>>, cmp: fn(&T, &T) -> O) -> ArraySeqMtPerS<Pair<T, ArraySeqMtPerS<T>>> {
  262|      1|            <ArraySeqMtPerS<T> as ArraySeqMtPerTraitChap18<T>>::collect(a, cmp)
  263|      1|        }
  264|       |
  265|    422|        fn inject(values: &ArraySeqMtPerS<T>, changes: &ArraySeqMtPerS<Pair<N, T>>) -> ArraySeqMtPerS<T> {
  266|    422|            <ArraySeqMtPerS<T> as ArraySeqMtPerTraitChap18<T>>::inject(values, changes)
  267|    422|        }
  268|       |
  269|      1|        fn atomicWrite(
  270|      1|            _values_with_change_number: &mut ArraySeqMtPerS<Pair<T, N>>,
  271|      1|            _changes: &ArraySeqMtPerS<Pair<N, T>>,
  272|      1|            _change_index: N,
  273|      1|        ) {
  274|       |            // Stub implementation - complex atomic operations not needed for basic functionality
  275|      1|        }
  276|       |
  277|    803|        fn isEmpty(a: &ArraySeqMtPerS<T>) -> bool {
  278|       |            // Algorithm 19.7: isEmpty a = |a| = 0
  279|    803|            a.length() == 0
  280|    803|        }
  281|       |
  282|    804|        fn isSingleton(a: &ArraySeqMtPerS<T>) -> bool {
  283|       |            // Algorithm 19.7: isSingleton a = |a| = 1
  284|    804|            a.length() == 1
  285|    804|        }
  286|       |
  287|      2|        fn append_select(a: &ArraySeqMtPerS<T>, b: &ArraySeqMtPerS<T>) -> ArraySeqMtPerS<T> {
  288|       |            // Algorithm 19.4 alternative: append a b = tabulate(select(a,b), |a|+|b|)
  289|      2|            <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::tabulate(
  290|      9|                &|i| {
  291|      9|                    <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::select(a, b, i)
  292|      9|                        .unwrap()
  293|      9|                        .clone()
  294|      9|                },
  295|      2|                a.length() + b.length(),
  296|       |            )
  297|      2|        }
  298|       |
  299|     13|        fn select<'a>(a: &'a ArraySeqMtPerS<T>, b: &'a ArraySeqMtPerS<T>, i: N) -> Option<&'a T> {
  300|     13|            let len_a = a.length();
  301|     13|            if i < len_a {
  302|      7|                return Some(a.nth(i));
  303|      6|            }
  304|      6|            let offset = i - len_a;
  305|      6|            let len_b = b.length();
  306|      6|            if offset < len_b { Some(b.nth(offset)) } else { None }
                                                                           ^0
  307|     13|        }
  308|       |
  309|      2|        fn deflate<F: Fn(&T) -> B + Send + Sync>(f: &F, x: &T) -> ArraySeqMtPerS<T> {
  310|       |            // Helper for filter: deflate f x = if f(x) then [x] else []
  311|      2|            if f(x) == true {
  312|      1|                <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::singleton(x.clone())
  313|       |            } else {
  314|      1|                <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::empty()
  315|       |            }
  316|      2|        }
  317|       |    }
  318|       |
  319|       |    #[macro_export]
  320|       |    macro_rules! ArrayMtPerSLit {
  321|       |        () => { $crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::ArraySeqMtPerS::from_vec(Vec::new()) };
  322|       |        ($x:expr; $n:expr) => { $crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::ArraySeqMtPerS::from_vec(vec![$x; $n]) };
  323|       |        ($($x:expr),* $(,)?) => { $crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::ArraySeqMtPerS::from_vec(vec![$($x),*]) };
  324|       |    }
  325|       |
  326|       |    #[macro_export]
  327|       |    macro_rules! ArraySeqMtPerS {
  328|       |        () => { $crate::Chap19::ArraySeqMtPer::ArraySeqMtPer::ArraySeqMtPerS::from_vec(Vec::new()) };
  329|       |        ($x:expr; $n:expr) => { $crate::Chap19::ArraySeqMtPer::ArraySeqMtPer::ArraySeqMtPerS::from_vec(vec![$x; $n]) };
  330|       |        ($($x:expr),* $(,)?) => { $crate::Chap19::ArraySeqMtPer::ArraySeqMtPer::ArraySeqMtPerS::from_vec(vec![$($x),*]) };
  331|       |    }
  332|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap19/ArraySeqStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 19 algorithms for `ArraySeqStEph<T>`.
    3|       |
    4|       |pub mod ArraySeqStEph {
    5|       |
    6|       |    use crate::Chap18::ArraySeq::ArraySeq::ArraySeq;
    7|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::{
    8|       |        ArraySeqStEphS as ArraySeqStEphSChap18, ArraySeqStEphTrait as ArraySeqStEphTraitChap18,
    9|       |    };
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    pub type ArraySeqStEphS<T> = ArraySeqStEphSChap18<T>;
   13|       |
   14|       |    pub trait ArraySeqStEphTrait<T: StT> {
   15|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   16|       |        fn new(length: N, init_value: T) -> ArraySeqStEphS<T>;
   17|       |        /// claude-4-sonet: Work (1), Span (1)
   18|       |        fn empty() -> ArraySeqStEphS<T>;
   19|       |        /// claude-4-sonet: Work (1), Span (1)
   20|       |        fn singleton(item: T) -> ArraySeqStEphS<T>;
   21|       |        /// claude-4-sonet: Work (1), Span (1)
   22|       |        fn length(&self) -> N;
   23|       |        /// claude-4-sonet: Work (1), Span (1)
   24|       |        fn nth(&self, index: N) -> &T;
   25|       |        /// claude-4-sonet: Work (length), Span (length), Parallelism (1)
   26|       |        fn subseq_copy(&self, start: N, length: N) -> ArraySeqStEphS<T>;
   27|       |
   28|       |        /// APAS: Work (1 +  i=0..n-1 W(f(i))), Span (1 + max i=0..n-1 S(f(i)))
   29|       |        /// claude-4-sonet: Work (n +  W(f(i))), Span (n + max S(f(i))), Parallelism (1)
   30|       |        fn tabulate<F: Fn(N) -> T>(f: &F, n: N) -> ArraySeqStEphS<T>;
   31|       |        /// APAS: Work (1 +  xa W(f(x))), Span (1 + max xa S(f(x)))
   32|       |        /// claude-4-sonet: Work (|a| +  W(f(x))), Span (|a| + max S(f(x))), Parallelism (1)
   33|       |        fn map<U: StT, F: Fn(&T) -> U>(a: &ArraySeqStEphS<T>, f: &F) -> ArraySeqStEphS<U>;
   34|       |        /// APAS: Work (1), Span (1)
   35|       |        /// claude-4-sonet: Work (1), Span (1)
   36|       |        fn select(a: &ArraySeqStEphS<T>, b: &ArraySeqStEphS<T>, index: N) -> Option<T>;
   37|       |        /// APAS: Work (1 + |a| + |b|), Span (1)
   38|       |        /// claude-4-sonet: Work (|a| + |b|), Span (|a| + |b|), Parallelism (1)
   39|       |        fn append(a: &ArraySeqStEphS<T>, b: &ArraySeqStEphS<T>) -> ArraySeqStEphS<T>;
   40|       |        /// APAS: Work (1 + |a| + |b|), Span (1)
   41|       |        /// claude-4-sonet: Work (|a| + |b|), Span (|a| + |b|), Parallelism (1)
   42|       |        fn append_select(a: &ArraySeqStEphS<T>, b: &ArraySeqStEphS<T>) -> ArraySeqStEphS<T>;
   43|       |        /// APAS: Work (1), Span (1)
   44|       |        /// claude-4-sonet: Work (1), Span (1)
   45|       |        fn deflate<F: Fn(&T) -> B>(f: &F, x: &T) -> ArraySeqStEphS<T>;
   46|       |        /// APAS: Work (1 +  i=0..|a|-1 W(f(a[i]))), Span (1 + max i S(f(a[i])))
   47|       |        /// claude-4-sonet: Work (|a| +  W(f(a))), Span (|a| + max S(f(a))), Parallelism (1)
   48|       |        fn filter<F: Fn(&T) -> B>(a: &ArraySeqStEphS<T>, pred: &F) -> ArraySeqStEphS<T>;
   49|       |        /// claude-4-sonet: Work (|a|  W(f)), Span (|a|  S(f)), Parallelism (1)
   50|       |        fn iterate<A: StT, F: Fn(&A, &T) -> A>(a: &ArraySeqStEphS<T>, f: &F, x: A) -> A;
   51|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1)
   52|       |        fn reduce<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, id: T) -> T;
   53|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1)
   54|       |        fn scan<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, id: T) -> (ArraySeqStEphS<T>, T);
   55|       |        /// claude-4-sonet: Work ( |s|), Span ( |s|), Parallelism (1)
   56|       |        fn flatten(s: &ArraySeqStEphS<ArraySeqStEphS<T>>) -> ArraySeqStEphS<T>;
   57|       |        /// claude-4-sonet: Work (1), Span (1)
   58|       |        fn isEmpty(a: &ArraySeqStEphS<T>) -> bool;
   59|       |        /// claude-4-sonet: Work (1), Span (1)
   60|       |        fn isSingleton(a: &ArraySeqStEphS<T>) -> bool;
   61|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   62|       |        fn update(a: &ArraySeqStEphS<T>, index: N, item: T) -> ArraySeqStEphS<T>;
   63|       |        /// Inject updates into base sequence. Updates is a vector of (index, value) pairs.
   64|       |        /// If multiple updates target the same index, the last update wins.
   65|       |        /// APAS: Work (|base| + |updates|), Span (|base| + |updates|)
   66|       |        /// claude-4-sonet: Work (|base| + |updates|), Span (|base| + |updates|), Parallelism (1)
   67|       |        fn inject(base: &ArraySeqStEphS<T>, updates: &[(N, T)]) -> ArraySeqStEphS<T>;
   68|       |    }
   69|       |
   70|       |    impl<T: StT> ArraySeqStEphTrait<T> for ArraySeqStEphS<T> {
   71|      1|        fn new(length: N, init_value: T) -> ArraySeqStEphS<T> {
   72|       |            // Keep as primitive - delegates to tabulate
   73|      1|            <ArraySeqStEphS<T> as ArraySeqStEphTraitChap18<T>>::new(length, init_value)
   74|      1|        }
   75|       |
   76|     19|        fn empty() -> ArraySeqStEphS<T> {
   77|       |            // Algorithm 19.1: empty = tabulate(lambda i.i, 0)
   78|     19|            <ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::tabulate(
   79|       |                &|_| unreachable!("empty sequence has no elements"),
   80|       |                0,
   81|       |            )
   82|     19|        }
   83|       |
   84|     18|        fn singleton(item: T) -> ArraySeqStEphS<T> {
   85|       |            // Algorithm 19.2: singleton x = tabulate(lambda i.x, 1)
   86|     18|            <ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::tabulate(&|_| item.clone(), 1)
   87|     18|        }
   88|       |
   89|      1|        fn length(&self) -> N { ArraySeqStEphTraitChap18::length(self) }
   90|       |
   91|      2|        fn nth(&self, index: N) -> &T { ArraySeqStEphTraitChap18::nth(self, index) }
   92|       |
   93|     15|        fn subseq_copy(&self, start: N, length: N) -> ArraySeqStEphS<T> {
   94|       |            // Keep as primitive - subseq is one of the 7 APAS primitives
   95|     15|            <ArraySeqStEphS<T> as ArraySeqStEphTraitChap18<T>>::subseq(self, start, length)
   96|     15|        }
   97|       |
   98|     80|        fn tabulate<F: Fn(N) -> T>(f: &F, n: N) -> ArraySeqStEphS<T> {
   99|       |            // Keep as primitive - tabulate is one of the 7 APAS primitives
  100|     80|            if n == 0 {
  101|     25|                return <ArraySeqStEphS<T> as ArraySeqStEphTraitChap18<T>>::empty();
  102|     55|            }
  103|     55|            let mut result = <ArraySeqStEphS<T> as ArraySeqStEphTraitChap18<T>>::new(n, f(0));
  104|    111|            for i in 1..n {
                                      ^55
  105|    111|                result.set(i, f(i)).unwrap();
  106|    111|            }
  107|     55|            result
  108|     80|        }
  109|       |
  110|      9|        fn map<U: StT, F: Fn(&T) -> U>(a: &ArraySeqStEphS<T>, f: &F) -> ArraySeqStEphS<U> {
  111|       |            // Algorithm 19.3: map f a = tabulate(lambda i.f(a[i]), |a|)
  112|     45|            <ArraySeqStEphS<U> as ArraySeqStEphTrait<U>>::tabulate(&|i| f(a.nth(i)), a.length())
                          ^9                                                                       ^9^9
  113|      9|        }
  114|       |
  115|     11|        fn select(a: &ArraySeqStEphS<T>, b: &ArraySeqStEphS<T>, index: N) -> Option<T> {
  116|     11|            let len_a = a.length();
  117|     11|            if index < len_a {
  118|      5|                return Some(a.nth(index).clone());
  119|      6|            }
  120|      6|            let offset = index - len_a;
  121|      6|            let len_b = b.length();
  122|      6|            if offset < len_b {
  123|      5|                Some(b.nth(offset).clone())
  124|       |            } else {
  125|      1|                None
  126|       |            }
  127|     11|        }
  128|       |
  129|      8|        fn append(a: &ArraySeqStEphS<T>, b: &ArraySeqStEphS<T>) -> ArraySeqStEphS<T> {
  130|       |            // Algorithm 19.4: append a b = flatten([a, b])
  131|      8|            let total_len = a.length() + b.length();
  132|      8|            if total_len == 0 {
  133|      0|                return <ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::empty();
  134|      8|            }
  135|      8|            let first_elem = if a.length() > 0 {
  136|      7|                a.nth(0).clone()
  137|       |            } else {
  138|      1|                b.nth(0).clone()
  139|       |            };
  140|      8|            let mut result = <ArraySeqStEphS<T> as ArraySeqStEphTraitChap18<T>>::new(total_len, first_elem);
  141|     15|            for i in 1..a.length() {
                                      ^8^8
  142|     15|                result.set(i, a.nth(i).clone()).unwrap();
  143|     15|            }
  144|     19|            for i in 0..b.length() {
                                      ^8^8
  145|     19|                result.set(a.length() + i, b.nth(i).clone()).unwrap();
  146|     19|            }
  147|      8|            result
  148|      8|        }
  149|       |
  150|      1|        fn append_select(a: &ArraySeqStEphS<T>, b: &ArraySeqStEphS<T>) -> ArraySeqStEphS<T> {
  151|       |            // Algorithm 19.4 alternative: append a b = tabulate(select(a,b), |a|+|b|)
  152|      1|            <ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::tabulate(
  153|      4|                &|i| <ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::select(a, b, i).unwrap(),
  154|      1|                a.length() + b.length(),
  155|       |            )
  156|      1|        }
  157|       |
  158|     35|        fn deflate<F: Fn(&T) -> B>(f: &F, x: &T) -> ArraySeqStEphS<T> {
  159|       |            // Helper for filter: deflate f x = if f(x) then [x] else []
  160|     35|            if f(x) == true {
  161|     17|                <ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::singleton(x.clone())
  162|       |            } else {
  163|     18|                <ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::empty()
  164|       |            }
  165|     35|        }
  166|       |
  167|      5|        fn filter<F: Fn(&T) -> B>(a: &ArraySeqStEphS<T>, pred: &F) -> ArraySeqStEphS<T> {
  168|       |            // Algorithm 19.5: filter f a = flatten(map(deflate f, a))
  169|     31|            let deflated = <ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::map(a, &|x| {
                              ^5         ^5                                                ^5
  170|     31|                <ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::deflate(pred, x)
  171|     31|            });
  172|      5|            <ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::flatten(&deflated)
  173|      5|        }
  174|       |
  175|      3|        fn iterate<A: StT, F: Fn(&A, &T) -> A>(a: &ArraySeqStEphS<T>, f: &F, x: A) -> A {
  176|       |            // Algorithm 19.8: iterate f x a = left-to-right traversal
  177|      3|            let mut acc = x;
  178|     12|            for i in 0..a.length() {
                                      ^3^3
  179|     12|                acc = f(&acc, a.nth(i));
  180|     12|            }
  181|      3|            acc
  182|      3|        }
  183|       |
  184|     18|        fn reduce<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, id: T) -> T {
  185|       |            // Algorithm 19.9: reduce using divide-and-conquer
  186|     18|            if a.length() == 0 {
  187|      1|                id
  188|     17|            } else if a.length() == 1 {
  189|     10|                a.nth(0).clone()
  190|       |            } else {
  191|      7|                let mid = a.length() / 2;
  192|      7|                let left = a.subseq_copy(0, mid);
  193|      7|                let right = a.subseq_copy(mid, a.length() - mid);
  194|      7|                let left_result = <ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::reduce(&left, f, id.clone());
  195|      7|                let right_result = <ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::reduce(&right, f, id);
  196|      7|                f(&left_result, &right_result)
  197|       |            }
  198|     18|        }
  199|       |
  200|      2|        fn scan<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, id: T) -> (ArraySeqStEphS<T>, T) {
  201|       |            // Algorithm 19.10: scan using contraction (simplified version)
  202|      2|            if a.length() == 0 {
  203|      0|                return (<ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::empty(), id);
  204|      2|            }
  205|      2|            let mut acc = id.clone();
  206|      2|            acc = f(&acc, a.nth(0));
  207|      2|            let mut result_seq = <ArraySeqStEphS<T> as ArraySeqStEphTraitChap18<T>>::new(a.length(), acc.clone());
  208|      7|            for i in 1..a.length() {
                                      ^2^2
  209|      7|                acc = f(&acc, a.nth(i));
  210|      7|                result_seq.set(i, acc.clone()).unwrap();
  211|      7|            }
  212|      2|            (result_seq, acc)
  213|      2|        }
  214|       |
  215|      7|        fn flatten(s: &ArraySeqStEphS<ArraySeqStEphS<T>>) -> ArraySeqStEphS<T> {
  216|       |            // Keep as primitive - flatten is one of the 7 APAS primitives
  217|      7|            <ArraySeqStEphS<T> as ArraySeqStEphTraitChap18<T>>::flatten(s)
  218|      7|        }
  219|       |
  220|      4|        fn isEmpty(a: &ArraySeqStEphS<T>) -> bool {
  221|       |            // Algorithm 19.7: isEmpty a = |a| = 0
  222|      4|            a.length() == 0
  223|      4|        }
  224|       |
  225|      4|        fn isSingleton(a: &ArraySeqStEphS<T>) -> bool {
  226|       |            // Algorithm 19.7: isSingleton a = |a| = 1
  227|      4|            a.length() == 1
  228|      4|        }
  229|       |
  230|      1|        fn update(a: &ArraySeqStEphS<T>, index: N, item: T) -> ArraySeqStEphS<T> {
  231|       |            // Algorithm 19.6: update a (i, x) = tabulate(lambda j. if i = j then x else a[j], |a|)
  232|      1|            <ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::tabulate(
  233|      3|                &|j| if j == index { item.clone() } else { a.nth(j).clone() },
                                                   ^1   ^1               ^2       ^2
  234|      1|                a.length(),
  235|       |            )
  236|      1|        }
  237|       |
  238|      1|        fn inject(base: &ArraySeqStEphS<T>, updates: &[(N, T)]) -> ArraySeqStEphS<T> {
  239|       |            // Used in Algorithm 62.3 (Star Partition)
  240|       |            // Create a mutable copy of the base sequence
  241|      1|            let mut result = base.clone();
  242|       |            // Apply each update
  243|      2|            for (index, value) in updates.iter() {
                                                ^1      ^1
  244|      2|                if *index < result.length() {
  245|      2|                    let _ = result.set(*index, value.clone());
  246|      2|                }
                              ^0
  247|       |            }
  248|      1|            result
  249|      1|        }
  250|       |    }
  251|       |
  252|       |    #[macro_export]
  253|       |    macro_rules! ArraySeqStEphSLit {
  254|       |        () => { $crate::Chap19::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS::from_vec(Vec::new()) };
  255|       |        ($x:expr; $n:expr) => { $crate::Chap19::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS::from_vec(vec![$x; $n]) };
  256|       |        ($($x:expr),* $(,)?) => { $crate::Chap19::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS::from_vec(vec![$($x),*]) };
  257|       |    }
  258|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap19/ArraySeqStPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 19 algorithms for ArraySeqStPer.
    3|       |
    4|       |pub mod ArraySeqStPer {
    5|       |
    6|       |    use crate::Chap18::ArraySeq::ArraySeq::ArraySeq;
    7|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::{
    8|       |        ArraySeqStPerS as ArraySeqStPerSChap18, ArraySeqStPerTrait as ArraySeqStPerTraitChap18,
    9|       |    };
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    pub type ArraySeqStPerS<T> = ArraySeqStPerSChap18<T>;
   13|       |
   14|       |    pub trait ArraySeqStPerTrait<T: StT> {
   15|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   16|       |        fn new(length: N, init_value: T) -> ArraySeqStPerS<T>;
   17|       |        /// claude-4-sonet: Work (1), Span (1)
   18|       |        fn empty() -> ArraySeqStPerS<T>;
   19|       |        /// claude-4-sonet: Work (1), Span (1)
   20|       |        fn singleton(item: T) -> ArraySeqStPerS<T>;
   21|       |        /// claude-4-sonet: Work (1), Span (1)
   22|       |        fn length(&self) -> N;
   23|       |        /// claude-4-sonet: Work (1), Span (1)
   24|       |        fn nth(&self, index: N) -> &T;
   25|       |        /// claude-4-sonet: Work (length), Span (length), Parallelism (1)
   26|       |        fn subseq_copy(&self, start: N, length: N) -> ArraySeqStPerS<T>;
   27|       |
   28|       |        /// APAS: Work (1 +  i=0..n-1 W(f(i))), Span (1 + max i=0..n-1 S(f(i)))
   29|       |        /// claude-4-sonet: Work (n +  W(f(i))), Span (n + max S(f(i))), Parallelism (1)
   30|       |        fn tabulate<F: Fn(N) -> T>(f: &F, n: N) -> ArraySeqStPerS<T>;
   31|       |        /// APAS: Work (1 +  xa W(f(x))), Span (1 + max xa S(f(x)))
   32|       |        /// claude-4-sonet: Work (|a| +  W(f(x))), Span (|a| + max S(f(x))), Parallelism (1)
   33|       |        fn map<U: StT, F: Fn(&T) -> U>(a: &ArraySeqStPerS<T>, f: &F) -> ArraySeqStPerS<U>;
   34|       |        /// APAS: Work (1), Span (1)
   35|       |        /// claude-4-sonet: Work (1), Span (1)
   36|       |        fn select<'a>(a: &'a ArraySeqStPerS<T>, b: &'a ArraySeqStPerS<T>, i: N) -> Option<&'a T>;
   37|       |        /// APAS: Work (1 + |a| + |b|), Span (1)
   38|       |        /// claude-4-sonet: Work (|a| + |b|), Span (|a| + |b|), Parallelism (1)
   39|       |        fn append(a: &ArraySeqStPerS<T>, b: &ArraySeqStPerS<T>) -> ArraySeqStPerS<T>;
   40|       |        /// APAS: Work (1 + |a| + |b|), Span (1)
   41|       |        /// claude-4-sonet: Work (|a| + |b|), Span (|a| + |b|), Parallelism (1)
   42|       |        fn append_select(a: &ArraySeqStPerS<T>, b: &ArraySeqStPerS<T>) -> ArraySeqStPerS<T>;
   43|       |        /// APAS: Work (1), Span (1)
   44|       |        /// claude-4-sonet: Work (1), Span (1)
   45|       |        fn deflate<F: Fn(&T) -> B>(f: &F, x: &T) -> ArraySeqStPerS<T>;
   46|       |        /// APAS: Work (1 +  i=0..|a|-1 W(f(a[i]))), Span (1 + max i S(f(a[i])))
   47|       |        /// claude-4-sonet: Work (|a| +  W(f(a))), Span (|a| + max S(f(a))), Parallelism (1)
   48|       |        fn filter<F: Fn(&T) -> B>(a: &ArraySeqStPerS<T>, pred: &F) -> ArraySeqStPerS<T>;
   49|       |        /// claude-4-sonet: Work (|a|  W(f)), Span (|a|  S(f)), Parallelism (1)
   50|       |        fn iterate<A: StT, F: Fn(&A, &T) -> A>(a: &ArraySeqStPerS<T>, f: &F, x: A) -> A;
   51|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1)
   52|       |        fn reduce<F: Fn(&T, &T) -> T>(a: &ArraySeqStPerS<T>, f: &F, id: T) -> T;
   53|       |        /// claude-4-sonet: Work (|a|), Span (|a|), Parallelism (1)
   54|       |        fn scan<F: Fn(&T, &T) -> T>(a: &ArraySeqStPerS<T>, f: &F, id: T) -> (ArraySeqStPerS<T>, T);
   55|       |        /// claude-4-sonet: Work ( |s|), Span ( |s|), Parallelism (1)
   56|       |        fn flatten(s: &ArraySeqStPerS<ArraySeqStPerS<T>>) -> ArraySeqStPerS<T>;
   57|       |        /// claude-4-sonet: Work (|a| + |updates|), Span (|a| + |updates|), Parallelism (1)
   58|       |        fn inject(a: &ArraySeqStPerS<T>, updates: &ArraySeqStPerS<Pair<N, T>>) -> ArraySeqStPerS<T>;
   59|       |        /// claude-4-sonet: Work (|a| + |updates|), Span (|a| + |updates|), Parallelism (1)
   60|       |        fn ninject(a: &ArraySeqStPerS<T>, updates: &ArraySeqStPerS<Pair<N, T>>) -> ArraySeqStPerS<T>;
   61|       |        /// claude-4-sonet: Work (1), Span (1)
   62|       |        fn isEmpty(a: &ArraySeqStPerS<T>) -> bool;
   63|       |        /// claude-4-sonet: Work (1), Span (1)
   64|       |        fn isSingleton(a: &ArraySeqStPerS<T>) -> bool;
   65|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   66|       |        fn update(a: &ArraySeqStPerS<T>, index: N, item: T) -> ArraySeqStPerS<T>;
   67|       |    }
   68|       |
   69|       |    impl<T: StT> ArraySeqStPerTrait<T> for ArraySeqStPerS<T> {
   70|      2|        fn new(length: N, init_value: T) -> ArraySeqStPerS<T> {
   71|       |            // Keep as primitive - delegates to tabulate
   72|      2|            <ArraySeqStPerS<T> as ArraySeqStPerTraitChap18<T>>::new(length, init_value)
   73|      2|        }
   74|       |
   75|     28|        fn empty() -> ArraySeqStPerS<T> {
   76|       |            // Algorithm 19.1: empty = tabulate(lambda i.i, 0)
   77|     28|            <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::tabulate(
   78|       |                &|_| unreachable!("empty sequence has no elements"),
   79|       |                0,
   80|       |            )
   81|     28|        }
   82|       |
   83|     23|        fn singleton(item: T) -> ArraySeqStPerS<T> {
   84|       |            // Algorithm 19.2: singleton x = tabulate(lambda i.x, 1)
   85|     23|            <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::tabulate(&|_| item.clone(), 1)
   86|     23|        }
   87|       |
   88|      1|        fn length(&self) -> N { ArraySeqStPerTraitChap18::length(self) }
   89|       |
   90|      2|        fn nth(&self, index: N) -> &T { ArraySeqStPerTraitChap18::nth(self, index) }
   91|       |
   92|      0|        fn subseq_copy(&self, start: N, length: N) -> ArraySeqStPerS<T> {
   93|       |            // Keep as primitive - subseq is one of the 7 APAS primitives
   94|      0|            <ArraySeqStPerS<T> as ArraySeqStPerTraitChap18<T>>::subseq_copy(self, start, length)
   95|      0|        }
   96|       |
   97|    472|        fn tabulate<F: Fn(N) -> T>(f: &F, n: N) -> ArraySeqStPerS<T> {
   98|       |            // Keep as primitive - tabulate is one of the 7 APAS primitives
   99|       |            // Implement directly to handle closures (can't delegate to Chap18 fn pointers)
  100|    472|            let mut values: Vec<T> = Vec::with_capacity(n);
  101|  1.52k|            for i in 0..n {
                                      ^472
  102|  1.52k|                values.push(f(i));
  103|  1.52k|            }
  104|    472|            ArraySeqStPerS::from_vec(values)
  105|    472|        }
  106|       |
  107|      6|        fn map<U: StT, F: Fn(&T) -> U>(a: &ArraySeqStPerS<T>, f: &F) -> ArraySeqStPerS<U> {
  108|       |            // Algorithm 19.3: map f a = tabulate(lambda i.f(a[i]), |a|)
  109|     53|            <ArraySeqStPerS<U> as ArraySeqStPerTrait<U>>::tabulate(&|i| f(a.nth(i)), a.length())
                          ^6                                                                       ^6^6
  110|      6|        }
  111|       |
  112|      7|        fn select<'a>(a: &'a ArraySeqStPerS<T>, b: &'a ArraySeqStPerS<T>, i: N) -> Option<&'a T> {
  113|      7|            let len_a = a.length();
  114|      7|            if i < len_a {
  115|      4|                return Some(a.nth(i));
  116|      3|            }
  117|      3|            let offset = i - len_a;
  118|      3|            let len_b = b.length();
  119|      3|            if offset < len_b { Some(b.nth(offset)) } else { None }
                                                                           ^0
  120|      7|        }
  121|       |
  122|    180|        fn append(a: &ArraySeqStPerS<T>, b: &ArraySeqStPerS<T>) -> ArraySeqStPerS<T> {
  123|       |            // Algorithm 19.4: append a b = flatten([a, b])
  124|    180|            let sequences = <ArraySeqStPerS<ArraySeqStPerS<T>> as ArraySeqStPerTrait<ArraySeqStPerS<T>>>::tabulate(
  125|    360|                &|i| if i == 0 { a.clone() } else { b.clone() },
                                               ^180^180             ^180^180
  126|       |                2,
  127|       |            );
  128|    180|            <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::flatten(&sequences)
  129|    180|        }
  130|       |
  131|      1|        fn append_select(a: &ArraySeqStPerS<T>, b: &ArraySeqStPerS<T>) -> ArraySeqStPerS<T> {
  132|       |            // Algorithm 19.4 alternative: append a b = tabulate(select(a,b), |a|+|b|)
  133|      1|            <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::tabulate(
  134|      4|                &|i| {
  135|      4|                    <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::select(a, b, i)
  136|      4|                        .unwrap()
  137|      4|                        .clone()
  138|      4|                },
  139|      1|                a.length() + b.length(),
  140|       |            )
  141|      1|        }
  142|       |
  143|     49|        fn deflate<F: Fn(&T) -> B>(f: &F, x: &T) -> ArraySeqStPerS<T> {
  144|       |            // Helper for filter: deflate f x = if f(x) then [x] else []
  145|     49|            if f(x) == true {
  146|     22|                <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::singleton(x.clone())
  147|       |            } else {
  148|     27|                <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::empty()
  149|       |            }
  150|     49|        }
  151|       |
  152|      4|        fn filter<F: Fn(&T) -> B>(a: &ArraySeqStPerS<T>, pred: &F) -> ArraySeqStPerS<T> {
  153|       |            // Algorithm 19.5: filter f a = flatten(map(deflate f, a))
  154|     46|            let deflated = <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::map(a, &|x| {
                              ^4         ^4                                                ^4
  155|     46|                <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::deflate(pred, x)
  156|     46|            });
  157|      4|            <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::flatten(&deflated)
  158|      4|        }
  159|       |
  160|      2|        fn iterate<A: StT, F: Fn(&A, &T) -> A>(a: &ArraySeqStPerS<T>, f: &F, x: A) -> A {
  161|       |            // Algorithm 19.8: iterate f x a = left-to-right traversal
  162|      2|            let mut acc = x;
  163|      9|            for i in 0..a.length() {
                                      ^2^2
  164|      9|                acc = f(&acc, a.nth(i));
  165|      9|            }
  166|      2|            acc
  167|      2|        }
  168|       |
  169|     16|        fn reduce<F: Fn(&T, &T) -> T>(a: &ArraySeqStPerS<T>, f: &F, id: T) -> T {
  170|       |            // Algorithm 19.9: reduce using divide-and-conquer
  171|     16|            if a.length() == 0 {
  172|      0|                id
  173|     16|            } else if a.length() == 1 {
  174|      9|                a.nth(0).clone()
  175|       |            } else {
  176|      7|                let mid = a.length() / 2;
  177|      7|                let left = a.subseq_copy(0, mid);
  178|      7|                let right = a.subseq_copy(mid, a.length() - mid);
  179|      7|                let left_result = <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::reduce(&left, f, id.clone());
  180|      7|                let right_result = <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::reduce(&right, f, id);
  181|      7|                f(&left_result, &right_result)
  182|       |            }
  183|     16|        }
  184|       |
  185|      2|        fn scan<F: Fn(&T, &T) -> T>(a: &ArraySeqStPerS<T>, f: &F, id: T) -> (ArraySeqStPerS<T>, T) {
  186|       |            // Algorithm 19.10: scan using contraction (simplified version)
  187|      2|            let mut acc = id.clone();
  188|      2|            let mut results = Vec::with_capacity(a.length());
  189|      9|            for i in 0..a.length() {
                                      ^2^2
  190|      9|                acc = f(&acc, a.nth(i));
  191|      9|                results.push(acc.clone());
  192|      9|            }
  193|       |            // Implement directly since we can't capture with &F
  194|      2|            let result_seq = ArraySeqStPerS::from_vec(results);
  195|      2|            (result_seq, acc)
  196|      2|        }
  197|       |
  198|    190|        fn flatten(s: &ArraySeqStPerS<ArraySeqStPerS<T>>) -> ArraySeqStPerS<T> {
  199|       |            // Keep as primitive - flatten is one of the 7 APAS primitives
  200|    190|            <ArraySeqStPerS<T> as ArraySeqStPerTraitChap18<T>>::flatten(s)
  201|    190|        }
  202|       |
  203|      2|        fn inject(a: &ArraySeqStPerS<T>, updates: &ArraySeqStPerS<Pair<N, T>>) -> ArraySeqStPerS<T> {
  204|       |            // Keep as primitive - inject is one of the 7 APAS primitives
  205|      2|            <ArraySeqStPerS<T> as ArraySeqStPerTraitChap18<T>>::inject(a, updates)
  206|      2|        }
  207|       |
  208|      3|        fn ninject(a: &ArraySeqStPerS<T>, updates: &ArraySeqStPerS<Pair<N, T>>) -> ArraySeqStPerS<T> {
  209|       |            // Keep as primitive - ninject is one of the 7 APAS primitives
  210|      3|            <ArraySeqStPerS<T> as ArraySeqStPerTraitChap18<T>>::ninject(a, updates)
  211|      3|        }
  212|       |
  213|      2|        fn isEmpty(a: &ArraySeqStPerS<T>) -> bool {
  214|       |            // Algorithm 19.7: isEmpty a = |a| = 0
  215|      2|            a.length() == 0
  216|      2|        }
  217|       |
  218|      1|        fn isSingleton(a: &ArraySeqStPerS<T>) -> bool {
  219|       |            // Algorithm 19.7: isSingleton a = |a| = 1
  220|      1|            a.length() == 1
  221|      1|        }
  222|       |
  223|     84|        fn update(a: &ArraySeqStPerS<T>, index: N, item: T) -> ArraySeqStPerS<T> {
  224|       |            // Algorithm 19.6: update a (i, x) = tabulate(lambda j. if i = j then x else a[j], |a|)
  225|     84|            <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::tabulate(
  226|    341|                &|j| if j == index { item.clone() } else { a.nth(j).clone() },
                                                   ^84  ^84              ^257     ^257
  227|     84|                a.length(),
  228|       |            )
  229|     84|        }
  230|       |    }
  231|       |
  232|       |    #[macro_export]
  233|       |    macro_rules! ArraySeqStPerSLit {
  234|       |        () => { $crate::Chap19::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS::from_vec(Vec::new()) };
  235|       |        ($x:expr; $n:expr) => { $crate::Chap19::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS::from_vec(vec![$x; $n]) };
  236|       |        ($($x:expr),* $(,)?) => { $crate::Chap19::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS::from_vec(vec![$($x),*]) };
  237|       |    }
  238|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap21/Algorithm21_1.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 21  Algorithm 21.1: 2D Points using ArraySeqPer via tabulate + flatten.
    3|       |
    4|       |pub mod Algorithm21_1 {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Types::Types::*;
    8|       |
    9|       |    pub trait Algorithm21_1Trait {
   10|       |        /// Algorithm 21.1 (2D Points) using ArraySeqPer: points2D via tabulate + flatten
   11|       |        /// APAS: Work (n), Span (lg n)
   12|       |        fn points2d_tab_flat(n: N) -> ArraySeqStPerS<Pair<N, N>>;
   13|       |    }
   14|       |
   15|       |    /// Algorithm 21.1 (2D Points) using ArraySeqPer: points2D via tabulate + flatten.
   16|       |    /// Functional form: points2D n = flatten (tabulate (\x. tabulate (\y. (x, y+1)) (n-1)) n)
   17|       |    ///
   18|       |    /// Generates all 2D points (x, y) where 0  x < n and 1  y < n.
   19|       |    /// gpt-5-hard: Work: (n), Span: (lg n)
   20|       |    /// APAS: Work: (n), Span: (lg n)
   21|      5|    pub fn points2d_tab_flat(n: N) -> ArraySeqStPerS<Pair<N, N>> {
   22|      5|        if n == 0 {
   23|      0|            return ArraySeqStPerS::from_vec(Vec::new());
   24|      5|        }
   25|      5|        let inner: ArraySeqStPerS<ArraySeqStPerS<Pair<N, N>>> =
   26|      5|            <ArraySeqStPerS<ArraySeqStPerS<Pair<N, N>>> as ArraySeqStPerTrait<ArraySeqStPerS<Pair<N, N>>>>::tabulate(
   27|     13|                &|x| {
   28|     26|                    <ArraySeqStPerS<Pair<N, N>> as ArraySeqStPerTrait<Pair<N, N>>>::tabulate(&|y| Pair(x, y + 1), n - 1)
                                  ^13                                                                                           ^13
   29|     13|                },
   30|      5|                n,
   31|       |            );
   32|      5|        <ArraySeqStPerS<Pair<N, N>> as ArraySeqStPerTrait<Pair<N, N>>>::flatten(&inner)
   33|      5|    }
   34|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap21/Algorithm21_2.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 21  Algorithm 21.2: 3D Points using ArraySeqPer via flatten of nested tabulates.
    3|       |
    4|       |pub mod Algorithm21_2 {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Types::Types::*;
    8|       |
    9|       |    pub trait Algorithm21_2Trait {
   10|       |        /// Algorithm 21.2 (3D Points) using ArraySeqPer: flatten of nested tabulates
   11|       |        /// APAS: Work (n), Span (lg n)
   12|       |        fn points3d_tab_flat(n: N) -> ArraySeqStPerS<Pair<N, Pair<N, N>>>;
   13|       |    }
   14|       |
   15|       |    /// Algorithm 21.2 (3D Points) using ArraySeqPer: flatten of nested tabulates.
   16|       |    /// Comprehension form: (x,y,z): 0  x  n1, 1  y  n, 2  z  n+1
   17|       |    /// Implemented as: flatten  (tabulate_x (flatten  (tabulate_y (tabulate_z))))
   18|       |    ///
   19|       |    /// Generates all 3D points (x, y, z) where 0  x < n, 1  y  n, 2  z  n+1.
   20|       |    /// gpt-5-hard: Work: (n), Span: (lg n)
   21|       |    /// APAS: Work: (n), Span: (lg n)
   22|      5|    pub fn points3d_tab_flat(n: N) -> ArraySeqStPerS<Pair<N, Pair<N, N>>> {
   23|      5|        if n == 0 {
   24|      1|            return ArraySeqStPerS::from_vec(Vec::new());
   25|      4|        }
   26|      4|        let outer: ArraySeqStPerS<ArraySeqStPerS<Pair<N, Pair<N, N>>>> = <ArraySeqStPerS<
   27|      4|            ArraySeqStPerS<Pair<N, Pair<N, N>>>,
   28|      4|        > as ArraySeqStPerTrait<
   29|      4|            ArraySeqStPerS<Pair<N, Pair<N, N>>>,
   30|      4|        >>::tabulate(
   31|      7|            &|x| {
   32|      7|                let mid: ArraySeqStPerS<ArraySeqStPerS<Pair<N, Pair<N, N>>>> =
   33|      7|                    <ArraySeqStPerS<ArraySeqStPerS<Pair<N, Pair<N, N>>>> as ArraySeqStPerTrait<
   34|      7|                        ArraySeqStPerS<Pair<N, Pair<N, N>>>,
   35|      7|                    >>::tabulate(
   36|     13|                        &|y| {
   37|     13|                            <ArraySeqStPerS<Pair<N, Pair<N, N>>> as ArraySeqStPerTrait<Pair<N, Pair<N, N>>>>::tabulate(
   38|     25|                                &|z_idx| Pair(x, Pair(y + 1, z_idx + 2)),
   39|     13|                                n + 1 - 2 + 1, // z: 2..=n+1 has length n
   40|       |                            )
   41|     13|                        },
   42|      7|                        n, // y: 1..=n has length n
   43|       |                    );
   44|      7|                <ArraySeqStPerS<Pair<N, Pair<N, N>>> as ArraySeqStPerTrait<Pair<N, Pair<N, N>>>>::flatten(&mid)
   45|      7|            },
   46|      4|            n,
   47|       |        );
   48|      4|        <ArraySeqStPerS<Pair<N, Pair<N, N>>> as ArraySeqStPerTrait<Pair<N, Pair<N, N>>>>::flatten(&outer)
   49|      5|    }
   50|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap21/Algorithm21_5.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 21  Algorithm 21.5: Brute Force Solution to the Primes Problem.
    3|       |
    4|       |pub mod Algorithm21_5 {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Chap21::Exercise21_8::Exercise21_8::is_prime;
    8|       |    use crate::Types::Types::*;
    9|       |
   10|       |    pub trait Algorithm21_5Trait {
   11|       |        /// Algorithm 21.5 (Brute Force Solution to the Primes Problem)
   12|       |        /// APAS: Work (n^{3/2}), Span (lg n)
   13|       |        fn primes_bf(n: N) -> ArraySeqStPerS<N>;
   14|       |    }
   15|       |
   16|       |    /// Algorithm 21.5 (Brute Force Solution to the Primes Problem)
   17|       |    /// primesBF n = { i in 2..n : isPrime(i) }
   18|       |    ///
   19|       |    /// Finds all prime numbers less than n using brute force primality testing.
   20|       |    ///
   21|       |    /// APAS: Work: (n^{3/2}), Span: (lg n)
   22|       |    /// gpt-5-hard: Work: (n^{3/2}), Span: (lg n)
   23|      5|    pub fn primes_bf(n: N) -> ArraySeqStPerS<N> {
   24|      5|        if n <= 2 {
   25|      2|            return ArraySeqStPerS::from_vec(Vec::new());
   26|      3|        }
   27|     12|        let all: ArraySeqStPerS<N> = <ArraySeqStPerS<N> as ArraySeqStPerTrait<N>>::tabulate(&|i| i + 2, n - 2);
                          ^3   ^3                  ^3                                                                 ^3
   28|     12|        let filtered: ArraySeqStPerS<N> = <ArraySeqStPerS<N> as ArraySeqStPerTrait<N>>::filter(&all, &|x| is_prime(*x));
                          ^3        ^3                  ^3                                                   ^3
   29|      3|        filtered
   30|      5|    }
   31|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap21/Algorithm21_6.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 21  Algorithm 21.6: Prime Sieve using ArraySeqPer and ninject.
    3|       |
    4|       |pub mod Algorithm21_6 {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Types::Types::*;
    8|       |
    9|       |    pub trait Algorithm21_6Trait {
   10|       |        /// Algorithm 21.6 (Prime Sieve) using ArraySeqPer - simplified version
   11|       |        /// APAS: Work (n lg n), Span (lg n)
   12|       |        fn prime_sieve(n: N) -> ArraySeqStPerS<N>;
   13|       |    }
   14|       |
   15|       |    /// Algorithm 21.6 (Prime Sieve) using ArraySeqPer - simplified version.
   16|       |    /// Construct primes using a sieve: generate composites, then filter candidates.
   17|       |    ///
   18|       |    /// Uses the sieve of Eratosthenes approach with functional programming constructs.
   19|       |    /// gpt-5-hard: Work: (n lg n), Span: (lg n)
   20|       |    /// APAS: Work: (n lg n), Span: (lg n)
   21|     16|    pub fn prime_sieve(n: N) -> ArraySeqStPerS<N> {
   22|     16|        if n <= 2 {
   23|      3|            return ArraySeqStPerS::from_vec(Vec::new());
   24|     13|        }
   25|       |        // cs =  i * j : 2  i  floor(sqrt(n)) , 2  j  n/i 
   26|     13|        let root: N = (n as f64).sqrt().floor() as N;
   27|     13|        let nested: ArraySeqStPerS<ArraySeqStPerS<N>> =
   28|     13|            <ArraySeqStPerS<ArraySeqStPerS<N>> as ArraySeqStPerTrait<ArraySeqStPerS<N>>>::tabulate(
   29|     54|                &|i0| {
   30|     54|                    let i = i0 + 2; // i in [2..=root]
   31|     54|                    let limit = if i == 0 { 0 } else { n / i };
                                                          ^0
   32|     54|                    let len = if limit >= 2 { limit - 1 } else { 0 }; // j in [2..=limit] => length max(limit-1,0)
                                                                               ^0
   33|    890|                    <ArraySeqStPerS<N> as ArraySeqStPerTrait<N>>::tabulate(&|j0| i * (j0 + 2), len)
                                  ^54                                                                        ^54
   34|     54|                },
   35|     13|                if root >= 2 { root - 1 } else { 0 },
                                             ^12               ^1
   36|       |            );
   37|     13|        let composites: ArraySeqStPerS<N> = <ArraySeqStPerS<N> as ArraySeqStPerTrait<N>>::flatten(&nested);
   38|       |
   39|       |        // Create candidates: 2, 3, ..., n
   40|    525|        let candidates: ArraySeqStPerS<N> = <ArraySeqStPerS<N> as ArraySeqStPerTrait<N>>::tabulate(&|i| i + 2, n - 1);
                          ^13         ^13                 ^13                                                                ^13
   41|       |
   42|       |        // Filter out composites to get primes
   43|    525|        let filtered: ArraySeqStPerS<N> = <ArraySeqStPerS<N> as ArraySeqStPerTrait<N>>::filter(&candidates, &|x| {
                          ^13       ^13                 ^13                                                  ^13
   44|       |            // Check if x is NOT in composites
   45|    525|            let mut is_composite = false;
   46|  48.7k|            for i in 0..composites.length() {
                                      ^525       ^525
   47|  48.7k|                if *composites.nth(i) == *x {
   48|    372|                    is_composite = true;
   49|    372|                    break;
   50|  48.4k|                }
   51|       |            }
   52|    525|            if is_composite { false } else { true }
                                            ^372           ^153
   53|    525|        });
   54|     13|        filtered
   55|     16|    }
   56|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap21/Exercise21_5.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 21  Exercise 21.5: All contiguous subsequences.
    3|       |
    4|       |pub mod Exercise21_5 {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Types::Types::*;
    8|       |
    9|       |    pub trait Exercise21_5Trait {
   10|       |        /// Exercise 21.5: Generate all contiguous subsequences using nested tabulate + flatten
   11|       |        /// APAS: Work (n), Span (lg n)
   12|       |        fn all_contiguous_subseqs<T: StT>(a: &ArraySeqStPerS<T>) -> ArraySeqStPerS<ArraySeqStPerS<T>>;
   13|       |    }
   14|       |
   15|       |    /// Exercise 21.5: Generate all contiguous subsequences using nested tabulate + flatten.
   16|       |    ///
   17|       |    /// gpt-5-hard: Work: (n), Span: (lg n)
   18|       |    /// APAS: Work: (n), Span: (lg n)
   19|      3|    pub fn all_contiguous_subseqs<T: StT>(a: &ArraySeqStPerS<T>) -> ArraySeqStPerS<ArraySeqStPerS<T>> {
   20|      3|        let n = a.length();
   21|      3|        let nested: ArraySeqStPerS<ArraySeqStPerS<ArraySeqStPerS<T>>> =
   22|      3|            <ArraySeqStPerS<ArraySeqStPerS<ArraySeqStPerS<T>>> as ArraySeqStPerTrait<
   23|      3|                ArraySeqStPerS<ArraySeqStPerS<T>>,
   24|      3|            >>::tabulate(
   25|      5|                &|i| {
   26|      5|                    <ArraySeqStPerS<ArraySeqStPerS<T>> as ArraySeqStPerTrait<ArraySeqStPerS<T>>>::tabulate(
   27|      9|                        &|j| a.subseq_copy(i, j + 1),
   28|      5|                        n - i,
   29|       |                    )
   30|      5|                },
   31|      3|                n,
   32|       |            );
   33|       |        // flatten twice
   34|      3|        let mid: ArraySeqStPerS<ArraySeqStPerS<T>> =
   35|      3|            <ArraySeqStPerS<ArraySeqStPerS<T>> as ArraySeqStPerTrait<ArraySeqStPerS<T>>>::flatten(&nested);
   36|      3|        mid
   37|      3|    }
   38|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap21/Exercise21_7.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 21  Exercise 21.7: Comprehension with Conditionals - even elements paired with vowels.
    3|       |
    4|       |pub mod Exercise21_7 {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Types::Types::*;
    8|       |
    9|       |    pub trait Exercise21_7Trait {
   10|       |        /// Check if a number is even
   11|       |        /// APAS: Work (1), Span (1)
   12|       |        fn is_even(x: &N) -> B;
   13|       |
   14|       |        /// Check if a character is a vowel (case-insensitive)
   15|       |        /// APAS: Work (1), Span (1)
   16|       |        fn is_vowel(c: &char) -> B;
   17|       |
   18|       |        /// Exercise 21.7: Comprehension with conditionals
   19|       |        /// APAS: Work (|a||b|), Span (lg |a|)
   20|       |        fn pair_even_with_vowels(a: &ArraySeqStPerS<N>, b: &ArraySeqStPerS<char>) -> ArraySeqStPerS<Pair<N, char>>;
   21|       |    }
   22|       |
   23|       |    /// Check if a number is even
   24|      5|    pub fn is_even(x: &N) -> B { if *x % 2 == 0 { true } else { false } }
                                                                ^3            ^2
   25|       |
   26|       |    /// Check if a character is a vowel (case-insensitive)
   27|      5|    pub fn is_vowel(c: &char) -> B {
   28|      5|        match *c {
   29|      3|            | 'a' | 'e' | 'i' | 'o' | 'u' | 'A' | 'E' | 'I' | 'O' | 'U' => true,
   30|      2|            | _ => false,
   31|       |        }
   32|      5|    }
   33|       |
   34|       |    /// Exercise 21.7: Comprehension with conditionals
   35|       |    /// flatten   (x, y) : y  b | isVowel y  : x  a | isEven x 
   36|       |    ///
   37|       |    /// Pairs even elements of sequence a with vowels of sequence b.
   38|       |    /// gpt-5-hard: Work: (|a||b|), Span: (lg |a|)
   39|       |    /// APAS: Work: (|a||b|), Span: (lg |a|)
   40|      2|    pub fn pair_even_with_vowels(a: &ArraySeqStPerS<N>, b: &ArraySeqStPerS<char>) -> ArraySeqStPerS<Pair<N, char>> {
   41|      5|        let filtered_a = <ArraySeqStPerS<N> as ArraySeqStPerTrait<N>>::filter(a, &|x| is_even(x));
                          ^2           ^2                                                   ^2
   42|      5|        let filtered_b = <ArraySeqStPerS<char> as ArraySeqStPerTrait<char>>::filter(b, &|y| is_vowel(y));
                          ^2           ^2                                                         ^2
   43|       |
   44|      2|        let nested = <ArraySeqStPerS<ArraySeqStPerS<Pair<N, char>>> as ArraySeqStPerTrait<
   45|      2|            ArraySeqStPerS<Pair<N, char>>,
   46|      2|        >>::tabulate(
   47|      3|            &|i| {
   48|      3|                let x = filtered_a.nth(i);
   49|      3|                <ArraySeqStPerS<Pair<N, char>> as ArraySeqStPerTrait<Pair<N, char>>>::tabulate(
   50|      5|                    &|j| Pair(*x, *filtered_b.nth(j)),
   51|      3|                    filtered_b.length(),
   52|       |                )
   53|      3|            },
   54|      2|            filtered_a.length(),
   55|       |        );
   56|      2|        <ArraySeqStPerS<Pair<N, char>> as ArraySeqStPerTrait<Pair<N, char>>>::flatten(&nested)
   57|      2|    }
   58|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap21/Exercise21_8.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 21  Exercise 21.8: Brute Force Primality Test (isPrime).
    3|       |
    4|       |pub mod Exercise21_8 {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Types::Types::*;
    8|       |
    9|       |    pub trait Exercise21_8Trait {
   10|       |        /// Helper function to check divisibility
   11|       |        /// APAS: Work (1), Span (1)
   12|       |        fn is_divisible(n: N, i: N) -> B;
   13|       |
   14|       |        /// Exercise 21.8 / Algorithm 21.4 (Brute Force Primality Test)
   15|       |        /// APAS: Work (n), Span (lg n)
   16|       |        fn is_prime(n: N) -> B;
   17|       |    }
   18|       |
   19|       |    /// Helper function to check divisibility
   20|     31|    pub fn is_divisible(n: N, i: N) -> B { if n % i == 0 { true } else { false } }
                                                                         ^25           ^6
   21|       |
   22|       |    /// Exercise 21.8 / Algorithm 21.4 (Brute Force Primality Test)
   23|       |    /// isPrime n = |{ x in 1..=floor(sqrt(n)) : n mod i == 0 }| == 1
   24|       |    ///
   25|       |    /// Tests if a number is prime by checking divisibility up to sqrt(n).
   26|       |    /// Only the divisor 1 should divide n for it to be prime.
   27|       |    ///
   28|       |    /// gpt-5-hard: Work: (n), Span: (lg n)
   29|       |    /// APAS: Work: (n), Span: (lg n)
   30|     18|    pub fn is_prime(n: N) -> B {
   31|     18|        if n < 2 {
   32|      2|            return false;
   33|     16|        }
   34|     16|        let k: N = (n as f64).sqrt().floor() as N;
   35|     16|        let all: ArraySeqStPerS<B> =
   36|     27|            <ArraySeqStPerS<B> as ArraySeqStPerTrait<B>>::tabulate(&|i| is_divisible(n, i + 1), k);
                          ^16                                                                                 ^16
   37|     16|        let ones: ArraySeqStPerS<B> = <ArraySeqStPerS<B> as ArraySeqStPerTrait<B>>::filter(&all, &|x| *x);
   38|     16|        if ones.length() == 1 { true } else { false }
                                              ^9            ^7
   39|     18|    }
   40|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap21/Problem21_1.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 21  Problem 21.1: Points in 2D using imperative loops.
    3|       |
    4|       |pub mod Problem21_1 {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Types::Types::*;
    8|       |
    9|       |    pub trait Problem21_1Trait {
   10|       |        /// Problem 21.1 (Points in 2D) - Imperative approach using nested loops
   11|       |        /// APAS: Work (n), Span (n)
   12|       |        fn points2d(n: N) -> ArraySeqStPerS<Pair<N, N>>;
   13|       |    }
   14|       |
   15|       |    /// Problem 21.1 (Points in 2D) - Imperative approach using nested loops.
   16|       |    /// Construct the sequence of 2D points (x, y) with 0  x < n and 1  y < n,
   17|       |    /// ordered by x major, then y.
   18|       |    ///
   19|       |    /// This is an educational example showing imperative style for comparison.
   20|       |    /// Work: (n), Span: (n) (sequential due to imperative loops)
   21|      0|    pub fn points2d(n: N) -> ArraySeqStPerS<Pair<N, N>> {
   22|      0|        if n == 0 {
   23|      0|            return ArraySeqStPerS::from_vec(Vec::new());
   24|      0|        }
   25|      0|        let len = n * (n - 1);
   26|      0|        let mut v: Vec<Pair<N, N>> = Vec::with_capacity(len);
   27|      0|        for x in 0..n {
   28|      0|            for y in 1..n {
   29|      0|                v.push(Pair(x, y));
   30|      0|            }
   31|       |        }
   32|      0|        ArraySeqStPerS::from_vec(v)
   33|      0|    }
   34|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap21/Problem21_3.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 21  Problem 21.3: Points in 3D using imperative triple loop.
    3|       |
    4|       |pub mod Problem21_3 {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Types::Types::*;
    8|       |
    9|       |    pub trait Problem21_3Trait {
   10|       |        /// Problem 21.3 (Points in 3D) using ArraySeqPer  imperative triple loop
   11|       |        /// APAS: Work (n), Span (n)
   12|       |        fn points3d_loops(n: N) -> ArraySeqStPerS<Pair<N, Pair<N, N>>>;
   13|       |    }
   14|       |
   15|       |    /// Problem 21.3 (Points in 3D) using ArraySeqPer  imperative triple loop.
   16|       |    /// Generate points (x, y, z) with 0  x  n1, 1  y  n, 2  z  n+1 in x-major, then y, then z order.
   17|       |    ///
   18|       |    /// This is an educational example showing imperative style for comparison with functional approaches.
   19|       |    /// The triple loop is intentionally inefficient (sequential) to contrast with parallel functional methods.
   20|       |    /// gpt-5-hard: Work: (n), Span: (n) (sequential due to imperative loops)
   21|       |    /// APAS: Work: (n), Span: (n)
   22|      0|    pub fn points3d_loops(n: N) -> ArraySeqStPerS<Pair<N, Pair<N, N>>> {
   23|      0|        if n == 0 {
   24|      0|            return ArraySeqStPerS::from_vec(Vec::new());
   25|      0|        }
   26|      0|        let len = n * n * n;
   27|      0|        let mut v: Vec<Pair<N, Pair<N, N>>> = Vec::with_capacity(len);
   28|      0|        for x in 0..n {
   29|      0|            for y in 1..=n {
   30|      0|                for z in 2..=n + 1 {
   31|      0|                    v.push(Pair(x, Pair(y, z)));
   32|      0|                }
   33|       |            }
   34|       |        }
   35|      0|        ArraySeqStPerS::from_vec(v)
   36|      0|    }
   37|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap21/Problem21_4.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 21  Problem 21.4: Cartesian Product using different approaches.
    3|       |
    4|       |pub mod Problem21_4 {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Types::Types::*;
    8|       |
    9|       |    pub trait Problem21_4Trait {
   10|       |        /// Problem 21.4 (Cartesian Product) - Imperative approach using explicit loops
   11|       |        /// APAS: Work (|a||b|), Span (|a||b|)
   12|       |        fn cartesian_loops(
   13|       |            a: &ArraySeqStPerS<N>,
   14|       |            b: &ArraySeqStPerS<&'static str>,
   15|       |        ) -> ArraySeqStPerS<Pair<N, &'static str>>;
   16|       |
   17|       |        /// Cartesian product using functional approach with tabulate + flatten
   18|       |        /// APAS: Work (|a||b|), Span (lg |a|)
   19|       |        fn cartesian_functional(
   20|       |            a: &ArraySeqStPerS<N>,
   21|       |            b: &ArraySeqStPerS<&'static str>,
   22|       |        ) -> ArraySeqStPerS<Pair<N, &'static str>>;
   23|       |    }
   24|       |
   25|       |    /// Problem 21.4 (Cartesian Product) - Imperative approach using explicit loops.
   26|       |    /// Cartesian product by explicit loops (x-major then y).
   27|       |    ///
   28|       |    /// This is an educational example showing imperative style for comparison.
   29|       |    /// gpt-5-hard: Work: (|a||b|), Span: (|a||b|) (sequential due to imperative loops)
   30|       |    /// APAS: Work: (|a||b|), Span: (|a||b|)
   31|      0|    pub fn cartesian_loops(
   32|      0|        a: &ArraySeqStPerS<N>,
   33|      0|        b: &ArraySeqStPerS<&'static str>,
   34|      0|    ) -> ArraySeqStPerS<Pair<N, &'static str>> {
   35|      0|        let mut v: Vec<Pair<N, &'static str>> = Vec::with_capacity(a.length() * b.length());
   36|      0|        for i in 0..a.length() {
   37|      0|            for j in 0..b.length() {
   38|      0|                v.push(Pair(*a.nth(i), *b.nth(j)));
   39|      0|            }
   40|       |        }
   41|      0|        ArraySeqStPerS::from_vec(v)
   42|      0|    }
   43|       |
   44|       |    /// Problem 21.4 (Cartesian Product) - Functional approach using tabulate + flatten.
   45|       |    /// Cartesian product using map + flatten: flatten(map(\x. map(\y. (x,y)) b) a)
   46|       |    ///
   47|       |    /// This shows the functional parallel approach for comparison with the imperative version.
   48|       |    /// gpt-5-hard: Work: (|a||b|), Span: (lg |a|)
   49|       |    /// APAS: Work: (|a||b|), Span: (lg |a|)
   50|      0|    pub fn cartesian_tab_flat(
   51|      0|        a: &ArraySeqStPerS<N>,
   52|      0|        b: &ArraySeqStPerS<&'static str>,
   53|      0|    ) -> ArraySeqStPerS<Pair<N, &'static str>> {
   54|      0|        let nested: ArraySeqStPerS<ArraySeqStPerS<Pair<N, &'static str>>> =
   55|      0|            <ArraySeqStPerS<ArraySeqStPerS<Pair<N, &'static str>>> as ArraySeqStPerTrait<
   56|      0|                ArraySeqStPerS<Pair<N, &'static str>>,
   57|      0|            >>::tabulate(
   58|      0|                &|i| {
   59|      0|                    let x = *a.nth(i);
   60|      0|                    <ArraySeqStPerS<Pair<N, &'static str>> as ArraySeqStPerTrait<Pair<N, &'static str>>>::tabulate(
   61|      0|                        &|j| Pair(x, *b.nth(j)),
   62|      0|                        b.length(),
   63|       |                    )
   64|      0|                },
   65|      0|                a.length(),
   66|       |            );
   67|      0|        <ArraySeqStPerS<Pair<N, &'static str>> as ArraySeqStPerTrait<Pair<N, &'static str>>>::flatten(&nested)
   68|      0|    }
   69|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap23/BalBinTreeStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Ephemeral full binary tree utilities (Chapter 23).
    3|       |
    4|       |pub mod BalBinTreeStEph {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Types::Types::*;
    8|       |
    9|       |    #[derive(Clone, PartialEq, Eq, Debug)]
   10|       |    pub enum BalBinTree<T: StT> {
   11|       |        Leaf,
   12|       |        Node(Box<BalBinNode<T>>),
   13|       |    }
   14|       |
   15|       |    #[derive(Clone, PartialEq, Eq, Debug)]
   16|       |    pub struct BalBinNode<T: StT> {
   17|       |        pub(crate) left: BalBinTree<T>,
   18|       |        pub(crate) value: T,
   19|       |        pub(crate) right: BalBinTree<T>,
   20|       |    }
   21|       |
   22|       |    impl<T: StT> BalBinNode<T> {
   23|    242|        fn new(left: BalBinTree<T>, value: T, right: BalBinTree<T>) -> Self { BalBinNode { left, value, right } }
   24|       |    }
   25|       |
   26|       |    pub trait BalBinTreeStEphTrait<T: StT> {
   27|       |        /// APAS: Work (1), Span (1)
   28|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   29|       |        fn leaf() -> Self;
   30|       |        /// APAS: Work (1), Span (1)
   31|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   32|       |        fn node(left: Self, value: T, right: Self) -> Self;
   33|       |        /// APAS: Work (1), Span (1)
   34|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   35|       |        fn is_leaf(&self) -> B;
   36|       |        /// APAS: Work (n), Span (n)
   37|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1) - sequential traversal with append
   38|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   39|       |        /// APAS: Work (n), Span (n)
   40|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1) - sequential traversal with append
   41|       |        fn pre_order(&self) -> ArraySeqStPerS<T>;
   42|       |        /// APAS: Work (n), Span (n)
   43|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1) - sequential tree traversal
   44|       |        fn height(&self) -> N;
   45|       |        /// APAS: Work (n), Span (n)
   46|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1) - sequential tree traversal
   47|       |        fn size(&self) -> N;
   48|       |    }
   49|       |
   50|       |    impl<T: StT> BalBinTree<T> {
   51|    478|        pub fn leaf() -> Self { BalBinTree::Leaf }
   52|       |
   53|    242|        pub fn node(left: BalBinTree<T>, value: T, right: BalBinTree<T>) -> Self {
   54|    242|            BalBinTree::Node(Box::new(BalBinNode::new(left, value, right)))
   55|    242|        }
   56|       |
   57|      6|        pub fn is_leaf(&self) -> B {
   58|      6|            match self {
   59|      3|                | BalBinTree::Leaf => true,
   60|      3|                | BalBinTree::Node(_) => false,
   61|       |            }
   62|      6|        }
   63|       |
   64|    418|        pub fn in_order(&self) -> ArraySeqStPerS<T> {
   65|    418|            match self {
   66|    220|                | BalBinTree::Leaf => <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::empty(),
   67|    198|                | BalBinTree::Node(node) => {
   68|    198|                    let left = node.left.in_order();
   69|    198|                    let middle = <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::singleton(node.value.clone());
   70|    198|                    let right = node.right.in_order();
   71|    198|                    let left_mid = <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::append(&left, &middle);
   72|    198|                    <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::append(&left_mid, &right)
   73|       |                }
   74|       |            }
   75|    418|        }
   76|       |
   77|     85|        pub fn pre_order(&self) -> ArraySeqStPerS<T> {
   78|     85|            match self {
   79|     48|                | BalBinTree::Leaf => <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::empty(),
   80|     37|                | BalBinTree::Node(node) => {
   81|     37|                    let root = <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::singleton(node.value.clone());
   82|     37|                    let left = node.left.pre_order();
   83|     37|                    let right = node.right.pre_order();
   84|     37|                    let root_left = <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::append(&root, &left);
   85|     37|                    <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::append(&root_left, &right)
   86|       |                }
   87|       |            }
   88|     85|        }
   89|       |
   90|    139|        pub fn height(&self) -> N {
   91|    139|            match self {
   92|     80|                | BalBinTree::Leaf => 0,
   93|     59|                | BalBinTree::Node(node) => {
   94|     59|                    let left_h = node.left.height();
   95|     59|                    let right_h = node.right.height();
   96|     59|                    1 + left_h.max(right_h)
   97|       |                }
   98|       |            }
   99|    139|        }
  100|       |
  101|    423|        pub fn size(&self) -> N {
  102|    423|            match self {
  103|    226|                | BalBinTree::Leaf => 0,
  104|    197|                | BalBinTree::Node(node) => 1 + node.left.size() + node.right.size(),
  105|       |            }
  106|    423|        }
  107|       |    }
  108|       |
  109|       |    impl<T: StT> BalBinTreeStEphTrait<T> for BalBinTree<T> {
  110|      0|        fn leaf() -> Self { BalBinTree::leaf() }
  111|       |
  112|      0|        fn node(left: Self, value: T, right: Self) -> Self { BalBinTree::node(left, value, right) }
  113|       |
  114|      0|        fn is_leaf(&self) -> B { BalBinTree::is_leaf(self) }
  115|       |
  116|      0|        fn in_order(&self) -> ArraySeqStPerS<T> { BalBinTree::in_order(self) }
  117|       |
  118|      0|        fn pre_order(&self) -> ArraySeqStPerS<T> { BalBinTree::pre_order(self) }
  119|       |
  120|      0|        fn height(&self) -> N { BalBinTree::height(self) }
  121|       |
  122|      0|        fn size(&self) -> N { BalBinTree::size(self) }
  123|       |    }
  124|       |
  125|       |    #[macro_export]
  126|       |    macro_rules! BalBinNodeLit {
  127|       |        ({ left: $left:expr, value: $value:expr, right: $right:expr }) => {
  128|       |            $crate::Chap23::BalBinTreeStEph::BalBinTreeStEph::BalBinNode::new($left, $value, $right)
  129|       |        };
  130|       |    }
  131|       |
  132|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap23/PrimTreeSeqSt.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Primitive tree sequence implementation for Chapter 23.
    3|       |//!
    4|       |//!  This module defines a single-threaded primitive tree sequence based on the APAS
    5|       |//! specification: sequences may be exposed as `Zero`, `One`, or `Two` parts, and the
    6|       |//! corresponding `join` operation reassembles a sequence while keeping it roughly
    7|       |//! balanced. The balancing here chooses a midpoint split; higher chapters can replace
    8|       |//! this strategy with more sophisticated tree management when needed.
    9|       |
   10|       |pub mod PrimTreeSeqSt {
   11|       |
   12|       |    use crate::Types::Types::*;
   13|       |
   14|       |    /// Trait for primitive tree sequence operations
   15|       |    pub trait PrimTreeSeqStTrait<T: StT> {
   16|       |        /// Creates an empty sequence
   17|       |        /// APAS: Work (1), Span (1)
   18|       |        fn empty() -> Self;
   19|       |
   20|       |        /// Builds a sequence containing a single element
   21|       |        /// APAS: Work (1), Span (1)
   22|       |        fn singleton(value: T) -> Self;
   23|       |
   24|       |        /// Constructs a sequence from the provided vector
   25|       |        /// APAS: Work (1), Span (1)
   26|       |        fn from_vec(vec: Vec<T>) -> Self;
   27|       |
   28|       |        /// Converts this sequence into its backing vector
   29|       |        /// APAS: Work (1), Span (1)
   30|       |        fn into_vec(self) -> Vec<T>;
   31|       |
   32|       |        /// Provides a shared view of the underlying elements
   33|       |        /// APAS: Work (1), Span (1)
   34|       |        fn as_slice(&self) -> &[T];
   35|       |
   36|       |        /// Returns the number of elements in the sequence
   37|       |        /// APAS: Work (1), Span (1)
   38|       |        fn length(&self) -> N;
   39|       |
   40|       |        /// Exposes the internal structure as Zero, One, or Two parts
   41|       |        /// APAS: Work (n), Span (n)
   42|       |        fn expose(&self) -> PrimTreeSeqStTree<T>;
   43|       |
   44|       |        /// Reassembles a primitive tree sequence from an exposed tree
   45|       |        /// APAS: Work (n), Span (n)
   46|       |        fn join(tree: PrimTreeSeqStTree<T>) -> Self;
   47|       |    }
   48|       |
   49|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   50|       |    pub enum PrimTreeSeqStTree<T: StT> {
   51|       |        Zero,
   52|       |        One(T),
   53|       |        Two(PrimTreeSeqStS<T>, PrimTreeSeqStS<T>),
   54|       |    }
   55|       |
   56|       |    /// Primitive tree sequence stored as a persistent Vec-backed collection.
   57|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   58|       |    pub struct PrimTreeSeqStS<T: StT> {
   59|       |        data: Vec<T>,
   60|       |    }
   61|       |
   62|       |    impl<T: StT> PrimTreeSeqStS<T> {
   63|       |        /// Creates an empty sequence.
   64|       |        /// APAS: Work (1), Span (1)
   65|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   66|      7|        pub fn empty() -> Self { Self { data: Vec::new() } }
   67|       |
   68|       |        /// Builds a sequence containing a single element.
   69|       |        /// APAS: Work (1), Span (1)
   70|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   71|      6|        pub fn singleton(value: T) -> Self { Self { data: vec![value] } }
   72|       |
   73|       |        /// Constructs a sequence from the provided vector without additional copying.
   74|       |        /// APAS: Work (1), Span (1)
   75|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1) - just wraps vector
   76|     38|        pub fn from_vec(vec: Vec<T>) -> Self { Self { data: vec } }
   77|       |
   78|       |        /// Converts this sequence into its backing vector.
   79|       |        /// APAS: Work (1), Span (1)
   80|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1) - just unwraps
   81|     12|        pub fn into_vec(self) -> Vec<T> { self.data }
   82|       |
   83|       |        /// Provides a shared view of the underlying elements.
   84|       |        /// APAS: Work (1), Span (1)
   85|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1) - reference operation
   86|     23|        pub fn as_slice(&self) -> &[T] { &self.data }
   87|       |
   88|       |        /// Returns the number of elements in the sequence.
   89|       |        /// APAS: Work (1), Span (1)
   90|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1)
   91|     29|        pub fn length(&self) -> N { self.data.len() }
   92|       |
   93|       |        /// Exposes the internal structure as `Zero`, `One`, or `Two` parts.
   94|       |        /// APAS: Work (n), Span (n)
   95|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1) - sequential split and copy
   96|      7|        pub fn expose(&self) -> PrimTreeSeqStTree<T> {
   97|      7|            match self.data.len() {
   98|      1|                | 0 => PrimTreeSeqStTree::Zero,
   99|      1|                | 1 => PrimTreeSeqStTree::One(self.data[0].clone()),
  100|       |                | _ => {
  101|      5|                    let mid = self.data.len() / 2;
  102|      5|                    let left = self.data[..mid].to_vec();
  103|      5|                    let right = self.data[mid..].to_vec();
  104|      5|                    PrimTreeSeqStTree::Two(PrimTreeSeqStS::from_vec(left), PrimTreeSeqStS::from_vec(right))
  105|       |                }
  106|       |            }
  107|      7|        }
  108|       |
  109|       |        /// Reassembles a primitive tree sequence from an exposed tree.
  110|       |        /// APAS: Work (n), Span (n)
  111|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1) - sequential append
  112|      7|        pub fn join(tree: PrimTreeSeqStTree<T>) -> Self {
  113|      7|            match tree {
  114|      1|                | PrimTreeSeqStTree::Zero => Self::empty(),
  115|      1|                | PrimTreeSeqStTree::One(value) => Self::singleton(value),
  116|      5|                | PrimTreeSeqStTree::Two(left, right) => {
  117|      5|                    let mut combined = left.into_vec();
  118|      5|                    combined.extend(right.into_vec());
  119|      5|                    PrimTreeSeqStS::from_vec(combined)
  120|       |                }
  121|       |            }
  122|      7|        }
  123|       |    }
  124|       |
  125|       |    impl<T: StT> PrimTreeSeqStTrait<T> for PrimTreeSeqStS<T> {
  126|      0|        fn empty() -> Self { Self { data: Vec::new() } }
  127|       |
  128|      0|        fn singleton(value: T) -> Self { Self { data: vec![value] } }
  129|       |
  130|      0|        fn from_vec(vec: Vec<T>) -> Self { Self { data: vec } }
  131|       |
  132|      0|        fn into_vec(self) -> Vec<T> { self.data }
  133|       |
  134|      0|        fn as_slice(&self) -> &[T] { &self.data }
  135|       |
  136|      0|        fn length(&self) -> N { self.data.len() }
  137|       |
  138|      0|        fn expose(&self) -> PrimTreeSeqStTree<T> {
  139|      0|            match self.data.len() {
  140|      0|                | 0 => PrimTreeSeqStTree::Zero,
  141|      0|                | 1 => PrimTreeSeqStTree::One(self.data[0].clone()),
  142|       |                | _ => {
  143|      0|                    let mid = self.data.len() / 2;
  144|      0|                    let left = self.data[..mid].to_vec();
  145|      0|                    let right = self.data[mid..].to_vec();
  146|      0|                    PrimTreeSeqStTree::Two(PrimTreeSeqStS::from_vec(left), PrimTreeSeqStS::from_vec(right))
  147|       |                }
  148|       |            }
  149|      0|        }
  150|       |
  151|      0|        fn join(tree: PrimTreeSeqStTree<T>) -> Self {
  152|      0|            match tree {
  153|      0|                | PrimTreeSeqStTree::Zero => Self::empty(),
  154|      0|                | PrimTreeSeqStTree::One(value) => Self::singleton(value),
  155|      0|                | PrimTreeSeqStTree::Two(left, right) => {
  156|      0|                    let mut combined = left.into_vec();
  157|      0|                    combined.extend(right.into_vec());
  158|      0|                    PrimTreeSeqStS::from_vec(combined)
  159|       |                }
  160|       |            }
  161|      0|        }
  162|       |    }
  163|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap26/DivConReduceMt.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Divide-and-conquer via reduce pattern - parallel implementation (Chapter 26, Section 5).
    3|       |//! Note: Unconditionally parallel - no thresholding per APAS rules.
    4|       |
    5|       |pub mod DivConReduceMt {
    6|       |
    7|       |    use crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::*;
    8|       |    use crate::Types::Types::*;
    9|       |
   10|       |    pub trait DivConReduceMtTrait {
   11|       |        /// Find maximum element via parallel reduce.
   12|       |        /// Pattern: reduce max MIN identity (parallel)
   13|       |        /// APAS: Work (n), Span (log n)
   14|       |        /// claude-4-sonet: Work (n), Span (log n), Parallelism (n/log n)
   15|       |        fn max_element_parallel(a: &ArraySeqMtPerS<N>) -> Option<N>;
   16|       |
   17|       |        /// Sum all elements via parallel reduce.
   18|       |        /// Pattern: reduce (+) 0 identity (parallel)
   19|       |        /// APAS: Work (n), Span (log n)
   20|       |        /// claude-4-sonet: Work (n), Span (log n), Parallelism (n/log n)
   21|       |        fn sum_parallel(a: &ArraySeqMtPerS<N>) -> N;
   22|       |
   23|       |        /// Product of all elements via parallel reduce.
   24|       |        /// Pattern: reduce (*) 1 identity (parallel)
   25|       |        /// APAS: Work (n), Span (log n)
   26|       |        /// claude-4-sonet: Work (n), Span (log n), Parallelism (n/log n)
   27|       |        fn product_parallel(a: &ArraySeqMtPerS<N>) -> N;
   28|       |
   29|       |        /// Logical OR of all elements via parallel reduce.
   30|       |        /// Pattern: reduce (||) false identity (parallel)
   31|       |        /// APAS: Work (n), Span (log n)
   32|       |        /// claude-4-sonet: Work (n), Span (log n), Parallelism (n/log n)
   33|       |        fn any_parallel(a: &ArraySeqMtPerS<B>) -> B;
   34|       |
   35|       |        /// Logical AND of all elements via parallel reduce.
   36|       |        /// Pattern: reduce (&&) true identity (parallel)
   37|       |        /// APAS: Work (n), Span (log n)
   38|       |        /// claude-4-sonet: Work (n), Span (log n), Parallelism (n/log n)
   39|       |        fn all_parallel(a: &ArraySeqMtPerS<B>) -> B;
   40|       |    }
   41|       |
   42|       |    impl DivConReduceMtTrait for ArraySeqMtPerS<N> {
   43|      2|        fn max_element_parallel(a: &ArraySeqMtPerS<N>) -> Option<N> {
   44|      2|            if a.length() == 0 {
   45|      1|                return None;
   46|      1|            }
   47|       |            // Use parallel reduce from ArraySeqMtPer (already uses ParaPair!)
   48|     19|            Some(ArraySeqMtPerS::reduce(a, &|x: &N, y: &N| (*x).max(*y), *a.nth(0)))
                               ^1                     ^1                               ^1
   49|      2|        }
   50|       |
   51|      1|        fn sum_parallel(a: &ArraySeqMtPerS<N>) -> N {
   52|       |            // Use parallel reduce from ArraySeqMtPer (already uses ParaPair!)
   53|     10|            ArraySeqMtPerS::reduce(a, &|x: &N, y: &N| *x + *y, 0)
                          ^1                     ^1
   54|      1|        }
   55|       |
   56|      1|        fn product_parallel(a: &ArraySeqMtPerS<N>) -> N {
   57|       |            // Use parallel reduce from ArraySeqMtPer (already uses ParaPair!)
   58|      4|            ArraySeqMtPerS::reduce(a, &|x: &N, y: &N| *x * *y, 1)
                          ^1                     ^1
   59|      1|        }
   60|       |
   61|      2|        fn any_parallel(a: &ArraySeqMtPerS<B>) -> B {
   62|       |            // Use parallel reduce from ArraySeqMtPer (already uses ParaPair!)
   63|     18|            ArraySeqMtPerS::reduce(a, &|x: &B, y: &B| *x || *y, false)
                          ^2                     ^2                       ^16
   64|      2|        }
   65|       |
   66|      2|        fn all_parallel(a: &ArraySeqMtPerS<B>) -> B {
   67|       |            // Use parallel reduce from ArraySeqMtPer (already uses ParaPair!)
   68|     18|            ArraySeqMtPerS::reduce(a, &|x: &B, y: &B| *x && *y, true)
                          ^2                     ^2                       ^16
   69|      2|        }
   70|       |    }
   71|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap26/DivConReduceSt.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Divide-and-conquer via reduce pattern - sequential implementation (Chapter 26, Section 5).
    3|       |
    4|       |pub mod DivConReduceSt {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Types::Types::*;
    8|       |
    9|       |    pub trait DivConReduceStTrait {
   10|       |        /// Find maximum element via reduce.
   11|       |        /// Pattern: reduce max MIN identity
   12|       |        /// APAS: Work (n), Span (n)
   13|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   14|       |        fn max_element(a: &ArraySeqStPerS<N>) -> Option<N>;
   15|       |
   16|       |        /// Sum all elements via reduce.
   17|       |        /// Pattern: reduce (+) 0 identity
   18|       |        /// APAS: Work (n), Span (n)
   19|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   20|       |        fn sum(a: &ArraySeqStPerS<N>) -> N;
   21|       |
   22|       |        /// Product of all elements via reduce.
   23|       |        /// Pattern: reduce (*) 1 identity
   24|       |        /// APAS: Work (n), Span (n)
   25|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   26|       |        fn product(a: &ArraySeqStPerS<N>) -> N;
   27|       |
   28|       |        /// Logical OR of all elements via reduce.
   29|       |        /// Pattern: reduce (||) false identity
   30|       |        /// APAS: Work (n), Span (n)
   31|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   32|       |        fn any(a: &ArraySeqStPerS<B>) -> B;
   33|       |
   34|       |        /// Logical AND of all elements via reduce.
   35|       |        /// Pattern: reduce (&&) true identity
   36|       |        /// APAS: Work (n), Span (n)
   37|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   38|       |        fn all(a: &ArraySeqStPerS<B>) -> B;
   39|       |    }
   40|       |
   41|       |    impl DivConReduceStTrait for ArraySeqStPerS<N> {
   42|      2|        fn max_element(a: &ArraySeqStPerS<N>) -> Option<N> {
   43|      2|            if a.length() == 0 {
   44|      1|                return None;
   45|      1|            }
   46|     19|            Some(ArraySeqStPerS::reduce(a, &|x, y| (*x).max(*y), *a.nth(0)))
                               ^1                     ^1                       ^1
   47|      2|        }
   48|       |
   49|     10|        fn sum(a: &ArraySeqStPerS<N>) -> N { ArraySeqStPerS::reduce(a, &|x, y| x + y, 0) }
                      ^1                                   ^1                     ^1                   ^1
   50|       |
   51|      4|        fn product(a: &ArraySeqStPerS<N>) -> N { ArraySeqStPerS::reduce(a, &|x, y| x * y, 1) }
                      ^1                                       ^1                     ^1                   ^1
   52|       |
   53|     18|        fn any(a: &ArraySeqStPerS<B>) -> B { ArraySeqStPerS::reduce(a, &|x, y| *x || *y, false) }
                      ^2                                   ^2                     ^2               ^16        ^2
   54|       |
   55|     18|        fn all(a: &ArraySeqStPerS<B>) -> B { ArraySeqStPerS::reduce(a, &|x, y| *x && *y, true) }
                      ^2                                   ^2                     ^2               ^16       ^2
   56|       |    }
   57|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap26/MergeSortMt.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Parallel merge sort implementation (Chapter 26).
    3|       |//! Note: Unconditionally parallel - no thresholding per APAS rules.
    4|       |
    5|       |pub mod MergeSortMt {
    6|       |
    7|       |    use std::sync::Arc;
    8|       |    use std::thread;
    9|       |
   10|       |    use crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::*;
   11|       |    use crate::ParaPair;
   12|       |    use crate::Types::Types::*;
   13|       |
   14|       |    pub trait MergeSortMtTrait<T: StT + Ord + Send + Sync + 'static> {
   15|       |        /// Merge two sorted sequences in parallel using binary search.
   16|       |        /// APAS: Work (n), Span (log n)
   17|       |        /// claude-4-sonet: Work (n), Span (log n), Parallelism (n/log n)
   18|       |        fn merge_parallel(left: &ArraySeqMtPerS<T>, right: &ArraySeqMtPerS<T>) -> ArraySeqMtPerS<T>;
   19|       |
   20|       |        /// Sort a sequence using parallel merge sort.
   21|       |        /// APAS: Work (n log n), Span (log n)
   22|       |        /// claude-4-sonet: Work (n log n), Span (log n), Parallelism (n/log n)
   23|       |        fn merge_sort_parallel(a: &ArraySeqMtPerS<T>) -> ArraySeqMtPerS<T>;
   24|       |    }
   25|       |
   26|       |    impl<T: StT + Ord + Send + Sync + 'static> MergeSortMtTrait<T> for ArraySeqMtPerS<T> {
   27|    151|        fn merge_parallel(left: &ArraySeqMtPerS<T>, right: &ArraySeqMtPerS<T>) -> ArraySeqMtPerS<T> {
   28|    151|            let n_left = left.length();
   29|    151|            let n_right = right.length();
   30|    151|            let total = n_left + n_right;
   31|       |
   32|    151|            if total == 0 {
   33|     14|                return ArraySeqMtPerS::empty();
   34|    137|            }
   35|    137|            if n_left == 0 {
   36|     30|                return right.clone();
   37|    107|            }
   38|    107|            if n_right == 0 {
   39|     20|                return left.clone();
   40|     87|            }
   41|       |
   42|       |            // Base case for small merges
   43|     87|            if total <= 2 {
   44|     31|                if n_left == 1 && n_right == 1 {
   45|     31|                    if left.nth(0) <= right.nth(0) {
   46|     16|                        return ArraySeqMtPerS::append(left, right);
   47|       |                    } else {
   48|     15|                        return ArraySeqMtPerS::append(right, left);
   49|       |                    }
   50|      0|                }
   51|       |                // For total == 1 or other small cases
   52|      0|                return ArraySeqMtPerS::tabulate(
   53|      0|                    &|i| {
   54|      0|                        if i < n_left {
   55|      0|                            left.nth(i).clone()
   56|       |                        } else {
   57|      0|                            right.nth(i - n_left).clone()
   58|       |                        }
   59|      0|                    },
   60|      0|                    total,
   61|       |                );
   62|     56|            }
   63|       |
   64|       |            // Parallel merge: split the longer sequence
   65|     56|            if n_left >= n_right {
   66|     26|                let mid_left = n_left / 2;
   67|     26|                let pivot = left.nth(mid_left);
   68|       |
   69|       |                // Binary search in right sequence
   70|     26|                let mut lo = 0;
   71|     26|                let mut hi = n_right;
   72|     72|                while lo < hi {
   73|     46|                    let mid = (lo + hi) / 2;
   74|     46|                    if right.nth(mid) < pivot {
   75|     22|                        lo = mid + 1;
   76|     24|                    } else {
   77|     24|                        hi = mid;
   78|     24|                    }
   79|       |                }
   80|     26|                let mid_right = lo;
   81|       |
   82|       |                // Parallel recursive merge
   83|     26|                let left_left = left.subseq_copy(0, mid_left);
   84|     26|                let left_right = left.subseq_copy(mid_left + 1, n_left - mid_left - 1);
   85|     26|                let right_left = right.subseq_copy(0, mid_right);
   86|     26|                let right_right = right.subseq_copy(mid_right, n_right - mid_right);
   87|       |
   88|     26|                let left_left_arc = Arc::new(left_left);
   89|     26|                let right_left_arc = Arc::new(right_left);
   90|     26|                let left_right_arc = Arc::new(left_right);
   91|     26|                let right_right_arc = Arc::new(right_right);
   92|       |
   93|     26|                let (merged_left, merged_right) = thread::scope(|s| {
   94|     26|                    let ll = left_left_arc.clone();
   95|     26|                    let rl = right_left_arc.clone();
   96|     26|                    let handle_left = s.spawn(move || Self::merge_parallel(&*ll, &*rl));
   97|       |
   98|     26|                    let lr = left_right_arc.clone();
   99|     26|                    let rr = right_right_arc.clone();
  100|     26|                    let merged_right = Self::merge_parallel(&*lr, &*rr);
  101|       |
  102|     26|                    let merged_left = handle_left.join().unwrap();
  103|     26|                    (merged_left, merged_right)
  104|     26|                });
  105|       |
  106|       |                // Combine: merged_left + [pivot] + merged_right
  107|     26|                let pivot_seq = ArraySeqMtPerS::singleton(pivot.clone());
  108|     26|                let left_with_pivot = ArraySeqMtPerS::append(&merged_left, &pivot_seq);
  109|     26|                ArraySeqMtPerS::append(&left_with_pivot, &merged_right)
  110|       |            } else {
  111|       |                // Symmetric case: split right sequence
  112|     30|                let mid_right = n_right / 2;
  113|     30|                let pivot = right.nth(mid_right);
  114|       |
  115|       |                // Binary search in left sequence
  116|     30|                let mut lo = 0;
  117|     30|                let mut hi = n_left;
  118|     73|                while lo < hi {
  119|     43|                    let mid = (lo + hi) / 2;
  120|     43|                    if left.nth(mid) <= pivot {
  121|     18|                        lo = mid + 1;
  122|     25|                    } else {
  123|     25|                        hi = mid;
  124|     25|                    }
  125|       |                }
  126|     30|                let mid_left = lo;
  127|       |
  128|       |                // Parallel recursive merge
  129|     30|                let left_left = left.subseq_copy(0, mid_left);
  130|     30|                let left_right = left.subseq_copy(mid_left, n_left - mid_left);
  131|     30|                let right_left = right.subseq_copy(0, mid_right);
  132|     30|                let right_right = right.subseq_copy(mid_right + 1, n_right - mid_right - 1);
  133|       |
  134|     30|                let left_left_arc = Arc::new(left_left);
  135|     30|                let right_left_arc = Arc::new(right_left);
  136|     30|                let left_right_arc = Arc::new(left_right);
  137|     30|                let right_right_arc = Arc::new(right_right);
  138|       |
  139|     30|                let (merged_left, merged_right) = thread::scope(|s| {
  140|     30|                    let ll = left_left_arc.clone();
  141|     30|                    let rl = right_left_arc.clone();
  142|     30|                    let handle_left = s.spawn(move || Self::merge_parallel(&*ll, &*rl));
  143|       |
  144|     30|                    let lr = left_right_arc.clone();
  145|     30|                    let rr = right_right_arc.clone();
  146|     30|                    let merged_right = Self::merge_parallel(&*lr, &*rr);
  147|       |
  148|     30|                    let merged_left = handle_left.join().unwrap();
  149|     30|                    (merged_left, merged_right)
  150|     30|                });
  151|       |
  152|       |                // Combine: merged_left + [pivot] + merged_right
  153|     30|                let pivot_seq = ArraySeqMtPerS::singleton(pivot.clone());
  154|     30|                let left_with_pivot = ArraySeqMtPerS::append(&merged_left, &pivot_seq);
  155|     30|                ArraySeqMtPerS::append(&left_with_pivot, &merged_right)
  156|       |            }
  157|    151|        }
  158|       |
  159|     80|        fn merge_sort_parallel(a: &ArraySeqMtPerS<T>) -> ArraySeqMtPerS<T> {
  160|     80|            let n = a.length();
  161|       |
  162|       |            // Base case: sequences of length 0 or 1 are already sorted
  163|     80|            if n <= 1 {
  164|     42|                return a.clone();
  165|     38|            }
  166|       |
  167|       |            // Divide: split at midpoint
  168|     38|            let mid = n / 2;
  169|     38|            let left = a.subseq_copy(0, mid);
  170|     38|            let right = a.subseq_copy(mid, n - mid);
  171|       |
  172|       |            // Recur: UNCONDITIONALLY PARALLEL using ParaPair!
  173|     38|            let left_arc = Arc::new(left);
  174|     38|            let right_arc = Arc::new(right);
  175|       |
  176|     38|            let Pair(sorted_left, sorted_right) = ParaPair!(
  177|       |                {
  178|     38|                    let l = left_arc.clone();
  179|     38|                    move || Self::merge_sort_parallel(&*l)
  180|       |                },
  181|       |                {
  182|     38|                    let r = right_arc.clone();
  183|     38|                    move || Self::merge_sort_parallel(&*r)
  184|       |                }
  185|       |            );
  186|       |
  187|       |            // Combine: parallel merge the two sorted halves
  188|     38|            Self::merge_parallel(&sorted_left, &sorted_right)
  189|     80|        }
  190|       |    }
  191|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap26/MergeSortSt.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Sequential merge sort implementation (Chapter 26).
    3|       |
    4|       |pub mod MergeSortSt {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Types::Types::*;
    8|       |
    9|       |    pub trait MergeSortStTrait<T: StT + Ord> {
   10|       |        /// Merge two sorted sequences into one sorted sequence.
   11|       |        /// APAS: Work (n), Span (n)
   12|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   13|       |        fn merge(left: &ArraySeqStPerS<T>, right: &ArraySeqStPerS<T>) -> ArraySeqStPerS<T>;
   14|       |
   15|       |        /// Sort a sequence using merge sort.
   16|       |        /// APAS: Work (n log n), Span (n log n)
   17|       |        /// claude-4-sonet: Work (n log n), Span (n log n), Parallelism (1)
   18|       |        fn merge_sort(a: &ArraySeqStPerS<T>) -> ArraySeqStPerS<T>;
   19|       |    }
   20|       |
   21|       |    impl<T: StT + Ord> MergeSortStTrait<T> for ArraySeqStPerS<T> {
   22|     32|        fn merge(left: &ArraySeqStPerS<T>, right: &ArraySeqStPerS<T>) -> ArraySeqStPerS<T> {
   23|     32|            let n_left = left.length();
   24|     32|            let n_right = right.length();
   25|     32|            let total = n_left + n_right;
   26|       |
   27|     32|            if total == 0 {
   28|      1|                return ArraySeqStPerS::empty();
   29|     31|            }
   30|     31|            if n_left == 0 {
   31|      0|                return right.clone();
   32|     31|            }
   33|     31|            if n_right == 0 {
   34|      1|                return left.clone();
   35|     30|            }
   36|       |
   37|       |            // Build result using tabulate (no Vec!)
   38|     30|            ArraySeqStPerS::tabulate(
   39|    122|                &|i| {
   40|       |                    // Determine position in left and right sequences
   41|    122|                    let mut l_idx = 0;
   42|    122|                    let mut r_idx = 0;
   43|    122|                    let mut count = 0;
   44|       |
   45|       |                    // Simulate the merge to find element at position i
   46|    429|                    while count < i {
   47|    307|                        if l_idx < n_left && r_idx < n_right {
                                                           ^284
   48|    272|                            if left.nth(l_idx) <= right.nth(r_idx) {
   49|    151|                                l_idx += 1;
   50|    151|                            } else {
   51|    121|                                r_idx += 1;
   52|    121|                            }
   53|     35|                        } else if l_idx < n_left {
   54|     12|                            l_idx += 1;
   55|     23|                        } else {
   56|     23|                            r_idx += 1;
   57|     23|                        }
   58|    307|                        count += 1;
   59|       |                    }
   60|       |
   61|       |                    // Get the element at position i
   62|    122|                    if l_idx < n_left && r_idx < n_right {
                                                       ^86
   63|     71|                        if left.nth(l_idx) <= right.nth(r_idx) {
   64|     40|                            left.nth(l_idx).clone()
   65|       |                        } else {
   66|     31|                            right.nth(r_idx).clone()
   67|       |                        }
   68|     51|                    } else if l_idx < n_left {
   69|     15|                        left.nth(l_idx).clone()
   70|       |                    } else {
   71|     36|                        right.nth(r_idx).clone()
   72|       |                    }
   73|    122|                },
   74|     30|                total,
   75|       |            )
   76|     32|        }
   77|       |
   78|     63|        fn merge_sort(a: &ArraySeqStPerS<T>) -> ArraySeqStPerS<T> {
   79|     63|            let n = a.length();
   80|       |
   81|       |            // Base case: sequences of length 0 or 1 are already sorted
   82|     63|            if n <= 1 {
   83|     34|                return a.clone();
   84|     29|            }
   85|       |
   86|       |            // Divide: split at midpoint
   87|     29|            let mid = n / 2;
   88|     29|            let left = a.subseq_copy(0, mid);
   89|     29|            let right = a.subseq_copy(mid, n - mid);
   90|       |
   91|       |            // Recur: sequential recursive calls
   92|     29|            let sorted_left = Self::merge_sort(&left);
   93|     29|            let sorted_right = Self::merge_sort(&right);
   94|       |
   95|       |            // Combine: merge the two sorted halves
   96|     29|            Self::merge(&sorted_left, &sorted_right)
   97|     63|        }
   98|       |    }
   99|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap27/ReduceContractMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Parallel reduce using contraction technique (Chapter 27, Algorithm 27.2).
    3|       |
    4|       |pub mod ReduceContractMtEph {
    5|       |
    6|       |    use std::sync::Arc;
    7|       |    use std::thread;
    8|       |
    9|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
   10|       |    use crate::ParaPair;
   11|       |    use crate::Types::Types::*;
   12|       |
   13|       |    pub trait ReduceContractMtEphTrait<T: StT + Send + Sync> {
   14|       |        /// Reduce a sequence using parallel contraction: contractsolveexpand.
   15|       |        /// APAS: Work (n), Span (log n)
   16|       |        /// claude-4-sonet: Work (n), Span (log n), Parallelism (n/log n)
   17|       |        fn reduce_contract_parallel<F: Fn(&T, &T) -> T + Send + Sync + 'static>(
   18|       |            a: &ArraySeqMtEphS<T>,
   19|       |            f: Arc<F>,
   20|       |            id: T,
   21|       |        ) -> T;
   22|       |    }
   23|       |
   24|       |    impl<T: StT + Send + Sync + Clone + 'static> ReduceContractMtEphTrait<T> for ArraySeqMtEphS<T> {
   25|     30|        fn reduce_contract_parallel<F: Fn(&T, &T) -> T + Send + Sync + 'static>(
   26|     30|            a: &ArraySeqMtEphS<T>,
   27|     30|            f: Arc<F>,
   28|     30|            id: T,
   29|     30|        ) -> T {
   30|     30|            let n = a.length();
   31|       |
   32|       |            // Base case: empty or single element
   33|     30|            if n == 0 {
   34|      1|                return id;
   35|     29|            }
   36|     29|            if n == 1 {
   37|      7|                return a.nth_cloned(0);
   38|     22|            }
   39|       |
   40|       |            // Contract: pair up elements and apply f in parallel
   41|       |            // b[i] = f(a[2i], a[2i+1])
   42|     22|            let half = n / 2;
   43|     22|            let a_arc = Arc::new(a.clone());
   44|     22|            let f_clone = Arc::clone(&f);
   45|       |
   46|     22|            let b = ArraySeqMtEphS::tabulate(
   47|  1.02k|                &|i| {
   48|  1.02k|                    let left = a_arc.nth_cloned(2 * i);
   49|  1.02k|                    let right = a_arc.nth_cloned(2 * i + 1);
   50|  1.02k|                    f_clone(&left, &right)
   51|  1.02k|                },
   52|     22|                half,
   53|       |            );
   54|       |
   55|       |            // Handle odd-length sequences: last element unpaired
   56|     22|            let f_solve = Arc::clone(&f);
   57|     22|            let f_combine = Arc::clone(&f);
   58|       |
   59|     22|            if n % 2 == 1 {
   60|      9|                let last = a.nth_cloned(n - 1);
   61|      9|                let last_for_combine = last.clone();
   62|      9|                let id_clone = id.clone();
   63|       |
   64|       |                // Solve and combine in parallel using ParaPair!
   65|      9|                let Pair(result, _) = ParaPair!(
   66|      9|                    move || Self::reduce_contract_parallel(&b, f_solve, id_clone),
   67|      9|                    move || last.clone()
   68|       |                );
   69|       |
   70|      9|                f_combine(&result, &last_for_combine)
   71|       |            } else {
   72|       |                // Solve: recursively reduce b
   73|     13|                Self::reduce_contract_parallel(&b, f_solve, id)
   74|       |            }
   75|     30|        }
   76|       |    }
   77|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap27/ReduceContractStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Sequential reduce using contraction technique (Chapter 27, Algorithm 27.2).
    3|       |
    4|       |pub mod ReduceContractStEph {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
    7|       |    use crate::Types::Types::*;
    8|       |
    9|       |    pub trait ReduceContractStEphTrait<T: StT> {
   10|       |        /// Reduce a sequence using contraction: contractsolveexpand.
   11|       |        /// APAS: Work (n), Span (n)
   12|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   13|       |        fn reduce_contract<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, id: T) -> T;
   14|       |    }
   15|       |
   16|       |    impl<T: StT + Clone> ReduceContractStEphTrait<T> for ArraySeqStEphS<T> {
   17|     30|        fn reduce_contract<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, id: T) -> T {
   18|     30|            let n = a.length();
   19|       |
   20|       |            // Base case: empty or single element
   21|     30|            if n == 0 {
   22|      1|                return id;
   23|     29|            }
   24|     29|            if n == 1 {
   25|      7|                return a.nth(0).clone();
   26|     22|            }
   27|       |
   28|       |            // Contract: pair up elements and apply f
   29|       |            // b[i] = f(a[2i], a[2i+1])
   30|     22|            let half = n / 2;
   31|     22|            let b = ArraySeqStEphS::tabulate(
   32|  1.02k|                &|i| {
   33|  1.02k|                    let left = a.nth(2 * i);
   34|  1.02k|                    let right = a.nth(2 * i + 1);
   35|  1.02k|                    f(left, right)
   36|  1.02k|                },
   37|     22|                half,
   38|       |            );
   39|       |
   40|       |            // Handle odd-length sequences: last element unpaired
   41|     22|            let result = Self::reduce_contract(&b, f, id);
   42|       |
   43|       |            // If odd length, combine result with last element
   44|     22|            if n % 2 == 1 { f(&result, a.nth(n - 1)) } else { result }
                                          ^9^9       ^9                     ^13
   45|     30|        }
   46|       |    }
   47|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap27/ScanContractMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Parallel scan using contraction technique (Chapter 27, Algorithm 27.3).
    3|       |
    4|       |pub mod ScanContractMtEph {
    5|       |
    6|       |    use std::sync::Arc;
    7|       |    use std::thread;
    8|       |
    9|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
   10|       |    use crate::ParaPair;
   11|       |    use crate::Types::Types::*;
   12|       |
   13|       |    pub trait ScanContractMtEphTrait<T: StT + Send + Sync> {
   14|       |        /// Scan a sequence using parallel contraction: contractsolveexpand.
   15|       |        /// APAS: Work (n), Span (log n)
   16|       |        /// claude-4-sonet: Work (n), Span (log n), Parallelism (n/log n)
   17|       |        fn scan_contract_parallel<F: Fn(&T, &T) -> T + Send + Sync + 'static>(
   18|       |            a: &ArraySeqMtEphS<T>,
   19|       |            f: Arc<F>,
   20|       |            id: T,
   21|       |        ) -> ArraySeqMtEphS<T>;
   22|       |    }
   23|       |
   24|       |    impl<T: StT + Send + Sync + Clone + 'static> ScanContractMtEphTrait<T> for ArraySeqMtEphS<T> {
   25|     22|        fn scan_contract_parallel<F: Fn(&T, &T) -> T + Send + Sync + 'static>(
   26|     22|            a: &ArraySeqMtEphS<T>,
   27|     22|            f: Arc<F>,
   28|     22|            id: T,
   29|     22|        ) -> ArraySeqMtEphS<T> {
   30|     22|            let n = a.length();
   31|       |
   32|       |            // Base case: empty sequence
   33|     22|            if n == 0 {
   34|      1|                return ArraySeqMtEphS::empty();
   35|     21|            }
   36|       |
   37|       |            // Base case: single element
   38|     21|            if n == 1 {
   39|      6|                return ArraySeqMtEphS::singleton(id.clone());
   40|     15|            }
   41|       |
   42|       |            // Contract: pair up elements and apply f in parallel
   43|       |            // b[i] = f(a[2i], a[2i+1])
   44|     15|            let half = n / 2;
   45|     15|            let a_arc = Arc::new(a.clone());
   46|     15|            let f_contract = Arc::clone(&f);
   47|       |
   48|     15|            let b = ArraySeqMtEphS::tabulate(
   49|    114|                &|i| {
   50|    114|                    let left = a_arc.nth_cloned(2 * i);
   51|    114|                    let right = a_arc.nth_cloned(2 * i + 1);
   52|    114|                    f_contract(&left, &right)
   53|    114|                },
   54|     15|                half,
   55|       |            );
   56|       |
   57|       |            // Solve: recursively scan b to get c (parallel)
   58|     15|            let f_solve = Arc::clone(&f);
   59|     15|            let c = Self::scan_contract_parallel(&b, f_solve, id);
   60|       |
   61|       |            // Expand: reconstruct result using parallel tabulation
   62|       |            // For even indices: result[2i] = c[i]
   63|       |            // For odd indices: result[2i+1] = f(c[i], a[2i])
   64|     15|            let c_arc = Arc::new(c);
   65|     15|            let a_arc2 = Arc::new(a.clone());
   66|     15|            let f_expand = Arc::clone(&f);
   67|       |
   68|     15|            let main_result = ArraySeqMtEphS::tabulate(
   69|    228|                &|i| {
   70|    228|                    if i % 2 == 0 {
   71|       |                        // Even index: use scan result from contracted sequence
   72|    114|                        c_arc.nth_cloned(i / 2)
   73|       |                    } else {
   74|       |                        // Odd index: combine scan result with original element
   75|    114|                        let scan_val = c_arc.nth_cloned(i / 2);
   76|    114|                        let orig_val = a_arc2.nth_cloned(i - 1);
   77|    114|                        f_expand(&scan_val, &orig_val)
   78|       |                    }
   79|    228|                },
   80|     15|                if n % 2 == 0 { n } else { n - 1 },
                                              ^10        ^5
   81|       |            );
   82|       |
   83|       |            // Handle last element if odd length
   84|     15|            if n % 2 == 1 {
   85|       |                // Last element: f(result[n-2], a[n-2])
   86|      5|                let last_elem_of_main = main_result.nth_cloned(n - 2);
   87|      5|                let last_val = f(&last_elem_of_main, &a.nth_cloned(n - 2));
   88|      5|                let last_part = ArraySeqMtEphS::singleton(last_val);
   89|      5|                ArraySeqMtEphS::append(&main_result, &last_part)
   90|       |            } else {
   91|     10|                main_result
   92|       |            }
   93|     22|        }
   94|       |    }
   95|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap27/ScanContractStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Sequential scan using contraction technique (Chapter 27, Algorithm 27.3).
    3|       |
    4|       |pub mod ScanContractStEph {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
    7|       |    use crate::Types::Types::*;
    8|       |
    9|       |    pub trait ScanContractStEphTrait<T: StT> {
   10|       |        /// Scan a sequence using contraction: contractsolveexpand.
   11|       |        /// APAS: Work (n), Span (n)
   12|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   13|       |        fn scan_contract<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, id: T) -> ArraySeqStEphS<T>;
   14|       |    }
   15|       |
   16|       |    impl<T: StT + Clone> ScanContractStEphTrait<T> for ArraySeqStEphS<T> {
   17|     22|        fn scan_contract<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, id: T) -> ArraySeqStEphS<T> {
   18|     22|            let n = a.length();
   19|       |
   20|       |            // Base case: empty sequence
   21|     22|            if n == 0 {
   22|      1|                return ArraySeqStEphS::empty();
   23|     21|            }
   24|       |
   25|       |            // Base case: single element
   26|     21|            if n == 1 {
   27|      6|                return ArraySeqStEphS::singleton(id.clone());
   28|     15|            }
   29|       |
   30|       |            // Contract: pair up elements and apply f
   31|       |            // b[i] = f(a[2i], a[2i+1])
   32|     15|            let half = n / 2;
   33|    114|            let b = ArraySeqStEphS::tabulate(&|i| f(a.nth(2 * i), a.nth(2 * i + 1)), half);
                              ^15 ^15                                                              ^15
   34|       |
   35|       |            // Solve: recursively scan b to get c
   36|     15|            let c = Self::scan_contract(&b, f, id.clone());
   37|       |
   38|       |            // Expand: reconstruct result
   39|       |            // For even indices: result[2i] = c[i]
   40|       |            // For odd indices: result[2i+1] = f(c[i], a[2i])
   41|     15|            let main_result = ArraySeqStEphS::tabulate(
   42|    228|                &|i| {
   43|    228|                    if i % 2 == 0 {
   44|       |                        // Even index: use scan result from contracted sequence
   45|    114|                        c.nth(i / 2).clone()
   46|       |                    } else {
   47|       |                        // Odd index: combine scan result with original element
   48|    114|                        f(c.nth(i / 2), a.nth(i - 1))
   49|       |                    }
   50|    228|                },
   51|     15|                if n % 2 == 0 { n } else { n - 1 },
                                              ^10        ^5
   52|       |            );
   53|       |
   54|       |            // Handle last element if odd length
   55|     15|            if n % 2 == 1 {
   56|       |                // Last element: f(result[n-2], a[n-2])
   57|      5|                let last_elem_of_main = main_result.nth(n - 2).clone();
   58|      5|                let last_part = ArraySeqStEphS::singleton(f(&last_elem_of_main, a.nth(n - 2)));
   59|      5|                ArraySeqStEphS::append(&main_result, &last_part)
   60|       |            } else {
   61|     10|                main_result
   62|       |            }
   63|     22|        }
   64|       |    }
   65|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap28/MaxContigSubSumBruteStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Maximum Contiguous Subsequence Sum - Brute Force (Chapter 28, Algorithm 28.8).
    3|       |
    4|       |pub mod MaxContigSubSumBruteStEph {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
    7|       |    use crate::Types::Types::*;
    8|       |
    9|     76|    fn max_with_neginf(a: Option<i32>, b: Option<i32>) -> Option<i32> {
   10|     76|        match (a, b) {
   11|      0|            | (None, None) => None,
   12|      8|            | (None, Some(_)) => b,
   13|      0|            | (Some(_), None) => a,
   14|     68|            | (Some(x), Some(y)) => Some(x.max(y)),
   15|       |        }
   16|     76|    }
   17|       |
   18|       |    /// Trait for brute force maximum contiguous subsequence sum.
   19|       |    pub trait MaxContigSubSumBruteTrait {
   20|       |        /// Compute maximum contiguous subsequence sum using brute force.
   21|       |        /// Returns None for empty sequence (representing -).
   22|       |        /// APAS: Work (n), Span (log n)
   23|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   24|       |        /// claude-4-sonnet: Work (n), Span (log n), Parallelism (n/log n)
   25|       |        fn max_contig_sub_sum_brute(a: &ArraySeqStEphS<i32>) -> Option<i32>;
   26|       |    }
   27|       |
   28|       |    impl MaxContigSubSumBruteTrait for ArraySeqStEphS<i32> {
   29|      9|        fn max_contig_sub_sum_brute(a: &ArraySeqStEphS<i32>) -> Option<i32> {
   30|      9|            let n = a.length();
   31|       |
   32|       |            // Base case: empty sequence returns None (-)
   33|      9|            if n == 0 {
   34|      1|                return None;
   35|      8|            }
   36|       |
   37|       |            // Generate all contiguous subsequences and their sums
   38|       |            // For each starting position i and ending position j (i  j)
   39|      8|            let mut max_sum = None;
   40|       |
   41|     27|            for i in 0..n {
                                      ^8
   42|     76|                for j in i..n {
                                       ^27^27
   43|       |                    // Compute sum of subsequence a[i..=j]
   44|     76|                    let mut sum = 0;
   45|    192|                    for k in i..=j {
                                           ^76 ^76
   46|    192|                        sum += a.nth(k);
   47|    192|                    }
   48|     76|                    max_sum = max_with_neginf(max_sum, Some(sum));
   49|       |                }
   50|       |            }
   51|       |
   52|      8|            max_sum
   53|      9|        }
   54|       |    }
   55|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap28/MaxContigSubSumDivConMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Maximum Contiguous Subsequence Sum - Parallel Divide and Conquer (Chapter 28, Algorithm 28.17).
    3|       |//!
    4|       |//! Historical Note: Based on the divide-and-conquer algorithm first designed by Michael Shamos
    5|       |//! of Carnegie Mellon University CS in 1977. This parallel version uses ParaPair! for
    6|       |//! unconditional parallelism with 32MB stack per thread.
    7|       |
    8|       |pub mod MaxContigSubSumDivConMtEph {
    9|       |
   10|       |    use std::sync::Arc;
   11|       |
   12|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
   13|       |    use crate::Chap27::ScanContractMtEph::ScanContractMtEph::ScanContractMtEphTrait;
   14|       |    use crate::ParaPair;
   15|       |    use crate::Types::Types::*;
   16|       |
   17|     32|    fn max_with_neginf(a: Option<i32>, b: Option<i32>) -> Option<i32> {
   18|     32|        match (a, b) {
   19|      0|            | (None, None) => None,
   20|      0|            | (None, Some(_)) => b,
   21|      0|            | (Some(_), None) => a,
   22|     32|            | (Some(x), Some(y)) => Some(x.max(y)),
   23|       |        }
   24|     32|    }
   25|       |
   26|       |    /// Helper to find max suffix sum using inclusive prefix sums.
   27|     16|    fn max_suffix_sum(a: &ArraySeqMtEphS<i32>) -> i32 {
   28|     16|        if a.length() == 0 {
   29|      0|            return i32::MIN / 2; // treat as -
   30|     16|        }
   31|       |
   32|     16|        let mut min_prefix = 0;
   33|     16|        let mut running_sum = 0;
   34|     24|        for i in 0..a.length() {
                                  ^16^16
   35|     24|            running_sum += a.nth_cloned(i);
   36|     24|            min_prefix = min_prefix.min(running_sum);
   37|     24|        }
   38|     16|        let total = running_sum;
   39|       |
   40|     16|        total - min_prefix
   41|     16|    }
   42|       |
   43|       |    /// Helper to find max prefix sum using inclusive prefix sums.
   44|     16|    fn max_prefix_sum(a: &ArraySeqMtEphS<i32>) -> i32 {
   45|     16|        if a.length() == 0 {
   46|      0|            return i32::MIN / 2; // treat as -
   47|     16|        }
   48|       |
   49|       |        // Note: Start with first element (not empty prefix) since empty sequence is not allowed
   50|     16|        let mut max_val = a.nth_cloned(0);
   51|     16|        let mut running_sum = a.nth_cloned(0);
   52|     16|        for i in 1..a.length() {
                          ^8
   53|      8|            running_sum += a.nth_cloned(i);
   54|      8|            max_val = max_val.max(running_sum);
   55|      8|        }
   56|       |
   57|     16|        max_val
   58|     16|    }
   59|       |
   60|       |    /// Trait for parallel divide-and-conquer maximum contiguous subsequence sum.
   61|       |    pub trait MaxContigSubSumDivConMtTrait {
   62|       |        /// Compute maximum contiguous subsequence sum using parallel divide-and-conquer.
   63|       |        /// Returns None for empty sequence (representing -).
   64|       |        /// APAS: Work (n log n), Span (log n)
   65|       |        /// claude-4-sonet: Work (n log n), Span (log n), Parallelism (n/log n)
   66|       |        /// claude-4-sonnet: Work (n log n), Span (log n), Parallelism (n/log n)
   67|       |        fn max_contig_sub_sum_divcon_mt(a: &ArraySeqMtEphS<i32>) -> Option<i32>;
   68|       |    }
   69|       |
   70|       |    impl MaxContigSubSumDivConMtTrait for ArraySeqMtEphS<i32> {
   71|     38|        fn max_contig_sub_sum_divcon_mt(a: &ArraySeqMtEphS<i32>) -> Option<i32> {
   72|     38|            let n = a.length();
   73|       |
   74|       |            // Base cases
   75|     38|            if n == 0 {
   76|      1|                return None; // -
   77|     37|            }
   78|     37|            if n == 1 {
   79|     21|                return Some(a.nth_cloned(0));
   80|     16|            }
   81|       |
   82|       |            // Divide: split at midpoint
   83|     16|            let mid = n / 2;
   84|     16|            let left = a.subseq_copy(0, mid);
   85|     16|            let right = a.subseq_copy(mid, n);
   86|       |
   87|       |            // Conquer: parallel recursive solve using ParaPair! with 32MB stack
   88|     16|            let left_clone = left.clone();
   89|     16|            let right_clone = right.clone();
   90|       |
   91|     16|            let result_pair = ParaPair!(move || Self::max_contig_sub_sum_divcon_mt(&left_clone), move || {
   92|     16|                Self::max_contig_sub_sum_divcon_mt(&right_clone)
   93|     16|            });
   94|     16|            let max_left = result_pair.0;
   95|     16|            let max_right = result_pair.1;
   96|       |
   97|       |            // Combine: handle subsequence spanning the cut (parallel suffix/prefix computation)
   98|     16|            let left_for_suffix = left.clone();
   99|     16|            let right_for_prefix = right.clone();
  100|       |
  101|     16|            let crossing_pair = ParaPair!(move || max_suffix_sum(&left_for_suffix), move || max_prefix_sum(
  102|     16|                &right_for_prefix
  103|       |            ));
  104|     16|            let max_suffix_left = crossing_pair.0;
  105|     16|            let max_prefix_right = crossing_pair.1;
  106|       |
  107|     16|            let max_crossing = max_suffix_left + max_prefix_right;
  108|       |
  109|       |            // Return maximum of the three cases
  110|     16|            let result = max_with_neginf(max_left, max_right);
  111|     16|            max_with_neginf(result, Some(max_crossing))
  112|     38|        }
  113|       |    }
  114|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap28/MaxContigSubSumDivConOptMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Maximum Contiguous Subsequence Sum - Parallel Strengthened Divide and Conquer (Chapter 28, Algorithm 28.19).
    3|       |//!
    4|       |//! Historical Note: This parallel work-optimal version builds on the original divide-and-conquer
    5|       |//! algorithm by Michael Shamos (CMU CS, 1977), using strengthening and ParaPair! with 32MB stack
    6|       |//! for unconditional parallelism.
    7|       |
    8|       |pub mod MaxContigSubSumDivConOptMtEph {
    9|       |
   10|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
   11|       |    use crate::ParaPair;
   12|       |    use crate::Types::Types::*;
   13|       |
   14|     42|    fn max_with_neginf(a: Option<i32>, b: Option<i32>) -> Option<i32> {
   15|     42|        match (a, b) {
   16|      0|            | (None, None) => None,
   17|      0|            | (None, Some(_)) => b,
   18|      0|            | (Some(_), None) => a,
   19|     42|            | (Some(x), Some(y)) => Some(x.max(y)),
   20|       |        }
   21|     42|    }
   22|       |
   23|       |    /// Strengthened return type: (max_sum, max_prefix, max_suffix, total).
   24|       |    type StrengthResult = (Option<i32>, i32, i32, i32);
   25|       |
   26|       |    /// Auxiliary function that returns strengthened result, using parallel recursion.
   27|     48|    fn max_contig_sub_sum_aux_mt(a: &ArraySeqMtEphS<i32>) -> StrengthResult {
   28|     48|        let n = a.length();
   29|       |
   30|       |        // Base case: empty sequence
   31|     48|        if n == 0 {
   32|      1|            return (None, i32::MIN / 2, i32::MIN / 2, 0); // (-, -, -, 0)
   33|     47|        }
   34|       |
   35|       |        // Base case: single element
   36|     47|        if n == 1 {
   37|     26|            let val = a.nth_cloned(0);
   38|     26|            return (Some(val), val, val, val);
   39|     21|        }
   40|       |
   41|       |        // Divide: split at midpoint
   42|     21|        let mid = n / 2;
   43|     21|        let left = a.subseq_copy(0, mid);
   44|     21|        let right = a.subseq_copy(mid, n);
   45|       |
   46|       |        // Conquer: parallel recursive solve using ParaPair! with 32MB stack
   47|     21|        let left_clone = left.clone();
   48|     21|        let right_clone = right.clone();
   49|       |
   50|     21|        let result_pair = ParaPair!(move || max_contig_sub_sum_aux_mt(&left_clone), move || {
   51|     21|            max_contig_sub_sum_aux_mt(&right_clone)
   52|     21|        });
   53|     21|        let (m_left, p_left, s_left, t_left) = result_pair.0;
   54|     21|        let (m_right, p_right, s_right, t_right) = result_pair.1;
   55|       |
   56|       |        // Combine: compute strengthened result
   57|     21|        let max_crossing = s_left + p_right;
   58|     21|        let max_sum = max_with_neginf(max_with_neginf(m_left, m_right), Some(max_crossing));
   59|     21|        let max_prefix = p_left.max(t_left + p_right);
   60|     21|        let max_suffix = s_right.max(s_left + t_right);
   61|     21|        let total = t_left + t_right;
   62|       |
   63|     21|        (max_sum, max_prefix, max_suffix, total)
   64|     48|    }
   65|       |
   66|       |    /// Trait for parallel strengthened divide-and-conquer maximum contiguous subsequence sum.
   67|       |    pub trait MaxContigSubSumDivConOptMtTrait {
   68|       |        /// Compute maximum contiguous subsequence sum using parallel strengthened divide-and-conquer.
   69|       |        /// Returns None for empty sequence (representing -).
   70|       |        /// APAS: Work (n), Span (log n)
   71|       |        /// claude-4-sonet: Work (n), Span (log n), Parallelism (n/log n)
   72|       |        /// claude-4-sonnet: Work (n), Span (log n), Parallelism (n/log n)
   73|       |        fn max_contig_sub_sum_divcon_opt_mt(a: &ArraySeqMtEphS<i32>) -> Option<i32>;
   74|       |    }
   75|       |
   76|       |    impl MaxContigSubSumDivConOptMtTrait for ArraySeqMtEphS<i32> {
   77|      6|        fn max_contig_sub_sum_divcon_opt_mt(a: &ArraySeqMtEphS<i32>) -> Option<i32> {
   78|      6|            let (max_sum, _, _, _) = max_contig_sub_sum_aux_mt(a);
   79|      6|            max_sum
   80|      6|        }
   81|       |    }
   82|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap28/MaxContigSubSumDivConOptStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Maximum Contiguous Subsequence Sum - Strengthened Divide and Conquer (Chapter 28, Algorithm 28.19).
    3|       |//!
    4|       |//! Historical Note: This work-optimal strengthened version builds on the original divide-and-conquer
    5|       |//! algorithm by Michael Shamos (CMU CS, 1977), using the strengthening technique to avoid
    6|       |//! redundant computation and achieve O(n) work complexity.
    7|       |
    8|       |pub mod MaxContigSubSumDivConOptStEph {
    9|       |
   10|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   11|       |    use crate::Types::Types::*;
   12|       |
   13|     42|    fn max_with_neginf(a: Option<i32>, b: Option<i32>) -> Option<i32> {
   14|     42|        match (a, b) {
   15|      0|            | (None, None) => None,
   16|      0|            | (None, Some(_)) => b,
   17|      0|            | (Some(_), None) => a,
   18|     42|            | (Some(x), Some(y)) => Some(x.max(y)),
   19|       |        }
   20|     42|    }
   21|       |
   22|       |    /// Strengthened return type: (max_sum, max_prefix, max_suffix, total).
   23|       |    /// This avoids recomputing max_prefix and max_suffix in the combine step.
   24|       |    type StrengthResult = (Option<i32>, i32, i32, i32);
   25|       |
   26|       |    /// Auxiliary function that returns strengthened result.
   27|     48|    fn max_contig_sub_sum_aux(a: &ArraySeqStEphS<i32>) -> StrengthResult {
   28|     48|        let n = a.length();
   29|       |
   30|       |        // Base case: empty sequence
   31|     48|        if n == 0 {
   32|      1|            return (None, i32::MIN / 2, i32::MIN / 2, 0); // (-, -, -, 0)
   33|     47|        }
   34|       |
   35|       |        // Base case: single element
   36|     47|        if n == 1 {
   37|     26|            let val = *a.nth(0);
   38|     26|            return (Some(val), val, val, val);
   39|     21|        }
   40|       |
   41|       |        // Divide: split at midpoint
   42|     21|        let mid = n / 2;
   43|     21|        let left = a.subseq(0, mid);
   44|     21|        let right = a.subseq(mid, n);
   45|       |
   46|       |        // Conquer: recursively solve with strengthened interface
   47|     21|        let (m_left, p_left, s_left, t_left) = max_contig_sub_sum_aux(&left);
   48|     21|        let (m_right, p_right, s_right, t_right) = max_contig_sub_sum_aux(&right);
   49|       |
   50|       |        // Combine: compute strengthened result
   51|       |        // max_sum = max(m_left, m_right, s_left + p_right)
   52|     21|        let max_crossing = s_left + p_right;
   53|     21|        let max_sum = max_with_neginf(max_with_neginf(m_left, m_right), Some(max_crossing));
   54|       |
   55|       |        // max_prefix = max(p_left, t_left + p_right)
   56|     21|        let max_prefix = p_left.max(t_left + p_right);
   57|       |
   58|       |        // max_suffix = max(s_right, s_left + t_right)
   59|     21|        let max_suffix = s_right.max(s_left + t_right);
   60|       |
   61|       |        // total = t_left + t_right
   62|     21|        let total = t_left + t_right;
   63|       |
   64|     21|        (max_sum, max_prefix, max_suffix, total)
   65|     48|    }
   66|       |
   67|       |    /// Trait for strengthened divide-and-conquer maximum contiguous subsequence sum.
   68|       |    pub trait MaxContigSubSumDivConOptTrait {
   69|       |        /// Compute maximum contiguous subsequence sum using strengthened divide-and-conquer.
   70|       |        /// Returns None for empty sequence (representing -).
   71|       |        /// APAS: Work (n), Span (log n)
   72|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   73|       |        /// claude-4-sonnet: Work (n), Span (log n), Parallelism (n/log n)
   74|       |        fn max_contig_sub_sum_divcon_opt(a: &ArraySeqStEphS<i32>) -> Option<i32>;
   75|       |    }
   76|       |
   77|       |    impl MaxContigSubSumDivConOptTrait for ArraySeqStEphS<i32> {
   78|      6|        fn max_contig_sub_sum_divcon_opt(a: &ArraySeqStEphS<i32>) -> Option<i32> {
   79|      6|            let (max_sum, _, _, _) = max_contig_sub_sum_aux(a);
   80|      6|            max_sum
   81|      6|        }
   82|       |    }
   83|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap28/MaxContigSubSumDivConStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Maximum Contiguous Subsequence Sum - Divide and Conquer (Chapter 28, Algorithm 28.17).
    3|       |//!
    4|       |//! Historical Note: This divide-and-conquer algorithm was first designed by Michael Shamos
    5|       |//! of Carnegie Mellon University CS in 1977, overnight, after hearing about the problem
    6|       |//! from Ulf Grenander. See Jon Bentley, Programming Pearls (1st edition), page 76.
    7|       |
    8|       |pub mod MaxContigSubSumDivConStEph {
    9|       |
   10|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   11|       |    use crate::Chap27::ScanContractStEph::ScanContractStEph::ScanContractStEphTrait;
   12|       |    use crate::Types::Types::*;
   13|       |
   14|     32|    fn max_with_neginf(a: Option<i32>, b: Option<i32>) -> Option<i32> {
   15|     32|        match (a, b) {
   16|      0|            | (None, None) => None,
   17|      0|            | (None, Some(_)) => b,
   18|      0|            | (Some(_), None) => a,
   19|     32|            | (Some(x), Some(y)) => Some(x.max(y)),
   20|       |        }
   21|     32|    }
   22|       |
   23|       |    /// Helper to find max suffix sum (MCSSE problem).
   24|     16|    fn max_suffix_sum(a: &ArraySeqStEphS<i32>) -> i32 {
   25|     16|        if a.length() == 0 {
   26|      0|            return i32::MIN / 2; // treat as -
   27|     16|        }
   28|       |
   29|       |        // Compute all inclusive prefix sums
   30|     16|        let mut min_prefix = 0;
   31|     16|        let mut running_sum = 0;
   32|     24|        for i in 0..a.length() {
                                  ^16^16
   33|     24|            running_sum += *a.nth(i);
   34|     24|            min_prefix = min_prefix.min(running_sum);
   35|     24|        }
   36|     16|        let total = running_sum;
   37|       |
   38|     16|        total - min_prefix
   39|     16|    }
   40|       |
   41|       |    /// Helper to find max prefix sum (MCSSS problem).
   42|     16|    fn max_prefix_sum(a: &ArraySeqStEphS<i32>) -> i32 {
   43|     16|        if a.length() == 0 {
   44|      0|            return i32::MIN / 2; // treat as -
   45|     16|        }
   46|       |
   47|       |        // Compute all inclusive prefix sums and return maximum
   48|       |        // Note: Start with first element (not empty prefix) since empty sequence is not allowed
   49|     16|        let mut max_val = *a.nth(0);
   50|     16|        let mut running_sum = *a.nth(0);
   51|     16|        for i in 1..a.length() {
                          ^8
   52|      8|            running_sum += *a.nth(i);
   53|      8|            max_val = max_val.max(running_sum);
   54|      8|        }
   55|       |
   56|     16|        max_val
   57|     16|    }
   58|       |
   59|       |    /// Trait for divide-and-conquer maximum contiguous subsequence sum.
   60|       |    pub trait MaxContigSubSumDivConTrait {
   61|       |        /// Compute maximum contiguous subsequence sum using divide-and-conquer.
   62|       |        /// Returns None for empty sequence (representing -).
   63|       |        /// APAS: Work (n log n), Span (log n)
   64|       |        /// claude-4-sonet: Work (n log n), Span (n log n), Parallelism (1)
   65|       |        /// claude-4-sonnet: Work (n log n), Span (log n), Parallelism (n/log n)
   66|       |        fn max_contig_sub_sum_divcon(a: &ArraySeqStEphS<i32>) -> Option<i32>;
   67|       |    }
   68|       |
   69|       |    impl MaxContigSubSumDivConTrait for ArraySeqStEphS<i32> {
   70|     38|        fn max_contig_sub_sum_divcon(a: &ArraySeqStEphS<i32>) -> Option<i32> {
   71|     38|            let n = a.length();
   72|       |
   73|       |            // Base cases
   74|     38|            if n == 0 {
   75|      1|                return None; // -
   76|     37|            }
   77|     37|            if n == 1 {
   78|     21|                return Some(*a.nth(0));
   79|     16|            }
   80|       |
   81|       |            // Divide: split at midpoint
   82|     16|            let mid = n / 2;
   83|     16|            let left = a.subseq(0, mid);
   84|     16|            let right = a.subseq(mid, n);
   85|       |
   86|       |            // Conquer: recursively solve subproblems
   87|     16|            let max_left = Self::max_contig_sub_sum_divcon(&left);
   88|     16|            let max_right = Self::max_contig_sub_sum_divcon(&right);
   89|       |
   90|       |            // Combine: handle subsequence spanning the cut
   91|     16|            let max_suffix_left = max_suffix_sum(&left);
   92|     16|            let max_prefix_right = max_prefix_sum(&right);
   93|     16|            let max_crossing = max_suffix_left + max_prefix_right;
   94|       |
   95|       |            // Return maximum of the three cases
   96|     16|            let result = max_with_neginf(max_left, max_right);
   97|     16|            max_with_neginf(result, Some(max_crossing))
   98|     38|        }
   99|       |    }
  100|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap28/MaxContigSubSumOptMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Maximum Contiguous Subsequence Sum - Parallel Optimal (Chapter 28, Algorithm 28.16).
    3|       |
    4|       |pub mod MaxContigSubSumOptMtEph {
    5|       |
    6|       |    use std::sync::Arc;
    7|       |
    8|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
    9|       |    use crate::Chap27::ScanContractMtEph::ScanContractMtEph::ScanContractMtEphTrait;
   10|       |    use crate::ParaPair;
   11|       |    use crate::Types::Types::*;
   12|       |
   13|       |    pub trait MaxContigSubSumOptMtTrait {
   14|       |        /// Compute maximum contiguous subsequence sum using parallel optimal scan-based algorithm.
   15|       |        /// Returns None for empty sequence (representing -).
   16|       |        /// APAS: Work (n), Span (log n)
   17|       |        /// claude-4-sonet: Work (n), Span (log n), Parallelism (n/log n)
   18|       |        /// claude-4-sonnet: Work (n), Span (log n), Parallelism (n/log n)
   19|       |        fn max_contig_sub_sum_opt_mt(a: &ArraySeqMtEphS<i32>) -> Option<i32>;
   20|       |    }
   21|       |
   22|       |    impl MaxContigSubSumOptMtTrait for ArraySeqMtEphS<i32> {
   23|      6|        fn max_contig_sub_sum_opt_mt(a: &ArraySeqMtEphS<i32>) -> Option<i32> {
   24|      6|            let n = a.length();
   25|       |
   26|       |            // Base case: empty sequence returns None (-)
   27|      6|            if n == 0 {
   28|      1|                return None;
   29|      5|            }
   30|       |
   31|       |            // Compute all prefix sums manually (inclusive)
   32|      5|            let mut all_prefixes_vec = Vec::with_capacity(n + 1);
   33|      5|            all_prefixes_vec.push(0); // empty prefix
   34|      5|            let mut running_sum = 0;
   35|     26|            for i in 0..n {
                                      ^5
   36|     26|                running_sum += a.nth_cloned(i);
   37|     26|                all_prefixes_vec.push(running_sum);
   38|     26|            }
   39|      5|            let all_prefixes = ArraySeqMtEphS::from_vec(all_prefixes_vec);
   40|       |
   41|       |            // Compute minimum prefix up to each position (inclusive)
   42|      5|            let mut min_prefixes_vec = Vec::with_capacity(n + 1);
   43|      5|            let mut running_min = i32::MAX;
   44|     31|            for i in 0..=n {
                                       ^5
   45|     31|                running_min = running_min.min(all_prefixes.nth_cloned(i));
   46|     31|                min_prefixes_vec.push(running_min);
   47|     31|            }
   48|      5|            let min_prefixes = ArraySeqMtEphS::from_vec(min_prefixes_vec);
   49|       |
   50|       |            // Compute maximum over all ending positions
   51|      5|            let mut max_sum = None;
   52|     26|            for i in 1..=n {
                                       ^5
   53|     26|                let ending_max = all_prefixes.nth_cloned(i) - min_prefixes.nth_cloned(i - 1);
   54|     26|                max_sum = match max_sum {
   55|      5|                    | None => Some(ending_max),
   56|     21|                    | Some(current_max) => Some(current_max.max(ending_max)),
   57|       |                };
   58|       |            }
   59|       |
   60|      5|            max_sum
   61|      6|        }
   62|       |    }
   63|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap28/MaxContigSubSumOptStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Maximum Contiguous Subsequence Sum - Work Optimal (Chapter 28, Algorithm 28.16).
    3|       |
    4|       |pub mod MaxContigSubSumOptStEph {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
    7|       |    use crate::Chap27::ScanContractStEph::ScanContractStEph::ScanContractStEphTrait;
    8|       |    use crate::Types::Types::*;
    9|       |
   10|       |    pub trait MaxContigSubSumOptTrait {
   11|       |        /// Compute maximum contiguous subsequence sum using optimal scan-based algorithm.
   12|       |        /// Returns None for empty sequence (representing -).
   13|       |        /// APAS: Work (n), Span (log n)
   14|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   15|       |        /// claude-4-sonnet: Work (n), Span (log n), Parallelism (n/log n)
   16|       |        fn max_contig_sub_sum_opt(a: &ArraySeqStEphS<i32>) -> Option<i32>;
   17|       |    }
   18|       |
   19|       |    impl MaxContigSubSumOptTrait for ArraySeqStEphS<i32> {
   20|      6|        fn max_contig_sub_sum_opt(a: &ArraySeqStEphS<i32>) -> Option<i32> {
   21|      6|            let n = a.length();
   22|       |
   23|       |            // Base case: empty sequence returns None (-)
   24|      6|            if n == 0 {
   25|      1|                return None;
   26|      5|            }
   27|       |
   28|       |            // Compute all prefix sums manually (inclusive)
   29|      5|            let mut all_prefixes_vec = Vec::with_capacity(n + 1);
   30|      5|            all_prefixes_vec.push(0); // empty prefix
   31|      5|            let mut running_sum = 0;
   32|     26|            for i in 0..n {
                                      ^5
   33|     26|                running_sum += *a.nth(i);
   34|     26|                all_prefixes_vec.push(running_sum);
   35|     26|            }
   36|      5|            let all_prefixes = ArraySeqStEphS::from_vec(all_prefixes_vec);
   37|       |
   38|       |            // Compute minimum prefix up to each position (inclusive)
   39|      5|            let mut min_prefixes_vec = Vec::with_capacity(n + 1);
   40|      5|            let mut running_min = i32::MAX;
   41|     31|            for i in 0..=n {
                                       ^5
   42|     31|                running_min = running_min.min(*all_prefixes.nth(i));
   43|     31|                min_prefixes_vec.push(running_min);
   44|     31|            }
   45|      5|            let min_prefixes = ArraySeqStEphS::from_vec(min_prefixes_vec);
   46|       |
   47|       |            // For each position i > 0, compute all_prefixes[i] - min_prefixes[i-1]
   48|       |            // This gives the max subsequence ending at position i-1 in original array
   49|      5|            let mut max_sum = None;
   50|     26|            for i in 1..=n {
                                       ^5
   51|     26|                let ending_max = *all_prefixes.nth(i) - *min_prefixes.nth(i - 1);
   52|     26|                max_sum = match max_sum {
   53|      5|                    | None => Some(ending_max),
   54|     21|                    | Some(current_max) => Some(current_max.max(ending_max)),
   55|       |                };
   56|       |            }
   57|       |
   58|      5|            max_sum
   59|      6|        }
   60|       |    }
   61|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap28/MaxContigSubSumReducedStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Maximum Contiguous Subsequence Sum - Reduced Force (Chapter 28, Algorithm 28.13).
    3|       |
    4|       |pub mod MaxContigSubSumReducedStEph {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
    7|       |    use crate::Chap27::ScanContractStEph::ScanContractStEph::ScanContractStEphTrait;
    8|       |    use crate::Types::Types::*;
    9|       |
   10|     57|    fn max_with_neginf(a: Option<i32>, b: Option<i32>) -> Option<i32> {
   11|     57|        match (a, b) {
   12|      0|            | (None, None) => None,
   13|      4|            | (None, Some(_)) => b,
   14|      0|            | (Some(_), None) => a,
   15|     53|            | (Some(x), Some(y)) => Some(x.max(y)),
   16|       |        }
   17|     57|    }
   18|       |
   19|       |    /// Trait for reduced force maximum contiguous subsequence sum.
   20|       |    pub trait MaxContigSubSumReducedTrait {
   21|       |        /// Compute maximum contiguous subsequence sum using reduction to MCSSS.
   22|       |        /// Returns None for empty sequence (representing -).
   23|       |        /// APAS: Work (n), Span (log n)
   24|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   25|       |        /// claude-4-sonnet: Work (n), Span (log n), Parallelism (n/log n)
   26|       |        fn max_contig_sub_sum_reduced(a: &ArraySeqStEphS<i32>) -> Option<i32>;
   27|       |    }
   28|       |
   29|       |    impl MaxContigSubSumReducedTrait for ArraySeqStEphS<i32> {
   30|      5|        fn max_contig_sub_sum_reduced(a: &ArraySeqStEphS<i32>) -> Option<i32> {
   31|      5|            let n = a.length();
   32|       |
   33|       |            // Base case: empty sequence returns None (-)
   34|      5|            if n == 0 {
   35|      1|                return None;
   36|      4|            }
   37|       |
   38|      4|            let mut global_max = None;
   39|       |
   40|       |            // For each starting position
   41|     17|            for i in 0..n {
                                      ^4
   42|       |                // Compute sum for each subsequence starting at position i
   43|       |                // We manually compute inclusive prefix sums instead of using scan_contract
   44|       |                // because scan_contract is exclusive (doesn't include the last element in each prefix)
   45|     17|                let mut running_sum = 0;
   46|     57|                for j in i..n {
                                       ^17^17
   47|     57|                    running_sum += *a.nth(j);
   48|     57|                    global_max = max_with_neginf(global_max, Some(running_sum));
   49|     57|                }
   50|       |            }
   51|       |
   52|      4|            global_max
   53|      5|        }
   54|       |    }
   55|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap35/OrderStatSelectMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Order Statistics - Parallel Ephemeral (Chapter 35, Algorithm 35.2).
    3|       |//! Randomized selection algorithm for finding kth order statistic with parallel partition.
    4|       |//! Work: O(n) expected, Span: O(lg n) expected.
    5|       |
    6|       |pub mod OrderStatSelectMtEph {
    7|       |
    8|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::{
    9|       |        ArraySeqMtEphS, ArraySeqMtEphTrait as ArraySeqMtEphTraitImported,
   10|       |    };
   11|       |    use crate::Types::Types::*;
   12|       |    use rand::Rng;
   13|       |
   14|       |    pub trait OrderStatSelectMtEphTrait<T: StTInMtT + Ord> {
   15|       |        /// claude-4-sonet: Work (n) expected, (n) worst case; Span (log n) expected (with parallel filter), Parallelism (n/log n) expected
   16|       |        fn select(&self, k: N) -> Option<T>;
   17|       |    }
   18|       |
   19|       |    impl<T: StTInMtT + Ord + 'static> OrderStatSelectMtEphTrait<T> for ArraySeqMtEphS<T> {
   20|     86|        fn select(&self, k: N) -> Option<T> {
   21|     86|            let n = self.length();
   22|     86|            if k >= n || n == 0 {
                                       ^84
   23|      2|                return None;
   24|     84|            }
   25|     84|            if n == 1 {
   26|     14|                return Some(self.nth_cloned(0));
   27|     70|            }
   28|       |
   29|     70|            let pivot_idx = rand::rng().random_range(0..n);
   30|     70|            let pivot = self.nth_cloned(pivot_idx);
   31|       |
   32|     70|            let mut left_count = 0;
   33|     70|            let mut right_count = 0;
   34|       |
   35|    347|            for i in 0..n {
                                      ^70
   36|    347|                let elem = self.nth_cloned(i);
   37|    347|                if elem < pivot {
   38|    142|                    left_count += 1;
   39|    205|                } else if elem > pivot {
   40|    110|                    right_count += 1;
   41|    110|                }
                              ^95
   42|       |            }
   43|       |
   44|     70|            if k < left_count {
   45|     27|                let left = ArraySeqMtEphS::tabulate(
   46|     88|                    &|i| {
   47|     88|                        let mut idx = 0;
   48|    290|                        for j in 0..n {
                                                  ^88
   49|    290|                            let elem = self.nth_cloned(j);
   50|    290|                            if elem < pivot {
   51|    233|                                if idx == i {
   52|     88|                                    return elem;
   53|    145|                                }
   54|    145|                                idx += 1;
   55|     57|                            }
   56|       |                        }
   57|      0|                        panic!("Index out of bounds in left partition");
   58|     88|                    },
   59|     27|                    left_count,
   60|       |                );
   61|     27|                left.select(k)
   62|     43|            } else if k < n - right_count {
   63|     22|                Some(pivot)
   64|       |            } else {
   65|     21|                let right = ArraySeqMtEphS::tabulate(
   66|     59|                    &|i| {
   67|     59|                        let mut idx = 0;
   68|    232|                        for j in 0..n {
                                                  ^59
   69|    232|                            let elem = self.nth_cloned(j);
   70|    232|                            if elem > pivot {
   71|    147|                                if idx == i {
   72|     59|                                    return elem;
   73|     88|                                }
   74|     88|                                idx += 1;
   75|     85|                            }
   76|       |                        }
   77|      0|                        panic!("Index out of bounds in right partition");
   78|     59|                    },
   79|     21|                    right_count,
   80|       |                );
   81|     21|                right.select(k - (n - right_count))
   82|       |            }
   83|     86|        }
   84|       |    }
   85|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap35/OrderStatSelectMtPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Order Statistics - Parallel Persistent (Chapter 35, Algorithm 35.2).
    3|       |//! Randomized selection algorithm for finding kth order statistic with parallel partition.
    4|       |//! Work: O(n) expected, Span: O(lg n) expected.
    5|       |
    6|       |pub mod OrderStatSelectMtPer {
    7|       |
    8|       |    use crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::*;
    9|       |    use crate::Types::Types::*;
   10|       |    use rand::Rng;
   11|       |
   12|       |    pub trait OrderStatSelectMtPerTrait<T: StTInMtT + Ord> {
   13|       |        /// claude-4-sonet: Work (n) expected, (n) worst case; Span (log n) expected (with parallel filter), Parallelism (n/log n) expected
   14|       |        fn select(&self, k: N) -> Option<T>;
   15|       |    }
   16|       |
   17|       |    impl<T: StTInMtT + Ord> OrderStatSelectMtPerTrait<T> for ArraySeqMtPerS<T> {
   18|     86|        fn select(&self, k: N) -> Option<T> {
   19|     86|            let n = self.length();
   20|     86|            if k >= n || n == 0 {
                                       ^84
   21|      2|                return None;
   22|     84|            }
   23|     84|            if n == 1 {
   24|     10|                return Some(self.nth(0).clone());
   25|     74|            }
   26|       |
   27|     74|            let pivot_idx = rand::rng().random_range(0..n);
   28|     74|            let pivot = self.nth(pivot_idx).clone();
   29|       |
   30|     74|            let mut left_count = 0;
   31|     74|            let mut right_count = 0;
   32|       |
   33|    342|            for i in 0..n {
                                      ^74
   34|    342|                let elem = self.nth(i);
   35|    342|                if elem < &pivot {
   36|    130|                    left_count += 1;
   37|    212|                } else if elem > &pivot {
   38|    116|                    right_count += 1;
   39|    116|                }
                              ^96
   40|       |            }
   41|       |
   42|     74|            if k < left_count {
   43|     24|                let left = ArraySeqMtPerS::tabulate(
   44|     76|                    &|i| {
   45|     76|                        let mut idx = 0;
   46|    245|                        for j in 0..n {
                                                  ^76
   47|    245|                            let elem = self.nth(j);
   48|    245|                            if elem < &pivot {
   49|    192|                                if idx == i {
   50|     76|                                    return elem.clone();
   51|    116|                                }
   52|    116|                                idx += 1;
   53|     53|                            }
   54|       |                        }
   55|      0|                        panic!("Index out of bounds in left partition");
   56|     76|                    },
   57|     24|                    left_count,
   58|       |                );
   59|     24|                left.select(k)
   60|     50|            } else if k < n - right_count {
   61|     26|                Some(pivot)
   62|       |            } else {
   63|     24|                let right = ArraySeqMtPerS::tabulate(
   64|     62|                    &|i| {
   65|     62|                        let mut idx = 0;
   66|    182|                        for j in 0..n {
                                                  ^62
   67|    182|                            let elem = self.nth(j);
   68|    182|                            if elem > &pivot {
   69|    129|                                if idx == i {
   70|     62|                                    return elem.clone();
   71|     67|                                }
   72|     67|                                idx += 1;
   73|     53|                            }
   74|       |                        }
   75|      0|                        panic!("Index out of bounds in right partition");
   76|     62|                    },
   77|     24|                    right_count,
   78|       |                );
   79|     24|                right.select(k - (n - right_count))
   80|       |            }
   81|     86|        }
   82|       |    }
   83|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap35/OrderStatSelectStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Order Statistics - Sequential Ephemeral (Chapter 35, Algorithm 35.2).
    3|       |//! Randomized selection algorithm for finding kth order statistic.
    4|       |//! Work: O(n) expected, Span: O(lg n) expected.
    5|       |
    6|       |pub mod OrderStatSelectStEph {
    7|       |
    8|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
    9|       |    use crate::Types::Types::*;
   10|       |    use rand::Rng;
   11|       |
   12|       |    pub trait OrderStatSelectStEphTrait<T: StT + Ord> {
   13|       |        /// claude-4-sonet: Work (n) expected, (n) worst case; Span (n) (sequential), Parallelism (1)
   14|       |        fn select(&self, k: N) -> Option<T>;
   15|       |    }
   16|       |
   17|       |    impl<T: StT + Ord> OrderStatSelectStEphTrait<T> for ArraySeqStEphS<T> {
   18|     87|        fn select(&self, k: N) -> Option<T> {
   19|     87|            let n = self.length();
   20|     87|            if k >= n || n == 0 {
                                       ^85
   21|      2|                return None;
   22|     85|            }
   23|     85|            if n == 1 {
   24|     10|                return Some(self.nth(0).clone());
   25|     75|            }
   26|       |
   27|     75|            let pivot_idx = rand::rng().random_range(0..n);
   28|     75|            let pivot = self.nth(pivot_idx).clone();
   29|       |
   30|     75|            let mut left_count = 0;
   31|     75|            let mut right_count = 0;
   32|       |
   33|    349|            for i in 0..n {
                                      ^75
   34|    349|                let elem = self.nth(i);
   35|    349|                if elem < &pivot {
   36|    118|                    left_count += 1;
   37|    231|                } else if elem > &pivot {
   38|    133|                    right_count += 1;
   39|    133|                }
                              ^98
   40|       |            }
   41|       |
   42|     75|            if k < left_count {
   43|     22|                let left = ArraySeqStEphS::tabulate(
   44|     68|                    &|i| {
   45|     68|                        let mut idx = 0;
   46|    206|                        for j in 0..n {
                                                  ^68
   47|    206|                            let elem = self.nth(j);
   48|    206|                            if elem < &pivot {
   49|    156|                                if idx == i {
   50|     68|                                    return elem.clone();
   51|     88|                                }
   52|     88|                                idx += 1;
   53|     50|                            }
   54|       |                        }
   55|      0|                        panic!("Index out of bounds in left partition");
   56|     68|                    },
   57|     22|                    left_count,
   58|       |                );
   59|     22|                left.select(k)
   60|     53|            } else if k < n - right_count {
   61|     26|                Some(pivot)
   62|       |            } else {
   63|     27|                let right = ArraySeqStEphS::tabulate(
   64|     77|                    &|i| {
   65|     77|                        let mut idx = 0;
   66|    275|                        for j in 0..n {
                                                  ^77
   67|    275|                            let elem = self.nth(j);
   68|    275|                            if elem > &pivot {
   69|    178|                                if idx == i {
   70|     77|                                    return elem.clone();
   71|    101|                                }
   72|    101|                                idx += 1;
   73|     97|                            }
   74|       |                        }
   75|      0|                        panic!("Index out of bounds in right partition");
   76|     77|                    },
   77|     27|                    right_count,
   78|       |                );
   79|     27|                right.select(k - (n - right_count))
   80|       |            }
   81|     87|        }
   82|       |    }
   83|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap35/OrderStatSelectStPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Order Statistics - Sequential Persistent (Chapter 35, Algorithm 35.2).
    3|       |//! Randomized selection algorithm for finding kth order statistic.
    4|       |//! Work: O(n) expected, Span: O(lg n) expected.
    5|       |
    6|       |pub mod OrderStatSelectStPer {
    7|       |
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |    use crate::Types::Types::*;
   10|       |    use rand::Rng;
   11|       |
   12|       |    pub trait OrderStatSelectStPerTrait<T: StT + Ord> {
   13|       |        /// claude-4-sonet: Work (n) expected, (n) worst case; Span (n) (sequential), Parallelism (1)
   14|       |        fn select(&self, k: N) -> Option<T>;
   15|       |    }
   16|       |
   17|       |    impl<T: StT + Ord> OrderStatSelectStPerTrait<T> for ArraySeqStPerS<T> {
   18|     83|        fn select(&self, k: N) -> Option<T> {
   19|     83|            let n = self.length();
   20|     83|            if k >= n || n == 0 {
                                       ^81
   21|      2|                return None;
   22|     81|            }
   23|     81|            if n == 1 {
   24|     11|                return Some(self.nth(0).clone());
   25|     70|            }
   26|       |
   27|     70|            let pivot_idx = rand::rng().random_range(0..n);
   28|     70|            let pivot = self.nth(pivot_idx).clone();
   29|       |
   30|     70|            let mut left_count = 0;
   31|     70|            let mut right_count = 0;
   32|       |
   33|    334|            for i in 0..n {
                                      ^70
   34|    334|                let elem = self.nth(i);
   35|    334|                if elem < &pivot {
   36|    125|                    left_count += 1;
   37|    209|                } else if elem > &pivot {
   38|    115|                    right_count += 1;
   39|    115|                }
                              ^94
   40|       |            }
   41|       |
   42|     70|            if k < left_count {
   43|     23|                let left = ArraySeqStPerS::tabulate(
   44|     71|                    &|i| {
   45|     71|                        let mut idx = 0;
   46|    231|                        for j in 0..n {
                                                  ^71
   47|    231|                            let elem = self.nth(j);
   48|    231|                            if elem < &pivot {
   49|    173|                                if idx == i {
   50|     71|                                    return elem.clone();
   51|    102|                                }
   52|    102|                                idx += 1;
   53|     58|                            }
   54|       |                        }
   55|      0|                        panic!("Index out of bounds in left partition");
   56|     71|                    },
   57|     23|                    left_count,
   58|       |                );
   59|     23|                left.select(k)
   60|     47|            } else if k < n - right_count {
   61|     25|                Some(pivot)
   62|       |            } else {
   63|     22|                let right = ArraySeqStPerS::tabulate(
   64|     60|                    &|i| {
   65|     60|                        let mut idx = 0;
   66|    208|                        for j in 0..n {
                                                  ^60
   67|    208|                            let elem = self.nth(j);
   68|    208|                            if elem > &pivot {
   69|    138|                                if idx == i {
   70|     60|                                    return elem.clone();
   71|     78|                                }
   72|     78|                                idx += 1;
   73|     70|                            }
   74|       |                        }
   75|      0|                        panic!("Index out of bounds in right partition");
   76|     60|                    },
   77|     22|                    right_count,
   78|       |                );
   79|     22|                right.select(k - (n - right_count))
   80|       |            }
   81|     83|        }
   82|       |    }
   83|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap36/QuickSortMt.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 36 (Multi-threaded): Quicksort with three pivot strategies over `ArraySeqMtEph`.
    3|       |
    4|       |pub mod Chapter36Mt {
    5|       |
    6|       |    use std::thread;
    7|       |
    8|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
    9|       |    use crate::Types::Types::*;
   10|       |    use rand::*;
   11|       |
   12|       |    pub trait Chapter36MtTrait<T: StT + Ord + Send> {
   13|       |        /// APAS: Work (1), Span (1)
   14|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1) - constant time pivot selection
   15|       |        fn pivot_mt_first(&self, lo: N, hi: N) -> T;
   16|       |        /// APAS: Work (1), Span (1)
   17|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1) - constant time median-of-3
   18|       |        fn pivot_mt_median3(&self, lo: N, hi: N) -> T;
   19|       |        /// APAS: Work (1), Span (1)
   20|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1) - constant time random selection
   21|       |        fn pivot_mt_random(&self, lo: N, hi: N) -> T;
   22|       |        /// APAS: Work (n log n) expected, (n) worst, Span (log n) expected, (n) worst
   23|       |        /// claude-4-sonet: Work (n log n) expected, (n) worst, Span (log n) expected, (n) worst, Parallelism (n/log n) expected - parallel divide-and-conquer with unconditional thread spawning
   24|       |        fn quick_sort_mt_first(&mut self);
   25|       |        /// APAS: Work (n log n) expected, (n) worst, Span (log n) expected, (n) worst
   26|       |        /// claude-4-sonet: Work (n log n) expected, (n) worst, Span (log n) expected, (n) worst, Parallelism (n/log n) expected - parallel divide-and-conquer with median-of-3 pivot
   27|       |        fn quick_sort_mt_median3(&mut self);
   28|       |        /// APAS: Work (n log n) expected, (n) worst, Span (log n) expected, (n) worst
   29|       |        /// claude-4-sonet: Work (n log n) expected, (n) worst, Span (log n) expected, (n) worst, Parallelism (n/log n) expected - parallel divide-and-conquer with random pivot
   30|       |        fn quick_sort_mt_random(&mut self);
   31|       |    }
   32|       |
   33|       |    impl<T: StT + Ord + Send + Sync> Chapter36MtTrait<T> for ArraySeqMtEphS<T> {
   34|      5|        fn pivot_mt_first(&self, lo: N, _hi: N) -> T { self.nth_cloned(lo) }
   35|      6|        fn pivot_mt_median3(&self, lo: N, hi: N) -> T {
   36|      6|            let mid = lo + (hi - lo) / 2;
   37|      6|            let x0 = self.nth_cloned(lo);
   38|      6|            let xm = self.nth_cloned(mid);
   39|      6|            let xl = self.nth_cloned(hi - 1);
   40|      6|            if (x0 <= xm && xm <= xl) || (xl <= xm && xm <= x0) {
                                          ^1            ^5          ^4
   41|      5|                xm
   42|      1|            } else if (xm <= x0 && x0 <= xl) || (xl <= x0 && x0 <= xm) {
   43|      0|                x0
   44|       |            } else {
   45|      1|                xl
   46|       |            }
   47|      6|        }
   48|      4|        fn pivot_mt_random(&self, lo: N, hi: N) -> T {
   49|      4|            let mut r = rng();
   50|      4|            let idx = r.random_range(lo..hi);
   51|      4|            self.nth_cloned(idx)
   52|      4|        }
   53|       |
   54|      8|        fn quick_sort_mt_first(&mut self) {
   55|      8|            if self.length() <= 1usize {
   56|      1|                return;
   57|      7|            }
   58|       |
   59|    699|            fn quick_sort<T: StT + Ord + Send>(data: &mut [T]) {
   60|    699|                let len = data.len();
   61|    699|                if len <= 1 {
   62|    353|                    return;
   63|    346|                }
   64|    346|                let pivot = data[0].clone();
   65|    346|                let mut lt = 0;
   66|    346|                let mut i = 0;
   67|    346|                let mut gt = len;
   68|  46.4k|                while i < gt {
   69|  46.1k|                    if data[i] < pivot {
   70|  43.0k|                        data.swap(lt, i);
   71|  43.0k|                        lt += 1;
   72|  43.0k|                        i += 1;
   73|  43.0k|                    } else if data[i] > pivot {
                                            ^3.01k
   74|    771|                        gt -= 1;
   75|    771|                        data.swap(i, gt);
   76|  2.24k|                    } else {
   77|  2.24k|                        i += 1;
   78|  2.24k|                    }
   79|       |                }
   80|    346|                let (left, mid_and_right) = data.split_at_mut(lt);
   81|    346|                let (_, right) = mid_and_right.split_at_mut(gt - lt);
   82|       |                // Unconditionally parallel - no thresholding
   83|    346|                thread::scope(|scope| {
   84|    346|                    scope.spawn(|| quick_sort(left));
   85|    346|                    quick_sort(right);
   86|    346|                });
   87|    699|            }
   88|       |
   89|      7|            let mut data = self.to_vec();
   90|      7|            quick_sort(&mut data);
   91|      7|            *self = ArraySeqMtEphS::from_vec(data);
   92|      8|        }
   93|      6|        fn quick_sort_mt_median3(&mut self) {
   94|      6|            if self.length() <= 1usize {
   95|      1|                return;
   96|      5|            }
   97|       |
   98|    227|            fn quick_sort<T: StT + Ord + Send>(data: &mut [T]) {
   99|    227|                let len = data.len();
  100|    227|                if len <= 1 {
  101|    116|                    return;
  102|    111|                }
  103|    111|                let len = data.len();
  104|    111|                let mid = len / 2;
  105|    111|                let last = len - 1;
  106|    111|                let x0 = data[0].clone();
  107|    111|                let xm = data[mid].clone();
  108|    111|                let xl = data[last].clone();
  109|    111|                let pivot = if (x0 <= xm && xm <= xl) || (xl <= xm && xm <= x0) {
                                                          ^75           ^62         ^39
  110|     79|                    xm
  111|     32|                } else if (xm <= x0 && x0 <= xl) || (xl <= x0 && x0 <= xm) {
                                                     ^23           ^15         ^15
  112|     26|                    x0
  113|       |                } else {
  114|      6|                    xl
  115|       |                };
  116|    111|                let mut lt = 0;
  117|    111|                let mut i = 0;
  118|    111|                let mut gt = len;
  119|  13.4k|                while i < gt {
  120|  13.3k|                    if data[i] < pivot {
  121|  9.14k|                        data.swap(lt, i);
  122|  9.14k|                        lt += 1;
  123|  9.14k|                        i += 1;
  124|  9.14k|                    } else if data[i] > pivot {
                                            ^4.17k
  125|  3.16k|                        gt -= 1;
  126|  3.16k|                        data.swap(i, gt);
  127|  3.16k|                    } else {
  128|  1.01k|                        i += 1;
  129|  1.01k|                    }
  130|       |                }
  131|    111|                let (left, mid_and_right) = data.split_at_mut(lt);
  132|    111|                let (_, right) = mid_and_right.split_at_mut(gt - lt);
  133|       |                // Unconditionally parallel - no thresholding
  134|    111|                thread::scope(|scope| {
  135|    111|                    scope.spawn(|| quick_sort(left));
  136|    111|                    quick_sort(right);
  137|    111|                });
  138|    227|            }
  139|       |
  140|      5|            let mut data = self.to_vec();
  141|      5|            quick_sort(&mut data);
  142|      5|            *self = ArraySeqMtEphS::from_vec(data);
  143|      6|        }
  144|      5|        fn quick_sort_mt_random(&mut self) {
  145|      5|            if self.length() <= 1usize {
  146|      0|                return;
  147|      5|            }
  148|       |
  149|    425|            fn quick_sort<T: StT + Ord + Send>(data: &mut [T]) {
  150|    425|                let len = data.len();
  151|    425|                if len <= 1 {
  152|    215|                    return;
  153|    210|                }
  154|    210|                let mut rng_local = rng();
  155|    210|                let idx = rng_local.random_range(0..len);
  156|    210|                let pivot = data[idx].clone();
  157|    210|                let mut lt = 0;
  158|    210|                let mut i = 0;
  159|    210|                let mut gt = len;
  160|  8.19k|                while i < gt {
  161|  7.98k|                    if data[i] < pivot {
  162|  4.01k|                        data.swap(lt, i);
  163|  4.01k|                        lt += 1;
  164|  4.01k|                        i += 1;
  165|  4.01k|                    } else if data[i] > pivot {
                                            ^3.97k
  166|  2.81k|                        gt -= 1;
  167|  2.81k|                        data.swap(i, gt);
  168|  2.81k|                    } else {
  169|  1.16k|                        i += 1;
  170|  1.16k|                    }
  171|       |                }
  172|    210|                let (left, mid_and_right) = data.split_at_mut(lt);
  173|    210|                let (_, right) = mid_and_right.split_at_mut(gt - lt);
  174|       |                // Unconditionally parallel - no thresholding
  175|    210|                thread::scope(|scope| {
  176|    210|                    scope.spawn(|| quick_sort(left));
  177|    210|                    quick_sort(right);
  178|    210|                });
  179|    425|            }
  180|       |
  181|      5|            let mut data = self.to_vec();
  182|      5|            quick_sort(&mut data);
  183|      5|            *self = ArraySeqMtEphS::from_vec(data);
  184|      5|        }
  185|       |    }
  186|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap36/QuickSortMtSlice.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 36 (Multi-threaded Slice): Quicksort over `ArraySeqMtEphSlice` without extra copies.
    3|       |
    4|       |pub mod Chapter36MtSlice {
    5|       |
    6|       |    use std::thread;
    7|       |
    8|       |    use crate::Chap19::ArraySeqMtEphSlice::ArraySeqMtEphSlice::*;
    9|       |    use crate::Types::Types::*;
   10|       |    use rand::*;
   11|       |
   12|       |    pub trait Chapter36MtSliceTrait<T: StT + Ord + Send> {
   13|       |        /// APAS: Work (1), Span (1)
   14|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1) - constant time pivot selection
   15|       |        fn pivot_mt_first(&self, lo: N, hi: N) -> T;
   16|       |        /// APAS: Work (1), Span (1)
   17|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1) - constant time median-of-3
   18|       |        fn pivot_mt_median3(&self, lo: N, hi: N) -> T;
   19|       |        /// APAS: Work (1), Span (1)
   20|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1) - constant time random selection
   21|       |        fn pivot_mt_random(&self, lo: N, hi: N) -> T;
   22|       |        /// APAS: Work (n log n) expected, (n) worst, Span (log n) expected, (n) worst
   23|       |        /// claude-4-sonet: Work (n log n) expected, (n) worst, Span (log n) expected, (n) worst, Parallelism (n/log n) expected - parallel divide-and-conquer with unconditional thread spawning (slice-based)
   24|       |        fn quick_sort_mt_first(&self);
   25|       |        /// APAS: Work (n log n) expected, (n) worst, Span (log n) expected, (n) worst
   26|       |        /// claude-4-sonet: Work (n log n) expected, (n) worst, Span (log n) expected, (n) worst, Parallelism (n/log n) expected - parallel divide-and-conquer with median-of-3 pivot (slice-based)
   27|       |        fn quick_sort_mt_median3(&self);
   28|       |        /// APAS: Work (n log n) expected, (n) worst, Span (log n) expected, (n) worst
   29|       |        /// claude-4-sonet: Work (n log n) expected, (n) worst, Span (log n) expected, (n) worst, Parallelism (n/log n) expected - parallel divide-and-conquer with random pivot (slice-based)
   30|       |        fn quick_sort_mt_random(&self);
   31|       |    }
   32|       |
   33|       |    impl<T: StT + Ord + Send + Sync + 'static> Chapter36MtSliceTrait<T> for ArraySeqMtEphSliceS<T> {
   34|      9|        fn pivot_mt_first(&self, lo: N, _hi: N) -> T { self.nth_cloned(lo) }
   35|       |
   36|      8|        fn pivot_mt_median3(&self, lo: N, hi: N) -> T {
   37|      8|            let mid = lo + (hi - lo) / 2;
   38|      8|            let x0 = self.nth_cloned(lo);
   39|      8|            let xm = self.nth_cloned(mid);
   40|      8|            let xl = self.nth_cloned(hi - 1);
   41|      8|            if (x0 <= xm && xm <= xl) || (xl <= xm && xm <= x0) {
                                          ^2            ^7          ^6
   42|      6|                xm
   43|      2|            } else if (xm <= x0 && x0 <= xl) || (xl <= x0 && x0 <= xm) {
                                                 ^1                        ^1
   44|      0|                x0
   45|       |            } else {
   46|      2|                xl
   47|       |            }
   48|      8|        }
   49|       |
   50|     19|        fn pivot_mt_random(&self, lo: N, hi: N) -> T {
   51|     19|            let mut r = rng();
   52|     19|            let idx = r.random_range(lo..hi);
   53|     19|            self.nth_cloned(idx)
   54|     19|        }
   55|       |
   56|      7|        fn quick_sort_mt_first(&self) {
   57|      7|            if self.length() <= 1usize {
   58|      1|                return;
   59|      6|            }
   60|      6|            self.with_exclusive(|data| {
   61|    512|                fn sort<T: StT + Ord + Send>(data: &mut [T]) {
   62|    512|                    let len = data.len();
   63|    512|                    if len <= 1 {
   64|    259|                        return;
   65|    253|                    }
   66|    253|                    let pivot = data[0].clone();
   67|    253|                    let mut lt = 0;
   68|    253|                    let mut i = 0;
   69|    253|                    let mut gt = len;
   70|  26.9k|                    while i < gt {
   71|  26.6k|                        if data[i] < pivot {
   72|  26.3k|                            data.swap(lt, i);
   73|  26.3k|                            lt += 1;
   74|  26.3k|                            i += 1;
   75|  26.3k|                        } else if data[i] > pivot {
                                                ^277
   76|     22|                            gt -= 1;
   77|     22|                            data.swap(i, gt);
   78|    255|                        } else {
   79|    255|                            i += 1;
   80|    255|                        }
   81|       |                    }
   82|    253|                    let (left, mid_and_right) = data.split_at_mut(lt);
   83|    253|                    let (_, right) = mid_and_right.split_at_mut(gt - lt);
   84|       |                    // Unconditionally parallel - no thresholding
   85|    253|                    thread::scope(|scope| {
   86|    253|                        scope.spawn(|| sort(left));
   87|    253|                        sort(right);
   88|    253|                    });
   89|    512|                }
   90|      6|                sort(data);
   91|      6|            });
   92|      7|        }
   93|       |
   94|      7|        fn quick_sort_mt_median3(&self) {
   95|      7|            if self.length() <= 1usize {
   96|      1|                return;
   97|      6|            }
   98|      6|            self.with_exclusive(|data| {
   99|  11.6k|                fn sort<T: StT + Ord + Send>(data: &mut [T]) {
  100|  11.6k|                    let len = data.len();
  101|  11.6k|                    if len <= 1 {
  102|  5.81k|                        return;
  103|  5.81k|                    }
  104|  5.81k|                    let pivot = {
  105|  5.81k|                        let mid = len / 2;
  106|  5.81k|                        let last = len - 1;
  107|  5.81k|                        let x0 = data[0].clone();
  108|  5.81k|                        let xm = data[mid].clone();
  109|  5.81k|                        let xl = data[last].clone();
  110|  5.81k|                        if (x0 <= xm && xm <= xl) || (xl <= xm && xm <= x0) {
                                                      ^4.72k        ^3.01k      ^3.00k
  111|  3.86k|                            xm
  112|  1.94k|                        } else if (xm <= x0 && x0 <= xl) || (xl <= x0 && x0 <= xm) {
                                                             ^10           ^1.93k      ^1.87k
  113|  1.88k|                            x0
  114|       |                        } else {
  115|     60|                            xl
  116|       |                        }
  117|       |                    };
  118|  5.81k|                    let mut lt = 0;
  119|  5.81k|                    let mut i = 0;
  120|  5.81k|                    let mut gt = len;
  121|   430k|                    while i < gt {
  122|   425k|                        if data[i] < pivot {
  123|  37.8k|                            data.swap(lt, i);
  124|  37.8k|                            lt += 1;
  125|  37.8k|                            i += 1;
  126|   387k|                        } else if data[i] > pivot {
  127|   381k|                            gt -= 1;
  128|   381k|                            data.swap(i, gt);
  129|   381k|                        } else {
  130|  5.81k|                            i += 1;
  131|  5.81k|                        }
  132|       |                    }
  133|  5.81k|                    let (left, mid_and_right) = data.split_at_mut(lt);
  134|  5.81k|                    let (_, right) = mid_and_right.split_at_mut(gt - lt);
  135|       |                    // Unconditionally parallel - no thresholding
  136|  5.81k|                    thread::scope(|scope| {
  137|  5.81k|                        scope.spawn(|| sort(left));
  138|  5.81k|                        sort(right);
  139|  5.81k|                    });
  140|  11.6k|                }
  141|      6|                sort(data);
  142|      6|            });
  143|      7|        }
  144|       |
  145|      5|        fn quick_sort_mt_random(&self) {
  146|      5|            if self.length() <= 1usize {
  147|      0|                return;
  148|      5|            }
  149|      5|            self.with_exclusive(|data| {
  150|    351|                fn sort<T: StT + Ord + Send>(data: &mut [T]) {
  151|    351|                    let len = data.len();
  152|    351|                    if len <= 1 {
  153|    178|                        return;
  154|    173|                    }
  155|    173|                    let mut r = rng();
  156|    173|                    let idx = r.random_range(0..len);
  157|    173|                    let pivot = data[idx].clone();
  158|    173|                    let mut lt = 0;
  159|    173|                    let mut i = 0;
  160|    173|                    let mut gt = len;
  161|  2.25k|                    while i < gt {
  162|  2.07k|                        if data[i] < pivot {
  163|    963|                            data.swap(lt, i);
  164|    963|                            lt += 1;
  165|    963|                            i += 1;
  166|  1.11k|                        } else if data[i] > pivot {
  167|    937|                            gt -= 1;
  168|    937|                            data.swap(i, gt);
  169|    937|                        } else {
  170|    179|                            i += 1;
  171|    179|                        }
  172|       |                    }
  173|    173|                    let (left, mid_and_right) = data.split_at_mut(lt);
  174|    173|                    let (_, right) = mid_and_right.split_at_mut(gt - lt);
  175|       |                    // Unconditionally parallel - no thresholding
  176|    173|                    thread::scope(|scope| {
  177|    173|                        scope.spawn(|| sort(left));
  178|    173|                        sort(right);
  179|    173|                    });
  180|    351|                }
  181|      5|                sort(data);
  182|      5|            });
  183|      5|        }
  184|       |    }
  185|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap36/QuickSortSt.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 36 (Single-threaded): Quicksort with three pivot strategies over `ArraySeqStEph`.
    3|       |
    4|       |pub mod Chapter36St {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
    7|       |    use crate::Types::Types::*;
    8|       |    use rand::*;
    9|       |
   10|       |    pub trait Chapter36StTrait<T: StT + Ord> {
   11|       |        /// APAS: Work (1), Span (1)
   12|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1) - constant time pivot selection
   13|       |        fn pivot_st_first(&self, lo: N, hi: N) -> T;
   14|       |        /// APAS: Work (1), Span (1)
   15|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1) - constant time median-of-3
   16|       |        fn pivot_st_median3(&self, lo: N, hi: N) -> T;
   17|       |        /// APAS: Work (1), Span (1)
   18|       |        /// claude-4-sonet: Work (1), Span (1), Parallelism (1) - constant time random selection
   19|       |        fn pivot_st_random(&self, lo: N, hi: N) -> T;
   20|       |        /// APAS: Work (n log n) expected, (n) worst, Span (n log n) expected, (n) worst
   21|       |        /// claude-4-sonet: Work (n log n) expected, (n) worst, Span (n log n) expected, (n) worst, Parallelism (1) - sequential divide-and-conquer
   22|       |        fn quick_sort_st_first(&mut self);
   23|       |        /// APAS: Work (n log n) expected, (n) worst, Span (n log n) expected, (n) worst
   24|       |        /// claude-4-sonet: Work (n log n) expected, (n) worst, Span (n log n) expected, (n) worst, Parallelism (1) - sequential divide-and-conquer with median-of-3 pivot
   25|       |        fn quick_sort_st_median3(&mut self);
   26|       |        /// APAS: Work (n log n) expected, (n) worst, Span (n log n) expected, (n) worst
   27|       |        /// claude-4-sonet: Work (n log n) expected, (n) worst, Span (n log n) expected, (n) worst, Parallelism (1) - sequential divide-and-conquer with random pivot
   28|       |        fn quick_sort_st_random(&mut self);
   29|       |    }
   30|       |
   31|       |    impl<T: StT + Ord> Chapter36StTrait<T> for ArraySeqStEphS<T> {
   32|      2|        fn pivot_st_first(&self, lo: N, _hi: N) -> T { self.nth(lo).clone() }
   33|      3|        fn pivot_st_median3(&self, lo: N, hi: N) -> T {
   34|      3|            let mid = lo + (hi - lo) / 2;
   35|      3|            let x0 = self.nth(lo).clone();
   36|      3|            let xm = self.nth(mid).clone();
   37|      3|            let xl = self.nth(hi - 1).clone();
   38|      3|            if (x0 <= xm && xm <= xl) || (xl <= xm && xm <= x0) {
                                          ^1            ^2          ^1
   39|      2|                xm
   40|      1|            } else if (xm <= x0 && x0 <= xl) || (xl <= x0 && x0 <= xm) {
   41|      0|                x0
   42|       |            } else {
   43|      1|                xl
   44|       |            }
   45|      3|        }
   46|      1|        fn pivot_st_random(&self, lo: N, hi: N) -> T {
   47|      1|            let mut r = rng();
   48|      1|            let idx = r.random_range(lo..hi);
   49|      1|            self.nth(idx).clone()
   50|      1|        }
   51|       |
   52|      4|        fn quick_sort_st_first(&mut self) {
   53|     24|            fn sort<T: StT + Ord>(a: &mut ArraySeqStEphS<T>, lo: N, hi: N) {
   54|     24|                if hi <= lo + 1 {
   55|     14|                    return;
   56|     10|                }
   57|     10|                let pivot = a.nth(lo).clone();
   58|     10|                let mut lt = lo;
   59|     10|                let mut i = lo;
   60|     10|                let mut gt = hi;
   61|     47|                while i < gt {
   62|     37|                    let xi = a.nth(i).clone();
   63|     37|                    if xi < pivot {
   64|     21|                        if lt != i {
   65|     21|                            let xlt = a.nth(lt).clone();
   66|     21|                            let _ = a.set(lt, xi);
   67|     21|                            let _ = a.set(i, xlt);
   68|     21|                        }
                                      ^0
   69|     21|                        lt += 1;
   70|     21|                        i += 1;
   71|     16|                    } else if xi > pivot {
   72|      4|                        gt -= 1;
   73|      4|                        let xgt = a.nth(gt).clone();
   74|      4|                        let _ = a.set(i, xgt);
   75|      4|                        let _ = a.set(gt, xi);
   76|     12|                    } else {
   77|     12|                        i += 1;
   78|     12|                    }
   79|       |                }
   80|     10|                sort(a, lo, lt);
   81|     10|                sort(a, gt, hi);
   82|     24|            }
   83|      4|            let n = self.length();
   84|      4|            sort(self, 0, n);
   85|      4|        }
   86|       |
   87|      4|        fn quick_sort_st_median3(&mut self) {
   88|      6|            fn median3<T: StT + Ord>(a: &ArraySeqStEphS<T>, lo: N, hi: N) -> T {
   89|      6|                let mid = lo + (hi - lo) / 2;
   90|      6|                let x0 = a.nth(lo).clone();
   91|      6|                let xm = a.nth(mid).clone();
   92|      6|                let xl = a.nth(hi - 1).clone();
   93|      6|                if (x0 <= xm && xm <= xl) || (xl <= xm && xm <= x0) {
                                              ^1            ^5          ^4
   94|      5|                    xm
   95|      1|                } else if (xm <= x0 && x0 <= xl) || (xl <= x0 && x0 <= xm) {
   96|      0|                    x0
   97|       |                } else {
   98|      1|                    xl
   99|       |                }
  100|      6|            }
  101|     16|            fn sort<T: StT + Ord>(a: &mut ArraySeqStEphS<T>, lo: N, hi: N) {
  102|     16|                if hi <= lo + 1 {
  103|     10|                    return;
  104|      6|                }
  105|      6|                let pivot = median3(a, lo, hi);
  106|      6|                let mut lt = lo;
  107|      6|                let mut i = lo;
  108|      6|                let mut gt = hi;
  109|     30|                while i < gt {
  110|     24|                    let xi = a.nth(i).clone();
  111|     24|                    if xi < pivot {
  112|     10|                        if lt != i {
  113|      4|                            let xlt = a.nth(lt).clone();
  114|      4|                            let _ = a.set(lt, xi);
  115|      4|                            let _ = a.set(i, xlt);
  116|      6|                        }
  117|     10|                        lt += 1;
  118|     10|                        i += 1;
  119|     14|                    } else if xi > pivot {
  120|      6|                        gt -= 1;
  121|      6|                        let xgt = a.nth(gt).clone();
  122|      6|                        let _ = a.set(i, xgt);
  123|      6|                        let _ = a.set(gt, xi);
  124|      8|                    } else {
  125|      8|                        i += 1;
  126|      8|                    }
  127|       |                }
  128|      6|                sort(a, lo, lt);
  129|      6|                sort(a, gt, hi);
  130|     16|            }
  131|      4|            let n = self.length();
  132|      4|            sort(self, 0, n);
  133|      4|        }
  134|       |
  135|      2|        fn quick_sort_st_random(&mut self) {
  136|     14|            fn sort<T: StT + Ord>(a: &mut ArraySeqStEphS<T>, lo: N, hi: N) {
  137|     14|                if hi <= lo + 1 {
  138|      8|                    return;
  139|      6|                }
  140|      6|                let mut r = rng();
  141|      6|                let idx = r.random_range(lo..hi);
  142|      6|                let pivot = a.nth(idx).clone();
  143|      6|                let mut lt = lo;
  144|      6|                let mut i = lo;
  145|      6|                let mut gt = hi;
  146|     31|                while i < gt {
  147|     25|                    let xi = a.nth(i).clone();
  148|     25|                    if xi < pivot {
  149|     10|                        if lt != i {
  150|      2|                            let xlt = a.nth(lt).clone();
  151|      2|                            let _ = a.set(lt, xi);
  152|      2|                            let _ = a.set(i, xlt);
  153|      8|                        }
  154|     10|                        lt += 1;
  155|     10|                        i += 1;
  156|     15|                    } else if xi > pivot {
  157|      7|                        gt -= 1;
  158|      7|                        let xgt = a.nth(gt).clone();
  159|      7|                        let _ = a.set(i, xgt);
  160|      7|                        let _ = a.set(gt, xi);
  161|      8|                    } else {
  162|      8|                        i += 1;
  163|      8|                    }
  164|       |                }
  165|      6|                sort(a, lo, lt);
  166|      6|                sort(a, gt, hi);
  167|     14|            }
  168|      2|            let n = self.length();
  169|      2|            sort(self, 0, n);
  170|      2|        }
  171|       |    }
  172|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap37/AVLTreeSeq.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Implicit-order AVL tree providing O(lg(n)) nth and set by maintaining subtree sizes.
    3|       |//!
    4|       |//! Abstract:
    5|       |//! - `AVLTreeRoot<T>` stores a balanced binary tree; in-order traversal defines the sequence order.
    6|       |//! - `AVLTreeNode<T>` stores `value`, `height`, `left_size`, `right_size`, and children.
    7|       |//! - Supports sequence-like operations similar to `ArraySeq` plus `from_vec`, iterator, and conversion to `ArrayS`.
    8|       |//! - Duplicates are supported naturally; a `dup_key` monotonically increases to distinguish insertion order if needed.
    9|       |
   10|       |pub mod AVLTreeSeq {
   11|       |
   12|       |    use std::fmt::Debug;
   13|       |
   14|       |    use crate::Chap18::ArraySeq::ArraySeq::*;
   15|       |    use crate::Types::Types::*;
   16|       |
   17|       |    type Link<T> = Option<Box<AVLTreeNode<T>>>;
   18|       |
   19|       |    pub struct AVLTreeNode<T: Copy + Debug> {
   20|       |        pub value: T,
   21|       |        pub height: N,
   22|       |        pub left_size: N,
   23|       |        pub right_size: N,
   24|       |        pub left: Link<T>,
   25|       |        pub right: Link<T>,
   26|       |        pub index: N,
   27|       |    }
   28|       |
   29|       |    impl<T: Copy + Debug> AVLTreeNode<T> {
   30|     39|        fn new(value: T, index: N) -> Self {
   31|     39|            AVLTreeNode {
   32|     39|                value,
   33|     39|                height: 1,
   34|     39|                left_size: 0,
   35|     39|                right_size: 0,
   36|     39|                left: None,
   37|     39|                right: None,
   38|     39|                index,
   39|     39|            }
   40|     39|        }
   41|       |    }
   42|       |
   43|       |    pub struct AVLTreeS<T: Copy + Debug> {
   44|       |        pub root: Link<T>,
   45|       |        pub next_key: N,
   46|       |    }
   47|       |
   48|       |    pub trait AVLTreeSeq<T: Copy + Debug> {
   49|       |        /// Construct an empty tree.
   50|       |        /// APAS: Work (1), Span (1).
   51|       |        /// claude-4-sonet: Work (1), Span (1).
   52|       |        fn empty() -> AVLTreeS<T>;
   53|       |
   54|       |        /// Construct an empty tree (alias).
   55|       |        /// APAS: Work (1), Span (1).
   56|       |        fn new() -> AVLTreeS<T>;
   57|       |
   58|       |        /// Return number of elements.
   59|       |        /// APAS: Work (1), Span (1).
   60|       |        fn length(&self) -> N;
   61|       |
   62|       |        /// Return a reference to the in-order `index`-th element. Panics if out of bounds.
   63|       |        /// APAS: Work (lg(n)), Span (lg(n)).
   64|       |        fn nth(&self, index: N) -> &T;
   65|       |
   66|       |        /// Set the in-order `index`-th element to `item`.
   67|       |        /// APAS: Work (lg(n)), Span (lg(n)).
   68|       |        fn set(&mut self, index: N, item: T) -> Result<&mut AVLTreeS<T>, &'static str>;
   69|       |
   70|       |        /// Construct a singleton sequence.
   71|       |        /// APAS: Work (1), Span (1).
   72|       |        fn singleton(item: T) -> AVLTreeS<T>;
   73|       |
   74|       |        /// Predicates.
   75|       |        /// APAS: Work (1), Span (1).
   76|       |        fn isEmpty(&self) -> B;
   77|       |        fn isSingleton(&self) -> B;
   78|       |
   79|       |        /// Return subsequence [start, start+length) as a new tree.
   80|       |        /// APAS: Work (1 + lg(|a|)), Span (1 + lg(|a|)).
   81|       |        fn subseq_copy(&self, start: N, length: N) -> AVLTreeS<T>
   82|       |        where
   83|       |            T: Clone + Eq;
   84|       |    }
   85|       |
   86|       |    impl<T: Copy + Debug> AVLTreeS<T> {
   87|     46|        pub fn new_root() -> Self {
   88|     46|            AVLTreeS {
   89|     46|                root: None,
   90|     46|                next_key: 0,
   91|     46|            }
   92|     46|        }
   93|      3|        pub fn new() -> Self { Self::new_root() }
   94|       |
   95|      1|        pub fn update(&mut self, (index, item): (N, T)) -> &mut AVLTreeS<T> {
   96|      1|            let _ = <AVLTreeS<T> as AVLTreeSeq<T>>::set(self, index, item);
   97|      1|            self
   98|      1|        }
   99|       |
  100|     10|        pub fn from_vec(values: Vec<T>) -> AVLTreeS<T>
  101|     10|        where
  102|     10|            T: Clone,
  103|       |        {
  104|     10|            let length = values.len();
  105|     10|            let mut t = AVLTreeS::new_root();
  106|     23|            for (i, v) in values.into_iter().enumerate() {
                                        ^10    ^10         ^10
  107|     23|                t.root = insert_at_link(t.root.take(), i, v, &mut t.next_key);
  108|     23|            }
  109|     10|            debug_assert!(t.length() == length);
  110|     10|            t
  111|     10|        }
  112|       |
  113|      1|        pub fn to_arrayseq(&self) -> ArraySeqS<T>
  114|      1|        where
  115|      1|            T: Clone,
  116|       |        {
  117|      1|            let len = self.length();
  118|      1|            if len == 0 {
  119|      0|                return <ArraySeqS<T> as ArraySeq<T>>::empty();
  120|      1|            }
  121|      1|            let mut it = self.iter();
  122|      1|            let first = it.next().expect("length > 0 but iter was empty").clone();
  123|      1|            let mut out = <ArraySeqS<T> as ArraySeq<T>>::new(len, first);
  124|      1|            let mut index: N = 1;
  125|      3|            for v in it {
                              ^2
  126|      2|                let _ = out.set(index, v.clone());
  127|      2|                index += 1;
  128|      2|            }
  129|      1|            out
  130|      1|        }
  131|       |
  132|      4|        pub fn iter<'a>(&'a self) -> AVLTreeSeqIter<'a, T> { AVLTreeSeqIter::new(&self.root) }
  133|       |
  134|      3|        pub fn push_back(&mut self, value: T) {
  135|      3|            let len = self.length();
  136|      3|            let node = insert_at_link(self.root.take(), len, value, &mut self.next_key);
  137|      3|            self.root = node;
  138|      3|        }
  139|       |
  140|       |        // Convenience APIs kept for older tests (set-like operations over sequence storage)
  141|      3|        pub fn contains_value(&self, target: &T) -> B
  142|      3|        where
  143|      3|            T: PartialEq,
  144|       |        {
  145|      6|            for v in self.iter() {
                                   ^3   ^3
  146|      6|                if v == target {
  147|      2|                    return true;
  148|      4|                }
  149|       |            }
  150|      1|            false
  151|      3|        }
  152|       |
  153|      1|        pub fn insert_value(&mut self, value: T) { self.push_back(value); }
  154|       |
  155|      1|        pub fn delete_value(&mut self, target: &T) -> bool
  156|      1|        where
  157|      1|            T: Clone + PartialEq,
  158|       |        {
  159|      1|            let len = self.length();
  160|      1|            let mut found_index: Option<N> = None;
  161|      2|            for i in 0..len {
                                      ^1
  162|      2|                if self.nth(i) == target {
  163|      1|                    found_index = Some(i);
  164|      1|                    break;
  165|      1|                }
  166|       |            }
  167|      1|            if let Some(idx) = found_index {
  168|       |                // Rebuild without the element at idx, using ArraySeq preallocation
  169|      1|                let mut out_vec: Vec<T> = Vec::with_capacity(len - 1);
  170|      1|                for i in 0..idx {
  171|      1|                    out_vec.push(self.nth(i).clone());
  172|      1|                }
  173|      1|                for i in (idx + 1)..len {
  174|      1|                    out_vec.push(self.nth(i).clone());
  175|      1|                }
  176|      1|                *self = AVLTreeS::from_vec(out_vec);
  177|      1|                true
  178|       |            } else {
  179|      0|                false
  180|       |            }
  181|      1|        }
  182|       |
  183|      2|        pub fn is_tree_empty(&self) -> bool { self.length() == 0 }
  184|       |
  185|      1|        pub fn values_in_order(&self) -> Vec<T>
  186|      1|        where
  187|      1|            T: Clone,
  188|       |        {
  189|      1|            let mut out = Vec::with_capacity(self.length());
  190|      1|            push_inorder(&self.root, &mut out);
  191|      1|            out
  192|      1|        }
  193|       |    }
  194|       |
  195|       |    impl<T: Copy + Debug> AVLTreeSeq<T> for AVLTreeS<T> {
  196|       |        /// APAS: Work (1), Span (1).
  197|     18|        fn empty() -> AVLTreeS<T> { AVLTreeS::new_root() }
  198|       |
  199|       |        /// APAS: Work (1), Span (1).
  200|      1|        fn new() -> AVLTreeS<T> { AVLTreeS::new_root() }
  201|       |
  202|       |        /// APAS: Work (1), Span (1).
  203|     91|        fn length(&self) -> N { size_link(&self.root) }
  204|       |
  205|       |        /// APAS: Work (lg(n)), Span (lg(n)).
  206|     23|        fn nth(&self, index: N) -> &T { nth_link(&self.root, index) }
  207|       |
  208|       |        /// APAS: Work (lg(n)), Span (lg(n)).
  209|      5|        fn set(&mut self, index: N, item: T) -> Result<&mut AVLTreeS<T>, &'static str> {
  210|      5|            set_link(&mut self.root, index, item)?;
                                                               ^2
  211|      3|            Ok(self)
  212|      5|        }
  213|       |
  214|       |        /// APAS: Work (1), Span (1).
  215|     13|        fn singleton(item: T) -> AVLTreeS<T> {
  216|     13|            let mut t = AVLTreeS::new_root();
  217|     13|            t.root = insert_at_link(t.root.take(), 0, item, &mut t.next_key);
  218|     13|            t
  219|     13|        }
  220|       |
  221|       |        /// APAS: Work (1), Span (1).
  222|     17|        fn isEmpty(&self) -> B { if self.length() == 0 { true } else { false } }
                                                                       ^14           ^3
  223|       |        /// APAS: Work (1), Span (1).
  224|      7|        fn isSingleton(&self) -> B { if self.length() == 1 { true } else { false } }
                                                                           ^3            ^4
  225|       |
  226|       |        /// APAS: Work (1 + lg(|a|)), Span (1 + lg(|a|)).
  227|     12|        fn subseq_copy(&self, start: N, length: N) -> AVLTreeS<T>
  228|     12|        where
  229|     12|            T: Clone + Eq,
  230|       |        {
  231|     12|            let n = self.length();
  232|     12|            let s = start.min(n);
  233|     12|            let e = start.saturating_add(length).min(n);
  234|     12|            if e <= s {
  235|     10|                return <AVLTreeS<T> as AVLTreeSeq<T>>::empty();
  236|      2|            }
  237|      2|            let mut vals: Vec<T> = Vec::with_capacity(e - s);
  238|      2|            for i in s..e {
  239|      2|                vals.push(self.nth(i).clone());
  240|      2|            }
  241|      2|            AVLTreeS::from_vec(vals)
  242|     12|        }
  243|       |    }
  244|       |
  245|       |    impl<T: Eq + Copy + Debug> PartialEq for AVLTreeS<T> {
  246|      0|        fn eq(&self, other: &Self) -> bool {
  247|      0|            if self.length() != other.length() {
  248|      0|                return false;
  249|      0|            }
  250|      0|            for i in 0..self.length() {
  251|      0|                if self.nth(i) != other.nth(i) {
  252|      0|                    return false;
  253|      0|                }
  254|       |            }
  255|      0|            true
  256|      0|        }
  257|       |    }
  258|       |
  259|       |    impl<T: Eq + Copy + Debug> Eq for AVLTreeS<T> {}
  260|       |
  261|       |    impl<T: Debug + Copy> std::fmt::Debug for AVLTreeS<T> {
  262|      0|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  263|      0|            let elts = (0..self.length()).map(|i| self.nth(i));
  264|      0|            f.debug_list().entries(elts).finish()
  265|      0|        }
  266|       |    }
  267|       |
  268|       |    impl<T: std::fmt::Display + Copy + Debug> std::fmt::Display for AVLTreeS<T> {
  269|      0|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  270|      0|            write!(f, "[")?;
  271|      0|            let mut first = true;
  272|      0|            for v in self.iter() {
  273|      0|                if !first {
  274|      0|                    write!(f, ", ")?;
  275|      0|                }
  276|      0|                first = false;
  277|      0|                write!(f, "{}", v)?;
  278|       |            }
  279|      0|            write!(f, "]")
  280|      0|        }
  281|       |    }
  282|       |
  283|       |    // ---- Iterator ----
  284|       |
  285|       |    pub struct AVLTreeSeqIter<'a, T: Copy + Debug> {
  286|       |        stack: Vec<&'a AVLTreeNode<T>>,
  287|       |        current: Option<&'a AVLTreeNode<T>>,
  288|       |    }
  289|       |
  290|       |    impl<'a, T: Copy + Debug> AVLTreeSeqIter<'a, T> {
  291|      4|        fn new(root: &'a Link<T>) -> Self {
  292|      4|            let mut it = AVLTreeSeqIter {
  293|      4|                stack: Vec::new(),
  294|      4|                current: None,
  295|      4|            };
  296|      4|            it.push_left(root);
  297|      4|            it
  298|      4|        }
  299|       |
  300|     13|        fn push_left(&mut self, link: &'a Link<T>) {
  301|     13|            let mut cursor = link;
  302|     23|            while let Some(ref node) = cursor.as_ref() {
                                         ^10
  303|     10|                self.stack.push(node);
  304|     10|                cursor = &node.left;
  305|     10|            }
  306|     13|        }
  307|       |    }
  308|       |
  309|       |    impl<'a, T: Copy + Debug> Iterator for AVLTreeSeqIter<'a, T> {
  310|       |        type Item = &'a T;
  311|     11|        fn next(&mut self) -> Option<Self::Item> {
  312|     11|            let node = self.stack.pop()?;
                              ^9                     ^2
  313|      9|            let value_ref: &T = &node.value;
  314|      9|            self.push_left(&node.right);
  315|      9|            Some(value_ref)
  316|     11|        }
  317|       |    }
  318|       |
  319|       |    // ---- Internal helpers ----
  320|       |
  321|    128|    fn h<T: Copy + Debug>(n: &Link<T>) -> N { n.as_ref().map_or(0, |b| b.height) }
  322|    167|    fn size_link<T: Copy + Debug>(n: &Link<T>) -> N {
  323|    167|        if let Some(b) = n {
                                  ^74
  324|     74|            1 + b.left_size + b.right_size
  325|       |        } else {
  326|     93|            0
  327|       |        }
  328|    167|    }
  329|       |
  330|     38|    fn update_meta<T: Copy + Debug>(n: &mut Box<AVLTreeNode<T>>) {
  331|     38|        n.left_size = size_link(&n.left);
  332|     38|        n.right_size = size_link(&n.right);
  333|     38|        let hl = h(&n.left);
  334|     38|        let hr = h(&n.right);
  335|     38|        n.height = 1 + hl.max(hr);
  336|     38|    }
  337|       |
  338|      0|    fn rotate_right<T: Copy + Debug>(mut y: Box<AVLTreeNode<T>>) -> Box<AVLTreeNode<T>> {
  339|      0|        let mut x = y.left.take().expect("rotate_right requires left child");
  340|      0|        let t2 = x.right.take();
  341|       |
  342|      0|        y.left = t2;
  343|      0|        update_meta(&mut y);
  344|       |
  345|      0|        x.right = Some(y);
  346|      0|        update_meta(x.right.as_mut().unwrap());
  347|      0|        update_meta(&mut x);
  348|      0|        x
  349|      0|    }
  350|       |
  351|      6|    fn rotate_left<T: Copy + Debug>(mut x: Box<AVLTreeNode<T>>) -> Box<AVLTreeNode<T>> {
  352|      6|        let mut y = x.right.take().expect("rotate_left requires right child");
  353|      6|        let t2 = y.left.take();
  354|       |
  355|      6|        x.right = t2;
  356|      6|        update_meta(&mut x);
  357|       |
  358|      6|        y.left = Some(x);
  359|      6|        update_meta(y.left.as_mut().unwrap());
  360|      6|        update_meta(&mut y);
  361|      6|        y
  362|      6|    }
  363|       |
  364|     20|    fn rebalance<T: Copy + Debug>(mut n: Box<AVLTreeNode<T>>) -> Box<AVLTreeNode<T>> {
  365|     20|        update_meta(&mut n);
  366|     20|        let hl = h(&n.left);
  367|     20|        let hr = h(&n.right);
  368|     20|        if hl > hr.saturating_add(1) {
  369|       |            // Left heavy: check for Left-Right case
  370|      0|            if h(&n.left.as_ref().unwrap().right) > h(&n.left.as_ref().unwrap().left) {
  371|      0|                let left = n.left.take().unwrap();
  372|      0|                n.left = Some(rotate_left(left));
  373|      0|            }
  374|      0|            return rotate_right(n);
  375|     20|        }
  376|     20|        if hr > hl.saturating_add(1) {
  377|       |            // Right heavy: check for Right-Left case
  378|      6|            if h(&n.right.as_ref().unwrap().left) > h(&n.right.as_ref().unwrap().right) {
  379|      0|                let right = n.right.take().unwrap();
  380|      0|                n.right = Some(rotate_right(right));
  381|      6|            }
  382|      6|            return rotate_left(n);
  383|     14|        }
  384|     14|        n
  385|     20|    }
  386|       |
  387|       |    #[doc(hidden)]
  388|     59|    pub(crate) fn insert_at_link<T: Copy + Debug>(node: Link<T>, index: N, value: T, next_key: &mut N) -> Link<T> {
  389|     59|        match node {
  390|       |            | None => {
  391|     39|                debug_assert!(index == 0, "insert_at_link reached None with index > 0");
                                                        ^0
  392|     39|                let key = *next_key;
  393|     39|                *next_key += 1;
  394|     39|                Some(Box::new(AVLTreeNode::new(value, key)))
  395|       |            }
  396|     20|            | Some(mut n) => {
  397|     20|                let left_size = n.left_size;
  398|     20|                if index <= left_size {
  399|      0|                    n.left = insert_at_link(n.left.take(), index, value, next_key);
  400|     20|                } else {
  401|     20|                    n.right = insert_at_link(n.right.take(), index - left_size - 1, value, next_key);
  402|     20|                }
  403|     20|                Some(rebalance(n))
  404|       |            }
  405|       |        }
  406|     59|    }
  407|       |
  408|     30|    fn nth_link<'a, T: Copy + Debug>(node: &'a Link<T>, index: N) -> &'a T {
  409|     30|        let n = node.as_ref().expect("index out of bounds");
  410|     30|        let left_size = n.left_size;
  411|     30|        if index < left_size {
  412|      3|            return nth_link(&n.left, index);
  413|     27|        }
  414|     27|        if index == left_size {
  415|     21|            return &n.value;
  416|      6|        }
  417|      6|        nth_link(&n.right, index - left_size - 1)
  418|     30|    }
  419|       |
  420|      7|    fn set_link<T: Copy + Debug>(node: &mut Link<T>, index: N, value: T) -> Result<(), &'static str> {
  421|      7|        match node {
  422|      2|            | None => Err("Index out of bounds"),
  423|      5|            | Some(n) => {
  424|      5|                let left_size = n.left_size;
  425|      5|                if index < left_size {
  426|      0|                    set_link(&mut n.left, index, value)
  427|      5|                } else if index == left_size {
  428|      3|                    n.value = value;
  429|      3|                    Ok(())
  430|       |                } else {
  431|      2|                    set_link(&mut n.right, index - left_size - 1, value)
  432|       |                }
  433|       |            }
  434|       |        }
  435|      7|    }
  436|       |
  437|      7|    fn push_inorder<T: Copy + Debug + Clone>(link: &Link<T>, out: &mut Vec<T>) {
  438|      7|        if let Some(n) = link {
                                  ^3
  439|      3|            push_inorder(&n.left, out);
  440|      3|            out.push(n.value);
  441|      3|            push_inorder(&n.right, out);
  442|      4|        }
  443|      7|    }
  444|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap37/AVLTreeSeqMtPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! MtPer (immutable, thread-safe, structurally shared) AVL tree sequence using Arc path-copying.
    3|       |
    4|       |pub mod AVLTreeSeqMtPer {
    5|       |
    6|       |    use std::fmt::Debug;
    7|       |    use std::sync::Arc;
    8|       |
    9|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    type Link<T> = Option<Arc<Node<T>>>;
   13|       |
   14|       |    struct Node<T: StTInMtT> {
   15|       |        value: T,
   16|       |        height: N,
   17|       |        size: N,
   18|       |        left: Link<T>,
   19|       |        right: Link<T>,
   20|       |    }
   21|       |
   22|  22.7k|    fn height<T: StTInMtT>(n: &Link<T>) -> N { n.as_ref().map_or(0, |r| r.height) }
                                                                                      ^10.4k
   23|  26.6k|    fn size<T: StTInMtT>(n: &Link<T>) -> N { n.as_ref().map_or(0, |r| r.size) }
                                                                                    ^13.6k
   24|       |
   25|  11.3k|    fn mk<T: StTInMtT>(value: T, left: Link<T>, right: Link<T>) -> Arc<Node<T>> {
   26|  11.3k|        let hl = height(&left);
   27|  11.3k|        let hr = height(&right);
   28|  11.3k|        let sz = 1 + size(&left) + size(&right);
   29|  11.3k|        Arc::new(Node {
   30|  11.3k|            value,
   31|  11.3k|            height: 1 + hl.max(hr),
   32|  11.3k|            size: sz,
   33|  11.3k|            left,
   34|  11.3k|            right,
   35|  11.3k|        })
   36|  11.3k|    }
   37|       |
   38|      0|    fn rotate_right<T: StTInMtT>(y: Arc<Node<T>>) -> Arc<Node<T>> {
   39|      0|        let x = y.left.as_ref().expect("rotate_right requires left").clone();
   40|      0|        let t2 = x.right.clone();
   41|      0|        let new_y = mk(y.value.clone(), t2.clone(), y.right.clone());
   42|      0|        mk(x.value.clone(), x.left.clone(), Some(new_y))
   43|      0|    }
   44|       |
   45|      0|    fn rotate_left<T: StTInMtT>(x: Arc<Node<T>>) -> Arc<Node<T>> {
   46|      0|        let y = x.right.as_ref().expect("rotate_left requires right").clone();
   47|      0|        let t2 = y.left.clone();
   48|      0|        let new_x = mk(x.value.clone(), x.left.clone(), t2.clone());
   49|      0|        mk(y.value.clone(), Some(new_x), y.right.clone())
   50|      0|    }
   51|       |
   52|      6|    fn rebalance<T: StTInMtT>(n: Arc<Node<T>>) -> Arc<Node<T>> {
   53|      6|        let hl = height(&n.left);
   54|      6|        let hr = height(&n.right);
   55|      6|        if hl > hr.saturating_add(1) {
   56|      0|            let left = n.left.as_ref().unwrap().clone();
   57|      0|            if height(&left.right) > height(&left.left) {
   58|      0|                let rotated = rotate_left(left);
   59|      0|                return rotate_right(mk(n.value.clone(), Some(rotated), n.right.clone()));
   60|      0|            }
   61|      0|            return rotate_right(n);
   62|      6|        }
   63|      6|        if hr > hl.saturating_add(1) {
   64|      0|            let right = n.right.as_ref().unwrap().clone();
   65|      0|            if height(&right.left) > height(&right.right) {
   66|      0|                let rotated = rotate_right(right);
   67|      0|                return rotate_left(mk(n.value.clone(), n.left.clone(), Some(rotated)));
   68|      0|            }
   69|      0|            return rotate_left(n);
   70|      6|        }
   71|      6|        n
   72|      6|    }
   73|       |
   74|  1.29k|    fn nth_ref<'a, T: StTInMtT>(mut cur: &'a Link<T>, mut index: N) -> &'a T {
   75|       |        loop {
   76|  2.66k|            let node = cur.as_ref().expect("index out of bounds");
   77|  2.66k|            let ls = size(&node.left);
   78|  2.66k|            if index < ls {
   79|    251|                cur = &node.left;
   80|  2.40k|            } else if index == ls {
   81|  1.29k|                return &node.value;
   82|  1.11k|            } else {
   83|  1.11k|                index -= ls + 1;
   84|  1.11k|                cur = &node.right;
   85|  1.11k|            }
   86|       |        }
   87|  1.29k|    }
   88|       |
   89|     14|    fn set_rec<T: StTInMtT>(cur: &Link<T>, index: N, value: T) -> Result<Link<T>, &'static str> {
   90|     14|        match cur {
   91|       |            | None => {
   92|      0|                if index == 0 {
   93|      0|                    Ok(Some(mk(value, None, None)))
   94|       |                } else {
   95|      0|                    Err("Index out of bounds")
   96|       |                }
   97|       |            }
   98|     14|            | Some(n) => {
   99|     14|                let ls = size(&n.left);
  100|     14|                if index < ls {
  101|      4|                    let new_left = set_rec(&n.left, index, value)?;
                                                                               ^0
  102|      4|                    Ok(Some(rebalance(mk(n.value.clone(), new_left, n.right.clone()))))
  103|     10|                } else if index == ls {
  104|      8|                    Ok(Some(mk(value, n.left.clone(), n.right.clone())))
  105|       |                } else {
  106|      2|                    let new_right = set_rec(&n.right, index - ls - 1, value)?;
                                                                                          ^0
  107|      2|                    Ok(Some(rebalance(mk(n.value.clone(), n.left.clone(), new_right))))
  108|       |                }
  109|       |            }
  110|       |        }
  111|     14|    }
  112|       |
  113|  22.0k|    fn inorder_collect<T: StTInMtT>(cur: &Link<T>, out: &mut Vec<T>) {
  114|  22.0k|        if let Some(n) = cur {
                                  ^10.6k
  115|  10.6k|            inorder_collect(&n.left, out);
  116|  10.6k|            out.push(n.value.clone());
  117|  10.6k|            inorder_collect(&n.right, out);
  118|  11.3k|        }
  119|  22.0k|    }
  120|       |
  121|    648|    fn build_balanced_from_slice<T: StTInMtT>(a: &[T]) -> Link<T> {
  122|  22.7k|        fn rec<T: StTInMtT>(a: &[T]) -> Link<T> {
  123|  22.7k|            if a.is_empty() {
  124|  11.7k|                return None;
  125|  11.0k|            }
  126|  11.0k|            let mid = a.len() / 2;
  127|  11.0k|            let left = rec(&a[..mid]);
  128|  11.0k|            let right = rec(&a[mid + 1..]);
  129|  11.0k|            Some(mk(a[mid].clone(), left, right))
  130|  22.7k|        }
  131|    648|        rec(a)
  132|    648|    }
  133|       |
  134|       |    pub struct AVLTreeSeqMtPerS<T: StTInMtT> {
  135|       |        root: Link<T>,
  136|       |    }
  137|       |
  138|       |    pub trait AVLTreeSeqMtPerTrait<T: StTInMtT> {
  139|       |        /// APAS: Work (1), Span (1)
  140|       |        /// claude-4-sonet: Work (1), Span (1)
  141|       |        fn empty() -> Self;
  142|       |        /// APAS: Work (1), Span (1)
  143|       |        fn new() -> Self;
  144|       |        /// APAS: Work (1), Span (1)
  145|       |        fn length(&self) -> N;
  146|       |        /// APAS: Work (lg(n)), Span (lg(n))
  147|       |        fn nth(&self, index: N) -> &T;
  148|       |        /// APAS (ephemeral set (lg n)); MtPer path-copy (lg n) allocations. Work (lg n), Span (lg n)
  149|       |        fn set(&self, index: N, item: T) -> Result<Self, &'static str>
  150|       |        where
  151|       |            Self: Sized;
  152|       |        /// APAS: Work (1), Span (1)
  153|       |        fn singleton(item: T) -> Self;
  154|       |        /// APAS: Work (1), Span (1)
  155|       |        fn isEmpty(&self) -> B;
  156|       |        /// APAS: Work (1), Span (1)
  157|       |        fn isSingleton(&self) -> B;
  158|       |        /// APAS: Work (1 + lg|a|), Span (1 + lg|a|)
  159|       |        fn subseq_copy(&self, start: N, length: N) -> Self;
  160|       |        /// Build balanced tree from values in in-order order.
  161|       |        fn from_vec(values: Vec<T>) -> Self;
  162|       |        /// Collect in-order values to Vec.
  163|       |        fn values_in_order(&self) -> Vec<T>;
  164|       |    }
  165|       |
  166|       |    impl<T: StTInMtT> AVLTreeSeqMtPerTrait<T> for AVLTreeSeqMtPerS<T> {
  167|    166|        fn empty() -> Self { AVLTreeSeqMtPerS { root: None } }
  168|      1|        fn new() -> Self { Self::empty() }
  169|  1.25k|        fn length(&self) -> N { size(&self.root) }
  170|  1.29k|        fn nth(&self, index: N) -> &T { nth_ref(&self.root, index) }
  171|      8|        fn set(&self, index: N, item: T) -> Result<Self, &'static str> {
  172|       |            Ok(AVLTreeSeqMtPerS {
  173|      8|                root: set_rec(&self.root, index, item)?,
                                                                    ^0
  174|       |            })
  175|      8|        }
  176|    274|        fn singleton(item: T) -> Self {
  177|    274|            AVLTreeSeqMtPerS {
  178|    274|                root: Some(mk(item, None, None)),
  179|    274|            }
  180|    274|        }
  181|      3|        fn isEmpty(&self) -> B { self.length() == 0 }
  182|      3|        fn isSingleton(&self) -> B { self.length() == 1 }
  183|      2|        fn subseq_copy(&self, start: N, length: N) -> Self {
  184|      2|            let n = self.length();
  185|      2|            let s = start.min(n);
  186|      2|            let e = (start + length).min(n);
  187|      2|            if s >= e {
  188|      1|                return Self::empty();
  189|      1|            }
  190|      1|            let mut vals = Vec::with_capacity((e - s) as usize);
  191|      3|            for i in s..e {
                                   ^1 ^1
  192|      3|                vals.push(self.nth(i).clone());
  193|      3|            }
  194|      1|            Self::from_vec(vals)
  195|      2|        }
  196|    648|        fn from_vec(values: Vec<T>) -> Self {
  197|    648|            AVLTreeSeqMtPerS {
  198|    648|                root: build_balanced_from_slice(&values),
  199|    648|            }
  200|    648|        }
  201|    676|        fn values_in_order(&self) -> Vec<T> {
  202|    676|            let mut out = Vec::new();
  203|    676|            inorder_collect(&self.root, &mut out);
  204|    676|            out
  205|    676|        }
  206|       |    }
  207|       |
  208|       |    impl<T: StTInMtT> Clone for AVLTreeSeqMtPerS<T> {
  209|    642|        fn clone(&self) -> Self {
  210|    642|            AVLTreeSeqMtPerS {
  211|    642|                root: self.root.clone(),
  212|    642|            }
  213|    642|        }
  214|       |    }
  215|       |
  216|       |    impl<T: StTInMtT> Default for AVLTreeSeqMtPerS<T> {
  217|      0|        fn default() -> Self { Self::empty() }
  218|       |    }
  219|       |
  220|       |    // Iterator implementation
  221|       |    pub struct AVLTreeSeqMtPerIter<T: StTInMtT> {
  222|       |        values: Vec<T>,
  223|       |        index: usize,
  224|       |    }
  225|       |
  226|       |    impl<T: StTInMtT> Iterator for AVLTreeSeqMtPerIter<T> {
  227|       |        type Item = T;
  228|       |
  229|      4|        fn next(&mut self) -> Option<Self::Item> {
  230|      4|            if self.index < self.values.len() {
  231|      3|                let val = self.values[self.index].clone();
  232|      3|                self.index += 1;
  233|      3|                Some(val)
  234|       |            } else {
  235|      1|                None
  236|       |            }
  237|      4|        }
  238|       |    }
  239|       |
  240|       |    impl<T: StTInMtT> IntoIterator for AVLTreeSeqMtPerS<T> {
  241|       |        type Item = T;
  242|       |        type IntoIter = AVLTreeSeqMtPerIter<T>;
  243|       |
  244|      1|        fn into_iter(self) -> Self::IntoIter {
  245|      1|            AVLTreeSeqMtPerIter {
  246|      1|                values: self.values_in_order(),
  247|      1|                index: 0,
  248|      1|            }
  249|      1|        }
  250|       |    }
  251|       |
  252|       |    impl<T: StTInMtT> PartialEq for AVLTreeSeqMtPerS<T> {
  253|      2|        fn eq(&self, other: &Self) -> bool {
  254|      2|            if self.length() != other.length() {
  255|      0|                return false;
  256|      2|            }
  257|      6|            for i in 0..self.length() {
                                      ^2   ^2
  258|      6|                if self.nth(i) != other.nth(i) {
  259|      1|                    return false;
  260|      5|                }
  261|       |            }
  262|      1|            true
  263|      2|        }
  264|       |    }
  265|       |
  266|       |    impl<T: StTInMtT> Eq for AVLTreeSeqMtPerS<T> {}
  267|       |
  268|       |    impl<T: StTInMtT> Debug for AVLTreeSeqMtPerS<T> {
  269|      0|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  270|      0|            write!(f, "[")?;
  271|      0|            for i in 0..self.length() {
  272|      0|                if i > 0 {
  273|      0|                    write!(f, ", ")?;
  274|      0|                }
  275|      0|                write!(f, "{:?}", self.nth(i))?;
  276|       |            }
  277|      0|            write!(f, "]")
  278|      0|        }
  279|       |    }
  280|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap37/AVLTreeSeqStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! StEphemeral (mutable) implicit-order AVL tree sequence.
    3|       |
    4|       |pub mod AVLTreeSeqStEph {
    5|       |
    6|       |    use std::fmt::Debug;
    7|       |
    8|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
    9|       |    use crate::Types::Types::*;
   10|       |
   11|       |    type Link<T> = Option<Box<AVLTreeNode<T>>>;
   12|       |
   13|       |    #[derive(Clone)]
   14|       |    pub struct AVLTreeNode<T: StT> {
   15|       |        pub value: T,
   16|       |        pub height: N,
   17|       |        pub left_size: N,
   18|       |        pub right_size: N,
   19|       |        pub left: Link<T>,
   20|       |        pub right: Link<T>,
   21|       |        pub index: N,
   22|       |    }
   23|       |
   24|       |    impl<T: StT> AVLTreeNode<T> {
   25|  20.5M|        fn new(value: T, index: N) -> Self {
   26|  20.5M|            AVLTreeNode {
   27|  20.5M|                value,
   28|  20.5M|                height: 1,
   29|  20.5M|                left_size: 0,
   30|  20.5M|                right_size: 0,
   31|  20.5M|                left: None,
   32|  20.5M|                right: None,
   33|  20.5M|                index,
   34|  20.5M|            }
   35|  20.5M|        }
   36|       |    }
   37|       |
   38|       |    pub struct AVLTreeSeqStEphS<T: StT> {
   39|       |        pub root: Link<T>,
   40|       |        pub next_key: N,
   41|       |    }
   42|       |
   43|       |    pub trait AVLTreeSeqStEphTrait<T: StT> {
   44|       |        /// APAS: Work (1), Span (1).
   45|       |        /// claude-4-sonet: Work (1), Span (1).
   46|       |        fn empty() -> Self;
   47|       |        /// APAS: Work (1), Span (1).
   48|       |        fn new() -> Self;
   49|       |        /// APAS: Work (1), Span (1).
   50|       |        fn length(&self) -> N;
   51|       |        /// APAS: Work (lg(n)), Span (lg(n)).
   52|       |        fn nth(&self, index: N) -> &T;
   53|       |        /// APAS: Work (lg(n)), Span (lg(n)).
   54|       |        fn set(&mut self, index: N, item: T) -> Result<&mut Self, &'static str>;
   55|       |        /// APAS: Work (1), Span (1).
   56|       |        fn singleton(item: T) -> Self;
   57|       |        /// APAS: Work (1), Span (1).
   58|       |        fn isEmpty(&self) -> B;
   59|       |        /// APAS: Work (1), Span (1).
   60|       |        fn isSingleton(&self) -> B;
   61|       |        /// APAS: Work (1 + lg(|a|)), Span (1 + lg(|a|)).
   62|       |        fn subseq_copy(&self, start: N, length: N) -> Self;
   63|       |    }
   64|       |
   65|       |    impl<T: StT> AVLTreeSeqStEphS<T> {
   66|   578k|        pub fn new_root() -> Self {
   67|   578k|            AVLTreeSeqStEphS {
   68|   578k|                root: None,
   69|   578k|                next_key: 0,
   70|   578k|            }
   71|   578k|        }
   72|     11|        pub fn new() -> Self { Self::new_root() }
   73|      3|        pub fn update(&mut self, (index, item): (N, T)) -> &mut AVLTreeSeqStEphS<T> {
   74|      3|            let _ = self.set(index, item);
   75|      3|            self
   76|      3|        }
   77|   555k|        pub fn from_vec(values: Vec<T>) -> AVLTreeSeqStEphS<T> {
   78|   555k|            let length = values.len();
   79|   555k|            let mut t = AVLTreeSeqStEphS::new_root();
   80|  20.5M|            for (i, v) in values.into_iter().enumerate() {
                                        ^555k  ^555k       ^555k
   81|  20.5M|                t.root = insert_at_link(t.root.take(), i, v, &mut t.next_key);
   82|  20.5M|            }
   83|   555k|            debug_assert!(t.length() == length);
   84|   555k|            t
   85|   555k|        }
   86|     10|        pub fn to_arrayseq(&self) -> ArraySeqStEphS<T> {
   87|     10|            let len = self.length();
   88|     10|            if len == 0 {
   89|      1|                return ArraySeqStEphS::empty();
   90|      9|            }
   91|      9|            let mut it = self.iter();
   92|      9|            let first = it.next().expect("length > 0 but iter was empty").clone();
   93|      9|            let mut out = ArraySeqStEphS::new(len, first.clone());
   94|      9|            let _ = out.set(0, first);
   95|      9|            let mut index: N = 1;
   96|     38|            for v in it {
                              ^29
   97|     29|                let _ = out.set(index, v.clone());
   98|     29|                index += 1;
   99|     29|            }
  100|      9|            out
  101|     10|        }
  102|     31|        pub fn iter<'a>(&'a self) -> AVLTreeSeqIterStEph<'a, T> { AVLTreeSeqIterStEph::new(&self.root) }
  103|     89|        pub fn push_back(&mut self, value: T) {
  104|     89|            let len = self.length();
  105|     89|            let node = insert_at_link(self.root.take(), len, value, &mut self.next_key);
  106|     89|            self.root = node;
  107|     89|        }
  108|     10|        pub fn contains_value(&self, target: &T) -> B {
  109|     73|            for v in self.iter() {
                                   ^10  ^10
  110|     73|                if v == target {
  111|      4|                    return true;
  112|     69|                }
  113|       |            }
  114|      6|            false
  115|     10|        }
  116|      3|        pub fn insert_value(&mut self, value: T) { self.push_back(value); }
  117|      8|        pub fn delete_value(&mut self, target: &T) -> bool {
  118|      8|            let len = self.length();
  119|      8|            let mut found_index: Option<N> = None;
  120|     16|            for i in 0..len {
                                      ^8
  121|     16|                if self.nth(i) == target {
  122|      6|                    found_index = Some(i);
  123|      6|                    break;
  124|     10|                }
  125|       |            }
  126|      8|            if let Some(idx) = found_index {
                                      ^6
  127|      6|                let mut out_vec: Vec<T> = Vec::with_capacity(len - 1);
  128|      8|                for i in 0..idx {
                                          ^6
  129|      8|                    out_vec.push(self.nth(i).clone());
  130|      8|                }
  131|     37|                for i in (idx + 1)..len {
                                       ^6         ^6
  132|     37|                    out_vec.push(self.nth(i).clone());
  133|     37|                }
  134|      6|                *self = AVLTreeSeqStEphS::from_vec(out_vec);
  135|      6|                true
  136|       |            } else {
  137|      2|                false
  138|       |            }
  139|      8|        }
  140|       |    }
  141|       |
  142|       |    impl<T: StT> AVLTreeSeqStEphTrait<T> for AVLTreeSeqStEphS<T> {
  143|  11.3k|        fn empty() -> Self { AVLTreeSeqStEphS::new_root() }
  144|       |
  145|      0|        fn new() -> Self { AVLTreeSeqStEphS::new_root() }
  146|       |
  147|  1.69M|        fn length(&self) -> N { size_link(&self.root) }
  148|       |
  149|  40.6M|        fn nth(&self, index: N) -> &T { nth_link(&self.root, index) }
  150|       |
  151|     11|        fn set(&mut self, index: N, item: T) -> Result<&mut Self, &'static str> {
  152|     11|            set_link(&mut self.root, index, item)?;
                                                               ^2
  153|      9|            Ok(self)
  154|     11|        }
  155|       |
  156|  10.9k|        fn singleton(item: T) -> Self {
  157|  10.9k|            let mut t = AVLTreeSeqStEphS::new_root();
  158|  10.9k|            t.root = insert_at_link(t.root.take(), 0, item, &mut t.next_key);
  159|  10.9k|            t
  160|  10.9k|        }
  161|       |
  162|      6|        fn isEmpty(&self) -> B { if self.length() == 0 { true } else { false } }
                                                                       ^5            ^1
  163|       |
  164|      3|        fn isSingleton(&self) -> B { if self.length() == 1 { true } else { false } }
                                                                           ^1            ^2
  165|       |
  166|      6|        fn subseq_copy(&self, start: N, length: N) -> Self {
  167|      6|            let n = self.length();
  168|      6|            let s = start.min(n);
  169|      6|            let e = start.saturating_add(length).min(n);
  170|      6|            if e <= s {
  171|      2|                return AVLTreeSeqStEphS::empty();
  172|      4|            }
  173|      4|            let mut vals: Vec<T> = Vec::with_capacity(e - s);
  174|     12|            for i in s..e {
                                   ^4 ^4
  175|     12|                vals.push(self.nth(i).clone());
  176|     12|            }
  177|      4|            AVLTreeSeqStEphS::from_vec(vals)
  178|      6|        }
  179|       |    }
  180|       |
  181|       |    pub struct AVLTreeSeqIterStEph<'a, T: StT> {
  182|       |        stack: Vec<&'a AVLTreeNode<T>>,
  183|       |        current: Option<&'a AVLTreeNode<T>>,
  184|       |    }
  185|       |
  186|       |    impl<'a, T: StT> AVLTreeSeqIterStEph<'a, T> {
  187|     31|        fn new(root: &'a Link<T>) -> Self {
  188|     31|            let mut it = AVLTreeSeqIterStEph {
  189|     31|                stack: Vec::new(),
  190|     31|                current: None,
  191|     31|            };
  192|     31|            it.push_left(root);
  193|     31|            it
  194|     31|        }
  195|    191|        fn push_left(&mut self, link: &'a Link<T>) {
  196|    191|            let mut cursor = link;
  197|    356|            while let Some(ref node) = cursor.as_ref() {
                                         ^165
  198|    165|                self.stack.push(node);
  199|    165|                cursor = &node.left;
  200|    165|            }
  201|    191|        }
  202|       |    }
  203|       |
  204|       |    impl<'a, T: StT> Iterator for AVLTreeSeqIterStEph<'a, T> {
  205|       |        type Item = &'a T;
  206|    187|        fn next(&mut self) -> Option<Self::Item> {
  207|    187|            let node = self.stack.pop()?;
                              ^160                   ^27
  208|    160|            let value_ref: &T = &node.value;
  209|    160|            self.push_left(&node.right);
  210|    160|            Some(value_ref)
  211|    187|        }
  212|       |    }
  213|       |
  214|   530M|    fn h<T: StT>(n: &Link<T>) -> N { n.as_ref().map_or(0, |b| b.height) }
  215|       |
  216|   302M|    fn size_link<T: StT>(n: &Link<T>) -> N {
  217|   302M|        if let Some(b) = n {
                                  ^232M
  218|   232M|            1 + b.left_size + b.right_size
  219|       |        } else {
  220|  69.4M|            0
  221|       |        }
  222|   302M|    }
  223|       |
  224|   150M|    fn update_meta<T: StT>(n: &mut Box<AVLTreeNode<T>>) {
  225|   150M|        n.left_size = size_link(&n.left);
  226|   150M|        n.right_size = size_link(&n.right);
  227|   150M|        let hl = h(&n.left);
  228|   150M|        let hr = h(&n.right);
  229|   150M|        n.height = 1 + hl.max(hr);
  230|   150M|    }
  231|       |
  232|      0|    fn rotate_right<T: StT>(mut y: Box<AVLTreeNode<T>>) -> Box<AVLTreeNode<T>> {
  233|      0|        let mut x = y.left.take().expect("rotate_right requires left child");
  234|      0|        let t2 = x.right.take();
  235|      0|        y.left = t2;
  236|      0|        update_meta(&mut y);
  237|      0|        x.right = Some(y);
  238|      0|        update_meta(x.right.as_mut().unwrap());
  239|      0|        update_meta(&mut x);
  240|      0|        x
  241|      0|    }
  242|       |
  243|  17.6M|    fn rotate_left<T: StT>(mut x: Box<AVLTreeNode<T>>) -> Box<AVLTreeNode<T>> {
  244|  17.6M|        let mut y = x.right.take().expect("rotate_left requires right child");
  245|  17.6M|        let t2 = y.left.take();
  246|  17.6M|        x.right = t2;
  247|  17.6M|        update_meta(&mut x);
  248|  17.6M|        y.left = Some(x);
  249|  17.6M|        update_meta(y.left.as_mut().unwrap());
  250|  17.6M|        update_meta(&mut y);
  251|  17.6M|        y
  252|  17.6M|    }
  253|       |
  254|  97.2M|    fn rebalance<T: StT>(mut n: Box<AVLTreeNode<T>>) -> Box<AVLTreeNode<T>> {
  255|  97.2M|        update_meta(&mut n);
  256|  97.2M|        let hl = h(&n.left);
  257|  97.2M|        let hr = h(&n.right);
  258|  97.2M|        if hl > hr.saturating_add(1) {
  259|      0|            if h(&n.left.as_ref().unwrap().right) > h(&n.left.as_ref().unwrap().left) {
  260|      0|                let left = n.left.take().unwrap();
  261|      0|                n.left = Some(rotate_left(left));
  262|      0|            }
  263|      0|            return rotate_right(n);
  264|  97.2M|        }
  265|  97.2M|        if hr > hl.saturating_add(1) {
  266|  17.6M|            if h(&n.right.as_ref().unwrap().left) > h(&n.right.as_ref().unwrap().right) {
  267|      0|                let right = n.right.take().unwrap();
  268|      0|                n.right = Some(rotate_right(right));
  269|  17.6M|            }
  270|  17.6M|            return rotate_left(n);
  271|  79.5M|        }
  272|  79.5M|        n
  273|  97.2M|    }
  274|       |
  275|   117M|    pub(crate) fn insert_at_link<T: StT>(node: Link<T>, index: N, value: T, next_key: &mut N) -> Link<T> {
  276|   117M|        match node {
  277|       |            | None => {
  278|  20.5M|                debug_assert!(index == 0, "insert_at_link reached None with index > 0");
                                                        ^0
  279|  20.5M|                let key = *next_key;
  280|  20.5M|                *next_key += 1;
  281|  20.5M|                Some(Box::new(AVLTreeNode::new(value, key)))
  282|       |            }
  283|  97.2M|            | Some(mut n) => {
  284|  97.2M|                let left_size = n.left_size;
  285|  97.2M|                if index <= left_size {
  286|      0|                    n.left = insert_at_link(n.left.take(), index, value, next_key);
  287|  97.2M|                } else {
  288|  97.2M|                    n.right = insert_at_link(n.right.take(), index - left_size - 1, value, next_key);
  289|  97.2M|                }
  290|  97.2M|                Some(rebalance(n))
  291|       |            }
  292|       |        }
  293|   117M|    }
  294|       |
  295|   197M|    fn nth_link<'a, T: StT>(node: &'a Link<T>, index: N) -> &'a T {
  296|   197M|        let n = node.as_ref().expect("index out of bounds");
  297|   197M|        let left_size = n.left_size;
  298|   197M|        if index < left_size {
  299|  75.9M|            return nth_link(&n.left, index);
  300|   121M|        }
  301|   121M|        if index == left_size {
  302|  40.6M|            return &n.value;
  303|  80.9M|        }
  304|  80.9M|        nth_link(&n.right, index - left_size - 1)
  305|   197M|    }
  306|       |
  307|     35|    fn set_link<T: StT>(node: &mut Link<T>, index: N, value: T) -> Result<(), &'static str> {
  308|     35|        match node {
  309|      2|            | None => Err("Index out of bounds"),
  310|     33|            | Some(n) => {
  311|     33|                let left_size = n.left_size;
  312|     33|                if index < left_size {
  313|      9|                    set_link(&mut n.left, index, value)
  314|     24|                } else if index == left_size {
  315|      9|                    n.value = value;
  316|      9|                    Ok(())
  317|       |                } else {
  318|     15|                    set_link(&mut n.right, index - left_size - 1, value)
  319|       |                }
  320|       |            }
  321|       |        }
  322|     35|    }
  323|       |
  324|       |    #[macro_export]
  325|       |    macro_rules! AVLTreeSeqStEphLit {
  326|       |        () => { $crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::AVLTreeSeqStEphS::from_vec(Vec::new()) };
  327|       |        ($x:expr; $n:expr) => {{
  328|       |            let mut t = $crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::AVLTreeSeqStEphS::from_vec(Vec::new());
  329|       |            for _ in 0..$n { t.push_back($x); }
  330|       |            t
  331|       |        }};
  332|       |        ($($x:expr),* $(,)?) => {{
  333|       |            let mut t = $crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::AVLTreeSeqStEphS::from_vec(Vec::new());
  334|       |            $( { t.push_back($x); } )*
  335|       |            t
  336|       |        }};
  337|       |    }
  338|       |
  339|       |    impl<T: StT> PartialEq for AVLTreeSeqStEphS<T> {
  340|      4|        fn eq(&self, other: &Self) -> bool {
  341|      4|            if self.length() != other.length() {
  342|      1|                return false;
  343|      3|            }
  344|     10|            for i in 0..self.length() {
                                      ^3   ^3
  345|     10|                if self.nth(i) != other.nth(i) {
  346|      1|                    return false;
  347|      9|                }
  348|       |            }
  349|      2|            true
  350|      4|        }
  351|       |    }
  352|       |
  353|       |    impl<T: StT> Eq for AVLTreeSeqStEphS<T> {}
  354|       |
  355|       |    impl<T: StT> Clone for AVLTreeSeqStEphS<T> {
  356|    233|        fn clone(&self) -> Self {
  357|    233|            AVLTreeSeqStEphS {
  358|    233|                root: self.root.clone(),
  359|    233|                next_key: self.next_key,
  360|    233|            }
  361|    233|        }
  362|       |    }
  363|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap37/AVLTreeSeqStPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! StPer (immutable, structurally shared) AVL tree sequence using Rc path-copying.
    3|       |
    4|       |pub mod AVLTreeSeqStPer {
    5|       |
    6|       |    use std::fmt::Debug;
    7|       |    use std::rc::Rc;
    8|       |
    9|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    type Link<T> = Option<Rc<Node<T>>>;
   13|       |
   14|       |    struct Node<T: StT> {
   15|       |        value: T,
   16|       |        height: N,
   17|       |        size: N,
   18|       |        left: Link<T>,
   19|       |        right: Link<T>,
   20|       |    }
   21|       |
   22|  2.47M|    fn height<T: StT>(n: &Link<T>) -> N { n.as_ref().map_or(0, |r| r.height) }
                                                                                 ^1.19M
   23|  13.8M|    fn size<T: StT>(n: &Link<T>) -> N { n.as_ref().map_or(0, |r| r.size) }
                                                                               ^11.5M
   24|       |
   25|  1.23M|    fn mk<T: StT>(value: T, left: Link<T>, right: Link<T>) -> Rc<Node<T>> {
   26|  1.23M|        let hl = height(&left);
   27|  1.23M|        let hr = height(&right);
   28|  1.23M|        let sz = 1 + size(&left) + size(&right);
   29|  1.23M|        Rc::new(Node {
   30|  1.23M|            value,
   31|  1.23M|            height: 1 + hl.max(hr),
   32|  1.23M|            size: sz,
   33|  1.23M|            left,
   34|  1.23M|            right,
   35|  1.23M|        })
   36|  1.23M|    }
   37|       |
   38|      0|    fn rotate_right<T: StT>(y: Rc<Node<T>>) -> Rc<Node<T>> {
   39|      0|        let x = y.left.as_ref().expect("rotate_right requires left").clone();
   40|      0|        let t2 = x.right.clone();
   41|      0|        let new_y = mk(y.value.clone(), t2.clone(), y.right.clone());
   42|      0|        mk(x.value.clone(), x.left.clone(), Some(new_y))
   43|      0|    }
   44|       |
   45|      0|    fn rotate_left<T: StT>(x: Rc<Node<T>>) -> Rc<Node<T>> {
   46|      0|        let y = x.right.as_ref().expect("rotate_left requires right").clone();
   47|      0|        let t2 = y.left.clone();
   48|      0|        let new_x = mk(x.value.clone(), x.left.clone(), t2.clone());
   49|      0|        mk(y.value.clone(), Some(new_x), y.right.clone())
   50|      0|    }
   51|       |
   52|     37|    fn rebalance<T: StT>(n: Rc<Node<T>>) -> Rc<Node<T>> {
   53|     37|        let hl = height(&n.left);
   54|     37|        let hr = height(&n.right);
   55|     37|        if hl > hr.saturating_add(1) {
   56|      0|            let left = n.left.as_ref().unwrap().clone();
   57|      0|            if height(&left.right) > height(&left.left) {
   58|      0|                let rotated = rotate_left(left);
   59|      0|                return rotate_right(mk(n.value.clone(), Some(rotated), n.right.clone()));
   60|      0|            }
   61|      0|            return rotate_right(n);
   62|     37|        }
   63|     37|        if hr > hl.saturating_add(1) {
   64|      0|            let right = n.right.as_ref().unwrap().clone();
   65|      0|            if height(&right.left) > height(&right.right) {
   66|      0|                let rotated = rotate_right(right);
   67|      0|                return rotate_left(mk(n.value.clone(), n.left.clone(), Some(rotated)));
   68|      0|            }
   69|      0|            return rotate_left(n);
   70|     37|        }
   71|     37|        n
   72|     37|    }
   73|       |
   74|  2.39M|    fn nth_ref<'a, T: StT>(mut cur: &'a Link<T>, mut index: N) -> &'a T {
   75|       |        loop {
   76|  11.2M|            let node = cur.as_ref().expect("index out of bounds");
   77|  11.2M|            let ls = size(&node.left);
   78|  11.2M|            if index < ls {
   79|  4.84M|                cur = &node.left;
   80|  6.41M|            } else if index == ls {
   81|  2.39M|                return &node.value;
   82|  4.01M|            } else {
   83|  4.01M|                index -= ls + 1;
   84|  4.01M|                cur = &node.right;
   85|  4.01M|            }
   86|       |        }
   87|  2.39M|    }
   88|       |
   89|     67|    fn set_rec<T: StT>(cur: &Link<T>, index: N, value: T) -> Result<Link<T>, &'static str> {
   90|     67|        match cur {
   91|       |            | None => {
   92|       |                // Allow setting at index 0 on empty tree (append to empty)
   93|      1|                if index == 0 {
   94|      0|                    Ok(Some(mk(value, None, None)))
   95|       |                } else {
   96|      1|                    Err("Index out of bounds")
   97|       |                }
   98|       |            }
   99|     66|            | Some(n) => {
  100|     66|                let ls = size(&n.left);
  101|     66|                if index < ls {
  102|     23|                    let new_left = set_rec(&n.left, index, value)?;
                                                                               ^0
  103|     23|                    Ok(Some(rebalance(mk(n.value.clone(), new_left, n.right.clone()))))
  104|     43|                } else if index == ls {
  105|     27|                    Ok(Some(mk(value, n.left.clone(), n.right.clone())))
  106|       |                } else {
  107|     16|                    let new_right = set_rec(&n.right, index - ls - 1, value)?;
                                      ^14                                                 ^2
  108|     14|                    Ok(Some(rebalance(mk(n.value.clone(), n.left.clone(), new_right))))
  109|       |                }
  110|       |            }
  111|       |        }
  112|     67|    }
  113|       |
  114|  15.4k|    fn inorder_collect<T: StT>(cur: &Link<T>, out: &mut Vec<T>) {
  115|  15.4k|        if let Some(n) = cur {
                                  ^7.45k
  116|  7.45k|            inorder_collect(&n.left, out);
  117|  7.45k|            out.push(n.value.clone());
  118|  7.45k|            inorder_collect(&n.right, out);
  119|  8.01k|        }
  120|  15.4k|    }
  121|       |
  122|  39.5k|    fn build_balanced_from_slice<T: StT>(a: &[T]) -> Link<T> {
  123|  2.51M|        fn rec<T: StT>(a: &[T]) -> Link<T> {
  124|  2.51M|            if a.is_empty() {
  125|  1.27M|                return None;
  126|  1.23M|            }
  127|  1.23M|            let mid = a.len() / 2;
  128|  1.23M|            let left = rec(&a[..mid]);
  129|  1.23M|            let right = rec(&a[mid + 1..]);
  130|  1.23M|            Some(mk(a[mid].clone(), left, right))
  131|  2.51M|        }
  132|  39.5k|        rec(a)
  133|  39.5k|    }
  134|       |
  135|       |    pub struct AVLTreeSeqStPerS<T: StT> {
  136|       |        root: Link<T>,
  137|       |    }
  138|       |
  139|       |    pub trait AVLTreeSeqStPerTrait<T: StT> {
  140|       |        /// APAS: Work (1), Span (1)
  141|       |        /// claude-4-sonet: Work (1), Span (1)
  142|       |        fn empty() -> Self;
  143|       |        /// APAS: Work (1), Span (1)
  144|       |        fn new() -> Self;
  145|       |        /// APAS: Work (1), Span (1)
  146|       |        fn length(&self) -> N;
  147|       |        /// APAS: Work (lg(n)), Span (lg(n))
  148|       |        fn nth(&self, index: N) -> &T;
  149|       |        /// APAS (ephemeral set (lg n)); StPer path-copy (lg n) allocations. Work (lg n), Span (lg n)
  150|       |        fn set(&self, index: N, item: T) -> Result<Self, &'static str>
  151|       |        where
  152|       |            Self: Sized;
  153|       |        /// APAS: Work (1), Span (1)
  154|       |        fn singleton(item: T) -> Self;
  155|       |        /// APAS: Work (1), Span (1)
  156|       |        fn isEmpty(&self) -> B;
  157|       |        /// APAS: Work (1), Span (1)
  158|       |        fn isSingleton(&self) -> B;
  159|       |        /// APAS: Work (1 + lg|a|), Span (1 + lg|a|)
  160|       |        fn subseq_copy(&self, start: N, length: N) -> Self;
  161|       |        /// Build balanced tree from values in in-order order.
  162|       |        fn from_vec(values: Vec<T>) -> Self;
  163|       |        /// Collect in-order values to Vec.
  164|       |        fn values_in_order(&self) -> Vec<T>;
  165|       |    }
  166|       |
  167|       |    impl<T: StT> AVLTreeSeqStPerTrait<T> for AVLTreeSeqStPerS<T> {
  168|  2.82k|        fn empty() -> Self { AVLTreeSeqStPerS { root: None } }
  169|      0|        fn new() -> Self { Self::empty() }
  170|  83.0k|        fn length(&self) -> N { size(&self.root) }
  171|  2.39M|        fn nth(&self, index: N) -> &T { nth_ref(&self.root, index) }
  172|     28|        fn set(&self, index: N, item: T) -> Result<Self, &'static str> {
  173|       |            Ok(AVLTreeSeqStPerS {
  174|     28|                root: set_rec(&self.root, index, item)?,
                                                                    ^1
  175|       |            })
  176|     28|        }
  177|  1.85k|        fn singleton(item: T) -> Self {
  178|  1.85k|            AVLTreeSeqStPerS {
  179|  1.85k|                root: Some(mk(item, None, None)),
  180|  1.85k|            }
  181|  1.85k|        }
  182|      4|        fn isEmpty(&self) -> B { if self.length() == 0 { true } else { false } }
                                                                       ^3            ^1
  183|      2|        fn isSingleton(&self) -> B { if self.length() == 1 { true } else { false } }
                                                                           ^1            ^1
  184|     24|        fn subseq_copy(&self, start: N, length: N) -> Self {
  185|     24|            let n = self.length();
  186|     24|            let s = start.min(n);
  187|     24|            let e = start.saturating_add(length).min(n);
  188|     24|            if e <= s {
  189|      3|                return Self::empty();
  190|     21|            }
  191|     21|            let mut vals: Vec<T> = Vec::with_capacity(e - s);
  192|     21|            let all = self.values_in_order();
  193|     72|            for i in s..e {
                                   ^21^21
  194|     72|                vals.push(all[i as usize].clone());
  195|     72|            }
  196|     21|            Self::from_vec(vals)
  197|     24|        }
  198|  39.5k|        fn from_vec(values: Vec<T>) -> Self {
  199|  39.5k|            AVLTreeSeqStPerS {
  200|  39.5k|                root: build_balanced_from_slice(&values[..]),
  201|  39.5k|            }
  202|  39.5k|        }
  203|    563|        fn values_in_order(&self) -> Vec<T> {
  204|    563|            let mut out = Vec::with_capacity(self.length());
  205|    563|            inorder_collect(&self.root, &mut out);
  206|    563|            out
  207|    563|        }
  208|       |    }
  209|       |
  210|       |    impl<T: StT> PartialEq for AVLTreeSeqStPerS<T> {
  211|      6|        fn eq(&self, other: &Self) -> bool {
  212|      6|            if self.length() != other.length() {
  213|      0|                return false;
  214|      6|            }
  215|     25|            for i in 0..self.length() {
                                      ^6   ^6
  216|     25|                if self.nth(i) != other.nth(i) {
  217|      1|                    return false;
  218|     24|                }
  219|       |            }
  220|      5|            true
  221|      6|        }
  222|       |    }
  223|       |    impl<T: StT> Eq for AVLTreeSeqStPerS<T> {}
  224|       |
  225|       |    impl<T: StT> Clone for AVLTreeSeqStPerS<T> {
  226|  5.81k|        fn clone(&self) -> Self {
  227|  5.81k|            AVLTreeSeqStPerS {
  228|  5.81k|                root: self.root.clone(),
  229|  5.81k|            }
  230|  5.81k|        }
  231|       |    }
  232|       |
  233|       |    impl<T: StT> std::fmt::Debug for AVLTreeSeqStPerS<T> {
  234|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  235|      1|            let v = self.values_in_order();
  236|      1|            f.debug_list().entries(v.iter()).finish()
  237|      1|        }
  238|       |    }
  239|       |
  240|       |    impl<T: StT> AVLTreeSeqStPerS<T> {
  241|      5|        pub fn to_arrayseq(&self) -> ArraySeqStPerS<T> {
  242|      5|            let v = self.values_in_order();
  243|      5|            ArraySeqStPerS::from_vec(v)
  244|      5|        }
  245|       |
  246|      1|        pub fn iter<'a>(&'a self) -> AVLTreeSeqStPerIter<'a, T> {
  247|      1|            AVLTreeSeqStPerIter {
  248|      1|                stack: Vec::new(),
  249|      1|                current: self.root.as_deref(),
  250|      1|            }
  251|      1|        }
  252|       |    }
  253|       |
  254|       |    pub struct AVLTreeSeqStPerIter<'a, T: StT> {
  255|       |        stack: Vec<&'a Node<T>>,
  256|       |        current: Option<&'a Node<T>>,
  257|       |    }
  258|       |
  259|       |    impl<'a, T: StT> AVLTreeSeqStPerIter<'a, T> {
  260|      6|        fn push_left(&mut self, mut cur: Option<&'a Node<T>>) {
  261|     11|            while let Some(n) = cur {
                                         ^5
  262|      5|                self.stack.push(n);
  263|      5|                cur = n.left.as_deref();
  264|      5|            }
  265|      6|        }
  266|       |    }
  267|       |
  268|       |    impl<'a, T: StT> Iterator for AVLTreeSeqStPerIter<'a, T> {
  269|       |        type Item = &'a T;
  270|      6|        fn next(&mut self) -> Option<Self::Item> {
  271|      6|            if self.current.is_some() {
  272|      1|                let cur = self.current.take();
  273|      1|                self.push_left(cur);
  274|      5|            }
  275|      6|            let node = self.stack.pop()?;
                              ^5                     ^1
  276|      5|            let value_ref: &T = &node.value;
  277|      5|            self.push_left(node.right.as_deref());
  278|      5|            Some(value_ref)
  279|      6|        }
  280|       |    }
  281|       |}
  282|       |
  283|       |#[macro_export]
  284|       |macro_rules! AVLTreeSeqStPerLit {
  285|       |    () => { < $crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::AVLTreeSeqStPerS<_> as
  286|       |              $crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::AVLTreeSeqStPerTrait<_> >::empty() };
  287|       |    ($x:expr; $n:expr) => {{
  288|       |        let __vals = vec![$x; $n];
  289|       |        < $crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::AVLTreeSeqStPerS<_> as
  290|       |          $crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::AVLTreeSeqStPerTrait<_> >::from_vec(__vals)
  291|       |    }};
  292|       |    ($($x:expr),* $(,)?) => {{
  293|       |        let __vals = vec![$($x),*];
  294|       |        < $crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::AVLTreeSeqStPerS<_> as
  295|       |          $crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::AVLTreeSeqStPerTrait<_> >::from_vec(__vals)
  296|       |    }};
  297|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap37/BSTAVLMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Ephemeral AVL-balanced binary search tree with interior locking for multi-threaded access.
    3|       |
    4|       |pub mod BSTAVLMtEph {
    5|       |
    6|       |    use std::sync::{Arc, RwLock};
    7|       |
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    type Link<T> = Option<Box<Node<T>>>;
   13|       |
   14|       |    #[derive(Debug, Clone)]
   15|       |    struct Node<T: StTInMtT + Ord> {
   16|       |        key: T,
   17|       |        height: i32,
   18|       |        size: N,
   19|       |        left: Link<T>,
   20|       |        right: Link<T>,
   21|       |    }
   22|       |
   23|       |    impl<T: StTInMtT + Ord> Node<T> {
   24|  1.59k|        fn new(key: T) -> Self {
   25|  1.59k|            Node {
   26|  1.59k|                key,
   27|  1.59k|                height: 1,
   28|  1.59k|                size: 1,
   29|  1.59k|                left: None,
   30|  1.59k|                right: None,
   31|  1.59k|            }
   32|  1.59k|        }
   33|       |    }
   34|       |
   35|       |    #[derive(Debug, Clone)]
   36|       |    pub struct BSTAVLMtEph<T: StTInMtT + Ord> {
   37|       |        root: Arc<RwLock<Link<T>>>,
   38|       |    }
   39|       |
   40|       |    pub type BSTreeAVL<T> = BSTAVLMtEph<T>;
   41|       |
   42|       |    pub trait BSTAVLMtEphTrait<T: StTInMtT + Ord>: Sized {
   43|       |        /// claude-4-sonet: Work (1), Span (1)
   44|       |        fn new() -> Self;
   45|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   46|       |        fn insert(&self, value: T);
   47|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   48|       |        fn find(&self, target: &T) -> Option<T>;
   49|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   50|       |        fn contains(&self, target: &T) -> B;
   51|       |        /// claude-4-sonet: Work (1), Span (1)
   52|       |        fn size(&self) -> N;
   53|       |        /// claude-4-sonet: Work (1), Span (1)
   54|       |        fn is_empty(&self) -> B;
   55|       |        /// claude-4-sonet: Work (n), Span (n)
   56|       |        fn height(&self) -> N;
   57|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   58|       |        fn minimum(&self) -> Option<T>;
   59|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   60|       |        fn maximum(&self) -> Option<T>;
   61|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   62|       |        fn pre_order(&self) -> ArraySeqStPerS<T>;
   63|       |    }
   64|       |
   65|       |    impl<T: StTInMtT + Ord> Default for BSTAVLMtEph<T> {
   66|      1|        fn default() -> Self { Self::new() }
   67|       |    }
   68|       |
   69|       |    impl<T: StTInMtT + Ord> BSTAVLMtEph<T> {
   70|       |        // Private helper methods only - no public delegation
   71|       |
   72|  62.2k|        fn height_link(link: &Link<T>) -> i32 { link.as_ref().map_or(0, |n| n.height) }
   73|       |
   74|   240k|        fn size_link(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }
   75|       |
   76|  20.8k|        fn update(node: &mut Node<T>) {
   77|  20.8k|            node.height = 1 + Self::height_link(&node.left).max(Self::height_link(&node.right));
   78|  20.8k|            node.size = 1 + Self::size_link(&node.left) + Self::size_link(&node.right);
   79|  20.8k|        }
   80|       |
   81|    140|        fn rotate_right(link: &mut Link<T>) {
   82|    140|            if let Some(mut y) = link.take() {
   83|    140|                if let Some(mut x) = y.left.take() {
   84|    140|                    y.left = x.right.take();
   85|    140|                    Self::update(&mut y);
   86|    140|                    Self::update(&mut x);
   87|    140|                    x.right = Some(y);
   88|    140|                    *link = Some(x);
   89|    140|                } else {
   90|      0|                    *link = Some(y);
   91|      0|                }
   92|      0|            }
   93|    140|        }
   94|       |
   95|  1.16k|        fn rotate_left(link: &mut Link<T>) {
   96|  1.16k|            if let Some(mut x) = link.take() {
   97|  1.16k|                if let Some(mut y) = x.right.take() {
   98|  1.16k|                    x.right = y.left.take();
   99|  1.16k|                    Self::update(&mut x);
  100|  1.16k|                    Self::update(&mut y);
  101|  1.16k|                    y.left = Some(x);
  102|  1.16k|                    *link = Some(y);
  103|  1.16k|                } else {
  104|      0|                    *link = Some(x);
  105|      0|                }
  106|      0|            }
  107|  1.16k|        }
  108|       |
  109|  9.10k|        fn rebalance(link: &mut Link<T>) {
  110|  9.10k|            if let Some(node) = link.as_mut() {
  111|  9.10k|                Self::update(node);
  112|  9.10k|                let bf = Self::height_link(&node.left) - Self::height_link(&node.right);
  113|  9.10k|                if bf > 1 {
  114|    125|                    if let Some(left) = node.left.as_mut() {
  115|    125|                        if Self::height_link(&left.right) > Self::height_link(&left.left) {
  116|    115|                            Self::rotate_left(&mut node.left);
  117|    115|                        }
                                      ^10
  118|      0|                    }
  119|    125|                    Self::rotate_right(link);
  120|  8.98k|                } else if bf < -1 {
  121|  1.04k|                    if let Some(right) = node.right.as_mut() {
  122|  1.04k|                        if Self::height_link(&right.left) > Self::height_link(&right.right) {
  123|     15|                            Self::rotate_right(&mut node.right);
  124|  1.03k|                        }
  125|      0|                    }
  126|  1.04k|                    Self::rotate_left(link);
  127|  7.93k|                }
  128|      0|            }
  129|  9.10k|            if let Some(node) = link.as_mut() {
  130|  9.10k|                Self::update(node);
  131|  9.10k|            }
                          ^0
  132|  9.10k|        }
  133|       |
  134|  10.7k|        fn insert_link(link: &mut Link<T>, value: T) {
  135|  10.7k|            match link {
  136|  9.19k|                | Some(node) => {
  137|  9.19k|                    if value < node.key {
  138|  1.74k|                        Self::insert_link(&mut node.left, value);
  139|  7.44k|                    } else if value > node.key {
  140|  7.36k|                        Self::insert_link(&mut node.right, value);
  141|  7.36k|                    } else {
  142|     81|                        return;
  143|       |                    }
  144|       |                }
  145|       |                | None => {
  146|  1.59k|                    *link = Some(Box::new(Node::new(value)));
  147|  1.59k|                    return;
  148|       |                }
  149|       |            }
  150|  9.10k|            Self::rebalance(link);
  151|  10.7k|        }
  152|       |
  153|  1.83M|        fn find_link<'a>(link: &'a Link<T>, target: &T) -> Option<&'a T> {
  154|  1.83M|            match link {
  155|   198k|                | None => None,
  156|  1.63M|                | Some(node) => {
  157|  1.63M|                    if target == &node.key {
  158|    139|                        Some(&node.key)
  159|  1.63M|                    } else if target < &node.key {
  160|   597k|                        Self::find_link(&node.left, target)
  161|       |                    } else {
  162|  1.03M|                        Self::find_link(&node.right, target)
  163|       |                    }
  164|       |                }
  165|       |            }
  166|  1.83M|        }
  167|       |
  168|  2.48k|        fn min_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  169|  2.48k|            match link {
  170|      4|                | None => None,
  171|  2.47k|                | Some(node) => match &node.left {
  172|    427|                    | None => Some(&node.key),
  173|  2.05k|                    | Some(_) => Self::min_link(&node.left),
  174|       |                },
  175|       |            }
  176|  2.48k|        }
  177|       |
  178|  3.25k|        fn max_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  179|  3.25k|            match link {
  180|      4|                | None => None,
  181|  3.25k|                | Some(node) => match &node.right {
  182|    427|                    | None => Some(&node.key),
  183|  2.82k|                    | Some(_) => Self::max_link(&node.right),
  184|       |                },
  185|       |            }
  186|  3.25k|        }
  187|       |
  188|    688|        fn in_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  189|    688|            if let Some(node) = link {
                                      ^305
  190|    305|                Self::in_order_collect(&node.left, out);
  191|    305|                out.push(node.key.clone());
  192|    305|                Self::in_order_collect(&node.right, out);
  193|    383|            }
  194|    688|        }
  195|       |
  196|      7|        fn pre_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  197|      7|            if let Some(node) = link {
                                      ^3
  198|      3|                out.push(node.key.clone());
  199|      3|                Self::pre_order_collect(&node.left, out);
  200|      3|                Self::pre_order_collect(&node.right, out);
  201|      4|            }
  202|      7|        }
  203|       |    }
  204|       |
  205|       |    impl<T: StTInMtT + Ord> BSTAVLMtEphTrait<T> for BSTAVLMtEph<T> {
  206|    145|        fn new() -> Self {
  207|    145|            BSTAVLMtEph {
  208|    145|                root: Arc::new(RwLock::new(None)),
  209|    145|            }
  210|    145|        }
  211|       |
  212|  1.67k|        fn insert(&self, value: T) {
  213|  1.67k|            let mut guard = self.root.write().unwrap();
  214|  1.67k|            Self::insert_link(&mut *guard, value);
  215|  1.67k|        }
  216|       |
  217|   198k|        fn find(&self, target: &T) -> Option<T> {
  218|   198k|            let guard = self.root.read().unwrap();
  219|   198k|            Self::find_link(&*guard, target).cloned()
  220|   198k|        }
  221|       |
  222|   198k|        fn contains(&self, target: &T) -> B { self.find(target).is_some() }
  223|       |
  224|   198k|        fn size(&self) -> N {
  225|   198k|            let guard = self.root.read().unwrap();
  226|   198k|            Self::size_link(&*guard)
  227|   198k|        }
  228|       |
  229|     10|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
                                                                      ^7            ^3
  230|       |
  231|     16|        fn height(&self) -> N {
  232|     16|            let guard = self.root.read().unwrap();
  233|     16|            Self::height_link(&*guard) as N
  234|     16|        }
  235|       |
  236|    431|        fn minimum(&self) -> Option<T> {
  237|    431|            let guard = self.root.read().unwrap();
  238|    431|            Self::min_link(&*guard).cloned()
  239|    431|        }
  240|       |
  241|    431|        fn maximum(&self) -> Option<T> {
  242|    431|            let guard = self.root.read().unwrap();
  243|    431|            Self::max_link(&*guard).cloned()
  244|    431|        }
  245|       |
  246|     78|        fn in_order(&self) -> ArraySeqStPerS<T> {
  247|     78|            let guard = self.root.read().unwrap();
  248|     78|            let mut out = Vec::with_capacity(Self::size_link(&*guard));
  249|     78|            Self::in_order_collect(&*guard, &mut out);
  250|     78|            ArraySeqStPerS::from_vec(out)
  251|     78|        }
  252|       |
  253|      1|        fn pre_order(&self) -> ArraySeqStPerS<T> {
  254|      1|            let guard = self.root.read().unwrap();
  255|      1|            let mut out = Vec::with_capacity(Self::size_link(&*guard));
  256|      1|            Self::pre_order_collect(&*guard, &mut out);
  257|      1|            ArraySeqStPerS::from_vec(out)
  258|      1|        }
  259|       |    }
  260|       |
  261|       |    #[macro_export]
  262|       |    macro_rules! BSTAVLMtEphLit {
  263|       |        () => {
  264|       |            < $crate::Chap37::BSTAVLMtEph::BSTAVLMtEph::BSTAVLMtEph<_> as $crate::Chap37::BSTAVLMtEph::BSTAVLMtEph::BSTAVLMtEphTrait<_> >::new()
  265|       |        };
  266|       |        ( $( $x:expr ),* $(,)? ) => {{
  267|       |            let __tree = < $crate::Chap37::BSTAVLMtEph::BSTAVLMtEph::BSTAVLMtEph<_> as $crate::Chap37::BSTAVLMtEph::BSTAVLMtEph::BSTAVLMtEphTrait<_> >::new();
  268|       |            $( __tree.insert($x); )*
  269|       |            __tree
  270|       |        }};
  271|       |    }
  272|       |
  273|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap37/BSTAVLStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Ephemeral AVL-balanced binary search tree with `find` support and public traversal helpers.
    3|       |
    4|       |pub mod BSTAVLStEph {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    8|       |    use crate::Types::Types::*;
    9|       |
   10|       |    type Link<T> = Option<Box<Node<T>>>;
   11|       |
   12|       |    #[derive(Clone, Debug)]
   13|       |    struct Node<T: StT + Ord> {
   14|       |        key: T,
   15|       |        height: i32,
   16|       |        size: N,
   17|       |        left: Link<T>,
   18|       |        right: Link<T>,
   19|       |    }
   20|       |
   21|       |    impl<T: StT + Ord> Node<T> {
   22|    204|        fn new(key: T) -> Self {
   23|    204|            Node {
   24|    204|                key,
   25|    204|                height: 1,
   26|    204|                size: 1,
   27|    204|                left: None,
   28|    204|                right: None,
   29|    204|            }
   30|    204|        }
   31|       |    }
   32|       |
   33|       |    #[derive(Debug, Clone)]
   34|       |    pub struct BSTAVLStEph<T: StT + Ord> {
   35|       |        root: Link<T>,
   36|       |    }
   37|       |
   38|       |    pub type BSTreeAVL<T> = BSTAVLStEph<T>;
   39|       |
   40|       |    pub trait BSTAVLStEphTrait<T: StT + Ord> {
   41|       |        /// claude-4-sonet: Work (1), Span (1)
   42|       |        fn new() -> Self;
   43|       |        /// claude-4-sonet: Work (1), Span (1)
   44|       |        fn size(&self) -> N;
   45|       |        /// claude-4-sonet: Work (1), Span (1)
   46|       |        fn is_empty(&self) -> B;
   47|       |        /// claude-4-sonet: Work (n), Span (n)
   48|       |        fn height(&self) -> N;
   49|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   50|       |        fn insert(&mut self, value: T);
   51|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   52|       |        fn find(&self, target: &T) -> Option<&T>;
   53|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   54|       |        fn contains(&self, target: &T) -> B;
   55|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   56|       |        fn minimum(&self) -> Option<&T>;
   57|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   58|       |        fn maximum(&self) -> Option<&T>;
   59|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   60|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   61|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   62|       |        fn pre_order(&self) -> ArraySeqStPerS<T>;
   63|       |    }
   64|       |
   65|       |    impl<T: StT + Ord> Default for BSTAVLStEph<T> {
   66|      1|        fn default() -> Self { Self::new() }
   67|       |    }
   68|       |
   69|       |    impl<T: StT + Ord> BSTAVLStEph<T> {
   70|       |        // Private helper methods only - no public delegation
   71|       |
   72|  5.59k|        fn height_link(link: &Link<T>) -> i32 { link.as_ref().map_or(0, |n| n.height) }
   73|       |
   74|  3.76k|        fn size_link(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }
   75|       |
   76|  1.86k|        fn update(node: &mut Node<T>) {
   77|  1.86k|            node.height = 1 + Self::height_link(&node.left).max(Self::height_link(&node.right));
   78|  1.86k|            node.size = 1 + Self::size_link(&node.left) + Self::size_link(&node.right);
   79|  1.86k|        }
   80|       |
   81|     16|        fn rotate_right(link: &mut Link<T>) {
   82|     16|            if let Some(mut y) = link.take() {
   83|     16|                if let Some(mut x) = y.left.take() {
   84|     16|                    y.left = x.right.take();
   85|     16|                    Self::update(&mut y);
   86|     16|                    Self::update(&mut x);
   87|     16|                    x.right = Some(y);
   88|     16|                    *link = Some(x);
   89|     16|                } else {
   90|      0|                    *link = Some(y);
   91|      0|                }
   92|      0|            }
   93|     16|        }
   94|       |
   95|    110|        fn rotate_left(link: &mut Link<T>) {
   96|    110|            if let Some(mut x) = link.take() {
   97|    110|                if let Some(mut y) = x.right.take() {
   98|    110|                    x.right = y.left.take();
   99|    110|                    Self::update(&mut x);
  100|    110|                    Self::update(&mut y);
  101|    110|                    y.left = Some(x);
  102|    110|                    *link = Some(y);
  103|    110|                } else {
  104|      0|                    *link = Some(x);
  105|      0|                }
  106|      0|            }
  107|    110|        }
  108|       |
  109|    807|        fn rebalance(link: &mut Link<T>) {
  110|    807|            if let Some(node) = link.as_mut() {
  111|    807|                Self::update(node);
  112|    807|                let bf = Self::height_link(&node.left) - Self::height_link(&node.right);
  113|    807|                if bf > 1 {
  114|     16|                    if let Some(left) = node.left.as_mut() {
  115|     16|                        if Self::height_link(&left.right) > Self::height_link(&left.left) {
  116|      0|                            Self::rotate_left(&mut node.left);
  117|     16|                        }
  118|      0|                    }
  119|     16|                    Self::rotate_right(link);
  120|    791|                } else if bf < -1 {
  121|    110|                    if let Some(right) = node.right.as_mut() {
  122|    110|                        if Self::height_link(&right.left) > Self::height_link(&right.right) {
  123|      0|                            Self::rotate_right(&mut node.right);
  124|    110|                        }
  125|      0|                    }
  126|    110|                    Self::rotate_left(link);
  127|    681|                }
  128|      0|            }
  129|    807|            if let Some(node) = link.as_mut() {
  130|    807|                Self::update(node);
  131|    807|            }
                          ^0
  132|    807|        }
  133|       |
  134|  1.01k|        fn insert_link(link: &mut Link<T>, value: T) {
  135|  1.01k|            match link {
  136|    811|                | Some(node) => {
  137|    811|                    if value < node.key {
  138|    114|                        Self::insert_link(&mut node.left, value);
  139|    697|                    } else if value > node.key {
  140|    693|                        Self::insert_link(&mut node.right, value);
  141|    693|                    } else {
  142|      4|                        return;
  143|       |                    }
  144|       |                }
  145|       |                | None => {
  146|    204|                    *link = Some(Box::new(Node::new(value)));
  147|    204|                    return;
  148|       |                }
  149|       |            }
  150|    807|            Self::rebalance(link);
  151|  1.01k|        }
  152|       |
  153|    213|        fn find_link<'a>(link: &'a Link<T>, target: &T) -> Option<&'a T> {
  154|    213|            match link {
  155|     23|                | None => None,
  156|    190|                | Some(node) => {
  157|    190|                    if target == &node.key {
  158|     38|                        Some(&node.key)
  159|    152|                    } else if target < &node.key {
  160|     77|                        Self::find_link(&node.left, target)
  161|       |                    } else {
  162|     75|                        Self::find_link(&node.right, target)
  163|       |                    }
  164|       |                }
  165|       |            }
  166|    213|        }
  167|       |
  168|     26|        fn min_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  169|     26|            match link {
  170|      2|                | None => None,
  171|     24|                | Some(node) => match node.left {
  172|      8|                    | None => Some(&node.key),
  173|     16|                    | Some(_) => Self::min_link(&node.left),
  174|       |                },
  175|       |            }
  176|     26|        }
  177|       |
  178|     26|        fn max_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  179|     26|            match link {
  180|      2|                | None => None,
  181|     24|                | Some(node) => match node.right {
  182|      8|                    | None => Some(&node.key),
  183|     16|                    | Some(_) => Self::max_link(&node.right),
  184|       |                },
  185|       |            }
  186|     26|        }
  187|       |
  188|    338|        fn in_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  189|    338|            if let Some(node) = link {
                                      ^165
  190|    165|                Self::in_order_collect(&node.left, out);
  191|    165|                out.push(node.key.clone());
  192|    165|                Self::in_order_collect(&node.right, out);
  193|    173|            }
  194|    338|        }
  195|       |
  196|     19|        fn pre_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  197|     19|            if let Some(node) = link {
                                      ^8
  198|      8|                out.push(node.key.clone());
  199|      8|                Self::pre_order_collect(&node.left, out);
  200|      8|                Self::pre_order_collect(&node.right, out);
  201|     11|            }
  202|     19|        }
  203|       |    }
  204|       |
  205|       |    impl<T: StT + Ord> BSTAVLStEphTrait<T> for BSTAVLStEph<T> {
  206|     19|        fn new() -> Self { BSTAVLStEph { root: None } }
  207|       |
  208|     34|        fn size(&self) -> N { Self::size_link(&self.root) }
  209|       |
  210|      7|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
                                                                      ^4            ^3
  211|       |
  212|     13|        fn height(&self) -> N {
  213|    359|            fn height_rec<T: StT + Ord>(link: &Link<T>) -> N {
  214|    359|                match link {
  215|    186|                    | None => 0,
  216|    173|                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),
  217|       |                }
  218|    359|            }
  219|     13|            height_rec(&self.root)
  220|     13|        }
  221|       |
  222|    208|        fn insert(&mut self, value: T) { Self::insert_link(&mut self.root, value); }
  223|       |
  224|     61|        fn find(&self, target: &T) -> Option<&T> { Self::find_link(&self.root, target) }
  225|       |
  226|     39|        fn contains(&self, target: &T) -> B { self.find(target).is_some() }
  227|       |
  228|     10|        fn minimum(&self) -> Option<&T> { Self::min_link(&self.root) }
  229|       |
  230|     10|        fn maximum(&self) -> Option<&T> { Self::max_link(&self.root) }
  231|       |
  232|      8|        fn in_order(&self) -> ArraySeqStPerS<T> {
  233|      8|            let mut out = Vec::with_capacity(self.size());
  234|      8|            Self::in_order_collect(&self.root, &mut out);
  235|      8|            ArraySeqStPerS::from_vec(out)
  236|      8|        }
  237|       |
  238|      3|        fn pre_order(&self) -> ArraySeqStPerS<T> {
  239|      3|            let mut out = Vec::with_capacity(self.size());
  240|      3|            Self::pre_order_collect(&self.root, &mut out);
  241|      3|            ArraySeqStPerS::from_vec(out)
  242|      3|        }
  243|       |    }
  244|       |
  245|       |    #[macro_export]
  246|       |    macro_rules! BSTAVLStEphLit {
  247|       |        () => {
  248|       |            < $crate::Chap37::BSTAVLStEph::BSTAVLStEph::BSTAVLStEph<_> as $crate::Chap37::BSTAVLStEph::BSTAVLStEph::BSTAVLStEphTrait<_> >::new()
  249|       |        };
  250|       |        ( $( $x:expr ),* $(,)? ) => {{
  251|       |            let mut __tree = < $crate::Chap37::BSTAVLStEph::BSTAVLStEph::BSTAVLStEph<_> as $crate::Chap37::BSTAVLStEph::BSTAVLStEph::BSTAVLStEphTrait<_> >::new();
  252|       |            $( __tree.insert($x); )*
  253|       |            __tree
  254|       |        }};
  255|       |    }
  256|       |
  257|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap37/BSTBBAlphaMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Ephemeral weight-balanced (BB[]) binary search tree with interior locking for multi-threaded access.
    3|       |
    4|       |pub mod BSTBBAlphaMtEph {
    5|       |
    6|       |    use std::sync::{Arc, RwLock};
    7|       |
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    const ALPHA: f64 = 0.75;
   13|       |
   14|       |    type Link<T> = Option<Box<Node<T>>>;
   15|       |
   16|       |    #[derive(Clone, Debug)]
   17|       |    struct Node<T: StTInMtT + Ord> {
   18|       |        key: T,
   19|       |        size: N,
   20|       |        left: Link<T>,
   21|       |        right: Link<T>,
   22|       |    }
   23|       |
   24|       |    impl<T: StTInMtT + Ord> Node<T> {
   25|  1.56k|        fn new(key: T) -> Self {
   26|  1.56k|            Node {
   27|  1.56k|                key,
   28|  1.56k|                size: 1,
   29|  1.56k|                left: None,
   30|  1.56k|                right: None,
   31|  1.56k|            }
   32|  1.56k|        }
   33|       |    }
   34|       |
   35|       |    #[derive(Debug, Clone)]
   36|       |    pub struct BSTBBAlphaMtEph<T: StTInMtT + Ord> {
   37|       |        root: Arc<RwLock<Link<T>>>,
   38|       |    }
   39|       |
   40|       |    pub type BSTreeBBAlpha<T> = BSTBBAlphaMtEph<T>;
   41|       |
   42|       |    pub trait BSTBBAlphaMtEphTrait<T: StTInMtT + Ord>: Sized {
   43|       |        /// claude-4-sonet: Work (1), Span (1)
   44|       |        fn new() -> Self;
   45|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   46|       |        fn insert(&self, value: T);
   47|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   48|       |        fn find(&self, target: &T) -> Option<T>;
   49|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   50|       |        fn contains(&self, target: &T) -> B;
   51|       |        /// claude-4-sonet: Work (1), Span (1)
   52|       |        fn size(&self) -> N;
   53|       |        /// claude-4-sonet: Work (1), Span (1)
   54|       |        fn is_empty(&self) -> B;
   55|       |        /// claude-4-sonet: Work (n), Span (n)
   56|       |        fn height(&self) -> N;
   57|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   58|       |        fn minimum(&self) -> Option<T>;
   59|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   60|       |        fn maximum(&self) -> Option<T>;
   61|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   62|       |        fn pre_order(&self) -> ArraySeqStPerS<T>;
   63|       |    }
   64|       |
   65|       |    impl<T: StTInMtT + Ord> Default for BSTBBAlphaMtEph<T> {
   66|      1|        fn default() -> Self { Self::new() }
   67|       |    }
   68|       |
   69|       |    impl<T: StTInMtT + Ord> BSTBBAlphaMtEph<T> {
   70|  21.4k|        fn size_link(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }
   71|       |
   72|  9.25k|        fn update(node: &mut Node<T>) { node.size = 1 + Self::size_link(&node.left) + Self::size_link(&node.right); }
   73|       |
   74|  9.51k|        fn insert_link(link: &mut Link<T>, value: T) -> bool {
   75|  9.51k|            match link {
   76|  8.60k|                | Some(node) => {
   77|  8.60k|                    let inserted = if value < node.key {
   78|  2.33k|                        Self::insert_link(&mut node.left, value)
   79|  6.27k|                    } else if value > node.key {
   80|  6.26k|                        Self::insert_link(&mut node.right, value)
   81|       |                    } else {
   82|      5|                        false
   83|       |                    };
   84|  8.60k|                    if inserted {
   85|  8.59k|                        Self::update(node);
   86|  8.59k|                    }
                                  ^6
   87|  8.60k|                    inserted
   88|       |                }
   89|       |                | None => {
   90|    907|                    *link = Some(Box::new(Node::new(value)));
   91|    907|                    true
   92|       |                }
   93|       |            }
   94|  9.51k|        }
   95|       |
   96|    907|        fn needs_rebuild(node: &Node<T>) -> bool {
   97|    907|            let total = node.size as f64;
   98|    907|            let left = Self::size_link(&node.left) as f64;
   99|    907|            let right = Self::size_link(&node.right) as f64;
  100|    907|            left > ALPHA * total || right > ALPHA * total
                                                  ^895
  101|    907|        }
  102|       |
  103|    907|        fn rebalance_if_needed(link: &mut Link<T>, total_size: N) {
  104|    907|            if let Some(node) = link.as_ref() {
  105|    907|                if Self::needs_rebuild(node) {
  106|     47|                    let mut values = Vec::with_capacity(total_size);
  107|     47|                    Self::collect_values(&Some(node.clone()), &mut values);
  108|     47|                    *link = Self::build_balanced(&values);
  109|    860|                }
  110|      0|            }
  111|    907|        }
  112|       |
  113|  1.36k|        fn collect_values(link: &Link<T>, out: &mut Vec<T>) {
  114|  1.36k|            if let Some(node) = link {
                                      ^659
  115|    659|                Self::collect_values(&node.left, out);
  116|    659|                out.push(node.key.clone());
  117|    659|                Self::collect_values(&node.right, out);
  118|    706|            }
  119|  1.36k|        }
  120|       |
  121|  1.36k|        fn build_balanced(values: &[T]) -> Link<T> {
  122|  1.36k|            if values.is_empty() {
  123|    706|                return None;
  124|    659|            }
  125|    659|            let mid = values.len() / 2;
  126|    659|            let mut node = Box::new(Node::new(values[mid].clone()));
  127|    659|            node.left = Self::build_balanced(&values[..mid]);
  128|    659|            node.right = Self::build_balanced(&values[mid + 1..]);
  129|    659|            Self::update(&mut node);
  130|    659|            Some(node)
  131|  1.36k|        }
  132|       |
  133|    397|        fn find_link<'a>(link: &'a Link<T>, target: &T) -> Option<&'a T> {
  134|    397|            match link {
  135|     15|                | None => None,
  136|    382|                | Some(node) => {
  137|    382|                    if target == &node.key {
  138|    119|                        Some(&node.key)
  139|    263|                    } else if target < &node.key {
  140|    130|                        Self::find_link(&node.left, target)
  141|       |                    } else {
  142|    133|                        Self::find_link(&node.right, target)
  143|       |                    }
  144|       |                }
  145|       |            }
  146|    397|        }
  147|       |
  148|     80|        fn min_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  149|     80|            match link {
  150|      2|                | None => None,
  151|     78|                | Some(node) => match node.left {
  152|     17|                    | None => Some(&node.key),
  153|     61|                    | Some(_) => Self::min_link(&node.left),
  154|       |                },
  155|       |            }
  156|     80|        }
  157|       |
  158|    126|        fn max_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  159|    126|            match link {
  160|      2|                | None => None,
  161|    124|                | Some(node) => match node.right {
  162|     17|                    | None => Some(&node.key),
  163|    107|                    | Some(_) => Self::max_link(&node.right),
  164|       |                },
  165|       |            }
  166|    126|        }
  167|       |
  168|    683|        fn in_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  169|    683|            if let Some(node) = link {
                                      ^304
  170|    304|                Self::in_order_collect(&node.left, out);
  171|    304|                out.push(node.key.clone());
  172|    304|                Self::in_order_collect(&node.right, out);
  173|    379|            }
  174|    683|        }
  175|       |
  176|     68|        fn pre_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  177|     68|            if let Some(node) = link {
                                      ^33
  178|     33|                out.push(node.key.clone());
  179|     33|                Self::pre_order_collect(&node.left, out);
  180|     33|                Self::pre_order_collect(&node.right, out);
  181|     35|            }
  182|     68|        }
  183|       |    }
  184|       |
  185|       |    impl<T: StTInMtT + Ord> BSTBBAlphaMtEphTrait<T> for BSTBBAlphaMtEph<T> {
  186|    135|        fn new() -> Self {
  187|    135|            BSTBBAlphaMtEph {
  188|    135|                root: Arc::new(RwLock::new(None)),
  189|    135|            }
  190|    135|        }
  191|       |
  192|    912|        fn insert(&self, value: T) {
  193|    912|            let mut guard = self.root.write().unwrap();
  194|    912|            let inserted = Self::insert_link(&mut *guard, value);
  195|    912|            if inserted {
  196|    907|                let total = Self::size_link(&*guard);
  197|    907|                Self::rebalance_if_needed(&mut *guard, total);
  198|    907|            }
                          ^5
  199|    912|        }
  200|       |
  201|    134|        fn find(&self, target: &T) -> Option<T> {
  202|    134|            let guard = self.root.read().unwrap();
  203|    134|            Self::find_link(&*guard, target).cloned()
  204|    134|        }
  205|       |
  206|     92|        fn contains(&self, target: &T) -> B { if self.find(target).is_some() { true } else { false } }
                                                                                             ^80           ^12
  207|       |
  208|     95|        fn size(&self) -> N {
  209|     95|            let guard = self.root.read().unwrap();
  210|     95|            Self::size_link(&*guard)
  211|     95|        }
  212|       |
  213|     10|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
                                                                      ^7            ^3
  214|       |
  215|     13|        fn height(&self) -> N {
  216|    681|            fn height_rec<T: StTInMtT + Ord>(link: &Link<T>) -> N {
  217|    681|                match link {
  218|    347|                    | None => 0,
  219|    334|                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),
  220|       |                }
  221|    681|            }
  222|       |
  223|     13|            let guard = self.root.read().unwrap();
  224|     13|            height_rec(&*guard)
  225|     13|        }
  226|       |
  227|     19|        fn minimum(&self) -> Option<T> {
  228|     19|            let guard = self.root.read().unwrap();
  229|     19|            Self::min_link(&*guard).cloned()
  230|     19|        }
  231|       |
  232|     19|        fn maximum(&self) -> Option<T> {
  233|     19|            let guard = self.root.read().unwrap();
  234|     19|            Self::max_link(&*guard).cloned()
  235|     19|        }
  236|       |
  237|     75|        fn in_order(&self) -> ArraySeqStPerS<T> {
  238|     75|            let guard = self.root.read().unwrap();
  239|     75|            let mut out = Vec::with_capacity(Self::size_link(&*guard));
  240|     75|            Self::in_order_collect(&*guard, &mut out);
  241|     75|            ArraySeqStPerS::from_vec(out)
  242|     75|        }
  243|       |
  244|      2|        fn pre_order(&self) -> ArraySeqStPerS<T> {
  245|      2|            let guard = self.root.read().unwrap();
  246|      2|            let mut out = Vec::with_capacity(Self::size_link(&*guard));
  247|      2|            Self::pre_order_collect(&*guard, &mut out);
  248|      2|            ArraySeqStPerS::from_vec(out)
  249|      2|        }
  250|       |    }
  251|       |
  252|       |    #[macro_export]
  253|       |    macro_rules! BSTBBAlphaMtEphLit {
  254|       |        () => {
  255|       |            < $crate::Chap37::BSTBBAlphaMtEph::BSTBBAlphaMtEph::BSTBBAlphaMtEph<_> as $crate::Chap37::BSTBBAlphaMtEph::BSTBBAlphaMtEph::BSTBBAlphaMtEphTrait<_> >::new()
  256|       |        };
  257|       |        ( $( $x:expr ),* $(,)? ) => {{
  258|       |            let __tree = < $crate::Chap37::BSTBBAlphaMtEph::BSTBBAlphaMtEph::BSTBBAlphaMtEph<_> as $crate::Chap37::BSTBBAlphaMtEph::BSTBBAlphaMtEph::BSTBBAlphaMtEphTrait<_> >::new();
  259|       |            $( __tree.insert($x); )*
  260|       |            __tree
  261|       |        }};
  262|       |    }
  263|       |
  264|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap37/BSTBBAlphaStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Ephemeral weight-balanced (BB[]) binary search tree with `find` support.
    3|       |
    4|       |pub mod BSTBBAlphaStEph {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    8|       |    use crate::Types::Types::*;
    9|       |
   10|       |    const ALPHA: f64 = 0.75;
   11|       |
   12|       |    type Link<T> = Option<Box<Node<T>>>;
   13|       |
   14|       |    #[derive(Debug, Clone)]
   15|       |    struct Node<T: StT + Ord> {
   16|       |        key: T,
   17|       |        size: N,
   18|       |        left: Link<T>,
   19|       |        right: Link<T>,
   20|       |    }
   21|       |
   22|       |    impl<T: StT + Ord> Node<T> {
   23|    494|        fn new(key: T) -> Self {
   24|    494|            Node {
   25|    494|                key,
   26|    494|                size: 1,
   27|    494|                left: None,
   28|    494|                right: None,
   29|    494|            }
   30|    494|        }
   31|       |    }
   32|       |
   33|       |    #[derive(Debug, Clone)]
   34|       |    pub struct BSTBBAlphaStEph<T: StT + Ord> {
   35|       |        root: Link<T>,
   36|       |    }
   37|       |
   38|       |    pub type BSTreeBBAlpha<T> = BSTBBAlphaStEph<T>;
   39|       |
   40|       |    pub trait BSTBBAlphaStEphTrait<T: StT + Ord> {
   41|       |        /// claude-4-sonet: Work (1), Span (1)
   42|       |        fn new() -> Self;
   43|       |        /// claude-4-sonet: Work (1), Span (1)
   44|       |        fn size(&self) -> N;
   45|       |        /// claude-4-sonet: Work (1), Span (1)
   46|       |        fn is_empty(&self) -> B;
   47|       |        /// claude-4-sonet: Work (n), Span (n)
   48|       |        fn height(&self) -> N;
   49|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   50|       |        fn insert(&mut self, value: T);
   51|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   52|       |        fn find(&self, target: &T) -> Option<&T>;
   53|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   54|       |        fn contains(&self, target: &T) -> B;
   55|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   56|       |        fn minimum(&self) -> Option<&T>;
   57|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   58|       |        fn maximum(&self) -> Option<&T>;
   59|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   60|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   61|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   62|       |        fn pre_order(&self) -> ArraySeqStPerS<T>;
   63|       |    }
   64|       |
   65|       |    impl<T: StT + Ord> Default for BSTBBAlphaStEph<T> {
   66|      0|        fn default() -> Self { Self::new() }
   67|       |    }
   68|       |
   69|       |    impl<T: StT + Ord> BSTBBAlphaStEph<T> {
   70|       |        // Private helper methods only - no public delegation
   71|       |
   72|      1|        pub fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
                                                                                        ^0
   73|       |
   74|      1|        pub fn height(&self) -> N {
   75|    129|            fn height_rec<T: StT + Ord>(link: &Link<T>) -> N {
   76|    129|                match link {
   77|     65|                    | None => 0,
   78|     64|                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),
   79|       |                }
   80|    129|            }
   81|      1|            height_rec(&self.root)
   82|      1|        }
   83|       |
   84|    232|        pub fn insert(&mut self, value: T) {
   85|    232|            let inserted = Self::insert_link(&mut self.root, value);
   86|    232|            if inserted {
   87|    231|                let total = Self::size_link(&self.root);
   88|    231|                Self::rebalance_if_needed(&mut self.root, total);
   89|    231|            }
                          ^1
   90|    232|        }
   91|       |
   92|     12|        pub fn find(&self, target: &T) -> Option<&T> { Self::find_link(&self.root, target) }
   93|       |
   94|      7|        pub fn contains(&self, target: &T) -> B { if self.find(target).is_some() { true } else { false } }
                                                                                                 ^5            ^2
   95|       |
   96|      3|        pub fn minimum(&self) -> Option<&T> { Self::min_link(&self.root) }
   97|       |
   98|      2|        pub fn maximum(&self) -> Option<&T> { Self::max_link(&self.root) }
   99|       |
  100|      1|        pub fn in_order(&self) -> ArraySeqStPerS<T> {
  101|      1|            let mut out = Vec::with_capacity(self.size());
  102|      1|            Self::in_order_collect(&self.root, &mut out);
  103|      1|            ArraySeqStPerS::from_vec(out)
  104|      1|        }
  105|       |
  106|      0|        pub fn pre_order(&self) -> ArraySeqStPerS<T> {
  107|      0|            let mut out = Vec::with_capacity(self.size());
  108|      0|            Self::pre_order_collect(&self.root, &mut out);
  109|      0|            ArraySeqStPerS::from_vec(out)
  110|      0|        }
  111|       |
  112|  7.67k|        fn size_link(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }
  113|       |
  114|  3.48k|        fn update(node: &mut Node<T>) { node.size = 1 + Self::size_link(&node.left) + Self::size_link(&node.right); }
  115|       |
  116|  3.45k|        fn insert_link(link: &mut Link<T>, value: T) -> bool {
  117|  3.45k|            match link {
  118|  3.22k|                | Some(node) => {
  119|  3.22k|                    let inserted = if value < node.key {
  120|    567|                        Self::insert_link(&mut node.left, value)
  121|  2.65k|                    } else if value > node.key {
  122|  2.65k|                        Self::insert_link(&mut node.right, value)
  123|       |                    } else {
  124|      1|                        false
  125|       |                    };
  126|  3.22k|                    if inserted {
  127|  3.22k|                        Self::update(node);
  128|  3.22k|                    }
                                  ^1
  129|  3.22k|                    inserted
  130|       |                }
  131|       |                | None => {
  132|    231|                    *link = Some(Box::new(Node::new(value)));
  133|    231|                    true
  134|       |                }
  135|       |            }
  136|  3.45k|        }
  137|       |
  138|    231|        fn needs_rebuild(node: &Node<T>) -> bool {
  139|    231|            let total = node.size as f64;
  140|    231|            let left = Self::size_link(&node.left) as f64;
  141|    231|            let right = Self::size_link(&node.right) as f64;
  142|    231|            left > ALPHA * total || right > ALPHA * total
                                                  ^228
  143|    231|        }
  144|       |
  145|    231|        fn rebalance_if_needed(link: &mut Link<T>, total_size: N) {
  146|    231|            if let Some(node) = link.as_ref() {
  147|    231|                if Self::needs_rebuild(node) {
  148|     11|                    let mut values = Vec::with_capacity(total_size);
  149|     11|                    Self::collect_values(&Some(node.clone()), &mut values);
  150|     11|                    *link = Self::build_balanced(&values);
  151|    220|                }
  152|      0|            }
  153|    231|        }
  154|       |
  155|    537|        fn collect_values(link: &Link<T>, out: &mut Vec<T>) {
  156|    537|            if let Some(node) = link {
                                      ^263
  157|    263|                Self::collect_values(&node.left, out);
  158|    263|                out.push(node.key.clone());
  159|    263|                Self::collect_values(&node.right, out);
  160|    274|            }
  161|    537|        }
  162|       |
  163|    537|        fn build_balanced(values: &[T]) -> Link<T> {
  164|    537|            if values.is_empty() {
  165|    274|                return None;
  166|    263|            }
  167|    263|            let mid = values.len() / 2;
  168|    263|            let mut node = Box::new(Node::new(values[mid].clone()));
  169|    263|            node.left = Self::build_balanced(&values[..mid]);
  170|    263|            node.right = Self::build_balanced(&values[mid + 1..]);
  171|    263|            Self::update(&mut node);
  172|    263|            Some(node)
  173|    537|        }
  174|       |
  175|     32|        fn find_link<'a>(link: &'a Link<T>, target: &T) -> Option<&'a T> {
  176|     32|            match link {
  177|      4|                | None => None,
  178|     28|                | Some(node) => {
  179|     28|                    if target == &node.key {
  180|      8|                        Some(&node.key)
  181|     20|                    } else if target < &node.key {
  182|      4|                        Self::find_link(&node.left, target)
  183|       |                    } else {
  184|     16|                        Self::find_link(&node.right, target)
  185|       |                    }
  186|       |                }
  187|       |            }
  188|     32|        }
  189|       |
  190|     34|        fn min_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  191|     34|            match link {
  192|      0|                | None => None,
  193|     34|                | Some(node) => match node.left {
  194|      3|                    | None => Some(&node.key),
  195|     31|                    | Some(_) => Self::min_link(&node.left),
  196|       |                },
  197|       |            }
  198|     34|        }
  199|       |
  200|     11|        fn max_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  201|     11|            match link {
  202|      0|                | None => None,
  203|     11|                | Some(node) => match node.right {
  204|      2|                    | None => Some(&node.key),
  205|      9|                    | Some(_) => Self::max_link(&node.right),
  206|       |                },
  207|       |            }
  208|     11|        }
  209|       |
  210|    129|        fn in_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  211|    129|            if let Some(node) = link {
                                      ^64
  212|     64|                Self::in_order_collect(&node.left, out);
  213|     64|                out.push(node.key.clone());
  214|     64|                Self::in_order_collect(&node.right, out);
  215|     65|            }
  216|    129|        }
  217|       |
  218|      0|        fn pre_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  219|      0|            if let Some(node) = link {
  220|      0|                out.push(node.key.clone());
  221|      0|                Self::pre_order_collect(&node.left, out);
  222|      0|                Self::pre_order_collect(&node.right, out);
  223|      0|            }
  224|      0|        }
  225|       |    }
  226|       |
  227|       |    impl<T: StT + Ord> BSTBBAlphaStEphTrait<T> for BSTBBAlphaStEph<T> {
  228|     12|        fn new() -> Self { BSTBBAlphaStEph { root: None } }
  229|       |
  230|     10|        fn size(&self) -> N { Self::size_link(&self.root) }
  231|       |
  232|      0|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
  233|       |
  234|      0|        fn height(&self) -> N {
  235|      0|            fn height_rec<T: StT + Ord>(link: &Link<T>) -> N {
  236|      0|                match link {
  237|      0|                    | None => 0,
  238|      0|                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),
  239|       |                }
  240|      0|            }
  241|      0|            height_rec(&self.root)
  242|      0|        }
  243|       |
  244|      0|        fn insert(&mut self, value: T) { Self::insert_link(&mut self.root, value); }
  245|       |
  246|      0|        fn find(&self, target: &T) -> Option<&T> { Self::find_link(&self.root, target) }
  247|       |
  248|      0|        fn contains(&self, target: &T) -> B { self.find(target).is_some() }
  249|       |
  250|      0|        fn minimum(&self) -> Option<&T> { Self::min_link(&self.root) }
  251|       |
  252|      0|        fn maximum(&self) -> Option<&T> { Self::max_link(&self.root) }
  253|       |
  254|      0|        fn in_order(&self) -> ArraySeqStPerS<T> {
  255|      0|            let mut out = Vec::with_capacity(self.size());
  256|      0|            Self::in_order_collect(&self.root, &mut out);
  257|      0|            ArraySeqStPerS::from_vec(out)
  258|      0|        }
  259|       |
  260|      0|        fn pre_order(&self) -> ArraySeqStPerS<T> {
  261|      0|            let mut out = Vec::with_capacity(self.size());
  262|      0|            Self::pre_order_collect(&self.root, &mut out);
  263|      0|            ArraySeqStPerS::from_vec(out)
  264|      0|        }
  265|       |    }
  266|       |
  267|       |    #[macro_export]
  268|       |    macro_rules! BSTBBAlphaStEphLit {
  269|       |        () => {
  270|       |            < $crate::Chap37::BSTBBAlphaStEph::BSTBBAlphaStEph::BSTBBAlphaStEph<_> as $crate::Chap37::BSTBBAlphaStEph::BSTBBAlphaStEph::BSTBBAlphaStEphTrait<_> >::new()
  271|       |        };
  272|       |        ( $( $x:expr ),* $(,)? ) => {{
  273|       |            let mut __tree = < $crate::Chap37::BSTBBAlphaStEph::BSTBBAlphaStEph::BSTBBAlphaStEph<_> as $crate::Chap37::BSTBBAlphaStEph::BSTBBAlphaStEph::BSTBBAlphaStEphTrait<_> >::new();
  274|       |            $( __tree.insert($x); )*
  275|       |            __tree
  276|       |        }};
  277|       |    }
  278|       |
  279|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap37/BSTPlainMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Ephemeral binary search tree built on `BBTEph` primitives with fine-grained locking.
    3|       |
    4|       |pub mod BSTPlainMtEph {
    5|       |
    6|       |    use std::sync::{Arc, RwLock};
    7|       |
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |    use crate::Types::Types::*;
   10|       |
   11|       |    type Link<T> = Arc<RwLock<Option<Node<T>>>>;
   12|       |
   13|       |    #[derive(Clone, Debug)]
   14|       |    struct Node<T: StTInMtT + Ord> {
   15|       |        key: T,
   16|       |        height: i32,
   17|       |        size: N,
   18|       |        left: Link<T>,
   19|       |        right: Link<T>,
   20|       |    }
   21|       |
   22|       |    impl<T: StTInMtT + Ord> Node<T> {
   23|    608|        fn new(key: T) -> Self {
   24|    608|            Node {
   25|    608|                key,
   26|    608|                height: 1,
   27|    608|                size: 1,
   28|    608|                left: Arc::new(RwLock::new(None)),
   29|    608|                right: Arc::new(RwLock::new(None)),
   30|    608|            }
   31|    608|        }
   32|       |
   33|  6.97k|        fn update(&mut self) {
   34|  6.97k|            let left = self.left.read().unwrap();
   35|  6.97k|            let right = self.right.read().unwrap();
   36|  6.97k|            self.height = 1 + height_of(&left).max(height_of(&right));
   37|  6.97k|            self.size = 1 + size_of(&left) + size_of(&right);
   38|  6.97k|        }
   39|       |    }
   40|       |
   41|       |    #[derive(Clone, Debug)]
   42|       |    pub struct BSTPlainMtEph<T: StTInMtT + Ord> {
   43|       |        root: Link<T>,
   44|       |    }
   45|       |
   46|       |    pub type BSTree<T> = BSTPlainMtEph<T>;
   47|       |
   48|       |    pub trait BSTPlainMtEphTrait<T: StTInMtT + Ord>: Sized {
   49|       |        /// claude-4-sonet: Work (1), Span (1)
   50|       |        fn new() -> Self;
   51|       |        /// claude-4-sonet: Work (log n) average, (n) worst case; Span (log n) average with locking
   52|       |        fn insert(&self, value: T);
   53|       |        /// claude-4-sonet: Work (log n) average, (n) worst case; Span (log n) average with locking
   54|       |        fn find(&self, target: &T) -> Option<T>;
   55|       |        fn contains(&self, target: &T) -> B;
   56|       |        fn size(&self) -> N;
   57|       |        fn is_empty(&self) -> B;
   58|       |        fn height(&self) -> N;
   59|       |        fn minimum(&self) -> Option<T>;
   60|       |        fn maximum(&self) -> Option<T>;
   61|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   62|       |    }
   63|       |
   64|       |    impl<T: StTInMtT + Ord> BSTPlainMtEph<T> {
   65|       |        // Private helper methods only - no public delegation
   66|       |    }
   67|       |
   68|  13.9k|    fn height_of<T: StTInMtT + Ord>(link: &Option<Node<T>>) -> i32 { link.as_ref().map_or(0, |n| n.height) }
   69|       |
   70|  13.9k|    fn size_of<T: StTInMtT + Ord>(link: &Option<Node<T>>) -> N { link.as_ref().map_or(0, |n| n.size) }
   71|       |
   72|       |    impl<T: StTInMtT + Ord> BSTPlainMtEphTrait<T> for BSTPlainMtEph<T> {
   73|    153|        fn new() -> Self {
   74|    153|            Self {
   75|    153|                root: Arc::new(RwLock::new(None)),
   76|    153|            }
   77|    153|        }
   78|       |
   79|    613|        fn insert(&self, value: T) {
   80|  7.59k|            fn descend<T: StTInMtT + Ord>(link: &Link<T>, value: T) -> bool {
   81|  7.59k|                let mut guard = link.write().unwrap();
   82|  7.59k|                match guard.as_mut() {
   83|  6.98k|                    | Some(node) => {
   84|  6.98k|                        if value == node.key {
   85|      5|                            return false;
   86|  6.97k|                        }
   87|       |
   88|  6.97k|                        let branch = if value < node.key {
   89|    109|                            node.left.clone()
   90|       |                        } else {
   91|  6.86k|                            node.right.clone()
   92|       |                        };
   93|       |
   94|  6.97k|                        drop(guard);
   95|  6.97k|                        let inserted = descend(&branch, value);
   96|  6.97k|                        if inserted {
   97|  6.97k|                            let mut guard = link.write().unwrap();
   98|  6.97k|                            if let Some(node) = guard.as_mut() {
   99|  6.97k|                                node.update();
  100|  6.97k|                            }
                                          ^0
  101|      1|                        }
  102|  6.97k|                        inserted
  103|       |                    }
  104|       |                    | None => {
  105|    608|                        *guard = Some(Node::new(value));
  106|    608|                        true
  107|       |                    }
  108|       |                }
  109|  7.59k|            }
  110|       |
  111|    613|            descend(&self.root, value);
  112|    613|        }
  113|       |
  114|    175|        fn find(&self, target: &T) -> Option<T> {
  115|    559|            fn find_rec<T: StTInMtT + Ord>(link: &Link<T>, target: &T) -> Option<T> {
  116|    559|                let guard = link.read().unwrap();
  117|    559|                match guard.as_ref() {
  118|    489|                    | Some(node) if target == &node.key => Some(node.key.clone()),
                                         ^105                       ^105 ^105
  119|    384|                    | Some(node) => {
  120|    384|                        let branch = if target < &node.key {
  121|     57|                            node.left.clone()
  122|       |                        } else {
  123|    327|                            node.right.clone()
  124|       |                        };
  125|    384|                        drop(guard);
  126|    384|                        find_rec(&branch, target)
  127|       |                    }
  128|     70|                    | None => None,
  129|       |                }
  130|    559|            }
  131|    175|            find_rec(&self.root, target)
  132|    175|        }
  133|       |
  134|    148|        fn contains(&self, target: &T) -> B { if self.find(target).is_some() { true } else { false } }
                                                                                             ^84           ^64
  135|       |
  136|    102|        fn size(&self) -> N {
  137|    102|            let guard = self.root.read().unwrap();
  138|    102|            guard.as_ref().map_or(0, |node| node.size)
  139|    102|        }
  140|       |
  141|     12|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
                                                                      ^8            ^4
  142|       |
  143|     11|        fn height(&self) -> N {
  144|     11|            let guard = self.root.read().unwrap();
  145|     11|            guard.as_ref().map_or(0, |node| node.height as N)
                                                          ^7
  146|     11|        }
  147|       |
  148|     22|        fn minimum(&self) -> Option<T> {
  149|     41|            fn leftmost<T: StTInMtT + Ord>(link: &Link<T>) -> Option<T> {
  150|     41|                let guard = link.read().unwrap();
  151|     41|                if let Some(node) = guard.as_ref() {
                                          ^37
  152|     37|                    let child = node.left.clone();
  153|     37|                    let key = node.key.clone();
  154|     37|                    drop(guard);
  155|     37|                    let left_guard = child.read().unwrap();
  156|     37|                    if left_guard.is_none() {
  157|     18|                        Some(key)
  158|       |                    } else {
  159|     19|                        drop(left_guard);
  160|     19|                        leftmost(&child)
  161|       |                    }
  162|       |                } else {
  163|      4|                    None
  164|       |                }
  165|     41|            }
  166|       |
  167|     22|            leftmost(&self.root)
  168|     22|        }
  169|       |
  170|     22|        fn maximum(&self) -> Option<T> {
  171|    187|            fn rightmost<T: StTInMtT + Ord>(link: &Link<T>) -> Option<T> {
  172|    187|                let guard = link.read().unwrap();
  173|    187|                if let Some(node) = guard.as_ref() {
                                          ^183
  174|    183|                    let child = node.right.clone();
  175|    183|                    let key = node.key.clone();
  176|    183|                    drop(guard);
  177|    183|                    let right_guard = child.read().unwrap();
  178|    183|                    if right_guard.is_none() {
  179|     18|                        Some(key)
  180|       |                    } else {
  181|    165|                        drop(right_guard);
  182|    165|                        rightmost(&child)
  183|       |                    }
  184|       |                } else {
  185|      4|                    None
  186|       |                }
  187|    187|            }
  188|       |
  189|     22|            rightmost(&self.root)
  190|     22|        }
  191|       |
  192|     90|        fn in_order(&self) -> ArraySeqStPerS<T> {
  193|    572|            fn traverse<T: StTInMtT + Ord>(link: &Link<T>, out: &mut Vec<T>) {
  194|    572|                let guard = link.read().unwrap();
  195|    572|                if let Some(node) = guard.as_ref() {
                                          ^241
  196|    241|                    let left = node.left.clone();
  197|    241|                    let right = node.right.clone();
  198|    241|                    let key = node.key.clone();
  199|    241|                    drop(guard);
  200|    241|                    traverse(&left, out);
  201|    241|                    out.push(key);
  202|    241|                    traverse(&right, out);
  203|    331|                }
  204|    572|            }
  205|       |
  206|     90|            let mut values = Vec::new();
  207|     90|            traverse(&self.root, &mut values);
  208|     90|            ArraySeqStPerS::from_vec(values)
  209|     90|        }
  210|       |    }
  211|       |
  212|       |    #[macro_export]
  213|       |    macro_rules! BSTPlainMtEphLit {
  214|       |        () => { $crate::Chap37::BSTPlainMtEph::BSTPlainMtEph::BSTPlainMtEph::new() };
  215|       |        ($x:expr; $n:expr) => {{
  216|       |            let __tree = $crate::Chap37::BSTPlainMtEph::BSTPlainMtEph::BSTPlainMtEph::new();
  217|       |            for _ in 0..$n { __tree.insert($x.clone()); }
  218|       |            __tree
  219|       |        }};
  220|       |        ($($x:expr),+ $(,)?) => {{
  221|       |            let __tree = $crate::Chap37::BSTPlainMtEph::BSTPlainMtEph::BSTPlainMtEph::new();
  222|       |            $( __tree.insert($x); )*
  223|       |            __tree
  224|       |        }};
  225|       |    }
  226|       |
  227|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap37/BSTPlainStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Ephemeral binary search tree built on `BBTEph` primitives.
    3|       |
    4|       |pub mod BSTPlainStEph {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Chap23::BalBinTreeStEph::BalBinTreeStEph::BalBinTree;
    8|       |    use crate::Types::Types::*;
    9|       |
   10|       |    #[derive(Debug, Clone)]
   11|       |    pub struct BSTPlainStEph<T: StT + Ord> {
   12|       |        root: BalBinTree<T>,
   13|       |    }
   14|       |
   15|       |    pub type BSTree<T> = BSTPlainStEph<T>;
   16|       |
   17|       |    pub trait BSTPlainStEphTrait<T: StT + Ord> {
   18|       |        /// claude-4-sonet: Work (1), Span (1)
   19|       |        fn new() -> Self;
   20|       |        /// claude-4-sonet: Work (1), Span (1)
   21|       |        fn size(&self) -> N;
   22|       |        /// claude-4-sonet: Work (1), Span (1)
   23|       |        fn is_empty(&self) -> B;
   24|       |        /// claude-4-sonet: Work (n), Span (n)
   25|       |        fn height(&self) -> N;
   26|       |        /// claude-4-sonet: Work (log n) average, (n) worst case; Span (log n) average, Parallelism (1)
   27|       |        fn insert(&mut self, value: T);
   28|       |        /// claude-4-sonet: Work (log n) average, (n) worst case; Span (log n) average, Parallelism (1)
   29|       |        fn find(&self, target: &T) -> Option<&T>;
   30|       |        /// claude-4-sonet: Work (log n) average, (n) worst case; Span (log n) average, Parallelism (1)
   31|       |        fn contains(&self, target: &T) -> B;
   32|       |        /// claude-4-sonet: Work (log n) average, (n) worst case; Span (log n) average, Parallelism (1)
   33|       |        fn minimum(&self) -> Option<&T>;
   34|       |        /// claude-4-sonet: Work (log n) average, (n) worst case; Span (log n) average, Parallelism (1)
   35|       |        fn maximum(&self) -> Option<&T>;
   36|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   37|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   38|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   39|       |        fn pre_order(&self) -> ArraySeqStPerS<T>;
   40|       |    }
   41|       |
   42|       |    impl<T: StT + Ord> BSTPlainStEph<T> {
   43|       |        // Private helper methods only - no public delegation
   44|       |    }
   45|       |
   46|       |    impl<T: StT + Ord> BSTPlainStEphTrait<T> for BSTPlainStEph<T> {
   47|     24|        fn new() -> Self {
   48|     24|            BSTPlainStEph {
   49|     24|                root: BalBinTree::leaf(),
   50|     24|            }
   51|     24|        }
   52|       |
   53|     16|        fn size(&self) -> N { self.root.size() }
   54|       |
   55|      3|        fn is_empty(&self) -> B { self.root.is_leaf() }
   56|       |
   57|      8|        fn height(&self) -> N { self.root.height() }
   58|       |
   59|    195|        fn insert(&mut self, value: T) { insert_node(&mut self.root, value); }
   60|       |
   61|    125|        fn find(&self, target: &T) -> Option<&T> { find_node(&self.root, target) }
   62|       |
   63|    133|        fn contains(&self, target: &T) -> B { contains_node(&self.root, target) }
   64|       |
   65|     11|        fn minimum(&self) -> Option<&T> { min_node(&self.root) }
   66|       |
   67|     11|        fn maximum(&self) -> Option<&T> { max_node(&self.root) }
   68|       |
   69|     12|        fn in_order(&self) -> ArraySeqStPerS<T> { self.root.in_order() }
   70|       |
   71|      3|        fn pre_order(&self) -> ArraySeqStPerS<T> { self.root.pre_order() }
   72|       |    }
   73|       |
   74|  5.27k|    fn insert_node<T: StT + Ord>(node: &mut BalBinTree<T>, value: T) {
   75|  5.27k|        match node {
   76|    192|            | BalBinTree::Leaf => {
   77|    192|                *node = BalBinTree::node(BalBinTree::leaf(), value, BalBinTree::leaf());
   78|    192|            }
   79|  5.08k|            | BalBinTree::Node(inner) => {
   80|  5.08k|                if value < inner.value {
   81|     66|                    insert_node(&mut inner.left, value);
   82|  5.01k|                } else if value > inner.value {
   83|  5.01k|                    insert_node(&mut inner.right, value);
   84|  5.01k|                }
                              ^3
   85|       |            }
   86|       |        }
   87|  5.27k|    }
   88|       |
   89|  5.13k|    fn contains_node<'a, T: StT + Ord>(node: &'a BalBinTree<T>, target: &T) -> B {
   90|  5.13k|        match node {
   91|      9|            | BalBinTree::Leaf => false,
   92|  5.12k|            | BalBinTree::Node(inner) => {
   93|  5.12k|                if target == &inner.value {
   94|    124|                    true
   95|  5.00k|                } else if target < &inner.value {
   96|     21|                    contains_node(&inner.left, target)
   97|       |                } else {
   98|  4.98k|                    contains_node(&inner.right, target)
   99|       |                }
  100|       |            }
  101|       |        }
  102|  5.13k|    }
  103|       |
  104|  5.11k|    fn find_node<'a, T: StT + Ord>(node: &'a BalBinTree<T>, target: &T) -> Option<&'a T> {
  105|  5.11k|        match node {
  106|      8|            | BalBinTree::Leaf => None,
  107|  5.11k|            | BalBinTree::Node(inner) => {
  108|  5.11k|                if target == &inner.value {
  109|    117|                    Some(&inner.value)
  110|  4.99k|                } else if target < &inner.value {
  111|     18|                    find_node(&inner.left, target)
  112|       |                } else {
  113|  4.97k|                    find_node(&inner.right, target)
  114|       |                }
  115|       |            }
  116|       |        }
  117|  5.11k|    }
  118|       |
  119|     29|    fn min_node<'a, T: StT + Ord>(node: &'a BalBinTree<T>) -> Option<&'a T> {
  120|     29|        match node {
  121|      1|            | BalBinTree::Leaf => None,
  122|     28|            | BalBinTree::Node(inner) => match &inner.left {
  123|     10|                | BalBinTree::Leaf => Some(&inner.value),
  124|     18|                | _ => min_node(&inner.left),
  125|       |            },
  126|       |        }
  127|     29|    }
  128|       |
  129|    127|    fn max_node<'a, T: StT + Ord>(node: &'a BalBinTree<T>) -> Option<&'a T> {
  130|    127|        match node {
  131|      1|            | BalBinTree::Leaf => None,
  132|    126|            | BalBinTree::Node(inner) => match &inner.right {
  133|     10|                | BalBinTree::Leaf => Some(&inner.value),
  134|    116|                | _ => max_node(&inner.right),
  135|       |            },
  136|       |        }
  137|    127|    }
  138|       |
  139|       |    #[macro_export]
  140|       |    macro_rules! BSTPlainStEphLit {
  141|       |        () => { $crate::Chap37::BSTPlainStEph::BSTPlainStEph::BSTPlainStEph::new() };
  142|       |        ($x:expr; $n:expr) => {{
  143|       |            let mut __tree = $crate::Chap37::BSTPlainStEph::BSTPlainStEph::BSTPlainStEph::new();
  144|       |            for _ in 0..$n { __tree.insert($x.clone()); }
  145|       |            __tree
  146|       |        }};
  147|       |        ($($x:expr),+ $(,)?) => {{
  148|       |            let mut __tree = $crate::Chap37::BSTPlainStEph::BSTPlainStEph::BSTPlainStEph::new();
  149|       |            $( __tree.insert($x); )*
  150|       |            __tree
  151|       |        }};
  152|       |    }
  153|       |
  154|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap37/BSTRBMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Ephemeral Red-Black balanced binary search tree with interior locking for multi-threaded access.
    3|       |
    4|       |pub mod BSTRBMtEph {
    5|       |
    6|       |    use std::sync::{Arc, RwLock};
    7|       |
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    #[derive(Clone, Copy, PartialEq, Eq, Debug)]
   13|       |    enum Color {
   14|       |        Red,
   15|       |        Black,
   16|       |    }
   17|       |
   18|       |    type Link<T> = Option<Box<Node<T>>>;
   19|       |
   20|       |    #[derive(Clone, Debug)]
   21|       |    struct Node<T: StTInMtT + Ord> {
   22|       |        key: T,
   23|       |        color: Color,
   24|       |        size: N,
   25|       |        left: Link<T>,
   26|       |        right: Link<T>,
   27|       |    }
   28|       |
   29|       |    impl<T: StTInMtT + Ord> Node<T> {
   30|  24.9k|        fn new(key: T) -> Self {
   31|  24.9k|            Node {
   32|  24.9k|                key,
   33|  24.9k|                color: Color::Red,
   34|  24.9k|                size: 1,
   35|  24.9k|                left: None,
   36|  24.9k|                right: None,
   37|  24.9k|            }
   38|  24.9k|        }
   39|       |    }
   40|       |
   41|       |    #[derive(Debug, Clone)]
   42|       |    pub struct BSTRBMtEph<T: StTInMtT + Ord> {
   43|       |        root: Arc<RwLock<Link<T>>>,
   44|       |    }
   45|       |
   46|       |    pub type BSTreeRB<T> = BSTRBMtEph<T>;
   47|       |
   48|       |    pub trait BSTRBMtEphTrait<T: StTInMtT + Ord>: Sized {
   49|       |        /// claude-4-sonet: Work (1), Span (1)
   50|       |        fn new() -> Self;
   51|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   52|       |        fn insert(&self, value: T);
   53|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   54|       |        fn find(&self, target: &T) -> Option<T>;
   55|       |        fn contains(&self, target: &T) -> B;
   56|       |        fn size(&self) -> N;
   57|       |        fn is_empty(&self) -> B;
   58|       |        fn height(&self) -> N;
   59|       |        fn minimum(&self) -> Option<T>;
   60|       |        fn maximum(&self) -> Option<T>;
   61|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   62|       |        fn pre_order(&self) -> ArraySeqStPerS<T>;
   63|       |    }
   64|       |
   65|       |    impl<T: StTInMtT + Ord> Default for BSTRBMtEph<T> {
   66|      1|        fn default() -> Self { Self::new() }
   67|       |    }
   68|       |
   69|       |    impl<T: StTInMtT + Ord> BSTRBMtEph<T> {
   70|       |        // Private helper methods only - no public delegation
   71|       |
   72|   542k|        fn is_red(link: &Link<T>) -> bool { matches!(link, Some(node) if node.color == Color::Red) }
                                                          ^240k    ^492k      ^492k    ^492k                  ^240k
   73|       |
   74|   371k|        fn size_link(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }
   75|       |
   76|   185k|        fn update(node: &mut Node<T>) { node.size = 1 + Self::size_link(&node.left) + Self::size_link(&node.right); }
   77|       |
   78|  22.9k|        fn rotate_left(link: &mut Link<T>) {
   79|  22.9k|            if let Some(mut h) = link.take() {
   80|  22.9k|                if let Some(mut x) = h.right.take() {
   81|  22.9k|                    h.right = x.left.take();
   82|  22.9k|                    Self::update(&mut h);
   83|  22.9k|                    x.color = h.color;
   84|  22.9k|                    h.color = Color::Red;
   85|  22.9k|                    x.left = Some(h);
   86|  22.9k|                    if let Some(left) = x.left.as_mut() {
   87|  22.9k|                        Self::update(left);
   88|  22.9k|                    }
                                  ^0
   89|  22.9k|                    Self::update(&mut x);
   90|  22.9k|                    *link = Some(x);
   91|      0|                } else {
   92|      0|                    *link = Some(h);
   93|      0|                }
   94|      0|            }
   95|  22.9k|        }
   96|       |
   97|    268|        fn rotate_right(link: &mut Link<T>) {
   98|    268|            if let Some(mut h) = link.take() {
   99|    268|                if let Some(mut x) = h.left.take() {
  100|    268|                    h.left = x.right.take();
  101|    268|                    Self::update(&mut h);
  102|    268|                    x.color = h.color;
  103|    268|                    h.color = Color::Red;
  104|    268|                    x.right = Some(h);
  105|    268|                    if let Some(right) = x.right.as_mut() {
  106|    268|                        Self::update(right);
  107|    268|                    }
                                  ^0
  108|    268|                    Self::update(&mut x);
  109|    268|                    *link = Some(x);
  110|      0|                } else {
  111|      0|                    *link = Some(h);
  112|      0|                }
  113|      0|            }
  114|    268|        }
  115|       |
  116|  22.1k|        fn flip_colors(link: &mut Link<T>) {
  117|  22.1k|            if let Some(node) = link.as_mut() {
  118|  22.1k|                node.color = match node.color {
  119|      0|                    | Color::Red => Color::Black,
  120|  22.1k|                    | Color::Black => Color::Red,
  121|       |                };
  122|  22.1k|                if let Some(left) = node.left.as_mut() {
  123|  22.1k|                    left.color = match left.color {
  124|  22.1k|                        | Color::Red => Color::Black,
  125|      0|                        | Color::Black => Color::Red,
  126|       |                    };
  127|      0|                }
  128|  22.1k|                if let Some(right) = node.right.as_mut() {
  129|  22.1k|                    right.color = match right.color {
  130|  22.1k|                        | Color::Red => Color::Black,
  131|      0|                        | Color::Black => Color::Red,
  132|       |                    };
  133|      0|                }
  134|      0|            }
  135|  22.1k|        }
  136|       |
  137|   115k|        fn fix_up(link: &mut Link<T>) {
  138|   115k|            let rotate_left_needed = match link {
  139|   115k|                | Some(node) => Self::is_red(&node.right) && !Self::is_red(&node.left),
                                                                           ^44.9k
  140|      0|                | None => false,
  141|       |            };
  142|   115k|            if rotate_left_needed {
  143|  22.9k|                Self::rotate_left(link);
  144|  92.6k|            }
  145|       |
  146|   115k|            let rotate_right_needed = match link {
  147|   115k|                | Some(node) => {
  148|   115k|                    if let Some(left) = node.left.as_ref() {
  149|   115k|                        Self::is_red(&node.left) && Self::is_red(&left.left)
                                                                  ^75.4k       ^75.4k
  150|       |                    } else {
  151|      0|                        false
  152|       |                    }
  153|       |                }
  154|      0|                | None => false,
  155|       |            };
  156|   115k|            if rotate_right_needed {
  157|    268|                Self::rotate_right(link);
  158|   115k|            }
  159|       |
  160|   115k|            let flip_needed = match link {
  161|   115k|                | Some(node) => Self::is_red(&node.left) && Self::is_red(&node.right),
                                                                          ^75.4k       ^75.4k
  162|      0|                | None => false,
  163|       |            };
  164|   115k|            if flip_needed {
  165|  22.1k|                Self::flip_colors(link);
  166|  93.4k|            }
  167|       |
  168|   115k|            if let Some(node) = link.as_mut() {
  169|   115k|                Self::update(node);
  170|   115k|            }
                          ^0
  171|   115k|        }
  172|       |
  173|   140k|        fn insert_link(link: &mut Link<T>, value: T) {
  174|   140k|            if let Some(node) = link.as_mut() {
                                      ^115k
  175|   115k|                if value < node.key {
  176|  2.55k|                    Self::insert_link(&mut node.left, value);
  177|   113k|                } else if value > node.key {
  178|   113k|                    Self::insert_link(&mut node.right, value);
  179|   113k|                } else {
  180|      5|                    return;
  181|       |                }
  182|       |            } else {
  183|  24.9k|                *link = Some(Box::new(Node::new(value)));
  184|  24.9k|                return;
  185|       |            }
  186|   115k|            Self::fix_up(link);
  187|   140k|        }
  188|       |
  189|  1.89k|        fn find_link<'a>(link: &'a Link<T>, target: &T) -> Option<&'a T> {
  190|  1.89k|            match link {
  191|     16|                | None => None,
  192|  1.87k|                | Some(node) => {
  193|  1.87k|                    if target == &node.key {
  194|    429|                        Some(&node.key)
  195|  1.44k|                    } else if target < &node.key {
  196|    418|                        Self::find_link(&node.left, target)
  197|       |                    } else {
  198|  1.02k|                        Self::find_link(&node.right, target)
  199|       |                    }
  200|       |                }
  201|       |            }
  202|  1.89k|        }
  203|       |
  204|    328|        fn min_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  205|    328|            match link {
  206|      5|                | None => None,
  207|    323|                | Some(node) => match node.left {
  208|     75|                    | None => Some(&node.key),
  209|    248|                    | Some(_) => Self::min_link(&node.left),
  210|       |                },
  211|       |            }
  212|    328|        }
  213|       |
  214|    304|        fn max_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  215|    304|            match link {
  216|      5|                | None => None,
  217|    299|                | Some(node) => match node.right {
  218|     75|                    | None => Some(&node.key),
  219|    224|                    | Some(_) => Self::max_link(&node.right),
  220|       |                },
  221|       |            }
  222|    304|        }
  223|       |
  224|  59.2k|        fn in_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  225|  59.2k|            if let Some(node) = link {
                                      ^29.4k
  226|  29.4k|                Self::in_order_collect(&node.left, out);
  227|  29.4k|                out.push(node.key.clone());
  228|  29.4k|                Self::in_order_collect(&node.right, out);
  229|  29.7k|            }
  230|  59.2k|        }
  231|       |
  232|      7|        fn pre_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  233|      7|            if let Some(node) = link {
                                      ^3
  234|      3|                out.push(node.key.clone());
  235|      3|                Self::pre_order_collect(&node.left, out);
  236|      3|                Self::pre_order_collect(&node.right, out);
  237|      4|            }
  238|      7|        }
  239|       |    }
  240|       |
  241|       |    impl<T: StTInMtT + Ord> BSTRBMtEphTrait<T> for BSTRBMtEph<T> {
  242|    410|        fn new() -> Self {
  243|    410|            BSTRBMtEph {
  244|    410|                root: Arc::new(RwLock::new(None)),
  245|    410|            }
  246|    410|        }
  247|       |
  248|  24.9k|        fn insert(&self, value: T) {
  249|  24.9k|            let mut guard = self.root.write().unwrap();
  250|  24.9k|            Self::insert_link(&mut *guard, value);
  251|  24.9k|            if let Some(node) = guard.as_mut() {
  252|  24.9k|                node.color = Color::Black;
  253|  24.9k|            }
                          ^0
  254|  24.9k|        }
  255|       |
  256|    445|        fn find(&self, target: &T) -> Option<T> {
  257|    445|            let guard = self.root.read().unwrap();
  258|    445|            Self::find_link(&*guard, target).cloned()
  259|    445|        }
  260|       |
  261|    403|        fn contains(&self, target: &T) -> B { self.find(target).is_some() }
  262|       |
  263|    465|        fn size(&self) -> N {
  264|    465|            let guard = self.root.read().unwrap();
  265|    465|            Self::size_link(&*guard)
  266|    465|        }
  267|       |
  268|     10|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
                                                                      ^7            ^3
  269|       |
  270|     18|        fn height(&self) -> N {
  271|  12.1k|            fn height_rec<T: StTInMtT + Ord>(link: &Link<T>) -> N {
  272|  12.1k|                match link {
  273|  6.09k|                    | None => 0,
  274|  6.07k|                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),
  275|       |                }
  276|  12.1k|            }
  277|     18|            let guard = self.root.read().unwrap();
  278|     18|            height_rec(&*guard)
  279|     18|        }
  280|       |
  281|     80|        fn minimum(&self) -> Option<T> {
  282|     80|            let guard = self.root.read().unwrap();
  283|     80|            Self::min_link(&*guard).cloned()
  284|     80|        }
  285|       |
  286|     80|        fn maximum(&self) -> Option<T> {
  287|     80|            let guard = self.root.read().unwrap();
  288|     80|            Self::max_link(&*guard).cloned()
  289|     80|        }
  290|       |
  291|    358|        fn in_order(&self) -> ArraySeqStPerS<T> {
  292|    358|            let guard = self.root.read().unwrap();
  293|    358|            let mut out = Vec::with_capacity(Self::size_link(&*guard));
  294|    358|            Self::in_order_collect(&*guard, &mut out);
  295|    358|            ArraySeqStPerS::from_vec(out)
  296|    358|        }
  297|       |
  298|      1|        fn pre_order(&self) -> ArraySeqStPerS<T> {
  299|      1|            let guard = self.root.read().unwrap();
  300|      1|            let mut out = Vec::with_capacity(Self::size_link(&*guard));
  301|      1|            Self::pre_order_collect(&*guard, &mut out);
  302|      1|            ArraySeqStPerS::from_vec(out)
  303|      1|        }
  304|       |    }
  305|       |
  306|       |    #[macro_export]
  307|       |    macro_rules! BSTRBMtEphLit {
  308|       |        () => {
  309|       |            < $crate::Chap37::BSTRBMtEph::BSTRBMtEph::BSTRBMtEph<_> as $crate::Chap37::BSTRBMtEph::BSTRBMtEph::BSTRBMtEphTrait<_> >::new()
  310|       |        };
  311|       |        ( $( $x:expr ),* $(,)? ) => {{
  312|       |            let __tree = < $crate::Chap37::BSTRBMtEph::BSTRBMtEph::BSTRBMtEph<_> as $crate::Chap37::BSTRBMtEph::BSTRBMtEph::BSTRBMtEphTrait<_> >::new();
  313|       |            $( __tree.insert($x); )*
  314|       |            __tree
  315|       |        }};
  316|       |    }
  317|       |
  318|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap37/BSTRBStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Ephemeral Red-Black balanced binary search tree with `find` support and public helpers.
    3|       |
    4|       |pub mod BSTRBStEph {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    8|       |    use crate::Types::Types::*;
    9|       |
   10|       |    #[derive(Clone, Copy, PartialEq, Eq, Debug)]
   11|       |    enum Color {
   12|       |        Red,
   13|       |        Black,
   14|       |    }
   15|       |
   16|       |    type Link<T> = Option<Box<Node<T>>>;
   17|       |
   18|       |    #[derive(Debug, Clone)]
   19|       |    struct Node<T: StT + Ord> {
   20|       |        key: T,
   21|       |        color: Color,
   22|       |        size: N,
   23|       |        left: Link<T>,
   24|       |        right: Link<T>,
   25|       |    }
   26|       |
   27|       |    impl<T: StT + Ord> Node<T> {
   28|    174|        fn new(key: T) -> Self {
   29|    174|            Node {
   30|    174|                key,
   31|    174|                color: Color::Red,
   32|    174|                size: 1,
   33|    174|                left: None,
   34|    174|                right: None,
   35|    174|            }
   36|    174|        }
   37|       |    }
   38|       |
   39|       |    #[derive(Debug, Clone)]
   40|       |    pub struct BSTRBStEph<T: StT + Ord> {
   41|       |        root: Link<T>,
   42|       |    }
   43|       |
   44|       |    pub type BSTreeRB<T> = BSTRBStEph<T>;
   45|       |
   46|       |    pub trait BSTRBStEphTrait<T: StT + Ord> {
   47|       |        /// claude-4-sonet: Work (1), Span (1)
   48|       |        fn new() -> Self;
   49|       |        /// claude-4-sonet: Work (1), Span (1)
   50|       |        fn size(&self) -> N;
   51|       |        /// claude-4-sonet: Work (1), Span (1)
   52|       |        fn is_empty(&self) -> B;
   53|       |        /// claude-4-sonet: Work (n), Span (n)
   54|       |        fn height(&self) -> N;
   55|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   56|       |        fn insert(&mut self, value: T);
   57|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   58|       |        fn find(&self, target: &T) -> Option<&T>;
   59|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   60|       |        fn contains(&self, target: &T) -> B;
   61|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   62|       |        fn minimum(&self) -> Option<&T>;
   63|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   64|       |        fn maximum(&self) -> Option<&T>;
   65|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   66|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   67|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   68|       |        fn pre_order(&self) -> ArraySeqStPerS<T>;
   69|       |    }
   70|       |
   71|       |    impl<T: StT + Ord> Default for BSTRBStEph<T> {
   72|      1|        fn default() -> Self { Self::new() }
   73|       |    }
   74|       |
   75|       |    impl<T: StT + Ord> BSTRBStEph<T> {
   76|       |        // Private helper methods only - no public delegation
   77|       |
   78|  2.93k|        fn is_red(link: &Link<T>) -> bool { matches!(link, Some(node) if node.color == Color::Red) }
                                                          ^1.34k   ^2.58k     ^2.58k   ^2.58k                 ^1.34k
   79|       |
   80|  1.96k|        fn size_link(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }
   81|       |
   82|    973|        fn update(node: &mut Node<T>) { node.size = 1 + Self::size_link(&node.left) + Self::size_link(&node.right); }
   83|       |
   84|    107|        fn rotate_left(link: &mut Link<T>) {
   85|    107|            if let Some(mut h) = link.take() {
   86|    107|                if let Some(mut x) = h.right.take() {
   87|    107|                    h.right = x.left.take();
   88|    107|                    Self::update(&mut h);
   89|    107|                    x.color = h.color;
   90|    107|                    h.color = Color::Red;
   91|    107|                    x.left = Some(h);
   92|    107|                    Self::update(x.left.as_mut().unwrap());
   93|    107|                    Self::update(&mut x);
   94|    107|                    *link = Some(x);
   95|    107|                } else {
   96|      0|                    *link = Some(h);
   97|      0|                }
   98|      0|            }
   99|    107|        }
  100|       |
  101|     11|        fn rotate_right(link: &mut Link<T>) {
  102|     11|            if let Some(mut h) = link.take() {
  103|     11|                if let Some(mut x) = h.left.take() {
  104|     11|                    h.left = x.right.take();
  105|     11|                    Self::update(&mut h);
  106|     11|                    x.color = h.color;
  107|     11|                    h.color = Color::Red;
  108|     11|                    x.right = Some(h);
  109|     11|                    Self::update(x.right.as_mut().unwrap());
  110|     11|                    Self::update(&mut x);
  111|     11|                    *link = Some(x);
  112|     11|                } else {
  113|      0|                    *link = Some(h);
  114|      0|                }
  115|      0|            }
  116|     11|        }
  117|       |
  118|    132|        fn flip_colors(link: &mut Link<T>) {
  119|    132|            if let Some(node) = link.as_mut() {
  120|    132|                node.color = match node.color {
  121|      0|                    | Color::Red => Color::Black,
  122|    132|                    | Color::Black => Color::Red,
  123|       |                };
  124|    132|                if let Some(left) = node.left.as_mut() {
  125|    132|                    left.color = match left.color {
  126|    132|                        | Color::Red => Color::Black,
  127|      0|                        | Color::Black => Color::Red,
  128|       |                    };
  129|      0|                }
  130|    132|                if let Some(right) = node.right.as_mut() {
  131|    132|                    right.color = match right.color {
  132|    132|                        | Color::Red => Color::Black,
  133|      0|                        | Color::Black => Color::Red,
  134|       |                    };
  135|      0|                }
  136|      0|            }
  137|    132|        }
  138|       |
  139|    619|        fn fix_up(link: &mut Link<T>) {
  140|    619|            if Self::is_red(&link.as_ref().unwrap().right) && !Self::is_red(&link.as_ref().unwrap().left) {
                                                                            ^228^228          ^228
  141|    107|                Self::rotate_left(link);
  142|    512|            }
  143|    619|            if Self::is_red(&link.as_ref().unwrap().left)
  144|    426|                && Self::is_red(&link.as_ref().unwrap().left.as_ref().unwrap().left)
  145|     11|            {
  146|     11|                Self::rotate_right(link);
  147|    608|            }
  148|    619|            if Self::is_red(&link.as_ref().unwrap().left) && Self::is_red(&link.as_ref().unwrap().right) {
                                                                           ^426         ^426^426
  149|    132|                Self::flip_colors(link);
  150|    487|            }
  151|    619|            if let Some(node) = link.as_mut() {
  152|    619|                Self::update(node);
  153|    619|            }
                          ^0
  154|    619|        }
  155|       |
  156|    794|        fn insert_link(link: &mut Link<T>, value: T) {
  157|    794|            if let Some(node) = link.as_mut() {
                                      ^620
  158|    620|                if value < node.key {
  159|     78|                    Self::insert_link(&mut node.left, value);
  160|    542|                } else if value > node.key {
  161|    541|                    Self::insert_link(&mut node.right, value);
  162|    541|                } else {
  163|      1|                    return;
  164|       |                }
  165|       |            } else {
  166|    174|                *link = Some(Box::new(Node::new(value)));
  167|    174|                return;
  168|       |            }
  169|    619|            Self::fix_up(link);
  170|    794|        }
  171|       |
  172|  1.19k|        fn find_link<'a>(link: &'a Link<T>, target: &T) -> Option<&'a T> {
  173|  1.19k|            match link {
  174|      6|                | None => None,
  175|  1.18k|                | Some(node) => {
  176|  1.18k|                    if target == &node.key {
  177|    210|                        Some(&node.key)
  178|    976|                    } else if target < &node.key {
  179|    506|                        Self::find_link(&node.left, target)
  180|       |                    } else {
  181|    470|                        Self::find_link(&node.right, target)
  182|       |                    }
  183|       |                }
  184|       |            }
  185|  1.19k|        }
  186|       |
  187|     19|        fn min_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  188|     19|            match link {
  189|      2|                | None => None,
  190|     17|                | Some(node) => match node.left {
  191|      6|                    | None => Some(&node.key),
  192|     11|                    | Some(_) => Self::min_link(&node.left),
  193|       |                },
  194|       |            }
  195|     19|        }
  196|       |
  197|     17|        fn max_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  198|     17|            match link {
  199|      2|                | None => None,
  200|     15|                | Some(node) => match node.right {
  201|      6|                    | None => Some(&node.key),
  202|      9|                    | Some(_) => Self::max_link(&node.right),
  203|       |                },
  204|       |            }
  205|     17|        }
  206|       |
  207|     96|        fn in_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  208|     96|            if let Some(node) = link {
                                      ^45
  209|     45|                Self::in_order_collect(&node.left, out);
  210|     45|                out.push(node.key.clone());
  211|     45|                Self::in_order_collect(&node.right, out);
  212|     51|            }
  213|     96|        }
  214|       |
  215|     16|        fn pre_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  216|     16|            if let Some(node) = link {
                                      ^7
  217|      7|                out.push(node.key.clone());
  218|      7|                Self::pre_order_collect(&node.left, out);
  219|      7|                Self::pre_order_collect(&node.right, out);
  220|      9|            }
  221|     16|        }
  222|       |    }
  223|       |
  224|       |    impl<T: StT + Ord> BSTRBStEphTrait<T> for BSTRBStEph<T> {
  225|     17|        fn new() -> Self { BSTRBStEph { root: None } }
  226|       |
  227|     21|        fn size(&self) -> N { Self::size_link(&self.root) }
  228|       |
  229|      5|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
                                                                      ^3            ^2
  230|       |
  231|     10|        fn height(&self) -> N {
  232|    308|            fn height_rec<T: StT + Ord>(link: &Link<T>) -> N {
  233|    308|                match link {
  234|    159|                    | None => 0,
  235|    149|                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),
  236|       |                }
  237|    308|            }
  238|     10|            height_rec(&self.root)
  239|     10|        }
  240|       |
  241|    175|        fn insert(&mut self, value: T) {
  242|    175|            Self::insert_link(&mut self.root, value);
  243|    175|            if let Some(node) = self.root.as_mut() {
  244|    175|                node.color = Color::Black;
  245|    175|            }
                          ^0
  246|    175|        }
  247|       |
  248|    216|        fn find(&self, target: &T) -> Option<&T> { Self::find_link(&self.root, target) }
  249|       |
  250|    111|        fn contains(&self, target: &T) -> B { self.find(target).is_some() }
  251|       |
  252|      8|        fn minimum(&self) -> Option<&T> { Self::min_link(&self.root) }
  253|       |
  254|      8|        fn maximum(&self) -> Option<&T> { Self::max_link(&self.root) }
  255|       |
  256|      6|        fn in_order(&self) -> ArraySeqStPerS<T> {
  257|      6|            let mut out = Vec::with_capacity(self.size());
  258|      6|            Self::in_order_collect(&self.root, &mut out);
  259|      6|            ArraySeqStPerS::from_vec(out)
  260|      6|        }
  261|       |
  262|      2|        fn pre_order(&self) -> ArraySeqStPerS<T> {
  263|      2|            let mut out = Vec::with_capacity(self.size());
  264|      2|            Self::pre_order_collect(&self.root, &mut out);
  265|      2|            ArraySeqStPerS::from_vec(out)
  266|      2|        }
  267|       |    }
  268|       |
  269|       |    #[macro_export]
  270|       |    macro_rules! BSTRBStEphLit {
  271|       |        () => {
  272|       |            < $crate::Chap37::BSTRBStEph::BSTRBStEph::BSTRBStEph<_> as $crate::Chap37::BSTRBStEph::BSTRBStEph::BSTRBStEphTrait<_> >::new()
  273|       |        };
  274|       |        ( $( $x:expr ),* $(,)? ) => {{
  275|       |            let mut __tree = < $crate::Chap37::BSTRBStEph::BSTRBStEph::BSTRBStEph<_> as $crate::Chap37::BSTRBStEph::BSTRBStEph::BSTRBStEphTrait<_> >::new();
  276|       |            $( __tree.insert($x); )*
  277|       |            __tree
  278|       |        }};
  279|       |    }
  280|       |
  281|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap37/BSTSetAVLMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Set interface built atop the AVL multi-threaded BST implementation.
    3|       |
    4|       |pub mod BSTSetAVLMtEph {
    5|       |
    6|       |    use std::collections::BTreeSet;
    7|       |
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |    use crate::Chap37::BSTAVLMtEph::BSTAVLMtEph::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    #[derive(Debug, Clone)]
   13|       |    pub struct BSTSetAVLMtEph<T: StTInMtT + Ord> {
   14|       |        tree: BSTAVLMtEph<T>,
   15|       |    }
   16|       |
   17|       |    pub type BSTSetAVLMt<T> = BSTSetAVLMtEph<T>;
   18|       |
   19|       |    pub trait BSTSetAVLMtEphTrait<T: StTInMtT + Ord>: Sized {
   20|       |        /// claude-4-sonet: Work (1), Span (1)
   21|       |        fn empty() -> Self;
   22|       |        /// claude-4-sonet: Work (1), Span (1)
   23|       |        fn singleton(value: T) -> Self;
   24|       |        /// claude-4-sonet: Work (1), Span (1)
   25|       |        fn size(&self) -> N;
   26|       |        /// claude-4-sonet: Work (1), Span (1)
   27|       |        fn is_empty(&self) -> B;
   28|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   29|       |        fn find(&self, value: &T) -> Option<T>;
   30|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   31|       |        fn contains(&self, value: &T) -> B;
   32|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   33|       |        fn minimum(&self) -> Option<T>;
   34|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   35|       |        fn maximum(&self) -> Option<T>;
   36|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   37|       |        fn insert(&mut self, value: T);
   38|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   39|       |        fn delete(&mut self, target: &T);
   40|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   41|       |        fn union(&self, other: &Self) -> Self;
   42|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   43|       |        fn intersection(&self, other: &Self) -> Self;
   44|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   45|       |        fn difference(&self, other: &Self) -> Self;
   46|       |        /// claude-4-sonet: Work (log n), Span (log n)
   47|       |        fn split(&self, pivot: &T) -> (Self, B, Self);
   48|       |        /// claude-4-sonet: Work (log(|left| + |right|)), Span (log(|left| + |right|))
   49|       |        fn join_pair(left: Self, right: Self) -> Self;
   50|       |        /// claude-4-sonet: Work (log(|left| + |right|)), Span (log(|left| + |right|))
   51|       |        fn join_m(left: Self, pivot: T, right: Self) -> Self;
   52|       |        /// claude-4-sonet: Work (n), Span (n)
   53|       |        fn filter<F: FnMut(&T) -> bool>(&self, predicate: F) -> Self;
   54|       |        /// claude-4-sonet: Work (n), Span (n)
   55|       |        fn reduce<F: FnMut(T, T) -> T>(&self, op: F, base: T) -> T;
   56|       |        /// claude-4-sonet: Work (n), Span (n)
   57|       |        fn iter_in_order(&self) -> ArraySeqStPerS<T>;
   58|       |        /// claude-4-sonet: Work (1), Span (1)
   59|       |        fn as_tree(&self) -> &BSTAVLMtEph<T>;
   60|       |    }
   61|       |
   62|       |    impl<T: StTInMtT + Ord> BSTSetAVLMtEph<T> {
   63|     72|        pub fn empty() -> Self {
   64|     72|            Self {
   65|     72|                tree: BSTAVLMtEph::new(),
   66|     72|            }
   67|     72|        }
   68|       |
   69|      2|        pub fn singleton(value: T) -> Self {
   70|      2|            let tree = BSTAVLMtEph::new();
   71|      2|            tree.insert(value);
   72|      2|            Self { tree }
   73|      2|        }
   74|       |
   75|   198k|        pub fn size(&self) -> N { self.tree.size() }
   76|       |
   77|      4|        pub fn is_empty(&self) -> B { self.tree.is_empty() }
   78|       |
   79|      4|        pub fn find(&self, value: &T) -> Option<T> { self.tree.find(value) }
   80|       |
   81|   198k|        pub fn contains(&self, value: &T) -> B { self.tree.contains(value) }
   82|       |
   83|    417|        pub fn minimum(&self) -> Option<T> { self.tree.minimum() }
   84|       |
   85|    417|        pub fn maximum(&self) -> Option<T> { self.tree.maximum() }
   86|       |
   87|  1.34k|        pub fn insert(&mut self, value: T) { self.tree.insert(value); }
   88|       |
   89|      6|        pub fn delete(&mut self, target: &T) {
   90|      6|            let mut values = self.values_vec();
   91|     21|            if let Some(pos) = values.iter().position(|x| x == target) {
                                      ^6     ^6            ^6
   92|      6|                values.remove(pos);
   93|      6|                self.tree = Self::rebuild_from_vec(values);
   94|      6|            }
                          ^0
   95|      6|        }
   96|       |
   97|      4|        pub fn union(&self, other: &Self) -> Self {
   98|      4|            let mut merged: BTreeSet<T> = self.values_vec().into_iter().collect();
   99|      5|            for value in other.values_vec() {
                                       ^4    ^4
  100|      5|                merged.insert(value);
  101|      5|            }
  102|      4|            Self::from_sorted_iter(merged.into_iter())
  103|      4|        }
  104|       |
  105|      4|        pub fn intersection(&self, other: &Self) -> Self {
  106|      4|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  107|      4|            let filtered: Vec<T> = self
  108|      4|                .tree
  109|      4|                .in_order()
  110|      4|                .iter()
  111|     10|                .filter_map(|v| {
                               ^4
  112|     10|                    if other_values.contains(v) {
  113|      4|                        Some(v.clone())
  114|       |                    } else {
  115|      6|                        None
  116|       |                    }
  117|     10|                })
  118|      4|                .collect();
  119|      4|            Self::from_sorted_iter(filtered.into_iter())
  120|      4|        }
  121|       |
  122|      3|        pub fn difference(&self, other: &Self) -> Self {
  123|      3|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  124|      3|            let filtered: Vec<T> = self
  125|      3|                .tree
  126|      3|                .in_order()
  127|      3|                .iter()
  128|      8|                .filter_map(|v| {
                               ^3
  129|      8|                    if !other_values.contains(v) {
  130|      5|                        Some(v.clone())
  131|       |                    } else {
  132|      3|                        None
  133|       |                    }
  134|      8|                })
  135|      3|                .collect();
  136|      3|            Self::from_sorted_iter(filtered.into_iter())
  137|      3|        }
  138|       |
  139|      6|        pub fn split(&self, pivot: &T) -> (Self, B, Self) {
  140|      6|            let mut left: Vec<T> = Vec::new();
  141|      6|            let mut right: Vec<T> = Vec::new();
  142|      6|            let mut found = false;
  143|     31|            for value in self.tree.in_order().iter() {
                                       ^6                   ^6
  144|     31|                if value < pivot {
  145|     14|                    left.push(value.clone());
  146|     17|                } else if value > pivot {
  147|     12|                    right.push(value.clone());
  148|     12|                } else {
  149|      5|                    found = true;
  150|      5|                }
  151|       |            }
  152|      6|            (
  153|      6|                Self::from_sorted_iter(left.into_iter()),
  154|      6|                found,
  155|      6|                Self::from_sorted_iter(right.into_iter()),
  156|      6|            )
  157|      6|        }
  158|       |
  159|      3|        pub fn join_pair(left: Self, right: Self) -> Self {
  160|      3|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  161|      5|            for value in right.values_vec() {
                                       ^3    ^3
  162|      5|                combined.insert(value);
  163|      5|            }
  164|      3|            Self::from_sorted_iter(combined.into_iter())
  165|      3|        }
  166|       |
  167|      5|        pub fn join_m(left: Self, pivot: T, right: Self) -> Self {
  168|      5|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  169|      5|            combined.insert(pivot);
  170|     13|            for value in right.values_vec() {
                                       ^5    ^5
  171|     13|                combined.insert(value);
  172|     13|            }
  173|      5|            Self::from_sorted_iter(combined.into_iter())
  174|      5|        }
  175|       |
  176|     13|        pub fn filter<F>(&self, mut predicate: F) -> Self
  177|     13|        where
  178|     13|            F: FnMut(&T) -> bool,
  179|       |        {
  180|     13|            let filtered: Vec<T> = self
  181|     13|                .tree
  182|     13|                .in_order()
  183|     13|                .iter()
  184|     94|                .filter_map(|v| if predicate(v) { Some(v.clone()) } else { None })
                               ^13                              ^47                      ^47
  185|     13|                .collect();
  186|     13|            Self::from_sorted_iter(filtered.into_iter())
  187|     13|        }
  188|       |
  189|      5|        pub fn reduce<F>(&self, mut op: F, base: T) -> T
  190|      5|        where
  191|      5|            F: FnMut(T, T) -> T,
  192|       |        {
  193|      5|            self.tree
  194|      5|                .in_order()
  195|      5|                .iter()
  196|     25|                .fold(base, |acc, value| op(acc, value.clone()))
                               ^5   ^5
  197|      5|        }
  198|       |
  199|      4|        pub fn iter_in_order(&self) -> ArraySeqStPerS<T> { self.tree.in_order() }
  200|       |
  201|      1|        pub fn as_tree(&self) -> &BSTAVLMtEph<T> { &self.tree }
  202|       |
  203|     37|        fn values_vec(&self) -> Vec<T> { self.tree.in_order().iter().cloned().collect() }
  204|       |
  205|      6|        fn rebuild_from_vec(values: Vec<T>) -> BSTAVLMtEph<T> {
  206|      6|            let tree = BSTAVLMtEph::new();
  207|     36|            for value in values {
                              ^30
  208|     30|                tree.insert(value);
  209|     30|            }
  210|      6|            tree
  211|      6|        }
  212|       |
  213|     44|        fn from_sorted_iter<I>(values: I) -> Self
  214|     44|        where
  215|     44|            I: IntoIterator<Item = T>,
  216|       |        {
  217|     44|            let tree = BSTAVLMtEph::new();
  218|    176|            for value in values {
                              ^132
  219|    132|                tree.insert(value);
  220|    132|            }
  221|     44|            Self { tree }
  222|     44|        }
  223|       |    }
  224|       |
  225|       |    impl<T: StTInMtT + Ord> BSTSetAVLMtEphTrait<T> for BSTSetAVLMtEph<T> {
  226|      3|        fn empty() -> Self { Self::empty() }
  227|       |
  228|      1|        fn singleton(value: T) -> Self { Self::singleton(value) }
  229|       |
  230|      0|        fn size(&self) -> N { self.tree.size() }
  231|       |
  232|      0|        fn is_empty(&self) -> B { self.tree.is_empty() }
  233|       |
  234|      1|        fn find(&self, value: &T) -> Option<T> { self.tree.find(value) }
  235|       |
  236|      1|        fn contains(&self, value: &T) -> B { self.tree.contains(value) }
  237|       |
  238|      1|        fn minimum(&self) -> Option<T> { self.tree.minimum() }
  239|       |
  240|      1|        fn maximum(&self) -> Option<T> { self.tree.maximum() }
  241|       |
  242|      1|        fn insert(&mut self, value: T) { self.tree.insert(value); }
  243|       |
  244|      1|        fn delete(&mut self, target: &T) { BSTSetAVLMtEph::delete(self, target) }
  245|       |
  246|      1|        fn union(&self, other: &Self) -> Self { BSTSetAVLMtEph::union(self, other) }
  247|       |
  248|      1|        fn intersection(&self, other: &Self) -> Self { BSTSetAVLMtEph::intersection(self, other) }
  249|       |
  250|      1|        fn difference(&self, other: &Self) -> Self { BSTSetAVLMtEph::difference(self, other) }
  251|       |
  252|      1|        fn split(&self, pivot: &T) -> (Self, B, Self) { BSTSetAVLMtEph::split(self, pivot) }
  253|       |
  254|      1|        fn join_pair(left: Self, right: Self) -> Self { BSTSetAVLMtEph::join_pair(left, right) }
  255|       |
  256|      1|        fn join_m(left: Self, pivot: T, right: Self) -> Self { BSTSetAVLMtEph::join_m(left, pivot, right) }
  257|       |
  258|      1|        fn filter<F: FnMut(&T) -> bool>(&self, predicate: F) -> Self { BSTSetAVLMtEph::filter(self, predicate) }
  259|       |
  260|      1|        fn reduce<F: FnMut(T, T) -> T>(&self, op: F, base: T) -> T { BSTSetAVLMtEph::reduce(self, op, base) }
  261|       |
  262|      1|        fn iter_in_order(&self) -> ArraySeqStPerS<T> { self.tree.in_order() }
  263|       |
  264|      1|        fn as_tree(&self) -> &BSTAVLMtEph<T> { &self.tree }
  265|       |    }
  266|       |
  267|       |    #[macro_export]
  268|       |    macro_rules! BSTSetAVLMtEphLit {
  269|       |        () => {
  270|       |            < $crate::Chap37::BSTSetAVLMtEph::BSTSetAVLMtEph::BSTSetAVLMtEph<_> as $crate::Chap37::BSTSetAVLMtEph::BSTSetAVLMtEph::BSTSetAVLMtEphTrait<_> >::empty()
  271|       |        };
  272|       |        ( $( $x:expr ),* $(,)? ) => {{
  273|       |            let mut __set = < $crate::Chap37::BSTSetAVLMtEph::BSTSetAVLMtEph::BSTSetAVLMtEph<_> as $crate::Chap37::BSTSetAVLMtEph::BSTSetAVLMtEph::BSTSetAVLMtEphTrait<_> >::empty();
  274|       |            $( __set.insert($x); )*
  275|       |            __set
  276|       |        }};
  277|       |    }
  278|       |
  279|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap37/BSTSetBBAlphaMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Set interface built atop the BB-Alpha multi-threaded BST implementation.
    3|       |
    4|       |pub mod BSTSetBBAlphaMtEph {
    5|       |
    6|       |    use std::collections::BTreeSet;
    7|       |
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |    use crate::Chap37::BSTBBAlphaMtEph::BSTBBAlphaMtEph::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    #[derive(Debug, Clone)]
   13|       |    pub struct BSTSetBBAlphaMtEph<T: StTInMtT + Ord> {
   14|       |        tree: BSTBBAlphaMtEph<T>,
   15|       |    }
   16|       |
   17|       |    pub type BSTSetBBAlphaMt<T> = BSTSetBBAlphaMtEph<T>;
   18|       |
   19|       |    pub trait BSTSetBBAlphaMtEphTrait<T: StTInMtT + Ord>: Sized {
   20|       |        /// claude-4-sonet: Work (1), Span (1)
   21|       |        fn empty() -> Self;
   22|       |        /// claude-4-sonet: Work (1), Span (1)
   23|       |        fn singleton(value: T) -> Self;
   24|       |        /// claude-4-sonet: Work (1), Span (1)
   25|       |        fn size(&self) -> N;
   26|       |        /// claude-4-sonet: Work (1), Span (1)
   27|       |        fn is_empty(&self) -> B;
   28|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   29|       |        fn find(&self, value: &T) -> Option<T>;
   30|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   31|       |        fn contains(&self, value: &T) -> B;
   32|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   33|       |        fn minimum(&self) -> Option<T>;
   34|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   35|       |        fn maximum(&self) -> Option<T>;
   36|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   37|       |        fn insert(&mut self, value: T);
   38|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   39|       |        fn delete(&mut self, target: &T);
   40|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   41|       |        fn union(&self, other: &Self) -> Self;
   42|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   43|       |        fn intersection(&self, other: &Self) -> Self;
   44|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   45|       |        fn difference(&self, other: &Self) -> Self;
   46|       |        /// claude-4-sonet: Work (log n), Span (log n)
   47|       |        fn split(&self, pivot: &T) -> (Self, B, Self);
   48|       |        /// claude-4-sonet: Work (log(|left| + |right|)), Span (log(|left| + |right|))
   49|       |        fn join_pair(left: Self, right: Self) -> Self;
   50|       |        /// claude-4-sonet: Work (log(|left| + |right|)), Span (log(|left| + |right|))
   51|       |        fn join_m(left: Self, pivot: T, right: Self) -> Self;
   52|       |        /// claude-4-sonet: Work (n), Span (n)
   53|       |        fn filter<F: FnMut(&T) -> bool>(&self, predicate: F) -> Self;
   54|       |        /// claude-4-sonet: Work (n), Span (n)
   55|       |        fn reduce<F: FnMut(T, T) -> T>(&self, op: F, base: T) -> T;
   56|       |        /// claude-4-sonet: Work (n), Span (n)
   57|       |        fn iter_in_order(&self) -> ArraySeqStPerS<T>;
   58|       |        /// claude-4-sonet: Work (1), Span (1)
   59|       |        fn as_tree(&self) -> &BSTBBAlphaMtEph<T>;
   60|       |    }
   61|       |
   62|       |    impl<T: StTInMtT + Ord> BSTSetBBAlphaMtEph<T> {
   63|     65|        pub fn empty() -> Self {
   64|     65|            Self {
   65|     65|                tree: BSTBBAlphaMtEph::new(),
   66|     65|            }
   67|     65|        }
   68|       |
   69|      2|        pub fn singleton(value: T) -> Self {
   70|      2|            let tree = BSTBBAlphaMtEph::new();
   71|      2|            tree.insert(value);
   72|      2|            Self { tree }
   73|      2|        }
   74|       |
   75|     63|        pub fn size(&self) -> N { self.tree.size() }
   76|       |
   77|      4|        pub fn is_empty(&self) -> B { self.tree.is_empty() }
   78|       |
   79|      4|        pub fn find(&self, value: &T) -> Option<T> { self.tree.find(value) }
   80|       |
   81|     45|        pub fn contains(&self, value: &T) -> B { self.tree.contains(value) }
   82|       |
   83|     12|        pub fn minimum(&self) -> Option<T> { self.tree.minimum() }
   84|       |
   85|     12|        pub fn maximum(&self) -> Option<T> { self.tree.maximum() }
   86|       |
   87|    494|        pub fn insert(&mut self, value: T) { self.tree.insert(value); }
   88|       |
   89|      6|        pub fn delete(&mut self, target: &T) {
   90|      6|            let mut values = self.values_vec();
   91|     21|            if let Some(pos) = values.iter().position(|x| x == target) {
                                      ^6     ^6            ^6
   92|      6|                values.remove(pos);
   93|      6|                self.tree = Self::rebuild_from_vec(values);
   94|      6|            }
                          ^0
   95|      6|        }
   96|       |
   97|      4|        pub fn union(&self, other: &Self) -> Self {
   98|      4|            let mut merged: BTreeSet<T> = self.values_vec().into_iter().collect();
   99|      5|            for value in other.values_vec() {
                                       ^4    ^4
  100|      5|                merged.insert(value);
  101|      5|            }
  102|      4|            Self::from_sorted_iter(merged.into_iter())
  103|      4|        }
  104|       |
  105|      4|        pub fn intersection(&self, other: &Self) -> Self {
  106|      4|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  107|      4|            let filtered: Vec<T> = self
  108|      4|                .tree
  109|      4|                .in_order()
  110|      4|                .iter()
  111|     10|                .filter_map(|v| {
                               ^4
  112|     10|                    if other_values.contains(v) {
  113|      4|                        Some(v.clone())
  114|       |                    } else {
  115|      6|                        None
  116|       |                    }
  117|     10|                })
  118|      4|                .collect();
  119|      4|            Self::from_sorted_iter(filtered.into_iter())
  120|      4|        }
  121|       |
  122|      3|        pub fn difference(&self, other: &Self) -> Self {
  123|      3|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  124|      3|            let filtered: Vec<T> = self
  125|      3|                .tree
  126|      3|                .in_order()
  127|      3|                .iter()
  128|      8|                .filter_map(|v| {
                               ^3
  129|      8|                    if !other_values.contains(v) {
  130|      5|                        Some(v.clone())
  131|       |                    } else {
  132|      3|                        None
  133|       |                    }
  134|      8|                })
  135|      3|                .collect();
  136|      3|            Self::from_sorted_iter(filtered.into_iter())
  137|      3|        }
  138|       |
  139|      7|        pub fn split(&self, pivot: &T) -> (Self, B, Self) {
  140|      7|            let mut left: Vec<T> = Vec::new();
  141|      7|            let mut right: Vec<T> = Vec::new();
  142|      7|            let mut found = false;
  143|     51|            for value in self.tree.in_order().iter() {
                                       ^7                   ^7
  144|     51|                if value < pivot {
  145|     23|                    left.push(value.clone());
  146|     28|                } else if value > pivot {
  147|     22|                    right.push(value.clone());
  148|     22|                } else {
  149|      6|                    found = true;
  150|      6|                }
  151|       |            }
  152|      7|            (
  153|      7|                Self::from_sorted_iter(left.into_iter()),
  154|      7|                found,
  155|      7|                Self::from_sorted_iter(right.into_iter()),
  156|      7|            )
  157|      7|        }
  158|       |
  159|      3|        pub fn join_pair(left: Self, right: Self) -> Self {
  160|      3|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  161|      5|            for value in right.values_vec() {
                                       ^3    ^3
  162|      5|                combined.insert(value);
  163|      5|            }
  164|      3|            Self::from_sorted_iter(combined.into_iter())
  165|      3|        }
  166|       |
  167|      6|        pub fn join_m(left: Self, pivot: T, right: Self) -> Self {
  168|      6|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  169|      6|            combined.insert(pivot);
  170|     23|            for value in right.values_vec() {
                                       ^6    ^6
  171|     23|                combined.insert(value);
  172|     23|            }
  173|      6|            Self::from_sorted_iter(combined.into_iter())
  174|      6|        }
  175|       |
  176|      7|        pub fn filter<F>(&self, mut predicate: F) -> Self
  177|      7|        where
  178|      7|            F: FnMut(&T) -> bool,
  179|       |        {
  180|      7|            let filtered: Vec<T> = self
  181|      7|                .tree
  182|      7|                .in_order()
  183|      7|                .iter()
  184|     39|                .filter_map(|v| if predicate(v) { Some(v.clone()) } else { None })
                               ^7                               ^16                      ^23
  185|      7|                .collect();
  186|      7|            Self::from_sorted_iter(filtered.into_iter())
  187|      7|        }
  188|       |
  189|      4|        pub fn reduce<F>(&self, mut op: F, base: T) -> T
  190|      4|        where
  191|      4|            F: FnMut(T, T) -> T,
  192|       |        {
  193|      4|            self.tree
  194|      4|                .in_order()
  195|      4|                .iter()
  196|     10|                .fold(base, |acc, value| op(acc, value.clone()))
                               ^4   ^4
  197|      4|        }
  198|       |
  199|      5|        pub fn iter_in_order(&self) -> ArraySeqStPerS<T> { self.tree.in_order() }
  200|       |
  201|      1|        pub fn as_tree(&self) -> &BSTBBAlphaMtEph<T> { &self.tree }
  202|       |
  203|     39|        fn values_vec(&self) -> Vec<T> { self.tree.in_order().iter().cloned().collect() }
  204|       |
  205|      6|        fn rebuild_from_vec(values: Vec<T>) -> BSTBBAlphaMtEph<T> {
  206|      6|            let tree = BSTBBAlphaMtEph::new();
  207|     36|            for value in values {
                              ^30
  208|     30|                tree.insert(value);
  209|     30|            }
  210|      6|            tree
  211|      6|        }
  212|       |
  213|     41|        fn from_sorted_iter<I>(values: I) -> Self
  214|     41|        where
  215|     41|            I: IntoIterator<Item = T>,
  216|       |        {
  217|     41|            let tree = BSTBBAlphaMtEph::new();
  218|    181|            for value in values {
                              ^140
  219|    140|                tree.insert(value);
  220|    140|            }
  221|     41|            Self { tree }
  222|     41|        }
  223|       |    }
  224|       |
  225|       |    impl<T: StTInMtT + Ord> BSTSetBBAlphaMtEphTrait<T> for BSTSetBBAlphaMtEph<T> {
  226|      3|        fn empty() -> Self { Self::empty() }
  227|       |
  228|      1|        fn singleton(value: T) -> Self { Self::singleton(value) }
  229|       |
  230|      0|        fn size(&self) -> N { self.tree.size() }
  231|       |
  232|      0|        fn is_empty(&self) -> B { self.tree.is_empty() }
  233|       |
  234|      1|        fn find(&self, value: &T) -> Option<T> { self.tree.find(value) }
  235|       |
  236|      1|        fn contains(&self, value: &T) -> B { self.tree.contains(value) }
  237|       |
  238|      1|        fn minimum(&self) -> Option<T> { self.tree.minimum() }
  239|       |
  240|      1|        fn maximum(&self) -> Option<T> { self.tree.maximum() }
  241|       |
  242|      1|        fn insert(&mut self, value: T) { self.tree.insert(value); }
  243|       |
  244|      1|        fn delete(&mut self, target: &T) { BSTSetBBAlphaMtEph::delete(self, target) }
  245|       |
  246|      1|        fn union(&self, other: &Self) -> Self { BSTSetBBAlphaMtEph::union(self, other) }
  247|       |
  248|      1|        fn intersection(&self, other: &Self) -> Self { BSTSetBBAlphaMtEph::intersection(self, other) }
  249|       |
  250|      1|        fn difference(&self, other: &Self) -> Self { BSTSetBBAlphaMtEph::difference(self, other) }
  251|       |
  252|      1|        fn split(&self, pivot: &T) -> (Self, B, Self) { BSTSetBBAlphaMtEph::split(self, pivot) }
  253|       |
  254|      1|        fn join_pair(left: Self, right: Self) -> Self { BSTSetBBAlphaMtEph::join_pair(left, right) }
  255|       |
  256|      1|        fn join_m(left: Self, pivot: T, right: Self) -> Self { BSTSetBBAlphaMtEph::join_m(left, pivot, right) }
  257|       |
  258|      1|        fn filter<F: FnMut(&T) -> bool>(&self, predicate: F) -> Self { BSTSetBBAlphaMtEph::filter(self, predicate) }
  259|       |
  260|      1|        fn reduce<F: FnMut(T, T) -> T>(&self, op: F, base: T) -> T { BSTSetBBAlphaMtEph::reduce(self, op, base) }
  261|       |
  262|      1|        fn iter_in_order(&self) -> ArraySeqStPerS<T> { self.tree.in_order() }
  263|       |
  264|      1|        fn as_tree(&self) -> &BSTBBAlphaMtEph<T> { &self.tree }
  265|       |    }
  266|       |
  267|       |    #[macro_export]
  268|       |    macro_rules! BSTSetBBAlphaMtEphLit {
  269|       |        () => {
  270|       |            < $crate::Chap37::BSTSetBBAlphaMtEph::BSTSetBBAlphaMtEph::BSTSetBBAlphaMtEph<_> as $crate::Chap37::BSTSetBBAlphaMtEph::BSTSetBBAlphaMtEph::BSTSetBBAlphaMtEphTrait<_> >::empty()
  271|       |        };
  272|       |        ( $( $x:expr ),* $(,)? ) => {{
  273|       |            let mut __set = < $crate::Chap37::BSTSetBBAlphaMtEph::BSTSetBBAlphaMtEph::BSTSetBBAlphaMtEph<_> as $crate::Chap37::BSTSetBBAlphaMtEph::BSTSetBBAlphaMtEph::BSTSetBBAlphaMtEphTrait<_> >::empty();
  274|       |            $( __set.insert($x); )*
  275|       |            __set
  276|       |        }};
  277|       |    }
  278|       |
  279|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap37/BSTSetPlainMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Set interface built atop the Plain multi-threaded BST implementation.
    3|       |
    4|       |pub mod BSTSetPlainMtEph {
    5|       |
    6|       |    use std::collections::BTreeSet;
    7|       |
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |    use crate::Chap37::BSTPlainMtEph::BSTPlainMtEph::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    #[derive(Debug, Clone)]
   13|       |    pub struct BSTSetPlainMtEph<T: StTInMtT + Ord> {
   14|       |        tree: BSTPlainMtEph<T>,
   15|       |    }
   16|       |
   17|       |    pub type BSTSetPlainMt<T> = BSTSetPlainMtEph<T>;
   18|       |
   19|       |    pub trait BSTSetPlainMtEphTrait<T: StTInMtT + Ord>: Sized {
   20|       |        /// claude-4-sonet: Work (1), Span (1)
   21|       |        fn empty() -> Self;
   22|       |        /// claude-4-sonet: Work (1), Span (1)
   23|       |        fn singleton(value: T) -> Self;
   24|       |        /// claude-4-sonet: Work (1), Span (1)
   25|       |        fn size(&self) -> N;
   26|       |        /// claude-4-sonet: Work (1), Span (1)
   27|       |        fn is_empty(&self) -> B;
   28|       |        /// claude-4-sonet: Work (log n) average, (n) worst case; Span (log n) average with locking
   29|       |        fn find(&self, value: &T) -> Option<T>;
   30|       |        /// claude-4-sonet: Work (log n) average, (n) worst case; Span (log n) average with locking
   31|       |        fn contains(&self, value: &T) -> B;
   32|       |        /// claude-4-sonet: Work (log n) average, (n) worst case; Span (log n) average with locking
   33|       |        fn minimum(&self) -> Option<T>;
   34|       |        /// claude-4-sonet: Work (log n) average, (n) worst case; Span (log n) average with locking
   35|       |        fn maximum(&self) -> Option<T>;
   36|       |        /// claude-4-sonet: Work (log n) average, (n) worst case; Span (log n) average with locking
   37|       |        fn insert(&mut self, value: T);
   38|       |        /// claude-4-sonet: Work (log n) average, (n) worst case; Span (log n) average with locking
   39|       |        fn delete(&mut self, target: &T);
   40|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   41|       |        fn union(&self, other: &Self) -> Self;
   42|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   43|       |        fn intersection(&self, other: &Self) -> Self;
   44|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   45|       |        fn difference(&self, other: &Self) -> Self;
   46|       |        /// claude-4-sonet: Work (log n) average, Span (log n)
   47|       |        fn split(&self, pivot: &T) -> (Self, B, Self);
   48|       |        /// claude-4-sonet: Work (log(|left| + |right|)), Span (log(|left| + |right|))
   49|       |        fn join_pair(left: Self, right: Self) -> Self;
   50|       |        /// claude-4-sonet: Work (log(|left| + |right|)), Span (log(|left| + |right|))
   51|       |        fn join_m(left: Self, pivot: T, right: Self) -> Self;
   52|       |        /// claude-4-sonet: Work (n), Span (n)
   53|       |        fn filter<F: FnMut(&T) -> bool>(&self, predicate: F) -> Self;
   54|       |        /// claude-4-sonet: Work (n), Span (n)
   55|       |        fn reduce<F: FnMut(T, T) -> T>(&self, op: F, base: T) -> T;
   56|       |        /// claude-4-sonet: Work (n), Span (n)
   57|       |        fn iter_in_order(&self) -> ArraySeqStPerS<T>;
   58|       |        /// claude-4-sonet: Work (1), Span (1)
   59|       |        fn as_tree(&self) -> &BSTPlainMtEph<T>;
   60|       |    }
   61|       |
   62|       |    impl<T: StTInMtT + Ord> BSTSetPlainMtEph<T> {
   63|     78|        pub fn empty() -> Self {
   64|     78|            Self {
   65|     78|                tree: BSTPlainMtEph::new(),
   66|     78|            }
   67|     78|        }
   68|       |
   69|      2|        pub fn singleton(value: T) -> Self {
   70|      2|            let tree = BSTPlainMtEph::new();
   71|      2|            tree.insert(value);
   72|      2|            Self { tree }
   73|      2|        }
   74|       |
   75|     70|        pub fn size(&self) -> N { self.tree.size() }
   76|       |
   77|      5|        pub fn is_empty(&self) -> B { self.tree.is_empty() }
   78|       |
   79|      6|        pub fn find(&self, value: &T) -> Option<T> { self.tree.find(value) }
   80|       |
   81|     56|        pub fn contains(&self, value: &T) -> B { self.tree.contains(value) }
   82|       |
   83|     12|        pub fn minimum(&self) -> Option<T> { self.tree.minimum() }
   84|       |
   85|     12|        pub fn maximum(&self) -> Option<T> { self.tree.maximum() }
   86|       |
   87|    341|        pub fn insert(&mut self, value: T) { self.tree.insert(value); }
   88|       |
   89|      7|        pub fn delete(&mut self, target: &T) {
   90|      7|            let mut values = self.values_vec();
   91|     25|            if let Some(pos) = values.iter().position(|x| x == target) {
                                      ^6     ^7            ^7
   92|      6|                values.remove(pos);
   93|      6|                self.tree = Self::rebuild_from_vec(values);
   94|      6|            }
                          ^1
   95|      7|        }
   96|       |
   97|      6|        pub fn union(&self, other: &Self) -> Self {
   98|      6|            let mut merged: BTreeSet<T> = self.values_vec().into_iter().collect();
   99|     15|            for value in other.values_vec() {
                                       ^6    ^6
  100|     15|                merged.insert(value);
  101|     15|            }
  102|      6|            Self::from_sorted_iter(merged.into_iter())
  103|      6|        }
  104|       |
  105|      6|        pub fn intersection(&self, other: &Self) -> Self {
  106|      6|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  107|      6|            let filtered: Vec<T> = self
  108|      6|                .tree
  109|      6|                .in_order()
  110|      6|                .iter()
  111|     17|                .filter_map(|v| {
                               ^6
  112|     17|                    if other_values.contains(v) {
  113|      5|                        Some(v.clone())
  114|       |                    } else {
  115|     12|                        None
  116|       |                    }
  117|     17|                })
  118|      6|                .collect();
  119|      6|            Self::from_sorted_iter(filtered.into_iter())
  120|      6|        }
  121|       |
  122|      4|        pub fn difference(&self, other: &Self) -> Self {
  123|      4|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  124|      4|            let filtered: Vec<T> = self
  125|      4|                .tree
  126|      4|                .in_order()
  127|      4|                .iter()
  128|     11|                .filter_map(|v| {
                               ^4
  129|     11|                    if !other_values.contains(v) {
  130|      8|                        Some(v.clone())
  131|       |                    } else {
  132|      3|                        None
  133|       |                    }
  134|     11|                })
  135|      4|                .collect();
  136|      4|            Self::from_sorted_iter(filtered.into_iter())
  137|      4|        }
  138|       |
  139|      6|        pub fn split(&self, pivot: &T) -> (Self, B, Self) {
  140|      6|            let mut left: Vec<T> = Vec::new();
  141|      6|            let mut right: Vec<T> = Vec::new();
  142|      6|            let mut found = false;
  143|     19|            for value in self.tree.in_order().iter() {
                                       ^6                   ^6
  144|     19|                if value < pivot {
  145|      8|                    left.push(value.clone());
  146|     11|                } else if value > pivot {
  147|      7|                    right.push(value.clone());
  148|      7|                } else {
  149|      4|                    found = true;
  150|      4|                }
  151|       |            }
  152|      6|            (
  153|      6|                Self::from_sorted_iter(left.into_iter()),
  154|      6|                found,
  155|      6|                Self::from_sorted_iter(right.into_iter()),
  156|      6|            )
  157|      6|        }
  158|       |
  159|      2|        pub fn join_pair(left: Self, right: Self) -> Self {
  160|      2|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  161|      4|            for value in right.values_vec() {
                                       ^2    ^2
  162|      4|                combined.insert(value);
  163|      4|            }
  164|      2|            Self::from_sorted_iter(combined.into_iter())
  165|      2|        }
  166|       |
  167|      4|        pub fn join_m(left: Self, pivot: T, right: Self) -> Self {
  168|      4|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  169|      4|            combined.insert(pivot);
  170|      7|            for value in right.values_vec() {
                                       ^4    ^4
  171|      7|                combined.insert(value);
  172|      7|            }
  173|      4|            Self::from_sorted_iter(combined.into_iter())
  174|      4|        }
  175|       |
  176|      7|        pub fn filter<F>(&self, mut predicate: F) -> Self
  177|      7|        where
  178|      7|            F: FnMut(&T) -> bool,
  179|       |        {
  180|      7|            let filtered: Vec<T> = self
  181|      7|                .tree
  182|      7|                .in_order()
  183|      7|                .iter()
  184|     17|                .filter_map(|v| if predicate(v) { Some(v.clone()) } else { None })
                               ^7                               ^7                       ^10
  185|      7|                .collect();
  186|      7|            Self::from_sorted_iter(filtered.into_iter())
  187|      7|        }
  188|       |
  189|      4|        pub fn reduce<F>(&self, mut op: F, base: T) -> T
  190|      4|        where
  191|      4|            F: FnMut(T, T) -> T,
  192|       |        {
  193|      4|            self.tree
  194|      4|                .in_order()
  195|      4|                .iter()
  196|     10|                .fold(base, |acc, value| op(acc, value.clone()))
                               ^4   ^4
  197|      4|        }
  198|       |
  199|      4|        pub fn iter_in_order(&self) -> ArraySeqStPerS<T> { self.tree.in_order() }
  200|       |
  201|      1|        pub fn as_tree(&self) -> &BSTPlainMtEph<T> { &self.tree }
  202|       |
  203|     50|        fn values_vec(&self) -> Vec<T> { self.tree.in_order().iter().cloned().collect() }
  204|       |
  205|      7|        fn rebuild_from_vec(values: Vec<T>) -> BSTPlainMtEph<T> {
  206|      7|            let tree = BSTPlainMtEph::new();
  207|     43|            for value in values {
                              ^36
  208|     36|                tree.insert(value);
  209|     36|            }
  210|      7|            tree
  211|      7|        }
  212|       |
  213|     48|        fn from_sorted_iter<I>(values: I) -> Self
  214|     48|        where
  215|     48|            I: IntoIterator<Item = T>,
  216|       |        {
  217|     48|            let tree = BSTPlainMtEph::new();
  218|    147|            for value in values {
                              ^99
  219|     99|                tree.insert(value);
  220|     99|            }
  221|     48|            Self { tree }
  222|     48|        }
  223|       |    }
  224|       |
  225|       |    impl<T: StTInMtT + Ord> BSTSetPlainMtEphTrait<T> for BSTSetPlainMtEph<T> {
  226|      3|        fn empty() -> Self { Self::empty() }
  227|       |
  228|      1|        fn singleton(value: T) -> Self { Self::singleton(value) }
  229|       |
  230|      0|        fn size(&self) -> N { self.tree.size() }
  231|       |
  232|      0|        fn is_empty(&self) -> B { self.tree.is_empty() }
  233|       |
  234|      1|        fn find(&self, value: &T) -> Option<T> { self.tree.find(value) }
  235|       |
  236|      1|        fn contains(&self, value: &T) -> B { self.tree.contains(value) }
  237|       |
  238|      1|        fn minimum(&self) -> Option<T> { self.tree.minimum() }
  239|       |
  240|      1|        fn maximum(&self) -> Option<T> { self.tree.maximum() }
  241|       |
  242|      1|        fn insert(&mut self, value: T) { self.tree.insert(value); }
  243|       |
  244|      1|        fn delete(&mut self, target: &T) {
  245|      1|            let mut values = self.values_vec();
  246|      1|            if let Some(pos) = values.iter().position(|x| x == target) {
  247|      1|                values.remove(pos);
  248|      1|                self.tree = Self::rebuild_from_vec(values);
  249|      1|            }
                          ^0
  250|      1|        }
  251|       |
  252|      1|        fn union(&self, other: &Self) -> Self {
  253|      1|            let mut merged: BTreeSet<T> = self.values_vec().into_iter().collect();
  254|      1|            for value in other.values_vec() {
  255|      1|                merged.insert(value);
  256|      1|            }
  257|      1|            Self::from_sorted_iter(merged.into_iter())
  258|      1|        }
  259|       |
  260|      1|        fn intersection(&self, other: &Self) -> Self {
  261|      1|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  262|      1|            let filtered: Vec<T> = self
  263|      1|                .tree
  264|      1|                .in_order()
  265|      1|                .iter()
  266|      2|                .filter_map(|v| {
                               ^1
  267|      2|                    if other_values.contains(v) {
  268|      1|                        Some(v.clone())
  269|       |                    } else {
  270|      1|                        None
  271|       |                    }
  272|      2|                })
  273|      1|                .collect();
  274|      1|            Self::from_sorted_iter(filtered.into_iter())
  275|      1|        }
  276|       |
  277|      1|        fn difference(&self, other: &Self) -> Self {
  278|      1|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  279|      1|            let filtered: Vec<T> = self
  280|      1|                .tree
  281|      1|                .in_order()
  282|      1|                .iter()
  283|      2|                .filter_map(|v| {
                               ^1
  284|      2|                    if !other_values.contains(v) {
  285|      1|                        Some(v.clone())
  286|       |                    } else {
  287|      1|                        None
  288|       |                    }
  289|      2|                })
  290|      1|                .collect();
  291|      1|            Self::from_sorted_iter(filtered.into_iter())
  292|      1|        }
  293|       |
  294|      1|        fn split(&self, pivot: &T) -> (Self, B, Self) {
  295|      1|            let mut left: Vec<T> = Vec::new();
  296|      1|            let mut right: Vec<T> = Vec::new();
  297|      1|            let mut found = false;
  298|      3|            for value in self.tree.in_order().iter() {
                                       ^1                   ^1
  299|      3|                if value < pivot {
  300|      1|                    left.push(value.clone());
  301|      2|                } else if value > pivot {
  302|      1|                    right.push(value.clone());
  303|      1|                } else {
  304|      1|                    found = true;
  305|      1|                }
  306|       |            }
  307|      1|            (
  308|      1|                Self::from_sorted_iter(left.into_iter()),
  309|      1|                found,
  310|      1|                Self::from_sorted_iter(right.into_iter()),
  311|      1|            )
  312|      1|        }
  313|       |
  314|      1|        fn join_pair(left: Self, right: Self) -> Self {
  315|      1|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  316|      1|            for value in right.values_vec() {
  317|      1|                combined.insert(value);
  318|      1|            }
  319|      1|            Self::from_sorted_iter(combined.into_iter())
  320|      1|        }
  321|       |
  322|      1|        fn join_m(left: Self, pivot: T, right: Self) -> Self {
  323|      1|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  324|      1|            combined.insert(pivot);
  325|      1|            for value in right.values_vec() {
  326|      1|                combined.insert(value);
  327|      1|            }
  328|      1|            Self::from_sorted_iter(combined.into_iter())
  329|      1|        }
  330|       |
  331|      1|        fn filter<F>(&self, predicate: F) -> Self
  332|      1|        where
  333|      1|            F: FnMut(&T) -> bool,
  334|       |        {
  335|      1|            Self::filter(self, predicate)
  336|      1|        }
  337|       |
  338|      1|        fn reduce<F>(&self, op: F, base: T) -> T
  339|      1|        where
  340|      1|            F: FnMut(T, T) -> T,
  341|       |        {
  342|      1|            Self::reduce(self, op, base)
  343|      1|        }
  344|       |
  345|      1|        fn iter_in_order(&self) -> ArraySeqStPerS<T> { self.tree.in_order() }
  346|       |
  347|      1|        fn as_tree(&self) -> &BSTPlainMtEph<T> { &self.tree }
  348|       |    }
  349|       |
  350|       |    #[macro_export]
  351|       |    macro_rules! BSTSetPlainMtEphLit {
  352|       |        () => {
  353|       |            < $crate::Chap37::BSTSetPlainMtEph::BSTSetPlainMtEph::BSTSetPlainMtEph<_> as $crate::Chap37::BSTSetPlainMtEph::BSTSetPlainMtEph::BSTSetPlainMtEphTrait<_> >::empty()
  354|       |        };
  355|       |        ( $( $x:expr ),* $(,)? ) => {{
  356|       |            let mut __set = < $crate::Chap37::BSTSetPlainMtEph::BSTSetPlainMtEph::BSTSetPlainMtEph<_> as $crate::Chap37::BSTSetPlainMtEph::BSTSetPlainMtEph::BSTSetPlainMtEphTrait<_> >::empty();
  357|       |            $( __set.insert($x); )*
  358|       |            __set
  359|       |        }};
  360|       |    }
  361|       |
  362|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap37/BSTSetRBMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Set interface built atop the Red-Black multi-threaded BST implementation.
    3|       |
    4|       |pub mod BSTSetRBMtEph {
    5|       |
    6|       |    use std::collections::BTreeSet;
    7|       |
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |    use crate::Chap37::BSTRBMtEph::BSTRBMtEph::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    #[derive(Debug, Clone)]
   13|       |    pub struct BSTSetRBMtEph<T: StTInMtT + Ord> {
   14|       |        tree: BSTRBMtEph<T>,
   15|       |    }
   16|       |
   17|       |    pub type BSTSetRBMt<T> = BSTSetRBMtEph<T>;
   18|       |
   19|       |    pub trait BSTSetRBMtEphTrait<T: StTInMtT + Ord>: Sized {
   20|       |        /// claude-4-sonet: Work (1), Span (1)
   21|       |        fn empty() -> Self;
   22|       |        /// claude-4-sonet: Work (1), Span (1)
   23|       |        fn singleton(value: T) -> Self;
   24|       |        /// claude-4-sonet: Work (1), Span (1)
   25|       |        fn size(&self) -> N;
   26|       |        /// claude-4-sonet: Work (1), Span (1)
   27|       |        fn is_empty(&self) -> B;
   28|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   29|       |        fn find(&self, value: &T) -> Option<T>;
   30|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   31|       |        fn contains(&self, value: &T) -> B;
   32|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   33|       |        fn minimum(&self) -> Option<T>;
   34|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   35|       |        fn maximum(&self) -> Option<T>;
   36|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   37|       |        fn insert(&mut self, value: T);
   38|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   39|       |        fn delete(&mut self, target: &T);
   40|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   41|       |        fn union(&self, other: &Self) -> Self;
   42|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   43|       |        fn intersection(&self, other: &Self) -> Self;
   44|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   45|       |        fn difference(&self, other: &Self) -> Self;
   46|       |        /// claude-4-sonet: Work (log n), Span (log n)
   47|       |        fn split(&self, pivot: &T) -> (Self, B, Self);
   48|       |        /// claude-4-sonet: Work (log(|left| + |right|)), Span (log(|left| + |right|))
   49|       |        fn join_pair(left: Self, right: Self) -> Self;
   50|       |        /// claude-4-sonet: Work (log(|left| + |right|)), Span (log(|left| + |right|))
   51|       |        fn join_m(left: Self, pivot: T, right: Self) -> Self;
   52|       |        /// claude-4-sonet: Work (n), Span (n)
   53|       |        fn filter<F: FnMut(&T) -> bool>(&self, predicate: F) -> Self;
   54|       |        /// claude-4-sonet: Work (n), Span (n)
   55|       |        fn reduce<F: FnMut(T, T) -> T>(&self, op: F, base: T) -> T;
   56|       |        /// claude-4-sonet: Work (n), Span (n)
   57|       |        fn iter_in_order(&self) -> ArraySeqStPerS<T>;
   58|       |        /// claude-4-sonet: Work (1), Span (1)
   59|       |        fn as_tree(&self) -> &BSTRBMtEph<T>;
   60|       |    }
   61|       |
   62|       |    impl<T: StTInMtT + Ord> BSTSetRBMtEph<T> {
   63|     73|        pub fn empty() -> Self {
   64|     73|            Self {
   65|     73|                tree: BSTRBMtEph::new(),
   66|     73|            }
   67|     73|        }
   68|       |
   69|      2|        pub fn singleton(value: T) -> Self {
   70|      2|            let tree = BSTRBMtEph::new();
   71|      2|            tree.insert(value);
   72|      2|            Self { tree }
   73|      2|        }
   74|       |
   75|    428|        pub fn size(&self) -> N { self.tree.size() }
   76|       |
   77|      4|        pub fn is_empty(&self) -> B { self.tree.is_empty() }
   78|       |
   79|      4|        pub fn find(&self, value: &T) -> Option<T> { self.tree.find(value) }
   80|       |
   81|    356|        pub fn contains(&self, value: &T) -> B { self.tree.contains(value) }
   82|       |
   83|     72|        pub fn minimum(&self) -> Option<T> { self.tree.minimum() }
   84|       |
   85|     72|        pub fn maximum(&self) -> Option<T> { self.tree.maximum() }
   86|       |
   87|  1.47k|        pub fn insert(&mut self, value: T) { self.tree.insert(value); }
   88|       |
   89|    280|        pub fn delete(&mut self, target: &T) {
   90|    280|            let mut values = self.values_vec();
   91|  9.28k|            if let Some(pos) = values.iter().position(|x| x == target) {
                                      ^280   ^280          ^280
   92|    280|                values.remove(pos);
   93|    280|                self.tree = Self::rebuild_from_vec(values);
   94|    280|            }
                          ^0
   95|    280|        }
   96|       |
   97|      4|        pub fn union(&self, other: &Self) -> Self {
   98|      4|            let mut merged: BTreeSet<T> = self.values_vec().into_iter().collect();
   99|      5|            for value in other.values_vec() {
                                       ^4    ^4
  100|      5|                merged.insert(value);
  101|      5|            }
  102|      4|            Self::from_sorted_iter(merged.into_iter())
  103|      4|        }
  104|       |
  105|      4|        pub fn intersection(&self, other: &Self) -> Self {
  106|      4|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  107|      4|            let filtered: Vec<T> = self
  108|      4|                .tree
  109|      4|                .in_order()
  110|      4|                .iter()
  111|     10|                .filter_map(|v| {
                               ^4
  112|     10|                    if other_values.contains(v) {
  113|      4|                        Some(v.clone())
  114|       |                    } else {
  115|      6|                        None
  116|       |                    }
  117|     10|                })
  118|      4|                .collect();
  119|      4|            Self::from_sorted_iter(filtered.into_iter())
  120|      4|        }
  121|       |
  122|      3|        pub fn difference(&self, other: &Self) -> Self {
  123|      3|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  124|      3|            let filtered: Vec<T> = self
  125|      3|                .tree
  126|      3|                .in_order()
  127|      3|                .iter()
  128|      8|                .filter_map(|v| {
                               ^3
  129|      8|                    if !other_values.contains(v) {
  130|      5|                        Some(v.clone())
  131|       |                    } else {
  132|      3|                        None
  133|       |                    }
  134|      8|                })
  135|      3|                .collect();
  136|      3|            Self::from_sorted_iter(filtered.into_iter())
  137|      3|        }
  138|       |
  139|      5|        pub fn split(&self, pivot: &T) -> (Self, B, Self) {
  140|      5|            let mut left: Vec<T> = Vec::new();
  141|      5|            let mut right: Vec<T> = Vec::new();
  142|      5|            let mut found = false;
  143|     16|            for value in self.tree.in_order().iter() {
                                       ^5                   ^5
  144|     16|                if value < pivot {
  145|      7|                    left.push(value.clone());
  146|      9|                } else if value > pivot {
  147|      5|                    right.push(value.clone());
  148|      5|                } else {
  149|      4|                    found = true;
  150|      4|                }
  151|       |            }
  152|      5|            (
  153|      5|                Self::from_sorted_iter(left.into_iter()),
  154|      5|                found,
  155|      5|                Self::from_sorted_iter(right.into_iter()),
  156|      5|            )
  157|      5|        }
  158|       |
  159|      3|        pub fn join_pair(left: Self, right: Self) -> Self {
  160|      3|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  161|      5|            for value in right.values_vec() {
                                       ^3    ^3
  162|      5|                combined.insert(value);
  163|      5|            }
  164|      3|            Self::from_sorted_iter(combined.into_iter())
  165|      3|        }
  166|       |
  167|      4|        pub fn join_m(left: Self, pivot: T, right: Self) -> Self {
  168|      4|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  169|      4|            combined.insert(pivot);
  170|      6|            for value in right.values_vec() {
                                       ^4    ^4
  171|      6|                combined.insert(value);
  172|      6|            }
  173|      4|            Self::from_sorted_iter(combined.into_iter())
  174|      4|        }
  175|       |
  176|      6|        pub fn filter<F>(&self, mut predicate: F) -> Self
  177|      6|        where
  178|      6|            F: FnMut(&T) -> bool,
  179|       |        {
  180|      6|            let filtered: Vec<T> = self
  181|      6|                .tree
  182|      6|                .in_order()
  183|      6|                .iter()
  184|     19|                .filter_map(|v| if predicate(v) { Some(v.clone()) } else { None })
                               ^6                               ^10                      ^9
  185|      6|                .collect();
  186|      6|            Self::from_sorted_iter(filtered.into_iter())
  187|      6|        }
  188|       |
  189|      4|        pub fn reduce<F>(&self, mut op: F, base: T) -> T
  190|      4|        where
  191|      4|            F: FnMut(T, T) -> T,
  192|       |        {
  193|      4|            self.tree
  194|      4|                .in_order()
  195|      4|                .iter()
  196|     10|                .fold(base, |acc, value| op(acc, value.clone()))
                               ^4   ^4
  197|      4|        }
  198|       |
  199|     13|        pub fn iter_in_order(&self) -> ArraySeqStPerS<T> { self.tree.in_order() }
  200|       |
  201|      1|        pub fn as_tree(&self) -> &BSTRBMtEph<T> { &self.tree }
  202|       |
  203|    309|        fn values_vec(&self) -> Vec<T> { self.tree.in_order().iter().cloned().collect() }
  204|       |
  205|    280|        fn rebuild_from_vec(values: Vec<T>) -> BSTRBMtEph<T> {
  206|    280|            let tree = BSTRBMtEph::new();
  207|  22.7k|            for value in values {
                              ^22.4k
  208|  22.4k|                tree.insert(value);
  209|  22.4k|            }
  210|    280|            tree
  211|    280|        }
  212|       |
  213|     34|        fn from_sorted_iter<I>(values: I) -> Self
  214|     34|        where
  215|     34|            I: IntoIterator<Item = T>,
  216|       |        {
  217|     34|            let tree = BSTRBMtEph::new();
  218|    100|            for value in values {
                              ^66
  219|     66|                tree.insert(value);
  220|     66|            }
  221|     34|            Self { tree }
  222|     34|        }
  223|       |    }
  224|       |
  225|       |    impl<T: StTInMtT + Ord> BSTSetRBMtEphTrait<T> for BSTSetRBMtEph<T> {
  226|      3|        fn empty() -> Self { Self::empty() }
  227|       |
  228|      1|        fn singleton(value: T) -> Self { Self::singleton(value) }
  229|       |
  230|      0|        fn size(&self) -> N { self.tree.size() }
  231|       |
  232|      0|        fn is_empty(&self) -> B { self.tree.is_empty() }
  233|       |
  234|      1|        fn find(&self, value: &T) -> Option<T> { self.tree.find(value) }
  235|       |
  236|      1|        fn contains(&self, value: &T) -> B { self.tree.contains(value) }
  237|       |
  238|      1|        fn minimum(&self) -> Option<T> { self.tree.minimum() }
  239|       |
  240|      1|        fn maximum(&self) -> Option<T> { self.tree.maximum() }
  241|       |
  242|      1|        fn insert(&mut self, value: T) { self.tree.insert(value); }
  243|       |
  244|      1|        fn delete(&mut self, target: &T) { BSTSetRBMtEph::delete(self, target) }
  245|       |
  246|      1|        fn union(&self, other: &Self) -> Self { BSTSetRBMtEph::union(self, other) }
  247|       |
  248|      1|        fn intersection(&self, other: &Self) -> Self { BSTSetRBMtEph::intersection(self, other) }
  249|       |
  250|      1|        fn difference(&self, other: &Self) -> Self { BSTSetRBMtEph::difference(self, other) }
  251|       |
  252|      1|        fn split(&self, pivot: &T) -> (Self, B, Self) { BSTSetRBMtEph::split(self, pivot) }
  253|       |
  254|      1|        fn join_pair(left: Self, right: Self) -> Self { BSTSetRBMtEph::join_pair(left, right) }
  255|       |
  256|      1|        fn join_m(left: Self, pivot: T, right: Self) -> Self { BSTSetRBMtEph::join_m(left, pivot, right) }
  257|       |
  258|      1|        fn filter<F: FnMut(&T) -> bool>(&self, predicate: F) -> Self { BSTSetRBMtEph::filter(self, predicate) }
  259|       |
  260|      1|        fn reduce<F: FnMut(T, T) -> T>(&self, op: F, base: T) -> T { BSTSetRBMtEph::reduce(self, op, base) }
  261|       |
  262|      1|        fn iter_in_order(&self) -> ArraySeqStPerS<T> { self.tree.in_order() }
  263|       |
  264|      1|        fn as_tree(&self) -> &BSTRBMtEph<T> { &self.tree }
  265|       |    }
  266|       |
  267|       |    #[macro_export]
  268|       |    macro_rules! BSTSetRBMtEphLit {
  269|       |        () => {
  270|       |            < $crate::Chap37::BSTSetRBMtEph::BSTSetRBMtEph::BSTSetRBMtEph<_> as $crate::Chap37::BSTSetRBMtEph::BSTSetRBMtEph::BSTSetRBMtEphTrait<_> >::empty()
  271|       |        };
  272|       |        ( $( $x:expr ),* $(,)? ) => {{
  273|       |            let mut __set = < $crate::Chap37::BSTSetRBMtEph::BSTSetRBMtEph::BSTSetRBMtEph<_> as $crate::Chap37::BSTSetRBMtEph::BSTSetRBMtEph::BSTSetRBMtEphTrait<_> >::empty();
  274|       |            $( __set.insert($x); )*
  275|       |            __set
  276|       |        }};
  277|       |    }
  278|       |
  279|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap37/BSTSetSplayMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Set interface built atop the Splay multi-threaded BST implementation.
    3|       |
    4|       |pub mod BSTSetSplayMtEph {
    5|       |
    6|       |    use std::collections::BTreeSet;
    7|       |
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |    use crate::Chap37::BSTSplayMtEph::BSTSplayMtEph::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    #[derive(Debug, Clone)]
   13|       |    pub struct BSTSetSplayMtEph<T: StTInMtT + Ord> {
   14|       |        tree: BSTSplayMtEph<T>,
   15|       |    }
   16|       |
   17|       |    pub type BSTSetSplayMt<T> = BSTSetSplayMtEph<T>;
   18|       |
   19|       |    pub trait BSTSetSplayMtEphTrait<T: StTInMtT + Ord>: Sized {
   20|       |        /// claude-4-sonet: Work (1), Span (1)
   21|       |        fn empty() -> Self;
   22|       |        /// claude-4-sonet: Work (1), Span (1)
   23|       |        fn singleton(value: T) -> Self;
   24|       |        /// claude-4-sonet: Work (1), Span (1)
   25|       |        fn size(&self) -> N;
   26|       |        /// claude-4-sonet: Work (1), Span (1)
   27|       |        fn is_empty(&self) -> B;
   28|       |        /// claude-4-sonet: Work (log n) amortized, (n) worst case; Span (log n) amortized with locking
   29|       |        fn find(&self, value: &T) -> Option<T>;
   30|       |        /// claude-4-sonet: Work (log n) amortized, (n) worst case; Span (log n) amortized with locking
   31|       |        fn contains(&self, value: &T) -> B;
   32|       |        /// claude-4-sonet: Work (log n) amortized, (n) worst case; Span (log n) amortized with locking
   33|       |        fn minimum(&self) -> Option<T>;
   34|       |        /// claude-4-sonet: Work (log n) amortized, (n) worst case; Span (log n) amortized with locking
   35|       |        fn maximum(&self) -> Option<T>;
   36|       |        /// claude-4-sonet: Work (log n) amortized, (n) worst case; Span (log n) amortized with locking
   37|       |        fn insert(&mut self, value: T);
   38|       |        /// claude-4-sonet: Work (log n) amortized, (n) worst case; Span (log n) amortized with locking
   39|       |        fn delete(&mut self, target: &T);
   40|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   41|       |        fn union(&self, other: &Self) -> Self;
   42|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   43|       |        fn intersection(&self, other: &Self) -> Self;
   44|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   45|       |        fn difference(&self, other: &Self) -> Self;
   46|       |        /// claude-4-sonet: Work (log n) amortized, Span (log n)
   47|       |        fn split(&self, pivot: &T) -> (Self, B, Self);
   48|       |        /// claude-4-sonet: Work (log(|left| + |right|)), Span (log(|left| + |right|))
   49|       |        fn join_pair(left: Self, right: Self) -> Self;
   50|       |        /// claude-4-sonet: Work (log(|left| + |right|)), Span (log(|left| + |right|))
   51|       |        fn join_m(left: Self, pivot: T, right: Self) -> Self;
   52|       |        /// claude-4-sonet: Work (n), Span (n)
   53|       |        fn filter<F: FnMut(&T) -> bool>(&self, predicate: F) -> Self;
   54|       |        /// claude-4-sonet: Work (n), Span (n)
   55|       |        fn reduce<F: FnMut(T, T) -> T>(&self, op: F, base: T) -> T;
   56|       |        /// claude-4-sonet: Work (n), Span (n)
   57|       |        fn iter_in_order(&self) -> ArraySeqStPerS<T>;
   58|       |        /// claude-4-sonet: Work (1), Span (1)
   59|       |        fn as_tree(&self) -> &BSTSplayMtEph<T>;
   60|       |    }
   61|       |
   62|       |    impl<T: StTInMtT + Ord> BSTSetSplayMtEph<T> {
   63|     65|        pub fn empty() -> Self {
   64|     65|            Self {
   65|     65|                tree: BSTSplayMtEph::new(),
   66|     65|            }
   67|     65|        }
   68|       |
   69|      2|        pub fn singleton(value: T) -> Self {
   70|      2|            let tree = BSTSplayMtEph::new();
   71|      2|            tree.insert(value);
   72|      2|            Self { tree }
   73|      2|        }
   74|       |
   75|     62|        pub fn size(&self) -> N { self.tree.size() }
   76|       |
   77|      4|        pub fn is_empty(&self) -> B { self.tree.is_empty() }
   78|       |
   79|      4|        pub fn find(&self, value: &T) -> Option<T> { self.tree.find(value) }
   80|       |
   81|     81|        pub fn contains(&self, value: &T) -> B { self.tree.contains(value) }
   82|       |
   83|      9|        pub fn minimum(&self) -> Option<T> { self.tree.minimum() }
   84|       |
   85|      9|        pub fn maximum(&self) -> Option<T> { self.tree.maximum() }
   86|       |
   87|    395|        pub fn insert(&mut self, value: T) { self.tree.insert(value); }
   88|       |
   89|      6|        pub fn delete(&mut self, target: &T) {
   90|      6|            let mut values = self.values_vec();
   91|     21|            if let Some(pos) = values.iter().position(|x| x == target) {
                                      ^6     ^6            ^6
   92|      6|                values.remove(pos);
   93|      6|                self.tree = Self::rebuild_from_vec(values);
   94|      6|            }
                          ^0
   95|      6|        }
   96|       |
   97|      4|        pub fn union(&self, other: &Self) -> Self {
   98|      4|            let mut merged: BTreeSet<T> = self.values_vec().into_iter().collect();
   99|      5|            for value in other.values_vec() {
                                       ^4    ^4
  100|      5|                merged.insert(value);
  101|      5|            }
  102|      4|            Self::from_sorted_iter(merged.into_iter())
  103|      4|        }
  104|       |
  105|      4|        pub fn intersection(&self, other: &Self) -> Self {
  106|      4|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  107|      4|            let filtered: Vec<T> = self
  108|      4|                .tree
  109|      4|                .in_order()
  110|      4|                .iter()
  111|     10|                .filter_map(|v| {
                               ^4
  112|     10|                    if other_values.contains(v) {
  113|      4|                        Some(v.clone())
  114|       |                    } else {
  115|      6|                        None
  116|       |                    }
  117|     10|                })
  118|      4|                .collect();
  119|      4|            Self::from_sorted_iter(filtered.into_iter())
  120|      4|        }
  121|       |
  122|      4|        pub fn difference(&self, other: &Self) -> Self {
  123|      4|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  124|      4|            let filtered: Vec<T> = self
  125|      4|                .tree
  126|      4|                .in_order()
  127|      4|                .iter()
  128|     15|                .filter_map(|v| {
                               ^4
  129|     15|                    if !other_values.contains(v) {
  130|     10|                        Some(v.clone())
  131|       |                    } else {
  132|      5|                        None
  133|       |                    }
  134|     15|                })
  135|      4|                .collect();
  136|      4|            Self::from_sorted_iter(filtered.into_iter())
  137|      4|        }
  138|       |
  139|      7|        pub fn split(&self, pivot: &T) -> (Self, B, Self) {
  140|      7|            let mut left: Vec<T> = Vec::new();
  141|      7|            let mut right: Vec<T> = Vec::new();
  142|      7|            let mut found = false;
  143|     28|            for value in self.tree.in_order().iter() {
                                       ^7                   ^7
  144|     28|                if value < pivot {
  145|     12|                    left.push(value.clone());
  146|     16|                } else if value > pivot {
  147|     10|                    right.push(value.clone());
  148|     10|                } else {
  149|      6|                    found = true;
  150|      6|                }
  151|       |            }
  152|      7|            (
  153|      7|                Self::from_sorted_iter(left.into_iter()),
  154|      7|                found,
  155|      7|                Self::from_sorted_iter(right.into_iter()),
  156|      7|            )
  157|      7|        }
  158|       |
  159|      5|        pub fn join_pair(left: Self, right: Self) -> Self {
  160|      5|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  161|     10|            for value in right.values_vec() {
                                       ^5    ^5
  162|     10|                combined.insert(value);
  163|     10|            }
  164|      5|            Self::from_sorted_iter(combined.into_iter())
  165|      5|        }
  166|       |
  167|      4|        pub fn join_m(left: Self, pivot: T, right: Self) -> Self {
  168|      4|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  169|      4|            combined.insert(pivot);
  170|      6|            for value in right.values_vec() {
                                       ^4    ^4
  171|      6|                combined.insert(value);
  172|      6|            }
  173|      4|            Self::from_sorted_iter(combined.into_iter())
  174|      4|        }
  175|       |
  176|      6|        pub fn filter<F>(&self, mut predicate: F) -> Self
  177|      6|        where
  178|      6|            F: FnMut(&T) -> bool,
  179|       |        {
  180|      6|            let filtered: Vec<T> = self
  181|      6|                .tree
  182|      6|                .in_order()
  183|      6|                .iter()
  184|     19|                .filter_map(|v| if predicate(v) { Some(v.clone()) } else { None })
                               ^6                               ^10                      ^9
  185|      6|                .collect();
  186|      6|            Self::from_sorted_iter(filtered.into_iter())
  187|      6|        }
  188|       |
  189|      4|        pub fn reduce<F>(&self, mut op: F, base: T) -> T
  190|      4|        where
  191|      4|            F: FnMut(T, T) -> T,
  192|       |        {
  193|      4|            self.tree
  194|      4|                .in_order()
  195|      4|                .iter()
  196|     10|                .fold(base, |acc, value| op(acc, value.clone()))
                               ^4   ^4
  197|      4|        }
  198|       |
  199|      4|        pub fn iter_in_order(&self) -> ArraySeqStPerS<T> { self.tree.in_order() }
  200|       |
  201|      1|        pub fn as_tree(&self) -> &BSTSplayMtEph<T> { &self.tree }
  202|       |
  203|     40|        fn values_vec(&self) -> Vec<T> { self.tree.in_order().iter().cloned().collect() }
  204|       |
  205|      6|        fn rebuild_from_vec(values: Vec<T>) -> BSTSplayMtEph<T> {
  206|      6|            let tree = BSTSplayMtEph::new();
  207|     36|            for value in values {
                              ^30
  208|     30|                tree.insert(value);
  209|     30|            }
  210|      6|            tree
  211|      6|        }
  212|       |
  213|     41|        fn from_sorted_iter<I>(values: I) -> Self
  214|     41|        where
  215|     41|            I: IntoIterator<Item = T>,
  216|       |        {
  217|     41|            let tree = BSTSplayMtEph::new();
  218|    132|            for value in values {
                              ^91
  219|     91|                tree.insert(value);
  220|     91|            }
  221|     41|            Self { tree }
  222|     41|        }
  223|       |    }
  224|       |
  225|       |    impl<T: StTInMtT + Ord> BSTSetSplayMtEphTrait<T> for BSTSetSplayMtEph<T> {
  226|      3|        fn empty() -> Self { Self::empty() }
  227|       |
  228|      1|        fn singleton(value: T) -> Self { Self::singleton(value) }
  229|       |
  230|      0|        fn size(&self) -> N { self.tree.size() }
  231|       |
  232|      0|        fn is_empty(&self) -> B { self.tree.is_empty() }
  233|       |
  234|      1|        fn find(&self, value: &T) -> Option<T> { self.tree.find(value) }
  235|       |
  236|      1|        fn contains(&self, value: &T) -> B { self.tree.contains(value) }
  237|       |
  238|      1|        fn minimum(&self) -> Option<T> { self.tree.minimum() }
  239|       |
  240|      1|        fn maximum(&self) -> Option<T> { self.tree.maximum() }
  241|       |
  242|      1|        fn insert(&mut self, value: T) { self.tree.insert(value); }
  243|       |
  244|      1|        fn delete(&mut self, target: &T) { BSTSetSplayMtEph::delete(self, target) }
  245|       |
  246|      1|        fn union(&self, other: &Self) -> Self { BSTSetSplayMtEph::union(self, other) }
  247|       |
  248|      1|        fn intersection(&self, other: &Self) -> Self { BSTSetSplayMtEph::intersection(self, other) }
  249|       |
  250|      1|        fn difference(&self, other: &Self) -> Self { BSTSetSplayMtEph::difference(self, other) }
  251|       |
  252|      1|        fn split(&self, pivot: &T) -> (Self, B, Self) { BSTSetSplayMtEph::split(self, pivot) }
  253|       |
  254|      1|        fn join_pair(left: Self, right: Self) -> Self { BSTSetSplayMtEph::join_pair(left, right) }
  255|       |
  256|      1|        fn join_m(left: Self, pivot: T, right: Self) -> Self { BSTSetSplayMtEph::join_m(left, pivot, right) }
  257|       |
  258|      1|        fn filter<F: FnMut(&T) -> bool>(&self, predicate: F) -> Self { BSTSetSplayMtEph::filter(self, predicate) }
  259|       |
  260|      1|        fn reduce<F: FnMut(T, T) -> T>(&self, op: F, base: T) -> T { BSTSetSplayMtEph::reduce(self, op, base) }
  261|       |
  262|      1|        fn iter_in_order(&self) -> ArraySeqStPerS<T> { self.tree.in_order() }
  263|       |
  264|      1|        fn as_tree(&self) -> &BSTSplayMtEph<T> { &self.tree }
  265|       |    }
  266|       |
  267|       |    #[macro_export]
  268|       |    macro_rules! BSTSetSplayMtEphLit {
  269|       |        () => {
  270|       |            < $crate::Chap37::BSTSetSplayMtEph::BSTSetSplayMtEph::BSTSetSplayMtEph<_> as $crate::Chap37::BSTSetSplayMtEph::BSTSetSplayMtEph::BSTSetSplayMtEphTrait<_> >::empty()
  271|       |        };
  272|       |        ( $( $x:expr ),* $(,)? ) => {{
  273|       |            let mut __set = < $crate::Chap37::BSTSetSplayMtEph::BSTSetSplayMtEph::BSTSetSplayMtEph<_> as $crate::Chap37::BSTSetSplayMtEph::BSTSetSplayMtEph::BSTSetSplayMtEphTrait<_> >::empty();
  274|       |            $( __set.insert($x); )*
  275|       |            __set
  276|       |        }};
  277|       |    }
  278|       |
  279|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap37/BSTSplayMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Ephemeral splay-style (simple BST) structure with interior locking for multi-threaded access.
    3|       |
    4|       |pub mod BSTSplayMtEph {
    5|       |
    6|       |    use std::sync::{Arc, RwLock};
    7|       |
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    type Link<T> = Option<Box<Node<T>>>;
   13|       |
   14|       |    #[derive(Debug, Clone)]
   15|       |    struct Node<T: StTInMtT + Ord> {
   16|       |        key: T,
   17|       |        size: N,
   18|       |        left: Link<T>,
   19|       |        right: Link<T>,
   20|       |    }
   21|       |
   22|       |    impl<T: StTInMtT + Ord> Node<T> {
   23|    624|        fn new(key: T) -> Self {
   24|    624|            Node {
   25|    624|                key,
   26|    624|                size: 1,
   27|    624|                left: None,
   28|    624|                right: None,
   29|    624|            }
   30|    624|        }
   31|       |    }
   32|       |
   33|       |    #[derive(Debug, Clone)]
   34|       |    pub struct BSTSplayMtEph<T: StTInMtT + Ord> {
   35|       |        root: Arc<RwLock<Link<T>>>,
   36|       |    }
   37|       |
   38|       |    pub type BSTreeSplay<T> = BSTSplayMtEph<T>;
   39|       |
   40|       |    pub trait BSTSplayMtEphTrait<T: StTInMtT + Ord>: Sized {
   41|       |        /// claude-4-sonet: Work (1), Span (1)
   42|       |        fn new() -> Self;
   43|       |        /// claude-4-sonet: Work (log n) amortized, (n) worst case; Span (log n) amortized with locking
   44|       |        fn insert(&self, value: T);
   45|       |        /// claude-4-sonet: Work (log n) amortized, (n) worst case; Span (log n) amortized with locking
   46|       |        fn find(&self, target: &T) -> Option<T>;
   47|       |        /// claude-4-sonet: Work (log n) amortized, (n) worst case; Span (log n) amortized with locking
   48|       |        fn contains(&self, target: &T) -> B;
   49|       |        /// claude-4-sonet: Work (1), Span (1)
   50|       |        fn size(&self) -> N;
   51|       |        /// claude-4-sonet: Work (1), Span (1)
   52|       |        fn is_empty(&self) -> B;
   53|       |        /// claude-4-sonet: Work (n), Span (n)
   54|       |        fn height(&self) -> N;
   55|       |        /// claude-4-sonet: Work (log n) amortized, (n) worst case; Span (log n) amortized with locking
   56|       |        fn minimum(&self) -> Option<T>;
   57|       |        /// claude-4-sonet: Work (log n) amortized, (n) worst case; Span (log n) amortized with locking
   58|       |        fn maximum(&self) -> Option<T>;
   59|       |        /// claude-4-sonet: Work (n), Span (n)
   60|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   61|       |        /// claude-4-sonet: Work (n), Span (n)
   62|       |        fn pre_order(&self) -> ArraySeqStPerS<T>;
   63|       |    }
   64|       |
   65|       |    impl<T: StTInMtT + Ord> Default for BSTSplayMtEph<T> {
   66|      1|        fn default() -> Self { Self::new() }
   67|       |    }
   68|       |
   69|       |    impl<T: StTInMtT + Ord> BSTSplayMtEph<T> {
   70|       |        // Private helper methods only - no public delegation
   71|       |
   72|  22.3k|        fn size_link(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }
   73|       |
   74|  11.0k|        fn update(node: &mut Node<T>) { node.size = 1 + Self::size_link(&node.left) + Self::size_link(&node.right); }
   75|       |
   76|  11.7k|        fn insert_link(link: &mut Link<T>, value: T) -> bool {
   77|  11.7k|            match link {
   78|  11.0k|                | Some(node) => {
   79|  11.0k|                    let inserted = if value < node.key {
   80|    149|                        Self::insert_link(&mut node.left, value)
   81|  10.9k|                    } else if value > node.key {
   82|  10.9k|                        Self::insert_link(&mut node.right, value)
   83|       |                    } else {
   84|      5|                        false
   85|       |                    };
   86|  11.0k|                    if inserted {
   87|  11.0k|                        Self::update(node);
   88|  11.0k|                    }
                                  ^6
   89|  11.0k|                    inserted
   90|       |                }
   91|       |                | None => {
   92|    624|                    *link = Some(Box::new(Node::new(value)));
   93|    624|                    true
   94|       |                }
   95|       |            }
   96|  11.7k|        }
   97|       |
   98|  1.00k|        fn find_link<'a>(link: &'a Link<T>, target: &T) -> Option<&'a T> {
   99|  1.00k|            match link {
  100|     16|                | None => None,
  101|    986|                | Some(node) => {
  102|    986|                    if target == &node.key {
  103|    162|                        Some(&node.key)
  104|    824|                    } else if target < &node.key {
  105|    134|                        Self::find_link(&node.left, target)
  106|       |                    } else {
  107|    690|                        Self::find_link(&node.right, target)
  108|       |                    }
  109|       |                }
  110|       |            }
  111|  1.00k|        }
  112|       |
  113|     29|        fn min_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  114|     29|            match link {
  115|      2|                | None => None,
  116|     27|                | Some(node) => match node.left {
  117|     15|                    | None => Some(&node.key),
  118|     12|                    | Some(_) => Self::min_link(&node.left),
  119|       |                },
  120|       |            }
  121|     29|        }
  122|       |
  123|    180|        fn max_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  124|    180|            match link {
  125|      2|                | None => None,
  126|    178|                | Some(node) => match node.right {
  127|     15|                    | None => Some(&node.key),
  128|    163|                    | Some(_) => Self::max_link(&node.right),
  129|       |                },
  130|       |            }
  131|    180|        }
  132|       |
  133|    483|        fn in_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  134|    483|            if let Some(node) = link {
                                      ^204
  135|    204|                Self::in_order_collect(&node.left, out);
  136|    204|                out.push(node.key.clone());
  137|    204|                Self::in_order_collect(&node.right, out);
  138|    279|            }
  139|    483|        }
  140|       |
  141|      7|        fn pre_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  142|      7|            if let Some(node) = link {
                                      ^3
  143|      3|                out.push(node.key.clone());
  144|      3|                Self::pre_order_collect(&node.left, out);
  145|      3|                Self::pre_order_collect(&node.right, out);
  146|      4|            }
  147|      7|        }
  148|       |    }
  149|       |
  150|       |    impl<T: StTInMtT + Ord> BSTSplayMtEphTrait<T> for BSTSplayMtEph<T> {
  151|    134|        fn new() -> Self {
  152|    134|            BSTSplayMtEph {
  153|    134|                root: Arc::new(RwLock::new(None)),
  154|    134|            }
  155|    134|        }
  156|       |
  157|    629|        fn insert(&self, value: T) {
  158|    629|            let mut guard = self.root.write().unwrap();
  159|    629|            Self::insert_link(&mut *guard, value);
  160|    629|        }
  161|       |
  162|    178|        fn find(&self, target: &T) -> Option<T> {
  163|    178|            let guard = self.root.read().unwrap();
  164|    178|            Self::find_link(&*guard, target).cloned()
  165|    178|        }
  166|       |
  167|    152|        fn contains(&self, target: &T) -> B { self.find(target).is_some() }
  168|       |
  169|     92|        fn size(&self) -> N {
  170|     92|            let guard = self.root.read().unwrap();
  171|     92|            Self::size_link(&*guard)
  172|     92|        }
  173|       |
  174|     10|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
                                                                      ^7            ^3
  175|       |
  176|      8|        fn height(&self) -> N {
  177|    138|            fn height_rec<T: StTInMtT + Ord>(link: &Link<T>) -> N {
  178|    138|                match link {
  179|     73|                    | None => 0,
  180|     65|                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),
  181|       |                }
  182|    138|            }
  183|      8|            let guard = self.root.read().unwrap();
  184|      8|            height_rec(&*guard)
  185|      8|        }
  186|       |
  187|     17|        fn minimum(&self) -> Option<T> {
  188|     17|            let guard = self.root.read().unwrap();
  189|     17|            Self::min_link(&*guard).cloned()
  190|     17|        }
  191|       |
  192|     17|        fn maximum(&self) -> Option<T> {
  193|     17|            let guard = self.root.read().unwrap();
  194|     17|            Self::max_link(&*guard).cloned()
  195|     17|        }
  196|       |
  197|     75|        fn in_order(&self) -> ArraySeqStPerS<T> {
  198|     75|            let guard = self.root.read().unwrap();
  199|     75|            let mut out = Vec::with_capacity(Self::size_link(&*guard));
  200|     75|            Self::in_order_collect(&*guard, &mut out);
  201|     75|            ArraySeqStPerS::from_vec(out)
  202|     75|        }
  203|       |
  204|      1|        fn pre_order(&self) -> ArraySeqStPerS<T> {
  205|      1|            let guard = self.root.read().unwrap();
  206|      1|            let mut out = Vec::with_capacity(Self::size_link(&*guard));
  207|      1|            Self::pre_order_collect(&*guard, &mut out);
  208|      1|            ArraySeqStPerS::from_vec(out)
  209|      1|        }
  210|       |    }
  211|       |
  212|       |    #[macro_export]
  213|       |    macro_rules! BSTSplayMtEphLit {
  214|       |        () => {
  215|       |            < $crate::Chap37::BSTSplayMtEph::BSTSplayMtEph::BSTSplayMtEph<_> as $crate::Chap37::BSTSplayMtEph::BSTSplayMtEph::BSTSplayMtEphTrait<_> >::new()
  216|       |        };
  217|       |        ( $( $x:expr ),* $(,)? ) => {{
  218|       |            let __tree = < $crate::Chap37::BSTSplayMtEph::BSTSplayMtEph::BSTSplayMtEph<_> as $crate::Chap37::BSTSplayMtEph::BSTSplayMtEph::BSTSplayMtEphTrait<_> >::new();
  219|       |            $( __tree.insert($x); )*
  220|       |            __tree
  221|       |        }};
  222|       |    }
  223|       |
  224|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap37/BSTSplayStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Ephemeral Splay Tree (standard BST semantics) with public methods.
    3|       |
    4|       |pub mod BSTSplayStEph {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    8|       |    use crate::Types::Types::*;
    9|       |
   10|       |    type Link<T> = Option<Box<Node<T>>>;
   11|       |
   12|       |    #[derive(Clone, Debug)]
   13|       |    struct Node<T: StT + Ord> {
   14|       |        key: T,
   15|       |        size: N,
   16|       |        left: Link<T>,
   17|       |        right: Link<T>,
   18|       |    }
   19|       |
   20|       |    impl<T: StT + Ord> Node<T> {
   21|    234|        fn new(key: T) -> Self {
   22|    234|            Node {
   23|    234|                key,
   24|    234|                size: 1,
   25|    234|                left: None,
   26|    234|                right: None,
   27|    234|            }
   28|    234|        }
   29|       |    }
   30|       |
   31|       |    #[derive(Debug, Clone)]
   32|       |    pub struct BSTSplayStEph<T: StT + Ord> {
   33|       |        root: Link<T>,
   34|       |    }
   35|       |
   36|       |    pub type BSTreeSplay<T> = BSTSplayStEph<T>;
   37|       |
   38|       |    pub trait BSTSplayStEphTrait<T: StT + Ord> {
   39|       |        /// claude-4-sonet: Work (1), Span (1)
   40|       |        fn new() -> Self;
   41|       |        /// claude-4-sonet: Work (1), Span (1)
   42|       |        fn size(&self) -> N;
   43|       |        /// claude-4-sonet: Work (1), Span (1)
   44|       |        fn is_empty(&self) -> B;
   45|       |        /// claude-4-sonet: Work (n), Span (n)
   46|       |        fn height(&self) -> N;
   47|       |        /// claude-4-sonet: Work (log n) amortized, (n) worst case; Span (log n) amortized, Parallelism (1)
   48|       |        fn insert(&mut self, value: T);
   49|       |        /// claude-4-sonet: Work (log n) amortized, (n) worst case; Span (log n) amortized, Parallelism (1)
   50|       |        fn find(&self, target: &T) -> Option<&T>;
   51|       |        /// claude-4-sonet: Work (log n) amortized, (n) worst case; Span (log n) amortized, Parallelism (1)
   52|       |        fn contains(&self, target: &T) -> B;
   53|       |        /// claude-4-sonet: Work (log n) amortized, (n) worst case; Span (log n) amortized, Parallelism (1)
   54|       |        fn minimum(&self) -> Option<&T>;
   55|       |        /// claude-4-sonet: Work (log n) amortized, (n) worst case; Span (log n) amortized, Parallelism (1)
   56|       |        fn maximum(&self) -> Option<&T>;
   57|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   58|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   59|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   60|       |        fn pre_order(&self) -> ArraySeqStPerS<T>;
   61|       |    }
   62|       |
   63|       |    impl<T: StT + Ord> Default for BSTSplayStEph<T> {
   64|      0|        fn default() -> Self { Self::new() }
   65|       |    }
   66|       |
   67|       |    impl<T: StT + Ord> BSTSplayStEph<T> {
   68|       |        // Private helper methods only - no public delegation
   69|       |
   70|  16.4k|        fn size_link(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }
   71|       |
   72|  8.21k|        fn update(node: &mut Node<T>) { node.size = 1 + Self::size_link(&node.left) + Self::size_link(&node.right); }
   73|       |
   74|  8.44k|        fn insert_link(link: &mut Link<T>, value: T) -> bool {
   75|  8.44k|            match link {
   76|  8.21k|                | Some(node) => {
   77|  8.21k|                    let inserted = if value < node.key {
   78|  1.23k|                        Self::insert_link(&mut node.left, value)
   79|  6.97k|                    } else if value > node.key {
   80|  6.97k|                        Self::insert_link(&mut node.right, value)
   81|       |                    } else {
   82|      1|                        false
   83|       |                    };
   84|  8.21k|                    if inserted {
   85|  8.21k|                        Self::update(node);
   86|  8.21k|                    }
                                  ^1
   87|  8.21k|                    inserted
   88|       |                }
   89|       |                | None => {
   90|    234|                    *link = Some(Box::new(Node::new(value)));
   91|    234|                    true
   92|       |                }
   93|       |            }
   94|  8.44k|        }
   95|       |
   96|     70|        fn find_link<'a>(link: &'a Link<T>, target: &T) -> Option<&'a T> {
   97|     70|            match link {
   98|      2|                | None => None,
   99|     68|                | Some(node) => {
  100|     68|                    if target == &node.key {
  101|      8|                        Some(&node.key)
  102|     60|                    } else if target < &node.key {
  103|      2|                        Self::find_link(&node.left, target)
  104|       |                    } else {
  105|     58|                        Self::find_link(&node.right, target)
  106|       |                    }
  107|       |                }
  108|       |            }
  109|     70|        }
  110|       |
  111|     55|        fn min_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  112|     55|            match link {
  113|      0|                | None => None,
  114|     55|                | Some(node) => match node.left {
  115|      3|                    | None => Some(&node.key),
  116|     52|                    | Some(_) => Self::min_link(&node.left),
  117|       |                },
  118|       |            }
  119|     55|        }
  120|       |
  121|      5|        fn max_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  122|      5|            match link {
  123|      0|                | None => None,
  124|      5|                | Some(node) => match node.right {
  125|      2|                    | None => Some(&node.key),
  126|      3|                    | Some(_) => Self::max_link(&node.right),
  127|       |                },
  128|       |            }
  129|      5|        }
  130|       |
  131|     15|        fn in_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  132|     15|            if let Some(node) = link {
                                      ^7
  133|      7|                Self::in_order_collect(&node.left, out);
  134|      7|                out.push(node.key.clone());
  135|      7|                Self::in_order_collect(&node.right, out);
  136|      8|            }
  137|     15|        }
  138|       |
  139|      7|        fn pre_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  140|      7|            if let Some(node) = link {
                                      ^3
  141|      3|                out.push(node.key.clone());
  142|      3|                Self::pre_order_collect(&node.left, out);
  143|      3|                Self::pre_order_collect(&node.right, out);
  144|      4|            }
  145|      7|        }
  146|       |    }
  147|       |
  148|       |    impl<T: StT + Ord> BSTSplayStEphTrait<T> for BSTSplayStEph<T> {
  149|     11|        fn new() -> Self { BSTSplayStEph { root: None } }
  150|       |
  151|     11|        fn size(&self) -> N { Self::size_link(&self.root) }
  152|       |
  153|      1|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
                                                                                    ^0
  154|       |
  155|      1|        fn height(&self) -> N {
  156|    129|            fn height_rec<T: StT + Ord>(link: &Link<T>) -> N {
  157|    129|                match link {
  158|     65|                    | None => 0,
  159|     64|                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),
  160|       |                }
  161|    129|            }
  162|      1|            height_rec(&self.root)
  163|      1|        }
  164|       |
  165|    235|        fn insert(&mut self, value: T) { Self::insert_link(&mut self.root, value); }
  166|       |
  167|     10|        fn find(&self, target: &T) -> Option<&T> { Self::find_link(&self.root, target) }
  168|       |
  169|      8|        fn contains(&self, target: &T) -> B { self.find(target).is_some() }
  170|       |
  171|      3|        fn minimum(&self) -> Option<&T> { Self::min_link(&self.root) }
  172|       |
  173|      2|        fn maximum(&self) -> Option<&T> { Self::max_link(&self.root) }
  174|       |
  175|      1|        fn in_order(&self) -> ArraySeqStPerS<T> {
  176|      1|            let mut out = Vec::with_capacity(self.size());
  177|      1|            Self::in_order_collect(&self.root, &mut out);
  178|      1|            ArraySeqStPerS::from_vec(out)
  179|      1|        }
  180|       |
  181|      1|        fn pre_order(&self) -> ArraySeqStPerS<T> {
  182|      1|            let mut out = Vec::with_capacity(self.size());
  183|      1|            Self::pre_order_collect(&self.root, &mut out);
  184|      1|            ArraySeqStPerS::from_vec(out)
  185|      1|        }
  186|       |    }
  187|       |
  188|       |    #[macro_export]
  189|       |    macro_rules! BSTSplayStEphLit {
  190|       |        () => {
  191|       |            < $crate::Chap37::BSTSplayStEph::BSTSplayStEph::BSTSplayStEph<_> as $crate::Chap37::BSTSplayStEph::BSTSplayStEph::BSTSplayStEphTrait<_> >::new()
  192|       |        };
  193|       |        ( $( $x:expr ),* $(,)? ) => {{
  194|       |            let mut __tree = < $crate::Chap37::BSTSplayStEph::BSTSplayStEph::BSTSplayStEph<_> as $crate::Chap37::BSTSplayStEph::BSTSplayStEph::BSTSplayStEphTrait<_> >::new();
  195|       |            $( __tree.insert($x); )*
  196|       |            __tree
  197|       |        }};
  198|       |    }
  199|       |
  200|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap38/BSTParaMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Parametric multi-threaded BST built around a joinMid interface.
    3|       |
    4|       |pub mod BSTParaMtEph {
    5|       |
    6|       |    use std::sync::{Arc, RwLock};
    7|       |
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |    use crate::Types::Types::*;
   10|       |
   11|       |    #[derive(Clone)]
   12|       |    pub enum Exposed<T: MtKey> {
   13|       |        Leaf,
   14|       |        Node(ParamBST<T>, T, ParamBST<T>),
   15|       |    }
   16|       |
   17|       |    #[derive(Clone, Debug)]
   18|       |    struct NodeInner<T: MtKey> {
   19|       |        key: T,
   20|       |        size: N,
   21|       |        left: ParamBST<T>,
   22|       |        right: ParamBST<T>,
   23|       |    }
   24|       |
   25|       |    #[derive(Debug, Clone)]
   26|       |    pub struct ParamBST<T: MtKey> {
   27|       |        root: Arc<RwLock<Option<Box<NodeInner<T>>>>>,
   28|       |    }
   29|       |
   30|       |    pub trait ParamBSTTrait<T: MtKey + 'static>: Sized {
   31|       |        /// APAS: Work O(1), Span O(1)
   32|       |        /// claude-4-sonet: Work (1), Span (1)
   33|       |        fn new() -> Self;
   34|       |        /// APAS: Work O(1), Span O(1)
   35|       |        /// claude-4-sonet: Work (1), Span (1)
   36|       |        fn expose(&self) -> Exposed<T>;
   37|       |        /// APAS: Work O(1), Span O(1)
   38|       |        /// claude-4-sonet: Work (1), Span (1)
   39|       |        fn join_mid(exposed: Exposed<T>) -> Self;
   40|       |        /// APAS: Work O(1), Span O(1)
   41|       |        /// claude-4-sonet: Work (1), Span (1)
   42|       |        fn size(&self) -> N;
   43|       |        /// APAS: Work O(1), Span O(1)
   44|       |        /// claude-4-sonet: Work (1), Span (1)
   45|       |        fn is_empty(&self) -> B;
   46|       |        /// APAS: Work O(lg |t|), Span O(lg |t|)
   47|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   48|       |        fn insert(&self, key: T);
   49|       |        /// APAS: Work O(lg |t|), Span O(lg |t|)
   50|       |        /// claude-4-sonet: Work (log n), Span (log n) with locking
   51|       |        fn delete(&self, key: &T);
   52|       |        // APAS - work O(lg |t|), span O(lg |t|)
   53|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
   54|       |        fn find(&self, key: &T) -> Option<T>;
   55|       |        // APAS - work O(lg |t|), span O(lg |t|)
   56|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
   57|       |        fn split(&self, key: &T) -> (Self, B, Self);
   58|       |        // APAS - work O(lg (|t_1| + |t_2|)), span O(lg (|t_1| + |t_2|))
   59|       |        // gpt-5-codex-medium: work O(lg (|t_1| + |t_2|)), span O(lg (|t_1| + |t_2|))
   60|       |        fn join_pair(&self, other: Self) -> Self;
   61|       |        // APAS - work O(m  lg (n / m)), span O(lg n)
   62|       |        // gpt-5-codex-medium: work O(m  lg (n / m)), span O(lg n)
   63|       |        fn union(&self, other: &Self) -> Self;
   64|       |        // APAS - work O(m  lg (n / m)), span O(lg n)
   65|       |        // gpt-5-codex-medium: work O(m  lg (n / m)), span O(lg n)
   66|       |        fn intersect(&self, other: &Self) -> Self;
   67|       |        // APAS - work O(m  lg (n / m)), span O(lg n)
   68|       |        // gpt-5-codex-medium: work O(m  lg (n / m)), span O(lg n)
   69|       |        fn difference(&self, other: &Self) -> Self;
   70|       |        // APAS - work O(|t|), span O(lg |t|)
   71|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
   72|       |        fn filter<F: Fn(&T) -> bool + Send + Sync + 'static>(&self, predicate: F) -> Self;
   73|       |        // APAS - work O(|t|), span O(lg |t|)
   74|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
   75|       |        fn reduce<F: Fn(T, T) -> T + Send + Sync + 'static>(&self, op: F, base: T) -> T;
   76|       |        // APAS - work O(|t|), span O(|t|)
   77|       |        // gpt-5-codex-medium: work O(|t|), span O(|t|)
   78|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   79|       |    }
   80|       |
   81|       |    impl<T: MtKey + 'static> ParamBST<T> {
   82|       |        // APAS - work O(1), span O(1)
   83|       |        // gpt-5-codex-medium: work O(1), span O(1)
   84|  18.0k|        fn expose_internal(&self) -> Exposed<T> {
   85|  18.0k|            let guard = self.root.read().unwrap();
   86|  18.0k|            match &*guard {
   87|  4.32k|                | None => Exposed::Leaf,
   88|  13.6k|                | Some(node) => Exposed::Node(node.left.clone(), node.key.clone(), node.right.clone()),
   89|       |            }
   90|  18.0k|        }
   91|       |
   92|       |        // APAS - work O(1), span O(1)
   93|       |        // gpt-5-codex-medium: work O(1), span O(1)
   94|  7.67k|        fn join_mid(exposed: Exposed<T>) -> Self {
   95|  7.67k|            match exposed {
   96|      5|                | Exposed::Leaf => ParamBST::new(),
   97|  7.66k|                | Exposed::Node(left, key, right) => {
   98|  7.66k|                    let size = 1 + left.size() + right.size();
   99|  7.66k|                    ParamBST {
  100|  7.66k|                        root: Arc::new(RwLock::new(Some(Box::new(NodeInner { key, size, left, right })))),
  101|  7.66k|                    }
  102|       |                }
  103|       |            }
  104|  7.67k|        }
  105|       |
  106|       |        // APAS - work O(lg |t|), span O(lg |t|)
  107|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  108|  7.71k|        fn split_inner(tree: &Self, key: &T) -> (Self, B, Self) {
  109|  7.71k|            match tree.expose_internal() {
  110|  1.75k|                | Exposed::Leaf => (ParamBST::new(), false, ParamBST::new()),
  111|  5.96k|                | Exposed::Node(left, root_key, right) => match key.cmp(&root_key) {
  112|       |                    | std::cmp::Ordering::Less => {
  113|  3.78k|                        let (ll, found, lr) = ParamBST::split_inner(&left, key);
  114|  3.78k|                        let rebuilt = ParamBST::join_mid(Exposed::Node(lr, root_key, right));
  115|  3.78k|                        (ll, found, rebuilt)
  116|       |                    }
  117|       |                    | std::cmp::Ordering::Greater => {
  118|  1.67k|                        let (rl, found, rr) = ParamBST::split_inner(&right, key);
  119|  1.67k|                        let rebuilt = ParamBST::join_mid(Exposed::Node(left, root_key, rl));
  120|  1.67k|                        (rebuilt, found, rr)
  121|       |                    }
  122|    496|                    | std::cmp::Ordering::Equal => (left, true, right),
  123|       |                },
  124|       |            }
  125|  7.71k|        }
  126|       |
  127|       |        // APAS - work O(1), span O(1)
  128|       |        // gpt-5-codex-medium: work O(1), span O(1)
  129|  2.19k|        fn join_m(left: Self, key: T, right: Self) -> Self { ParamBST::join_mid(Exposed::Node(left, key, right)) }
  130|       |
  131|       |        // APAS - work O(lg |t|), span O(lg |t|)
  132|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  133|  1.32k|        fn min_key(tree: &Self) -> Option<T> {
  134|  1.32k|            match tree.expose_internal() {
  135|     28|                | Exposed::Leaf => None,
  136|  1.29k|                | Exposed::Node(left, key, _) => match ParamBST::min_key(&left) {
  137|  1.26k|                    | Some(rec) => Some(rec),
  138|     28|                    | None => Some(key),
  139|       |                },
  140|       |            }
  141|  1.32k|        }
  142|       |
  143|       |        // APAS - work O(lg (|left| + |right|)), span O(lg (|left| + |right|))
  144|       |        // gpt-5-codex-medium: work O(lg (|left| + |right|)), span O(lg (|left| + |right|))
  145|    319|        fn join_pair_inner(left: Self, right: Self) -> Self {
  146|    319|            match right.expose_internal() {
  147|    291|                | Exposed::Leaf => left,
  148|     28|                | Exposed::Node(_, key, _) => {
  149|     28|                    let min_key = ParamBST::min_key(&right).unwrap_or(key);
  150|     28|                    let (_, _, reduced_right) = ParamBST::split_inner(&right, &min_key);
  151|     28|                    ParamBST::join_m(left, min_key, reduced_right)
  152|       |                }
  153|       |            }
  154|    319|        }
  155|       |
  156|       |        // APAS - work O(m  lg (n / m)), span O(lg n)
  157|       |        // gpt-5-codex-medium: work O(m  lg (n / m)), span O(lg n)
  158|    511|        fn union_inner(a: &Self, b: &Self) -> Self {
  159|    511|            match a.expose_internal() {
  160|    257|                | Exposed::Leaf => b.clone(),
  161|    254|                | Exposed::Node(al, ak, ar) => {
  162|    254|                    let (bl, _, br) = ParamBST::split_inner(b, &ak);
  163|    254|                    let Pair(left_union, right_union) = crate::ParaPair!(
  164|    254|                        move || ParamBST::union_inner(&al, &bl),
  165|    254|                        move || ParamBST::union_inner(&ar, &br)
  166|       |                    );
  167|    254|                    ParamBST::join_m(left_union, ak, right_union)
  168|       |                }
  169|       |            }
  170|    511|        }
  171|       |
  172|       |        // APAS - work O(m  lg (n / m)), span O(lg n)
  173|       |        // gpt-5-codex-medium: work O(m  lg (n / m)), span O(lg n)
  174|    315|        fn intersect_inner(a: &Self, b: &Self) -> Self {
  175|    315|            match (a.expose_internal(), b.expose_internal()) {
  176|    159|                | (Exposed::Leaf, _) | (_, Exposed::Leaf) => ParamBST::new(),
  177|    156|                | (Exposed::Node(al, ak, ar), _) => {
  178|    156|                    let (bl, found, br) = ParamBST::split_inner(b, &ak);
  179|    156|                    let Pair(left_res, right_res) =
  180|    156|                        crate::ParaPair!(move || ParamBST::intersect_inner(&al, &bl), move || {
  181|    156|                            ParamBST::intersect_inner(&ar, &br)
  182|    156|                        });
  183|    156|                    if found == true {
  184|    156|                        ParamBST::join_m(left_res, ak, right_res)
  185|       |                    } else {
  186|      0|                        ParamBST::join_pair_inner(left_res, right_res)
  187|       |                    }
  188|       |                }
  189|       |            }
  190|    315|        }
  191|       |
  192|       |        // APAS - work O(m  lg (n / m)), span O(lg n)
  193|       |        // gpt-5-codex-medium: work O(m  lg (n / m)), span O(lg n)
  194|    315|        fn difference_inner(a: &Self, b: &Self) -> Self {
  195|    315|            match (a.expose_internal(), b.expose_internal()) {
  196|    156|                | (Exposed::Leaf, _) => ParamBST::new(),
  197|      3|                | (_, Exposed::Leaf) => a.clone(),
  198|    156|                | (Exposed::Node(al, ak, ar), _) => {
  199|    156|                    let (bl, found, br) = ParamBST::split_inner(b, &ak);
  200|    156|                    let Pair(left_res, right_res) =
  201|    156|                        crate::ParaPair!(move || ParamBST::difference_inner(&al, &bl), move || {
  202|    156|                            ParamBST::difference_inner(&ar, &br)
  203|    156|                        });
  204|    156|                    if found == true {
  205|    156|                        ParamBST::join_pair_inner(left_res, right_res)
  206|       |                    } else {
  207|      0|                        ParamBST::join_m(left_res, ak, right_res)
  208|       |                    }
  209|       |                }
  210|       |            }
  211|    315|        }
  212|       |
  213|       |        // APAS - work O(|t|), span O(lg |t|)
  214|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  215|    547|        fn filter_inner<F: Fn(&T) -> bool + Send + Sync + 'static>(tree: &Self, predicate: &Arc<F>) -> Self {
  216|    547|            match tree.expose_internal() {
  217|    276|                | Exposed::Leaf => ParamBST::new(),
  218|    271|                | Exposed::Node(left, key, right) => {
  219|    271|                    let pred_left = Arc::clone(predicate);
  220|    271|                    let pred_right = Arc::clone(predicate);
  221|    271|                    let Pair(left_filtered, right_filtered) =
  222|    271|                        crate::ParaPair!(move || ParamBST::filter_inner(&left, &pred_left), move || {
  223|    271|                            ParamBST::filter_inner(&right, &pred_right)
  224|    271|                        });
  225|    271|                    if (**predicate)(&key) {
  226|    136|                        ParamBST::join_m(left_filtered, key, right_filtered)
  227|       |                    } else {
  228|    135|                        ParamBST::join_pair_inner(left_filtered, right_filtered)
  229|       |                    }
  230|       |                }
  231|       |            }
  232|    547|        }
  233|       |
  234|       |        // APAS - work O(|t|), span O(lg |t|)
  235|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  236|      5|        fn filter_parallel<F: Fn(&T) -> bool + Send + Sync + 'static>(tree: &Self, predicate: F) -> Self {
  237|      5|            let predicate = Arc::new(predicate);
  238|      5|            ParamBST::filter_inner(tree, &predicate)
  239|      5|        }
  240|       |
  241|       |        // APAS - work O(|t|), span O(lg |t|)
  242|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  243|    548|        fn reduce_inner<F: Fn(T, T) -> T + Send + Sync + 'static>(tree: &Self, op: &Arc<F>, identity: T) -> T {
  244|    548|            match tree.expose_internal() {
  245|    277|                | Exposed::Leaf => identity,
  246|    271|                | Exposed::Node(left, key, right) => {
  247|    271|                    let op_left = Arc::clone(op);
  248|    271|                    let op_right = Arc::clone(op);
  249|    271|                    let left_base = identity.clone();
  250|    271|                    let right_base = identity;
  251|    271|                    let Pair(left_acc, right_acc) =
  252|    271|                        crate::ParaPair!(move || ParamBST::reduce_inner(&left, &op_left, left_base), move || {
  253|    271|                            ParamBST::reduce_inner(&right, &op_right, right_base)
  254|    271|                        });
  255|    271|                    let op_ref = op.as_ref();
  256|    271|                    let right_with_key = op_ref(key, right_acc);
  257|    271|                    op_ref(left_acc, right_with_key)
  258|       |                }
  259|       |            }
  260|    548|        }
  261|       |
  262|       |        // APAS - work O(|t|), span O(lg |t|)
  263|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  264|      6|        fn reduce_parallel<F: Fn(T, T) -> T + Send + Sync + 'static>(tree: &Self, op: F, base: T) -> T {
  265|      6|            let op = Arc::new(op);
  266|      6|            ParamBST::reduce_inner(tree, &op, base)
  267|      6|        }
  268|       |
  269|       |        // APAS - work O(|t|), span O(|t|)
  270|       |        // gpt-5-codex-medium: work O(|t|), span O(|t|)
  271|  1.27k|        fn collect_in_order(tree: &Self, out: &mut Vec<T>) {
  272|  1.27k|            match tree.expose_internal() {
  273|    645|                | Exposed::Leaf => {}
  274|    631|                | Exposed::Node(left, key, right) => {
  275|    631|                    ParamBST::collect_in_order(&left, out);
  276|    631|                    out.push(key);
  277|    631|                    ParamBST::collect_in_order(&right, out);
  278|    631|                }
  279|       |            }
  280|  1.27k|        }
  281|       |    }
  282|       |
  283|       |    impl<T: MtKey + 'static> ParamBSTTrait<T> for ParamBST<T> {
  284|       |        // APAS - work O(1), span O(1)
  285|       |        // gpt-5-codex-medium: work O(1), span O(1)
  286|  4.12k|        fn new() -> Self {
  287|  4.12k|            ParamBST {
  288|  4.12k|                root: Arc::new(RwLock::new(None)),
  289|  4.12k|            }
  290|  4.12k|        }
  291|       |
  292|       |        // APAS - work O(1), span O(1)
  293|       |        // gpt-5-codex-medium: work O(1), span O(1)
  294|      3|        fn expose(&self) -> Exposed<T> { self.expose_internal() }
  295|       |
  296|       |        // APAS - work O(1), span O(1)
  297|       |        // gpt-5-codex-medium: work O(1), span O(1)
  298|      8|        fn join_mid(exposed: Exposed<T>) -> Self { ParamBST::join_mid(exposed) }
  299|       |
  300|       |        // APAS - work O(1), span O(1)
  301|       |        // gpt-5-codex-medium: work O(1), span O(1)
  302|  15.3k|        fn size(&self) -> N {
  303|  15.3k|            let guard = self.root.read().unwrap();
  304|  15.3k|            guard.as_ref().map_or(0, |node| node.size)
  305|  15.3k|        }
  306|       |
  307|       |        // APAS - work O(1), span O(1)
  308|       |        // gpt-5-codex-medium: work O(1), span O(1)
  309|      7|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
                                                                      ^0
  310|       |
  311|       |        // APAS - work O(lg |t|), span O(lg |t|)
  312|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  313|  1.62k|        fn insert(&self, key: T) {
  314|  1.62k|            let (left, _, right) = ParamBST::split_inner(self, &key);
  315|  1.62k|            let rebuilt = ParamBST::join_m(left, key, right);
  316|  1.62k|            let new_state = rebuilt.root.read().unwrap().clone();
  317|  1.62k|            let mut guard = self.root.write().unwrap();
  318|  1.62k|            *guard = new_state;
  319|  1.62k|        }
  320|       |
  321|       |        // APAS - work O(lg |t|), span O(lg |t|)
  322|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  323|     27|        fn delete(&self, key: &T) {
  324|     27|            let (left, _, right) = ParamBST::split_inner(self, key);
  325|     27|            let merged = ParamBST::join_pair_inner(left, right);
  326|     27|            let new_state = merged.root.read().unwrap().clone();
  327|     27|            let mut guard = self.root.write().unwrap();
  328|     27|            *guard = new_state;
  329|     27|        }
  330|       |
  331|       |        // APAS - work O(lg |t|), span O(lg |t|)
  332|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  333|  4.50k|        fn find(&self, key: &T) -> Option<T> {
  334|  4.50k|            match self.expose_internal() {
  335|    171|                | Exposed::Leaf => None,
  336|  4.33k|                | Exposed::Node(left, root_key, right) => match key.cmp(&root_key) {
  337|  3.78k|                    | std::cmp::Ordering::Less => ParamBSTTrait::find(&left, key),
  338|    416|                    | std::cmp::Ordering::Greater => ParamBSTTrait::find(&right, key),
  339|    138|                    | std::cmp::Ordering::Equal => Some(root_key),
  340|       |                },
  341|       |            }
  342|  4.50k|        }
  343|       |
  344|       |        // APAS - work O(lg |t|), span O(lg |t|)
  345|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  346|      4|        fn split(&self, key: &T) -> (Self, B, Self) { ParamBST::split_inner(self, key) }
  347|       |
  348|       |        // APAS - work O(lg (|t_1| + |t_2|)), span O(lg (|t_1| + |t_2|))
  349|       |        // gpt-5-codex-medium: work O(lg (|t_1| + |t_2|)), span O(lg (|t_1| + |t_2|))
  350|      1|        fn join_pair(&self, other: Self) -> Self { ParamBST::join_pair_inner(self.clone(), other) }
  351|       |
  352|       |        // APAS - work O(m  lg (n / m)), span O(lg n)
  353|       |        // gpt-5-codex-medium: work O(m  lg (n / m)), span O(lg n)
  354|      3|        fn union(&self, other: &Self) -> Self { ParamBST::union_inner(self, other) }
  355|       |
  356|       |        // APAS - work O(m  lg (n / m)), span O(lg n)
  357|       |        // gpt-5-codex-medium: work O(m  lg (n / m)), span O(lg n)
  358|      3|        fn intersect(&self, other: &Self) -> Self { ParamBST::intersect_inner(self, other) }
  359|       |
  360|       |        // APAS - work O(m  lg (n / m)), span O(lg n)
  361|       |        // gpt-5-codex-medium: work O(m  lg (n / m)), span O(lg n)
  362|      3|        fn difference(&self, other: &Self) -> Self { ParamBST::difference_inner(self, other) }
  363|       |
  364|       |        // APAS - work O(|t|), span O(lg |t|)
  365|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  366|      5|        fn filter<F: Fn(&T) -> bool + Send + Sync + 'static>(&self, predicate: F) -> Self {
  367|      5|            ParamBST::filter_parallel(self, predicate)
  368|      5|        }
  369|       |
  370|       |        // APAS - work O(|t|), span O(lg |t|)
  371|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  372|      6|        fn reduce<F: Fn(T, T) -> T + Send + Sync + 'static>(&self, op: F, base: T) -> T {
  373|      6|            ParamBST::reduce_parallel(self, op, base)
  374|      6|        }
  375|       |
  376|       |        // APAS - work O(|t|), span O(|t|)
  377|       |        // gpt-5-codex-medium: work O(|t|), span O(|t|)
  378|     14|        fn in_order(&self) -> ArraySeqStPerS<T> {
  379|     14|            let mut out = Vec::with_capacity(self.size());
  380|     14|            ParamBST::collect_in_order(self, &mut out);
  381|     14|            ArraySeqStPerS::from_vec(out)
  382|     14|        }
  383|       |    }
  384|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap38/BSTParaStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Parametric single-threaded BST built around a joinMid interface.
    3|       |
    4|       |pub mod BSTParaStEph {
    5|       |
    6|       |    use std::cell::RefCell;
    7|       |    use std::rc::Rc;
    8|       |
    9|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    #[derive(Debug, Clone, Default)]
   13|       |    pub enum Exposed<T: StT + Ord> {
   14|       |        #[default]
   15|       |        Leaf,
   16|       |        Node(ParamBST<T>, T, ParamBST<T>),
   17|       |    }
   18|       |
   19|       |    #[derive(Debug, Clone)]
   20|       |    struct NodeInner<T: StT + Ord> {
   21|       |        key: T,
   22|       |        size: N,
   23|       |        left: ParamBST<T>,
   24|       |        right: ParamBST<T>,
   25|       |    }
   26|       |
   27|       |    #[derive(Debug, Clone)]
   28|       |    pub struct ParamBST<T: StT + Ord> {
   29|       |        root: Rc<RefCell<Option<Box<NodeInner<T>>>>>,
   30|       |    }
   31|       |
   32|       |    pub trait ParamBSTTrait<T: StT + Ord>: Sized {
   33|       |        /// claude-4-sonet: Work (1), Span (1)
   34|       |        fn new() -> Self;
   35|       |        /// claude-4-sonet: Work (1), Span (1)
   36|       |        fn expose(&self) -> Exposed<T>;
   37|       |        /// claude-4-sonet: Work (1), Span (1)
   38|       |        fn join_mid(exposed: Exposed<T>) -> Self;
   39|       |        /// claude-4-sonet: Work (1), Span (1)
   40|       |        fn size(&self) -> N;
   41|       |        /// claude-4-sonet: Work (1), Span (1)
   42|       |        fn is_empty(&self) -> B;
   43|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   44|       |        fn insert(&self, key: T);
   45|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   46|       |        fn delete(&self, key: &T);
   47|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   48|       |        fn find(&self, key: &T) -> Option<T>;
   49|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   50|       |        fn split(&self, key: &T) -> (Self, B, Self);
   51|       |        /// claude-4-sonet: Work (log(|self| + |other|)), Span (log(|self| + |other|)), Parallelism (1)
   52|       |        fn join_pair(&self, other: Self) -> Self;
   53|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   54|       |        fn union(&self, other: &Self) -> Self;
   55|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   56|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   57|       |    }
   58|       |
   59|       |    impl<T: StT + Ord> ParamBST<T> {
   60|    196|        fn expose_internal(&self) -> Exposed<T> {
   61|    196|            let guard = self.root.borrow();
   62|    196|            match &*guard {
   63|     82|                | None => Exposed::Leaf,
   64|    114|                | Some(node) => Exposed::Node(node.left.clone(), node.key.clone(), node.right.clone()),
   65|       |            }
   66|    196|        }
   67|       |
   68|     81|        fn join_mid(exposed: Exposed<T>) -> Self {
   69|     81|            match exposed {
   70|      3|                | Exposed::Leaf => ParamBST::new(),
   71|     78|                | Exposed::Node(left, key, right) => {
   72|     78|                    let size = 1 + left.size() + right.size();
   73|     78|                    ParamBST {
   74|     78|                        root: Rc::new(RefCell::new(Some(Box::new(NodeInner { key, size, left, right })))),
   75|     78|                    }
   76|       |                }
   77|       |            }
   78|     81|        }
   79|       |
   80|     80|        fn split_inner(tree: &Self, key: &T) -> (Self, B, Self) {
   81|     80|            match tree.expose_internal() {
   82|     29|                | Exposed::Leaf => (ParamBST::new(), false, ParamBST::new()),
   83|     51|                | Exposed::Node(left, root_key, right) => match key.cmp(&root_key) {
   84|       |                    | std::cmp::Ordering::Less => {
   85|     17|                        let (ll, found, lr) = ParamBST::split_inner(&left, key);
   86|     17|                        let rebuilt = ParamBST::join_mid(Exposed::Node(lr, root_key, right));
   87|     17|                        (ll, found, rebuilt)
   88|       |                    }
   89|       |                    | std::cmp::Ordering::Greater => {
   90|     28|                        let (rl, found, rr) = ParamBST::split_inner(&right, key);
   91|     28|                        let rebuilt = ParamBST::join_mid(Exposed::Node(left, root_key, rl));
   92|     28|                        (rebuilt, found, rr)
   93|       |                    }
   94|      6|                    | std::cmp::Ordering::Equal => (left, true, right),
   95|       |                },
   96|       |            }
   97|     80|        }
   98|       |
   99|     32|        fn join_m(left: Self, key: T, right: Self) -> Self { ParamBST::join_mid(Exposed::Node(left, key, right)) }
  100|       |
  101|      8|        fn min_key(tree: &Self) -> Option<T> {
  102|      8|            match tree.expose_internal() {
  103|      3|                | Exposed::Leaf => None,
  104|      5|                | Exposed::Node(left, key, _) => match ParamBST::min_key(&left) {
  105|      2|                    | Some(rec) => Some(rec),
  106|      3|                    | None => Some(key),
  107|       |                },
  108|       |            }
  109|      8|        }
  110|       |
  111|      3|        fn join_pair_inner(left: Self, right: Self) -> Self {
  112|      3|            match right.expose_internal() {
  113|      0|                | Exposed::Leaf => left,
  114|      3|                | Exposed::Node(_, key, _) => {
  115|      3|                    let min_key = ParamBST::min_key(&right).unwrap_or(key);
  116|      3|                    let (_, _, reduced_right) = ParamBST::split_inner(&right, &min_key);
  117|      3|                    ParamBST::join_m(left, min_key, reduced_right)
  118|       |                }
  119|       |            }
  120|      3|        }
  121|       |
  122|      9|        fn union_inner(a: &Self, b: &Self) -> Self {
  123|      9|            match a.expose_internal() {
  124|      5|                | Exposed::Leaf => b.clone(),
  125|      4|                | Exposed::Node(al, ak, ar) => {
  126|      4|                    let (bl, _, br) = ParamBST::split_inner(b, &ak);
  127|      4|                    let left_union = ParamBST::union_inner(&al, &bl);
  128|      4|                    let right_union = ParamBST::union_inner(&ar, &br);
  129|      4|                    ParamBST::join_m(left_union, ak, right_union)
  130|       |                }
  131|       |            }
  132|      9|        }
  133|       |
  134|     72|        fn collect_in_order(tree: &Self, out: &mut Vec<T>) {
  135|     72|            match tree.expose_internal() {
  136|     39|                | Exposed::Leaf => {}
  137|     33|                | Exposed::Node(left, key, right) => {
  138|     33|                    ParamBST::collect_in_order(&left, out);
  139|     33|                    out.push(key);
  140|     33|                    ParamBST::collect_in_order(&right, out);
  141|     33|                }
  142|       |            }
  143|     72|        }
  144|       |    }
  145|       |
  146|       |    impl<T: StT + Ord> ParamBSTTrait<T> for ParamBST<T> {
  147|     67|        fn new() -> Self {
  148|     67|            ParamBST {
  149|     67|                root: Rc::new(RefCell::new(None)),
  150|     67|            }
  151|     67|        }
  152|       |
  153|      2|        fn expose(&self) -> Exposed<T> { self.expose_internal() }
  154|       |
  155|      4|        fn join_mid(exposed: Exposed<T>) -> Self { ParamBST::join_mid(exposed) }
  156|       |
  157|    168|        fn size(&self) -> N { self.root.borrow().as_ref().map_or(0, |node| node.size) }
  158|       |
  159|      1|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
                                                                      ^0
  160|       |
  161|     25|        fn insert(&self, key: T) {
  162|     25|            let (left, _, right) = ParamBST::split_inner(self, &key);
  163|     25|            let rebuilt = ParamBST::join_m(left, key, right);
  164|     25|            let new_state = { rebuilt.root.borrow().clone() };
  165|     25|            *self.root.borrow_mut() = new_state;
  166|     25|        }
  167|       |
  168|      2|        fn delete(&self, key: &T) {
  169|      2|            let (left, _, right) = ParamBST::split_inner(self, key);
  170|      2|            let merged = ParamBST::join_pair_inner(left, right);
  171|      2|            let new_state = { merged.root.borrow().clone() };
  172|      2|            *self.root.borrow_mut() = new_state;
  173|      2|        }
  174|       |
  175|     22|        fn find(&self, key: &T) -> Option<T> {
  176|     22|            match self.expose_internal() {
  177|      5|                | Exposed::Leaf => None,
  178|     17|                | Exposed::Node(left, root_key, right) => match key.cmp(&root_key) {
  179|      7|                    | std::cmp::Ordering::Less => ParamBSTTrait::find(&left, key),
  180|      6|                    | std::cmp::Ordering::Greater => ParamBSTTrait::find(&right, key),
  181|      4|                    | std::cmp::Ordering::Equal => Some(root_key),
  182|       |                },
  183|       |            }
  184|     22|        }
  185|       |
  186|      1|        fn split(&self, key: &T) -> (Self, B, Self) { ParamBST::split_inner(self, key) }
  187|       |
  188|      1|        fn join_pair(&self, other: Self) -> Self { ParamBST::join_pair_inner(self.clone(), other) }
  189|       |
  190|      1|        fn union(&self, other: &Self) -> Self { ParamBST::union_inner(self, other) }
  191|       |
  192|      6|        fn in_order(&self) -> ArraySeqStPerS<T> {
  193|      6|            let mut out = Vec::with_capacity(self.size());
  194|      6|            ParamBST::collect_in_order(self, &mut out);
  195|      6|            ArraySeqStPerS::from_vec(out)
  196|      6|        }
  197|       |    }
  198|       |
  199|       |    #[macro_export]
  200|       |    macro_rules! ParamBSTLit {
  201|       |        () => {
  202|       |            < $crate::Chap38::BSTParaStEph::BSTParaStEph::ParamBST<_> as $crate::Chap38::BSTParaStEph::BSTParaStEph::ParamBSTTrait<_> >::new()
  203|       |        };
  204|       |        ( $( $x:expr ),* $(,)? ) => {{
  205|       |            let __tree = < $crate::Chap38::BSTParaStEph::BSTParaStEph::ParamBST<_> as
  206|       |                           $crate::Chap38::BSTParaStEph::BSTParaStEph::ParamBSTTrait<_> >::new();
  207|       |            $( __tree.insert($x); )*
  208|       |            __tree
  209|       |        }};
  210|       |    }
  211|       |
  212|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap39/BSTParaTreapMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Parametric multi-threaded Treap (probabilistically balanced BST) with parallel operations.
    3|       |
    4|       |pub mod BSTParaTreapMtEph {
    5|       |
    6|       |    use std::fmt::Write;
    7|       |    use std::hash::{Hash, Hasher};
    8|       |    use std::sync::{Arc, RwLock};
    9|       |
   10|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
   11|       |    use crate::Types::Types::*;
   12|       |
   13|       |    #[derive(Clone)]
   14|       |    pub enum Exposed<T: MtKey> {
   15|       |        Leaf,
   16|       |        Node(ParamTreap<T>, T, ParamTreap<T>),
   17|       |    }
   18|       |
   19|       |    #[derive(Clone)]
   20|       |    struct NodeInner<T: MtKey> {
   21|       |        key: T,
   22|       |        priority: i64,
   23|       |        size: N,
   24|       |        left: ParamTreap<T>,
   25|       |        right: ParamTreap<T>,
   26|       |    }
   27|       |
   28|       |    #[derive(Clone)]
   29|       |    pub struct ParamTreap<T: MtKey> {
   30|       |        root: Arc<RwLock<Option<Box<NodeInner<T>>>>>,
   31|       |    }
   32|       |
   33|    207|    fn priority_for<T: MtKey>(key: &T) -> i64 {
   34|    207|        let mut hasher = std::collections::hash_map::DefaultHasher::new();
   35|    207|        let mut buf = String::new();
   36|    207|        let _ = write!(&mut buf, "{:?}", key);
   37|    207|        Hash::hash(&buf, &mut hasher);
   38|    207|        hasher.finish() as i64
   39|    207|    }
   40|       |
   41|  2.22k|    fn tree_priority<T: MtKey>(tree: &ParamTreap<T>) -> i64 {
   42|  2.22k|        let guard = tree.root.read().unwrap();
   43|  2.22k|        guard.as_ref().map_or(i64::MIN, |node| node.priority)
   44|  2.22k|    }
   45|       |
   46|  2.26k|    fn tree_size<T: MtKey>(tree: &ParamTreap<T>) -> N {
   47|  2.26k|        let guard = tree.root.read().unwrap();
   48|  2.26k|        guard.as_ref().map_or(0, |node| node.size)
   49|  2.26k|    }
   50|       |
   51|  1.11k|    fn make_node<T: MtKey>(left: ParamTreap<T>, key: T, priority: i64, right: ParamTreap<T>) -> ParamTreap<T> {
   52|  1.11k|        let size = 1 + tree_size(&left) + tree_size(&right);
   53|  1.11k|        ParamTreap {
   54|  1.11k|            root: Arc::new(RwLock::new(Some(Box::new(NodeInner {
   55|  1.11k|                key,
   56|  1.11k|                priority,
   57|  1.11k|                size,
   58|  1.11k|                left,
   59|  1.11k|                right,
   60|  1.11k|            })))),
   61|  1.11k|        }
   62|  1.11k|    }
   63|       |
   64|       |    impl<T: MtKey + 'static> ParamTreap<T> {
   65|       |        // APAS - work O(1), span O(1)
   66|       |        // gpt-5-codex-medium: work O(1), span O(1)
   67|    802|        fn expose_internal(&self) -> Exposed<T> {
   68|    802|            let guard = self.root.read().unwrap();
   69|    802|            match &*guard {
   70|      8|                | None => Exposed::Leaf,
   71|    794|                | Some(node) => Exposed::Node(node.left.clone(), node.key.clone(), node.right.clone()),
   72|       |            }
   73|    802|        }
   74|       |
   75|       |        // APAS - work O(1), span O(1)
   76|       |        // gpt-5-codex-medium: work O(1), span O(1)
   77|  1.25k|        pub fn expose_with_priority(&self) -> Option<(ParamTreap<T>, T, i64, ParamTreap<T>)> {
   78|  1.25k|            let guard = self.root.read().unwrap();
   79|  1.25k|            guard
   80|  1.25k|                .as_ref()
   81|  1.25k|                .map(|node| (node.left.clone(), node.key.clone(), node.priority, node.right.clone()))
                                           ^939      ^939     ^939     ^939     ^939           ^939       ^939
   82|  1.25k|        }
   83|       |
   84|       |        // APAS - work O(lg (|left| + |right|)), span O(lg (|left| + |right|))
   85|       |        // gpt-5-codex-medium: work O(lg (|left| + |right|)), span O(lg (|left| + |right|))
   86|  1.11k|        fn join_with_priority(left: ParamTreap<T>, key: T, priority: i64, right: ParamTreap<T>) -> ParamTreap<T> {
   87|  1.11k|            let left_priority = tree_priority(&left);
   88|  1.11k|            let right_priority = tree_priority(&right);
   89|  1.11k|            if priority > left_priority && priority > right_priority {
                                                         ^778
   90|    765|                return make_node(left, key, priority, right);
   91|    349|            }
   92|    349|            if left_priority > right_priority {
   93|    334|                if let Some((ll, lk, lp, lr)) = left.expose_with_priority() {
   94|    334|                    let merged_right = ParamTreap::join_with_priority(lr, key, priority, right);
   95|    334|                    return make_node(ll, lk, lp, merged_right);
   96|      0|                }
   97|      0|                make_node(left, key, priority, right)
   98|       |            } else {
   99|     15|                if let Some((rl, rk, rp, rr)) = right.expose_with_priority() {
  100|     15|                    let merged_left = ParamTreap::join_with_priority(left, key, priority, rl);
  101|     15|                    return make_node(merged_left, rk, rp, rr);
  102|      0|                }
  103|      0|                make_node(left, key, priority, right)
  104|       |            }
  105|  1.11k|        }
  106|       |
  107|       |        // APAS - work O(1), span O(1)
  108|       |        // gpt-5-codex-medium: work O(1), span O(1)
  109|      1|        fn join_mid(exposed: Exposed<T>) -> Self {
  110|      1|            match exposed {
  111|      0|                | Exposed::Leaf => ParamTreap::new(),
  112|      1|                | Exposed::Node(left, key, right) => {
  113|      1|                    let priority = priority_for(&key);
  114|      1|                    ParamTreap::join_with_priority(left, key, priority, right)
  115|       |                }
  116|       |            }
  117|      1|        }
  118|       |
  119|       |        // APAS - work O(lg |t|), span O(lg |t|)
  120|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  121|    775|        fn split_inner(tree: &Self, key: &T) -> (Self, B, Self) {
  122|    775|            match tree.expose_with_priority() {
  123|    237|                | None => (ParamTreap::new(), false, ParamTreap::new()),
  124|    538|                | Some((left, root_key, priority, right)) => match key.cmp(&root_key) {
  125|       |                    | std::cmp::Ordering::Less => {
  126|     41|                        let (ll, found, lr) = ParamTreap::split_inner(&left, key);
  127|     41|                        let rebuilt = ParamTreap::join_with_priority(lr, root_key, priority, right);
  128|     41|                        (ll, found, rebuilt)
  129|       |                    }
  130|       |                    | std::cmp::Ordering::Greater => {
  131|    484|                        let (rl, found, rr) = ParamTreap::split_inner(&right, key);
  132|    484|                        let rebuilt = ParamTreap::join_with_priority(left, root_key, priority, rl);
  133|    484|                        (rebuilt, found, rr)
  134|       |                    }
  135|     13|                    | std::cmp::Ordering::Equal => (left, true, right),
  136|       |                },
  137|       |            }
  138|    775|        }
  139|       |
  140|       |        // APAS - work O(m  lg (n / m)), span O(lg n)
  141|       |        // gpt-5-codex-medium: work O(m  lg (n / m)), span O(lg n)
  142|     53|        fn join_pair_inner(left: Self, right: Self) -> Self {
  143|     53|            match right.expose_with_priority() {
  144|     36|                | None => left,
  145|     17|                | Some((r_left, r_key, r_priority, r_right)) => {
  146|     17|                    let (split_left, _, split_right) = ParamTreap::split_inner(&left, &r_key);
  147|     17|                    let combined_left = ParamTreap::join_pair_inner(split_left, r_left);
  148|     17|                    let combined_right = ParamTreap::join_pair_inner(split_right, r_right);
  149|     17|                    ParamTreap::join_with_priority(combined_left, r_key, r_priority, combined_right)
  150|       |                }
  151|       |            }
  152|     53|        }
  153|       |
  154|       |        // APAS - work O(m  lg (n / m)), span O(lg n)
  155|       |        // gpt-5-codex-medium: work O(m  lg (n / m)), span O(lg n)
  156|     14|        fn union_inner(a: &Self, b: &Self) -> Self {
  157|     14|            match a.expose_with_priority() {
  158|      8|                | None => b.clone(),
  159|      6|                | Some((al, ak, ap, ar)) => {
  160|      6|                    let (bl, _, br) = ParamTreap::split_inner(b, &ak);
  161|      6|                    let Pair(left_union, right_union) =
  162|      6|                        crate::ParaPair!(move || ParamTreap::union_inner(&al, &bl), move || {
  163|      6|                            ParamTreap::union_inner(&ar, &br)
  164|      6|                        });
  165|      6|                    ParamTreap::join_with_priority(left_union, ak, ap, right_union)
  166|       |                }
  167|       |            }
  168|     14|        }
  169|       |
  170|       |        // APAS - work O(m  lg (n / m)), span O(lg n)
  171|       |        // gpt-5-codex-medium: work O(m  lg (n / m)), span O(lg n)
  172|     14|        fn intersect_inner(a: &Self, b: &Self) -> Self {
  173|     14|            match a.expose_with_priority() {
  174|      8|                | None => ParamTreap::new(),
  175|      6|                | Some((al, ak, ap, ar)) => {
  176|      6|                    let (bl, found, br) = ParamTreap::split_inner(b, &ak);
  177|      6|                    let Pair(left_res, right_res) =
  178|      6|                        crate::ParaPair!(move || ParamTreap::intersect_inner(&al, &bl), move || {
  179|      6|                            ParamTreap::intersect_inner(&ar, &br)
  180|      6|                        });
  181|      6|                    if found == true {
  182|      2|                        ParamTreap::join_with_priority(left_res, ak, ap, right_res)
  183|       |                    } else {
  184|      4|                        ParamTreap::join_pair_inner(left_res, right_res)
  185|       |                    }
  186|       |                }
  187|       |            }
  188|     14|        }
  189|       |
  190|       |        // APAS - work O(m  lg (n / m)), span O(lg n)
  191|       |        // gpt-5-codex-medium: work O(m  lg (n / m)), span O(lg n)
  192|     16|        fn difference_inner(a: &Self, b: &Self) -> Self {
  193|     16|            match a.expose_with_priority() {
  194|      9|                | None => ParamTreap::new(),
  195|      7|                | Some((al, ak, ap, ar)) => {
  196|      7|                    let (bl, found, br) = ParamTreap::split_inner(b, &ak);
  197|      7|                    let Pair(left_res, right_res) =
  198|      7|                        crate::ParaPair!(move || ParamTreap::difference_inner(&al, &bl), move || {
  199|      7|                            ParamTreap::difference_inner(&ar, &br)
  200|      7|                        });
  201|      7|                    if found == true {
  202|      5|                        ParamTreap::join_pair_inner(left_res, right_res)
  203|       |                    } else {
  204|      2|                        ParamTreap::join_with_priority(left_res, ak, ap, right_res)
  205|       |                    }
  206|       |                }
  207|       |            }
  208|     16|        }
  209|       |
  210|       |        // APAS - work O(|t|), span O(lg |t|)
  211|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  212|     25|        fn filter_inner<F: Pred<T>>(tree: &Self, predicate: &Arc<F>) -> Self {
  213|     25|            match tree.expose_with_priority() {
  214|     14|                | None => ParamTreap::new(),
  215|     11|                | Some((left, key, priority, right)) => {
  216|     11|                    let pred_left = Arc::clone(predicate);
  217|     11|                    let pred_right = Arc::clone(predicate);
  218|     11|                    let Pair(left_filtered, right_filtered) =
  219|     11|                        crate::ParaPair!(move || ParamTreap::filter_inner(&left, &pred_left), move || {
  220|     11|                            ParamTreap::filter_inner(&right, &pred_right)
  221|     11|                        });
  222|     11|                    if (**predicate)(&key) {
  223|      6|                        ParamTreap::join_with_priority(left_filtered, key, priority, right_filtered)
  224|       |                    } else {
  225|      5|                        ParamTreap::join_pair_inner(left_filtered, right_filtered)
  226|       |                    }
  227|       |                }
  228|       |            }
  229|     25|        }
  230|       |
  231|       |        // APAS - work O(|t|), span O(lg |t|)
  232|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  233|      3|        fn filter_parallel<F: Pred<T>>(tree: &Self, predicate: F) -> Self {
  234|      3|            let predicate = Arc::new(predicate);
  235|      3|            ParamTreap::filter_inner(tree, &predicate)
  236|      3|        }
  237|       |
  238|       |        // APAS - work O(|t|), span O(lg |t|)
  239|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  240|     10|        fn reduce_inner<F>(tree: &Self, op: &Arc<F>, identity: T) -> T
  241|     10|        where
  242|     10|            F: Fn(T, T) -> T + Send + Sync + 'static,
  243|       |        {
  244|     10|            match tree.expose_with_priority() {
  245|      6|                | None => identity,
  246|      4|                | Some((left, key, _priority, right)) => {
  247|      4|                    let op_left = Arc::clone(op);
  248|      4|                    let op_right = Arc::clone(op);
  249|      4|                    let left_base = identity.clone();
  250|      4|                    let right_base = identity;
  251|      4|                    let Pair(left_acc, right_acc) = crate::ParaPair!(
  252|      4|                        move || ParamTreap::reduce_inner(&left, &op_left, left_base),
  253|      4|                        move || ParamTreap::reduce_inner(&right, &op_right, right_base)
  254|       |                    );
  255|      4|                    let op_ref = op.as_ref();
  256|      4|                    let right_with_key = op_ref(key, right_acc);
  257|      4|                    op_ref(left_acc, right_with_key)
  258|       |                }
  259|       |            }
  260|     10|        }
  261|       |
  262|       |        // APAS - work O(|t|), span O(lg |t|)
  263|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  264|      2|        fn reduce_parallel<F>(tree: &Self, op: F, base: T) -> T
  265|      2|        where
  266|      2|            F: Fn(T, T) -> T + Send + Sync + 'static,
  267|       |        {
  268|      2|            let op = Arc::new(op);
  269|      2|            ParamTreap::reduce_inner(tree, &op, base)
  270|      2|        }
  271|       |
  272|       |        // APAS - work O(|t|), span O(|t|)
  273|       |        // gpt-5-codex-medium: work O(|t|), span O(|t|)
  274|      0|        fn collect_in_order(tree: &Self, out: &mut Vec<T>) {
  275|      0|            match tree.expose_internal() {
  276|      0|                | Exposed::Leaf => {}
  277|      0|                | Exposed::Node(left, key, right) => {
  278|      0|                    ParamTreap::collect_in_order(&left, out);
  279|      0|                    out.push(key);
  280|      0|                    ParamTreap::collect_in_order(&right, out);
  281|      0|                }
  282|       |            }
  283|      0|        }
  284|       |    }
  285|       |
  286|       |    pub trait ParamTreapTrait<T: MtKey + 'static>: Sized {
  287|       |        /// APAS: Work O(1), Span O(1)
  288|       |        /// claude-4-sonet: Work (1), Span (1)
  289|       |        fn new() -> Self;
  290|       |        /// APAS: Work O(1), Span O(1)
  291|       |        /// claude-4-sonet: Work (1), Span (1)
  292|       |        fn expose(&self) -> Exposed<T>;
  293|       |        /// APAS: Work O(1), Span O(1)
  294|       |        /// claude-4-sonet: Work (1), Span (1)
  295|       |        fn join_mid(exposed: Exposed<T>) -> Self;
  296|       |        /// APAS: Work O(1), Span O(1)
  297|       |        /// claude-4-sonet: Work (1), Span (1)
  298|       |        fn size(&self) -> N;
  299|       |        /// APAS: Work O(1), Span O(1)
  300|       |        /// claude-4-sonet: Work (1), Span (1)
  301|       |        fn is_empty(&self) -> B;
  302|       |        // APAS - work O(lg |t|), span O(lg |t|)
  303|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  304|       |        fn insert(&self, key: T);
  305|       |        // APAS - work O(lg |t|), span O(lg |t|)
  306|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  307|       |        fn delete(&self, key: &T);
  308|       |        // APAS - work O(lg |t|), span O(lg |t|)
  309|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  310|       |        fn find(&self, key: &T) -> Option<T>;
  311|       |        // APAS - work O(lg |t|), span O(lg |t|)
  312|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  313|       |        fn split(&self, key: &T) -> (Self, B, Self);
  314|       |        // APAS - work O(lg (|t_1| + |t_2|)), span O(lg (|t_1| + |t_2|))
  315|       |        // gpt-5-codex-medium: work O(lg (|t_1| + |t_2|)), span O(lg (|t_1| + |t_2|))
  316|       |        fn join_pair(&self, other: Self) -> Self;
  317|       |        // APAS - work O(m  lg (n / m)), span O(lg n)
  318|       |        // gpt-5-codex-medium: work O(m  lg (n / m)), span O(lg n)
  319|       |        fn union(&self, other: &Self) -> Self;
  320|       |        // APAS - work O(m  lg (n / m)), span O(lg n)
  321|       |        // gpt-5-codex-medium: work O(m  lg (n / m)), span O(lg n)
  322|       |        fn intersect(&self, other: &Self) -> Self;
  323|       |        // APAS - work O(m  lg (n / m)), span O(lg n)
  324|       |        // gpt-5-codex-medium: work O(m  lg (n / m)), span O(lg n)
  325|       |        fn difference(&self, other: &Self) -> Self;
  326|       |        // APAS - work O(|t|), span O(lg |t|)
  327|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  328|       |        fn filter<F: Pred<T>>(&self, predicate: F) -> Self;
  329|       |        // APAS - work O(|t|), span O(lg |t|)
  330|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  331|       |        fn reduce<F>(&self, op: F, base: T) -> T
  332|       |        where
  333|       |            F: Fn(T, T) -> T + Send + Sync + 'static;
  334|       |        // APAS - work O(|t|), span O(|t|)
  335|       |        // gpt-5-codex-medium: work O(|t|), span O(|t|)
  336|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
  337|       |    }
  338|       |
  339|       |    impl<T: MtKey + 'static> ParamTreapTrait<T> for ParamTreap<T> {
  340|       |        // APAS - work O(1), span O(1)
  341|       |        // gpt-5-codex-medium: work O(1), span O(1)
  342|    541|        fn new() -> Self {
  343|    541|            ParamTreap {
  344|    541|                root: Arc::new(RwLock::new(None)),
  345|    541|            }
  346|    541|        }
  347|       |
  348|       |        // APAS - work O(1), span O(1)
  349|       |        // gpt-5-codex-medium: work O(1), span O(1)
  350|      3|        fn expose(&self) -> Exposed<T> { self.expose_internal() }
  351|       |
  352|       |        // APAS - work O(1), span O(1)
  353|       |        // gpt-5-codex-medium: work O(1), span O(1)
  354|      1|        fn join_mid(exposed: Exposed<T>) -> Self { ParamTreap::join_mid(exposed) }
  355|       |
  356|       |        // APAS - work O(1), span O(1)
  357|       |        // gpt-5-codex-medium: work O(1), span O(1)
  358|     34|        fn size(&self) -> N { tree_size(self) }
  359|       |
  360|       |        // APAS - work O(1), span O(1)
  361|       |        // gpt-5-codex-medium: work O(1), span O(1)
  362|      2|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
                                                                      ^1            ^1
  363|       |
  364|       |        // APAS - work O(lg |t|), span O(lg |t|)
  365|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  366|    206|        fn insert(&self, key: T) {
  367|    206|            let (left, _, right) = ParamTreap::split_inner(self, &key);
  368|    206|            let priority = priority_for(&key);
  369|    206|            let rebuilt = ParamTreap::join_with_priority(left, key, priority, right);
  370|    206|            let new_state = rebuilt.root.read().unwrap().clone();
  371|    206|            let mut guard = self.root.write().unwrap();
  372|    206|            *guard = new_state;
  373|    206|        }
  374|       |
  375|       |        // APAS - work O(lg |t|), span O(lg |t|)
  376|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  377|      4|        fn delete(&self, key: &T) {
  378|      4|            let (left, _, right) = ParamTreap::split_inner(self, key);
  379|      4|            let merged = ParamTreap::join_pair_inner(left, right);
  380|      4|            let new_state = merged.root.read().unwrap().clone();
  381|      4|            let mut guard = self.root.write().unwrap();
  382|      4|            *guard = new_state;
  383|      4|        }
  384|       |
  385|       |        // APAS - work O(lg |t|), span O(lg |t|)
  386|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  387|    799|        fn find(&self, key: &T) -> Option<T> {
  388|    799|            match self.expose_internal() {
  389|      7|                | Exposed::Leaf => None,
  390|    792|                | Exposed::Node(left, root_key, right) => match key.cmp(&root_key) {
  391|    361|                    | std::cmp::Ordering::Less => ParamTreapTrait::find(&left, key),
  392|    305|                    | std::cmp::Ordering::Greater => ParamTreapTrait::find(&right, key),
  393|    126|                    | std::cmp::Ordering::Equal => Some(root_key),
  394|       |                },
  395|       |            }
  396|    799|        }
  397|       |
  398|       |        // APAS - work O(lg |t|), span O(lg |t|)
  399|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  400|      4|        fn split(&self, key: &T) -> (Self, B, Self) { ParamTreap::split_inner(self, key) }
  401|       |
  402|       |        // APAS - work O(lg (|t_1| + |t_2|)), span O(lg (|t_1| + |t_2|))
  403|       |        // gpt-5-codex-medium: work O(lg (|t_1| + |t_2|)), span O(lg (|t_1| + |t_2|))
  404|      1|        fn join_pair(&self, other: Self) -> Self { ParamTreap::join_pair_inner(self.clone(), other) }
  405|       |
  406|       |        // APAS - work O(m  lg (n / m)), span O(lg n)
  407|       |        // gpt-5-codex-medium: work O(m  lg (n / m)), span O(lg n)
  408|      2|        fn union(&self, other: &Self) -> Self { ParamTreap::union_inner(self, other) }
  409|       |
  410|       |        // APAS - work O(m  lg (n / m)), span O(lg n)
  411|       |        // gpt-5-codex-medium: work O(m  lg (n / m)), span O(lg n)
  412|      2|        fn intersect(&self, other: &Self) -> Self { ParamTreap::intersect_inner(self, other) }
  413|       |
  414|       |        // APAS - work O(m  lg (n / m)), span O(lg n)
  415|       |        // gpt-5-codex-medium: work O(m  lg (n / m)), span O(lg n)
  416|      2|        fn difference(&self, other: &Self) -> Self { ParamTreap::difference_inner(self, other) }
  417|       |
  418|       |        // APAS - work O(|t|), span O(lg |t|)
  419|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  420|      3|        fn filter<F: Pred<T>>(&self, predicate: F) -> Self { ParamTreap::filter_parallel(self, predicate) }
  421|       |
  422|       |        // APAS - work O(|t|), span O(lg |t|)
  423|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  424|      2|        fn reduce<F>(&self, op: F, base: T) -> T
  425|      2|        where
  426|      2|            F: Fn(T, T) -> T + Send + Sync + 'static,
  427|       |        {
  428|      2|            ParamTreap::reduce_parallel(self, op, base)
  429|      2|        }
  430|       |
  431|       |        // APAS - work O(|t|), span O(|t|)
  432|       |        // gpt-5-codex-medium: work O(|t|), span O(|t|)
  433|      0|        fn in_order(&self) -> ArraySeqStPerS<T> {
  434|      0|            let mut out = Vec::with_capacity(self.size());
  435|      0|            ParamTreap::collect_in_order(self, &mut out);
  436|      0|            ArraySeqStPerS::from_vec(out)
  437|      0|        }
  438|       |    }
  439|       |
  440|       |    #[macro_export]
  441|       |    macro_rules! ParamTreapLit {
  442|       |        () => {
  443|       |            < $crate::Chap39::BSTParaTreapMtEph::BSTParaTreapMtEph::ParamTreap<_> as $crate::Chap39::BSTParaTreapMtEph::BSTParaTreapMtEph::ParamTreapTrait<_> >::new()
  444|       |        };
  445|       |        ( $( $x:expr ),* $(,)? ) => {{
  446|       |            let __tree = < $crate::Chap39::BSTParaTreapMtEph::BSTParaTreapMtEph::ParamTreap<_> as $crate::Chap39::BSTParaTreapMtEph::BSTParaTreapMtEph::ParamTreapTrait<_> >::new();
  447|       |            $( __tree.insert($x); )*
  448|       |            __tree
  449|       |        }};
  450|       |    }
  451|       |
  452|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap39/BSTSetTreapMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Set interface built atop the Treap multi-threaded BST implementation.
    3|       |
    4|       |pub mod BSTSetTreapMtEph {
    5|       |
    6|       |    use std::collections::BTreeSet;
    7|       |
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |    use crate::Chap39::BSTTreapMtEph::BSTTreapMtEph::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    #[derive(Debug, Clone)]
   13|       |    pub struct BSTSetTreapMtEph<T: StTInMtT + Ord> {
   14|       |        tree: BSTTreapMtEph<T>,
   15|       |    }
   16|       |
   17|       |    pub type BSTSetTreapMt<T> = BSTSetTreapMtEph<T>;
   18|       |
   19|       |    pub trait BSTSetTreapMtEphTrait<T: StTInMtT + Ord>: Sized {
   20|       |        /// claude-4-sonet: Work (1), Span (1)
   21|       |        fn empty() -> Self;
   22|       |        /// claude-4-sonet: Work (1), Span (1)
   23|       |        fn singleton(value: T) -> Self;
   24|       |        /// claude-4-sonet: Work (1), Span (1)
   25|       |        fn size(&self) -> N;
   26|       |        /// claude-4-sonet: Work (1), Span (1)
   27|       |        fn is_empty(&self) -> B;
   28|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected with locking
   29|       |        fn find(&self, value: &T) -> Option<T>;
   30|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected with locking
   31|       |        fn contains(&self, value: &T) -> B;
   32|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected with locking
   33|       |        fn minimum(&self) -> Option<T>;
   34|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected with locking
   35|       |        fn maximum(&self) -> Option<T>;
   36|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected with locking
   37|       |        fn insert(&mut self, value: T);
   38|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected with locking
   39|       |        fn delete(&mut self, target: &T);
   40|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   41|       |        fn union(&self, other: &Self) -> Self;
   42|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   43|       |        fn intersection(&self, other: &Self) -> Self;
   44|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   45|       |        fn difference(&self, other: &Self) -> Self;
   46|       |        /// claude-4-sonet: Work (log n) expected, Span (log n)
   47|       |        fn split(&self, pivot: &T) -> (Self, B, Self);
   48|       |        /// claude-4-sonet: Work (log(|left| + |right|)), Span (log(|left| + |right|))
   49|       |        fn join_pair(left: Self, right: Self) -> Self;
   50|       |        /// claude-4-sonet: Work (log(|left| + |right|)), Span (log(|left| + |right|))
   51|       |        fn join_m(left: Self, pivot: T, right: Self) -> Self;
   52|       |        /// claude-4-sonet: Work (n), Span (n)
   53|       |        fn filter<F: FnMut(&T) -> bool>(&self, predicate: F) -> Self;
   54|       |        /// claude-4-sonet: Work (n), Span (n)
   55|       |        fn reduce<F: FnMut(T, T) -> T>(&self, op: F, base: T) -> T;
   56|       |        /// claude-4-sonet: Work (n), Span (n)
   57|       |        fn iter_in_order(&self) -> ArraySeqStPerS<T>;
   58|       |        /// claude-4-sonet: Work (1), Span (1)
   59|       |        fn as_tree(&self) -> &BSTTreapMtEph<T>;
   60|       |    }
   61|       |
   62|       |    impl<T: StTInMtT + Ord> BSTSetTreapMtEph<T> {
   63|     71|        pub fn empty() -> Self {
   64|     71|            Self {
   65|     71|                tree: BSTTreapMtEph::new(),
   66|     71|            }
   67|     71|        }
   68|       |
   69|      2|        pub fn singleton(value: T) -> Self {
   70|      2|            let tree = BSTTreapMtEph::new();
   71|      2|            tree.insert(value);
   72|      2|            Self { tree }
   73|      2|        }
   74|       |
   75|     70|        pub fn size(&self) -> N { self.tree.size() }
   76|       |
   77|      4|        pub fn is_empty(&self) -> B { self.tree.is_empty() }
   78|       |
   79|      4|        pub fn find(&self, value: &T) -> Option<T> { self.tree.find(value) }
   80|       |
   81|     46|        pub fn contains(&self, value: &T) -> B { self.tree.contains(value) }
   82|       |
   83|      9|        pub fn minimum(&self) -> Option<T> { self.tree.minimum() }
   84|       |
   85|      9|        pub fn maximum(&self) -> Option<T> { self.tree.maximum() }
   86|       |
   87|    534|        pub fn insert(&mut self, value: T) { self.tree.insert(value); }
   88|       |
   89|      6|        pub fn delete(&mut self, target: &T) {
   90|      6|            let mut values = self.values_vec();
   91|     21|            if let Some(pos) = values.iter().position(|x| x == target) {
                                      ^6     ^6            ^6
   92|      6|                values.remove(pos);
   93|      6|                self.tree = Self::rebuild_from_vec(values);
   94|      6|            }
                          ^0
   95|      6|        }
   96|       |
   97|      9|        pub fn union(&self, other: &Self) -> Self {
   98|      9|            let mut merged: BTreeSet<T> = self.values_vec().into_iter().collect();
   99|     90|            for value in other.values_vec() {
                                       ^9    ^9
  100|     90|                merged.insert(value);
  101|     90|            }
  102|      9|            Self::from_sorted_iter(merged.into_iter())
  103|      9|        }
  104|       |
  105|      9|        pub fn intersection(&self, other: &Self) -> Self {
  106|      9|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  107|      9|            let filtered: Vec<T> = self
  108|      9|                .tree
  109|      9|                .in_order()
  110|      9|                .iter()
  111|    100|                .filter_map(|v| {
                               ^9
  112|    100|                    if other_values.contains(v) {
  113|     47|                        Some(v.clone())
  114|       |                    } else {
  115|     53|                        None
  116|       |                    }
  117|    100|                })
  118|      9|                .collect();
  119|      9|            Self::from_sorted_iter(filtered.into_iter())
  120|      9|        }
  121|       |
  122|      7|        pub fn difference(&self, other: &Self) -> Self {
  123|      7|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  124|      7|            let filtered: Vec<T> = self
  125|      7|                .tree
  126|      7|                .in_order()
  127|      7|                .iter()
  128|     88|                .filter_map(|v| {
                               ^7
  129|     88|                    if !other_values.contains(v) {
  130|     45|                        Some(v.clone())
  131|       |                    } else {
  132|     43|                        None
  133|       |                    }
  134|     88|                })
  135|      7|                .collect();
  136|      7|            Self::from_sorted_iter(filtered.into_iter())
  137|      7|        }
  138|       |
  139|      5|        pub fn split(&self, pivot: &T) -> (Self, B, Self) {
  140|      5|            let mut left: Vec<T> = Vec::new();
  141|      5|            let mut right: Vec<T> = Vec::new();
  142|      5|            let mut found = false;
  143|     16|            for value in self.tree.in_order().iter() {
                                       ^5                   ^5
  144|     16|                if value < pivot {
  145|      7|                    left.push(value.clone());
  146|      9|                } else if value > pivot {
  147|      5|                    right.push(value.clone());
  148|      5|                } else {
  149|      4|                    found = true;
  150|      4|                }
  151|       |            }
  152|      5|            (
  153|      5|                Self::from_sorted_iter(left.into_iter()),
  154|      5|                found,
  155|      5|                Self::from_sorted_iter(right.into_iter()),
  156|      5|            )
  157|      5|        }
  158|       |
  159|      3|        pub fn join_pair(left: Self, right: Self) -> Self {
  160|      3|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  161|      5|            for value in right.values_vec() {
                                       ^3    ^3
  162|      5|                combined.insert(value);
  163|      5|            }
  164|      3|            Self::from_sorted_iter(combined.into_iter())
  165|      3|        }
  166|       |
  167|      4|        pub fn join_m(left: Self, pivot: T, right: Self) -> Self {
  168|      4|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  169|      4|            combined.insert(pivot);
  170|      6|            for value in right.values_vec() {
                                       ^4    ^4
  171|      6|                combined.insert(value);
  172|      6|            }
  173|      4|            Self::from_sorted_iter(combined.into_iter())
  174|      4|        }
  175|       |
  176|      6|        pub fn filter<F>(&self, mut predicate: F) -> Self
  177|      6|        where
  178|      6|            F: FnMut(&T) -> bool,
  179|       |        {
  180|      6|            let filtered: Vec<T> = self
  181|      6|                .tree
  182|      6|                .in_order()
  183|      6|                .iter()
  184|     19|                .filter_map(|v| if predicate(v) { Some(v.clone()) } else { None })
                               ^6                               ^10                      ^9
  185|      6|                .collect();
  186|      6|            Self::from_sorted_iter(filtered.into_iter())
  187|      6|        }
  188|       |
  189|      9|        pub fn reduce<F>(&self, mut op: F, base: T) -> T
  190|      9|        where
  191|      9|            F: FnMut(T, T) -> T,
  192|       |        {
  193|      9|            self.tree
  194|      9|                .in_order()
  195|      9|                .iter()
  196|     53|                .fold(base, |acc, value| op(acc, value.clone()))
                               ^9   ^9
  197|      9|        }
  198|       |
  199|      4|        pub fn iter_in_order(&self) -> ArraySeqStPerS<T> { self.tree.in_order() }
  200|       |
  201|      1|        pub fn as_tree(&self) -> &BSTTreapMtEph<T> { &self.tree }
  202|       |
  203|     54|        fn values_vec(&self) -> Vec<T> { self.tree.in_order().iter().cloned().collect() }
  204|       |
  205|      6|        fn rebuild_from_vec(values: Vec<T>) -> BSTTreapMtEph<T> {
  206|      6|            let tree = BSTTreapMtEph::new();
  207|     36|            for value in values {
                              ^30
  208|     30|                tree.insert(value);
  209|     30|            }
  210|      6|            tree
  211|      6|        }
  212|       |
  213|     48|        fn from_sorted_iter<I>(values: I) -> Self
  214|     48|        where
  215|     48|            I: IntoIterator<Item = T>,
  216|       |        {
  217|     48|            let tree = BSTTreapMtEph::new();
  218|    329|            for value in values {
                              ^281
  219|    281|                tree.insert(value);
  220|    281|            }
  221|     48|            Self { tree }
  222|     48|        }
  223|       |    }
  224|       |
  225|       |    impl<T: StTInMtT + Ord> BSTSetTreapMtEphTrait<T> for BSTSetTreapMtEph<T> {
  226|      3|        fn empty() -> Self { Self::empty() }
  227|       |
  228|      1|        fn singleton(value: T) -> Self { Self::singleton(value) }
  229|       |
  230|      0|        fn size(&self) -> N { self.tree.size() }
  231|       |
  232|      0|        fn is_empty(&self) -> B { self.tree.is_empty() }
  233|       |
  234|      1|        fn find(&self, value: &T) -> Option<T> { self.tree.find(value) }
  235|       |
  236|      1|        fn contains(&self, value: &T) -> B { self.tree.contains(value) }
  237|       |
  238|      1|        fn minimum(&self) -> Option<T> { self.tree.minimum() }
  239|       |
  240|      1|        fn maximum(&self) -> Option<T> { self.tree.maximum() }
  241|       |
  242|      1|        fn insert(&mut self, value: T) { self.tree.insert(value); }
  243|       |
  244|      1|        fn delete(&mut self, target: &T) { BSTSetTreapMtEph::delete(self, target) }
  245|       |
  246|      1|        fn union(&self, other: &Self) -> Self { BSTSetTreapMtEph::union(self, other) }
  247|       |
  248|      1|        fn intersection(&self, other: &Self) -> Self { BSTSetTreapMtEph::intersection(self, other) }
  249|       |
  250|      1|        fn difference(&self, other: &Self) -> Self { BSTSetTreapMtEph::difference(self, other) }
  251|       |
  252|      1|        fn split(&self, pivot: &T) -> (Self, B, Self) { BSTSetTreapMtEph::split(self, pivot) }
  253|       |
  254|      1|        fn join_pair(left: Self, right: Self) -> Self { BSTSetTreapMtEph::join_pair(left, right) }
  255|       |
  256|      1|        fn join_m(left: Self, pivot: T, right: Self) -> Self { BSTSetTreapMtEph::join_m(left, pivot, right) }
  257|       |
  258|      1|        fn filter<F: FnMut(&T) -> bool>(&self, predicate: F) -> Self { BSTSetTreapMtEph::filter(self, predicate) }
  259|       |
  260|      1|        fn reduce<F: FnMut(T, T) -> T>(&self, op: F, base: T) -> T { BSTSetTreapMtEph::reduce(self, op, base) }
  261|       |
  262|      1|        fn iter_in_order(&self) -> ArraySeqStPerS<T> { self.tree.in_order() }
  263|       |
  264|      1|        fn as_tree(&self) -> &BSTTreapMtEph<T> { &self.tree }
  265|       |    }
  266|       |
  267|       |    #[macro_export]
  268|       |    macro_rules! BSTSetTreapMtEphLit {
  269|       |        () => {
  270|       |            < $crate::Chap39::BSTSetTreapMtEph::BSTSetTreapMtEph::BSTSetTreapMtEph<_> as $crate::Chap39::BSTSetTreapMtEph::BSTSetTreapMtEph::BSTSetTreapMtEphTrait<_> >::empty()
  271|       |        };
  272|       |        ( $( $x:expr ),* $(,)? ) => {{
  273|       |            let mut __set = < $crate::Chap39::BSTSetTreapMtEph::BSTSetTreapMtEph::BSTSetTreapMtEph<_> as $crate::Chap39::BSTSetTreapMtEph::BSTSetTreapMtEph::BSTSetTreapMtEphTrait<_> >::empty();
  274|       |            $( __set.insert($x); )*
  275|       |            __set
  276|       |        }};
  277|       |    }
  278|       |
  279|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap39/BSTTreapMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Ephemeral Treap (randomized heap-ordered BST) with interior locking for multi-threaded access.
    3|       |
    4|       |pub mod BSTTreapMtEph {
    5|       |
    6|       |    use std::sync::{Arc, RwLock};
    7|       |
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |    use crate::Types::Types::*;
   10|       |    use rand::*;
   11|       |
   12|       |    type Link<T> = Option<Box<Node<T>>>;
   13|       |
   14|       |    #[derive(Debug, Clone)]
   15|       |    struct Node<T: StTInMtT + Ord> {
   16|       |        key: T,
   17|       |        priority: u64,
   18|       |        size: N,
   19|       |        left: Link<T>,
   20|       |        right: Link<T>,
   21|       |    }
   22|       |
   23|       |    impl<T: StTInMtT + Ord> Node<T> {
   24|  1.02k|        fn new(key: T, priority: u64) -> Self {
   25|  1.02k|            Node {
   26|  1.02k|                key,
   27|  1.02k|                priority,
   28|  1.02k|                size: 1,
   29|  1.02k|                left: None,
   30|  1.02k|                right: None,
   31|  1.02k|            }
   32|  1.02k|        }
   33|       |    }
   34|       |
   35|       |    #[derive(Debug, Clone)]
   36|       |    pub struct BSTTreapMtEph<T: StTInMtT + Ord> {
   37|       |        root: Arc<RwLock<Link<T>>>,
   38|       |    }
   39|       |
   40|       |    pub type BSTreeTreap<T> = BSTTreapMtEph<T>;
   41|       |
   42|       |    pub trait BSTTreapMtEphTrait<T: StTInMtT + Ord>: Sized {
   43|       |        /// claude-4-sonet: Work (1), Span (1)
   44|       |        fn new() -> Self;
   45|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected with locking
   46|       |        fn insert(&self, value: T);
   47|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected with locking
   48|       |        fn find(&self, target: &T) -> Option<T>;
   49|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected with locking
   50|       |        fn contains(&self, target: &T) -> B;
   51|       |        /// claude-4-sonet: Work (1), Span (1)
   52|       |        fn size(&self) -> N;
   53|       |        /// claude-4-sonet: Work (1), Span (1)
   54|       |        fn is_empty(&self) -> B;
   55|       |        /// claude-4-sonet: Work (n), Span (n)
   56|       |        fn height(&self) -> N;
   57|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected with locking
   58|       |        fn minimum(&self) -> Option<T>;
   59|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected with locking
   60|       |        fn maximum(&self) -> Option<T>;
   61|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   62|       |        fn pre_order(&self) -> ArraySeqStPerS<T>;
   63|       |    }
   64|       |
   65|       |    impl<T: StTInMtT + Ord> Default for BSTTreapMtEph<T> {
   66|      0|        fn default() -> Self { Self::new() }
   67|       |    }
   68|       |
   69|       |    impl<T: StTInMtT + Ord> BSTTreapMtEph<T> {
   70|       |        // Private helper methods only - no public delegation
   71|       |
   72|  9.27k|        fn size_link(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }
   73|       |
   74|  4.53k|        fn update(node: &mut Node<T>) { node.size = 1 + Self::size_link(&node.left) + Self::size_link(&node.right); }
   75|       |
   76|    705|        fn rotate_left(link: &mut Link<T>) {
   77|    705|            if let Some(mut x) = link.take() {
   78|    705|                if let Some(mut y) = x.right.take() {
   79|    705|                    x.right = y.left.take();
   80|    705|                    Self::update(&mut x);
   81|    705|                    Self::update(&mut y);
   82|    705|                    y.left = Some(x);
   83|    705|                    *link = Some(y);
   84|    705|                } else {
   85|      0|                    *link = Some(x);
   86|      0|                }
   87|      0|            }
   88|    705|        }
   89|       |
   90|     90|        fn rotate_right(link: &mut Link<T>) {
   91|     90|            if let Some(mut x) = link.take() {
   92|     90|                if let Some(mut y) = x.left.take() {
   93|     90|                    x.left = y.right.take();
   94|     90|                    Self::update(&mut x);
   95|     90|                    Self::update(&mut y);
   96|     90|                    y.right = Some(x);
   97|     90|                    *link = Some(y);
   98|     90|                } else {
   99|      0|                    *link = Some(x);
  100|      0|                }
  101|      0|            }
  102|     90|        }
  103|       |
  104|  3.97k|        fn insert_link(link: &mut Link<T>, value: T, rng: &mut impl Rng) {
  105|  3.97k|            if let Some(node) = link.as_mut() {
                                      ^2.94k
  106|  2.94k|                if value < node.key {
  107|    343|                    Self::insert_link(&mut node.left, value, rng);
  108|    343|                    if node.left.as_ref().map_or(false, |left| left.priority < node.priority) {
  109|     90|                        Self::rotate_right(link);
  110|    253|                    }
  111|  2.60k|                } else if value > node.key {
  112|  2.59k|                    Self::insert_link(&mut node.right, value, rng);
  113|  2.59k|                    if node
  114|  2.59k|                        .right
  115|  2.59k|                        .as_ref()
  116|  2.59k|                        .map_or(false, |right| right.priority < node.priority)
  117|    705|                    {
  118|    705|                        Self::rotate_left(link);
  119|  1.89k|                    }
  120|      7|                }
  121|  2.94k|                if let Some(node) = link.as_mut() {
  122|  2.94k|                    Self::update(node);
  123|  2.94k|                }
                              ^0
  124|  1.02k|            } else {
  125|  1.02k|                *link = Some(Box::new(Node::new(value, rng.random())));
  126|  1.02k|            }
  127|  3.97k|        }
  128|       |
  129|    453|        fn find_link<'a>(link: &'a Link<T>, target: &T) -> Option<&'a T> {
  130|    453|            match link {
  131|     25|                | None => None,
  132|    428|                | Some(node) => {
  133|    428|                    if target == &node.key {
  134|    129|                        Some(&node.key)
  135|    299|                    } else if target < &node.key {
  136|    179|                        Self::find_link(&node.left, target)
  137|       |                    } else {
  138|    120|                        Self::find_link(&node.right, target)
  139|       |                    }
  140|       |                }
  141|       |            }
  142|    453|        }
  143|       |
  144|     62|        fn min_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  145|     62|            match link {
  146|      3|                | None => None,
  147|     59|                | Some(node) => match node.left {
  148|     22|                    | None => Some(&node.key),
  149|     37|                    | Some(_) => Self::min_link(&node.left),
  150|       |                },
  151|       |            }
  152|     62|        }
  153|       |
  154|     69|        fn max_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  155|     69|            match link {
  156|      3|                | None => None,
  157|     66|                | Some(node) => match node.right {
  158|     22|                    | None => Some(&node.key),
  159|     44|                    | Some(_) => Self::max_link(&node.right),
  160|       |                },
  161|       |            }
  162|     69|        }
  163|       |
  164|  1.56k|        fn in_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  165|  1.56k|            if let Some(node) = link {
                                      ^734
  166|    734|                Self::in_order_collect(&node.left, out);
  167|    734|                out.push(node.key.clone());
  168|    734|                Self::in_order_collect(&node.right, out);
  169|    834|            }
  170|  1.56k|        }
  171|       |
  172|      0|        fn pre_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  173|      0|            if let Some(node) = link {
  174|      0|                out.push(node.key.clone());
  175|      0|                Self::pre_order_collect(&node.left, out);
  176|      0|                Self::pre_order_collect(&node.right, out);
  177|      0|            }
  178|      0|        }
  179|       |    }
  180|       |
  181|       |    impl<T: StTInMtT + Ord> BSTTreapMtEphTrait<T> for BSTTreapMtEph<T> {
  182|    144|        fn new() -> Self {
  183|    144|            BSTTreapMtEph {
  184|    144|                root: Arc::new(RwLock::new(None)),
  185|    144|            }
  186|    144|        }
  187|       |
  188|  1.03k|        fn insert(&self, value: T) {
  189|  1.03k|            let mut guard = self.root.write().unwrap();
  190|  1.03k|            let mut rng = rng();
  191|  1.03k|            Self::insert_link(&mut *guard, value, &mut rng);
  192|  1.03k|        }
  193|       |
  194|    154|        fn find(&self, target: &T) -> Option<T> {
  195|    154|            let guard = self.root.read().unwrap();
  196|    154|            Self::find_link(&*guard, target).cloned()
  197|    154|        }
  198|       |
  199|    110|        fn contains(&self, target: &T) -> B { self.find(target).is_some() }
  200|       |
  201|    103|        fn size(&self) -> N {
  202|    103|            let guard = self.root.read().unwrap();
  203|    103|            Self::size_link(&*guard)
  204|    103|        }
  205|       |
  206|      9|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
                                                                      ^5            ^4
  207|       |
  208|     12|        fn height(&self) -> N {
  209|    728|            fn height_rec<T: StTInMtT + Ord>(link: &Link<T>) -> N {
  210|    728|                match link {
  211|    370|                    | None => 0,
  212|    358|                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),
  213|       |                }
  214|    728|            }
  215|       |
  216|     12|            let guard = self.root.read().unwrap();
  217|     12|            height_rec(&*guard)
  218|     12|        }
  219|       |
  220|     25|        fn minimum(&self) -> Option<T> {
  221|     25|            let guard = self.root.read().unwrap();
  222|     25|            Self::min_link(&*guard).cloned()
  223|     25|        }
  224|       |
  225|     25|        fn maximum(&self) -> Option<T> {
  226|     25|            let guard = self.root.read().unwrap();
  227|     25|            Self::max_link(&*guard).cloned()
  228|     25|        }
  229|       |
  230|    100|        fn in_order(&self) -> ArraySeqStPerS<T> {
  231|    100|            let guard = self.root.read().unwrap();
  232|    100|            let mut out = Vec::with_capacity(Self::size_link(&*guard));
  233|    100|            Self::in_order_collect(&*guard, &mut out);
  234|    100|            ArraySeqStPerS::from_vec(out)
  235|    100|        }
  236|       |
  237|      0|        fn pre_order(&self) -> ArraySeqStPerS<T> {
  238|      0|            let guard = self.root.read().unwrap();
  239|      0|            let mut out = Vec::with_capacity(Self::size_link(&*guard));
  240|      0|            Self::pre_order_collect(&*guard, &mut out);
  241|      0|            ArraySeqStPerS::from_vec(out)
  242|      0|        }
  243|       |    }
  244|       |
  245|       |    #[macro_export]
  246|       |    macro_rules! BSTTreapMtEphLit {
  247|       |        () => {
  248|       |            < $crate::Chap39::BSTTreapMtEph::BSTTreapMtEph::BSTTreapMtEph<_> as $crate::Chap39::BSTTreapMtEph::BSTTreapMtEph::BSTTreapMtEphTrait<_> >::new()
  249|       |        };
  250|       |        ( $( $x:expr ),* $(,)? ) => {{
  251|       |            let __tree = < $crate::Chap39::BSTTreapMtEph::BSTTreapMtEph::BSTTreapMtEph<_> as $crate::Chap39::BSTTreapMtEph::BSTTreapMtEph::BSTTreapMtEphTrait<_> >::new();
  252|       |            $( __tree.insert($x); )*
  253|       |            __tree
  254|       |        }};
  255|       |    }
  256|       |
  257|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap39/BSTTreapStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Ephemeral Treap (randomized heap-ordered BST) with `find` support.
    3|       |
    4|       |pub mod BSTTreapStEph {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Types::Types::*;
    8|       |    use rand::*;
    9|       |
   10|       |    type Link<T> = Option<Box<Node<T>>>;
   11|       |
   12|       |    #[derive(Clone, Debug)]
   13|       |    struct Node<T: StT + Ord> {
   14|       |        key: T,
   15|       |        priority: u64,
   16|       |        size: N,
   17|       |        left: Link<T>,
   18|       |        right: Link<T>,
   19|       |    }
   20|       |
   21|       |    impl<T: StT + Ord> Node<T> {
   22|    326|        fn new(key: T, priority: u64) -> Self {
   23|    326|            Node {
   24|    326|                key,
   25|    326|                priority,
   26|    326|                size: 1,
   27|    326|                left: None,
   28|    326|                right: None,
   29|    326|            }
   30|    326|        }
   31|       |    }
   32|       |
   33|       |    #[derive(Debug, Clone)]
   34|       |    pub struct BSTTreapStEph<T: StT + Ord> {
   35|       |        root: Link<T>,
   36|       |    }
   37|       |
   38|       |    pub type BSTreeTreap<T> = BSTTreapStEph<T>;
   39|       |
   40|       |    pub trait BSTTreapStEphTrait<T: StT + Ord> {
   41|       |        /// claude-4-sonet: Work (1), Span (1)
   42|       |        fn new() -> Self;
   43|       |        /// claude-4-sonet: Work (1), Span (1)
   44|       |        fn size(&self) -> N;
   45|       |        /// claude-4-sonet: Work (1), Span (1)
   46|       |        fn is_empty(&self) -> B;
   47|       |        /// claude-4-sonet: Work (n), Span (n)
   48|       |        fn height(&self) -> N;
   49|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected, Parallelism (1)
   50|       |        fn insert(&mut self, value: T);
   51|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected, Parallelism (1)
   52|       |        fn find(&self, target: &T) -> Option<&T>;
   53|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected, Parallelism (1)
   54|       |        fn contains(&self, target: &T) -> B;
   55|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected, Parallelism (1)
   56|       |        fn minimum(&self) -> Option<&T>;
   57|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected, Parallelism (1)
   58|       |        fn maximum(&self) -> Option<&T>;
   59|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   60|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   61|       |        fn pre_order(&self) -> ArraySeqStPerS<T>;
   62|       |    }
   63|       |
   64|       |    impl<T: StT + Ord> Default for BSTreeTreap<T> {
   65|     28|        fn default() -> Self { Self::new() }
   66|       |    }
   67|       |
   68|       |    impl<T: StT + Ord> BSTTreapStEph<T> {
   69|       |        // Private helper methods only - no public delegation
   70|       |
   71|  3.13k|        fn size_link(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }
   72|       |
   73|  1.55k|        fn update(node: &mut Node<T>) { node.size = 1 + Self::size_link(&node.left) + Self::size_link(&node.right); }
   74|       |
   75|    243|        fn rotate_left(link: &mut Link<T>) {
   76|    243|            if let Some(mut x) = link.take() {
   77|    243|                if let Some(mut y) = x.right.take() {
   78|    243|                    x.right = y.left.take();
   79|    243|                    Self::update(&mut x);
   80|    243|                    Self::update(&mut y);
   81|    243|                    y.left = Some(x);
   82|    243|                    *link = Some(y);
   83|    243|                } else {
   84|      0|                    *link = Some(x);
   85|      0|                }
   86|      0|            }
   87|    243|        }
   88|       |
   89|     14|        fn rotate_right(link: &mut Link<T>) {
   90|     14|            if let Some(mut x) = link.take() {
   91|     14|                if let Some(mut y) = x.left.take() {
   92|     14|                    x.left = y.right.take();
   93|     14|                    Self::update(&mut x);
   94|     14|                    Self::update(&mut y);
   95|     14|                    y.right = Some(x);
   96|     14|                    *link = Some(y);
   97|     14|                } else {
   98|      0|                    *link = Some(x);
   99|      0|                }
  100|      0|            }
  101|     14|        }
  102|       |
  103|  1.36k|        fn insert_link(link: &mut Link<T>, value: T, rng: &mut impl Rng) {
  104|  1.36k|            if let Some(node) = link.as_mut() {
                                      ^1.04k
  105|  1.04k|                if value < node.key {
  106|     53|                    Self::insert_link(&mut node.left, value, rng);
  107|     53|                    if node.left.as_ref().map_or(false, |left| left.priority < node.priority) {
  108|     14|                        Self::rotate_right(link);
  109|     39|                    }
  110|    987|                } else if value > node.key {
  111|    985|                    Self::insert_link(&mut node.right, value, rng);
  112|    985|                    if node
  113|    985|                        .right
  114|    985|                        .as_ref()
  115|    985|                        .map_or(false, |right| right.priority < node.priority)
  116|    243|                    {
  117|    243|                        Self::rotate_left(link);
  118|    742|                    }
  119|      2|                }
  120|  1.04k|                if let Some(node) = link.as_mut() {
  121|  1.04k|                    Self::update(node);
  122|  1.04k|                }
                              ^0
  123|    326|            } else {
  124|    326|                *link = Some(Box::new(Node::new(value, rng.random())));
  125|    326|            }
  126|  1.36k|        }
  127|       |
  128|    572|        fn find_link<'a>(link: &'a Link<T>, target: &T) -> Option<&'a T> {
  129|    572|            match link {
  130|     10|                | None => None,
  131|    562|                | Some(node) => {
  132|    562|                    if target == &node.key {
  133|    109|                        Some(&node.key)
  134|    453|                    } else if target < &node.key {
  135|    217|                        Self::find_link(&node.left, target)
  136|       |                    } else {
  137|    236|                        Self::find_link(&node.right, target)
  138|       |                    }
  139|       |                }
  140|       |            }
  141|    572|        }
  142|       |
  143|     32|        fn min_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  144|     32|            match link {
  145|      2|                | None => None,
  146|     30|                | Some(node) => match node.left {
  147|     10|                    | None => Some(&node.key),
  148|     20|                    | Some(_) => Self::min_link(&node.left),
  149|       |                },
  150|       |            }
  151|     32|        }
  152|       |
  153|     24|        fn max_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  154|     24|            match link {
  155|      2|                | None => None,
  156|     22|                | Some(node) => match node.right {
  157|     10|                    | None => Some(&node.key),
  158|     12|                    | Some(_) => Self::max_link(&node.right),
  159|       |                },
  160|       |            }
  161|     24|        }
  162|       |
  163|     27|        fn in_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  164|     27|            if let Some(node) = link {
                                      ^11
  165|     11|                Self::in_order_collect(&node.left, out);
  166|     11|                out.push(node.key.clone());
  167|     11|                Self::in_order_collect(&node.right, out);
  168|     16|            }
  169|     27|        }
  170|       |
  171|     18|        fn pre_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  172|     18|            if let Some(node) = link {
                                      ^7
  173|      7|                out.push(node.key.clone());
  174|      7|                Self::pre_order_collect(&node.left, out);
  175|      7|                Self::pre_order_collect(&node.right, out);
  176|     11|            }
  177|     18|        }
  178|       |    }
  179|       |
  180|       |    impl<T: StT + Ord> BSTTreapStEphTrait<T> for BSTTreapStEph<T> {
  181|     30|        fn new() -> Self { BSTTreapStEph { root: None } }
  182|       |
  183|     29|        fn size(&self) -> N { Self::size_link(&self.root) }
  184|       |
  185|      4|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
                                                                      ^3            ^1
  186|       |
  187|      6|        fn height(&self) -> N {
  188|    144|            fn height_rec<T: StT + Ord>(link: &Link<T>) -> N {
  189|    144|                match link {
  190|     75|                    | None => 0,
  191|     69|                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),
  192|       |                }
  193|    144|            }
  194|      6|            height_rec(&self.root)
  195|      6|        }
  196|       |
  197|    328|        fn insert(&mut self, value: T) {
  198|    328|            let mut r = rng();
  199|    328|            Self::insert_link(&mut self.root, value, &mut r);
  200|    328|        }
  201|       |
  202|    119|        fn find(&self, target: &T) -> Option<&T> { Self::find_link(&self.root, target) }
  203|       |
  204|    111|        fn contains(&self, target: &T) -> B { self.find(target).is_some() }
  205|       |
  206|     12|        fn minimum(&self) -> Option<&T> { Self::min_link(&self.root) }
  207|       |
  208|     12|        fn maximum(&self) -> Option<&T> { Self::max_link(&self.root) }
  209|       |
  210|      5|        fn in_order(&self) -> ArraySeqStPerS<T> {
  211|      5|            let mut out = Vec::with_capacity(self.size());
  212|      5|            Self::in_order_collect(&self.root, &mut out);
  213|      5|            ArraySeqStPerS::from_vec(out)
  214|      5|        }
  215|       |
  216|      4|        fn pre_order(&self) -> ArraySeqStPerS<T> {
  217|      4|            let mut out = Vec::with_capacity(self.size());
  218|      4|            Self::pre_order_collect(&self.root, &mut out);
  219|      4|            ArraySeqStPerS::from_vec(out)
  220|      4|        }
  221|       |    }
  222|       |
  223|       |    #[macro_export]
  224|       |    macro_rules! BSTTreapStEphLit {
  225|       |        () => {
  226|       |            < $crate::Chap39::BSTTreapStEph::BSTTreapStEph::BSTTreapStEph<_> as $crate::Chap39::BSTTreapStEph::BSTTreapStEph::BSTTreapStEphTrait<_> >::new()
  227|       |        };
  228|       |        ( $( $x:expr ),* $(,)? ) => {{
  229|       |            let mut __tree = < $crate::Chap39::BSTTreapStEph::BSTTreapStEph::BSTTreapStEph<_> as $crate::Chap39::BSTTreapStEph::BSTTreapStEph::BSTTreapStEphTrait<_> >::new();
  230|       |            $( __tree.insert($x); )*
  231|       |            __tree
  232|       |        }};
  233|       |    }
  234|       |
  235|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap40/BSTKeyValueStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Key-Value BST (dictionary/table) with ephemeral treap structure.
    3|       |
    4|       |pub mod BSTKeyValueStEph {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Types::Types::*;
    8|       |    use rand::*;
    9|       |
   10|       |    type Link<K, V> = Option<Box<Node<K, V>>>;
   11|       |
   12|       |    #[derive(Clone, Debug)]
   13|       |    struct Node<K: StT + Ord, V: StT> {
   14|       |        key: K,
   15|       |        value: V,
   16|       |        priority: u64,
   17|       |        left: Link<K, V>,
   18|       |        right: Link<K, V>,
   19|       |    }
   20|       |
   21|       |    impl<K: StT + Ord, V: StT> Node<K, V> {
   22|    117|        fn new(key: K, value: V, priority: u64) -> Self {
   23|    117|            Node {
   24|    117|                key,
   25|    117|                value,
   26|    117|                priority,
   27|    117|                left: None,
   28|    117|                right: None,
   29|    117|            }
   30|    117|        }
   31|       |    }
   32|       |
   33|       |    #[derive(Debug, Clone)]
   34|       |    pub struct BSTKeyValueStEph<K: StT + Ord, V: StT> {
   35|       |        root: Link<K, V>,
   36|       |        size: N,
   37|       |    }
   38|       |
   39|       |    pub type BSTreeKeyValue<K, V> = BSTKeyValueStEph<K, V>;
   40|       |
   41|       |    pub trait BSTKeyValueStEphTrait<K: StT + Ord, V: StT> {
   42|       |        /// claude-4-sonet: Work (1), Span (1)
   43|       |        fn new() -> Self;
   44|       |        /// claude-4-sonet: Work (1), Span (1)
   45|       |        fn size(&self) -> N;
   46|       |        /// claude-4-sonet: Work (1), Span (1)
   47|       |        fn is_empty(&self) -> B;
   48|       |        /// claude-4-sonet: Work (n), Span (n)
   49|       |        fn height(&self) -> N;
   50|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected, Parallelism (1)
   51|       |        fn insert(&mut self, key: K, value: V);
   52|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected, Parallelism (1)
   53|       |        fn find(&self, key: &K) -> Option<&V>;
   54|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected, Parallelism (1)
   55|       |        fn contains(&self, key: &K) -> B;
   56|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected, Parallelism (1)
   57|       |        fn get(&self, key: &K) -> Option<&V>;
   58|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   59|       |        fn keys(&self) -> ArraySeqStPerS<K>;
   60|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   61|       |        fn values(&self) -> ArraySeqStPerS<V>;
   62|       |        fn minimum_key(&self) -> Option<&K>;
   63|       |        fn maximum_key(&self) -> Option<&K>;
   64|       |    }
   65|       |
   66|       |    impl<K: StT + Ord, V: StT> Default for BSTreeKeyValue<K, V> {
   67|      0|        fn default() -> Self { Self::new() }
   68|       |    }
   69|       |
   70|       |    impl<K: StT + Ord, V: StT> BSTKeyValueStEph<K, V> {
   71|       |        // Private helper methods only - no public delegation
   72|       |
   73|    104|        fn rotate_left(link: &mut Link<K, V>) {
   74|    104|            if let Some(mut x) = link.take() {
   75|    104|                if let Some(mut y) = x.right.take() {
   76|    104|                    x.right = y.left.take();
   77|    104|                    y.left = Some(x);
   78|    104|                    *link = Some(y);
   79|    104|                } else {
   80|      0|                    *link = Some(x);
   81|      0|                }
   82|      0|            }
   83|    104|        }
   84|       |
   85|      4|        fn rotate_right(link: &mut Link<K, V>) {
   86|      4|            if let Some(mut x) = link.take() {
   87|      4|                if let Some(mut y) = x.left.take() {
   88|      4|                    x.left = y.right.take();
   89|      4|                    y.right = Some(x);
   90|      4|                    *link = Some(y);
   91|      4|                } else {
   92|      0|                    *link = Some(x);
   93|      0|                }
   94|      0|            }
   95|      4|        }
   96|       |
   97|    536|        fn insert_link(link: &mut Link<K, V>, key: K, value: V, rng: &mut impl Rng) -> bool {
   98|    536|            if let Some(node) = link.as_mut() {
                                      ^419
   99|    419|                if key < node.key {
  100|      9|                    let inserted = Self::insert_link(&mut node.left, key, value, rng);
  101|      9|                    if node.left.as_ref().map_or(false, |left| left.priority < node.priority) {
  102|      4|                        Self::rotate_right(link);
  103|      5|                    }
  104|      9|                    inserted
  105|    410|                } else if key > node.key {
  106|    409|                    let inserted = Self::insert_link(&mut node.right, key, value, rng);
  107|    409|                    if node
  108|    409|                        .right
  109|    409|                        .as_ref()
  110|    409|                        .map_or(false, |right| right.priority < node.priority)
  111|    104|                    {
  112|    104|                        Self::rotate_left(link);
  113|    305|                    }
  114|    409|                    inserted
  115|       |                } else {
  116|       |                    // Key exists, update value
  117|      1|                    node.value = value;
  118|      1|                    false // No new insertion
  119|       |                }
  120|       |            } else {
  121|    117|                *link = Some(Box::new(Node::new(key, value, rng.random())));
  122|    117|                true // New insertion
  123|       |            }
  124|    536|        }
  125|       |
  126|    690|        fn find_link<'a>(link: &'a Link<K, V>, key: &K) -> Option<&'a V> {
  127|    690|            match link {
  128|      2|                | None => None,
  129|    688|                | Some(node) => {
  130|    688|                    if key == &node.key {
  131|    110|                        Some(&node.value)
  132|    578|                    } else if key < &node.key {
  133|    268|                        Self::find_link(&node.left, key)
  134|       |                    } else {
  135|    310|                        Self::find_link(&node.right, key)
  136|       |                    }
  137|       |                }
  138|       |            }
  139|    690|        }
  140|       |
  141|      2|        fn min_key_link<'a>(link: &'a Link<K, V>) -> Option<&'a K> {
  142|      2|            match link {
  143|      0|                | None => None,
  144|      2|                | Some(node) => match node.left {
  145|      1|                    | None => Some(&node.key),
  146|      1|                    | Some(_) => Self::min_key_link(&node.left),
  147|       |                },
  148|       |            }
  149|      2|        }
  150|       |
  151|      2|        fn max_key_link<'a>(link: &'a Link<K, V>) -> Option<&'a K> {
  152|      2|            match link {
  153|      0|                | None => None,
  154|      2|                | Some(node) => match node.right {
  155|      1|                    | None => Some(&node.key),
  156|      1|                    | Some(_) => Self::max_key_link(&node.right),
  157|       |                },
  158|       |            }
  159|      2|        }
  160|       |
  161|     18|        fn collect_keys(link: &Link<K, V>, out: &mut Vec<K>) {
  162|     18|            if let Some(node) = link {
                                      ^8
  163|      8|                Self::collect_keys(&node.left, out);
  164|      8|                out.push(node.key.clone());
  165|      8|                Self::collect_keys(&node.right, out);
  166|     10|            }
  167|     18|        }
  168|       |
  169|     11|        fn collect_values(link: &Link<K, V>, out: &mut Vec<V>) {
  170|     11|            if let Some(node) = link {
                                      ^5
  171|      5|                Self::collect_values(&node.left, out);
  172|      5|                out.push(node.value.clone());
  173|      5|                Self::collect_values(&node.right, out);
  174|      6|            }
  175|     11|        }
  176|       |    }
  177|       |
  178|       |    impl<K: StT + Ord, V: StT> BSTKeyValueStEphTrait<K, V> for BSTKeyValueStEph<K, V> {
  179|      7|        fn new() -> Self { BSTKeyValueStEph { root: None, size: 0 } }
  180|       |
  181|      6|        fn size(&self) -> N { self.size }
  182|       |
  183|      3|        fn is_empty(&self) -> B { self.size == 0 }
  184|       |
  185|      1|        fn height(&self) -> N {
  186|    201|            fn height_rec<K: StT + Ord, V: StT>(link: &Link<K, V>) -> N {
  187|    201|                match link {
  188|    101|                    | None => 0,
  189|    100|                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),
  190|       |                }
  191|    201|            }
  192|      1|            height_rec(&self.root)
  193|      1|        }
  194|       |
  195|    118|        fn insert(&mut self, key: K, value: V) {
  196|    118|            let mut r = rng();
  197|    118|            let inserted = Self::insert_link(&mut self.root, key, value, &mut r);
  198|    118|            if inserted {
  199|    117|                self.size += 1;
  200|    117|            }
                          ^1
  201|    118|        }
  202|       |
  203|    112|        fn find(&self, key: &K) -> Option<&V> { Self::find_link(&self.root, key) }
  204|       |
  205|      2|        fn contains(&self, key: &K) -> B { self.find(key).is_some() }
  206|       |
  207|      1|        fn get(&self, key: &K) -> Option<&V> { self.find(key) }
  208|       |
  209|      2|        fn keys(&self) -> ArraySeqStPerS<K> {
  210|      2|            let mut out = Vec::with_capacity(self.size);
  211|      2|            Self::collect_keys(&self.root, &mut out);
  212|      2|            ArraySeqStPerS::from_vec(out)
  213|      2|        }
  214|       |
  215|      1|        fn values(&self) -> ArraySeqStPerS<V> {
  216|      1|            let mut out = Vec::with_capacity(self.size);
  217|      1|            Self::collect_values(&self.root, &mut out);
  218|      1|            ArraySeqStPerS::from_vec(out)
  219|      1|        }
  220|       |
  221|      1|        fn minimum_key(&self) -> Option<&K> { Self::min_key_link(&self.root) }
  222|       |
  223|      1|        fn maximum_key(&self) -> Option<&K> { Self::max_key_link(&self.root) }
  224|       |    }
  225|       |
  226|       |    #[macro_export]
  227|       |    macro_rules! BSTKeyValueStEphLit {
  228|       |        () => {
  229|       |            < $crate::Chap40::BSTKeyValueStEph::BSTKeyValueStEph::BSTKeyValueStEph<_, _> as $crate::Chap40::BSTKeyValueStEph::BSTKeyValueStEph::BSTKeyValueStEphTrait<_, _> >::new()
  230|       |        };
  231|       |        ( $( ($k:expr, $v:expr) ),* $(,)? ) => {{
  232|       |            let mut __tree = < $crate::Chap40::BSTKeyValueStEph::BSTKeyValueStEph::BSTKeyValueStEph<_, _> as $crate::Chap40::BSTKeyValueStEph::BSTKeyValueStEph::BSTKeyValueStEphTrait<_, _> >::new();
  233|       |            $( __tree.insert($k, $v); )*
  234|       |            __tree
  235|       |        }};
  236|       |    }
  237|       |
  238|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap40/BSTReducedStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! BST with general reduced values augmentation using associative functions.
    3|       |
    4|       |pub mod BSTReducedStEph {
    5|       |
    6|       |    use std::marker::PhantomData;
    7|       |
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |    use crate::Types::Types::*;
   10|       |    use rand::*;
   11|       |
   12|       |    type Link<K, V, R> = Option<Box<Node<K, V, R>>>;
   13|       |
   14|       |    #[derive(Clone, Debug)]
   15|       |    struct Node<K: StT + Ord, V: StT, R: StT> {
   16|       |        key: K,
   17|       |        value: V,
   18|       |        priority: u64,
   19|       |        size: N,
   20|       |        reduced_value: R, // Reduced value of subtree rooted at this node
   21|       |        left: Link<K, V, R>,
   22|       |        right: Link<K, V, R>,
   23|       |    }
   24|       |
   25|       |    impl<K: StT + Ord, V: StT, R: StT> Node<K, V, R> {
   26|    199|        fn new(key: K, value: V, priority: u64, reduced_value: R) -> Self {
   27|    199|            Node {
   28|    199|                key,
   29|    199|                value,
   30|    199|                priority,
   31|    199|                size: 1,
   32|    199|                reduced_value,
   33|    199|                left: None,
   34|    199|                right: None,
   35|    199|            }
   36|    199|        }
   37|       |    }
   38|       |
   39|       |    /// Trait for associative reduction operations
   40|       |    pub trait ReduceOp<V: StT, R: StT> {
   41|       |        /// Identity element for the reduction operation
   42|       |        fn identity() -> R;
   43|       |        /// Associative binary operation: f(a, b)
   44|       |        fn combine(a: R, b: R) -> R;
   45|       |        /// Convert value to reduced form
   46|       |        fn lift(value: &V) -> R;
   47|       |    }
   48|       |
   49|       |    /// Example: Sum reduction for numeric values
   50|       |    #[derive(Debug, Clone)]
   51|       |    pub struct SumOp<T>(PhantomData<T>);
   52|       |
   53|       |    impl<T: ArithmeticT> ReduceOp<T, T> for SumOp<T> {
   54|    864|        fn identity() -> T { T::default() }
   55|  2.07k|        fn combine(a: T, b: T) -> T { a + b }
   56|  1.19k|        fn lift(value: &T) -> T { *value }
   57|       |    }
   58|       |
   59|       |    /// Example: Max reduction for ordered values
   60|       |    #[derive(Debug, Clone)]
   61|       |    pub struct MaxOp<T>(PhantomData<T>);
   62|       |
   63|       |    /// Example: Count reduction (counts number of elements)
   64|       |    #[derive(Debug, Clone)]
   65|       |    pub struct CountOp<T>(PhantomData<T>);
   66|       |
   67|       |    impl<T: StT> ReduceOp<T, N> for CountOp<T> {
   68|     42|        fn identity() -> N { 0 }
   69|     56|        fn combine(a: N, b: N) -> N { a + b }
   70|     31|        fn lift(_value: &T) -> N { 1 }
   71|       |    }
   72|       |
   73|       |    #[derive(Debug, Clone)]
   74|       |    pub struct BSTReducedStEph<K: StT + Ord, V: StT, R: StT, Op: ReduceOp<V, R>> {
   75|       |        root: Link<K, V, R>,
   76|       |        _op: PhantomData<Op>,
   77|       |    }
   78|       |
   79|       |    pub type BSTreeReduced<K, V, R, Op> = BSTReducedStEph<K, V, R, Op>;
   80|       |
   81|       |    pub trait BSTReducedStEphTrait<K: StT + Ord, V: StT, R: StT, Op: ReduceOp<V, R>> {
   82|       |        /// claude-4-sonet: Work (1), Span (1)
   83|       |        fn new() -> Self;
   84|       |        /// claude-4-sonet: Work (1), Span (1)
   85|       |        fn size(&self) -> N;
   86|       |        /// claude-4-sonet: Work (1), Span (1)
   87|       |        fn is_empty(&self) -> B;
   88|       |        /// claude-4-sonet: Work (n), Span (n)
   89|       |        fn height(&self) -> N;
   90|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected, Parallelism (1)
   91|       |        fn insert(&mut self, key: K, value: V);
   92|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected, Parallelism (1)
   93|       |        fn find(&self, key: &K) -> Option<&V>;
   94|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected, Parallelism (1)
   95|       |        fn contains(&self, key: &K) -> B;
   96|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected, Parallelism (1)
   97|       |        fn get(&self, key: &K) -> Option<&V>;
   98|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   99|       |        fn keys(&self) -> ArraySeqStPerS<K>;
  100|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
  101|       |        fn values(&self) -> ArraySeqStPerS<V>;
  102|       |        fn minimum_key(&self) -> Option<&K>;
  103|       |        fn maximum_key(&self) -> Option<&K>;
  104|       |        fn reduced_value(&self) -> R;
  105|       |        fn range_reduce(&self, low: &K, high: &K) -> R;
  106|       |    }
  107|       |
  108|       |    impl<K: StT + Ord, V: StT, R: StT, Op: ReduceOp<V, R>> Default for BSTreeReduced<K, V, R, Op> {
  109|      0|        fn default() -> Self { Self::new() }
  110|       |    }
  111|       |
  112|       |    impl<K: StT + Ord, V: StT, R: StT, Op: ReduceOp<V, R>> BSTReducedStEph<K, V, R, Op> {
  113|       |        // Private helper methods only - no public delegation
  114|       |
  115|  1.94k|        fn size_link(link: &Link<K, V, R>) -> N { link.as_ref().map_or(0, |n| n.size) }
  116|       |
  117|  1.93k|        fn reduced_value_link(link: &Link<K, V, R>) -> R {
  118|  1.93k|            link.as_ref()
  119|  1.93k|                .map_or_else(|| Op::identity(), |n| n.reduced_value.clone())
                                              ^735                ^1.20k          ^1.20k
  120|  1.93k|        }
  121|       |
  122|    960|        fn update_node(node: &mut Node<K, V, R>) {
  123|    960|            node.size = 1 + Self::size_link(&node.left) + Self::size_link(&node.right);
  124|       |
  125|       |            // Compute reduced value: f(left_reduced, f(node_value, right_reduced))
  126|    960|            let left_reduced = Self::reduced_value_link(&node.left);
  127|    960|            let right_reduced = Self::reduced_value_link(&node.right);
  128|    960|            let node_reduced = Op::lift(&node.value);
  129|       |
  130|    960|            node.reduced_value = Op::combine(left_reduced, Op::combine(node_reduced, right_reduced));
  131|    960|        }
  132|       |
  133|      0|        fn make_node(key: K, value: V, priority: u64, left: Link<K, V, R>, right: Link<K, V, R>) -> Link<K, V, R> {
  134|      0|            let node_reduced = Op::lift(&value);
  135|      0|            let mut node = Node::new(key, value, priority, node_reduced);
  136|      0|            node.left = left;
  137|      0|            node.right = right;
  138|      0|            Self::update_node(&mut node);
  139|      0|            Some(Box::new(node))
  140|      0|        }
  141|       |
  142|    155|        fn rotate_left(link: &mut Link<K, V, R>) {
  143|    155|            if let Some(mut x) = link.take() {
  144|    155|                if let Some(mut y) = x.right.take() {
  145|    155|                    x.right = y.left.take();
  146|    155|                    Self::update_node(&mut x);
  147|    155|                    Self::update_node(&mut y);
  148|    155|                    y.left = Some(x);
  149|    155|                    *link = Some(y);
  150|    155|                } else {
  151|      0|                    *link = Some(x);
  152|      0|                }
  153|      0|            }
  154|    155|        }
  155|       |
  156|      6|        fn rotate_right(link: &mut Link<K, V, R>) {
  157|      6|            if let Some(mut x) = link.take() {
  158|      6|                if let Some(mut y) = x.left.take() {
  159|      6|                    x.left = y.right.take();
  160|      6|                    Self::update_node(&mut x);
  161|      6|                    Self::update_node(&mut y);
  162|      6|                    y.right = Some(x);
  163|      6|                    *link = Some(y);
  164|      6|                } else {
  165|      0|                    *link = Some(x);
  166|      0|                }
  167|      0|            }
  168|      6|        }
  169|       |
  170|    837|        fn insert_link(link: &mut Link<K, V, R>, key: K, value: V, rng: &mut impl Rng) {
  171|    837|            if let Some(node) = link.as_mut() {
                                      ^638
  172|    638|                if key < node.key {
  173|     17|                    Self::insert_link(&mut node.left, key, value, rng);
  174|     17|                    if node.left.as_ref().map_or(false, |left| left.priority < node.priority) {
  175|      6|                        Self::rotate_right(link);
  176|     11|                    }
  177|    621|                } else if key > node.key {
  178|    618|                    Self::insert_link(&mut node.right, key, value, rng);
  179|    618|                    if node
  180|    618|                        .right
  181|    618|                        .as_ref()
  182|    618|                        .map_or(false, |right| right.priority < node.priority)
  183|    155|                    {
  184|    155|                        Self::rotate_left(link);
  185|    463|                    }
  186|      3|                } else {
  187|      3|                    // Key exists, update value
  188|      3|                    node.value = value;
  189|      3|                }
  190|    638|                if let Some(node) = link.as_mut() {
  191|    638|                    Self::update_node(node);
  192|    638|                }
                              ^0
  193|    199|            } else {
  194|    199|                let node_reduced = Op::lift(&value);
  195|    199|                *link = Some(Box::new(Node::new(key, value, rng.random(), node_reduced)));
  196|    199|            }
  197|    837|        }
  198|       |
  199|  1.62k|        fn find_link<'a>(link: &'a Link<K, V, R>, key: &K) -> Option<&'a V> {
  200|  1.62k|            match link {
  201|      9|                | None => None,
  202|  1.61k|                | Some(node) => {
  203|  1.61k|                    if key == &node.key {
  204|    271|                        Some(&node.value)
  205|  1.34k|                    } else if key < &node.key {
  206|    683|                        Self::find_link(&node.left, key)
  207|       |                    } else {
  208|    661|                        Self::find_link(&node.right, key)
  209|       |                    }
  210|       |                }
  211|       |            }
  212|  1.62k|        }
  213|       |
  214|     21|        fn min_key_link<'a>(link: &'a Link<K, V, R>) -> Option<&'a K> {
  215|     21|            match link {
  216|      2|                | None => None,
  217|     19|                | Some(node) => match node.left {
  218|      8|                    | None => Some(&node.key),
  219|     11|                    | Some(_) => Self::min_key_link(&node.left),
  220|       |                },
  221|       |            }
  222|     21|        }
  223|       |
  224|     19|        fn max_key_link<'a>(link: &'a Link<K, V, R>) -> Option<&'a K> {
  225|     19|            match link {
  226|      2|                | None => None,
  227|     17|                | Some(node) => match node.right {
  228|      8|                    | None => Some(&node.key),
  229|      9|                    | Some(_) => Self::max_key_link(&node.right),
  230|       |                },
  231|       |            }
  232|     19|        }
  233|       |
  234|    116|        fn collect_keys(link: &Link<K, V, R>, out: &mut Vec<K>) {
  235|    116|            if let Some(node) = link {
                                      ^56
  236|     56|                Self::collect_keys(&node.left, out);
  237|     56|                out.push(node.key.clone());
  238|     56|                Self::collect_keys(&node.right, out);
  239|     60|            }
  240|    116|        }
  241|       |
  242|    116|        fn collect_values(link: &Link<K, V, R>, out: &mut Vec<V>) {
  243|    116|            if let Some(node) = link {
                                      ^56
  244|     56|                Self::collect_values(&node.left, out);
  245|     56|                out.push(node.value.clone());
  246|     56|                Self::collect_values(&node.right, out);
  247|     60|            }
  248|    116|        }
  249|       |
  250|    171|        fn range_reduce_link(link: &Link<K, V, R>, low: &K, high: &K) -> R {
  251|    171|            match link {
  252|     65|                | None => Op::identity(),
  253|    106|                | Some(node) => {
  254|    106|                    let mut result = Op::identity();
  255|       |
  256|       |                    // Include left subtree if it might contain keys >= low
  257|    106|                    if &node.key > low {
  258|     70|                        result = Op::combine(result, Self::range_reduce_link(&node.left, low, high));
  259|     70|                    }
                                  ^36
  260|       |
  261|       |                    // Include current node if it's in range
  262|    106|                    if &node.key >= low && &node.key <= high {
                                                         ^88
  263|     71|                        result = Op::combine(result, Op::lift(&node.value));
  264|     71|                    }
                                  ^35
  265|       |
  266|       |                    // Include right subtree if it might contain keys <= high
  267|    106|                    if &node.key < high {
  268|     72|                        result = Op::combine(result, Self::range_reduce_link(&node.right, low, high));
  269|     72|                    }
                                  ^34
  270|       |
  271|    106|                    result
  272|       |                }
  273|       |            }
  274|    171|        }
  275|       |    }
  276|       |
  277|       |    impl<K: StT + Ord, V: StT, R: StT, Op: ReduceOp<V, R>> BSTReducedStEphTrait<K, V, R, Op>
  278|       |        for BSTReducedStEph<K, V, R, Op>
  279|       |    {
  280|     18|        fn new() -> Self {
  281|     18|            BSTReducedStEph {
  282|     18|                root: None,
  283|     18|                _op: PhantomData,
  284|     18|            }
  285|     18|        }
  286|       |
  287|     28|        fn size(&self) -> N { Self::size_link(&self.root) }
  288|       |
  289|      5|        fn is_empty(&self) -> B { self.size() == 0 }
  290|       |
  291|      3|        fn height(&self) -> N {
  292|    205|            fn height_rec<K: StT + Ord, V: StT, R: StT>(link: &Link<K, V, R>) -> N {
  293|    205|                match link {
  294|    104|                    | None => 0,
  295|    101|                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),
  296|       |                }
  297|    205|            }
  298|      3|            height_rec(&self.root)
  299|      3|        }
  300|       |
  301|    202|        fn insert(&mut self, key: K, value: V) {
  302|    202|            let mut r = rng();
  303|    202|            Self::insert_link(&mut self.root, key, value, &mut r);
  304|    202|        }
  305|       |
  306|    280|        fn find(&self, key: &K) -> Option<&V> { Self::find_link(&self.root, key) }
  307|       |
  308|     59|        fn contains(&self, key: &K) -> B { self.find(key).is_some() }
  309|       |
  310|     60|        fn get(&self, key: &K) -> Option<&V> { self.find(key) }
  311|       |
  312|      4|        fn keys(&self) -> ArraySeqStPerS<K> {
  313|      4|            let mut out = Vec::with_capacity(self.size());
  314|      4|            Self::collect_keys(&self.root, &mut out);
  315|      4|            ArraySeqStPerS::from_vec(out)
  316|      4|        }
  317|       |
  318|      4|        fn values(&self) -> ArraySeqStPerS<V> {
  319|      4|            let mut out = Vec::with_capacity(self.size());
  320|      4|            Self::collect_values(&self.root, &mut out);
  321|      4|            ArraySeqStPerS::from_vec(out)
  322|      4|        }
  323|       |
  324|     10|        fn minimum_key(&self) -> Option<&K> { Self::min_key_link(&self.root) }
  325|       |
  326|     10|        fn maximum_key(&self) -> Option<&K> { Self::max_key_link(&self.root) }
  327|       |
  328|     19|        fn reduced_value(&self) -> R { Self::reduced_value_link(&self.root) }
  329|       |
  330|     29|        fn range_reduce(&self, low: &K, high: &K) -> R { Self::range_reduce_link(&self.root, low, high) }
  331|       |    }
  332|       |
  333|       |    // Type aliases for common reductions
  334|       |    pub type BSTSumStEph<K, V> = BSTReducedStEph<K, V, V, SumOp<V>>;
  335|       |    pub type BSTCountStEph<K, V> = BSTReducedStEph<K, V, N, CountOp<V>>;
  336|       |
  337|       |    #[macro_export]
  338|       |    macro_rules! BSTReducedStEphLit {
  339|       |        () => {
  340|       |            < $crate::Chap40::BSTReducedStEph::BSTReducedStEph::BSTReducedStEph<_, _, _, _> as $crate::Chap40::BSTReducedStEph::BSTReducedStEph::BSTReducedStEphTrait<_, _, _, _> >::new()
  341|       |        };
  342|       |        ( $( ($k:expr, $v:expr) ),* $(,)? ) => {{
  343|       |            let mut __tree = < $crate::Chap40::BSTReducedStEph::BSTReducedStEph::BSTReducedStEph<_, _, _, _> as $crate::Chap40::BSTReducedStEph::BSTReducedStEph::BSTReducedStEphTrait<_, _, _, _> >::new();
  344|       |            $( __tree.insert($k, $v); )*
  345|       |            __tree
  346|       |        }};
  347|       |    }
  348|       |
  349|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap40/BSTSizeStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Size-augmented BST with O(1) size queries and rank/select operations.
    3|       |
    4|       |pub mod BSTSizeStEph {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Types::Types::*;
    8|       |    use rand::*;
    9|       |
   10|       |    type Link<T> = Option<Box<Node<T>>>;
   11|       |
   12|       |    #[derive(Clone, Debug)]
   13|       |    struct Node<T: StT + Ord> {
   14|       |        key: T,
   15|       |        priority: u64,
   16|       |        size: N, // Size of subtree rooted at this node
   17|       |        left: Link<T>,
   18|       |        right: Link<T>,
   19|       |    }
   20|       |
   21|       |    impl<T: StT + Ord> Node<T> {
   22|  1.07k|        fn new(key: T, priority: u64) -> Self {
   23|  1.07k|            Node {
   24|  1.07k|                key,
   25|  1.07k|                priority,
   26|  1.07k|                size: 1,
   27|  1.07k|                left: None,
   28|  1.07k|                right: None,
   29|  1.07k|            }
   30|  1.07k|        }
   31|       |    }
   32|       |
   33|       |    #[derive(Debug, Clone)]
   34|       |    pub struct BSTSizeStEph<T: StT + Ord> {
   35|       |        root: Link<T>,
   36|       |    }
   37|       |
   38|       |    pub type BSTreeSize<T> = BSTSizeStEph<T>;
   39|       |
   40|       |    pub trait BSTSizeStEphTrait<T: StT + Ord> {
   41|       |        /// claude-4-sonet: Work (1), Span (1)
   42|       |        fn new() -> Self;
   43|       |        /// claude-4-sonet: Work (1), Span (1)
   44|       |        fn size(&self) -> N;
   45|       |        /// claude-4-sonet: Work (1), Span (1)
   46|       |        fn is_empty(&self) -> B;
   47|       |        /// claude-4-sonet: Work (n), Span (n)
   48|       |        fn height(&self) -> N;
   49|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected, Parallelism (1)
   50|       |        fn insert(&mut self, value: T);
   51|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected, Parallelism (1)
   52|       |        fn find(&self, target: &T) -> Option<&T>;
   53|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected, Parallelism (1)
   54|       |        fn contains(&self, target: &T) -> B;
   55|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected, Parallelism (1)
   56|       |        fn minimum(&self) -> Option<&T>;
   57|       |        /// claude-4-sonet: Work (log n) expected, (n) worst case; Span (log n) expected, Parallelism (1)
   58|       |        fn maximum(&self) -> Option<&T>;
   59|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   60|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   61|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   62|       |        fn rank(&self, key: &T) -> N;
   63|       |        fn select(&self, rank: N) -> Option<&T>;
   64|       |        fn split_rank(&self, rank: N) -> (BSTSizeStEph<T>, BSTSizeStEph<T>);
   65|       |    }
   66|       |
   67|       |    impl<T: StT + Ord> Default for BSTreeSize<T> {
   68|      0|        fn default() -> Self { Self::new() }
   69|       |    }
   70|       |
   71|       |    impl<T: StT + Ord> BSTSizeStEph<T> {
   72|       |        // Private helper methods only - no public delegation
   73|       |
   74|  19.9k|        fn size_link(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }
   75|       |
   76|  9.74k|        fn update_size(node: &mut Node<T>) {
   77|  9.74k|            node.size = 1 + Self::size_link(&node.left) + Self::size_link(&node.right);
   78|  9.74k|        }
   79|       |
   80|     22|        fn make_node(key: T, priority: u64, left: Link<T>, right: Link<T>) -> Link<T> {
   81|     22|            let mut node = Node::new(key, priority);
   82|     22|            node.left = left;
   83|     22|            node.right = right;
   84|     22|            Self::update_size(&mut node);
   85|     22|            Some(Box::new(node))
   86|     22|        }
   87|       |
   88|  1.01k|        fn rotate_left(link: &mut Link<T>) {
   89|  1.01k|            if let Some(mut x) = link.take() {
   90|  1.01k|                if let Some(mut y) = x.right.take() {
   91|  1.01k|                    x.right = y.left.take();
   92|  1.01k|                    Self::update_size(&mut x);
   93|  1.01k|                    Self::update_size(&mut y);
   94|  1.01k|                    y.left = Some(x);
   95|  1.01k|                    *link = Some(y);
   96|  1.01k|                } else {
   97|      0|                    *link = Some(x);
   98|      0|                }
   99|      0|            }
  100|  1.01k|        }
  101|       |
  102|     27|        fn rotate_right(link: &mut Link<T>) {
  103|     27|            if let Some(mut x) = link.take() {
  104|     27|                if let Some(mut y) = x.left.take() {
  105|     27|                    x.left = y.right.take();
  106|     27|                    Self::update_size(&mut x);
  107|     27|                    Self::update_size(&mut y);
  108|     27|                    y.right = Some(x);
  109|     27|                    *link = Some(y);
  110|     27|                } else {
  111|      0|                    *link = Some(x);
  112|      0|                }
  113|      0|            }
  114|     27|        }
  115|       |
  116|  8.69k|        fn insert_link(link: &mut Link<T>, value: T, rng: &mut impl Rng) {
  117|  8.69k|            if let Some(node) = link.as_mut() {
                                      ^7.64k
  118|  7.64k|                if value < node.key {
  119|     52|                    Self::insert_link(&mut node.left, value, rng);
  120|     52|                    if node.left.as_ref().map_or(false, |left| left.priority < node.priority) {
  121|     27|                        Self::rotate_right(link);
  122|     27|                    }
                                  ^25
  123|  7.59k|                } else if value > node.key {
  124|  7.59k|                    Self::insert_link(&mut node.right, value, rng);
  125|  7.59k|                    if node
  126|  7.59k|                        .right
  127|  7.59k|                        .as_ref()
  128|  7.59k|                        .map_or(false, |right| right.priority < node.priority)
  129|  1.01k|                    {
  130|  1.01k|                        Self::rotate_left(link);
  131|  6.57k|                    }
  132|      1|                }
  133|  7.64k|                if let Some(node) = link.as_mut() {
  134|  7.64k|                    Self::update_size(node);
  135|  7.64k|                }
                              ^0
  136|  1.05k|            } else {
  137|  1.05k|                *link = Some(Box::new(Node::new(value, rng.random())));
  138|  1.05k|            }
  139|  8.69k|        }
  140|       |
  141|     39|        fn find_link<'a>(link: &'a Link<T>, target: &T) -> Option<&'a T> {
  142|     39|            match link {
  143|      4|                | None => None,
  144|     35|                | Some(node) => {
  145|     35|                    if target == &node.key {
  146|     11|                        Some(&node.key)
  147|     24|                    } else if target < &node.key {
  148|      8|                        Self::find_link(&node.left, target)
  149|       |                    } else {
  150|     16|                        Self::find_link(&node.right, target)
  151|       |                    }
  152|       |                }
  153|       |            }
  154|     39|        }
  155|       |
  156|      3|        fn min_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  157|      3|            match link {
  158|      0|                | None => None,
  159|      3|                | Some(node) => match node.left {
  160|      1|                    | None => Some(&node.key),
  161|      2|                    | Some(_) => Self::min_link(&node.left),
  162|       |                },
  163|       |            }
  164|      3|        }
  165|       |
  166|      2|        fn max_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  167|      2|            match link {
  168|      0|                | None => None,
  169|      2|                | Some(node) => match node.right {
  170|      1|                    | None => Some(&node.key),
  171|      1|                    | Some(_) => Self::max_link(&node.right),
  172|       |                },
  173|       |            }
  174|      2|        }
  175|       |
  176|     31|        fn in_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  177|     31|            if let Some(node) = link {
                                      ^15
  178|     15|                Self::in_order_collect(&node.left, out);
  179|     15|                out.push(node.key.clone());
  180|     15|                Self::in_order_collect(&node.right, out);
  181|     16|            }
  182|     31|        }
  183|       |
  184|    176|        fn rank_link(link: &Link<T>, key: &T) -> N {
  185|    176|            match link {
  186|      2|                | None => 0,
  187|    174|                | Some(node) => {
  188|    174|                    let left_size = Self::size_link(&node.left);
  189|    174|                    if key < &node.key {
  190|     58|                        Self::rank_link(&node.left, key)
  191|    116|                    } else if key == &node.key {
  192|     42|                        left_size + 1
  193|       |                    } else {
  194|     74|                        left_size + 1 + Self::rank_link(&node.right, key)
  195|       |                    }
  196|       |                }
  197|       |            }
  198|    176|        }
  199|       |
  200|    164|        fn select_link<'a>(link: &'a Link<T>, rank: N) -> Option<&'a T> {
  201|    164|            match link {
  202|      0|                | None => None,
  203|    164|                | Some(node) => {
  204|    164|                    let left_size = Self::size_link(&node.left);
  205|    164|                    if rank <= left_size {
  206|     58|                        Self::select_link(&node.left, rank)
  207|    106|                    } else if rank == left_size + 1 {
  208|     42|                        Some(&node.key)
  209|       |                    } else {
  210|     64|                        Self::select_link(&node.right, rank - left_size - 1)
  211|       |                    }
  212|       |                }
  213|       |            }
  214|    164|        }
  215|       |
  216|     24|        fn split_rank_link(link: &Link<T>, rank: N) -> (Link<T>, Link<T>) {
  217|     24|            match link {
  218|      2|                | None => (None, None),
  219|     22|                | Some(node) => {
  220|     22|                    let left_size = Self::size_link(&node.left);
  221|     22|                    if rank <= left_size {
  222|     11|                        let (ll, lr) = Self::split_rank_link(&node.left, rank);
  223|     11|                        let right_tree = Self::make_node(node.key.clone(), node.priority, lr, node.right.clone());
  224|     11|                        (ll, right_tree)
  225|       |                    } else {
  226|     11|                        let (rl, rr) = Self::split_rank_link(&node.right, rank - left_size - 1);
  227|     11|                        let left_tree = Self::make_node(node.key.clone(), node.priority, node.left.clone(), rl);
  228|     11|                        (left_tree, rr)
  229|       |                    }
  230|       |                }
  231|       |            }
  232|     24|        }
  233|       |    }
  234|       |
  235|       |    impl<T: StT + Ord> BSTSizeStEphTrait<T> for BSTSizeStEph<T> {
  236|     11|        fn new() -> Self { BSTSizeStEph { root: None } }
  237|       |
  238|     64|        fn size(&self) -> N { Self::size_link(&self.root) }
  239|       |
  240|      3|        fn is_empty(&self) -> B { self.size() == 0 }
  241|       |
  242|      1|        fn height(&self) -> N {
  243|  2.00k|            fn height_rec<T: StT + Ord>(link: &Link<T>) -> N {
  244|  2.00k|                match link {
  245|  1.00k|                    | None => 0,
  246|  1.00k|                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),
  247|       |                }
  248|  2.00k|            }
  249|      1|            height_rec(&self.root)
  250|      1|        }
  251|       |
  252|  1.05k|        fn insert(&mut self, value: T) {
  253|  1.05k|            let mut r = rng();
  254|  1.05k|            Self::insert_link(&mut self.root, value, &mut r);
  255|  1.05k|        }
  256|       |
  257|     15|        fn find(&self, target: &T) -> Option<&T> { Self::find_link(&self.root, target) }
  258|       |
  259|     13|        fn contains(&self, target: &T) -> B { self.find(target).is_some() }
  260|       |
  261|      1|        fn minimum(&self) -> Option<&T> { Self::min_link(&self.root) }
  262|       |
  263|      1|        fn maximum(&self) -> Option<&T> { Self::max_link(&self.root) }
  264|       |
  265|      1|        fn in_order(&self) -> ArraySeqStPerS<T> {
  266|      1|            let mut out = Vec::with_capacity(self.size());
  267|      1|            Self::in_order_collect(&self.root, &mut out);
  268|      1|            ArraySeqStPerS::from_vec(out)
  269|      1|        }
  270|       |
  271|     44|        fn rank(&self, key: &T) -> N { Self::rank_link(&self.root, key) }
  272|       |
  273|     44|        fn select(&self, rank: N) -> Option<&T> {
  274|     44|            if rank == 0 || rank > self.size() {
                                          ^43
  275|      2|                None
  276|       |            } else {
  277|     42|                Self::select_link(&self.root, rank)
  278|       |            }
  279|     44|        }
  280|       |
  281|      4|        fn split_rank(&self, rank: N) -> (BSTSizeStEph<T>, BSTSizeStEph<T>) {
  282|      4|            if rank == 0 {
  283|      1|                (BSTSizeStEph::new(), self.clone())
  284|      3|            } else if rank >= self.size() {
  285|      1|                (self.clone(), BSTSizeStEph::new())
  286|       |            } else {
  287|      2|                let (left_root, right_root) = Self::split_rank_link(&self.root, rank);
  288|      2|                (BSTSizeStEph { root: left_root }, BSTSizeStEph { root: right_root })
  289|       |            }
  290|      4|        }
  291|       |    }
  292|       |
  293|       |    #[macro_export]
  294|       |    macro_rules! BSTSizeStEphLit {
  295|       |        () => {
  296|       |            < $crate::Chap40::BSTSizeStEph::BSTSizeStEph::BSTSizeStEph<_> as $crate::Chap40::BSTSizeStEph::BSTSizeStEph::BSTSizeStEphTrait<_> >::new()
  297|       |        };
  298|       |        ( $( $x:expr ),* $(,)? ) => {{
  299|       |            let mut __tree = < $crate::Chap40::BSTSizeStEph::BSTSizeStEph::BSTSizeStEph<_> as $crate::Chap40::BSTSizeStEph::BSTSizeStEph::BSTSizeStEphTrait<_> >::new();
  300|       |            $( __tree.insert($x); )*
  301|       |            __tree
  302|       |        }};
  303|       |    }
  304|       |
  305|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap41/AVLTreeSetMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Multi-threaded ephemeral set implementation using AVLTreeSetStEph as backing store.
    3|       |//!
    4|       |//! Work/Span Analysis (with extract-parallelize-rebuild pattern):
    5|       |//! - union: Work (n+m), Span (log(n+m)) via PARALLEL divide-and-conquer
    6|       |//! - intersection: Work (n+m), Span (log(n+m)) via PARALLEL divide-and-conquer
    7|       |//! - filter: Work (n), Span (log n) via PARALLEL map-reduce
    8|       |
    9|       |pub mod AVLTreeSetMtEph {
   10|       |
   11|       |    use std::fmt;
   12|       |    use std::sync::{Arc, Mutex};
   13|       |
   14|       |    use crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::*;
   15|       |    use crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::*;
   16|       |    use crate::ParaPair;
   17|       |    use crate::Types::Types::*;
   18|       |
   19|       |    pub struct AVLTreeSetMtEph<T: StTInMtT + Ord + 'static> {
   20|       |        inner: Arc<Mutex<AVLTreeSetStEph<T>>>,
   21|       |    }
   22|       |
   23|       |    pub trait AVLTreeSetMtEphTrait<T: StTInMtT + Ord + 'static> {
   24|       |        /// claude-4-sonet: Work (1), Span (1)
   25|       |        fn size(&self) -> N;
   26|       |        /// claude-4-sonet: Work (n), Span (n)
   27|       |        fn to_seq(&self) -> AVLTreeSeqStEphS<T>;
   28|       |        /// claude-4-sonet: Work (1), Span (1)
   29|       |        fn empty() -> Self;
   30|       |        /// claude-4-sonet: Work (1), Span (1)
   31|       |        fn singleton(x: T) -> Self;
   32|       |        /// claude-4-sonet: Work (n log n), Span (log n), Parallelism (n)
   33|       |        fn from_seq(seq: AVLTreeSeqStEphS<T>) -> Self;
   34|       |        /// claude-4-sonet: Work (n), Span (log n), Parallelism (n/log n)
   35|       |        fn filter<F: Fn(&T) -> B + Send + Sync + Clone + 'static>(&self, f: F) -> Self;
   36|       |        /// claude-4-sonet: Work (m + n), Span (log(m + n)), Parallelism ((m+n)/log(m+n))
   37|       |        fn intersection(&self, other: &Self) -> Self;
   38|       |        /// claude-4-sonet: Work (m + n), Span (log(m + n)), Parallelism ((m+n)/log(m+n))
   39|       |        fn difference(&self, other: &Self) -> Self;
   40|       |        /// claude-4-sonet: Work (m + n), Span (log(m + n)), Parallelism ((m+n)/log(m+n))
   41|       |        fn union(&self, other: &Self) -> Self;
   42|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   43|       |        fn find(&self, x: &T) -> B;
   44|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   45|       |        fn delete(&mut self, x: &T);
   46|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   47|       |        fn insert(&mut self, x: T);
   48|       |    }
   49|       |
   50|       |    impl<T: StTInMtT + Ord + 'static> AVLTreeSetMtEphTrait<T> for AVLTreeSetMtEph<T> {
   51|     53|        fn size(&self) -> N {
   52|     53|            let inner = self.inner.lock().unwrap();
   53|     53|            inner.size()
   54|     53|        }
   55|       |
   56|     60|        fn to_seq(&self) -> AVLTreeSeqStEphS<T> {
   57|     60|            let inner = self.inner.lock().unwrap();
   58|     60|            inner.to_seq()
   59|     60|        }
   60|       |
   61|     48|        fn empty() -> Self {
   62|     48|            AVLTreeSetMtEph {
   63|     48|                inner: Arc::new(Mutex::new(AVLTreeSetStEph::empty())),
   64|     48|            }
   65|     48|        }
   66|       |
   67|     26|        fn singleton(x: T) -> Self {
   68|     26|            AVLTreeSetMtEph {
   69|     26|                inner: Arc::new(Mutex::new(AVLTreeSetStEph::singleton(x))),
   70|     26|            }
   71|     26|        }
   72|       |
   73|    122|        fn from_seq(seq: AVLTreeSeqStEphS<T>) -> Self {
   74|    122|            AVLTreeSetMtEph {
   75|    122|                inner: Arc::new(Mutex::new(AVLTreeSetStEph::from_seq(seq))),
   76|    122|            }
   77|    122|        }
   78|       |
   79|       |        // PARALLEL: filter using extract-parallelize-rebuild pattern (unconditionally parallel)
   80|       |        // Work: (n), Span: (log n)
   81|      3|        fn filter<F: Fn(&T) -> B + Send + Sync + Clone + 'static>(&self, f: F) -> Self {
   82|       |            // Extract data from mutex
   83|      3|            let vals = {
   84|      3|                let inner = self.inner.lock().unwrap();
   85|      3|                let seq = inner.to_seq();
   86|      3|                let mut vals = Vec::with_capacity(seq.length());
   87|    220|                for i in 0..seq.length() {
                                          ^3  ^3
   88|    220|                    vals.push(seq.nth(i).clone());
   89|    220|                }
   90|      3|                vals
   91|       |            };
   92|       |            // Lock released here
   93|       |
   94|       |            // Unconditionally parallel divide-and-conquer using ParaPair!
   95|    437|            fn parallel_filter<T: StTInMtT + Ord + 'static, F: Fn(&T) -> B + Send + Sync + Clone + 'static>(
   96|    437|                vals: Vec<T>,
   97|    437|                f: F,
   98|    437|            ) -> Vec<T> {
   99|    437|                let n = vals.len();
  100|    437|                if n == 0 {
  101|      0|                    return Vec::new();
  102|    437|                }
  103|    437|                if n == 1 {
  104|    220|                    return if f(&vals[0]) { vals } else { Vec::new() };
                                                          ^109          ^111
  105|    217|                }
  106|       |
  107|    217|                let mid = n / 2;
  108|    217|                let mut right_vals = vals;
  109|    217|                let left_vals = right_vals.split_off(mid);
  110|    217|                let right_vals_final = right_vals;
  111|       |
  112|    217|                let f_left = f.clone();
  113|    217|                let f_right = f;
  114|       |
  115|    217|                let Pair(left_filtered, right_filtered) = ParaPair!(
  116|    217|                    move || parallel_filter(left_vals, f_left),
  117|    217|                    move || parallel_filter(right_vals_final, f_right)
  118|       |                );
  119|       |
  120|    217|                let mut result = left_filtered;
  121|    217|                result.extend(right_filtered);
  122|    217|                result
  123|    437|            }
  124|       |
  125|      3|            let filtered = parallel_filter(vals, f);
  126|      3|            Self::from_seq(AVLTreeSeqStEphS::from_vec(filtered))
  127|      3|        }
  128|       |
  129|       |        // PARALLEL: intersection using extract-parallelize-rebuild pattern (unconditionally parallel)
  130|       |        // Work: (n+m), Span: (log(n+m))
  131|      2|        fn intersection(&self, other: &Self) -> Self {
  132|       |            // Extract data from both mutexes
  133|      2|            let (self_vals, other_vals) = {
  134|      2|                let self_inner = self.inner.lock().unwrap();
  135|      2|                let other_inner = other.inner.lock().unwrap();
  136|       |
  137|      2|                let self_seq = self_inner.to_seq();
  138|      2|                let other_seq = other_inner.to_seq();
  139|       |
  140|      2|                let mut sv = Vec::with_capacity(self_seq.length());
  141|    110|                for i in 0..self_seq.length() {
                                          ^2       ^2
  142|    110|                    sv.push(self_seq.nth(i).clone());
  143|    110|                }
  144|       |
  145|      2|                let mut ov = Vec::with_capacity(other_seq.length());
  146|    112|                for i in 0..other_seq.length() {
                                          ^2        ^2
  147|    112|                    ov.push(other_seq.nth(i).clone());
  148|    112|                }
  149|       |
  150|      2|                (sv, ov)
  151|       |            };
  152|       |            // Locks released here
  153|       |
  154|       |            // Unconditionally parallel divide-and-conquer using ParaPair!
  155|    218|            fn parallel_intersect<T: StTInMtT + Ord + 'static>(self_vals: Vec<T>, other_vals: Vec<T>) -> Vec<T> {
  156|    218|                let n = self_vals.len();
  157|    218|                if n == 0 {
  158|      0|                    return Vec::new();
  159|    218|                }
  160|    218|                if n == 1 {
  161|    110|                    let other_set = AVLTreeSetMtEph::from_seq(AVLTreeSeqStEphS::from_vec(other_vals));
  162|    110|                    return if other_set.find(&self_vals[0]) {
  163|     57|                        self_vals
  164|       |                    } else {
  165|     53|                        Vec::new()
  166|       |                    };
  167|    108|                }
  168|       |
  169|    108|                let mid = n / 2;
  170|    108|                let mut right_self = self_vals;
  171|    108|                let left_self = right_self.split_off(mid);
  172|    108|                let right_self_final = right_self;
  173|       |
  174|    108|                let other_left = other_vals.clone();
  175|    108|                let other_right = other_vals;
  176|       |
  177|    108|                let Pair(left_intersect, right_intersect) =
  178|    108|                    ParaPair!(move || parallel_intersect(left_self, other_left), move || {
  179|    108|                        parallel_intersect(right_self_final, other_right)
  180|    108|                    });
  181|       |
  182|    108|                let mut result = left_intersect;
  183|    108|                result.extend(right_intersect);
  184|    108|                result
  185|    218|            }
  186|       |
  187|      2|            let intersect = parallel_intersect(self_vals, other_vals);
  188|      2|            Self::from_seq(AVLTreeSeqStEphS::from_vec(intersect))
  189|      2|        }
  190|       |
  191|       |        // PARALLEL: difference using filter
  192|      1|        fn difference(&self, other: &Self) -> Self {
  193|      1|            let other_clone = other.clone();
  194|     10|            self.filter(move |x| !other_clone.find(x))
                          ^1   ^1
  195|      1|        }
  196|       |
  197|       |        // PARALLEL: union using extract-parallelize-rebuild pattern (unconditionally parallel)
  198|       |        // Work: (n+m), Span: (log(n+m))
  199|       |        // Note: Union uses a simple merge strategy to avoid thread explosion.
  200|      6|        fn union(&self, other: &Self) -> Self {
  201|       |            // Extract data from both mutexes
  202|      6|            let (self_vals, other_vals) = {
  203|      6|                let self_inner = self.inner.lock().unwrap();
  204|      6|                let other_inner = other.inner.lock().unwrap();
  205|       |
  206|      6|                let self_seq = self_inner.to_seq();
  207|      6|                let other_seq = other_inner.to_seq();
  208|       |
  209|      6|                let mut sv = Vec::with_capacity(self_seq.length());
  210|    159|                for i in 0..self_seq.length() {
                                          ^6       ^6
  211|    159|                    sv.push(self_seq.nth(i).clone());
  212|    159|                }
  213|       |
  214|      6|                let mut ov = Vec::with_capacity(other_seq.length());
  215|    160|                for i in 0..other_seq.length() {
                                          ^6        ^6
  216|    160|                    ov.push(other_seq.nth(i).clone());
  217|    160|                }
  218|       |
  219|      6|                (sv, ov)
  220|       |            };
  221|       |            // Locks released here
  222|       |
  223|       |            // Simple merge (sequential to avoid thread explosion)
  224|      6|            let mut merged = self_vals;
  225|      6|            merged.extend(other_vals);
  226|      6|            merged.sort();
  227|      6|            merged.dedup();
  228|       |
  229|      6|            Self::from_seq(AVLTreeSeqStEphS::from_vec(merged))
  230|      6|        }
  231|       |
  232|    605|        fn find(&self, x: &T) -> B {
  233|    605|            let inner = self.inner.lock().unwrap();
  234|    605|            inner.find(x)
  235|    605|        }
  236|       |
  237|     24|        fn delete(&mut self, x: &T) {
  238|     24|            let mut inner = self.inner.lock().unwrap();
  239|     24|            inner.delete(x);
  240|     24|        }
  241|       |
  242|    845|        fn insert(&mut self, x: T) {
  243|    845|            let mut inner = self.inner.lock().unwrap();
  244|    845|            inner.insert(x);
  245|    845|        }
  246|       |    }
  247|       |
  248|       |    impl<T: StTInMtT + Ord + 'static> Default for AVLTreeSetMtEph<T> {
  249|      0|        fn default() -> Self { Self::empty() }
  250|       |    }
  251|       |
  252|       |    impl<T: StTInMtT + Ord + 'static> Clone for AVLTreeSetMtEph<T> {
  253|     11|        fn clone(&self) -> Self {
  254|     11|            let inner = self.inner.lock().unwrap();
  255|     11|            AVLTreeSetMtEph {
  256|     11|                inner: Arc::new(Mutex::new((*inner).clone())),
  257|     11|            }
  258|     11|        }
  259|       |    }
  260|       |
  261|       |    impl<T: StTInMtT + Ord + 'static> fmt::Debug for AVLTreeSetMtEph<T> {
  262|      0|        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  263|      0|            write!(f, "{{")?;
  264|      0|            let seq = self.to_seq();
  265|      0|            for i in 0..seq.length() {
  266|      0|                if i > 0 {
  267|      0|                    write!(f, ", ")?;
  268|      0|                }
  269|      0|                write!(f, "{:?}", seq.nth(i))?;
  270|       |            }
  271|      0|            write!(f, "}}")
  272|      0|        }
  273|       |    }
  274|       |
  275|       |    impl<T: StTInMtT + Ord + 'static> fmt::Display for AVLTreeSetMtEph<T> {
  276|      0|        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  277|      0|            write!(f, "{{")?;
  278|      0|            let seq = self.to_seq();
  279|      0|            for i in 0..seq.length() {
  280|      0|                if i > 0 {
  281|      0|                    write!(f, ", ")?;
  282|      0|                }
  283|      0|                write!(f, "{}", seq.nth(i))?;
  284|       |            }
  285|      0|            write!(f, "}}")
  286|      0|        }
  287|       |    }
  288|       |
  289|       |    #[macro_export]
  290|       |    macro_rules! AVLTreeSetMtEphLit {
  291|       |        () => {
  292|       |            < $crate::Chap41::AVLTreeSetMtEph::AVLTreeSetMtEph::AVLTreeSetMtEph<_> as $crate::Chap41::AVLTreeSetMtEph::AVLTreeSetMtEph::AVLTreeSetMtEphTrait<_> >::empty()
  293|       |        };
  294|       |        ( $( $x:expr ),* $(,)? ) => {{
  295|       |            let mut __set = < $crate::Chap41::AVLTreeSetMtEph::AVLTreeSetMtEph::AVLTreeSetMtEph<_> as $crate::Chap41::AVLTreeSetMtEph::AVLTreeSetMtEph::AVLTreeSetMtEphTrait<_> >::empty();
  296|       |            $( __set.insert($x); )*
  297|       |            __set
  298|       |        }};
  299|       |    }
  300|       |
  301|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap41/AVLTreeSetMtPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Multi-threaded persistent set implementation using AVLTreeSeqMtPer (Arc-based).
    3|       |//!
    4|       |//! Work/Span Analysis:
    5|       |//! - union: Work (n+m), Span (log(n+m)) via PARALLEL divide-and-conquer
    6|       |//! - intersection: Work (n+m), Span (log(n+m)) via PARALLEL divide-and-conquer
    7|       |//! - filter: Work (n), Span (log n) via PARALLEL map-reduce
    8|       |
    9|       |pub mod AVLTreeSetMtPer {
   10|       |
   11|       |    use std::fmt;
   12|       |    use std::thread;
   13|       |
   14|       |    use crate::Chap37::AVLTreeSeqMtPer::AVLTreeSeqMtPer::*;
   15|       |    use crate::ParaPair;
   16|       |    use crate::Types::Types::*;
   17|       |
   18|       |    #[derive(PartialEq, Eq)]
   19|       |    pub struct AVLTreeSetMtPer<T: StTInMtT + Ord + 'static> {
   20|       |        elements: AVLTreeSeqMtPerS<T>,
   21|       |    }
   22|       |
   23|       |    pub trait AVLTreeSetMtPerTrait<T: StTInMtT + Ord + 'static> {
   24|       |        /// claude-4-sonet: Work (1), Span (1)
   25|       |        fn size(&self) -> N;
   26|       |        /// claude-4-sonet: Work (1), Span (1)
   27|       |        fn to_seq(&self) -> AVLTreeSeqMtPerS<T>;
   28|       |        /// claude-4-sonet: Work (1), Span (1)
   29|       |        fn empty() -> Self;
   30|       |        /// claude-4-sonet: Work (1), Span (1)
   31|       |        fn singleton(x: T) -> Self;
   32|       |        /// claude-4-sonet: Work (n log n), Span (log n), Parallelism (n)
   33|       |        fn from_seq(seq: AVLTreeSeqMtPerS<T>) -> Self;
   34|       |        /// claude-4-sonet: Work (n), Span (log n), Parallelism (n/log n)
   35|       |        fn filter<F: Fn(&T) -> B + Send + Sync + Clone + 'static>(&self, f: F) -> Self;
   36|       |        /// claude-4-sonet: Work (m + n), Span (log(m + n)), Parallelism ((m+n)/log(m+n))
   37|       |        fn intersection(&self, other: &Self) -> Self;
   38|       |        /// claude-4-sonet: Work (m + n), Span (log(m + n)), Parallelism ((m+n)/log(m+n))
   39|       |        fn difference(&self, other: &Self) -> Self;
   40|       |        /// claude-4-sonet: Work (m + n), Span (log(m + n)), Parallelism ((m+n)/log(m+n))
   41|       |        fn union(&self, other: &Self) -> Self;
   42|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   43|       |        fn find(&self, x: &T) -> B;
   44|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   45|       |        fn delete(&self, x: &T) -> Self;
   46|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   47|       |        fn insert(&self, x: T) -> Self;
   48|       |    }
   49|       |
   50|       |    impl<T: StTInMtT + Ord + 'static> AVLTreeSetMtPerTrait<T> for AVLTreeSetMtPer<T> {
   51|  1.12k|        fn size(&self) -> N { self.elements.length() }
   52|       |
   53|    147|        fn to_seq(&self) -> AVLTreeSeqMtPerS<T> { self.elements.clone() }
   54|       |
   55|    161|        fn empty() -> Self {
   56|    161|            AVLTreeSetMtPer {
   57|    161|                elements: AVLTreeSeqMtPerS::empty(),
   58|    161|            }
   59|    161|        }
   60|       |
   61|    271|        fn singleton(x: T) -> Self {
   62|    271|            AVLTreeSetMtPer {
   63|    271|                elements: AVLTreeSeqMtPerS::singleton(x),
   64|    271|            }
   65|    271|        }
   66|       |
   67|    216|        fn from_seq(seq: AVLTreeSeqMtPerS<T>) -> Self {
   68|    216|            let mut vals = seq.values_in_order();
   69|       |
   70|       |            // Unconditionally parallel merge sort using ParaPair!
   71|  10.2k|            fn parallel_sort<T: StTInMtT + Ord + 'static>(mut vals: Vec<T>) -> Vec<T> {
   72|  10.2k|                let n = vals.len();
   73|  10.2k|                if n <= 1 {
   74|  5.25k|                    return vals;
   75|  5.04k|                }
   76|       |
   77|  5.04k|                let mid = n / 2;
   78|  5.04k|                let right_vals = vals.split_off(mid);
   79|  5.04k|                let left_vals = vals;
   80|       |
   81|  5.04k|                let Pair(left_sorted, right_sorted) =
   82|  5.04k|                    ParaPair!(move || parallel_sort(left_vals), move || parallel_sort(right_vals));
   83|       |
   84|       |                // Merge sorted halves
   85|  5.04k|                let mut result = Vec::with_capacity(n);
   86|  5.04k|                let mut i = 0;
   87|  5.04k|                let mut j = 0;
   88|  19.3k|                while i < left_sorted.len() && j < right_sorted.len() {
                                                             ^14.3k
   89|  14.3k|                    if left_sorted[i] <= right_sorted[j] {
   90|  14.3k|                        result.push(left_sorted[i].clone());
   91|  14.3k|                        i += 1;
   92|  14.3k|                    } else {
   93|      2|                        result.push(right_sorted[j].clone());
   94|      2|                        j += 1;
   95|      2|                    }
   96|       |                }
   97|  5.04k|                result.extend_from_slice(&left_sorted[i..]);
   98|  5.04k|                result.extend_from_slice(&right_sorted[j..]);
   99|  5.04k|                result
  100|  10.2k|            }
  101|       |
  102|    216|            vals = parallel_sort(vals);
  103|    216|            vals.dedup();
  104|    216|            AVLTreeSetMtPer {
  105|    216|                elements: AVLTreeSeqMtPerS::from_vec(vals),
  106|    216|            }
  107|    216|        }
  108|       |
  109|       |        // PARALLEL: filter using divide-and-conquer (unconditionally parallel)
  110|       |        // Work: (n), Span: (log n)
  111|     75|        fn filter<F: Fn(&T) -> B + Send + Sync + Clone + 'static>(&self, f: F) -> Self {
  112|     75|            let n = self.size();
  113|       |
  114|     75|            if n <= 8 {
  115|     75|                let mut vals = Vec::new();
  116|    117|                for i in 0..n {
                                          ^75
  117|    117|                    let elem = self.elements.nth(i);
  118|    117|                    if f(elem) {
  119|     53|                        vals.push(elem.clone());
  120|     64|                    }
  121|       |                }
  122|     75|                return AVLTreeSetMtPer {
  123|     75|                    elements: AVLTreeSeqMtPerS::from_vec(vals),
  124|     75|                };
  125|      0|            }
  126|       |
  127|       |            // Unconditionally parallel divide-and-conquer using ParaPair!
  128|      0|            let mid = n / 2;
  129|       |
  130|      0|            let left_vals: Vec<T> = (0..mid).map(|i| self.elements.nth(i).clone()).collect();
  131|      0|            let right_vals: Vec<T> = (mid..n).map(|i| self.elements.nth(i).clone()).collect();
  132|       |
  133|      0|            let left_set = Self::from_seq(AVLTreeSeqMtPerS::from_vec(left_vals));
  134|      0|            let right_set = Self::from_seq(AVLTreeSeqMtPerS::from_vec(right_vals));
  135|       |
  136|      0|            let f_left = f.clone();
  137|      0|            let f_right = f;
  138|       |
  139|      0|            let Pair(left_result, right_result) =
  140|      0|                ParaPair!(move || left_set.filter(f_left), move || right_set.filter(f_right));
  141|       |
  142|      0|            left_result.union(&right_result)
  143|     75|        }
  144|       |
  145|       |        // PARALLEL: intersection using divide-and-conquer (unconditionally parallel)
  146|       |        // Work: (n+m), Span: (log(n+m))
  147|      3|        fn intersection(&self, other: &Self) -> Self {
  148|      3|            let n = self.size();
  149|      3|            let m = other.size();
  150|       |
  151|      3|            if n == 0 || m == 0 {
  152|      0|                return Self::empty();
  153|      3|            }
  154|       |
  155|      3|            if n <= 8 {
  156|      3|                let mut vals = Vec::new();
  157|      8|                for i in 0..n {
                                          ^3
  158|      8|                    let elem = self.elements.nth(i);
  159|      8|                    if other.find(elem) {
  160|      4|                        vals.push(elem.clone());
  161|      4|                    }
  162|       |                }
  163|      3|                return AVLTreeSetMtPer {
  164|      3|                    elements: AVLTreeSeqMtPerS::from_vec(vals),
  165|      3|                };
  166|      0|            }
  167|       |
  168|       |            // Unconditionally parallel divide-and-conquer using ParaPair!
  169|      0|            let mid = n / 2;
  170|       |
  171|      0|            let left_vals: Vec<T> = (0..mid).map(|i| self.elements.nth(i).clone()).collect();
  172|      0|            let right_vals: Vec<T> = (mid..n).map(|i| self.elements.nth(i).clone()).collect();
  173|       |
  174|      0|            let left_set = Self::from_seq(AVLTreeSeqMtPerS::from_vec(left_vals));
  175|      0|            let right_set = Self::from_seq(AVLTreeSeqMtPerS::from_vec(right_vals));
  176|      0|            let other_left = other.clone();
  177|      0|            let other_right = other.clone();
  178|       |
  179|      0|            let Pair(left_result, right_result) =
  180|      0|                ParaPair!(move || left_set.intersection(&other_left), move || right_set
  181|      0|                    .intersection(&other_right));
  182|       |
  183|      0|            left_result.union(&right_result)
  184|      3|        }
  185|       |
  186|     62|        fn difference(&self, other: &Self) -> Self {
  187|     62|            let other_clone = other.clone();
  188|     88|            self.filter(move |x| !other_clone.find(x))
                          ^62  ^62
  189|     62|        }
  190|       |
  191|       |        // PARALLEL: union using divide-and-conquer (unconditionally parallel)
  192|       |        // Work: (n+m), Span: (log(n+m))
  193|    197|        fn union(&self, other: &Self) -> Self {
  194|    197|            let n = self.size();
  195|    197|            let m = other.size();
  196|       |
  197|    197|            if n == 0 {
  198|     74|                return other.clone();
  199|    123|            }
  200|    123|            if m == 0 {
  201|      2|                return self.clone();
  202|    121|            }
  203|       |
  204|    121|            if n <= 8 {
  205|    121|                let mut vals = self.elements.values_in_order();
  206|    121|                vals.extend(other.elements.values_in_order());
  207|    121|                vals.sort();
  208|    121|                vals.dedup();
  209|    121|                return AVLTreeSetMtPer {
  210|    121|                    elements: AVLTreeSeqMtPerS::from_vec(vals),
  211|    121|                };
  212|      0|            }
  213|       |
  214|       |            // Unconditionally parallel divide-and-conquer using ParaPair!
  215|      0|            let mid = n / 2;
  216|       |
  217|      0|            let left_vals: Vec<T> = (0..mid).map(|i| self.elements.nth(i).clone()).collect();
  218|      0|            let right_vals: Vec<T> = (mid..n).map(|i| self.elements.nth(i).clone()).collect();
  219|       |
  220|      0|            let left_set = Self::from_seq(AVLTreeSeqMtPerS::from_vec(left_vals));
  221|      0|            let right_set = Self::from_seq(AVLTreeSeqMtPerS::from_vec(right_vals));
  222|      0|            let other_left = other.clone();
  223|      0|            let other_right = other.clone();
  224|       |
  225|      0|            let Pair(left_result, right_result) = ParaPair!(move || left_set.union(&other_left), move || right_set
  226|      0|                .union(&other_right));
  227|       |
  228|      0|            left_result.union(&right_result)
  229|    197|        }
  230|       |
  231|    493|        fn find(&self, x: &T) -> B {
  232|       |            // Binary search in sorted sequence
  233|    493|            let n = self.size();
  234|    493|            let mut left = 0;
  235|    493|            let mut right = n;
  236|       |
  237|  1.25k|            while left < right {
  238|    941|                let mid = (left + right) / 2;
  239|    941|                let elem = self.elements.nth(mid);
  240|    941|                match elem.cmp(x) {
  241|    673|                    | std::cmp::Ordering::Less => left = mid + 1,
  242|    176|                    | std::cmp::Ordering::Equal => return true,
  243|     92|                    | std::cmp::Ordering::Greater => right = mid,
  244|       |                }
  245|       |            }
  246|    317|            false
  247|    493|        }
  248|       |
  249|      8|        fn delete(&self, x: &T) -> Self {
  250|       |            // Unconditionally use parallel filter
  251|      8|            let x_clone = x.clone();
  252|     17|            self.filter(move |v| v != &x_clone)
                          ^8   ^8
  253|      8|        }
  254|       |
  255|    232|        fn insert(&self, x: T) -> Self {
  256|    232|            if self.find(&x) {
  257|     16|                return self.clone();
  258|    216|            }
  259|    216|            let mut vals = self.elements.values_in_order();
  260|    216|            vals.push(x);
  261|       |
  262|       |            // Unconditionally use parallel from_seq
  263|    216|            Self::from_seq(AVLTreeSeqMtPerS::from_vec(vals))
  264|    232|        }
  265|       |    }
  266|       |
  267|       |    impl<T: StTInMtT + Ord + 'static> Default for AVLTreeSetMtPer<T> {
  268|      0|        fn default() -> Self { Self::empty() }
  269|       |    }
  270|       |
  271|       |    impl<T: StTInMtT + Ord + 'static> Clone for AVLTreeSetMtPer<T> {
  272|    494|        fn clone(&self) -> Self {
  273|    494|            AVLTreeSetMtPer {
  274|    494|                elements: self.elements.clone(),
  275|    494|            }
  276|    494|        }
  277|       |    }
  278|       |
  279|       |    impl<T: StTInMtT + Ord + 'static> fmt::Debug for AVLTreeSetMtPer<T> {
  280|      0|        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  281|      0|            write!(f, "{{")?;
  282|      0|            for i in 0..self.size() {
  283|      0|                if i > 0 {
  284|      0|                    write!(f, ", ")?;
  285|      0|                }
  286|      0|                write!(f, "{:?}", self.elements.nth(i))?;
  287|       |            }
  288|      0|            write!(f, "}}")
  289|      0|        }
  290|       |    }
  291|       |
  292|       |    impl<T: StTInMtT + Ord + 'static> fmt::Display for AVLTreeSetMtPer<T> {
  293|      0|        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  294|      0|            write!(f, "{{")?;
  295|      0|            for i in 0..self.size() {
  296|      0|                if i > 0 {
  297|      0|                    write!(f, ", ")?;
  298|      0|                }
  299|      0|                write!(f, "{}", self.elements.nth(i))?;
  300|       |            }
  301|      0|            write!(f, "}}")
  302|      0|        }
  303|       |    }
  304|       |
  305|       |    #[macro_export]
  306|       |    macro_rules! AVLTreeSetMtPerLit {
  307|       |        () => {
  308|       |            < $crate::Chap41::AVLTreeSetMtPer::AVLTreeSetMtPer::AVLTreeSetMtPer<_> as $crate::Chap41::AVLTreeSetMtPer::AVLTreeSetMtPer::AVLTreeSetMtPerTrait<_> >::empty()
  309|       |        };
  310|       |        ( $( $x:expr ),* $(,)? ) => {{
  311|       |            let mut __set = < $crate::Chap41::AVLTreeSetMtPer::AVLTreeSetMtPer::AVLTreeSetMtPer<_> as $crate::Chap41::AVLTreeSetMtPer::AVLTreeSetMtPer::AVLTreeSetMtPerTrait<_> >::empty();
  312|       |            $( __set = __set.insert($x); )*
  313|       |            __set
  314|       |        }};
  315|       |    }
  316|       |
  317|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap41/AVLTreeSetStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Single-threaded ephemeral set implementation using AVLTreeSeqStEph as backing store.
    3|       |
    4|       |pub mod AVLTreeSetStEph {
    5|       |
    6|       |    use std::fmt;
    7|       |
    8|       |    use crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::*;
    9|       |    use crate::Types::Types::*;
   10|       |
   11|       |    #[derive(PartialEq, Eq)]
   12|       |    pub struct AVLTreeSetStEph<T: StT + Ord> {
   13|       |        elements: AVLTreeSeqStEphS<T>,
   14|       |    }
   15|       |
   16|       |    pub type AVLTreeSetS<T> = AVLTreeSetStEph<T>;
   17|       |
   18|       |    pub trait AVLTreeSetStEphTrait<T: StT + Ord> {
   19|       |        /// claude-4-sonet: Work (1), Span (1)
   20|       |        fn size(&self) -> N;
   21|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   22|       |        fn to_seq(&self) -> AVLTreeSeqStEphS<T>;
   23|       |        /// claude-4-sonet: Work (1), Span (1)
   24|       |        fn empty() -> Self;
   25|       |        /// claude-4-sonet: Work (1), Span (1)
   26|       |        fn singleton(x: T) -> Self;
   27|       |        /// claude-4-sonet: Work (n log n), Span (n log n), Parallelism (1)
   28|       |        fn from_seq(seq: AVLTreeSeqStEphS<T>) -> Self;
   29|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   30|       |        fn filter<F: Fn(&T) -> B>(&self, f: F) -> Self;
   31|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   32|       |        fn intersection(&self, other: &Self) -> Self;
   33|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   34|       |        fn difference(&self, other: &Self) -> Self;
   35|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   36|       |        fn union(&self, other: &Self) -> Self;
   37|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   38|       |        fn find(&self, x: &T) -> B;
   39|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   40|       |        fn delete(&mut self, x: &T);
   41|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   42|       |        fn insert(&mut self, x: T);
   43|       |    }
   44|       |
   45|       |    impl<T: StT + Ord> AVLTreeSetStEphTrait<T> for AVLTreeSetStEph<T> {
   46|    263|        fn size(&self) -> N { self.elements.length() }
   47|       |
   48|    268|        fn to_seq(&self) -> AVLTreeSeqStEphS<T> {
   49|       |            // Create a new sequence from the elements
   50|    268|            let size = self.elements.length();
   51|    268|            let mut vec_elements = Vec::with_capacity(size);
   52|  1.25k|            for i in 0..size {
                                      ^268
   53|  1.25k|                vec_elements.push(self.elements.nth(i).clone());
   54|  1.25k|            }
   55|    268|            AVLTreeSeqStEphS::from_vec(vec_elements)
   56|    268|        }
   57|       |
   58|  11.3k|        fn empty() -> Self {
   59|  11.3k|            AVLTreeSetStEph {
   60|  11.3k|                elements: AVLTreeSeqStEphS::empty(),
   61|  11.3k|            }
   62|  11.3k|        }
   63|       |
   64|  10.9k|        fn singleton(x: T) -> Self {
   65|  10.9k|            AVLTreeSetStEph {
   66|  10.9k|                elements: AVLTreeSeqStEphS::singleton(x),
   67|  10.9k|            }
   68|  10.9k|        }
   69|       |
   70|    135|        fn from_seq(seq: AVLTreeSeqStEphS<T>) -> Self {
   71|       |            // Example 41.3: fromSeq a = Seq.reduce Set.union  {x} : x  a
   72|       |            // Work efficient and parallel implementation
   73|    135|            if seq.length() == 0 {
   74|      1|                return Self::empty();
   75|    134|            }
   76|       |
   77|       |            // Create sequence of singleton sets {x} : x  a
   78|    134|            let seq_len = seq.length();
   79|    134|            let mut singleton_sets = Vec::with_capacity(seq_len);
   80|  10.6k|            for i in 0..seq_len {
                                      ^134
   81|  10.6k|                let elem = seq.nth(i).clone();
   82|  10.6k|                singleton_sets.push(Self::singleton(elem));
   83|  10.6k|            }
   84|       |
   85|       |            // Reduce with union operation
   86|    134|            let mut result = Self::empty();
   87|  10.8k|            for set in singleton_sets {
                              ^10.6k
   88|  10.6k|                result = result.union(&set);
   89|  10.6k|            }
   90|    134|            result
   91|    135|        }
   92|       |
   93|      7|        fn filter<F: Fn(&T) -> B>(&self, f: F) -> Self {
   94|      7|            let mut result = Self::empty();
   95|     25|            for i in 0..self.elements.length() {
                                      ^7            ^7
   96|     25|                let elem = self.elements.nth(i);
   97|     25|                if f(elem) {
   98|     15|                    result.insert(elem.clone());
   99|     15|                }
                              ^10
  100|       |            }
  101|      7|            result
  102|      7|        }
  103|       |
  104|      2|        fn intersection(&self, other: &Self) -> Self {
  105|      2|            let mut result = Self::empty();
  106|      7|            for i in 0..self.elements.length() {
                                      ^2            ^2
  107|      7|                let elem = self.elements.nth(i);
  108|      7|                if other.find(elem) {
  109|      3|                    result.insert(elem.clone());
  110|      4|                }
  111|       |            }
  112|      2|            result
  113|      2|        }
  114|       |
  115|     62|        fn difference(&self, other: &Self) -> Self {
  116|     62|            let mut result = Self::empty();
  117|     89|            for i in 0..self.elements.length() {
                                      ^62           ^62
  118|     89|                let elem = self.elements.nth(i);
  119|     89|                if !other.find(elem) {
  120|     38|                    result.insert(elem.clone());
  121|     51|                }
  122|       |            }
  123|     62|            result
  124|     62|        }
  125|       |
  126|  10.8k|        fn union(&self, other: &Self) -> Self {
  127|  10.8k|            let mut result = Self::empty();
  128|       |            // Add all elements from self
  129|   543k|            for i in 0..self.elements.length() {
                                      ^10.8k        ^10.8k
  130|   543k|                let elem = self.elements.nth(i);
  131|   543k|                result.insert(elem.clone());
  132|   543k|            }
  133|       |            // Add all elements from other
  134|  10.8k|            for i in 0..other.elements.length() {
                                      ^10.8k         ^10.8k
  135|  10.8k|                let elem = other.elements.nth(i);
  136|  10.8k|                result.insert(elem.clone());
  137|  10.8k|            }
  138|  10.8k|            result
  139|  10.8k|        }
  140|       |
  141|   556k|        fn find(&self, x: &T) -> B {
  142|  20.0M|            for i in 0..self.elements.length() {
                                      ^556k         ^556k
  143|  20.0M|                if self.elements.nth(i) == x {
  144|    792|                    return true;
  145|  20.0M|                }
  146|       |            }
  147|   555k|            false
  148|   556k|        }
  149|       |
  150|     48|        fn delete(&mut self, x: &T) {
  151|     48|            let size = self.elements.length();
  152|     48|            let mut vec_elements = Vec::with_capacity(size);
  153|     80|            for i in 0..size {
                                      ^48
  154|     80|                let elem = self.elements.nth(i);
  155|     80|                if elem != x {
  156|     33|                    vec_elements.push(elem.clone());
  157|     47|                }
  158|       |            }
  159|     48|            self.elements = AVLTreeSeqStEphS::from_vec(vec_elements);
  160|     48|        }
  161|       |
  162|   555k|        fn insert(&mut self, x: T) {
  163|   555k|            if !self.find(&x) {
  164|       |                // Element doesn't exist, add it
  165|   555k|                let size = self.elements.length();
  166|   555k|                let mut vec_elements = Vec::with_capacity(size + 1);
  167|  20.0M|                for i in 0..size {
                                          ^555k
  168|  20.0M|                    vec_elements.push(self.elements.nth(i).clone());
  169|  20.0M|                }
  170|   555k|                vec_elements.push(x);
  171|   555k|                vec_elements.sort();
  172|   555k|                self.elements = AVLTreeSeqStEphS::from_vec(vec_elements);
  173|     35|            }
  174|   555k|        }
  175|       |    }
  176|       |
  177|       |    impl<T: StT + Ord> Default for AVLTreeSetStEph<T> {
  178|      0|        fn default() -> Self { Self::empty() }
  179|       |    }
  180|       |
  181|       |    impl<T: StT + Ord> Clone for AVLTreeSetStEph<T> {
  182|    233|        fn clone(&self) -> Self {
  183|    233|            AVLTreeSetStEph {
  184|    233|                elements: self.elements.clone(),
  185|    233|            }
  186|    233|        }
  187|       |    }
  188|       |
  189|       |    impl<T: StT + Ord> fmt::Debug for AVLTreeSetStEph<T> {
  190|      0|        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  191|      0|            write!(f, "{{")?;
  192|      0|            for i in 0..self.elements.length() {
  193|      0|                if i > 0 {
  194|      0|                    write!(f, ", ")?;
  195|      0|                }
  196|      0|                write!(f, "{:?}", self.elements.nth(i))?;
  197|       |            }
  198|      0|            write!(f, "}}")
  199|      0|        }
  200|       |    }
  201|       |
  202|       |    impl<T: StT + Ord> fmt::Display for AVLTreeSetStEph<T> {
  203|      0|        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  204|      0|            write!(f, "{{")?;
  205|      0|            for i in 0..self.elements.length() {
  206|      0|                if i > 0 {
  207|      0|                    write!(f, ", ")?;
  208|      0|                }
  209|      0|                write!(f, "{}", self.elements.nth(i))?;
  210|       |            }
  211|      0|            write!(f, "}}")
  212|      0|        }
  213|       |    }
  214|       |
  215|       |    #[macro_export]
  216|       |    macro_rules! AVLTreeSetStEphLit {
  217|       |        () => {
  218|       |            < $crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::AVLTreeSetStEph<_> as $crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::AVLTreeSetStEphTrait<_> >::empty()
  219|       |        };
  220|       |        ( $( $x:expr ),* $(,)? ) => {{
  221|       |            let mut __set = < $crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::AVLTreeSetStEph<_> as $crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::AVLTreeSetStEphTrait<_> >::empty();
  222|       |            $( __set.insert($x); )*
  223|       |            __set
  224|       |        }};
  225|       |    }
  226|       |
  227|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap41/AVLTreeSetStPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Single-threaded persistent set implementation using AVLTreeSeqStPer as backing store.
    3|       |
    4|       |pub mod AVLTreeSetStPer {
    5|       |
    6|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::*;
    7|       |    use crate::Types::Types::*;
    8|       |
    9|       |    #[derive(PartialEq, Eq, Debug)]
   10|       |    pub struct AVLTreeSetStPer<T: StT + Ord> {
   11|       |        elements: AVLTreeSeqStPerS<T>,
   12|       |    }
   13|       |
   14|       |    pub type AVLTreeSetPer<T> = AVLTreeSetStPer<T>;
   15|       |
   16|       |    pub trait AVLTreeSetStPerTrait<T: StT + Ord> {
   17|       |        /// claude-4-sonet: Work (1), Span (1)
   18|       |        fn size(&self) -> N;
   19|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   20|       |        fn to_seq(&self) -> AVLTreeSeqStPerS<T>;
   21|       |        /// claude-4-sonet: Work (1), Span (1)
   22|       |        fn empty() -> Self;
   23|       |        /// claude-4-sonet: Work (1), Span (1)
   24|       |        fn singleton(x: T) -> Self;
   25|       |        /// claude-4-sonet: Work (n log n), Span (n log n), Parallelism (1)
   26|       |        fn from_seq(seq: AVLTreeSeqStPerS<T>) -> Self;
   27|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   28|       |        fn filter<F: Fn(&T) -> B>(&self, f: F) -> Self;
   29|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   30|       |        fn intersection(&self, other: &Self) -> Self;
   31|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   32|       |        fn difference(&self, other: &Self) -> Self;
   33|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   34|       |        fn union(&self, other: &Self) -> Self;
   35|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   36|       |        fn find(&self, x: &T) -> B;
   37|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   38|       |        fn delete(&self, x: &T) -> Self;
   39|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   40|       |        fn insert(&self, x: T) -> Self;
   41|       |    }
   42|       |
   43|       |    impl<T: StT + Ord> AVLTreeSetStPerTrait<T> for AVLTreeSetStPer<T> {
   44|    253|        fn size(&self) -> N { self.elements.length() }
   45|       |
   46|    279|        fn to_seq(&self) -> AVLTreeSeqStPerS<T> {
   47|       |            // Create a new sequence from the elements
   48|    279|            let size = self.elements.length();
   49|    279|            let mut vec_elements = Vec::with_capacity(size);
   50|  1.09k|            for i in 0..size {
                                      ^279
   51|  1.09k|                vec_elements.push(self.elements.nth(i).clone());
   52|  1.09k|            }
   53|    279|            AVLTreeSeqStPerS::from_vec(vec_elements)
   54|    279|        }
   55|       |
   56|  2.75k|        fn empty() -> Self {
   57|  2.75k|            AVLTreeSetStPer {
   58|  2.75k|                elements: AVLTreeSeqStPerS::empty(),
   59|  2.75k|            }
   60|  2.75k|        }
   61|       |
   62|  1.84k|        fn singleton(x: T) -> Self {
   63|  1.84k|            AVLTreeSetStPer {
   64|  1.84k|                elements: AVLTreeSeqStPerS::singleton(x),
   65|  1.84k|            }
   66|  1.84k|        }
   67|       |
   68|    588|        fn from_seq(seq: AVLTreeSeqStPerS<T>) -> Self {
   69|       |            // Example 41.3: fromSeq a = Seq.reduce Set.union  {x} : x  a
   70|       |            // Work efficient and parallel implementation
   71|    588|            if seq.length() == 0 {
   72|      2|                return Self::empty();
   73|    586|            }
   74|       |
   75|       |            // Create sequence of singleton sets {x} : x  a
   76|    586|            let seq_len = seq.length();
   77|    586|            let mut singleton_sets = Vec::with_capacity(seq_len);
   78|  1.66k|            for i in 0..seq_len {
                                      ^586
   79|  1.66k|                let elem = seq.nth(i).clone();
   80|  1.66k|                singleton_sets.push(Self::singleton(elem));
   81|  1.66k|            }
   82|       |
   83|       |            // Reduce with union operation
   84|    586|            let mut result = Self::empty();
   85|  2.25k|            for set in singleton_sets {
                              ^1.66k
   86|  1.66k|                result = result.union(&set);
   87|  1.66k|            }
   88|    586|            result
   89|    588|        }
   90|       |
   91|      7|        fn filter<F: Fn(&T) -> B>(&self, f: F) -> Self {
   92|      7|            let mut result = Self::empty();
   93|     24|            for i in 0..self.elements.length() {
                                      ^7            ^7
   94|     24|                let elem = self.elements.nth(i);
   95|     24|                if f(elem) {
   96|     12|                    result = result.insert(elem.clone());
   97|     12|                }
   98|       |            }
   99|      7|            result
  100|      7|        }
  101|       |
  102|     16|        fn intersection(&self, other: &Self) -> Self {
  103|     16|            let mut result = Self::empty();
  104|     38|            for i in 0..self.elements.length() {
                                      ^16           ^16
  105|     38|                let elem = self.elements.nth(i);
  106|     38|                if other.find(elem) {
  107|     21|                    result = result.insert(elem.clone());
  108|     21|                }
                              ^17
  109|       |            }
  110|     16|            result
  111|     16|        }
  112|       |
  113|     56|        fn difference(&self, other: &Self) -> Self {
  114|     56|            let mut result = Self::empty();
  115|     77|            for i in 0..self.elements.length() {
                                      ^56           ^56
  116|     77|                let elem = self.elements.nth(i);
  117|     77|                if !other.find(elem) {
  118|     43|                    result = result.insert(elem.clone());
  119|     43|                }
                              ^34
  120|       |            }
  121|     56|            result
  122|     56|        }
  123|       |
  124|  1.83k|        fn union(&self, other: &Self) -> Self {
  125|  1.83k|            let mut result = Self::empty();
  126|       |            // Add all elements from self
  127|  35.4k|            for i in 0..self.elements.length() {
                                      ^1.83k        ^1.83k
  128|  35.4k|                let elem = self.elements.nth(i);
  129|  35.4k|                result = result.insert(elem.clone());
  130|  35.4k|            }
  131|       |            // Add all elements from other
  132|  1.85k|            for i in 0..other.elements.length() {
                                      ^1.83k         ^1.83k
  133|  1.85k|                let elem = other.elements.nth(i);
  134|  1.85k|                result = result.insert(elem.clone());
  135|  1.85k|            }
  136|  1.83k|            result
  137|  1.83k|        }
  138|       |
  139|  38.2k|        fn find(&self, x: &T) -> B {
  140|  1.16M|            for i in 0..self.elements.length() {
                                      ^38.2k        ^38.2k
  141|  1.16M|                if self.elements.nth(i) == x {
  142|    291|                    return true;
  143|  1.16M|                }
  144|       |            }
  145|  37.9k|            false
  146|  38.2k|        }
  147|       |
  148|     22|        fn delete(&self, x: &T) -> Self {
  149|     22|            let mut result = Self::empty();
  150|     41|            for i in 0..self.elements.length() {
                                      ^22           ^22
  151|     41|                let elem = self.elements.nth(i);
  152|     41|                if elem != x {
  153|     21|                    result = result.insert(elem.clone());
  154|     21|                }
                              ^20
  155|       |            }
  156|     22|            result
  157|     22|        }
  158|       |
  159|  37.6k|        fn insert(&self, x: T) -> Self {
  160|  37.6k|            if self.find(&x) {
  161|       |                // Element already exists, return unchanged
  162|     26|                let size = self.elements.length();
  163|     26|                let mut vec_elements = Vec::with_capacity(size);
  164|     65|                for i in 0..size {
                                          ^26
  165|     65|                    vec_elements.push(self.elements.nth(i).clone());
  166|     65|                }
  167|     26|                AVLTreeSetStPer {
  168|     26|                    elements: AVLTreeSeqStPerS::from_vec(vec_elements),
  169|     26|                }
  170|       |            } else {
  171|  37.6k|                let size = self.elements.length();
  172|  37.6k|                let mut vec_elements = Vec::with_capacity(size + 1);
  173|  1.16M|                for i in 0..size {
                                          ^37.6k
  174|  1.16M|                    vec_elements.push(self.elements.nth(i).clone());
  175|  1.16M|                }
  176|  37.6k|                vec_elements.push(x);
  177|  37.6k|                vec_elements.sort();
  178|  37.6k|                AVLTreeSetStPer {
  179|  37.6k|                    elements: AVLTreeSeqStPerS::from_vec(vec_elements),
  180|  37.6k|                }
  181|       |            }
  182|  37.6k|        }
  183|       |    }
  184|       |
  185|       |    impl<T: StT + Ord> Default for AVLTreeSetStPer<T> {
  186|      0|        fn default() -> Self { Self::empty() }
  187|       |    }
  188|       |
  189|       |    impl<T: StT + Ord> Clone for AVLTreeSetStPer<T> {
  190|  5.80k|        fn clone(&self) -> Self {
  191|  5.80k|            AVLTreeSetStPer {
  192|  5.80k|                elements: self.elements.clone(),
  193|  5.80k|            }
  194|  5.80k|        }
  195|       |    }
  196|       |
  197|       |    impl<T: StT + Ord> std::fmt::Display for AVLTreeSetStPer<T> {
  198|      0|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  199|      0|            write!(
  200|      0|                f,
  201|      0|                "{{{}}}",
  202|      0|                (0..self.size())
  203|      0|                    .map(|i| format!("{}", self.elements.nth(i)))
  204|      0|                    .collect::<Vec<_>>()
  205|      0|                    .join(", ")
  206|       |            )
  207|      0|        }
  208|       |    }
  209|       |
  210|       |    #[macro_export]
  211|       |    macro_rules! AVLTreeSetStPerLit {
  212|       |        () => {
  213|       |            < $crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::AVLTreeSetStPer<_> as $crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::AVLTreeSetStPerTrait<_> >::empty()
  214|       |        };
  215|       |        ( $( $x:expr ),* $(,)? ) => {{
  216|       |            let mut __set = < $crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::AVLTreeSetStPer<_> as $crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::AVLTreeSetStPerTrait<_> >::empty();
  217|       |            $( __set = __set.insert($x); )*
  218|       |            __set
  219|       |        }};
  220|       |    }
  221|       |
  222|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap41/ArraySetEnumMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Multi-threaded ephemeral enumerated set using bit array.
    3|       |//!
    4|       |//! Uses `bitvec::BitBox` for true 1-bit-per-element storage (vs 1-byte-per-element in `Vec<bool>`).
    5|       |//! Memory: universe_size / 64  8 bytes. Only filter() uses parallelism.
    6|       |
    7|       |pub mod ArraySetEnumMtEph {
    8|       |
    9|       |    use std::sync::Arc;
   10|       |    use std::thread;
   11|       |
   12|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::ArraySeqMtEphS;
   13|       |    use crate::Types::Types::*;
   14|       |    use bitvec::prelude::*;
   15|       |
   16|       |    #[derive(PartialEq, Clone)]
   17|       |    pub struct ArraySetEnumMtEph {
   18|       |        bits: BitBox,     // 1 bit per element
   19|       |        universe_size: N, // elements are 0..universe_size-1
   20|       |    }
   21|       |
   22|       |    pub trait ArraySetEnumMtEphTrait {
   23|       |        /// claude-4-sonet: Work (u), Span (1)
   24|       |        fn new(u: N) -> Self;
   25|       |        /// claude-4-sonet: Work (u/w) where w is word size, Span (u/w)
   26|       |        fn size(&self) -> N;
   27|       |        /// claude-4-sonet: Work (|set|), Span (|set|)
   28|       |        fn to_seq(&self) -> ArraySeqMtEphS<N>;
   29|       |        /// claude-4-sonet: Work (u), Span (1)
   30|       |        fn empty(u: N) -> Self;
   31|       |        /// claude-4-sonet: Work (u), Span (1)
   32|       |        fn singleton(u: N, x: N) -> Self;
   33|       |        /// claude-4-sonet: Work (u + |seq|), Span (1)
   34|       |        fn from_seq(u: N, seq: ArraySeqMtEphS<N>) -> Self;
   35|       |        /// claude-4-sonet: Work (u), Span (log u), Parallelism (u/log u)
   36|       |        fn filter<F: PredVal<N> + Clone>(&self, f: F) -> Self;
   37|       |        /// claude-4-sonet: Work (u/w), Span (u/w)
   38|       |        fn intersection(&self, other: &Self) -> Self;
   39|       |        /// claude-4-sonet: Work (u/w), Span (u/w)
   40|       |        fn difference(&self, other: &Self) -> Self;
   41|       |        /// claude-4-sonet: Work (u/w), Span (u/w)
   42|       |        fn union(&self, other: &Self) -> Self;
   43|       |        /// claude-4-sonet: Work (1), Span (1)
   44|       |        fn find(&self, x: N) -> B;
   45|       |        /// claude-4-sonet: Work (1), Span (1)
   46|       |        fn delete(&mut self, x: N);
   47|       |        /// claude-4-sonet: Work (1), Span (1)
   48|       |        fn insert(&mut self, x: N);
   49|       |    }
   50|       |
   51|       |    impl ArraySetEnumMtEphTrait for ArraySetEnumMtEph {
   52|     14|        fn new(u: N) -> Self {
   53|     14|            ArraySetEnumMtEph {
   54|     14|                bits: bitbox![0; u],
   55|     14|                universe_size: u,
   56|     14|            }
   57|     14|        }
   58|       |
   59|     19|        fn size(&self) -> N {
   60|     19|            self.bits.count_ones() // popcount
   61|     19|        }
   62|       |
   63|      1|        fn to_seq(&self) -> ArraySeqMtEphS<N> {
   64|      1|            let set_size = self.size();
   65|      1|            let mut result = Vec::with_capacity(set_size);
   66|     10|            for (i, bit) in self.bits.iter().enumerate() {
                                          ^1               ^1
   67|     10|                if *bit {
   68|      4|                    result.push(i);
   69|      6|                }
   70|       |            }
   71|      1|            ArraySeqMtEphS::from_vec(result)
   72|      1|        }
   73|       |
   74|     12|        fn empty(u: N) -> Self { Self::new(u) }
   75|       |
   76|      1|        fn singleton(u: N, x: N) -> Self {
   77|      1|            let mut bits = bitbox![0; u];
   78|      1|            if x < u {
   79|      1|                bits.set(x, true);
   80|      1|            }
                          ^0
   81|      1|            ArraySetEnumMtEph { bits, universe_size: u }
   82|      1|        }
   83|       |
   84|      2|        fn from_seq(u: N, seq: ArraySeqMtEphS<N>) -> Self {
   85|      2|            let mut bits = bitbox![0; u];
   86|     11|            for i in 0..seq.length() {
                                      ^2  ^2
   87|     11|                let elem = seq.nth_cloned(i);
   88|     11|                if elem < u {
   89|     11|                    bits.set(elem, true);
   90|     11|                }
                              ^0
   91|       |            }
   92|      2|            ArraySetEnumMtEph { bits, universe_size: u }
   93|      2|        }
   94|       |
   95|      1|        fn filter<F: PredVal<N> + Clone>(&self, f: F) -> Self {
   96|       |            // Parallel filter: spawn thread per element (as if f is expensive)
   97|      1|            let f = Arc::new(f);
   98|      1|            let mut new_bits = bitbox![0; self.universe_size];
   99|       |
  100|       |            // Process each element directly without intermediate collection
  101|     10|            for i in 0..self.universe_size {
                                      ^1
  102|     10|                if self.bits[i] {
  103|      6|                    let f_clone = Arc::clone(&f);
  104|      6|                    let handle = thread::spawn(move || (i, f_clone(i)));
  105|      6|                    let (elem_i, keep) = handle.join().unwrap();
  106|      6|                    if keep {
  107|      3|                        new_bits.set(elem_i, true);
  108|      3|                    }
  109|      4|                }
  110|       |            }
  111|       |
  112|      1|            ArraySetEnumMtEph {
  113|      1|                bits: new_bits,
  114|      1|                universe_size: self.universe_size,
  115|      1|            }
  116|      1|        }
  117|       |
  118|      1|        fn intersection(&self, other: &Self) -> Self {
  119|      1|            assert_eq!(self.universe_size, other.universe_size, "Universe sizes must match");
                                                                              ^0
  120|      1|            let mut result_bits = bitbox![0; self.universe_size];
  121|     10|            for i in 0..self.universe_size {
                                      ^1
  122|     10|                result_bits.set(i, self.bits[i] && other.bits[i]);
                                                                 ^3
  123|       |            }
  124|      1|            ArraySetEnumMtEph {
  125|      1|                bits: result_bits,
  126|      1|                universe_size: self.universe_size,
  127|      1|            }
  128|      1|        }
  129|       |
  130|      1|        fn difference(&self, other: &Self) -> Self {
  131|      1|            assert_eq!(self.universe_size, other.universe_size, "Universe sizes must match");
                                                                              ^0
  132|      1|            let mut result_bits = bitbox![0; self.universe_size];
  133|     10|            for i in 0..self.universe_size {
                                      ^1
  134|     10|                result_bits.set(i, self.bits[i] && !other.bits[i]);
                                                                 ^3
  135|       |            }
  136|      1|            ArraySetEnumMtEph {
  137|      1|                bits: result_bits,
  138|      1|                universe_size: self.universe_size,
  139|      1|            }
  140|      1|        }
  141|       |
  142|      1|        fn union(&self, other: &Self) -> Self {
  143|      1|            assert_eq!(self.universe_size, other.universe_size, "Universe sizes must match");
                                                                              ^0
  144|      1|            let mut result_bits = bitbox![0; self.universe_size];
  145|     10|            for i in 0..self.universe_size {
                                      ^1
  146|     10|                result_bits.set(i, self.bits[i] || other.bits[i]);
                                                                 ^7
  147|       |            }
  148|      1|            ArraySetEnumMtEph {
  149|      1|                bits: result_bits,
  150|      1|                universe_size: self.universe_size,
  151|      1|            }
  152|      1|        }
  153|       |
  154|     70|        fn find(&self, x: N) -> B { if x < self.universe_size { self.bits[x] } else { false } }
                                                                              ^65                   ^5
  155|       |
  156|      1|        fn delete(&mut self, x: N) {
  157|      1|            if x < self.universe_size {
  158|      1|                self.bits.set(x, false);
  159|      1|            }
                          ^0
  160|      1|        }
  161|       |
  162|     36|        fn insert(&mut self, x: N) {
  163|     36|            if x < self.universe_size {
  164|     33|                self.bits.set(x, true);
  165|     33|            }
                          ^3
  166|     36|        }
  167|       |    }
  168|       |
  169|       |    // Macro for creating ArraySetEnumMtEph literals
  170|       |    #[macro_export]
  171|       |    macro_rules! ArraySetEnumMtEphLit {
  172|       |        ( $u:expr ; ) => {{
  173|       |            < $crate::Chap41::ArraySetEnumMtEph::ArraySetEnumMtEph::ArraySetEnumMtEph as $crate::Chap41::ArraySetEnumMtEph::ArraySetEnumMtEph::ArraySetEnumMtEphTrait >::empty($u)
  174|       |        }};
  175|       |        ( $u:expr ; $( $x:expr ),* $(,)? ) => {{
  176|       |            let mut __set = < $crate::Chap41::ArraySetEnumMtEph::ArraySetEnumMtEph::ArraySetEnumMtEph as $crate::Chap41::ArraySetEnumMtEph::ArraySetEnumMtEph::ArraySetEnumMtEphTrait >::empty($u);
  177|       |            $( __set.insert($x); )*
  178|       |            __set
  179|       |        }};
  180|       |    }
  181|       |
  182|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap41/ArraySetStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Single-threaded ephemeral set implementation using ArraySeqStEph as backing store.
    3|       |
    4|       |pub mod ArraySetStEph {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
    7|       |    use crate::Types::Types::*;
    8|       |
    9|       |    #[derive(Debug, Clone, PartialEq)]
   10|       |    pub struct ArraySetStEph<T: StT + Ord> {
   11|       |        elements: ArraySeqStEphS<T>,
   12|       |    }
   13|       |
   14|       |    pub type ArraySetS<T> = ArraySetStEph<T>;
   15|       |
   16|       |    pub trait ArraySetStEphTrait<T: StT + Ord> {
   17|       |        /// claude-4-sonet: Work (1), Span (1)
   18|       |        fn size(&self) -> N;
   19|       |        /// claude-4-sonet: Work (1), Span (1)
   20|       |        fn to_seq(&self) -> ArraySeqStEphS<T>;
   21|       |        /// claude-4-sonet: Work (1), Span (1)
   22|       |        fn empty() -> Self;
   23|       |        /// claude-4-sonet: Work (1), Span (1)
   24|       |        fn singleton(x: T) -> Self;
   25|       |        /// claude-4-sonet: Work (n log n), Span (n log n), Parallelism (1)
   26|       |        fn from_seq(seq: ArraySeqStEphS<T>) -> Self;
   27|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   28|       |        fn filter<F: Fn(&T) -> B>(&self, f: F) -> Self;
   29|       |        /// claude-4-sonet: Work (m + n), Span (m + n), Parallelism (1)
   30|       |        fn intersection(&self, other: &Self) -> Self;
   31|       |        /// claude-4-sonet: Work (m + n), Span (m + n), Parallelism (1)
   32|       |        fn difference(&self, other: &Self) -> Self;
   33|       |        /// claude-4-sonet: Work (m + n), Span (m + n), Parallelism (1)
   34|       |        fn union(&self, other: &Self) -> Self;
   35|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   36|       |        fn find(&self, x: &T) -> B;
   37|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   38|       |        fn delete(&mut self, x: &T);
   39|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   40|       |        fn insert(&mut self, x: T);
   41|       |    }
   42|       |
   43|       |    impl<T: StT + Ord> ArraySetStEphTrait<T> for ArraySetStEph<T> {
   44|     71|        fn size(&self) -> N { self.elements.length() }
   45|       |
   46|     54|        fn to_seq(&self) -> ArraySeqStEphS<T> { self.elements.clone() }
   47|       |
   48|    117|        fn empty() -> Self {
   49|    117|            ArraySetStEph {
   50|    117|                elements: ArraySeqStEphS::empty(),
   51|    117|            }
   52|    117|        }
   53|       |
   54|    112|        fn singleton(x: T) -> Self {
   55|    112|            ArraySetStEph {
   56|    112|                elements: ArraySeqStEphS::singleton(x),
   57|    112|            }
   58|    112|        }
   59|       |
   60|     34|        fn from_seq(seq: ArraySeqStEphS<T>) -> Self {
   61|       |            // Example 41.3: fromSeq a = Seq.reduce Set.union  {x} : x  a
   62|       |            // Work efficient and parallel implementation
   63|     34|            if seq.length() == 0 {
   64|      6|                return Self::empty();
   65|     28|            }
   66|       |
   67|       |            // Reduce with union operation directly from seq
   68|     28|            let mut result = Self::empty();
   69|    103|            for i in 0..seq.length() {
                                      ^28 ^28
   70|    103|                let elem = seq.nth(i).clone();
   71|    103|                let singleton_set = Self::singleton(elem);
   72|    103|                result = result.union(&singleton_set);
   73|    103|            }
   74|     28|            result
   75|     34|        }
   76|       |
   77|      3|        fn filter<F: Fn(&T) -> B>(&self, f: F) -> Self {
   78|      3|            let filtered = ArraySeqStEphS::filter(&self.elements, &f);
   79|      3|            ArraySetStEph { elements: filtered }
   80|      3|        }
   81|       |
   82|      3|        fn intersection(&self, other: &Self) -> Self {
   83|     13|            let filtered = ArraySeqStEphS::filter(&self.elements, &|elem| other.find(elem));
                              ^3         ^3                     ^3
   84|      3|            ArraySetStEph { elements: filtered }
   85|      3|        }
   86|       |
   87|      3|        fn difference(&self, other: &Self) -> Self {
   88|     13|            let filtered = ArraySeqStEphS::filter(&self.elements, &|elem| !other.find(elem));
                              ^3         ^3                     ^3
   89|      3|            ArraySetStEph { elements: filtered }
   90|      3|        }
   91|       |
   92|    118|        fn union(&self, other: &Self) -> Self {
   93|    118|            let self_len = self.elements.length();
   94|    118|            let other_len = other.elements.length();
   95|    118|            let mut result = Vec::with_capacity(self_len + other_len);
   96|       |
   97|       |            // Add all elements from self
   98|    218|            for i in 0..self_len {
                                      ^118
   99|    218|                result.push(self.elements.nth(i).clone());
  100|    218|            }
  101|       |
  102|       |            // Add elements from other that are not in self
  103|    128|            for i in 0..other_len {
                                      ^118
  104|    128|                let elem = other.elements.nth(i);
  105|    128|                if !self.find(elem) {
  106|    104|                    result.push(elem.clone());
  107|    104|                }
                              ^24
  108|       |            }
  109|       |
  110|    118|            result.sort();
  111|    118|            ArraySetStEph {
  112|    118|                elements: ArraySeqStEphS::from_vec(result),
  113|    118|            }
  114|    118|        }
  115|       |
  116|    724|        fn find(&self, x: &T) -> B {
  117|  1.71k|            for i in 0..self.elements.length() {
                                      ^724          ^724
  118|  1.71k|                if self.elements.nth(i) == x {
  119|    223|                    return true;
  120|  1.49k|                }
  121|       |            }
  122|    501|            false
  123|    724|        }
  124|       |
  125|      3|        fn delete(&mut self, x: &T) {
  126|     12|            let filtered = ArraySeqStEphS::filter(&self.elements, &|elem| elem != x);
                              ^3         ^3                     ^3
  127|      3|            self.elements = filtered;
  128|      3|        }
  129|       |
  130|    275|        fn insert(&mut self, x: T) {
  131|    275|            if !self.find(&x) {
  132|       |                // Element doesn't exist, add it
  133|    271|                let new_len = self.elements.length() + 1;
  134|    271|                let mut temp_vec = Vec::with_capacity(new_len);
  135|    599|                for i in 0..self.elements.length() {
                                          ^271          ^271
  136|    599|                    temp_vec.push(self.elements.nth(i).clone());
  137|    599|                }
  138|    271|                temp_vec.push(x);
  139|    271|                temp_vec.sort();
  140|    271|                self.elements = ArraySeqStEphS::from_vec(temp_vec);
  141|      4|            }
  142|    275|        }
  143|       |    }
  144|       |
  145|       |    impl<T: StT + Ord> Default for ArraySetStEph<T> {
  146|      0|        fn default() -> Self { Self::empty() }
  147|       |    }
  148|       |
  149|       |    #[macro_export]
  150|       |    macro_rules! ArraySetStEphLit {
  151|       |        () => {
  152|       |            < $crate::Chap41::ArraySetStEph::ArraySetStEph::ArraySetStEph<_> as $crate::Chap41::ArraySetStEph::ArraySetStEph::ArraySetStEphTrait<_> >::empty()
  153|       |        };
  154|       |        ( $( $x:expr ),* $(,)? ) => {{
  155|       |            let mut __set = < $crate::Chap41::ArraySetStEph::ArraySetStEph::ArraySetStEph<_> as $crate::Chap41::ArraySetStEph::ArraySetStEph::ArraySetStEphTrait<_> >::empty();
  156|       |            $( __set.insert($x); )*
  157|       |            __set
  158|       |        }};
  159|       |    }
  160|       |
  161|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap41/Example41_3.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Example 41.3: Demonstrating set operations from Example 41.1
    3|       |
    4|       |pub mod Example41_3 {
    5|       |
    6|       |    use crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::AVLTreeSeqStEphTrait;
    7|       |    use crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::*;
    8|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::*;
    9|       |    use crate::Types::Types::*;
   10|       |    use crate::*;
   11|       |
   12|       |    pub trait Example41_3Trait {
   13|       |        /// Example 41.1 cases using ArraySetStEph
   14|       |        /// APAS: Work (n log n), Span (log n)
   15|       |        fn example_41_1_array_set();
   16|       |
   17|       |        /// Example 41.1 cases using AVLTreeSetStEph
   18|       |        /// APAS: Work (n log n), Span (log n)
   19|       |        fn example_41_1_avl_set();
   20|       |
   21|       |        /// Demonstrate set operations with different implementations
   22|       |        /// APAS: Work (n log n), Span (log n)
   23|       |        fn demonstrate_set_operations();
   24|       |    }
   25|       |
   26|      2|    pub fn example_41_1_array_set() {
   27|       |        // Example 41.1 cases using ArraySetStEph
   28|       |
   29|       |        // |{a, b, c}| = 3
   30|      2|        let set_abc = ArraySetStEphLit!['a', 'b', 'c'];
   31|      2|        assert_eq!(set_abc.size(), 3);
   32|       |
   33|       |        // {x  {4, 11, 2, 6} | x < 7} = {4, 2, 6}
   34|      2|        let set_nums = ArraySetStEphLit![4, 11, 2, 6];
   35|      8|        let filtered = set_nums.filter(|&x| x < 7);
                          ^2         ^2       ^2
   36|      2|        assert_eq!(filtered.size(), 3);
   37|      2|        assert!(filtered.find(&4));
   38|      2|        assert!(filtered.find(&2));
   39|      2|        assert!(filtered.find(&6));
   40|      2|        assert!(!filtered.find(&11));
   41|       |
   42|       |        // find {6, 2, 9, 11, 8} 4 = false
   43|      2|        let set_search = ArraySetStEphLit![6, 2, 9, 11, 8];
   44|      2|        assert_eq!(set_search.find(&4), false);
   45|      2|        assert_eq!(set_search.find(&6), true);
   46|       |
   47|       |        // {2, 7, 8, 11}  {7, 9, 11, 14, 17} = {2, 7, 8, 9, 11, 14, 17}
   48|      2|        let set1 = ArraySetStEphLit![2, 7, 8, 11];
   49|      2|        let set2 = ArraySetStEphLit![7, 9, 11, 14, 17];
   50|      2|        let union_result = set1.union(&set2);
   51|      2|        assert_eq!(union_result.size(), 7);
   52|      2|        assert!(union_result.find(&2));
   53|      2|        assert!(union_result.find(&7));
   54|      2|        assert!(union_result.find(&8));
   55|      2|        assert!(union_result.find(&9));
   56|      2|        assert!(union_result.find(&11));
   57|      2|        assert!(union_result.find(&14));
   58|      2|        assert!(union_result.find(&17));
   59|       |
   60|       |        // toSeq {2, 7, 8, 11} = 8, 11, 2, 7 (order may vary)
   61|      2|        let set_to_seq = ArraySetStEphLit![2, 7, 8, 11];
   62|      2|        let seq_result = set_to_seq.to_seq();
   63|      2|        assert_eq!(seq_result.length(), 4);
   64|       |
   65|       |        // Example 41.3: fromSeq a = Seq.reduce Set.union  {x} : x  a
   66|       |        // fromSeq 2, 7, 2, 8, 11, 2 = {8, 2, 11, 7}
   67|      2|        let seq_with_dups = ArraySeqStEphSLit![2, 7, 2, 8, 11, 2];
   68|      2|        let set_from_seq = ArraySetStEph::from_seq(seq_with_dups);
   69|      2|        assert_eq!(set_from_seq.size(), 4);
   70|      2|        assert!(set_from_seq.find(&2));
   71|      2|        assert!(set_from_seq.find(&7));
   72|      2|        assert!(set_from_seq.find(&8));
   73|      2|        assert!(set_from_seq.find(&11));
   74|      2|    }
   75|       |
   76|      2|    pub fn example_41_1_avl_set() {
   77|       |        // Example 41.1 cases using AVLTreeSetStEph
   78|       |
   79|       |        // |{a, b, c}| = 3
   80|      2|        let set_abc = AVLTreeSetStEphLit!['a', 'b', 'c'];
   81|      2|        assert_eq!(set_abc.size(), 3);
   82|       |
   83|       |        // {x  {4, 11, 2, 6} | x < 7} = {4, 2, 6}
   84|      2|        let set_nums = AVLTreeSetStEphLit![4, 11, 2, 6];
   85|      8|        let filtered = set_nums.filter(|&x| x < 7);
                          ^2         ^2       ^2
   86|      2|        assert_eq!(filtered.size(), 3);
   87|      2|        assert!(filtered.find(&4));
   88|      2|        assert!(filtered.find(&2));
   89|      2|        assert!(filtered.find(&6));
   90|      2|        assert!(!filtered.find(&11));
   91|       |
   92|       |        // find {6, 2, 9, 11, 8} 4 = false
   93|      2|        let set_search = AVLTreeSetStEphLit![6, 2, 9, 11, 8];
   94|      2|        assert_eq!(set_search.find(&4), false);
   95|      2|        assert_eq!(set_search.find(&6), true);
   96|       |
   97|       |        // {2, 7, 8, 11}  {7, 9, 11, 14, 17} = {2, 7, 8, 9, 11, 14, 17}
   98|      2|        let set1 = AVLTreeSetStEphLit![2, 7, 8, 11];
   99|      2|        let set2 = AVLTreeSetStEphLit![7, 9, 11, 14, 17];
  100|      2|        let union_result = set1.union(&set2);
  101|      2|        assert_eq!(union_result.size(), 7);
  102|      2|        assert!(union_result.find(&2));
  103|      2|        assert!(union_result.find(&7));
  104|      2|        assert!(union_result.find(&8));
  105|      2|        assert!(union_result.find(&9));
  106|      2|        assert!(union_result.find(&11));
  107|      2|        assert!(union_result.find(&14));
  108|      2|        assert!(union_result.find(&17));
  109|       |
  110|       |        // toSeq {2, 7, 8, 11} = 8, 11, 2, 7 (order may vary)
  111|      2|        let set_to_seq = AVLTreeSetStEphLit![2, 7, 8, 11];
  112|      2|        let seq_result = set_to_seq.to_seq();
  113|      2|        assert_eq!(seq_result.length(), 4);
  114|       |
  115|       |        // Example 41.3: fromSeq a = Seq.reduce Set.union  {x} : x  a
  116|       |        // fromSeq 2, 7, 2, 8, 11, 2 = {8, 2, 11, 7}
  117|      2|        let seq_with_dups = AVLTreeSeqStEphLit![2, 7, 2, 8, 11, 2];
  118|      2|        let set_from_seq = AVLTreeSetStEph::from_seq(seq_with_dups);
  119|      2|        assert_eq!(set_from_seq.size(), 4);
  120|      2|        assert!(set_from_seq.find(&2));
  121|      2|        assert!(set_from_seq.find(&7));
  122|      2|        assert!(set_from_seq.find(&8));
  123|      2|        assert!(set_from_seq.find(&11));
  124|      2|    }
  125|       |
  126|      2|    pub fn example_41_3_from_seq_demonstration() {
  127|       |        // Example 41.3: Two implementations of fromSeq
  128|       |
  129|       |        // Sequential version: fromseq a = Seq.iterate Set.insert  a
  130|       |        // (This would be implemented as a simple loop with insert)
  131|       |
  132|       |        // Parallel version: fromSeq a = Seq.reduce Set.union  {x} : x  a
  133|       |        // This is what our implementation uses
  134|       |
  135|      2|        let seq = ArraySeqStEphSLit![1, 3, 2, 3, 1, 4, 2];
  136|      2|        let set_result = ArraySetStEph::from_seq(seq);
  137|       |
  138|       |        // Should contain unique elements: {1, 2, 3, 4}
  139|      2|        assert_eq!(set_result.size(), 4);
  140|      2|        assert!(set_result.find(&1));
  141|      2|        assert!(set_result.find(&2));
  142|      2|        assert!(set_result.find(&3));
  143|      2|        assert!(set_result.find(&4));
  144|       |
  145|       |        // Demonstrate the conceptual steps:
  146|       |        // 1. Create singleton sets: {1}, {3}, {2}, {3}, {1}, {4}, {2}
  147|       |        // 2. Reduce with union: {1}  {3}  {2}  {3}  {1}  {4}  {2} = {1, 2, 3, 4}
  148|       |
  149|      2|        let singleton1 = ArraySetStEph::singleton(1);
  150|      2|        let singleton3 = ArraySetStEph::singleton(3);
  151|      2|        let singleton2 = ArraySetStEph::singleton(2);
  152|      2|        let singleton4 = ArraySetStEph::singleton(4);
  153|       |
  154|      2|        let manual_union = singleton1
  155|      2|            .union(&singleton3)
  156|      2|            .union(&singleton2)
  157|      2|            .union(&singleton3) // duplicate, should not change result
  158|      2|            .union(&singleton1) // duplicate, should not change result
  159|      2|            .union(&singleton4)
  160|      2|            .union(&singleton2); // duplicate, should not change result
  161|       |
  162|      2|        assert_eq!(manual_union.size(), 4);
  163|      2|        assert!(manual_union.find(&1));
  164|      2|        assert!(manual_union.find(&2));
  165|      2|        assert!(manual_union.find(&3));
  166|      2|        assert!(manual_union.find(&4));
  167|       |
  168|       |        // Both approaches should yield the same result
  169|      2|        assert_eq!(set_result.size(), manual_union.size());
  170|      2|    }
  171|       |
  172|      2|    pub fn additional_set_operations() {
  173|       |        // Additional set operations testing
  174|      2|        let set1 = ArraySetStEphLit![1, 2, 3, 4, 5];
  175|      2|        let set2 = ArraySetStEphLit![4, 5, 6, 7, 8];
  176|       |
  177|       |        // Intersection: {1, 2, 3, 4, 5}  {4, 5, 6, 7, 8} = {4, 5}
  178|      2|        let intersection = set1.intersection(&set2);
  179|      2|        assert_eq!(intersection.size(), 2);
  180|      2|        assert!(intersection.find(&4));
  181|      2|        assert!(intersection.find(&5));
  182|      2|        assert!(!intersection.find(&1));
  183|      2|        assert!(!intersection.find(&6));
  184|       |
  185|       |        // Difference: {1, 2, 3, 4, 5} \ {4, 5, 6, 7, 8} = {1, 2, 3}
  186|      2|        let difference = set1.difference(&set2);
  187|      2|        assert_eq!(difference.size(), 3);
  188|      2|        assert!(difference.find(&1));
  189|      2|        assert!(difference.find(&2));
  190|      2|        assert!(difference.find(&3));
  191|      2|        assert!(!difference.find(&4));
  192|      2|        assert!(!difference.find(&5));
  193|       |
  194|       |        // Delete operation
  195|      2|        let mut set_delete = ArraySetStEphLit![1, 2, 3, 4, 5];
  196|      2|        set_delete.delete(&3);
  197|      2|        assert_eq!(set_delete.size(), 4);
  198|      2|        assert!(!set_delete.find(&3));
  199|      2|        assert!(set_delete.find(&1));
  200|      2|        assert!(set_delete.find(&2));
  201|      2|        assert!(set_delete.find(&4));
  202|      2|        assert!(set_delete.find(&5));
  203|       |
  204|       |        // Insert operation
  205|      2|        let mut set_insert = ArraySetStEphLit![1, 2, 4, 5];
  206|      2|        set_insert.insert(3);
  207|      2|        assert_eq!(set_insert.size(), 5);
  208|      2|        assert!(set_insert.find(&3));
  209|       |
  210|       |        // Insert duplicate (should not change size)
  211|      2|        set_insert.insert(3);
  212|      2|        assert_eq!(set_insert.size(), 5);
  213|      2|    }
  214|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap42/Example42_1.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 42 Example 42.1 demonstrating table operations.
    3|       |
    4|       |pub mod Example42_1 {
    5|       |
    6|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::*;
    7|       |    use crate::Chap42::TableMtEph::TableMtEph::*;
    8|       |    use crate::Chap42::TableStEph::TableStEph::*;
    9|       |    use crate::Chap42::TableStPer::TableStPer::*;
   10|       |    use crate::Types::Types::*;
   11|       |    use crate::*;
   12|       |
   13|       |    pub trait Example42_1Trait {
   14|       |        /// Example 42.1: Basic table operations demonstration
   15|       |        /// APAS: Work (n log n), Span (log n)
   16|       |        fn example_42_1();
   17|       |
   18|       |        /// Demonstrate table operations with different implementations
   19|       |        /// APAS: Work (n log n), Span (log n)
   20|       |        fn demonstrate_table_operations();
   21|       |    }
   22|       |
   23|       |    /// Example 42.1: Basic table operations demonstration
   24|      1|    pub fn example_42_1() {
   25|      1|        println!("=== Chapter 42 Example 42.1: Table Operations ===");
   26|       |
   27|       |        // Create tables using different implementations
   28|      1|        let table_per = TableStPerLit![1 => "Alice".to_string(), 2 => "Bob".to_string(), 3 => "Carol".to_string()];
   29|      1|        let mut table_eph = TableStEphLit![1 => "Alice".to_string(), 2 => "Bob".to_string(), 3 => "Carol".to_string()];
   30|      1|        let mut table_mt = TableMtEphLit![1 => "Alice".to_string(), 2 => "Bob".to_string(), 3 => "Carol".to_string()];
   31|       |
   32|      1|        println!("Initial tables created with 3 entries each");
   33|      1|        println!("Persistent table size: {}", table_per.size());
   34|      1|        println!("Ephemeral table size: {}", table_eph.size());
   35|      1|        println!("Multi-threaded table size: {}", table_mt.size());
   36|       |
   37|       |        // Demonstrate find operation
   38|      1|        println!("\n--- Find Operations ---");
   39|      1|        println!("Find key 2 in persistent table: {:?}", table_per.find(&2));
   40|      1|        println!("Find key 4 in persistent table: {:?}", table_per.find(&4));
   41|       |
   42|       |        // Demonstrate insert operation (persistent vs ephemeral)
   43|      1|        println!("\n--- Insert Operations ---");
   44|      1|        let table_per_new = table_per.insert(4, "Dave".to_string(), |_old, new| new.clone());
                                                                                              ^0  ^0
   45|      1|        println!(
   46|      1|            "After persistent insert - original size: {}, new size: {}",
   47|      1|            table_per.size(),
   48|      1|            table_per_new.size()
   49|       |        );
   50|       |
   51|      1|        table_eph.insert(4, "Dave".to_string(), |_old, new| new.clone());
                                                                          ^0  ^0
   52|      1|        println!("After ephemeral insert - table size: {}", table_eph.size());
   53|       |
   54|      1|        table_mt.insert(4, "Dave".to_string(), |_old, new| new.clone());
                                                                         ^0  ^0
   55|      1|        println!("After multi-threaded insert - table size: {}", table_mt.size());
   56|       |
   57|       |        // Demonstrate domain operation
   58|      1|        println!("\n--- Domain Operations ---");
   59|      1|        let domain_per = table_per_new.domain();
   60|      1|        let domain_eph = table_eph.domain();
   61|      1|        let domain_mt = table_mt.domain();
   62|       |
   63|      1|        println!("Persistent table domain size: {}", domain_per.size());
   64|      1|        println!("Ephemeral table domain size: {}", domain_eph.size());
   65|      1|        println!("Multi-threaded table domain size: {}", domain_mt.size());
   66|       |
   67|       |        // Demonstrate map operation
   68|      1|        println!("\n--- Map Operations ---");
   69|      4|        let table_per_mapped = table_per_new.map(|name| name.to_uppercase());
                          ^1                 ^1            ^1
   70|      1|        println!(
   71|      1|            "Persistent table after map (original unchanged): {:?}",
   72|      1|            table_per_new.find(&1)
   73|       |        );
   74|      1|        println!(
   75|      1|            "Persistent table after map (new table): {:?}",
   76|      1|            table_per_mapped.find(&1)
   77|       |        );
   78|       |
   79|      4|        table_eph.map(|name| name.to_uppercase());
                      ^1        ^1
   80|      1|        println!(
   81|      1|            "Ephemeral table after map (modified in place): {:?}",
   82|      1|            table_eph.find(&1)
   83|       |        );
   84|       |
   85|      4|        table_mt.map(|name| name.to_uppercase());
                      ^1       ^1
   86|      1|        println!(
   87|      1|            "Multi-threaded table after map (modified in place): {:?}",
   88|      1|            table_mt.find(&1)
   89|       |        );
   90|       |
   91|       |        // Demonstrate filter operation
   92|      1|        println!("\n--- Filter Operations ---");
   93|      4|        let table_per_filtered = table_per_new.filter(|k, _v| *k <= 2);
                          ^1                   ^1            ^1
   94|      1|        println!(
   95|      1|            "Persistent table after filter (keys <= 2): size = {}",
   96|      1|            table_per_filtered.size()
   97|       |        );
   98|       |
   99|      4|        table_eph.filter(|k, _v| *k <= 2);
                      ^1        ^1
  100|      1|        println!("Ephemeral table after filter (keys <= 2): size = {}", table_eph.size());
  101|       |
  102|      4|        table_mt.filter(|k, _v| *k <= 2);
                      ^1       ^1
  103|      1|        println!(
  104|      1|            "Multi-threaded table after filter (keys <= 2): size = {}",
  105|      1|            table_mt.size()
  106|       |        );
  107|       |
  108|       |        // Demonstrate tabulate operation
  109|      1|        println!("\n--- Tabulate Operations ---");
  110|      1|        let mut keys = ArraySetStEph::empty();
  111|      1|        keys.insert(10);
  112|      1|        keys.insert(20);
  113|      1|        keys.insert(30);
  114|       |
  115|      3|        let table_per_tab = TableStPer::tabulate(|k| k * k, &keys);
                          ^1              ^1                              ^1
  116|      3|        let table_eph_tab = TableStEph::tabulate(|k| k * k, &keys);
                          ^1              ^1                              ^1
  117|      3|        let table_mt_tab = TableMtEph::tabulate(|k| k * k, &keys);
                          ^1             ^1                              ^1
  118|       |
  119|      1|        println!("Tabulated tables (f(k) = k):");
  120|      1|        println!("  Persistent: key 20 -> {:?}", table_per_tab.find(&20));
  121|      1|        println!("  Ephemeral: key 20 -> {:?}", table_eph_tab.find(&20));
  122|      1|        println!("  Multi-threaded: key 20 -> {:?}", table_mt_tab.find(&20));
  123|       |
  124|       |        // Demonstrate set operations
  125|      1|        println!("\n--- Set Operations ---");
  126|      1|        let table1 = TableStPerLit![1 => "A".to_string(), 2 => "B".to_string()];
  127|      1|        let table2 = TableStPerLit![2 => "X".to_string(), 3 => "Y".to_string()];
  128|       |
  129|      1|        let intersection = table1.intersection(&table2, |v1, v2| format!("{}+{}", v1, v2));
  130|      1|        let union = table1.union(&table2, |v1, v2| format!("{}+{}", v1, v2));
  131|      1|        let difference = table1.difference(&table2);
  132|       |
  133|      1|        println!(
  134|      1|            "Table1  Table2: size = {}, key 2 -> {:?}",
  135|      1|            intersection.size(),
  136|      1|            intersection.find(&2)
  137|       |        );
  138|      1|        println!("Table1  Table2: size = {}", union.size());
  139|      1|        println!("Table1 - Table2: size = {}", difference.size());
  140|       |
  141|      1|        println!("\n=== Example 42.1 Complete ===");
  142|      1|    }
  143|       |
  144|       |    /// Demonstrate performance characteristics of different table implementations
  145|      1|    pub fn performance_comparison() {
  146|      1|        println!("\n=== Performance Comparison ===");
  147|       |
  148|      1|        let size = 1000;
  149|      1|        println!("Building tables with {} entries...", size);
  150|       |
  151|       |        // Build persistent table
  152|      1|        let start = std::time::Instant::now();
  153|      1|        let mut table_per = TableStPer::empty();
  154|  1.00k|        for i in 0..size {
                                  ^1
  155|  1.00k|            table_per = table_per.insert(i, format!("value_{}", i), |_old, new| new.clone());
                                                                                              ^0  ^0
  156|       |        }
  157|      1|        let per_time = start.elapsed();
  158|      1|        println!("Persistent table construction: {:?}", per_time);
  159|       |
  160|       |        // Build ephemeral table
  161|      1|        let start = std::time::Instant::now();
  162|      1|        let mut table_eph = TableStEph::empty();
  163|  1.00k|        for i in 0..size {
                                  ^1
  164|  1.00k|            table_eph.insert(i, format!("value_{}", i), |_old, new| new.clone());
                                                                                  ^0  ^0
  165|       |        }
  166|      1|        let eph_time = start.elapsed();
  167|      1|        println!("Ephemeral table construction: {:?}", eph_time);
  168|       |
  169|       |        // Build multi-threaded table
  170|      1|        let start = std::time::Instant::now();
  171|      1|        let mut table_mt = TableMtEph::empty();
  172|  1.00k|        for i in 0..size {
                                  ^1
  173|  1.00k|            table_mt.insert(i, format!("value_{}", i), |_old, new| new.clone());
                                                                                 ^0  ^0
  174|       |        }
  175|      1|        let mt_time = start.elapsed();
  176|      1|        println!("Multi-threaded table construction: {:?}", mt_time);
  177|       |
  178|       |        // Test map operation performance
  179|      1|        println!("\nMap operation performance:");
  180|       |
  181|      1|        let start = std::time::Instant::now();
  182|  1.00k|        let _mapped_per = table_per.map(|s| s.to_uppercase());
                          ^1            ^1        ^1
  183|      1|        let per_map_time = start.elapsed();
  184|      1|        println!("Persistent map: {:?}", per_map_time);
  185|       |
  186|      1|        let start = std::time::Instant::now();
  187|  1.00k|        table_eph.map(|s| s.to_uppercase());
                      ^1        ^1
  188|      1|        let eph_map_time = start.elapsed();
  189|      1|        println!("Ephemeral map: {:?}", eph_map_time);
  190|       |
  191|      1|        let start = std::time::Instant::now();
  192|  1.00k|        table_mt.map(|s| s.to_uppercase());
                      ^1       ^1
  193|      1|        let mt_map_time = start.elapsed();
  194|      1|        println!("Multi-threaded map: {:?}", mt_map_time);
  195|      1|    }
  196|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap42/TableMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 42 multi-threaded ephemeral table implementation using ArraySeqMtEph as backing store.
    3|       |
    4|       |pub mod TableMtEph {
    5|       |
    6|       |    use std::cmp::Ordering;
    7|       |    use std::sync::Arc;
    8|       |    use std::thread;
    9|       |
   10|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphTrait;
   11|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
   12|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::*;
   13|       |    use crate::Types::Types::*;
   14|       |
   15|       |    #[derive(Debug, Clone, PartialEq)]
   16|       |    pub struct TableMtEph<K: MtKey, V: MtVal> {
   17|       |        entries: ArraySeqMtEphS<Pair<K, V>>,
   18|       |    }
   19|       |
   20|       |    pub type TableS<K, V> = TableMtEph<K, V>;
   21|       |
   22|       |    /// Trait defining the Table ADT operations from Chapter 42
   23|       |    pub trait TableMtEphTrait<K: MtKey, V: MtVal> {
   24|       |        /// claude-4-sonet: Work (1), Span (1)
   25|       |        fn size(&self) -> N;
   26|       |        /// claude-4-sonet: Work (1), Span (1)
   27|       |        fn empty() -> Self;
   28|       |        /// claude-4-sonet: Work (1), Span (1)
   29|       |        fn singleton(key: K, value: V) -> Self;
   30|       |        /// claude-4-sonet: Work (n log n), Span (log n), Parallelism (n)
   31|       |        fn domain(&self) -> ArraySetStEph<K>;
   32|       |        /// claude-4-sonet: Work (|keys|  W(f)), Span (log |keys| + S(f)), Parallelism (|keys|/(log |keys| + S(f)))
   33|       |        fn tabulate<F: Fn(&K) -> V + Send + Sync + 'static>(f: F, keys: &ArraySetStEph<K>) -> Self;
   34|       |        /// claude-4-sonet: Work (n  W(f)), Span (log n + S(f)), Parallelism (n/(log n + S(f)))
   35|       |        fn map<F: Fn(&V) -> V + Send + Sync + 'static>(&mut self, f: F);
   36|       |        /// claude-4-sonet: Work (n  W(f)), Span (log n + S(f)), Parallelism (n/(log n + S(f)))
   37|       |        fn filter<F: Fn(&K, &V) -> B + Send + Sync + 'static>(&mut self, f: F);
   38|       |        /// claude-4-sonet: Work (m + n), Span (log(m + n)), Parallelism ((m+n)/log(m+n))
   39|       |        fn intersection<F: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, combine: F);
   40|       |        /// claude-4-sonet: Work (m + n), Span (log(m + n)), Parallelism ((m+n)/log(m+n))
   41|       |        fn union<F: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, combine: F);
   42|       |        /// claude-4-sonet: Work (m + n), Span (log(m + n)), Parallelism ((m+n)/log(m+n))
   43|       |        fn difference(&mut self, other: &Self);
   44|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   45|       |        fn find(&self, key: &K) -> Option<V>;
   46|       |        /// claude-4-sonet: Work (n), Span (log n), Parallelism (n/log n)
   47|       |        fn delete(&mut self, key: &K);
   48|       |        /// claude-4-sonet: Work (n), Span (log n), Parallelism (n/log n)
   49|       |        fn insert<F: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, key: K, value: V, combine: F);
   50|       |        /// claude-4-sonet: Work (m + n), Span (log(m + n)), Parallelism ((m+n)/log(m+n))
   51|       |        fn restrict(&mut self, keys: &ArraySetStEph<K>);
   52|       |        /// claude-4-sonet: Work (m + n), Span (log(m + n)), Parallelism ((m+n)/log(m+n))
   53|       |        fn subtract(&mut self, keys: &ArraySetStEph<K>);
   54|       |
   55|       |        /// APAS: Work (|a|), Span (lg |a|)
   56|       |        /// claude-4-sonet: Work (n), Span (log n), Parallelism (n/log n)
   57|       |        fn collect(&self) -> ArraySeqMtEphS<Pair<K, V>>;
   58|       |    }
   59|       |
   60|       |    impl<K: MtKey, V: MtVal> TableMtEphTrait<K, V> for TableMtEph<K, V> {
   61|       |        /// Work: O(1), Span: O(1)
   62|  2.68k|        fn size(&self) -> N { self.entries.length() }
   63|       |
   64|       |        /// Work: O(1), Span: O(1)
   65|    107|        fn empty() -> Self {
   66|    107|            TableMtEph {
   67|    107|                entries: ArraySeqMtEphS::empty(),
   68|    107|            }
   69|    107|        }
   70|       |
   71|       |        /// Work: O(1), Span: O(1)
   72|      4|        fn singleton(key: K, value: V) -> Self {
   73|      4|            TableMtEph {
   74|      4|                entries: ArraySeqMtEphS::singleton(Pair(key, value)),
   75|      4|            }
   76|      4|        }
   77|       |
   78|       |        /// Work: O(n), Span: O(log n) - parallel domain extraction
   79|      5|        fn domain(&self) -> ArraySetStEph<K> {
   80|      5|            let mut keys = ArraySetStEph::empty();
   81|      5|            let len = self.entries.length();
   82|       |
   83|      5|            if len <= 1 {
   84|       |                // Base case: extract key directly
   85|      1|                if len == 1 {
   86|      0|                    keys.insert(self.entries.nth_cloned(0).0);
   87|      1|                }
   88|      1|                return keys;
   89|      4|            }
   90|       |
   91|       |            // Parallel extraction using spawn/join
   92|      4|            let mid = len / 2;
   93|      4|            let left_entries = self.entries.subseq_copy(0, mid);
   94|      4|            let right_entries = self.entries.subseq_copy(mid, len - mid);
   95|       |
   96|      4|            let handle = thread::spawn(move || {
   97|      9|                ArraySeqMtEphS::tabulate(&|i| left_entries.nth_cloned(i).0, left_entries.length())
                              ^4                                                          ^4           ^4
   98|      4|            });
   99|       |
  100|     11|            let right_keys = ArraySeqMtEphS::tabulate(&|i| right_entries.nth_cloned(i).0, right_entries.length());
                              ^4           ^4                                                           ^4            ^4
  101|       |
  102|      4|            let left_keys = handle.join().unwrap();
  103|       |
  104|       |            // Insert all keys sequentially (ArraySetStEph is single-threaded)
  105|      9|            for i in 0..left_keys.length() {
                                      ^4        ^4
  106|      9|                keys.insert(left_keys.nth_cloned(i));
  107|      9|            }
  108|     11|            for i in 0..right_keys.length() {
                                      ^4         ^4
  109|     11|                keys.insert(right_keys.nth_cloned(i));
  110|     11|            }
  111|      4|            keys
  112|      5|        }
  113|       |
  114|       |        /// Work: O(n), Span: O(log n) - parallel tabulation
  115|      6|        fn tabulate<F: Fn(&K) -> V + Send + Sync + 'static>(f: F, keys: &ArraySetStEph<K>) -> Self {
  116|      6|            let key_seq = keys.to_seq();
  117|      6|            let f = Arc::new(f);
  118|      6|            let len = key_seq.length();
  119|       |
  120|      6|            if len == 0 {
  121|      1|                return TableMtEph::empty();
  122|      5|            }
  123|       |
  124|      5|            if len == 1 {
  125|      0|                let key = key_seq.nth(0);
  126|      0|                let value = f(key);
  127|      0|                return TableMtEph::singleton(key.clone(), value);
  128|      5|            }
  129|       |
  130|       |            // Parallel tabulation using spawn/join
  131|      5|            let mid = len / 2;
  132|      5|            let left_seq = key_seq.subseq(0, mid);
  133|      5|            let right_seq = key_seq.subseq(mid, len - mid);
  134|      5|            let f_clone = f.clone();
  135|       |
  136|      5|            let handle = thread::spawn(move || {
  137|      5|                ArraySeqMtEphS::tabulate(
  138|     15|                    &|i| {
  139|     15|                        let key = left_seq.nth(i);
  140|     15|                        let value = f_clone(key);
  141|     15|                        Pair(key.clone(), value)
  142|     15|                    },
  143|      5|                    left_seq.length(),
  144|       |                )
  145|      5|            });
  146|       |
  147|      5|            let right_entries = ArraySeqMtEphS::tabulate(
  148|     19|                &|i| {
  149|     19|                    let key = right_seq.nth(i);
  150|     19|                    let value = f(key);
  151|     19|                    Pair(key.clone(), value)
  152|     19|                },
  153|      5|                right_seq.length(),
  154|       |            );
  155|       |
  156|      5|            let left_entries = handle.join().unwrap();
  157|       |
  158|       |            // Merge and sort entries - combine both sequences
  159|      5|            let total_len = left_entries.length() + right_entries.length();
  160|      5|            let mut entries = Vec::with_capacity(total_len);
  161|     15|            for i in 0..left_entries.length() {
                                      ^5           ^5
  162|     15|                entries.push(left_entries.nth_cloned(i));
  163|     15|            }
  164|     19|            for i in 0..right_entries.length() {
                                      ^5            ^5
  165|     19|                entries.push(right_entries.nth_cloned(i));
  166|     19|            }
  167|     29|            entries.sort_by(|a, b| a.0.cmp(&b.0));
                          ^5      ^5
  168|       |
  169|      5|            TableMtEph {
  170|      5|                entries: ArraySeqMtEphS::from_vec(entries),
  171|      5|            }
  172|      6|        }
  173|       |
  174|       |        /// Work: O(n), Span: O(log n) - parallel map
  175|      4|        fn map<F: Fn(&V) -> V + Send + Sync + 'static>(&mut self, f: F) {
  176|      4|            let f = Arc::new(f);
  177|      4|            let len = self.entries.length();
  178|       |
  179|      4|            if len <= 1 {
  180|      0|                if len == 1 {
  181|      0|                    let pair = self.entries.nth_cloned(0);
  182|      0|                    let new_value = f(&pair.1);
  183|      0|                    self.entries = ArraySeqMtEphS::singleton(Pair(pair.0, new_value));
  184|      0|                }
  185|      0|                return;
  186|      4|            }
  187|       |
  188|       |            // Parallel map using spawn/join
  189|      4|            let mid = len / 2;
  190|      4|            let left_entries = self.entries.subseq_copy(0, mid);
  191|      4|            let right_entries = self.entries.subseq_copy(mid, len - mid);
  192|      4|            let f_clone = f.clone();
  193|       |
  194|      4|            let handle = thread::spawn(move || {
  195|      4|                ArraySeqMtEphS::tabulate(
  196|    528|                    &|i| {
  197|    528|                        let pair = left_entries.nth_cloned(i);
  198|    528|                        let new_value = f_clone(&pair.1);
  199|    528|                        Pair(pair.0, new_value)
  200|    528|                    },
  201|      4|                    left_entries.length(),
  202|       |                )
  203|      4|            });
  204|       |
  205|      4|            let right_mapped = ArraySeqMtEphS::tabulate(
  206|    528|                &|i| {
  207|    528|                    let pair = right_entries.nth_cloned(i);
  208|    528|                    let new_value = f(&pair.1);
  209|    528|                    Pair(pair.0, new_value)
  210|    528|                },
  211|      4|                right_entries.length(),
  212|       |            );
  213|       |
  214|      4|            let left_mapped = handle.join().unwrap();
  215|       |
  216|       |            // Merge results - combine both sequences
  217|      4|            let mut mapped_entries = Vec::with_capacity(len);
  218|    528|            for i in 0..left_mapped.length() {
                                      ^4          ^4
  219|    528|                mapped_entries.push(left_mapped.nth_cloned(i));
  220|    528|            }
  221|    528|            for i in 0..right_mapped.length() {
                                      ^4           ^4
  222|    528|                mapped_entries.push(right_mapped.nth_cloned(i));
  223|    528|            }
  224|       |
  225|      4|            self.entries = ArraySeqMtEphS::from_vec(mapped_entries);
  226|      4|        }
  227|       |
  228|       |        /// Work: O(n), Span: O(log n) - parallel filter
  229|      3|        fn filter<F: Fn(&K, &V) -> B + Send + Sync + 'static>(&mut self, f: F) {
  230|      3|            let f = Arc::new(f);
  231|      3|            let len = self.entries.length();
  232|       |
  233|      3|            if len == 0 {
  234|      0|                return;
  235|      3|            }
  236|       |
  237|      3|            if len == 1 {
  238|      0|                let pair = self.entries.nth_cloned(0);
  239|      0|                if !f(&pair.0, &pair.1) {
  240|      0|                    self.entries = ArraySeqMtEphS::empty();
  241|      0|                }
  242|      0|                return;
  243|      3|            }
  244|       |
  245|       |            // Parallel filter using spawn/join
  246|      3|            let mid = len / 2;
  247|      3|            let left_entries = self.entries.subseq_copy(0, mid);
  248|      3|            let right_entries = self.entries.subseq_copy(mid, len - mid);
  249|      3|            let f_clone = f.clone();
  250|       |
  251|      3|            let handle = thread::spawn(move || {
  252|      3|                let mut left_filtered = Vec::new();
  253|     29|                for i in 0..left_entries.length() {
                                          ^3           ^3
  254|     29|                    let pair = left_entries.nth_cloned(i);
  255|     29|                    if f_clone(&pair.0, &pair.1) {
  256|     16|                        left_filtered.push(pair);
  257|     16|                    }
                                  ^13
  258|       |                }
  259|      3|                left_filtered
  260|      3|            });
  261|       |
  262|      3|            let mut right_filtered = Vec::new();
  263|     29|            for i in 0..right_entries.length() {
                                      ^3            ^3
  264|     29|                let pair = right_entries.nth_cloned(i);
  265|     29|                if f(&pair.0, &pair.1) {
  266|     13|                    right_filtered.push(pair);
  267|     16|                }
  268|       |            }
  269|       |
  270|      3|            let left_filtered = handle.join().unwrap();
  271|       |
  272|       |            // Merge results - combine both filtered sequences
  273|      3|            let mut filtered_entries = Vec::with_capacity(left_filtered.len() + right_filtered.len());
  274|     16|            for i in 0..left_filtered.len() {
                                      ^3            ^3
  275|     16|                filtered_entries.push(left_filtered[i].clone());
  276|     16|            }
  277|     13|            for i in 0..right_filtered.len() {
                                      ^3             ^3
  278|     13|                filtered_entries.push(right_filtered[i].clone());
  279|     13|            }
  280|       |
  281|      3|            self.entries = ArraySeqMtEphS::from_vec(filtered_entries);
  282|      3|        }
  283|       |
  284|       |        /// Work: O(n + m), Span: O(log(n + m)) - parallel intersection
  285|      4|        fn intersection<F: Fn(&V, &V) -> V + Send + Sync>(&mut self, other: &Self, combine: F) {
  286|      4|            let combine = Arc::new(combine);
  287|      4|            let mut intersection_entries = Vec::new();
  288|      4|            let mut i = 0;
  289|      4|            let mut j = 0;
  290|       |
  291|       |            // Sequential merge (sorted sequences)
  292|     15|            while i < self.entries.length() && j < other.entries.length() {
                                                             ^11
  293|     11|                let pair1 = self.entries.nth_cloned(i);
  294|     11|                let pair2 = other.entries.nth_cloned(j);
  295|       |
  296|     11|                match pair1.0.cmp(&pair2.0) {
  297|      5|                    | Ordering::Less => i += 1,
  298|      0|                    | Ordering::Greater => j += 1,
  299|      6|                    | Ordering::Equal => {
  300|      6|                        let combined_value = combine(&pair1.1, &pair2.1);
  301|      6|                        intersection_entries.push(Pair(pair1.0.clone(), combined_value));
  302|      6|                        i += 1;
  303|      6|                        j += 1;
  304|      6|                    }
  305|       |                }
  306|       |            }
  307|       |
  308|      4|            self.entries = ArraySeqMtEphS::from_vec(intersection_entries);
  309|      4|        }
  310|       |
  311|       |        /// Work: O(n + m), Span: O(log(n + m)) - parallel union
  312|      6|        fn union<F: Fn(&V, &V) -> V + Send + Sync>(&mut self, other: &Self, combine: F) {
  313|      6|            let combine = Arc::new(combine);
  314|      6|            let mut union_entries = Vec::new();
  315|      6|            let mut i = 0;
  316|      6|            let mut j = 0;
  317|       |
  318|       |            // Sequential merge (sorted sequences)
  319|     16|            while i < self.entries.length() && j < other.entries.length() {
                                                             ^11
  320|     10|                let pair1 = self.entries.nth_cloned(i);
  321|     10|                let pair2 = other.entries.nth_cloned(j);
  322|       |
  323|     10|                match pair1.0.cmp(&pair2.0) {
  324|      7|                    | Ordering::Less => {
  325|      7|                        union_entries.push(pair1.clone());
  326|      7|                        i += 1;
  327|      7|                    }
  328|      0|                    | Ordering::Greater => {
  329|      0|                        union_entries.push(pair2.clone());
  330|      0|                        j += 1;
  331|      0|                    }
  332|      3|                    | Ordering::Equal => {
  333|      3|                        let combined_value = combine(&pair1.1, &pair2.1);
  334|      3|                        union_entries.push(Pair(pair1.0.clone(), combined_value));
  335|      3|                        i += 1;
  336|      3|                        j += 1;
  337|      3|                    }
  338|       |                }
  339|       |            }
  340|       |
  341|       |            // Add remaining entries from self
  342|      7|            while i < self.entries.length() {
  343|      1|                union_entries.push(self.entries.nth_cloned(i).clone());
  344|      1|                i += 1;
  345|      1|            }
  346|       |
  347|       |            // Add remaining entries from other
  348|     13|            while j < other.entries.length() {
  349|      7|                union_entries.push(other.entries.nth_cloned(j).clone());
  350|      7|                j += 1;
  351|      7|            }
  352|       |
  353|      6|            self.entries = ArraySeqMtEphS::from_vec(union_entries);
  354|      6|        }
  355|       |
  356|       |        /// Work: O(n + m), Span: O(log(n + m)) - parallel difference
  357|      4|        fn difference(&mut self, other: &Self) {
  358|      4|            let mut difference_entries = Vec::new();
  359|      4|            let mut i = 0;
  360|      4|            let mut j = 0;
  361|       |
  362|       |            // Sequential merge (sorted sequences)
  363|     14|            while i < self.entries.length() && j < other.entries.length() {
                                                             ^11
  364|     10|                let pair1 = self.entries.nth_cloned(i);
  365|     10|                let pair2 = other.entries.nth_cloned(j);
  366|       |
  367|     10|                match pair1.0.cmp(&pair2.0) {
  368|      6|                    | Ordering::Less => {
  369|      6|                        difference_entries.push(pair1.clone());
  370|      6|                        i += 1;
  371|      6|                    }
  372|      0|                    | Ordering::Greater => {
  373|      0|                        j += 1;
  374|      0|                    }
  375|      4|                    | Ordering::Equal => {
  376|      4|                        i += 1;
  377|      4|                        j += 1;
  378|      4|                    }
  379|       |                }
  380|       |            }
  381|       |
  382|       |            // Add remaining entries from self
  383|      5|            while i < self.entries.length() {
  384|      1|                difference_entries.push(self.entries.nth_cloned(i).clone());
  385|      1|                i += 1;
  386|      1|            }
  387|       |
  388|      4|            self.entries = ArraySeqMtEphS::from_vec(difference_entries);
  389|      4|        }
  390|       |
  391|       |        /// Work: O(log n), Span: O(log n) - binary search
  392|  4.74k|        fn find(&self, key: &K) -> Option<V> {
  393|       |            // Binary search since entries are sorted by key
  394|  4.74k|            let mut left = 0;
  395|  4.74k|            let mut right = self.entries.length();
  396|       |
  397|  37.7k|            while left < right {
  398|  33.1k|                let mid = left + (right - left) / 2;
  399|  33.1k|                let pair = self.entries.nth_cloned(mid);
  400|       |
  401|  33.1k|                match key.cmp(&pair.0) {
  402|    752|                    | Ordering::Less => right = mid,
  403|  32.2k|                    | Ordering::Greater => left = mid + 1,
  404|    215|                    | Ordering::Equal => return Some(pair.1.clone()),
  405|       |                }
  406|       |            }
  407|       |
  408|  4.52k|            None
  409|  4.74k|        }
  410|       |
  411|       |        /// Work: O(n), Span: O(log n) - parallel filter
  412|     11|        fn delete(&mut self, key: &K) {
  413|     11|            let len = self.entries.length();
  414|       |
  415|     11|            if len == 0 {
  416|      0|                return;
  417|     11|            }
  418|       |
  419|     11|            if len == 1 {
  420|      2|                let pair = self.entries.nth_cloned(0);
  421|      2|                if pair.0 == *key {
  422|      0|                    self.entries = ArraySeqMtEphS::empty();
  423|      2|                }
  424|      2|                return;
  425|      9|            }
  426|       |
  427|       |            // Parallel delete using spawn/join
  428|      9|            let mid = len / 2;
  429|      9|            let left_entries = self.entries.subseq_copy(0, mid);
  430|      9|            let right_entries = self.entries.subseq_copy(mid, len - mid);
  431|      9|            let key_clone = key.clone();
  432|       |
  433|      9|            let handle = thread::spawn(move || {
  434|      9|                let mut left_filtered = Vec::new();
  435|      9|                for i in 0..left_entries.length() {
  436|      9|                    let pair = left_entries.nth_cloned(i);
  437|      9|                    if pair.0 != key_clone {
  438|      5|                        left_filtered.push(pair);
  439|      5|                    }
                                  ^4
  440|       |                }
  441|      9|                left_filtered
  442|      9|            });
  443|       |
  444|      9|            let key_clone2 = key.clone();
  445|      9|            let mut right_filtered = Vec::new();
  446|     13|            for i in 0..right_entries.length() {
                                      ^9            ^9
  447|     13|                let pair = right_entries.nth_cloned(i);
  448|     13|                if pair.0 != key_clone2 {
  449|     10|                    right_filtered.push(pair);
  450|     10|                }
                              ^3
  451|       |            }
  452|       |
  453|      9|            let left_filtered = handle.join().unwrap();
  454|       |
  455|       |            // Merge results - combine both filtered sequences
  456|      9|            let mut filtered_entries = Vec::with_capacity(left_filtered.len() + right_filtered.len());
  457|      9|            for i in 0..left_filtered.len() {
                              ^5
  458|      5|                filtered_entries.push(left_filtered[i].clone());
  459|      5|            }
  460|     10|            for i in 0..right_filtered.len() {
                                      ^9             ^9
  461|     10|                filtered_entries.push(right_filtered[i].clone());
  462|     10|            }
  463|       |
  464|      9|            self.entries = ArraySeqMtEphS::from_vec(filtered_entries);
  465|     11|        }
  466|       |
  467|       |        /// Work: O(n), Span: O(log n) - parallel insert with combine
  468|  4.45k|        fn insert<F: Fn(&V, &V) -> V + Send + Sync>(&mut self, key: K, value: V, combine: F) {
  469|       |            // Check if key already exists
  470|  4.45k|            if let Some(existing_value) = self.find(&key) {
                                      ^3
  471|       |                // Key exists, combine values and replace
  472|      3|                let combined_value = combine(&existing_value, &value);
  473|      3|                let len = self.entries.length();
  474|       |
  475|      3|                if len == 1 {
  476|      1|                    self.entries = ArraySeqMtEphS::singleton(Pair(key, combined_value));
  477|      1|                    return;
  478|      2|                }
  479|       |
  480|       |                // Parallel update using spawn/join
  481|      2|                let mid = len / 2;
  482|      2|                let left_entries = self.entries.subseq_copy(0, mid);
  483|      2|                let right_entries = self.entries.subseq_copy(mid, len - mid);
  484|      2|                let key_clone = key.clone();
  485|      2|                let combined_clone = combined_value.clone();
  486|       |
  487|      2|                let handle = thread::spawn(move || {
  488|      2|                    ArraySeqMtEphS::tabulate(
  489|      2|                        &|i| {
  490|      2|                            let pair = left_entries.nth_cloned(i);
  491|      2|                            if pair.0 == key_clone {
  492|      0|                                Pair(key_clone.clone(), combined_clone.clone())
  493|       |                            } else {
  494|      2|                                pair
  495|       |                            }
  496|      2|                        },
  497|      2|                        left_entries.length(),
  498|       |                    )
  499|      2|                });
  500|       |
  501|      2|                let right_updated = ArraySeqMtEphS::tabulate(
  502|      4|                    &|i| {
  503|      4|                        let pair = right_entries.nth_cloned(i);
  504|      4|                        if pair.0 == key {
  505|      2|                            Pair(key.clone(), combined_value.clone())
  506|       |                        } else {
  507|      2|                            pair
  508|       |                        }
  509|      4|                    },
  510|      2|                    right_entries.length(),
  511|       |                );
  512|       |
  513|      2|                let left_updated = handle.join().unwrap();
  514|       |
  515|       |                // Merge results - combine both sequences
  516|      2|                let mut updated_entries = Vec::with_capacity(len);
  517|      2|                for i in 0..left_updated.length() {
  518|      2|                    updated_entries.push(left_updated.nth_cloned(i));
  519|      2|                }
  520|      4|                for i in 0..right_updated.length() {
                                          ^2            ^2
  521|      4|                    updated_entries.push(right_updated.nth_cloned(i));
  522|      4|                }
  523|       |
  524|      2|                self.entries = ArraySeqMtEphS::from_vec(updated_entries);
  525|       |            } else {
  526|       |                // Key doesn't exist, add new entry
  527|  4.45k|                let new_pair = Pair(key, value);
  528|  4.45k|                let new_entries = ArraySeqMtEphS::tabulate(
  529|  2.58M|                    &|i| {
  530|  2.58M|                        if i < self.entries.length() {
  531|  2.58M|                            self.entries.nth_cloned(i)
  532|       |                        } else {
  533|  4.45k|                            new_pair.clone()
  534|       |                        }
  535|  2.58M|                    },
  536|  4.45k|                    self.entries.length() + 1,
  537|       |                );
  538|  4.45k|                let mut entries_vec = Vec::with_capacity(new_entries.length());
  539|  2.58M|                for i in 0..new_entries.length() {
                                          ^4.45k      ^4.45k
  540|  2.58M|                    entries_vec.push(new_entries.nth_cloned(i));
  541|  2.58M|                }
  542|  2.58M|                entries_vec.sort_by(|a, b| a.0.cmp(&b.0));
                              ^4.45k      ^4.45k
  543|  4.45k|                self.entries = ArraySeqMtEphS::from_vec(entries_vec);
  544|       |            }
  545|  4.45k|        }
  546|       |
  547|       |        /// Work: O(n + m), Span: O(log n) - parallel restrict
  548|      4|        fn restrict(&mut self, keys: &ArraySetStEph<K>) {
  549|      4|            let len = self.entries.length();
  550|       |
  551|      4|            if len == 0 {
  552|      0|                return;
  553|      4|            }
  554|       |
  555|      4|            if len == 1 {
  556|      0|                let pair = self.entries.nth_cloned(0);
  557|      0|                if !keys.find(&pair.0) {
  558|      0|                    self.entries = ArraySeqMtEphS::empty();
  559|      0|                }
  560|      0|                return;
  561|      4|            }
  562|       |
  563|       |            // Parallel restrict using spawn/join
  564|      4|            let mid = len / 2;
  565|      4|            let left_entries = self.entries.subseq_copy(0, mid);
  566|      4|            let right_entries = self.entries.subseq_copy(mid, len - mid);
  567|      4|            let keys_clone = keys.clone();
  568|       |
  569|      4|            let handle = thread::spawn(move || {
  570|      4|                let mut left_filtered = Vec::new();
  571|     10|                for i in 0..left_entries.length() {
                                          ^4           ^4
  572|     10|                    let pair = left_entries.nth_cloned(i);
  573|     10|                    if keys_clone.find(&pair.0) {
  574|      4|                        left_filtered.push(pair);
  575|      6|                    }
  576|       |                }
  577|      4|                left_filtered
  578|      4|            });
  579|       |
  580|      4|            let keys_clone2 = keys.clone();
  581|      4|            let mut right_filtered = Vec::new();
  582|     10|            for i in 0..right_entries.length() {
                                      ^4            ^4
  583|     10|                let pair = right_entries.nth_cloned(i);
  584|     10|                if keys_clone2.find(&pair.0) {
  585|      3|                    right_filtered.push(pair);
  586|      7|                }
  587|       |            }
  588|       |
  589|      4|            let left_filtered = handle.join().unwrap();
  590|       |
  591|       |            // Merge results - combine both filtered sequences
  592|      4|            let mut filtered_entries = Vec::with_capacity(left_filtered.len() + right_filtered.len());
  593|      4|            for i in 0..left_filtered.len() {
  594|      4|                filtered_entries.push(left_filtered[i].clone());
  595|      4|            }
  596|      4|            for i in 0..right_filtered.len() {
                              ^3
  597|      3|                filtered_entries.push(right_filtered[i].clone());
  598|      3|            }
  599|       |
  600|      4|            self.entries = ArraySeqMtEphS::from_vec(filtered_entries);
  601|      4|        }
  602|       |
  603|       |        /// Work: O(n + m), Span: O(log n) - parallel subtract
  604|      4|        fn subtract(&mut self, keys: &ArraySetStEph<K>) {
  605|      4|            let len = self.entries.length();
  606|       |
  607|      4|            if len == 0 {
  608|      0|                return;
  609|      4|            }
  610|       |
  611|      4|            if len == 1 {
  612|      0|                let pair = self.entries.nth_cloned(0);
  613|      0|                if keys.find(&pair.0) {
  614|      0|                    self.entries = ArraySeqMtEphS::empty();
  615|      0|                }
  616|      0|                return;
  617|      4|            }
  618|       |
  619|       |            // Parallel subtract using spawn/join
  620|      4|            let mid = len / 2;
  621|      4|            let left_entries = self.entries.subseq_copy(0, mid);
  622|      4|            let right_entries = self.entries.subseq_copy(mid, len - mid);
  623|      4|            let keys_clone = keys.clone();
  624|       |
  625|      4|            let handle = thread::spawn(move || {
  626|      4|                let mut left_filtered = Vec::new();
  627|     10|                for i in 0..left_entries.length() {
                                          ^4           ^4
  628|     10|                    let pair = left_entries.nth_cloned(i);
  629|     10|                    if !keys_clone.find(&pair.0) {
  630|      6|                        left_filtered.push(pair);
  631|      6|                    }
                                  ^4
  632|       |                }
  633|      4|                left_filtered
  634|      4|            });
  635|       |
  636|      4|            let keys_clone2 = keys.clone();
  637|      4|            let mut right_filtered = Vec::new();
  638|     10|            for i in 0..right_entries.length() {
                                      ^4            ^4
  639|     10|                let pair = right_entries.nth_cloned(i);
  640|     10|                if !keys_clone2.find(&pair.0) {
  641|      7|                    right_filtered.push(pair);
  642|      7|                }
                              ^3
  643|       |            }
  644|       |
  645|      4|            let left_filtered = handle.join().unwrap();
  646|       |
  647|       |            // Merge results - combine both filtered sequences
  648|      4|            let mut filtered_entries = Vec::with_capacity(left_filtered.len() + right_filtered.len());
  649|      6|            for i in 0..left_filtered.len() {
                                      ^4            ^4
  650|      6|                filtered_entries.push(left_filtered[i].clone());
  651|      6|            }
  652|      7|            for i in 0..right_filtered.len() {
                                      ^4             ^4
  653|      7|                filtered_entries.push(right_filtered[i].clone());
  654|      7|            }
  655|       |
  656|      4|            self.entries = ArraySeqMtEphS::from_vec(filtered_entries);
  657|      4|        }
  658|       |
  659|    149|        fn collect(&self) -> ArraySeqMtEphS<Pair<K, V>> { self.entries.clone() }
  660|       |    }
  661|       |
  662|       |    /// Helper function for creating tables from sorted entries
  663|     39|    pub fn from_sorted_entries<K: MtKey, V: MtVal>(entries: Vec<Pair<K, V>>) -> TableMtEph<K, V> {
  664|     39|        TableMtEph {
  665|     39|            entries: ArraySeqMtEphS::from_vec(entries),
  666|     39|        }
  667|     39|    }
  668|       |
  669|       |    /// Macro for creating multi-threaded ephemeral table literals
  670|       |    #[macro_export]
  671|       |    macro_rules! TableMtEphLit {
  672|       |        () => {
  673|       |            $crate::Chap42::TableMtEph::TableMtEph::TableMtEph::empty()
  674|       |        };
  675|       |        ($($key:expr => $value:expr),+ $(,)?) => {{
  676|       |            let mut entries = vec![$($crate::Types::Types::Pair($key, $value)),+];
  677|      7|            entries.sort_by(|a, b| a.0.cmp(&b.0));
  678|       |            $crate::Chap42::TableMtEph::TableMtEph::from_sorted_entries(entries)
  679|       |        }};
  680|       |    }
  681|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap42/TableStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 42 single-threaded ephemeral table implementation using ArraySeq as backing store.
    3|       |
    4|       |pub mod TableStEph {
    5|       |
    6|       |    use std::cmp::Ordering;
    7|       |
    8|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
    9|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    #[derive(Debug, Clone, PartialEq)]
   13|       |    pub struct TableStEph<K: StT + Ord, V: StT> {
   14|       |        entries: ArraySeqStEphS<Pair<K, V>>,
   15|       |    }
   16|       |
   17|       |    pub type TableS<K, V> = TableStEph<K, V>;
   18|       |
   19|       |    /// Trait defining the Table ADT operations from Chapter 42
   20|       |    pub trait TableStEphTrait<K: StT + Ord, V: StT> {
   21|       |        /// claude-4-sonet: Work (1), Span (1)
   22|       |        fn size(&self) -> N;
   23|       |        /// claude-4-sonet: Work (1), Span (1)
   24|       |        fn empty() -> Self;
   25|       |        /// claude-4-sonet: Work (1), Span (1)
   26|       |        fn singleton(key: K, value: V) -> Self;
   27|       |        /// claude-4-sonet: Work (n log n), Span (n log n), Parallelism (1)
   28|       |        fn domain(&self) -> ArraySetStEph<K>;
   29|       |        /// claude-4-sonet: Work (|keys|  W(f)), Span (|keys|  S(f)), Parallelism (1)
   30|       |        fn tabulate<F: Fn(&K) -> V>(f: F, keys: &ArraySetStEph<K>) -> Self;
   31|       |        /// claude-4-sonet: Work (n  W(f)), Span (n  S(f)), Parallelism (1)
   32|       |        fn map<F: Fn(&V) -> V>(&mut self, f: F);
   33|       |        /// claude-4-sonet: Work (n  W(f)), Span (n  S(f)), Parallelism (1)
   34|       |        fn filter<F: Fn(&K, &V) -> B>(&mut self, f: F);
   35|       |        /// claude-4-sonet: Work (m + n), Span (m + n), Parallelism (1)
   36|       |        fn intersection<F: Fn(&V, &V) -> V>(&mut self, other: &Self, combine: F);
   37|       |        /// claude-4-sonet: Work (m + n), Span (m + n), Parallelism (1)
   38|       |        fn union<F: Fn(&V, &V) -> V>(&mut self, other: &Self, combine: F);
   39|       |        /// claude-4-sonet: Work (m + n), Span (m + n), Parallelism (1)
   40|       |        fn difference(&mut self, other: &Self);
   41|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   42|       |        fn find(&self, key: &K) -> Option<V>;
   43|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   44|       |        fn delete(&mut self, key: &K);
   45|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   46|       |        fn insert<F: Fn(&V, &V) -> V>(&mut self, key: K, value: V, combine: F);
   47|       |        /// claude-4-sonet: Work (m + n), Span (m + n), Parallelism (1)
   48|       |        fn restrict(&mut self, keys: &ArraySetStEph<K>);
   49|       |        /// claude-4-sonet: Work (m + n), Span (m + n), Parallelism (1)
   50|       |        fn subtract(&mut self, keys: &ArraySetStEph<K>);
   51|       |
   52|       |        /// APAS: Work (|a|), Span (lg |a|)
   53|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   54|       |        fn collect(&self) -> ArraySeqStEphS<Pair<K, V>>;
   55|       |    }
   56|       |
   57|       |    impl<K: StT + Ord, V: StT> TableStEphTrait<K, V> for TableStEph<K, V> {
   58|       |        /// Work: O(1), Span: O(1)
   59|    330|        fn size(&self) -> N { self.entries.length() }
   60|       |
   61|       |        /// Work: O(1), Span: O(1)
   62|    116|        fn empty() -> Self {
   63|    116|            TableStEph {
   64|    116|                entries: ArraySeqStEphS::empty(),
   65|    116|            }
   66|    116|        }
   67|       |
   68|       |        /// Work: O(1), Span: O(1)
   69|      4|        fn singleton(key: K, value: V) -> Self {
   70|      4|            TableStEph {
   71|      4|                entries: ArraySeqStEphS::singleton(Pair(key, value)),
   72|      4|            }
   73|      4|        }
   74|       |
   75|       |        /// Work: O(n), Span: O(n)
   76|     13|        fn domain(&self) -> ArraySetStEph<K> {
   77|     13|            let mut keys = ArraySetStEph::empty();
   78|     39|            for i in 0..self.entries.length() {
                                      ^13          ^13
   79|     39|                let pair = self.entries.nth(i);
   80|     39|                keys.insert(pair.0.clone());
   81|     39|            }
   82|     13|            keys
   83|     13|        }
   84|       |
   85|       |        /// Work: O(n), Span: O(n)
   86|      5|        fn tabulate<F: Fn(&K) -> V>(f: F, keys: &ArraySetStEph<K>) -> Self {
   87|      5|            let key_seq = keys.to_seq();
   88|      5|            let mut entries = Vec::with_capacity(key_seq.length());
   89|     14|            for i in 0..key_seq.length() {
                                      ^5      ^5
   90|     14|                let key = key_seq.nth(i);
   91|     14|                let value = f(key);
   92|     14|                entries.push(Pair(key.clone(), value));
   93|     14|            }
   94|       |            // Sort entries by key
   95|     10|            entries.sort_by(|a, b| a.0.cmp(&b.0));
                          ^5      ^5
   96|      5|            TableStEph {
   97|      5|                entries: ArraySeqStEphS::from_vec(entries),
   98|      5|            }
   99|      5|        }
  100|       |
  101|       |        /// Work: O(n), Span: O(n)
  102|      3|        fn map<F: Fn(&V) -> V>(&mut self, f: F) {
  103|      3|            let mapped_entries = ArraySeqStEphS::tabulate(
  104|  1.00k|                &|i| {
  105|  1.00k|                    let pair = self.entries.nth(i);
  106|  1.00k|                    let new_value = f(&pair.1);
  107|  1.00k|                    Pair(pair.0.clone(), new_value)
  108|  1.00k|                },
  109|      3|                self.entries.length(),
  110|       |            );
  111|      3|            self.entries = mapped_entries;
  112|      3|        }
  113|       |
  114|       |        /// Work: O(n), Span: O(n)
  115|      3|        fn filter<F: Fn(&K, &V) -> B>(&mut self, f: F) {
  116|    108|            let filtered = ArraySeqStEphS::filter(&self.entries, &|pair| f(&pair.0, &pair.1));
                              ^3         ^3                     ^3
  117|      3|            self.entries = filtered;
  118|      3|        }
  119|       |
  120|       |        /// Work: O(n + m), Span: O(n + m)
  121|      4|        fn intersection<F: Fn(&V, &V) -> V>(&mut self, other: &Self, combine: F) {
  122|      4|            let mut intersection_entries = Vec::new();
  123|      4|            let mut i = 0;
  124|      4|            let mut j = 0;
  125|       |
  126|     15|            while i < self.entries.length() && j < other.entries.length() {
                                                             ^11
  127|     11|                let pair1 = self.entries.nth(i);
  128|     11|                let pair2 = other.entries.nth(j);
  129|       |
  130|     11|                match pair1.0.cmp(&pair2.0) {
  131|      5|                    | Ordering::Less => i += 1,
  132|      0|                    | Ordering::Greater => j += 1,
  133|      6|                    | Ordering::Equal => {
  134|      6|                        let combined_value = combine(&pair1.1, &pair2.1);
  135|      6|                        intersection_entries.push(Pair(pair1.0.clone(), combined_value));
  136|      6|                        i += 1;
  137|      6|                        j += 1;
  138|      6|                    }
  139|       |                }
  140|       |            }
  141|       |
  142|      4|            self.entries = ArraySeqStEphS::from_vec(intersection_entries);
  143|      4|        }
  144|       |
  145|       |        /// Work: O(n + m), Span: O(n + m)
  146|      6|        fn union<F: Fn(&V, &V) -> V>(&mut self, other: &Self, combine: F) {
  147|      6|            let mut union_entries = Vec::new();
  148|      6|            let mut i = 0;
  149|      6|            let mut j = 0;
  150|       |
  151|     16|            while i < self.entries.length() && j < other.entries.length() {
                                                             ^11
  152|     10|                let pair1 = self.entries.nth(i);
  153|     10|                let pair2 = other.entries.nth(j);
  154|       |
  155|     10|                match pair1.0.cmp(&pair2.0) {
  156|      7|                    | Ordering::Less => {
  157|      7|                        union_entries.push(pair1.clone());
  158|      7|                        i += 1;
  159|      7|                    }
  160|      0|                    | Ordering::Greater => {
  161|      0|                        union_entries.push(pair2.clone());
  162|      0|                        j += 1;
  163|      0|                    }
  164|      3|                    | Ordering::Equal => {
  165|      3|                        let combined_value = combine(&pair1.1, &pair2.1);
  166|      3|                        union_entries.push(Pair(pair1.0.clone(), combined_value));
  167|      3|                        i += 1;
  168|      3|                        j += 1;
  169|      3|                    }
  170|       |                }
  171|       |            }
  172|       |
  173|       |            // Add remaining entries from self
  174|      7|            while i < self.entries.length() {
  175|      1|                union_entries.push(self.entries.nth(i).clone());
  176|      1|                i += 1;
  177|      1|            }
  178|       |
  179|       |            // Add remaining entries from other
  180|     13|            while j < other.entries.length() {
  181|      7|                union_entries.push(other.entries.nth(j).clone());
  182|      7|                j += 1;
  183|      7|            }
  184|       |
  185|      6|            self.entries = ArraySeqStEphS::from_vec(union_entries);
  186|      6|        }
  187|       |
  188|       |        /// Work: O(n + m), Span: O(n + m)
  189|      4|        fn difference(&mut self, other: &Self) {
  190|      4|            let mut difference_entries = Vec::new();
  191|      4|            let mut i = 0;
  192|      4|            let mut j = 0;
  193|       |
  194|     13|            while i < self.entries.length() && j < other.entries.length() {
                                                             ^10
  195|      9|                let pair1 = self.entries.nth(i);
  196|      9|                let pair2 = other.entries.nth(j);
  197|       |
  198|      9|                match pair1.0.cmp(&pair2.0) {
  199|      6|                    | Ordering::Less => {
  200|      6|                        difference_entries.push(pair1.clone());
  201|      6|                        i += 1;
  202|      6|                    }
  203|      0|                    | Ordering::Greater => {
  204|      0|                        j += 1;
  205|      0|                    }
  206|      3|                    | Ordering::Equal => {
  207|      3|                        i += 1;
  208|      3|                        j += 1;
  209|      3|                    }
  210|       |                }
  211|       |            }
  212|       |
  213|       |            // Add remaining entries from self
  214|      5|            while i < self.entries.length() {
  215|      1|                difference_entries.push(self.entries.nth(i).clone());
  216|      1|                i += 1;
  217|      1|            }
  218|       |
  219|      4|            self.entries = ArraySeqStEphS::from_vec(difference_entries);
  220|      4|        }
  221|       |
  222|       |        /// Work: O(log n), Span: O(log n)
  223|  2.44k|        fn find(&self, key: &K) -> Option<V> {
  224|       |            // Binary search since entries are sorted by key
  225|  2.44k|            let mut left = 0;
  226|  2.44k|            let mut right = self.entries.length();
  227|       |
  228|  15.4k|            while left < right {
  229|  13.3k|                let mid = left + (right - left) / 2;
  230|  13.3k|                let pair = self.entries.nth(mid);
  231|       |
  232|  13.3k|                match key.cmp(&pair.0) {
  233|    671|                    | Ordering::Less => right = mid,
  234|  12.3k|                    | Ordering::Greater => left = mid + 1,
  235|    348|                    | Ordering::Equal => return Some(pair.1.clone()),
  236|       |                }
  237|       |            }
  238|       |
  239|  2.10k|            None
  240|  2.44k|        }
  241|       |
  242|       |        /// Work: O(n), Span: O(n)
  243|     10|        fn delete(&mut self, key: &K) {
  244|     25|            let filtered = ArraySeqStEphS::filter(&self.entries, &|pair| &pair.0 != key);
                              ^10        ^10                    ^10
  245|     10|            self.entries = filtered;
  246|     10|        }
  247|       |
  248|       |        /// Work: O(n), Span: O(n)
  249|  2.00k|        fn insert<F: Fn(&V, &V) -> V>(&mut self, key: K, value: V, combine: F) {
  250|       |            // Check if key already exists
  251|  2.00k|            if let Some(existing_value) = self.find(&key) {
                                      ^20
  252|       |                // Key exists, combine values and replace
  253|     20|                let combined_value = combine(&existing_value, &value);
  254|     52|                let filtered = ArraySeqStEphS::filter(&self.entries, &|pair| pair.0 != key);
                                  ^20        ^20                    ^20
  255|     20|                let mut updated_entries = Vec::with_capacity(filtered.length() + 1);
  256|     32|                for i in 0..filtered.length() {
                                          ^20      ^20
  257|     32|                    updated_entries.push(filtered.nth(i).clone());
  258|     32|                }
  259|     20|                updated_entries.push(Pair(key, combined_value));
  260|     44|                updated_entries.sort_by(|a, b| a.0.cmp(&b.0));
                              ^20             ^20
  261|     20|                self.entries = ArraySeqStEphS::from_vec(updated_entries);
  262|       |            } else {
  263|       |                // Key doesn't exist, add new entry
  264|  1.98k|                let mut new_entries = Vec::with_capacity(self.entries.length() + 1);
  265|   551k|                for i in 0..self.entries.length() {
                                          ^1.98k       ^1.98k
  266|   551k|                    new_entries.push(self.entries.nth(i).clone());
  267|   551k|                }
  268|  1.98k|                new_entries.push(Pair(key, value));
  269|   551k|                new_entries.sort_by(|a, b| a.0.cmp(&b.0));
                              ^1.98k      ^1.98k
  270|  1.98k|                self.entries = ArraySeqStEphS::from_vec(new_entries);
  271|       |            }
  272|  2.00k|        }
  273|       |
  274|       |        /// Work: O(n + m), Span: O(n + m)
  275|      4|        fn restrict(&mut self, keys: &ArraySetStEph<K>) {
  276|     20|            let filtered = ArraySeqStEphS::filter(&self.entries, &|pair| keys.find(&pair.0));
                              ^4         ^4                     ^4
  277|      4|            self.entries = filtered;
  278|      4|        }
  279|       |
  280|       |        /// Work: O(n + m), Span: O(n + m)
  281|      4|        fn subtract(&mut self, keys: &ArraySetStEph<K>) {
  282|     20|            let filtered = ArraySeqStEphS::filter(&self.entries, &|pair| !keys.find(&pair.0));
                              ^4         ^4                     ^4
  283|      4|            self.entries = filtered;
  284|      4|        }
  285|       |
  286|    116|        fn collect(&self) -> ArraySeqStEphS<Pair<K, V>> { self.entries.clone() }
  287|       |    }
  288|       |
  289|       |    /// Helper function for creating tables from sorted entries
  290|     24|    pub fn from_sorted_entries<K: StT + Ord, V: StT>(entries: Vec<Pair<K, V>>) -> TableStEph<K, V> {
  291|     24|        TableStEph {
  292|     24|            entries: ArraySeqStEphS::from_vec(entries),
  293|     24|        }
  294|     24|    }
  295|       |
  296|       |    /// Macro for creating ephemeral table literals
  297|       |    #[macro_export]
  298|       |    macro_rules! TableStEphLit {
  299|       |        () => {
  300|       |            $crate::Chap42::TableStEph::TableStEph::TableStEph::empty()
  301|       |        };
  302|       |        ($($key:expr => $value:expr),+ $(,)?) => {{
  303|       |            let mut entries = vec![$($crate::Types::Types::Pair($key, $value)),+];
  304|      7|            entries.sort_by(|a, b| a.0.cmp(&b.0));
  305|       |            $crate::Chap42::TableStEph::TableStEph::from_sorted_entries(entries)
  306|       |        }};
  307|       |    }
  308|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap42/TableStPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 42 single-threaded persistent table implementation using ArraySeq as backing store.
    3|       |
    4|       |pub mod TableStPer {
    5|       |
    6|       |    use std::cmp::Ordering;
    7|       |
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    #[derive(Debug, Clone, PartialEq)]
   13|       |    pub struct TableStPer<K: StT + Ord, V: StT> {
   14|       |        entries: ArraySeqStPerS<Pair<K, V>>,
   15|       |    }
   16|       |
   17|       |    pub type TableS<K, V> = TableStPer<K, V>;
   18|       |
   19|       |    /// Trait defining the Table ADT operations from Chapter 42
   20|       |    pub trait TableStPerTrait<K: StT + Ord, V: StT> {
   21|       |        /// APAS: Work (1), Span (1)
   22|       |        /// claude-4-sonet: Work (1), Span (1)
   23|       |        fn size(&self) -> N;
   24|       |
   25|       |        /// APAS: Work (1), Span (1)
   26|       |        /// claude-4-sonet: Work (1), Span (1)
   27|       |        fn empty() -> Self;
   28|       |
   29|       |        /// APAS: Work (1), Span (1)
   30|       |        /// claude-4-sonet: Work (1), Span (1)
   31|       |        fn singleton(key: K, value: V) -> Self;
   32|       |
   33|       |        /// APAS: Work (|a|), Span (lg |a|)
   34|       |        /// claude-4-sonet: Work (n log n), Span (n log n), Parallelism (1)
   35|       |        fn domain(&self) -> ArraySetStEph<K>;
   36|       |
   37|       |        /// APAS: Work (|s| * W(f)), Span (lg |s| + S(f))
   38|       |        /// claude-4-sonet: Work (|keys|  W(f)), Span (log |keys| + S(f)), Parallelism (|keys|/(log |keys| + S(f)))
   39|       |        fn tabulate<F: Fn(&K) -> V>(f: F, keys: &ArraySetStEph<K>) -> Self;
   40|       |
   41|       |        /// APAS: Work (|a| * W(f)), Span (lg |a| + S(f))
   42|       |        /// claude-4-sonet: Work (n  W(f)), Span (log n + S(f)), Parallelism (n/(log n + S(f)))
   43|       |        fn map<F: Fn(&V) -> V>(&self, f: F) -> Self;
   44|       |
   45|       |        /// APAS: Work (|a| * W(f)), Span (lg |a| + S(f))
   46|       |        /// claude-4-sonet: Work (n  W(f)), Span (log n + S(f)), Parallelism (n/(log n + S(f)))
   47|       |        fn filter<F: Fn(&K, &V) -> B>(&self, f: F) -> Self;
   48|       |
   49|       |        /// APAS: Work (m * lg(1 + n/m)), Span (lg(n + m))
   50|       |        /// claude-4-sonet: Work (m log(1 + n/m)), Span (log(n + m)), Parallelism (m/log(n + m))
   51|       |        fn intersection<F: Fn(&V, &V) -> V>(&self, other: &Self, combine: F) -> Self;
   52|       |
   53|       |        /// APAS: Work (m * lg(1 + n/m)), Span (lg(n + m))
   54|       |        /// claude-4-sonet: Work (m log(1 + n/m)), Span (log(n + m)), Parallelism (m/log(n + m))
   55|       |        fn union<F: Fn(&V, &V) -> V>(&self, other: &Self, combine: F) -> Self;
   56|       |
   57|       |        /// APAS: Work (m * lg(1 + n/m)), Span (lg(n + m))
   58|       |        /// claude-4-sonet: Work (m log(1 + n/m)), Span (log(n + m)), Parallelism (m/log(n + m))
   59|       |        fn difference(&self, other: &Self) -> Self;
   60|       |
   61|       |        /// APAS: Work (lg |a|), Span (lg |a|)
   62|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   63|       |        fn find(&self, key: &K) -> Option<V>;
   64|       |
   65|       |        /// APAS: Work (lg |a|), Span (lg |a|)
   66|       |        fn delete(&self, key: &K) -> Self;
   67|       |
   68|       |        /// APAS: Work (lg |a|), Span (lg |a|)
   69|       |        fn insert<F: Fn(&V, &V) -> V>(&self, key: K, value: V, combine: F) -> Self;
   70|       |
   71|       |        /// APAS: Work (m * lg(1 + n/m)), Span (lg(n + m))
   72|       |        fn restrict(&self, keys: &ArraySetStEph<K>) -> Self;
   73|       |
   74|       |        /// APAS: Work (m * lg(1 + n/m)), Span (lg(n + m))
   75|       |        fn subtract(&self, keys: &ArraySetStEph<K>) -> Self;
   76|       |
   77|       |        /// APAS: Work (|a|), Span (lg |a|)
   78|       |        fn collect(&self) -> ArraySeqStPerS<Pair<K, V>>;
   79|       |    }
   80|       |
   81|       |    impl<K: StT + Ord, V: StT> TableStPerTrait<K, V> for TableStPer<K, V> {
   82|    319|        fn size(&self) -> N { self.entries.length() }
   83|       |
   84|    184|        fn empty() -> Self {
   85|    184|            TableStPer {
   86|    184|                entries: ArraySeqStPerS::empty(),
   87|    184|            }
   88|    184|        }
   89|       |
   90|      5|        fn singleton(key: K, value: V) -> Self {
   91|      5|            TableStPer {
   92|      5|                entries: ArraySeqStPerS::singleton(Pair(key, value)),
   93|      5|            }
   94|      5|        }
   95|       |
   96|     28|        fn domain(&self) -> ArraySetStEph<K> {
   97|     28|            let keys: Vec<K> = (0..self.entries.length())
   98|     66|                .map(|i| self.entries.nth(i).0.clone())
                               ^28
   99|     28|                .collect();
  100|     28|            ArraySetStEph::from_seq(crate::Chap19::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS::from_vec(
  101|     28|                keys,
  102|       |            ))
  103|     28|        }
  104|       |
  105|      4|        fn tabulate<F: Fn(&K) -> V>(f: F, keys: &ArraySetStEph<K>) -> Self {
  106|      4|            let key_seq = keys.to_seq();
  107|      4|            let entries = ArraySeqStPerS::tabulate(
  108|     14|                &|i| {
  109|     14|                    let key = key_seq.nth(i);
  110|     14|                    let value = f(key);
  111|     14|                    Pair(key.clone(), value)
  112|     14|                },
  113|      4|                key_seq.length(),
  114|       |            );
  115|       |
  116|      4|            TableStPer { entries }
  117|      4|        }
  118|       |
  119|      8|        fn map<F: Fn(&V) -> V>(&self, f: F) -> Self {
  120|      8|            let entries = ArraySeqStPerS::tabulate(
  121|  1.02k|                &|i| {
  122|  1.02k|                    let Pair(key, value) = self.entries.nth(i);
  123|  1.02k|                    let new_value = f(value);
  124|  1.02k|                    Pair(key.clone(), new_value)
  125|  1.02k|                },
  126|      8|                self.entries.length(),
  127|       |            );
  128|       |
  129|      8|            TableStPer { entries }
  130|      8|        }
  131|       |
  132|      7|        fn filter<F: Fn(&K, &V) -> B>(&self, f: F) -> Self {
  133|    143|            let filtered = ArraySeqStPerS::filter(&self.entries, &|pair| f(&pair.0, &pair.1));
                              ^7         ^7                     ^7
  134|      7|            TableStPer { entries: filtered }
  135|      7|        }
  136|       |
  137|     10|        fn intersection<F: Fn(&V, &V) -> V>(&self, other: &Self, combine: F) -> Self {
  138|     10|            let mut result_entries = Vec::new();
  139|     10|            let mut i = 0;
  140|     10|            let mut j = 0;
  141|       |
  142|     38|            while i < self.entries.length() && j < other.entries.length() {
                                                             ^29
  143|     28|                let Pair(key1, val1) = self.entries.nth(i);
  144|     28|                let Pair(key2, val2) = other.entries.nth(j);
  145|       |
  146|     28|                match key1.cmp(key2) {
  147|     14|                    | Ordering::Less => i += 1,
  148|      3|                    | Ordering::Greater => j += 1,
  149|     11|                    | Ordering::Equal => {
  150|     11|                        let combined_value = combine(val1, val2);
  151|     11|                        result_entries.push(Pair(key1.clone(), combined_value));
  152|     11|                        i += 1;
  153|     11|                        j += 1;
  154|     11|                    }
  155|       |                }
  156|       |            }
  157|       |
  158|     10|            TableStPer {
  159|     10|                entries: ArraySeqStPerS::from_vec(result_entries),
  160|     10|            }
  161|     10|        }
  162|       |
  163|      6|        fn union<F: Fn(&V, &V) -> V>(&self, other: &Self, combine: F) -> Self {
  164|      6|            let intersection = self.intersection(other, &combine);
  165|      6|            let left_diff = self.difference(other);
  166|      6|            let right_diff = other.difference(self);
  167|       |
  168|       |            // Combine all three parts
  169|      6|            let mut all_entries = Vec::new();
  170|       |
  171|       |            // Add intersection entries
  172|      6|            for i in 0..intersection.entries.length() {
                              ^4
  173|      4|                all_entries.push(intersection.entries.nth(i).clone());
  174|      4|            }
  175|       |
  176|       |            // Add left difference entries
  177|      9|            for i in 0..left_diff.entries.length() {
                                      ^6                ^6
  178|      9|                all_entries.push(left_diff.entries.nth(i).clone());
  179|      9|            }
  180|       |
  181|       |            // Add right difference entries
  182|      9|            for i in 0..right_diff.entries.length() {
                                      ^6                 ^6
  183|      9|                all_entries.push(right_diff.entries.nth(i).clone());
  184|      9|            }
  185|       |
  186|       |            // Sort by key to maintain order
  187|     17|            all_entries.sort_by(|a, b| a.0.cmp(&b.0));
                          ^6          ^6
  188|       |
  189|      6|            TableStPer {
  190|      6|                entries: ArraySeqStPerS::from_vec(all_entries),
  191|      6|            }
  192|      6|        }
  193|       |
  194|     16|        fn difference(&self, other: &Self) -> Self {
  195|     16|            let mut result_entries = Vec::new();
  196|     16|            let mut i = 0;
  197|     16|            let mut j = 0;
  198|       |
  199|     56|            while i < self.entries.length() && j < other.entries.length() {
                                                             ^47
  200|     40|                let Pair(key1, val1) = self.entries.nth(i);
  201|     40|                let Pair(key2, _) = other.entries.nth(j);
  202|       |
  203|     40|                match key1.cmp(key2) {
  204|     16|                    | Ordering::Less => {
  205|     16|                        result_entries.push(Pair(key1.clone(), val1.clone()));
  206|     16|                        i += 1;
  207|     16|                    }
  208|     10|                    | Ordering::Greater => j += 1,
  209|     14|                    | Ordering::Equal => {
  210|     14|                        i += 1;
  211|     14|                        j += 1;
  212|     14|                    }
  213|       |                }
  214|       |            }
  215|       |
  216|       |            // Add remaining entries from self
  217|     25|            while i < self.entries.length() {
  218|      9|                let Pair(key, val) = self.entries.nth(i);
  219|      9|                result_entries.push(Pair(key.clone(), val.clone()));
  220|      9|                i += 1;
  221|      9|            }
  222|       |
  223|     16|            TableStPer {
  224|     16|                entries: ArraySeqStPerS::from_vec(result_entries),
  225|     16|            }
  226|     16|        }
  227|       |
  228|  4.02k|        fn find(&self, key: &K) -> Option<V> {
  229|       |            // Binary search on sorted entries
  230|  4.02k|            let mut left = 0;
  231|  4.02k|            let mut right = self.entries.length();
  232|       |
  233|  18.0k|            while left < right {
  234|  15.3k|                let mid = left + (right - left) / 2;
  235|  15.3k|                let Pair(mid_key, mid_val) = self.entries.nth(mid);
  236|       |
  237|  15.3k|                match key.cmp(mid_key) {
  238|  1.85k|                    | Ordering::Less => right = mid,
  239|  12.1k|                    | Ordering::Greater => left = mid + 1,
  240|  1.31k|                    | Ordering::Equal => return Some(mid_val.clone()),
  241|       |                }
  242|       |            }
  243|       |
  244|  2.71k|            None
  245|  4.02k|        }
  246|       |
  247|    982|        fn delete(&self, key: &K) -> Self {
  248|  8.32k|            let filtered = ArraySeqStPerS::filter(&self.entries, &|pair| &pair.0 != key);
                              ^982       ^982                   ^982
  249|    982|            TableStPer { entries: filtered }
  250|    982|        }
  251|       |
  252|  3.56k|        fn insert<F: Fn(&V, &V) -> V>(&self, key: K, value: V, combine: F) -> Self {
  253|  3.56k|            if let Some(existing_value) = self.find(&key) {
                                      ^973
  254|       |                // Key exists, combine values
  255|    973|                let combined_value = combine(&existing_value, &value);
  256|    973|                let updated = self.delete(&key);
  257|       |                // Find insertion point
  258|    973|                let mut insert_pos = updated.entries.length();
  259|  4.74k|                for i in 0..updated.entries.length() {
                                          ^973            ^973
  260|  4.74k|                    let Pair(k, _) = updated.entries.nth(i);
  261|  4.74k|                    if key < *k {
  262|    821|                        insert_pos = i;
  263|    821|                        break;
  264|  3.92k|                    }
  265|       |                }
  266|       |
  267|    973|                let new_pair = Pair(key, combined_value);
  268|    973|                let entries = ArraySeqStPerS::tabulate(
  269|  8.29k|                    &|i| {
  270|  8.29k|                        if i < insert_pos {
  271|  3.92k|                            updated.entries.nth(i).clone()
  272|  4.37k|                        } else if i == insert_pos {
  273|    973|                            new_pair.clone()
  274|       |                        } else {
  275|  3.39k|                            updated.entries.nth(i - 1).clone()
  276|       |                        }
  277|  8.29k|                    },
  278|    973|                    updated.entries.length() + 1,
  279|       |                );
  280|       |
  281|    973|                TableStPer { entries }
  282|       |            } else {
  283|       |                // Key doesn't exist, insert new entry
  284|       |                // Find insertion point
  285|  2.58k|                let mut insert_pos = self.entries.length();
  286|   513k|                for i in 0..self.entries.length() {
                                          ^2.58k       ^2.58k
  287|   513k|                    let Pair(k, _) = self.entries.nth(i);
  288|   513k|                    if key < *k {
  289|    439|                        insert_pos = i;
  290|    439|                        break;
  291|   513k|                    }
  292|       |                }
  293|       |
  294|  2.58k|                let new_pair = Pair(key, value);
  295|  2.58k|                let entries = ArraySeqStPerS::tabulate(
  296|   518k|                    &|i| {
  297|   518k|                        if i < insert_pos {
  298|   513k|                            self.entries.nth(i).clone()
  299|  5.06k|                        } else if i == insert_pos {
  300|  2.58k|                            new_pair.clone()
  301|       |                        } else {
  302|  2.47k|                            self.entries.nth(i - 1).clone()
  303|       |                        }
  304|   518k|                    },
  305|  2.58k|                    self.entries.length() + 1,
  306|       |                );
  307|       |
  308|  2.58k|                TableStPer { entries }
  309|       |            }
  310|  3.56k|        }
  311|       |
  312|      3|        fn restrict(&self, keys: &ArraySetStEph<K>) -> Self {
  313|     19|            let filtered = ArraySeqStPerS::filter(&self.entries, &|pair| keys.find(&pair.0));
                              ^3         ^3                     ^3
  314|      3|            TableStPer { entries: filtered }
  315|      3|        }
  316|       |
  317|      3|        fn subtract(&self, keys: &ArraySetStEph<K>) -> Self {
  318|     19|            let filtered = ArraySeqStPerS::filter(&self.entries, &|pair| !keys.find(&pair.0));
                              ^3         ^3                     ^3
  319|      3|            TableStPer { entries: filtered }
  320|      3|        }
  321|       |
  322|    134|        fn collect(&self) -> ArraySeqStPerS<Pair<K, V>> { self.entries.clone() }
  323|       |    }
  324|       |
  325|       |    /// Helper function for creating tables from sorted entries
  326|     27|    pub fn from_sorted_entries<K: StT + Ord, V: StT>(entries: Vec<Pair<K, V>>) -> TableStPer<K, V> {
  327|     27|        TableStPer {
  328|     27|            entries: ArraySeqStPerS::from_vec(entries),
  329|     27|        }
  330|     27|    }
  331|       |
  332|       |    /// Macro for creating table literals
  333|       |    #[macro_export]
  334|       |    macro_rules! TableStPerLit {
  335|       |        () => {
  336|       |            $crate::Chap42::TableStPer::TableStPer::TableStPer::empty()
  337|       |        };
  338|       |        ($($key:expr => $value:expr),+ $(,)?) => {{
  339|       |            let mut entries = vec![$($crate::Types::Types::Pair($key, $value)),+];
  340|      9|            entries.sort_by(|a, b| a.0.cmp(&b.0));
  341|       |            $crate::Chap42::TableStPer::TableStPer::from_sorted_entries(entries)
  342|       |        }};
  343|       |    }
  344|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap43/AugOrderedTableMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Multi-threaded ephemeral reducer-augmented ordered table implementation.
    3|       |//!
    4|       |//! Note: reduce_range_parallel() uses unconditional parallelism with ParaPair! for range reductions.
    5|       |
    6|       |pub mod AugOrderedTableMtEph {
    7|       |
    8|       |    use std::fmt::{Debug, Display, Formatter, Result};
    9|       |    use std::sync::Arc;
   10|       |    use std::thread;
   11|       |
   12|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
   13|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::*;
   14|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::*;
   15|       |    use crate::Chap43::OrderedTableMtEph::OrderedTableMtEph::*;
   16|       |    use crate::OrderedTableMtEphLit;
   17|       |    use crate::ParaPair;
   18|       |    use crate::Types::Types::*;
   19|       |
   20|       |    #[derive(PartialEq, Clone)]
   21|       |    pub struct AugOrderedTableMtEph<K: MtKey, V: MtVal, F: MtReduceFn<V>> {
   22|       |        base_table: OrderedTableMtEph<K, V>,
   23|       |        reducer: F,
   24|       |        identity: V,
   25|       |        cached_reduction: V,
   26|       |    }
   27|       |
   28|       |    pub type AugOrderedTableMt<K, V, F> = AugOrderedTableMtEph<K, V, F>;
   29|       |
   30|       |    /// Trait defining all augmented ordered table operations (ADT 43.3) with multi-threaded ephemeral semantics
   31|       |    /// Extends ordered table operations with efficient reduction and thread-safe operations
   32|       |    pub trait AugOrderedTableMtEphTrait<K: MtKey, V: MtVal, F: MtReduceFn<V>> {
   33|       |        // Base table operations (ADT 42.1) - ephemeral semantics with parallelism
   34|       |        fn size(&self) -> N;
   35|       |        fn empty(reducer: F, identity: V) -> Self;
   36|       |        fn singleton(k: K, v: V, reducer: F, identity: V) -> Self;
   37|       |        fn find(&self, k: &K) -> Option<V>;
   38|       |        fn lookup(&self, k: &K) -> Option<V>;
   39|       |        fn is_empty(&self) -> B;
   40|       |        fn insert<G: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, k: K, v: V, combine: G);
   41|       |        fn delete(&mut self, k: &K) -> Option<V>;
   42|       |        fn domain(&self) -> ArraySetStEph<K>;
   43|       |        fn tabulate<G: Fn(&K) -> V + Send + Sync + 'static>(
   44|       |            f: G,
   45|       |            keys: &ArraySetStEph<K>,
   46|       |            reducer: F,
   47|       |            identity: V,
   48|       |        ) -> Self;
   49|       |        fn map<G: Fn(&K, &V) -> V + Send + Sync + 'static>(&self, f: G) -> Self;
   50|       |        fn filter<G: Fn(&K, &V) -> B + Send + Sync + 'static>(&self, f: G) -> Self;
   51|       |        fn intersection<G: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, f: G);
   52|       |        fn union<G: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, f: G);
   53|       |        fn difference(&mut self, other: &Self);
   54|       |        fn restrict(&mut self, keys: &ArraySetStEph<K>);
   55|       |        fn subtract(&mut self, keys: &ArraySetStEph<K>);
   56|       |        fn reduce<R: StTInMtT + 'static, G: Fn(R, &K, &V) -> R + Send + Sync + 'static>(&self, init: R, f: G) -> R;
   57|       |        fn collect(&self) -> AVLTreeSeqStPerS<Pair<K, V>>;
   58|       |
   59|       |        // Key ordering operations (ADT 43.1 adapted for tables) - sequential (inherently sequential on trees)
   60|       |        fn first_key(&self) -> Option<K>;
   61|       |        fn last_key(&self) -> Option<K>;
   62|       |        fn previous_key(&self, k: &K) -> Option<K>;
   63|       |        fn next_key(&self, k: &K) -> Option<K>;
   64|       |        fn split_key(&mut self, k: &K) -> (Self, Self)
   65|       |        where
   66|       |            Self: Sized;
   67|       |        fn join_key(&mut self, other: Self);
   68|       |        fn get_key_range(&self, k1: &K, k2: &K) -> Self;
   69|       |        fn rank_key(&self, k: &K) -> N;
   70|       |        fn select_key(&self, i: N) -> Option<K>;
   71|       |        fn split_rank_key(&mut self, i: N) -> (Self, Self)
   72|       |        where
   73|       |            Self: Sized;
   74|       |
   75|       |        // Augmented operations (ADT 43.3) - the key innovation with parallelism
   76|       |        /// claude-4-sonet: Work (1), Span (1)
   77|       |        /// Returns the cached reduction of all values using the reducer function
   78|       |        fn reduce_val(&self) -> V;
   79|       |
   80|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   81|       |        /// Efficient range reduction for TRAMLAW/QADSAN scenarios
   82|       |        fn reduce_range(&self, k1: &K, k2: &K) -> V;
   83|       |
   84|       |        /// claude-4-sonet: Work (log n), Span (log n) with parallel reduce_val, Parallelism (n/log n)
   85|       |        /// Parallel range reduction using spawn/join
   86|       |        fn reduce_range_parallel(&self, k1: &K, k2: &K) -> V;
   87|       |    }
   88|       |
   89|       |    impl<K: MtKey, V: MtVal, F: MtReduceFn<V>> AugOrderedTableMtEphTrait<K, V, F> for AugOrderedTableMtEph<K, V, F> {
   90|       |        /// Claude Work: O(1), Span: O(1)
   91|     36|        fn size(&self) -> N { self.base_table.size() }
   92|       |
   93|       |        /// Claude Work: O(1), Span: O(1)
   94|     32|        fn empty(reducer: F, identity: V) -> Self {
   95|     32|            Self {
   96|     32|                base_table: OrderedTableMtEph::empty(),
   97|     32|                cached_reduction: identity.clone(),
   98|     32|                reducer,
   99|     32|                identity,
  100|     32|            }
  101|     32|        }
  102|       |
  103|       |        /// Claude Work: O(1), Span: O(1)
  104|      2|        fn singleton(k: K, v: V, reducer: F, identity: V) -> Self {
  105|      2|            Self {
  106|      2|                base_table: OrderedTableMtEph::singleton(k, v.clone()),
  107|      2|                cached_reduction: v,
  108|      2|                reducer,
  109|      2|                identity,
  110|      2|            }
  111|      2|        }
  112|       |
  113|       |        /// Claude Work: O(lg n), Span: O(lg n)
  114|     37|        fn find(&self, k: &K) -> Option<V> { self.base_table.find(k) }
  115|       |
  116|       |        /// Claude Work: O(lg n), Span: O(lg n)
  117|      1|        fn lookup(&self, k: &K) -> Option<V> { self.base_table.lookup(k) }
  118|       |
  119|       |        /// Claude Work: O(1), Span: O(1)
  120|      2|        fn is_empty(&self) -> B { self.base_table.is_empty() }
  121|       |
  122|       |        /// Claude Work: O(lg n), Span: O(lg n)
  123|  2.51k|        fn insert<G: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, k: K, v: V, combine: G) {
  124|  2.51k|            let old_size = self.base_table.size();
  125|  2.51k|            self.base_table.insert(k, v.clone(), combine);
  126|       |
  127|       |            // Update cached reduction
  128|  2.51k|            if old_size == 0 {
  129|     30|                self.cached_reduction = v;
  130|  2.48k|            } else {
  131|  2.48k|                self.cached_reduction = (self.reducer)(&self.cached_reduction, &v);
  132|  2.48k|            }
  133|  2.51k|        }
  134|       |
  135|       |        /// Claude Work: O(lg n), Span: O(lg n)
  136|      5|        fn delete(&mut self, k: &K) -> Option<V> {
  137|      5|            let result = self.base_table.delete(k);
  138|       |            // Recalculate reduction after deletion
  139|      5|            self.cached_reduction = self.recalculate_reduction();
  140|      5|            result
  141|      5|        }
  142|       |
  143|       |        /// Claude Work: O(n), Span: O(lg n)
  144|      1|        fn domain(&self) -> ArraySetStEph<K> { self.base_table.domain() }
  145|       |
  146|       |        /// Claude Work: O(n), Span: O(lg n)
  147|      1|        fn tabulate<G: Fn(&K) -> V + Send + Sync + 'static>(
  148|      1|            f: G,
  149|      1|            keys: &ArraySetStEph<K>,
  150|      1|            reducer: F,
  151|      1|            identity: V,
  152|      1|        ) -> Self {
  153|      1|            let base_table = OrderedTableMtEph::tabulate(f, keys);
  154|      1|            let cached_reduction = Self::calculate_reduction(&base_table, &reducer, &identity);
  155|       |
  156|      1|            Self {
  157|      1|                base_table,
  158|      1|                cached_reduction,
  159|      1|                reducer,
  160|      1|                identity,
  161|      1|            }
  162|      1|        }
  163|       |
  164|       |        /// Claude Work: O(n), Span: O(lg n)
  165|      1|        fn map<G: Fn(&K, &V) -> V + Send + Sync + 'static>(&self, f: G) -> Self {
  166|      1|            let new_base = self.base_table.map(f);
  167|      1|            let new_reduction = Self::calculate_reduction(&new_base, &self.reducer, &self.identity);
  168|       |
  169|      1|            Self {
  170|      1|                base_table: new_base,
  171|      1|                cached_reduction: new_reduction,
  172|      1|                reducer: self.reducer.clone(),
  173|      1|                identity: self.identity.clone(),
  174|      1|            }
  175|      1|        }
  176|       |
  177|       |        /// Claude Work: O(n), Span: O(lg n)
  178|      1|        fn filter<G: Fn(&K, &V) -> B + Send + Sync + 'static>(&self, f: G) -> Self {
  179|      1|            let new_base = self.base_table.filter(f);
  180|      1|            let new_reduction = Self::calculate_reduction(&new_base, &self.reducer, &self.identity);
  181|       |
  182|      1|            Self {
  183|      1|                base_table: new_base,
  184|      1|                cached_reduction: new_reduction,
  185|      1|                reducer: self.reducer.clone(),
  186|      1|                identity: self.identity.clone(),
  187|      1|            }
  188|      1|        }
  189|       |
  190|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  191|      1|        fn intersection<G: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, f: G) {
  192|      1|            self.base_table.intersection(&other.base_table, f);
  193|      1|            self.cached_reduction = self.recalculate_reduction();
  194|      1|        }
  195|       |
  196|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  197|      1|        fn union<G: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, f: G) {
  198|      1|            self.base_table.union(&other.base_table, f);
  199|      1|            self.cached_reduction = self.recalculate_reduction();
  200|      1|        }
  201|       |
  202|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  203|      1|        fn difference(&mut self, other: &Self) {
  204|      1|            self.base_table.difference(&other.base_table);
  205|      1|            self.cached_reduction = self.recalculate_reduction();
  206|      1|        }
  207|       |
  208|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  209|      1|        fn restrict(&mut self, keys: &ArraySetStEph<K>) {
  210|      1|            self.base_table.restrict(keys);
  211|      1|            self.cached_reduction = self.recalculate_reduction();
  212|      1|        }
  213|       |
  214|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  215|      1|        fn subtract(&mut self, keys: &ArraySetStEph<K>) {
  216|      1|            self.base_table.subtract(keys);
  217|      1|            self.cached_reduction = self.recalculate_reduction();
  218|      1|        }
  219|       |
  220|       |        /// Claude Work: O(n), Span: O(lg n)
  221|      3|        fn reduce<R: StTInMtT + 'static, G: Fn(R, &K, &V) -> R + Send + Sync + 'static>(&self, init: R, f: G) -> R {
  222|      3|            self.base_table.reduce(init, f)
  223|      3|        }
  224|       |
  225|       |        /// Claude Work: O(n), Span: O(lg n)
  226|      1|        fn collect(&self) -> AVLTreeSeqStPerS<Pair<K, V>> { self.base_table.collect() }
  227|       |
  228|       |        /// Claude Work: O(lg n), Span: O(lg n)
  229|      3|        fn first_key(&self) -> Option<K> { self.base_table.first_key() }
  230|       |
  231|       |        /// Claude Work: O(lg n), Span: O(lg n)
  232|      3|        fn last_key(&self) -> Option<K> { self.base_table.last_key() }
  233|       |
  234|       |        /// Claude Work: O(lg n), Span: O(lg n)
  235|      7|        fn previous_key(&self, k: &K) -> Option<K> { self.base_table.previous_key(k) }
  236|       |
  237|       |        /// Claude Work: O(lg n), Span: O(lg n)
  238|      7|        fn next_key(&self, k: &K) -> Option<K> { self.base_table.next_key(k) }
  239|       |
  240|       |        /// Claude Work: O(lg n), Span: O(lg n)
  241|      1|        fn split_key(&mut self, k: &K) -> (Self, Self) {
  242|      1|            let (left_base, right_base) = self.base_table.split_key(k);
  243|       |
  244|      1|            let left_reduction = Self::calculate_reduction(&left_base, &self.reducer, &self.identity);
  245|      1|            let right_reduction = Self::calculate_reduction(&right_base, &self.reducer, &self.identity);
  246|       |
  247|      1|            let left = Self {
  248|      1|                base_table: left_base,
  249|      1|                cached_reduction: left_reduction,
  250|      1|                reducer: self.reducer.clone(),
  251|      1|                identity: self.identity.clone(),
  252|      1|            };
  253|       |
  254|      1|            let right = Self {
  255|      1|                base_table: right_base,
  256|      1|                cached_reduction: right_reduction,
  257|      1|                reducer: self.reducer.clone(),
  258|      1|                identity: self.identity.clone(),
  259|      1|            };
  260|       |
  261|      1|            (left, right)
  262|      1|        }
  263|       |
  264|       |        /// Claude Work: O(lg n), Span: O(lg n)
  265|      1|        fn join_key(&mut self, other: Self) {
  266|      1|            let old_reduction = self.cached_reduction.clone();
  267|      1|            let other_reduction = other.cached_reduction.clone();
  268|      1|            let other_size = other.base_table.size();
  269|       |
  270|      1|            self.base_table.join_key(other.base_table);
  271|       |
  272|       |            // Combine reductions
  273|      1|            if self.base_table.size() == 0 {
  274|      0|                self.cached_reduction = other_reduction;
  275|      1|            } else if other_size == 0 {
  276|      0|                self.cached_reduction = old_reduction;
  277|      1|            } else {
  278|      1|                self.cached_reduction = (self.reducer)(&old_reduction, &other_reduction);
  279|      1|            }
  280|      1|        }
  281|       |
  282|       |        /// Claude Work: O(lg n), Span: O(lg n)
  283|     23|        fn get_key_range(&self, k1: &K, k2: &K) -> Self {
  284|     23|            let new_base = self.base_table.get_key_range(k1, k2);
  285|     23|            let new_reduction = Self::calculate_reduction(&new_base, &self.reducer, &self.identity);
  286|       |
  287|     23|            Self {
  288|     23|                base_table: new_base,
  289|     23|                cached_reduction: new_reduction,
  290|     23|                reducer: self.reducer.clone(),
  291|     23|                identity: self.identity.clone(),
  292|     23|            }
  293|     23|        }
  294|       |
  295|       |        /// Claude Work: O(lg n), Span: O(lg n)
  296|      6|        fn rank_key(&self, k: &K) -> N { self.base_table.rank_key(k) }
  297|       |
  298|       |        /// Claude Work: O(lg n), Span: O(lg n)
  299|      8|        fn select_key(&self, i: N) -> Option<K> { self.base_table.select_key(i) }
  300|       |
  301|       |        /// Claude Work: O(lg n), Span: O(lg n)
  302|      1|        fn split_rank_key(&mut self, i: N) -> (Self, Self) {
  303|      1|            let (left_base, right_base) = self.base_table.split_rank_key(i);
  304|       |
  305|      1|            let left_reduction = Self::calculate_reduction(&left_base, &self.reducer, &self.identity);
  306|      1|            let right_reduction = Self::calculate_reduction(&right_base, &self.reducer, &self.identity);
  307|       |
  308|      1|            let left = Self {
  309|      1|                base_table: left_base,
  310|      1|                cached_reduction: left_reduction,
  311|      1|                reducer: self.reducer.clone(),
  312|      1|                identity: self.identity.clone(),
  313|      1|            };
  314|       |
  315|      1|            let right = Self {
  316|      1|                base_table: right_base,
  317|      1|                cached_reduction: right_reduction,
  318|      1|                reducer: self.reducer.clone(),
  319|      1|                identity: self.identity.clone(),
  320|      1|            };
  321|       |
  322|      1|            (left, right)
  323|      1|        }
  324|       |
  325|       |        /// Claude Work: O(1), Span: O(1)
  326|       |        /// The key innovation: O(1) reduction using cached value
  327|     68|        fn reduce_val(&self) -> V { self.cached_reduction.clone() }
  328|       |
  329|       |        /// Claude Work: O(lg n), Span: O(lg n)
  330|       |        /// Efficient range reduction for TRAMLAW/QADSAN scenarios
  331|     19|        fn reduce_range(&self, k1: &K, k2: &K) -> V {
  332|     19|            let range_table = self.get_key_range(k1, k2);
  333|     19|            range_table.reduce_val()
  334|     19|        }
  335|       |
  336|       |        /// Claude Work: O(lg n), Span: O(lg n)
  337|       |        /// Parallel range reduction using ParaPair! for unconditional parallelism
  338|      1|        fn reduce_range_parallel(&self, k1: &K, k2: &K) -> V {
  339|      1|            let range_table = self.get_key_range(k1, k2);
  340|       |
  341|       |            // Base cases
  342|      1|            if range_table.size() == 0 {
  343|      0|                return range_table.identity.clone();
  344|      1|            }
  345|      1|            if range_table.size() == 1 {
  346|      0|                return range_table.reduce_val();
  347|      1|            }
  348|       |
  349|       |            // Unconditionally parallel split using ParaPair!
  350|      1|            let mid_rank = range_table.size() / 2;
  351|      1|            if let Some(mid_key) = range_table.select_key(mid_rank) {
  352|      1|                let left_table = range_table.get_key_range(k1, &mid_key);
  353|      1|                let right_table = range_table.get_key_range(&mid_key, k2);
  354|      1|                let reducer = range_table.reducer.clone();
  355|       |
  356|      1|                let Pair(left_val, right_val) =
  357|      1|                    ParaPair!(move || left_table.reduce_val(), move || right_table.reduce_val());
  358|       |
  359|      1|                reducer(&left_val, &right_val)
  360|       |            } else {
  361|      0|                range_table.reduce_val()
  362|       |            }
  363|      1|        }
  364|       |    }
  365|       |
  366|       |    impl<K: MtKey, V: MtVal, F: MtReduceFn<V>> AugOrderedTableMtEph<K, V, F> {
  367|       |        /// Helper to recalculate reduction from current base table
  368|     10|        fn recalculate_reduction(&self) -> V {
  369|     10|            Self::calculate_reduction(&self.base_table, &self.reducer, &self.identity)
  370|     10|        }
  371|       |
  372|       |        /// Helper to calculate reduction from any base table
  373|     40|        fn calculate_reduction(base: &OrderedTableMtEph<K, V>, reducer: &F, identity: &V) -> V {
  374|     40|            if base.size() == 0 {
  375|      0|                return identity.clone();
  376|     40|            }
  377|       |
  378|     40|            let pairs = base.collect();
  379|     40|            let mut result = identity.clone();
  380|     40|            let mut first = true;
  381|       |
  382|  3.81k|            for i in 0..pairs.length() {
                                      ^40   ^40
  383|  3.81k|                let pair = pairs.nth(i);
  384|  3.81k|                if first {
  385|     40|                    result = pair.1.clone();
  386|     40|                    first = false;
  387|  3.77k|                } else {
  388|  3.77k|                    result = reducer(&result, &pair.1);
  389|  3.77k|                }
  390|       |            }
  391|       |
  392|     40|            result
  393|     40|        }
  394|       |    }
  395|       |
  396|       |    impl<K: MtKey, V: MtVal, F: MtReduceFn<V>> Display for AugOrderedTableMtEph<K, V, F> {
  397|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  398|      1|            write!(
  399|      1|                f,
  400|      1|                "AugOrderedTableMtEph(size: {}, reduction: {})",
  401|      1|                self.size(),
  402|       |                self.cached_reduction
  403|       |            )
  404|      1|        }
  405|       |    }
  406|       |
  407|       |    impl<K: MtKey, V: MtVal, F: MtReduceFn<V>> Debug for AugOrderedTableMtEph<K, V, F> {
  408|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  409|      1|            f.debug_struct("AugOrderedTableMtEph")
  410|      1|                .field("size", &self.size())
  411|      1|                .field("cached_reduction", &self.cached_reduction)
  412|      1|                .finish()
  413|      1|        }
  414|       |    }
  415|       |
  416|       |    // Macro for creating augmented ordered table literals
  417|       |    #[macro_export]
  418|       |    macro_rules! AugOrderedTableMtEphLit {
  419|       |        (reducer: $reducer:expr, identity: $identity:expr, $($k:expr => $v:expr),* $(,)?) => {{
  420|       |            let mut table = $crate::Chap43::AugOrderedTableMtEph::AugOrderedTableMtEph::AugOrderedTableMtEphTrait::empty($reducer, $identity);
  421|       |            $(
  422|      0|                $crate::Chap43::AugOrderedTableMtEph::AugOrderedTableMtEph::AugOrderedTableMtEphTrait::insert(&mut table, $k, $v, |_old, new| new.clone());
  423|       |            )*
  424|       |            table
  425|       |        }};
  426|       |        (reducer: $reducer:expr, identity: $identity:expr) => {{
  427|       |            $crate::Chap43::AugOrderedTableMtEph::AugOrderedTableMtEph::AugOrderedTableMtEphTrait::empty($reducer, $identity)
  428|       |        }};
  429|       |    }
  430|       |
  431|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap43/AugOrderedTableStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Single-threaded ephemeral reducer-augmented ordered table implementation.
    3|       |
    4|       |pub mod AugOrderedTableStEph {
    5|       |
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |
    8|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::*;
    9|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::*;
   10|       |    use crate::Chap43::OrderedTableStEph::OrderedTableStEph::*;
   11|       |    use crate::OrderedTableStEphLit;
   12|       |    use crate::Types::Types::*;
   13|       |
   14|       |    #[derive(PartialEq, Clone)]
   15|       |    pub struct AugOrderedTableStEph<K: StT + Ord, V: StT, F>
   16|       |    where
   17|       |        F: Fn(&V, &V) -> V + Clone,
   18|       |    {
   19|       |        base_table: OrderedTableStEph<K, V>,
   20|       |        reducer: F,
   21|       |        identity: V,
   22|       |        cached_reduction: V,
   23|       |    }
   24|       |
   25|       |    pub type AugOrderedTableEph<K, V, F> = AugOrderedTableStEph<K, V, F>;
   26|       |
   27|       |    /// Trait defining all augmented ordered table operations (ADT 43.3) with ephemeral semantics
   28|       |    /// Extends ordered table operations with efficient reduction and in-place mutations
   29|       |    pub trait AugOrderedTableStEphTrait<K: StT + Ord, V: StT, F>
   30|       |    where
   31|       |        F: Fn(&V, &V) -> V + Clone,
   32|       |    {
   33|       |        // Base table operations (ADT 42.1) - ephemeral semantics
   34|       |        fn size(&self) -> N;
   35|       |        fn empty(reducer: F, identity: V) -> Self;
   36|       |        fn singleton(k: K, v: V, reducer: F, identity: V) -> Self;
   37|       |        fn find(&self, k: &K) -> Option<V>;
   38|       |        fn lookup(&self, k: &K) -> Option<V>;
   39|       |        fn is_empty(&self) -> B;
   40|       |        fn insert<G: Fn(&V, &V) -> V>(&mut self, k: K, v: V, combine: G);
   41|       |        fn delete(&mut self, k: &K) -> Option<V>;
   42|       |        fn domain(&self) -> ArraySetStEph<K>;
   43|       |        fn tabulate<G: Fn(&K) -> V>(f: G, keys: &ArraySetStEph<K>, reducer: F, identity: V) -> Self;
   44|       |        fn map<G: Fn(&K, &V) -> V>(&self, f: G) -> Self;
   45|       |        fn filter<G: Fn(&K, &V) -> B>(&self, f: G) -> Self;
   46|       |        fn reduce<R, G: Fn(R, &K, &V) -> R>(&self, init: R, f: G) -> R;
   47|       |        fn intersection<G: Fn(&V, &V) -> V>(&mut self, other: &Self, f: G);
   48|       |        fn union<G: Fn(&V, &V) -> V>(&mut self, other: &Self, f: G);
   49|       |        fn difference(&mut self, other: &Self);
   50|       |        fn restrict(&mut self, keys: &ArraySetStEph<K>);
   51|       |        fn subtract(&mut self, keys: &ArraySetStEph<K>);
   52|       |        fn collect(&self) -> AVLTreeSeqStPerS<Pair<K, V>>;
   53|       |
   54|       |        // Key ordering operations (ADT 43.1 adapted for tables) - ephemeral semantics
   55|       |        fn first_key(&self) -> Option<K>;
   56|       |        fn last_key(&self) -> Option<K>;
   57|       |        fn previous_key(&self, k: &K) -> Option<K>;
   58|       |        fn next_key(&self, k: &K) -> Option<K>;
   59|       |        fn split_key(&mut self, k: &K) -> (Self, Self)
   60|       |        where
   61|       |            Self: Sized;
   62|       |        fn join_key(&mut self, other: Self);
   63|       |        fn get_key_range(&self, k1: &K, k2: &K) -> Self;
   64|       |        fn rank_key(&self, k: &K) -> N;
   65|       |        fn select_key(&self, i: N) -> Option<K>;
   66|       |        fn split_rank_key(&mut self, i: N) -> (Self, Self)
   67|       |        where
   68|       |            Self: Sized;
   69|       |
   70|       |        // Augmented operations (ADT 43.3) - the key innovation
   71|       |        /// claude-4-sonet: Work (1), Span (1)
   72|       |        /// Returns the cached reduction of all values using the reducer function
   73|       |        fn reduce_val(&self) -> V;
   74|       |
   75|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   76|       |        /// Efficient range reduction: getRange followed by reduceVal
   77|       |        fn reduce_range(&self, k1: &K, k2: &K) -> V;
   78|       |    }
   79|       |
   80|       |    impl<K: StT + Ord, V: StT, F> AugOrderedTableStEphTrait<K, V, F> for AugOrderedTableStEph<K, V, F>
   81|       |    where
   82|       |        F: Fn(&V, &V) -> V + Clone,
   83|       |    {
   84|       |        /// Claude Work: O(1), Span: O(1)
   85|     27|        fn size(&self) -> N { self.base_table.size() }
   86|       |
   87|       |        /// Claude Work: O(1), Span: O(1)
   88|     31|        fn empty(reducer: F, identity: V) -> Self {
   89|     31|            Self {
   90|     31|                base_table: OrderedTableStEph::empty(),
   91|     31|                cached_reduction: identity.clone(),
   92|     31|                reducer,
   93|     31|                identity,
   94|     31|            }
   95|     31|        }
   96|       |
   97|       |        /// Claude Work: O(1), Span: O(1)
   98|      2|        fn singleton(k: K, v: V, reducer: F, identity: V) -> Self {
   99|      2|            Self {
  100|      2|                base_table: OrderedTableStEph::singleton(k, v.clone()),
  101|      2|                cached_reduction: v,
  102|      2|                reducer,
  103|      2|                identity,
  104|      2|            }
  105|      2|        }
  106|       |
  107|       |        /// Claude Work: O(lg n), Span: O(lg n)
  108|     38|        fn find(&self, k: &K) -> Option<V> { self.base_table.find(k) }
  109|       |
  110|       |        /// Claude Work: O(lg n), Span: O(lg n)
  111|      1|        fn lookup(&self, k: &K) -> Option<V> { self.base_table.lookup(k) }
  112|       |
  113|       |        /// Claude Work: O(1), Span: O(1)
  114|      2|        fn is_empty(&self) -> B { self.base_table.is_empty() }
  115|       |
  116|       |        /// Claude Work: O(lg n), Span: O(lg n)
  117|    203|        fn insert<G: Fn(&V, &V) -> V>(&mut self, k: K, v: V, combine: G) {
  118|    203|            let old_size = self.base_table.size();
  119|    203|            self.base_table.insert(k, v.clone(), combine);
  120|       |
  121|       |            // Update cached reduction
  122|    203|            if old_size == 0 {
  123|     29|                self.cached_reduction = v;
  124|    174|            } else {
  125|    174|                self.cached_reduction = (self.reducer)(&self.cached_reduction, &v);
  126|    174|            }
  127|    203|        }
  128|       |
  129|       |        /// Claude Work: O(lg n), Span: O(lg n)
  130|      3|        fn delete(&mut self, k: &K) -> Option<V> {
  131|      3|            let result = self.base_table.delete(k);
  132|       |            // Recalculate reduction after deletion
  133|      3|            self.cached_reduction = self.recalculate_reduction();
  134|      3|            result
  135|      3|        }
  136|       |
  137|       |        /// Claude Work: O(n), Span: O(lg n)
  138|      1|        fn domain(&self) -> ArraySetStEph<K> { self.base_table.domain() }
  139|       |
  140|       |        /// Claude Work: O(n), Span: O(lg n)
  141|      1|        fn tabulate<G: Fn(&K) -> V>(f: G, keys: &ArraySetStEph<K>, reducer: F, identity: V) -> Self {
  142|      1|            let base_table = OrderedTableStEph::tabulate(f, keys);
  143|      1|            let cached_reduction = Self::calculate_reduction(&base_table, &reducer, &identity);
  144|       |
  145|      1|            Self {
  146|      1|                base_table,
  147|      1|                cached_reduction,
  148|      1|                reducer,
  149|      1|                identity,
  150|      1|            }
  151|      1|        }
  152|       |
  153|       |        /// Claude Work: O(n), Span: O(lg n)
  154|      1|        fn map<G: Fn(&K, &V) -> V>(&self, f: G) -> Self {
  155|      1|            let new_base = self.base_table.map(f);
  156|      1|            let new_reduction = Self::calculate_reduction(&new_base, &self.reducer, &self.identity);
  157|       |
  158|      1|            Self {
  159|      1|                base_table: new_base,
  160|      1|                cached_reduction: new_reduction,
  161|      1|                reducer: self.reducer.clone(),
  162|      1|                identity: self.identity.clone(),
  163|      1|            }
  164|      1|        }
  165|       |
  166|       |        /// Claude Work: O(n), Span: O(lg n)
  167|      1|        fn filter<G: Fn(&K, &V) -> B>(&self, f: G) -> Self {
  168|      1|            let new_base = self.base_table.filter(f);
  169|      1|            let new_reduction = Self::calculate_reduction(&new_base, &self.reducer, &self.identity);
  170|       |
  171|      1|            Self {
  172|      1|                base_table: new_base,
  173|      1|                cached_reduction: new_reduction,
  174|      1|                reducer: self.reducer.clone(),
  175|      1|                identity: self.identity.clone(),
  176|      1|            }
  177|      1|        }
  178|       |
  179|       |        /// Claude Work: O(n), Span: O(lg n)
  180|      3|        fn reduce<R, G: Fn(R, &K, &V) -> R>(&self, init: R, f: G) -> R { self.base_table.reduce(init, f) }
  181|       |
  182|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  183|      1|        fn intersection<G: Fn(&V, &V) -> V>(&mut self, other: &Self, f: G) {
  184|      1|            self.base_table.intersection(&other.base_table, f);
  185|      1|            self.cached_reduction = self.recalculate_reduction();
  186|      1|        }
  187|       |
  188|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  189|      1|        fn union<G: Fn(&V, &V) -> V>(&mut self, other: &Self, f: G) {
  190|      1|            self.base_table.union(&other.base_table, f);
  191|      1|            self.cached_reduction = self.recalculate_reduction();
  192|      1|        }
  193|       |
  194|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  195|      1|        fn difference(&mut self, other: &Self) {
  196|      1|            self.base_table.difference(&other.base_table);
  197|      1|            self.cached_reduction = self.recalculate_reduction();
  198|      1|        }
  199|       |
  200|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  201|      1|        fn restrict(&mut self, keys: &ArraySetStEph<K>) {
  202|      1|            self.base_table.restrict(keys);
  203|      1|            self.cached_reduction = self.recalculate_reduction();
  204|      1|        }
  205|       |
  206|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  207|      1|        fn subtract(&mut self, keys: &ArraySetStEph<K>) {
  208|      1|            self.base_table.subtract(keys);
  209|      1|            self.cached_reduction = self.recalculate_reduction();
  210|      1|        }
  211|       |
  212|       |        /// Claude Work: O(n), Span: O(lg n)
  213|      1|        fn collect(&self) -> AVLTreeSeqStPerS<Pair<K, V>> { self.base_table.collect() }
  214|       |
  215|       |        /// Claude Work: O(lg n), Span: O(lg n)
  216|      3|        fn first_key(&self) -> Option<K> { self.base_table.first_key() }
  217|       |
  218|       |        /// Claude Work: O(lg n), Span: O(lg n)
  219|      3|        fn last_key(&self) -> Option<K> { self.base_table.last_key() }
  220|       |
  221|       |        /// Claude Work: O(lg n), Span: O(lg n)
  222|      7|        fn previous_key(&self, k: &K) -> Option<K> { self.base_table.previous_key(k) }
  223|       |
  224|       |        /// Claude Work: O(lg n), Span: O(lg n)
  225|      7|        fn next_key(&self, k: &K) -> Option<K> { self.base_table.next_key(k) }
  226|       |
  227|       |        /// Claude Work: O(lg n), Span: O(lg n)
  228|      1|        fn split_key(&mut self, k: &K) -> (Self, Self) {
  229|      1|            let (left_base, right_base) = self.base_table.split_key(k);
  230|       |
  231|      1|            let left_reduction = Self::calculate_reduction(&left_base, &self.reducer, &self.identity);
  232|      1|            let right_reduction = Self::calculate_reduction(&right_base, &self.reducer, &self.identity);
  233|       |
  234|      1|            let left = Self {
  235|      1|                base_table: left_base,
  236|      1|                cached_reduction: left_reduction,
  237|      1|                reducer: self.reducer.clone(),
  238|      1|                identity: self.identity.clone(),
  239|      1|            };
  240|       |
  241|      1|            let right = Self {
  242|      1|                base_table: right_base,
  243|      1|                cached_reduction: right_reduction,
  244|      1|                reducer: self.reducer.clone(),
  245|      1|                identity: self.identity.clone(),
  246|      1|            };
  247|       |
  248|      1|            (left, right)
  249|      1|        }
  250|       |
  251|       |        /// Claude Work: O(lg n), Span: O(lg n)
  252|      1|        fn join_key(&mut self, other: Self) {
  253|      1|            let old_reduction = self.cached_reduction.clone();
  254|      1|            let other_reduction = other.cached_reduction.clone();
  255|      1|            let other_size = other.base_table.size();
  256|       |
  257|      1|            self.base_table.join_key(other.base_table);
  258|       |
  259|       |            // Combine reductions
  260|      1|            if self.base_table.size() == 0 {
  261|      0|                self.cached_reduction = other_reduction;
  262|      1|            } else if other_size == 0 {
  263|      0|                self.cached_reduction = old_reduction;
  264|      1|            } else {
  265|      1|                self.cached_reduction = (self.reducer)(&old_reduction, &other_reduction);
  266|      1|            }
  267|      1|        }
  268|       |
  269|       |        /// Claude Work: O(lg n), Span: O(lg n)
  270|      8|        fn get_key_range(&self, k1: &K, k2: &K) -> Self {
  271|      8|            let new_base = self.base_table.get_key_range(k1, k2);
  272|      8|            let new_reduction = Self::calculate_reduction(&new_base, &self.reducer, &self.identity);
  273|       |
  274|      8|            Self {
  275|      8|                base_table: new_base,
  276|      8|                cached_reduction: new_reduction,
  277|      8|                reducer: self.reducer.clone(),
  278|      8|                identity: self.identity.clone(),
  279|      8|            }
  280|      8|        }
  281|       |
  282|       |        /// Claude Work: O(lg n), Span: O(lg n)
  283|      6|        fn rank_key(&self, k: &K) -> N { self.base_table.rank_key(k) }
  284|       |
  285|       |        /// Claude Work: O(lg n), Span: O(lg n)
  286|      7|        fn select_key(&self, i: N) -> Option<K> { self.base_table.select_key(i) }
  287|       |
  288|       |        /// Claude Work: O(lg n), Span: O(lg n)
  289|      1|        fn split_rank_key(&mut self, i: N) -> (Self, Self) {
  290|      1|            let (left_base, right_base) = self.base_table.split_rank_key(i);
  291|       |
  292|      1|            let left_reduction = Self::calculate_reduction(&left_base, &self.reducer, &self.identity);
  293|      1|            let right_reduction = Self::calculate_reduction(&right_base, &self.reducer, &self.identity);
  294|       |
  295|      1|            let left = Self {
  296|      1|                base_table: left_base,
  297|      1|                cached_reduction: left_reduction,
  298|      1|                reducer: self.reducer.clone(),
  299|      1|                identity: self.identity.clone(),
  300|      1|            };
  301|       |
  302|      1|            let right = Self {
  303|      1|                base_table: right_base,
  304|      1|                cached_reduction: right_reduction,
  305|      1|                reducer: self.reducer.clone(),
  306|      1|                identity: self.identity.clone(),
  307|      1|            };
  308|       |
  309|      1|            (left, right)
  310|      1|        }
  311|       |
  312|       |        /// Claude Work: O(1), Span: O(1)
  313|       |        /// The key innovation: O(1) reduction using cached value
  314|     45|        fn reduce_val(&self) -> V { self.cached_reduction.clone() }
  315|       |
  316|       |        /// Claude Work: O(lg n), Span: O(lg n)
  317|       |        /// Efficient range reduction for TRAMLAW/QADSAN scenarios
  318|      7|        fn reduce_range(&self, k1: &K, k2: &K) -> V {
  319|      7|            let range_table = self.get_key_range(k1, k2);
  320|      7|            range_table.reduce_val()
  321|      7|        }
  322|       |    }
  323|       |
  324|       |    impl<K: StT + Ord, V: StT, F> AugOrderedTableStEph<K, V, F>
  325|       |    where
  326|       |        F: Fn(&V, &V) -> V + Clone,
  327|       |    {
  328|       |        /// Helper to recalculate reduction from current base table
  329|      8|        fn recalculate_reduction(&self) -> V {
  330|      8|            Self::calculate_reduction(&self.base_table, &self.reducer, &self.identity)
  331|      8|        }
  332|       |
  333|       |        /// Helper to calculate reduction from any base table
  334|     23|        fn calculate_reduction(base: &OrderedTableStEph<K, V>, reducer: &F, identity: &V) -> V {
  335|     23|            if base.size() == 0 {
  336|      0|                return identity.clone();
  337|     23|            }
  338|       |
  339|     23|            let pairs = base.collect();
  340|     23|            let mut result = identity.clone();
  341|     23|            let mut first = true;
  342|       |
  343|    131|            for i in 0..pairs.length() {
                                      ^23   ^23
  344|    131|                let pair = pairs.nth(i);
  345|    131|                if first {
  346|     23|                    result = pair.1.clone();
  347|     23|                    first = false;
  348|    108|                } else {
  349|    108|                    result = reducer(&result, &pair.1);
  350|    108|                }
  351|       |            }
  352|       |
  353|     23|            result
  354|     23|        }
  355|       |    }
  356|       |
  357|       |    impl<K: StT + Ord, V: StT, F> Display for AugOrderedTableStEph<K, V, F>
  358|       |    where
  359|       |        F: Fn(&V, &V) -> V + Clone,
  360|       |    {
  361|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  362|      1|            write!(
  363|      1|                f,
  364|      1|                "AugOrderedTableStEph(size: {}, reduction: {})",
  365|      1|                self.size(),
  366|       |                self.cached_reduction
  367|       |            )
  368|      1|        }
  369|       |    }
  370|       |
  371|       |    impl<K: StT + Ord, V: StT, F> Debug for AugOrderedTableStEph<K, V, F>
  372|       |    where
  373|       |        F: Fn(&V, &V) -> V + Clone,
  374|       |    {
  375|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  376|      1|            f.debug_struct("AugOrderedTableStEph")
  377|      1|                .field("size", &self.size())
  378|      1|                .field("cached_reduction", &self.cached_reduction)
  379|      1|                .finish()
  380|      1|        }
  381|       |    }
  382|       |
  383|       |    // Macro for creating augmented ordered table literals
  384|       |    #[macro_export]
  385|       |    macro_rules! AugOrderedTableStEphLit {
  386|       |        (reducer: $reducer:expr, identity: $identity:expr, $($k:expr => $v:expr),* $(,)?) => {{
  387|       |            let mut table = $crate::Chap43::AugOrderedTableStEph::AugOrderedTableStEph::AugOrderedTableStEphTrait::empty($reducer, $identity);
  388|       |            $(
  389|      0|                $crate::Chap43::AugOrderedTableStEph::AugOrderedTableStEph::AugOrderedTableStEphTrait::insert(&mut table, $k, $v, |_old, new| new.clone());
  390|       |            )*
  391|       |            table
  392|       |        }};
  393|       |        (reducer: $reducer:expr, identity: $identity:expr) => {{
  394|       |            $crate::Chap43::AugOrderedTableStEph::AugOrderedTableStEph::AugOrderedTableStEphTrait::empty($reducer, $identity)
  395|       |        }};
  396|       |    }
  397|       |
  398|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap43/AugOrderedTableStPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Single-threaded persistent reducer-augmented ordered table implementation.
    3|       |
    4|       |pub mod AugOrderedTableStPer {
    5|       |
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |
    8|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::*;
    9|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::*;
   10|       |    use crate::Chap43::OrderedTableStPer::OrderedTableStPer::*;
   11|       |    use crate::OrderedTableStPerLit;
   12|       |    use crate::Types::Types::*;
   13|       |
   14|       |    #[derive(PartialEq, Clone)]
   15|       |    pub struct AugOrderedTableStPer<K: StT + Ord, V: StT, F>
   16|       |    where
   17|       |        F: Fn(&V, &V) -> V + Clone,
   18|       |    {
   19|       |        base_table: OrderedTableStPer<K, V>,
   20|       |        reducer: F,
   21|       |        identity: V,
   22|       |        cached_reduction: V,
   23|       |    }
   24|       |
   25|       |    pub type AugOrderedTablePer<K, V, F> = AugOrderedTableStPer<K, V, F>;
   26|       |
   27|       |    /// Trait defining all augmented ordered table operations (ADT 43.3)
   28|       |    /// Extends ordered table operations with efficient reduction
   29|       |    pub trait AugOrderedTableStPerTrait<K: StT + Ord, V: StT, F>
   30|       |    where
   31|       |        F: Fn(&V, &V) -> V + Clone,
   32|       |    {
   33|       |        // Base table operations (ADT 42.1) - delegated to OrderedTableStPer
   34|       |        fn size(&self) -> N;
   35|       |        fn empty(reducer: F, identity: V) -> Self;
   36|       |        fn singleton(k: K, v: V, reducer: F, identity: V) -> Self;
   37|       |        fn find(&self, k: &K) -> Option<V>;
   38|       |        fn insert(&self, k: K, v: V) -> Self;
   39|       |        fn delete(&self, k: &K) -> Self;
   40|       |        fn domain(&self) -> ArraySetStEph<K>;
   41|       |        fn tabulate<G: Fn(&K) -> V>(f: G, keys: &ArraySetStEph<K>, reducer: F, identity: V) -> Self;
   42|       |        fn map<G: Fn(&V) -> V>(&self, f: G) -> Self;
   43|       |        fn filter<G: Fn(&K, &V) -> B>(&self, f: G) -> Self;
   44|       |        fn intersection<G: Fn(&V, &V) -> V>(&self, other: &Self, f: G) -> Self;
   45|       |        fn union<G: Fn(&V, &V) -> V>(&self, other: &Self, f: G) -> Self;
   46|       |        fn difference(&self, other: &Self) -> Self;
   47|       |        fn restrict(&self, keys: &ArraySetStEph<K>) -> Self;
   48|       |        fn subtract(&self, keys: &ArraySetStEph<K>) -> Self;
   49|       |        fn collect(&self) -> AVLTreeSeqStPerS<Pair<K, V>>;
   50|       |
   51|       |        // Key ordering operations (ADT 43.1 adapted for tables)
   52|       |        fn first_key(&self) -> Option<K>;
   53|       |        fn last_key(&self) -> Option<K>;
   54|       |        fn previous_key(&self, k: &K) -> Option<K>;
   55|       |        fn next_key(&self, k: &K) -> Option<K>;
   56|       |        fn split_key(&self, k: &K) -> (Self, Option<V>, Self)
   57|       |        where
   58|       |            Self: Sized;
   59|       |        fn join_key(left: &Self, right: &Self) -> Self;
   60|       |        fn get_key_range(&self, k1: &K, k2: &K) -> Self;
   61|       |        fn rank_key(&self, k: &K) -> N;
   62|       |        fn select_key(&self, i: N) -> Option<K>;
   63|       |        fn split_rank_key(&self, i: N) -> (Self, Self)
   64|       |        where
   65|       |            Self: Sized;
   66|       |
   67|       |        // Augmented operations (ADT 43.3) - the key innovation
   68|       |        /// claude-4-sonet: Work (1), Span (1)
   69|       |        /// Returns the cached reduction of all values using the reducer function
   70|       |        fn reduce_val(&self) -> V;
   71|       |
   72|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   73|       |        /// Efficient range reduction: getRange followed by reduceVal
   74|       |        fn reduce_range(&self, k1: &K, k2: &K) -> V;
   75|       |    }
   76|       |
   77|       |    impl<K: StT + Ord, V: StT, F> AugOrderedTableStPerTrait<K, V, F> for AugOrderedTableStPer<K, V, F>
   78|       |    where
   79|       |        F: Fn(&V, &V) -> V + Clone,
   80|       |    {
   81|       |        /// Claude Work: O(1), Span: O(1)
   82|     25|        fn size(&self) -> N { self.base_table.size() }
   83|       |
   84|       |        /// Claude Work: O(1), Span: O(1)
   85|     27|        fn empty(reducer: F, identity: V) -> Self {
   86|     27|            Self {
   87|     27|                base_table: OrderedTableStPer::empty(),
   88|     27|                cached_reduction: identity.clone(),
   89|     27|                reducer,
   90|     27|                identity,
   91|     27|            }
   92|     27|        }
   93|       |
   94|       |        /// Claude Work: O(1), Span: O(1)
   95|      2|        fn singleton(k: K, v: V, reducer: F, identity: V) -> Self {
   96|      2|            Self {
   97|      2|                base_table: OrderedTableStPer::singleton(k, v.clone()),
   98|      2|                cached_reduction: v,
   99|      2|                reducer,
  100|      2|                identity,
  101|      2|            }
  102|      2|        }
  103|       |
  104|       |        /// Claude Work: O(lg n), Span: O(lg n)
  105|     40|        fn find(&self, k: &K) -> Option<V> { self.base_table.find(k) }
  106|       |
  107|       |        /// Claude Work: O(lg n), Span: O(lg n)
  108|    172|        fn insert(&self, k: K, v: V) -> Self {
  109|    172|            let new_base = self.base_table.insert(k, v.clone());
  110|    172|            let new_reduction = if self.base_table.size() == 0 {
  111|     25|                v
  112|       |            } else {
  113|    147|                (self.reducer)(&self.cached_reduction, &v)
  114|       |            };
  115|       |
  116|    172|            Self {
  117|    172|                base_table: new_base,
  118|    172|                cached_reduction: new_reduction,
  119|    172|                reducer: self.reducer.clone(),
  120|    172|                identity: self.identity.clone(),
  121|    172|            }
  122|    172|        }
  123|       |
  124|       |        /// Claude Work: O(lg n), Span: O(lg n)
  125|      2|        fn delete(&self, k: &K) -> Self {
  126|      2|            let new_base = self.base_table.delete(k);
  127|       |            // For simplicity, recalculate reduction from scratch
  128|       |            // In practice, would maintain augmented tree structure
  129|      2|            let new_reduction = self.recalculate_reduction(&new_base);
  130|       |
  131|      2|            Self {
  132|      2|                base_table: new_base,
  133|      2|                cached_reduction: new_reduction,
  134|      2|                reducer: self.reducer.clone(),
  135|      2|                identity: self.identity.clone(),
  136|      2|            }
  137|      2|        }
  138|       |
  139|       |        /// Claude Work: O(n), Span: O(lg n)
  140|      1|        fn domain(&self) -> ArraySetStEph<K> { self.base_table.domain() }
  141|       |
  142|       |        /// Claude Work: O(n), Span: O(lg n)
  143|      1|        fn tabulate<G: Fn(&K) -> V>(f: G, keys: &ArraySetStEph<K>, reducer: F, identity: V) -> Self {
  144|      1|            let base_table = OrderedTableStPer::tabulate(f, keys);
  145|      1|            let cached_reduction = Self::calculate_reduction(&base_table, &reducer, &identity);
  146|       |
  147|      1|            Self {
  148|      1|                base_table,
  149|      1|                cached_reduction,
  150|      1|                reducer,
  151|      1|                identity,
  152|      1|            }
  153|      1|        }
  154|       |
  155|       |        /// Claude Work: O(n), Span: O(lg n)
  156|      1|        fn map<G: Fn(&V) -> V>(&self, f: G) -> Self {
  157|      1|            let new_base = self.base_table.map(f);
  158|      1|            let new_reduction = self.recalculate_reduction(&new_base);
  159|       |
  160|      1|            Self {
  161|      1|                base_table: new_base,
  162|      1|                cached_reduction: new_reduction,
  163|      1|                reducer: self.reducer.clone(),
  164|      1|                identity: self.identity.clone(),
  165|      1|            }
  166|      1|        }
  167|       |
  168|       |        /// Claude Work: O(n), Span: O(lg n)
  169|      1|        fn filter<G: Fn(&K, &V) -> B>(&self, f: G) -> Self {
  170|      1|            let new_base = self.base_table.filter(f);
  171|      1|            let new_reduction = self.recalculate_reduction(&new_base);
  172|       |
  173|      1|            Self {
  174|      1|                base_table: new_base,
  175|      1|                cached_reduction: new_reduction,
  176|      1|                reducer: self.reducer.clone(),
  177|      1|                identity: self.identity.clone(),
  178|      1|            }
  179|      1|        }
  180|       |
  181|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  182|      1|        fn intersection<G: Fn(&V, &V) -> V>(&self, other: &Self, f: G) -> Self {
  183|      1|            let new_base = self.base_table.intersection(&other.base_table, f);
  184|      1|            let new_reduction = self.recalculate_reduction(&new_base);
  185|       |
  186|      1|            Self {
  187|      1|                base_table: new_base,
  188|      1|                cached_reduction: new_reduction,
  189|      1|                reducer: self.reducer.clone(),
  190|      1|                identity: self.identity.clone(),
  191|      1|            }
  192|      1|        }
  193|       |
  194|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  195|      1|        fn union<G: Fn(&V, &V) -> V>(&self, other: &Self, f: G) -> Self {
  196|      1|            let new_base = self.base_table.union(&other.base_table, f);
  197|      1|            let new_reduction = self.recalculate_reduction(&new_base);
  198|       |
  199|      1|            Self {
  200|      1|                base_table: new_base,
  201|      1|                cached_reduction: new_reduction,
  202|      1|                reducer: self.reducer.clone(),
  203|      1|                identity: self.identity.clone(),
  204|      1|            }
  205|      1|        }
  206|       |
  207|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  208|      1|        fn difference(&self, other: &Self) -> Self {
  209|      1|            let new_base = self.base_table.difference(&other.base_table);
  210|      1|            let new_reduction = self.recalculate_reduction(&new_base);
  211|       |
  212|      1|            Self {
  213|      1|                base_table: new_base,
  214|      1|                cached_reduction: new_reduction,
  215|      1|                reducer: self.reducer.clone(),
  216|      1|                identity: self.identity.clone(),
  217|      1|            }
  218|      1|        }
  219|       |
  220|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  221|      1|        fn restrict(&self, keys: &ArraySetStEph<K>) -> Self {
  222|      1|            let new_base = self.base_table.restrict(keys);
  223|      1|            let new_reduction = self.recalculate_reduction(&new_base);
  224|       |
  225|      1|            Self {
  226|      1|                base_table: new_base,
  227|      1|                cached_reduction: new_reduction,
  228|      1|                reducer: self.reducer.clone(),
  229|      1|                identity: self.identity.clone(),
  230|      1|            }
  231|      1|        }
  232|       |
  233|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  234|      1|        fn subtract(&self, keys: &ArraySetStEph<K>) -> Self {
  235|      1|            let new_base = self.base_table.subtract(keys);
  236|      1|            let new_reduction = self.recalculate_reduction(&new_base);
  237|       |
  238|      1|            Self {
  239|      1|                base_table: new_base,
  240|      1|                cached_reduction: new_reduction,
  241|      1|                reducer: self.reducer.clone(),
  242|      1|                identity: self.identity.clone(),
  243|      1|            }
  244|      1|        }
  245|       |
  246|       |        /// Claude Work: O(n), Span: O(lg n)
  247|      1|        fn collect(&self) -> AVLTreeSeqStPerS<Pair<K, V>> { self.base_table.collect() }
  248|       |
  249|       |        /// Claude Work: O(lg n), Span: O(lg n)
  250|      3|        fn first_key(&self) -> Option<K> { self.base_table.first_key() }
  251|       |
  252|       |        /// Claude Work: O(lg n), Span: O(lg n)
  253|      3|        fn last_key(&self) -> Option<K> { self.base_table.last_key() }
  254|       |
  255|       |        /// Claude Work: O(lg n), Span: O(lg n)
  256|      1|        fn previous_key(&self, k: &K) -> Option<K> { self.base_table.previous_key(k) }
  257|       |
  258|       |        /// Claude Work: O(lg n), Span: O(lg n)
  259|      1|        fn next_key(&self, k: &K) -> Option<K> { self.base_table.next_key(k) }
  260|       |
  261|       |        /// Claude Work: O(lg n), Span: O(lg n)
  262|      1|        fn split_key(&self, k: &K) -> (Self, Option<V>, Self) {
  263|      1|            let (left_base, middle, right_base) = self.base_table.split_key(k);
  264|       |
  265|      1|            let left_reduction = self.recalculate_reduction(&left_base);
  266|      1|            let right_reduction = self.recalculate_reduction(&right_base);
  267|       |
  268|      1|            let left = Self {
  269|      1|                base_table: left_base,
  270|      1|                cached_reduction: left_reduction,
  271|      1|                reducer: self.reducer.clone(),
  272|      1|                identity: self.identity.clone(),
  273|      1|            };
  274|       |
  275|      1|            let right = Self {
  276|      1|                base_table: right_base,
  277|      1|                cached_reduction: right_reduction,
  278|      1|                reducer: self.reducer.clone(),
  279|      1|                identity: self.identity.clone(),
  280|      1|            };
  281|       |
  282|      1|            (left, middle, right)
  283|      1|        }
  284|       |
  285|       |        /// Claude Work: O(lg n), Span: O(lg n)
  286|      1|        fn join_key(left: &Self, right: &Self) -> Self {
  287|      1|            let new_base = OrderedTableStPer::join_key(&left.base_table, &right.base_table);
  288|      1|            let new_reduction = if left.base_table.size() == 0 {
  289|      0|                right.cached_reduction.clone()
  290|      1|            } else if right.base_table.size() == 0 {
  291|      0|                left.cached_reduction.clone()
  292|       |            } else {
  293|      1|                (left.reducer)(&left.cached_reduction, &right.cached_reduction)
  294|       |            };
  295|       |
  296|      1|            Self {
  297|      1|                base_table: new_base,
  298|      1|                cached_reduction: new_reduction,
  299|      1|                reducer: left.reducer.clone(),
  300|      1|                identity: left.identity.clone(),
  301|      1|            }
  302|      1|        }
  303|       |
  304|       |        /// Claude Work: O(lg n), Span: O(lg n)
  305|      7|        fn get_key_range(&self, k1: &K, k2: &K) -> Self {
  306|      7|            let new_base = self.base_table.get_key_range(k1, k2);
  307|      7|            let new_reduction = self.recalculate_reduction(&new_base);
  308|       |
  309|      7|            Self {
  310|      7|                base_table: new_base,
  311|      7|                cached_reduction: new_reduction,
  312|      7|                reducer: self.reducer.clone(),
  313|      7|                identity: self.identity.clone(),
  314|      7|            }
  315|      7|        }
  316|       |
  317|       |        /// Claude Work: O(lg n), Span: O(lg n)
  318|      1|        fn rank_key(&self, k: &K) -> N { self.base_table.rank_key(k) }
  319|       |
  320|       |        /// Claude Work: O(lg n), Span: O(lg n)
  321|      1|        fn select_key(&self, i: N) -> Option<K> { self.base_table.select_key(i) }
  322|       |
  323|       |        /// Claude Work: O(lg n), Span: O(lg n)
  324|      1|        fn split_rank_key(&self, i: N) -> (Self, Self) {
  325|      1|            let (left_base, right_base) = self.base_table.split_rank_key(i);
  326|       |
  327|      1|            let left_reduction = self.recalculate_reduction(&left_base);
  328|      1|            let right_reduction = self.recalculate_reduction(&right_base);
  329|       |
  330|      1|            let left = Self {
  331|      1|                base_table: left_base,
  332|      1|                cached_reduction: left_reduction,
  333|      1|                reducer: self.reducer.clone(),
  334|      1|                identity: self.identity.clone(),
  335|      1|            };
  336|       |
  337|      1|            let right = Self {
  338|      1|                base_table: right_base,
  339|      1|                cached_reduction: right_reduction,
  340|      1|                reducer: self.reducer.clone(),
  341|      1|                identity: self.identity.clone(),
  342|      1|            };
  343|       |
  344|      1|            (left, right)
  345|      1|        }
  346|       |
  347|       |        /// Claude Work: O(1), Span: O(1)
  348|       |        /// The key innovation: O(1) reduction using cached value
  349|     37|        fn reduce_val(&self) -> V { self.cached_reduction.clone() }
  350|       |
  351|       |        /// Claude Work: O(lg n), Span: O(lg n)
  352|       |        /// Efficient range reduction for TRAMLAW/QADSAN scenarios
  353|      6|        fn reduce_range(&self, k1: &K, k2: &K) -> V {
  354|      6|            let range_table = self.get_key_range(k1, k2);
  355|      6|            range_table.reduce_val()
  356|      6|        }
  357|       |    }
  358|       |
  359|       |    impl<K: StT + Ord, V: StT, F> AugOrderedTableStPer<K, V, F>
  360|       |    where
  361|       |        F: Fn(&V, &V) -> V + Clone,
  362|       |    {
  363|       |        /// Helper to recalculate reduction from base table
  364|     20|        fn recalculate_reduction(&self, base: &OrderedTableStPer<K, V>) -> V {
  365|     20|            Self::calculate_reduction(base, &self.reducer, &self.identity)
  366|     20|        }
  367|       |
  368|       |        /// Helper to calculate reduction from any base table
  369|     21|        fn calculate_reduction(base: &OrderedTableStPer<K, V>, reducer: &F, identity: &V) -> V {
  370|     21|            if base.size() == 0 {
  371|      0|                return identity.clone();
  372|     21|            }
  373|       |
  374|     21|            let pairs = base.collect();
  375|     21|            let mut result = identity.clone();
  376|     21|            let mut first = true;
  377|       |
  378|    120|            for i in 0..pairs.length() {
                                      ^21   ^21
  379|    120|                let pair = pairs.nth(i);
  380|    120|                if first {
  381|     21|                    result = pair.1.clone();
  382|     21|                    first = false;
  383|     99|                } else {
  384|     99|                    result = reducer(&result, &pair.1);
  385|     99|                }
  386|       |            }
  387|       |
  388|     21|            result
  389|     21|        }
  390|       |    }
  391|       |
  392|       |    impl<K: StT + Ord, V: StT, F> Display for AugOrderedTableStPer<K, V, F>
  393|       |    where
  394|       |        F: Fn(&V, &V) -> V + Clone,
  395|       |    {
  396|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  397|      1|            write!(
  398|      1|                f,
  399|      1|                "AugOrderedTableStPer(size: {}, reduction: {})",
  400|      1|                self.size(),
  401|       |                self.cached_reduction
  402|       |            )
  403|      1|        }
  404|       |    }
  405|       |
  406|       |    impl<K: StT + Ord, V: StT, F> Debug for AugOrderedTableStPer<K, V, F>
  407|       |    where
  408|       |        F: Fn(&V, &V) -> V + Clone,
  409|       |    {
  410|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  411|      1|            f.debug_struct("AugOrderedTableStPer")
  412|      1|                .field("size", &self.size())
  413|      1|                .field("cached_reduction", &self.cached_reduction)
  414|      1|                .finish()
  415|      1|        }
  416|       |    }
  417|       |
  418|       |    // Macro for creating augmented ordered table literals
  419|       |    #[macro_export]
  420|       |    macro_rules! AugOrderedTableStPerLit {
  421|       |        (reducer: $reducer:expr, identity: $identity:expr, $($k:expr => $v:expr),* $(,)?) => {{
  422|       |            let mut table = $crate::Chap43::AugOrderedTableStPer::AugOrderedTableStPer::AugOrderedTableStPerTrait::empty($reducer, $identity);
  423|       |            $(
  424|       |                table = $crate::Chap43::AugOrderedTableStPer::AugOrderedTableStPer::AugOrderedTableStPerTrait::insert(&table, $k, $v);
  425|       |            )*
  426|       |            table
  427|       |        }};
  428|       |        (reducer: $reducer:expr, identity: $identity:expr) => {{
  429|       |            $crate::Chap43::AugOrderedTableStPer::AugOrderedTableStPer::AugOrderedTableStPerTrait::empty($reducer, $identity)
  430|       |        }};
  431|       |    }
  432|       |
  433|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap43/Example43_1.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Example 43.1 from the textbook demonstrating ordered set operations.
    3|       |
    4|       |pub mod Example43_1 {
    5|       |
    6|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::AVLTreeSeqStPerTrait;
    7|       |    use crate::Chap43::OrderedSetStPer::OrderedSetStPer::*;
    8|       |    use crate::OrderedSetStPerLit;
    9|       |    use crate::Types::Types::*;
   10|       |
   11|       |    pub trait Example43_1Trait {
   12|       |        /// Demonstrates Example 43.1 from the textbook with lexicographic ordering
   13|       |        /// APAS: Work (n log n), Span (log n)
   14|       |        fn run_example43_1();
   15|       |
   16|       |        /// Demonstrate ordered set operations
   17|       |        /// APAS: Work (n log n), Span (log n)
   18|       |        fn demonstrate_ordered_operations();
   19|       |    }
   20|       |
   21|       |    /// Demonstrates Example 43.1 from the textbook with lexicographic ordering
   22|      7|    pub fn run_example43_1() {
   23|      7|        println!("=== Example 43.1: Ordered Set Operations ===");
   24|       |
   25|       |        // Create the ordered set A = {'artie', 'burt', 'finn', 'mike', 'rachel', 'sam', 'tina'}
   26|      7|        let set_a: OrderedSetStPer<String> = OrderedSetStPerLit![
   27|      7|            "artie".to_string(),
   28|      7|            "burt".to_string(),
   29|      7|            "finn".to_string(),
   30|      7|            "mike".to_string(),
   31|      7|            "rachel".to_string(),
   32|      7|            "sam".to_string(),
   33|      7|            "tina".to_string()
   34|       |        ];
   35|       |
   36|      7|        print!("Set A: [");
   37|      7|        let seq = set_a.to_seq();
   38|     49|        for i in 0..seq.length() {
                                  ^7  ^7
   39|     49|            if i > 0 {
   40|     42|                print!(", ");
   41|     42|            }
                          ^7
   42|     49|            print!("\"{}\"", seq.nth(i));
   43|       |        }
   44|      7|        println!("]");
   45|       |
   46|       |        // first A  'artie'
   47|      7|        match set_a.first() {
   48|      7|            | Some(first) => println!("first(A) = '{}'", first),
   49|      0|            | None => println!("first(A) = "),
   50|       |        }
   51|       |
   52|       |        // next(A, 'quinn')  'rachel'
   53|      7|        match set_a.next(&"quinn".to_string()) {
   54|      7|            | Some(next_elem) => println!("next(A, 'quinn') = '{}'", next_elem),
   55|      0|            | None => println!("next(A, 'quinn') = "),
   56|       |        }
   57|       |
   58|       |        // next(A, 'mike')  'rachel'
   59|      7|        match set_a.next(&"mike".to_string()) {
   60|      7|            | Some(next_elem) => println!("next(A, 'mike') = '{}'", next_elem),
   61|      0|            | None => println!("next(A, 'mike') = "),
   62|       |        }
   63|       |
   64|       |        // getRange A ('burt', 'mike')  {'burt', 'finn', 'mike'}
   65|      7|        let range_set = set_a.get_range(&"burt".to_string(), &"mike".to_string());
   66|      7|        print!("getRange(A, 'burt', 'mike') = [");
   67|      7|        let seq = range_set.to_seq();
   68|     21|        for i in 0..seq.length() {
                                  ^7  ^7
   69|     21|            if i > 0 {
   70|     14|                print!(", ");
   71|     14|            }
                          ^7
   72|     21|            print!("\"{}\"", seq.nth(i));
   73|       |        }
   74|      7|        println!("]");
   75|       |
   76|       |        // rank(A, 'rachel')  4
   77|      7|        let rachel_rank = set_a.rank(&"rachel".to_string());
   78|      7|        println!("rank(A, 'rachel') = {}", rachel_rank);
   79|       |
   80|       |        // rank(A, 'quinn')  4 (elements less than 'quinn')
   81|      7|        let quinn_rank = set_a.rank(&"quinn".to_string());
   82|      7|        println!("rank(A, 'quinn') = {}", quinn_rank);
   83|       |
   84|       |        // select(A, 5)  'sam'
   85|      7|        match set_a.select(5) {
   86|      7|            | Some(selected) => println!("select(A, 5) = '{}'", selected),
   87|      0|            | None => println!("select(A, 5) = "),
   88|       |        }
   89|       |
   90|       |        // splitRank(A, 3)  ({'artie', 'burt', 'finn'}, {'mike', 'rachel', 'sam', 'tina'})
   91|      7|        let (left_set, right_set) = set_a.split_rank(3);
   92|      7|        println!("splitRank(A, 3) = (");
   93|      7|        print!("  left: [");
   94|      7|        let seq = left_set.to_seq();
   95|     21|        for i in 0..seq.length() {
                                  ^7  ^7
   96|     21|            if i > 0 {
   97|     14|                print!(", ");
   98|     14|            }
                          ^7
   99|     21|            print!("\"{}\"", seq.nth(i));
  100|       |        }
  101|      7|        println!("],");
  102|      7|        print!("  right: [");
  103|      7|        let seq = right_set.to_seq();
  104|     28|        for i in 0..seq.length() {
                                  ^7  ^7
  105|     28|            if i > 0 {
  106|     21|                print!(", ");
  107|     21|            }
                          ^7
  108|     28|            print!("\"{}\"", seq.nth(i));
  109|       |        }
  110|      7|        println!("]");
  111|      7|        println!(")");
  112|       |
  113|       |        // Additional demonstrations of other ordering operations
  114|      7|        println!("\n=== Additional Ordering Operations ===");
  115|       |
  116|       |        // last A  'tina'
  117|      7|        match set_a.last() {
  118|      7|            | Some(last) => println!("last(A) = '{}'", last),
  119|      0|            | None => println!("last(A) = "),
  120|       |        }
  121|       |
  122|       |        // previous(A, 'rachel')  'mike'
  123|      7|        match set_a.previous(&"rachel".to_string()) {
  124|      7|            | Some(prev) => println!("previous(A, 'rachel') = '{}'", prev),
  125|      0|            | None => println!("previous(A, 'rachel') = "),
  126|       |        }
  127|       |
  128|       |        // split(A, 'mike')  ({'artie', 'burt', 'finn'}, true, {'rachel', 'sam', 'tina'})
  129|      7|        let (left_split, found, right_split) = set_a.split(&"mike".to_string());
  130|      7|        println!("split(A, 'mike') = (");
  131|      7|        print!("  left: [");
  132|      7|        let seq = left_split.to_seq();
  133|     21|        for i in 0..seq.length() {
                                  ^7  ^7
  134|     21|            if i > 0 {
  135|     14|                print!(", ");
  136|     14|            }
                          ^7
  137|     21|            print!("\"{}\"", seq.nth(i));
  138|       |        }
  139|      7|        println!("],");
  140|      7|        println!("  found: {},", found);
  141|      7|        print!("  right: [");
  142|      7|        let seq = right_split.to_seq();
  143|     21|        for i in 0..seq.length() {
                                  ^7  ^7
  144|     21|            if i > 0 {
  145|     14|                print!(", ");
  146|     14|            }
                          ^7
  147|     21|            print!("\"{}\"", seq.nth(i));
  148|       |        }
  149|      7|        println!("]");
  150|      7|        println!(")");
  151|       |
  152|       |        // Demonstrate join operation
  153|      7|        let joined_set = OrderedSetStPer::join(&left_split, &right_split);
  154|      7|        print!("join(left, right) = [");
  155|      7|        let seq = joined_set.to_seq();
  156|     42|        for i in 0..seq.length() {
                                  ^7  ^7
  157|     42|            if i > 0 {
  158|     35|                print!(", ");
  159|     35|            }
                          ^7
  160|     42|            print!("\"{}\"", seq.nth(i));
  161|       |        }
  162|      7|        println!("]");
  163|       |
  164|      7|        println!("\n=== Example 43.1 Complete ===");
  165|      7|    }
  166|       |
  167|       |    /// Demonstrates ordering operations with integer sets for additional clarity
  168|      0|    pub fn run_integer_example() {
  169|      0|        println!("\n=== Integer Ordered Set Example ===");
  170|       |
  171|       |        // Create an ordered set of integers
  172|      0|        let int_set: OrderedSetStPer<i32> = OrderedSetStPerLit![1, 3, 5, 7, 9, 11, 13];
  173|       |
  174|      0|        print!("Integer Set: [");
  175|      0|        let seq = int_set.to_seq();
  176|      0|        for i in 0..seq.length() {
  177|      0|            if i > 0 {
  178|      0|                print!(", ");
  179|      0|            }
  180|      0|            print!("{}", seq.nth(i));
  181|       |        }
  182|      0|        println!("]");
  183|       |
  184|       |        // Demonstrate all ordering operations
  185|      0|        println!("first() = {:?}", int_set.first());
  186|      0|        println!("last() = {:?}", int_set.last());
  187|      0|        println!("previous(7) = {:?}", int_set.previous(&7));
  188|      0|        println!("next(7) = {:?}", int_set.next(&7));
  189|      0|        println!("rank(7) = {}", int_set.rank(&7));
  190|      0|        println!("select(3) = {:?}", int_set.select(3));
  191|       |
  192|      0|        let range = int_set.get_range(&3, &9);
  193|      0|        print!("getRange(3, 9) = [");
  194|      0|        let seq = range.to_seq();
  195|      0|        for i in 0..seq.length() {
  196|      0|            if i > 0 {
  197|      0|                print!(", ");
  198|      0|            }
  199|      0|            print!("{}", seq.nth(i));
  200|       |        }
  201|      0|        println!("]");
  202|       |
  203|      0|        let (left, right) = int_set.split_rank(4);
  204|      0|        print!("splitRank(4) = ([");
  205|      0|        let seq = left.to_seq();
  206|      0|        for i in 0..seq.length() {
  207|      0|            if i > 0 {
  208|      0|                print!(", ");
  209|      0|            }
  210|      0|            print!("{}", seq.nth(i));
  211|       |        }
  212|      0|        print!("], [");
  213|      0|        let seq = right.to_seq();
  214|      0|        for i in 0..seq.length() {
  215|      0|            if i > 0 {
  216|      0|                print!(", ");
  217|      0|            }
  218|      0|            print!("{}", seq.nth(i));
  219|       |        }
  220|      0|        println!("])");
  221|       |
  222|      0|        println!("=== Integer Example Complete ===");
  223|      0|    }
  224|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap43/OrderedSetMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Multi-threaded ephemeral ordered set implementation using custom backing store.
    3|       |
    4|       |pub mod OrderedSetMtEph {
    5|       |
    6|       |    use std::sync::Arc;
    7|       |    use std::thread;
    8|       |
    9|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    #[derive(PartialEq)]
   13|       |    pub struct OrderedSetMtEph<T: MtKey> {
   14|       |        elements: Vec<T>,
   15|       |    }
   16|       |
   17|       |    pub type OrderedSetMt<T> = OrderedSetMtEph<T>;
   18|       |
   19|       |    /// Trait defining all ordered set operations (ADT 41.1 + ADT 43.1) with multi-threaded ephemeral semantics
   20|       |    pub trait OrderedSetMtEphTrait<T: MtKey> {
   21|       |        // Base set operations (ADT 41.1) - ephemeral semantics with parallelism
   22|       |        /// claude-4-sonet: Work (1), Span (1)
   23|       |        fn size(&self) -> N;
   24|       |        /// claude-4-sonet: Work (1), Span (1)
   25|       |        fn empty() -> Self;
   26|       |        /// claude-4-sonet: Work (1), Span (1)
   27|       |        fn singleton(x: T) -> Self;
   28|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   29|       |        fn find(&self, x: &T) -> B;
   30|       |        /// claude-4-sonet: Work (n), Span (log n), Parallelism (n/log n)
   31|       |        fn insert(&mut self, x: T);
   32|       |        /// claude-4-sonet: Work (n), Span (log n), Parallelism (n/log n)
   33|       |        fn delete(&mut self, x: &T);
   34|       |        /// claude-4-sonet: Work (n), Span (log n), Parallelism (n/log n)
   35|       |        fn filter<F: Pred<T>>(&mut self, f: F);
   36|       |        /// claude-4-sonet: Work (m + n), Span (log(m + n)), Parallelism ((m+n)/log(m+n))
   37|       |        fn intersection(&mut self, other: &Self);
   38|       |        /// claude-4-sonet: Work (m + n), Span (log(m + n)), Parallelism ((m+n)/log(m+n))
   39|       |        fn union(&mut self, other: &Self);
   40|       |        /// claude-4-sonet: Work (m + n), Span (log(m + n)), Parallelism ((m+n)/log(m+n))
   41|       |        fn difference(&mut self, other: &Self);
   42|       |        /// claude-4-sonet: Work (n), Span (log n), Parallelism (n/log n)
   43|       |        fn to_seq(&self) -> AVLTreeSeqStPerS<T>;
   44|       |        /// claude-4-sonet: Work (n log n), Span (log n), Parallelism (n)
   45|       |        fn from_seq(seq: AVLTreeSeqStPerS<T>) -> Self;
   46|       |
   47|       |        // Ordering operations (ADT 43.1) - sequential (inherently sequential on trees)
   48|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   49|       |        fn first(&self) -> Option<T>;
   50|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   51|       |        fn last(&self) -> Option<T>;
   52|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   53|       |        fn previous(&self, k: &T) -> Option<T>;
   54|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   55|       |        fn next(&self, k: &T) -> Option<T>;
   56|       |        /// claude-4-sonet: Work (n), Span (log n), Parallelism (n/log n)
   57|       |        fn split(&mut self, k: &T) -> (Self, B, Self)
   58|       |        where
   59|       |            Self: Sized;
   60|       |        /// claude-4-sonet: Work (m + n), Span (log(m + n)), Parallelism ((m+n)/log(m+n))
   61|       |        fn join(&mut self, other: Self);
   62|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   63|       |        fn get_range(&self, k1: &T, k2: &T) -> Self;
   64|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   65|       |        fn rank(&self, k: &T) -> N;
   66|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   67|       |        fn select(&self, i: N) -> Option<T>;
   68|       |        /// claude-4-sonet: Work (n), Span (log n), Parallelism (n/log n)
   69|       |        fn split_rank(&mut self, i: N) -> (Self, Self)
   70|       |        where
   71|       |            Self: Sized;
   72|       |    }
   73|       |
   74|       |    impl<T: MtKey> OrderedSetMtEphTrait<T> for OrderedSetMtEph<T> {
   75|       |        /// Claude Work: O(1), Span: O(1)
   76|     27|        fn size(&self) -> N { self.elements.len() }
   77|       |
   78|       |        /// Claude Work: O(1), Span: O(1)
   79|     33|        fn empty() -> Self { OrderedSetMtEph { elements: Vec::new() } }
   80|       |
   81|       |        /// Claude Work: O(1), Span: O(1)
   82|      1|        fn singleton(x: T) -> Self { OrderedSetMtEph { elements: vec![x] } }
   83|       |
   84|       |        /// Claude Work: O(log n), Span: O(log n)
   85|    221|        fn find(&self, x: &T) -> B { self.elements.binary_search(x).is_ok() }
   86|       |
   87|       |        /// Claude Work: O(n), Span: O(log n)
   88|    266|        fn insert(&mut self, x: T) {
   89|    266|            match self.elements.binary_search(&x) {
   90|      0|                | Ok(_) => {} // Element already exists
   91|    266|                | Err(pos) => {
   92|    266|                    self.elements.insert(pos, x);
   93|    266|                }
   94|       |            }
   95|    266|        }
   96|       |
   97|       |        /// Claude Work: O(n), Span: O(log n)
   98|      2|        fn delete(&mut self, x: &T) {
   99|      2|            if let Ok(pos) = self.elements.binary_search(x) {
  100|      2|                self.elements.remove(pos);
  101|      2|            }
                          ^0
  102|      2|        }
  103|       |
  104|       |        /// Claude Work: O(n), Span: O(log n)
  105|    145|        fn filter<F: Fn(&T) -> B + Send + Sync + 'static>(&mut self, f: F) { self.elements.retain(|x| f(x)); }
                      ^3                                                                   ^3            ^3                ^3
  106|       |
  107|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  108|      4|        fn intersection(&mut self, other: &Self) { self.elements.retain(|elem| other.find(elem)); }
                      ^1                                         ^1            ^1                               ^1
  109|       |
  110|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  111|      3|        fn union(&mut self, other: &Self) {
  112|       |            // Simple sequential implementation for correctness
  113|     28|            for elem in &other.elements {
                              ^25
  114|     25|                if !self.find(elem) {
  115|     24|                    self.insert(elem.clone());
  116|     24|                }
                              ^1
  117|       |            }
  118|      3|        }
  119|       |
  120|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  121|      1|        fn difference(&mut self, other: &Self) {
  122|       |            // Simple sequential implementation for correctness
  123|      4|            self.elements.retain(|elem| !other.find(elem));
                          ^1            ^1
  124|      1|        }
  125|       |
  126|       |        /// Claude Work: O(n), Span: O(log n)
  127|      0|        fn to_seq(&self) -> AVLTreeSeqStPerS<T> { AVLTreeSeqStPerS::from_vec(self.elements.clone()) }
  128|       |
  129|       |        /// Claude Work: O(n log n), Span: O(log n)
  130|      0|        fn from_seq(seq: AVLTreeSeqStPerS<T>) -> Self {
  131|      0|            let len = seq.length();
  132|      0|            let mut elements = Vec::new();
  133|      0|            for i in 0..len {
  134|      0|                elements.push(seq.nth(i).clone());
  135|      0|            }
  136|      0|            elements.sort();
  137|      0|            elements.dedup();
  138|      0|            OrderedSetMtEph { elements }
  139|      0|        }
  140|       |
  141|       |        // Ordering operations (ADT 43.1)
  142|       |
  143|       |        /// Claude Work: O(1), Span: O(1)
  144|      6|        fn first(&self) -> Option<T> { self.elements.first().cloned() }
  145|       |
  146|       |        /// Claude Work: O(1), Span: O(1)
  147|      6|        fn last(&self) -> Option<T> { self.elements.last().cloned() }
  148|       |
  149|       |        /// Claude Work: O(log n), Span: O(log n)
  150|      7|        fn previous(&self, k: &T) -> Option<T> {
  151|      7|            match self.elements.binary_search(k) {
  152|      3|                | Ok(pos) => {
  153|      3|                    if pos > 0 {
  154|      2|                        Some(self.elements[pos - 1].clone())
  155|       |                    } else {
  156|      1|                        None
  157|       |                    }
  158|       |                }
  159|      4|                | Err(pos) => {
  160|      4|                    if pos > 0 {
  161|      3|                        Some(self.elements[pos - 1].clone())
  162|       |                    } else {
  163|      1|                        None
  164|       |                    }
  165|       |                }
  166|       |            }
  167|      7|        }
  168|       |
  169|       |        /// Claude Work: O(log n), Span: O(log n)
  170|      8|        fn next(&self, k: &T) -> Option<T> {
  171|      8|            match self.elements.binary_search(k) {
  172|      4|                | Ok(pos) => {
  173|      4|                    if pos + 1 < self.elements.len() {
  174|      3|                        Some(self.elements[pos + 1].clone())
  175|       |                    } else {
  176|      1|                        None
  177|       |                    }
  178|       |                }
  179|      4|                | Err(pos) => {
  180|      4|                    if pos < self.elements.len() {
  181|      3|                        Some(self.elements[pos].clone())
  182|       |                    } else {
  183|      1|                        None
  184|       |                    }
  185|       |                }
  186|       |            }
  187|      8|        }
  188|       |
  189|       |        /// Claude Work: O(log n), Span: O(log n)
  190|      2|        fn split(&mut self, k: &T) -> (Self, B, Self) {
  191|      2|            let pos = match self.elements.binary_search(k) {
  192|      2|                | Ok(pos) => pos,
  193|      0|                | Err(pos) => pos,
  194|       |            };
  195|       |
  196|      2|            let found = self.elements.get(pos) == Some(k);
  197|      2|            let right_elements: Vec<T> = self.elements.drain(pos..).collect();
  198|      2|            let left_elements = std::mem::take(&mut self.elements);
  199|       |
  200|      2|            let mut right_elements_filtered = right_elements;
  201|      2|            if found {
  202|      2|                right_elements_filtered.remove(0); // Remove the found element
  203|      2|            }
                          ^0
  204|       |
  205|      2|            *self = Self::empty();
  206|      2|            (
  207|      2|                OrderedSetMtEph {
  208|      2|                    elements: left_elements,
  209|      2|                },
  210|      2|                found,
  211|      2|                OrderedSetMtEph {
  212|      2|                    elements: right_elements_filtered,
  213|      2|                },
  214|      2|            )
  215|      2|        }
  216|       |
  217|       |        /// Claude Work: O(log(m + n)), Span: O(log(m + n))
  218|      1|        fn join(&mut self, other: Self) { self.union(&other); }
  219|       |
  220|       |        /// Claude Work: O(log n), Span: O(log n)
  221|      2|        fn get_range(&self, k1: &T, k2: &T) -> Self {
  222|      2|            let start_pos = match self.elements.binary_search(k1) {
  223|      1|                | Ok(pos) => pos,
  224|      1|                | Err(pos) => pos,
  225|       |            };
  226|      2|            let end_pos = match self.elements.binary_search(k2) {
  227|      1|                | Ok(pos) => pos + 1,
  228|      1|                | Err(pos) => pos,
  229|       |            };
  230|       |
  231|      2|            let range_elements = self.elements[start_pos..end_pos].to_vec();
  232|      2|            OrderedSetMtEph {
  233|      2|                elements: range_elements,
  234|      2|            }
  235|      2|        }
  236|       |
  237|       |        /// Claude Work: O(log n), Span: O(log n)
  238|      6|        fn rank(&self, k: &T) -> N {
  239|      6|            match self.elements.binary_search(k) {
  240|      2|                | Ok(pos) => pos,
  241|      4|                | Err(pos) => pos,
  242|       |            }
  243|      6|        }
  244|       |
  245|       |        /// Claude Work: O(1), Span: O(1)
  246|      6|        fn select(&self, i: N) -> Option<T> { self.elements.get(i).cloned() }
  247|       |
  248|       |        /// Claude Work: O(log n), Span: O(log n)
  249|      1|        fn split_rank(&mut self, i: N) -> (Self, Self) {
  250|      1|            let right_elements: Vec<T> = self.elements.drain(i..).collect();
  251|      1|            let left_elements = std::mem::take(&mut self.elements);
  252|       |
  253|      1|            *self = Self::empty();
  254|      1|            (
  255|      1|                OrderedSetMtEph {
  256|      1|                    elements: left_elements,
  257|      1|                },
  258|      1|                OrderedSetMtEph {
  259|      1|                    elements: right_elements,
  260|      1|                },
  261|      1|            )
  262|      1|        }
  263|       |    }
  264|       |
  265|       |    /// Macro for creating ordered sets from literals
  266|       |    #[macro_export]
  267|       |    macro_rules! OrderedSetMtEphLit {
  268|       |        ($($x:expr),* $(,)?) => {
  269|       |            {
  270|       |                let mut set = $crate::Chap43::OrderedSetMtEph::OrderedSetMtEph::OrderedSetMtEph::empty();
  271|       |                $(
  272|       |                    set.insert($x);
  273|       |                )*
  274|       |                set
  275|       |            }
  276|       |        };
  277|       |    }
  278|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap43/OrderedSetStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Single-threaded ephemeral ordered set implementation extending AVLTreeSetStEph.
    3|       |
    4|       |pub mod OrderedSetStEph {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::*;
    8|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::*;
    9|       |    use crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    #[derive(PartialEq)]
   13|       |    pub struct OrderedSetStEph<T: StT + Ord> {
   14|       |        base_set: AVLTreeSetStEph<T>,
   15|       |    }
   16|       |
   17|       |    pub type OrderedSetEph<T> = OrderedSetStEph<T>;
   18|       |
   19|       |    /// Trait defining all ordered set operations (ADT 41.1 + ADT 43.1) with ephemeral semantics
   20|       |    pub trait OrderedSetStEphTrait<T: StT + Ord> {
   21|       |        // Base set operations (ADT 41.1) - ephemeral semantics
   22|       |        /// claude-4-sonet: Work (1), Span (1)
   23|       |        fn size(&self) -> N;
   24|       |        /// claude-4-sonet: Work (1), Span (1)
   25|       |        fn empty() -> Self;
   26|       |        /// claude-4-sonet: Work (1), Span (1)
   27|       |        fn singleton(x: T) -> Self;
   28|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   29|       |        fn find(&self, x: &T) -> B;
   30|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   31|       |        fn insert(&mut self, x: T);
   32|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   33|       |        fn delete(&mut self, x: &T);
   34|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   35|       |        fn filter<F: Fn(&T) -> B>(&mut self, f: F);
   36|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   37|       |        fn intersection(&mut self, other: &Self);
   38|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   39|       |        fn union(&mut self, other: &Self);
   40|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   41|       |        fn difference(&mut self, other: &Self);
   42|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   43|       |        fn to_seq(&self) -> AVLTreeSeqStPerS<T>;
   44|       |        /// claude-4-sonet: Work (n log n), Span (n log n), Parallelism (1)
   45|       |        fn from_seq(seq: AVLTreeSeqStPerS<T>) -> Self;
   46|       |
   47|       |        // Ordering operations (ADT 43.1)
   48|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   49|       |        fn first(&self) -> Option<T>;
   50|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   51|       |        fn last(&self) -> Option<T>;
   52|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   53|       |        fn previous(&self, k: &T) -> Option<T>;
   54|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   55|       |        fn next(&self, k: &T) -> Option<T>;
   56|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   57|       |        fn split(&mut self, k: &T) -> (Self, B, Self)
   58|       |        where
   59|       |            Self: Sized;
   60|       |        /// claude-4-sonet: Work (log(|self| + |other|)), Span (log(|self| + |other|)), Parallelism (1)
   61|       |        fn join(&mut self, other: Self);
   62|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   63|       |        fn get_range(&self, k1: &T, k2: &T) -> Self;
   64|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   65|       |        fn rank(&self, k: &T) -> N;
   66|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   67|       |        fn select(&self, i: N) -> Option<T>;
   68|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   69|       |        fn split_rank(&mut self, i: N) -> (Self, Self)
   70|       |        where
   71|       |            Self: Sized;
   72|       |    }
   73|       |
   74|       |    impl<T: StT + Ord> OrderedSetStEphTrait<T> for OrderedSetStEph<T> {
   75|       |        // Base set operations - delegate to backing store with ephemeral semantics
   76|       |
   77|       |        /// Claude Work: O(1), Span: O(1)
   78|     33|        fn size(&self) -> N { self.base_set.size() }
   79|       |
   80|       |        /// Claude Work: O(1), Span: O(1)
   81|     28|        fn empty() -> Self {
   82|     28|            OrderedSetStEph {
   83|     28|                base_set: AVLTreeSetStEph::empty(),
   84|     28|            }
   85|     28|        }
   86|       |
   87|       |        /// Claude Work: O(1), Span: O(1)
   88|      1|        fn singleton(x: T) -> Self {
   89|      1|            OrderedSetStEph {
   90|      1|                base_set: AVLTreeSetStEph::singleton(x),
   91|      1|            }
   92|      1|        }
   93|       |
   94|       |        /// Claude Work: O(log n), Span: O(log n)
   95|     58|        fn find(&self, x: &T) -> B { self.base_set.find(x) }
   96|       |
   97|       |        /// Claude Work: O(log n), Span: O(log n)
   98|     87|        fn insert(&mut self, x: T) { self.base_set.insert(x); }
   99|       |
  100|       |        /// Claude Work: O(log n), Span: O(log n)
  101|      2|        fn delete(&mut self, x: &T) { self.base_set.delete(x); }
  102|       |
  103|       |        /// Claude Work: O(n), Span: O(log n)
  104|      1|        fn filter<F: Fn(&T) -> B>(&mut self, f: F) {
  105|      1|            let result = self.base_set.filter(f);
  106|      1|            self.base_set = result;
  107|      1|        }
  108|       |
  109|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  110|      1|        fn intersection(&mut self, other: &Self) {
  111|      1|            let result = self.base_set.intersection(&other.base_set);
  112|      1|            self.base_set = result;
  113|      1|        }
  114|       |
  115|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  116|      2|        fn union(&mut self, other: &Self) {
  117|      2|            let result = self.base_set.union(&other.base_set);
  118|      2|            self.base_set = result;
  119|      2|        }
  120|       |
  121|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  122|      1|        fn difference(&mut self, other: &Self) {
  123|      1|            let result = self.base_set.difference(&other.base_set);
  124|      1|            self.base_set = result;
  125|      1|        }
  126|       |
  127|       |        /// Claude Work: O(n), Span: O(log n)
  128|     38|        fn to_seq(&self) -> AVLTreeSeqStPerS<T> {
  129|       |            // Convert ephemeral sequence to persistent sequence
  130|     38|            let eph_seq = self.base_set.to_seq();
  131|     38|            let len = eph_seq.length();
  132|     38|            let mut elements = Vec::new();
  133|    172|            for i in 0..len {
                                      ^38
  134|    172|                elements.push(eph_seq.nth(i).clone());
  135|    172|            }
  136|     38|            AVLTreeSeqStPerS::from_vec(elements)
  137|     38|        }
  138|       |
  139|       |        /// Claude Work: O(n log n), Span: O(log n)
  140|      9|        fn from_seq(seq: AVLTreeSeqStPerS<T>) -> Self {
  141|       |            // Convert persistent sequence to ephemeral sequence
  142|      9|            let len = seq.length();
  143|      9|            let mut elements = Vec::new();
  144|     19|            for i in 0..len {
                                      ^9
  145|     19|                elements.push(seq.nth(i).clone());
  146|     19|            }
  147|      9|            let eph_seq = AVLTreeSeqStEphS::from_vec(elements);
  148|      9|            OrderedSetStEph {
  149|      9|                base_set: AVLTreeSetStEph::from_seq(eph_seq),
  150|      9|            }
  151|      9|        }
  152|       |
  153|       |        // Ordering operations (ADT 43.1)
  154|       |
  155|       |        /// Claude Work: O(log n), Span: O(log n)
  156|      5|        fn first(&self) -> Option<T> {
  157|      5|            if self.size() == 0 {
  158|      2|                None
  159|       |            } else {
  160|      3|                let seq = self.to_seq();
  161|      3|                Some(seq.nth(0).clone())
  162|       |            }
  163|      5|        }
  164|       |
  165|       |        /// Claude Work: O(log n), Span: O(log n)
  166|      5|        fn last(&self) -> Option<T> {
  167|      5|            let size = self.size();
  168|      5|            if size == 0 {
  169|      2|                None
  170|       |            } else {
  171|      3|                let seq = self.to_seq();
  172|      3|                Some(seq.nth(size - 1).clone())
  173|       |            }
  174|      5|        }
  175|       |
  176|       |        /// Claude Work: O(log n), Span: O(log n)
  177|      7|        fn previous(&self, k: &T) -> Option<T> {
  178|      7|            let seq = self.to_seq();
  179|      7|            let size = seq.length();
  180|       |
  181|     25|            for i in (0..size).rev() {
                                   ^7        ^7
  182|     25|                let elem = seq.nth(i);
  183|     25|                if elem < k {
  184|      5|                    return Some(elem.clone());
  185|     20|                }
  186|       |            }
  187|      2|            None
  188|      7|        }
  189|       |
  190|       |        /// Claude Work: O(log n), Span: O(log n)
  191|      8|        fn next(&self, k: &T) -> Option<T> {
  192|      8|            let seq = self.to_seq();
  193|      8|            let size = seq.length();
  194|       |
  195|     26|            for i in 0..size {
                                      ^8
  196|     26|                let elem = seq.nth(i);
  197|     26|                if elem > k {
  198|      6|                    return Some(elem.clone());
  199|     20|                }
  200|       |            }
  201|      2|            None
  202|      8|        }
  203|       |
  204|       |        /// Claude Work: O(log n), Span: O(log n)
  205|      2|        fn split(&mut self, k: &T) -> (Self, B, Self) {
  206|      2|            let seq = self.to_seq();
  207|       |
  208|       |            // Convert to ArraySeqStPerS for filtering operations
  209|      8|            let array_seq = ArraySeqStPerS::tabulate(&|i| seq.nth(i).clone(), seq.length());
                              ^2          ^2                                                ^2  ^2
  210|       |
  211|       |            // Use proper sequence filter operations
  212|      8|            let left_array = ArraySeqStPerS::filter(&array_seq, &|elem| elem < k);
                              ^2           ^2                     ^2
  213|      8|            let right_array = ArraySeqStPerS::filter(&array_seq, &|elem| elem > k);
                              ^2            ^2                     ^2
  214|      8|            let found = ArraySeqStPerS::filter(&array_seq, &|elem| elem == k).length() > 0;
                              ^2      ^2                     ^2                             ^2
  215|       |
  216|       |            // Convert back to AVLTreeSeqStPerS
  217|      2|            let left_seq = AVLTreeSeqStPerS::from_vec(left_array.into_iter().collect());
  218|      2|            let right_seq = AVLTreeSeqStPerS::from_vec(right_array.into_iter().collect());
  219|       |
  220|       |            // Clear current set (ephemeral behavior)
  221|      2|            *self = Self::empty();
  222|       |
  223|      2|            (Self::from_seq(left_seq), found, Self::from_seq(right_seq))
  224|      2|        }
  225|       |
  226|       |        /// Claude Work: O(log(m + n)), Span: O(log(m + n))
  227|      1|        fn join(&mut self, other: Self) { self.union(&other); }
  228|       |
  229|       |        /// Claude Work: O(log n), Span: O(log n)
  230|      2|        fn get_range(&self, k1: &T, k2: &T) -> Self {
  231|      2|            let seq = self.to_seq();
  232|       |
  233|       |            // Convert to ArraySeqStPerS for filtering operations
  234|     10|            let array_seq = ArraySeqStPerS::tabulate(&|i| seq.nth(i).clone(), seq.length());
                              ^2          ^2                                                ^2  ^2
  235|       |
  236|       |            // Use proper sequence filter operation
  237|     10|            let range_array = ArraySeqStPerS::filter(&array_seq, &|elem| elem >= k1 && elem <= k2);
                              ^2            ^2                     ^2                                ^4
  238|       |
  239|       |            // Convert back to AVLTreeSeqStPerS
  240|      2|            let range_seq = AVLTreeSeqStPerS::from_vec(range_array.into_iter().collect());
  241|      2|            Self::from_seq(range_seq)
  242|      2|        }
  243|       |
  244|       |        /// Claude Work: O(log n), Span: O(log n)
  245|      6|        fn rank(&self, k: &T) -> N {
  246|      6|            let seq = self.to_seq();
  247|      6|            let size = seq.length();
  248|      6|            let mut count = 0;
  249|       |
  250|     16|            for i in 0..size {
                                      ^6
  251|     16|                let elem = seq.nth(i);
  252|     16|                if elem < k {
  253|     11|                    count += 1;
  254|     11|                } else {
  255|      5|                    break;
  256|       |                }
  257|       |            }
  258|      6|            count
  259|      6|        }
  260|       |
  261|       |        /// Claude Work: O(log n), Span: O(log n)
  262|      6|        fn select(&self, i: N) -> Option<T> {
  263|      6|            let seq = self.to_seq();
  264|      6|            if i >= seq.length() {
  265|      1|                None
  266|       |            } else {
  267|      5|                Some(seq.nth(i).clone())
  268|       |            }
  269|      6|        }
  270|       |
  271|       |        /// Claude Work: O(log n), Span: O(log n)
  272|      1|        fn split_rank(&mut self, i: N) -> (Self, Self) {
  273|      1|            let seq = self.to_seq();
  274|      1|            let size = seq.length();
  275|       |
  276|      1|            if i >= size {
  277|      0|                let current = self.clone();
  278|      0|                *self = Self::empty();
  279|      0|                return (current, Self::empty());
  280|      1|            }
  281|       |
  282|      1|            let mut left_elements = Vec::new();
  283|      1|            let mut right_elements = Vec::new();
  284|       |
  285|      2|            for j in 0..i {
                                      ^1
  286|      2|                left_elements.push(seq.nth(j).clone());
  287|      2|            }
  288|      3|            for j in i..size {
                                   ^1 ^1
  289|      3|                right_elements.push(seq.nth(j).clone());
  290|      3|            }
  291|       |
  292|      1|            let left_seq = AVLTreeSeqStPerS::from_vec(left_elements);
  293|      1|            let right_seq = AVLTreeSeqStPerS::from_vec(right_elements);
  294|       |
  295|       |            // Clear current set (ephemeral behavior)
  296|      1|            *self = Self::empty();
  297|       |
  298|      1|            (Self::from_seq(left_seq), Self::from_seq(right_seq))
  299|      1|        }
  300|       |    }
  301|       |
  302|       |    impl<T: StT + Ord> Clone for OrderedSetStEph<T> {
  303|      0|        fn clone(&self) -> Self {
  304|      0|            OrderedSetStEph {
  305|      0|                base_set: self.base_set.clone(),
  306|      0|            }
  307|      0|        }
  308|       |    }
  309|       |
  310|       |    /// Helper function for macro construction
  311|      1|    pub fn from_sorted_elements<T: StT + Ord>(elements: Vec<T>) -> OrderedSetStEph<T> {
  312|      1|        let seq = AVLTreeSeqStPerS::from_vec(elements);
  313|      1|        OrderedSetStEph::from_seq(seq)
  314|      1|    }
  315|       |
  316|       |    /// Macro for creating ephemeral ordered sets from sorted element lists
  317|       |    #[macro_export]
  318|       |    macro_rules! OrderedSetStEphLit {
  319|       |        () => {
  320|       |            $crate::Chap43::OrderedSetStEph::OrderedSetStEph::OrderedSetStEph::empty()
  321|       |        };
  322|       |        ($($elem:expr),+ $(,)?) => {
  323|       |            $crate::Chap43::OrderedSetStEph::OrderedSetStEph::from_sorted_elements(vec![$($elem),+])
  324|       |        };
  325|       |    }
  326|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap43/OrderedSetStPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Single-threaded persistent ordered set implementation extending AVLTreeSetStPer.
    3|       |
    4|       |pub mod OrderedSetStPer {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::*;
    8|       |    use crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::*;
    9|       |    use crate::Types::Types::*;
   10|       |
   11|       |    #[derive(PartialEq)]
   12|       |    pub struct OrderedSetStPer<T: StT + Ord> {
   13|       |        base_set: AVLTreeSetStPer<T>,
   14|       |    }
   15|       |
   16|       |    pub type OrderedSetPer<T> = OrderedSetStPer<T>;
   17|       |
   18|       |    /// Trait defining all ordered set operations (ADT 41.1 + ADT 43.1)
   19|       |    pub trait OrderedSetStPerTrait<T: StT + Ord> {
   20|       |        // Base set operations (ADT 41.1) - delegated
   21|       |        /// claude-4-sonet: Work (1), Span (1)
   22|       |        fn size(&self) -> N;
   23|       |        /// claude-4-sonet: Work (1), Span (1)
   24|       |        fn empty() -> Self;
   25|       |        /// claude-4-sonet: Work (1), Span (1)
   26|       |        fn singleton(x: T) -> Self;
   27|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   28|       |        fn find(&self, x: &T) -> B;
   29|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   30|       |        fn insert(&self, x: T) -> Self;
   31|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   32|       |        fn delete(&self, x: &T) -> Self;
   33|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   34|       |        fn filter<F: Fn(&T) -> B>(&self, f: F) -> Self;
   35|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   36|       |        fn intersection(&self, other: &Self) -> Self;
   37|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   38|       |        fn union(&self, other: &Self) -> Self;
   39|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   40|       |        fn difference(&self, other: &Self) -> Self;
   41|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   42|       |        fn to_seq(&self) -> AVLTreeSeqStPerS<T>;
   43|       |        /// claude-4-sonet: Work (n log n), Span (n log n), Parallelism (1)
   44|       |        fn from_seq(seq: AVLTreeSeqStPerS<T>) -> Self;
   45|       |
   46|       |        // Ordering operations (ADT 43.1)
   47|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   48|       |        fn first(&self) -> Option<T>;
   49|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   50|       |        fn last(&self) -> Option<T>;
   51|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   52|       |        fn previous(&self, k: &T) -> Option<T>;
   53|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   54|       |        fn next(&self, k: &T) -> Option<T>;
   55|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   56|       |        fn split(&self, k: &T) -> (Self, B, Self)
   57|       |        where
   58|       |            Self: Sized;
   59|       |        /// claude-4-sonet: Work (log(|left| + |right|)), Span (log(|left| + |right|)), Parallelism (1)
   60|       |        fn join(left: &Self, right: &Self) -> Self;
   61|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   62|       |        fn get_range(&self, k1: &T, k2: &T) -> Self;
   63|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   64|       |        fn rank(&self, k: &T) -> N;
   65|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   66|       |        fn select(&self, i: N) -> Option<T>;
   67|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   68|       |        fn split_rank(&self, i: N) -> (Self, Self)
   69|       |        where
   70|       |            Self: Sized;
   71|       |    }
   72|       |
   73|       |    impl<T: StT + Ord> OrderedSetStPerTrait<T> for OrderedSetStPer<T> {
   74|       |        // Base set operations - delegate to backing store
   75|       |
   76|       |        /// Claude Work: O(1), Span: O(1)
   77|     50|        fn size(&self) -> N { self.base_set.size() }
   78|       |
   79|       |        /// Claude Work: O(1), Span: O(1)
   80|     25|        fn empty() -> Self {
   81|     25|            OrderedSetStPer {
   82|     25|                base_set: AVLTreeSetStPer::empty(),
   83|     25|            }
   84|     25|        }
   85|       |
   86|       |        /// Claude Work: O(1), Span: O(1)
   87|      1|        fn singleton(x: T) -> Self {
   88|      1|            OrderedSetStPer {
   89|      1|                base_set: AVLTreeSetStPer::singleton(x),
   90|      1|            }
   91|      1|        }
   92|       |
   93|       |        /// Claude Work: O(log n), Span: O(log n)
   94|     70|        fn find(&self, x: &T) -> B { self.base_set.find(x) }
   95|       |
   96|       |        /// Claude Work: O(log n), Span: O(log n)
   97|     84|        fn insert(&self, x: T) -> Self {
   98|     84|            OrderedSetStPer {
   99|     84|                base_set: self.base_set.insert(x),
  100|     84|            }
  101|     84|        }
  102|       |
  103|       |        /// Claude Work: O(log n), Span: O(log n)
  104|      2|        fn delete(&self, x: &T) -> Self {
  105|      2|            OrderedSetStPer {
  106|      2|                base_set: self.base_set.delete(x),
  107|      2|            }
  108|      2|        }
  109|       |
  110|       |        /// Claude Work: O(n), Span: O(log n)
  111|      1|        fn filter<F: Fn(&T) -> B>(&self, f: F) -> Self {
  112|      1|            OrderedSetStPer {
  113|      1|                base_set: self.base_set.filter(f),
  114|      1|            }
  115|      1|        }
  116|       |
  117|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  118|      1|        fn intersection(&self, other: &Self) -> Self {
  119|      1|            OrderedSetStPer {
  120|      1|                base_set: self.base_set.intersection(&other.base_set),
  121|      1|            }
  122|      1|        }
  123|       |
  124|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  125|      9|        fn union(&self, other: &Self) -> Self {
  126|      9|            OrderedSetStPer {
  127|      9|                base_set: self.base_set.union(&other.base_set),
  128|      9|            }
  129|      9|        }
  130|       |
  131|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  132|      1|        fn difference(&self, other: &Self) -> Self {
  133|      1|            OrderedSetStPer {
  134|      1|                base_set: self.base_set.difference(&other.base_set),
  135|      1|            }
  136|      1|        }
  137|       |
  138|       |        /// Claude Work: O(n), Span: O(log n)
  139|    166|        fn to_seq(&self) -> AVLTreeSeqStPerS<T> { self.base_set.to_seq() }
  140|       |
  141|       |        /// Claude Work: O(n log n), Span: O(log n)
  142|     53|        fn from_seq(seq: AVLTreeSeqStPerS<T>) -> Self {
  143|     53|            OrderedSetStPer {
  144|     53|                base_set: AVLTreeSetStPer::from_seq(seq),
  145|     53|            }
  146|     53|        }
  147|       |
  148|       |        // Ordering operations (ADT 43.1)
  149|       |
  150|       |        /// Claude Work: O(log n), Span: O(log n)
  151|     12|        fn first(&self) -> Option<T> {
  152|     12|            if self.size() == 0 {
  153|      2|                None
  154|       |            } else {
  155|     10|                let seq = self.to_seq();
  156|     10|                Some(seq.nth(0).clone())
  157|       |            }
  158|     12|        }
  159|       |
  160|       |        /// Claude Work: O(log n), Span: O(log n)
  161|     12|        fn last(&self) -> Option<T> {
  162|     12|            let size = self.size();
  163|     12|            if size == 0 {
  164|      2|                None
  165|       |            } else {
  166|     10|                let seq = self.to_seq();
  167|     10|                Some(seq.nth(size - 1).clone())
  168|       |            }
  169|     12|        }
  170|       |
  171|       |        /// Claude Work: O(log n), Span: O(log n)
  172|     14|        fn previous(&self, k: &T) -> Option<T> {
  173|     14|            let seq = self.to_seq();
  174|     14|            let size = seq.length();
  175|       |
  176|     53|            for i in (0..size).rev() {
                                   ^14       ^14
  177|     53|                let elem = seq.nth(i);
  178|     53|                if elem < k {
  179|     12|                    return Some(elem.clone());
  180|     41|                }
  181|       |            }
  182|      2|            None
  183|     14|        }
  184|       |
  185|       |        /// Claude Work: O(log n), Span: O(log n)
  186|     22|        fn next(&self, k: &T) -> Option<T> {
  187|     22|            let seq = self.to_seq();
  188|     22|            let size = seq.length();
  189|       |
  190|     96|            for i in 0..size {
                                      ^22
  191|     96|                let elem = seq.nth(i);
  192|     96|                if elem > k {
  193|     20|                    return Some(elem.clone());
  194|     76|                }
  195|       |            }
  196|      2|            None
  197|     22|        }
  198|       |
  199|       |        /// Claude Work: O(log n), Span: O(log n)
  200|      9|        fn split(&self, k: &T) -> (Self, B, Self) {
  201|      9|            let seq = self.to_seq();
  202|       |
  203|       |            // Convert to ArraySeqStPerS for filtering operations
  204|     59|            let array_seq = ArraySeqStPerS::tabulate(&|i| seq.nth(i).clone(), seq.length());
                              ^9          ^9                                                ^9  ^9
  205|       |
  206|       |            // Use proper sequence filter operations
  207|     59|            let left_array = ArraySeqStPerS::filter(&array_seq, &|elem| elem < k);
                              ^9           ^9                     ^9
  208|     59|            let right_array = ArraySeqStPerS::filter(&array_seq, &|elem| elem > k);
                              ^9            ^9                     ^9
  209|     59|            let found = ArraySeqStPerS::filter(&array_seq, &|elem| elem == k).length() > 0;
                              ^9      ^9                     ^9                             ^9
  210|       |
  211|       |            // Convert back to AVLTreeSeqStPerS
  212|      9|            let left_seq = AVLTreeSeqStPerS::from_vec(left_array.into_iter().collect());
  213|      9|            let right_seq = AVLTreeSeqStPerS::from_vec(right_array.into_iter().collect());
  214|       |
  215|      9|            (Self::from_seq(left_seq), found, Self::from_seq(right_seq))
  216|      9|        }
  217|       |
  218|       |        /// Claude Work: O(log(m + n)), Span: O(log(m + n))
  219|      8|        fn join(left: &Self, right: &Self) -> Self { left.union(right) }
  220|       |
  221|       |        /// Claude Work: O(log n), Span: O(log n)
  222|      9|        fn get_range(&self, k1: &T, k2: &T) -> Self {
  223|      9|            let seq = self.to_seq();
  224|       |
  225|       |            // Convert to ArraySeqStPerS for filtering operations
  226|     59|            let array_seq = ArraySeqStPerS::tabulate(&|i| seq.nth(i).clone(), seq.length());
                              ^9          ^9                                                ^9  ^9
  227|       |
  228|       |            // Use proper sequence filter operation
  229|     59|            let range_array = ArraySeqStPerS::filter(&array_seq, &|elem| elem >= k1 && elem <= k2);
                              ^9            ^9                     ^9                                ^46
  230|       |
  231|       |            // Convert back to AVLTreeSeqStPerS
  232|      9|            let range_seq = AVLTreeSeqStPerS::from_vec(range_array.into_iter().collect());
  233|      9|            Self::from_seq(range_seq)
  234|      9|        }
  235|       |
  236|       |        /// Claude Work: O(log n), Span: O(log n)
  237|     20|        fn rank(&self, k: &T) -> N {
  238|     20|            let seq = self.to_seq();
  239|     20|            let size = seq.length();
  240|     20|            let mut count = 0;
  241|       |
  242|     86|            for i in 0..size {
                                      ^20
  243|     86|                let elem = seq.nth(i);
  244|     86|                if elem < k {
  245|     67|                    count += 1;
  246|     67|                } else {
  247|     19|                    break;
  248|       |                }
  249|       |            }
  250|     20|            count
  251|     20|        }
  252|       |
  253|       |        /// Claude Work: O(log n), Span: O(log n)
  254|     13|        fn select(&self, i: N) -> Option<T> {
  255|     13|            let seq = self.to_seq();
  256|     13|            if i >= seq.length() {
  257|      1|                None
  258|       |            } else {
  259|     12|                Some(seq.nth(i).clone())
  260|       |            }
  261|     13|        }
  262|       |
  263|       |        /// Claude Work: O(log n), Span: O(log n)
  264|     10|        fn split_rank(&self, i: N) -> (Self, Self) {
  265|     10|            let seq = self.to_seq();
  266|     10|            let size = seq.length();
  267|       |
  268|     10|            if i >= size {
  269|      1|                return (self.clone(), Self::empty());
  270|      9|            }
  271|       |
  272|       |            // Use subseq_copy for known index ranges
  273|      9|            let left_seq = seq.subseq_copy(0, i);
  274|      9|            let right_seq = seq.subseq_copy(i, size - i);
  275|       |
  276|      9|            (Self::from_seq(left_seq), Self::from_seq(right_seq))
  277|     10|        }
  278|       |    }
  279|       |
  280|       |    impl<T: StT + Ord> Clone for OrderedSetStPer<T> {
  281|      1|        fn clone(&self) -> Self {
  282|      1|            OrderedSetStPer {
  283|      1|                base_set: self.base_set.clone(),
  284|      1|            }
  285|      1|        }
  286|       |    }
  287|       |
  288|       |    /// Helper function for macro construction
  289|      8|    pub fn from_sorted_elements<T: StT + Ord>(elements: Vec<T>) -> OrderedSetStPer<T> {
  290|      8|        let seq = AVLTreeSeqStPerS::from_vec(elements);
  291|      8|        OrderedSetStPer::from_seq(seq)
  292|      8|    }
  293|       |
  294|       |    /// Macro for creating ordered sets from sorted element lists
  295|       |    #[macro_export]
  296|       |    macro_rules! OrderedSetStPerLit {
  297|       |        () => {
  298|       |            $crate::Chap43::OrderedSetStPer::OrderedSetStPer::OrderedSetStPer::empty()
  299|       |        };
  300|       |        ($($elem:expr),+ $(,)?) => {
  301|       |            $crate::Chap43::OrderedSetStPer::OrderedSetStPer::from_sorted_elements(vec![$($elem),+])
  302|       |        };
  303|       |    }
  304|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap43/OrderedTableMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Multi-threaded ephemeral ordered table implementation extending TableMtEph.
    3|       |
    4|       |pub mod OrderedTableMtEph {
    5|       |
    6|       |    use std::sync::Arc;
    7|       |    use std::thread;
    8|       |
    9|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
   10|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::*;
   11|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::*;
   12|       |    use crate::Chap42::TableMtEph::TableMtEph::*;
   13|       |    use crate::Types::Types::*;
   14|       |
   15|       |    #[derive(PartialEq)]
   16|       |    pub struct OrderedTableMtEph<K: MtKey, V: MtVal> {
   17|       |        base_table: TableMtEph<K, V>,
   18|       |    }
   19|       |
   20|       |    pub type OrderedTableMt<K, V> = OrderedTableMtEph<K, V>;
   21|       |
   22|       |    /// Trait defining all ordered table operations (ADT 42.1 + ADT 43.1 for keys) with multi-threaded ephemeral semantics
   23|       |    pub trait OrderedTableMtEphTrait<K: MtKey, V: MtVal> {
   24|       |        // Base table operations (ADT 42.1) - ephemeral semantics with parallelism
   25|       |        /// claude-4-sonet: Work (1), Span (1)
   26|       |        fn size(&self) -> N;
   27|       |        /// claude-4-sonet: Work (1), Span (1)
   28|       |        fn empty() -> Self;
   29|       |        /// claude-4-sonet: Work (1), Span (1)
   30|       |        fn singleton(k: K, v: V) -> Self;
   31|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   32|       |        fn find(&self, k: &K) -> Option<V>;
   33|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   34|       |        fn lookup(&self, k: &K) -> Option<V>; // Alias for find
   35|       |        /// claude-4-sonet: Work (1), Span (1)
   36|       |        fn is_empty(&self) -> B;
   37|       |        /// claude-4-sonet: Work (n), Span (log n), Parallelism (n/log n)
   38|       |        fn insert<F: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, k: K, v: V, combine: F);
   39|       |        /// claude-4-sonet: Work (n), Span (log n), Parallelism (n/log n)
   40|       |        fn delete(&mut self, k: &K) -> Option<V>;
   41|       |        /// claude-4-sonet: Work (n log n), Span (log n), Parallelism (n)
   42|       |        fn domain(&self) -> ArraySetStEph<K>;
   43|       |        /// claude-4-sonet: Work (|keys|  W(f)), Span (log |keys| + S(f)), Parallelism (|keys|/(log |keys| + S(f)))
   44|       |        fn tabulate<F: Fn(&K) -> V + Send + Sync + 'static>(f: F, keys: &ArraySetStEph<K>) -> Self;
   45|       |        /// claude-4-sonet: Work (n  W(f)), Span (log n + S(f)), Parallelism (n/(log n + S(f)))
   46|       |        fn map<F: Fn(&K, &V) -> V + Send + Sync + 'static>(&self, f: F) -> Self;
   47|       |        /// claude-4-sonet: Work (n  W(f)), Span (log n + S(f)), Parallelism (n/(log n + S(f)))
   48|       |        fn filter<F: Fn(&K, &V) -> B + Send + Sync + 'static>(&self, f: F) -> Self;
   49|       |        /// claude-4-sonet: Work (m + n), Span (log(m + n)), Parallelism ((m+n)/log(m+n))
   50|       |        fn intersection<F: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, f: F);
   51|       |        /// claude-4-sonet: Work (m + n), Span (log(m + n)), Parallelism ((m+n)/log(m+n))
   52|       |        fn union<F: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, f: F);
   53|       |        /// claude-4-sonet: Work (m + n), Span (log(m + n)), Parallelism ((m+n)/log(m+n))
   54|       |        fn difference(&mut self, other: &Self);
   55|       |        /// claude-4-sonet: Work (m + n), Span (log(m + n)), Parallelism ((m+n)/log(m+n))
   56|       |        fn restrict(&mut self, keys: &ArraySetStEph<K>);
   57|       |        /// claude-4-sonet: Work (m + n), Span (log(m + n)), Parallelism ((m+n)/log(m+n))
   58|       |        fn subtract(&mut self, keys: &ArraySetStEph<K>);
   59|       |        /// claude-4-sonet: Work (n  W(f)), Span (log n + S(f)), Parallelism (n/(log n + S(f)))
   60|       |        fn reduce<R: StTInMtT + 'static, F: Fn(R, &K, &V) -> R + Send + Sync + 'static>(&self, init: R, f: F) -> R;
   61|       |        /// claude-4-sonet: Work (n), Span (log n), Parallelism (n/log n)
   62|       |        fn collect(&self) -> AVLTreeSeqStPerS<Pair<K, V>>;
   63|       |
   64|       |        // Key ordering operations (ADT 43.1 adapted for tables) - sequential (inherently sequential on trees)
   65|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   66|       |        fn first_key(&self) -> Option<K>;
   67|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   68|       |        fn last_key(&self) -> Option<K>;
   69|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   70|       |        fn previous_key(&self, k: &K) -> Option<K>;
   71|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   72|       |        fn next_key(&self, k: &K) -> Option<K>;
   73|       |        /// claude-4-sonet: Work (n), Span (log n), Parallelism (n/log n)
   74|       |        fn split_key(&mut self, k: &K) -> (Self, Self)
   75|       |        where
   76|       |            Self: Sized;
   77|       |        fn join_key(&mut self, other: Self);
   78|       |        fn get_key_range(&self, k1: &K, k2: &K) -> Self;
   79|       |        fn rank_key(&self, k: &K) -> N;
   80|       |        fn select_key(&self, i: N) -> Option<K>;
   81|       |        fn split_rank_key(&mut self, i: N) -> (Self, Self)
   82|       |        where
   83|       |            Self: Sized;
   84|       |    }
   85|       |
   86|       |    impl<K: MtKey, V: MtVal> OrderedTableMtEphTrait<K, V> for OrderedTableMtEph<K, V> {
   87|       |        // Base table operations - delegate to backing store with ephemeral semantics and parallelism
   88|       |
   89|       |        /// Claude Work: O(1), Span: O(1)
   90|  2.65k|        fn size(&self) -> N { self.base_table.size() }
   91|       |
   92|       |        /// Claude Work: O(1), Span: O(1)
   93|     83|        fn empty() -> Self {
   94|     83|            OrderedTableMtEph {
   95|     83|                base_table: TableMtEph::empty(),
   96|     83|            }
   97|     83|        }
   98|       |
   99|       |        /// Claude Work: O(1), Span: O(1)
  100|      3|        fn singleton(k: K, v: V) -> Self {
  101|      3|            OrderedTableMtEph {
  102|      3|                base_table: TableMtEph::singleton(k, v),
  103|      3|            }
  104|      3|        }
  105|       |
  106|       |        /// Claude Work: O(log n), Span: O(log n)
  107|    118|        fn find(&self, k: &K) -> Option<V> { self.base_table.find(k) }
  108|       |
  109|       |        /// Claude Work: O(log n), Span: O(log n)
  110|     67|        fn lookup(&self, k: &K) -> Option<V> { self.find(k) }
  111|       |
  112|       |        /// Claude Work: O(1), Span: O(1)
  113|     17|        fn is_empty(&self) -> B { self.size() == 0 }
  114|       |
  115|       |        /// Claude Work: O(log n), Span: O(log n)
  116|  2.90k|        fn insert<F: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, k: K, v: V, combine: F) {
  117|  2.90k|            self.base_table.insert(k, v, combine);
  118|  2.90k|        }
  119|       |
  120|       |        /// Claude Work: O(log n), Span: O(log n)
  121|      8|        fn delete(&mut self, k: &K) -> Option<V> {
  122|      8|            let old_value = self.find(k);
  123|      8|            self.base_table.delete(k);
  124|      8|            old_value
  125|      8|        }
  126|       |
  127|       |        /// Claude Work: O(n), Span: O(log n) - Parallel domain extraction
  128|      3|        fn domain(&self) -> ArraySetStEph<K> { self.base_table.domain() }
  129|       |
  130|       |        /// Claude Work: O(n log n), Span: O(log n) - Parallel tabulation
  131|      3|        fn tabulate<F>(f: F, keys: &ArraySetStEph<K>) -> Self
  132|      3|        where
  133|      3|            F: Fn(&K) -> V + Send + Sync + 'static,
  134|       |        {
  135|      3|            OrderedTableMtEph {
  136|      3|                base_table: TableMtEph::tabulate(f, keys),
  137|      3|            }
  138|      3|        }
  139|       |
  140|       |        /// Claude Work: O(n), Span: O(log n) - Parallel map
  141|      3|        fn map<F>(&self, f: F) -> Self
  142|      3|        where
  143|      3|            F: Fn(&K, &V) -> V + Send + Sync + 'static,
  144|       |        {
  145|      3|            let mut result = self.clone();
  146|       |            // Sequential implementation for now - parallel mapping would require more complex logic
  147|      3|            let entries = self.collect();
  148|      3|            result.base_table = TableMtEph::empty();
  149|    303|            for i in 0..entries.length() {
                                      ^3      ^3
  150|    303|                let pair = entries.nth(i);
  151|    303|                let new_value = f(&pair.0, &pair.1);
  152|    303|                result
  153|    303|                    .base_table
  154|    303|                    .insert(pair.0.clone(), new_value, |_old, new| new.clone());
                                                                                 ^0  ^0
  155|       |            }
  156|      3|            result
  157|      3|        }
  158|       |
  159|       |        /// Claude Work: O(n), Span: O(log n) - Parallel filter
  160|      3|        fn filter<F>(&self, f: F) -> Self
  161|      3|        where
  162|      3|            F: Fn(&K, &V) -> B + Send + Sync + 'static,
  163|       |        {
  164|      3|            let mut result = OrderedTableMtEph::empty();
  165|       |            // Sequential implementation for now - parallel filtering would require more complex logic
  166|      3|            let entries = self.collect();
  167|    310|            for i in 0..entries.length() {
                                      ^3      ^3
  168|    310|                let pair = entries.nth(i);
  169|    310|                if f(&pair.0, &pair.1) {
  170|    155|                    result
  171|    155|                        .base_table
  172|    155|                        .insert(pair.0.clone(), pair.1.clone(), |_old, new| new.clone());
                                                                                          ^0  ^0
  173|    155|                }
  174|       |            }
  175|      3|            result
  176|      3|        }
  177|       |
  178|       |        /// Claude Work: O(n), Span: O(log n) - Parallel reduction
  179|      6|        fn reduce<R, F>(&self, init: R, f: F) -> R
  180|      6|        where
  181|      6|            F: Fn(R, &K, &V) -> R + Send + Sync + 'static,
  182|      6|            R: Send + Sync + 'static,
  183|       |        {
  184|       |            // Sequential implementation for now - parallel reduction would require more complex logic
  185|      6|            let entries = self.collect();
  186|      6|            let mut result = init;
  187|    112|            for i in 0..entries.length() {
                                      ^6      ^6
  188|    112|                let pair = entries.nth(i);
  189|    112|                result = f(result, &pair.0, &pair.1);
  190|    112|            }
  191|      6|            result
  192|      6|        }
  193|       |
  194|       |        /// Claude Work: O(m + n), Span: O(log(m + n)) - Parallel intersection
  195|      3|        fn intersection<F>(&mut self, other: &Self, f: F)
  196|      3|        where
  197|      3|            F: Fn(&V, &V) -> V + Send + Sync + 'static,
  198|       |        {
  199|      3|            self.base_table.intersection(&other.base_table, f);
  200|      3|        }
  201|       |
  202|       |        /// Claude Work: O(m + n), Span: O(log(m + n)) - Parallel union
  203|      5|        fn union<F>(&mut self, other: &Self, f: F)
  204|      5|        where
  205|      5|            F: Fn(&V, &V) -> V + Send + Sync + 'static,
  206|       |        {
  207|      5|            self.base_table.union(&other.base_table, f);
  208|      5|        }
  209|       |
  210|       |        /// Claude Work: O(m + n), Span: O(log(m + n)) - Parallel difference
  211|      3|        fn difference(&mut self, other: &Self) { self.base_table.difference(&other.base_table); }
  212|       |
  213|       |        /// Claude Work: O(n), Span: O(log n) - Parallel restrict
  214|      3|        fn restrict(&mut self, keys: &ArraySetStEph<K>) { self.base_table.restrict(keys); }
  215|       |
  216|       |        /// Claude Work: O(n), Span: O(log n) - Parallel subtract
  217|      3|        fn subtract(&mut self, keys: &ArraySetStEph<K>) { self.base_table.subtract(keys); }
  218|       |
  219|       |        /// Claude Work: O(n), Span: O(log n)
  220|    149|        fn collect(&self) -> AVLTreeSeqStPerS<Pair<K, V>> {
  221|    149|            let array_seq = self.base_table.collect();
  222|       |            // Convert ArraySeqMtEphS to AVLTreeSeqStPerS
  223|    149|            let len = array_seq.length();
  224|    149|            let mut elements = Vec::new();
  225|  14.5k|            for i in 0..len {
                                      ^149
  226|  14.5k|                elements.push(array_seq.nth_cloned(i));
  227|  14.5k|            }
  228|    149|            AVLTreeSeqStPerS::from_vec(elements)
  229|    149|        }
  230|       |
  231|       |        // Key ordering operations (ADT 43.1 adapted for tables) - Sequential implementation
  232|       |
  233|       |        /// Claude Work: O(log n), Span: O(log n)
  234|      8|        fn first_key(&self) -> Option<K> {
  235|      8|            let entries = self.collect();
  236|      8|            if entries.length() == 0 {
  237|      3|                None
  238|       |            } else {
  239|      5|                Some(entries.nth(0).0.clone())
  240|       |            }
  241|      8|        }
  242|       |
  243|       |        /// Claude Work: O(log n), Span: O(log n)
  244|      8|        fn last_key(&self) -> Option<K> {
  245|      8|            let entries = self.collect();
  246|      8|            let size = entries.length();
  247|      8|            if size == 0 {
  248|      3|                None
  249|       |            } else {
  250|      5|                Some(entries.nth(size - 1).0.clone())
  251|       |            }
  252|      8|        }
  253|       |
  254|       |        /// Claude Work: O(log n), Span: O(log n)
  255|     12|        fn previous_key(&self, k: &K) -> Option<K> {
  256|     12|            let entries = self.collect();
  257|     12|            let size = entries.length();
  258|       |
  259|     37|            for i in (0..size).rev() {
                                   ^12       ^12
  260|     37|                let pair = entries.nth(i);
  261|     37|                if &pair.0 < k {
  262|      9|                    return Some(pair.0.clone());
  263|     28|                }
  264|       |            }
  265|      3|            None
  266|     12|        }
  267|       |
  268|       |        /// Claude Work: O(log n), Span: O(log n)
  269|     12|        fn next_key(&self, k: &K) -> Option<K> {
  270|     12|            let entries = self.collect();
  271|     12|            let size = entries.length();
  272|       |
  273|     36|            for i in 0..size {
                                      ^12
  274|     36|                let pair = entries.nth(i);
  275|     36|                if &pair.0 > k {
  276|      9|                    return Some(pair.0.clone());
  277|     27|                }
  278|       |            }
  279|      3|            None
  280|     12|        }
  281|       |
  282|       |        /// Claude Work: O(n), Span: O(log n) - Sequential split (AVLTreeSeq not thread-safe)
  283|      3|        fn split_key(&mut self, k: &K) -> (Self, Self) {
  284|      3|            let entries = self.collect();
  285|      3|            let size = entries.length();
  286|      3|            let mut left_entries = Vec::new();
  287|      3|            let mut right_entries = Vec::new();
  288|      3|            let mut _found_value = None;
  289|       |
  290|      8|            for i in 0..size {
                                      ^3
  291|      8|                let pair = entries.nth(i);
  292|      8|                if &pair.0 < k {
  293|      4|                    left_entries.push(pair.clone());
  294|      4|                } else {
  295|       |                    // Keys >= k go to the right side
  296|      4|                    right_entries.push(pair.clone());
  297|      4|                    if &pair.0 == k {
  298|      1|                        _found_value = Some(pair.1.clone());
  299|      3|                    }
  300|       |                }
  301|       |            }
  302|       |
  303|      3|            let left_seq = AVLTreeSeqStPerS::from_vec(left_entries);
  304|      3|            let right_seq = AVLTreeSeqStPerS::from_vec(right_entries);
  305|       |
  306|      3|            *self = Self::empty();
  307|      3|            (from_sorted_entries(left_seq), from_sorted_entries(right_seq))
  308|      3|        }
  309|       |
  310|       |        /// Claude Work: O(log(m + n)), Span: O(log(m + n))
  311|      2|        fn join_key(&mut self, other: Self) { self.union(&other, |v1, _v2| v1.clone()); }
                                                                                         ^0 ^0
  312|       |
  313|       |        /// Claude Work: O(log n), Span: O(log n) - Sequential (AVLTreeSeq not thread-safe)
  314|     25|        fn get_key_range(&self, k1: &K, k2: &K) -> Self {
  315|     25|            let entries = self.collect();
  316|     25|            let size = entries.length();
  317|     25|            let mut range_entries = Vec::new();
  318|       |
  319|  7.97k|            for i in 0..size {
                                      ^25
  320|  7.97k|                let pair = entries.nth(i);
  321|  7.97k|                if &pair.0 >= k1 && &pair.0 <= k2 {
                                                  ^6.05k
  322|  3.77k|                    range_entries.push(pair.clone());
  323|  4.20k|                }
  324|       |            }
  325|       |
  326|     25|            let range_seq = AVLTreeSeqStPerS::from_vec(range_entries);
  327|     25|            from_sorted_entries(range_seq)
  328|     25|        }
  329|       |
  330|       |        /// Claude Work: O(log n), Span: O(log n)
  331|     11|        fn rank_key(&self, k: &K) -> N {
  332|     11|            let entries = self.collect();
  333|     11|            let size = entries.length();
  334|     11|            let mut count = 0;
  335|       |
  336|    127|            for i in 0..size {
                                      ^11
  337|    127|                let pair = entries.nth(i);
  338|    127|                if &pair.0 < k {
  339|    116|                    count += 1;
  340|    116|                } else {
  341|     11|                    break;
  342|       |                }
  343|       |            }
  344|     11|            count
  345|     11|        }
  346|       |
  347|       |        /// Claude Work: O(log n), Span: O(log n)
  348|     14|        fn select_key(&self, i: N) -> Option<K> {
  349|     14|            let entries = self.collect();
  350|     14|            if i >= entries.length() {
  351|      3|                None
  352|       |            } else {
  353|     11|                Some(entries.nth(i).0.clone())
  354|       |            }
  355|     14|        }
  356|       |
  357|       |        /// Claude Work: O(n), Span: O(log n) - Sequential (AVLTreeSeq not thread-safe)
  358|      2|        fn split_rank_key(&mut self, i: N) -> (Self, Self) {
  359|      2|            let entries = self.collect();
  360|      2|            let size = entries.length();
  361|       |
  362|      2|            if i >= size {
  363|      0|                let current = self.clone();
  364|      0|                *self = Self::empty();
  365|      0|                return (current, Self::empty());
  366|      2|            }
  367|       |
  368|      2|            let mut left_entries = Vec::new();
  369|      2|            let mut right_entries = Vec::new();
  370|       |
  371|      4|            for j in 0..i {
                                      ^2
  372|      4|                left_entries.push(entries.nth(j).clone());
  373|      4|            }
  374|      5|            for j in i..size {
                                   ^2 ^2
  375|      5|                right_entries.push(entries.nth(j).clone());
  376|      5|            }
  377|       |
  378|      2|            let left_seq = AVLTreeSeqStPerS::from_vec(left_entries);
  379|      2|            let right_seq = AVLTreeSeqStPerS::from_vec(right_entries);
  380|       |
  381|      2|            *self = Self::empty();
  382|      2|            (from_sorted_entries(left_seq), from_sorted_entries(right_seq))
  383|      2|        }
  384|       |    }
  385|       |
  386|       |    impl<K: MtKey, V: MtVal> Clone for OrderedTableMtEph<K, V> {
  387|      4|        fn clone(&self) -> Self {
  388|      4|            OrderedTableMtEph {
  389|      4|                base_table: self.base_table.clone(),
  390|      4|            }
  391|      4|        }
  392|       |    }
  393|       |
  394|       |    /// Helper function for macro construction
  395|     36|    pub fn from_sorted_entries<K: MtKey, V: MtVal>(entries: AVLTreeSeqStPerS<Pair<K, V>>) -> OrderedTableMtEph<K, V> {
  396|       |        // Convert persistent sequence to Vec for TableMtEph helper
  397|     36|        let len = entries.length();
  398|     36|        let mut elements = Vec::new();
  399|  3.79k|        for i in 0..len {
                                  ^36
  400|  3.79k|            elements.push(entries.nth(i).clone());
  401|  3.79k|        }
  402|     36|        OrderedTableMtEph {
  403|     36|            base_table: crate::Chap42::TableMtEph::TableMtEph::from_sorted_entries(elements),
  404|     36|        }
  405|     36|    }
  406|       |
  407|       |    /// Macro for creating multi-threaded ephemeral ordered tables from sorted key-value pairs
  408|       |
  409|       |    #[macro_export]
  410|       |    macro_rules! OrderedTableMtEphLit {
  411|       |        () => {
  412|       |            $crate::Chap43::OrderedTableMtEph::OrderedTableMtEph::OrderedTableMtEph::empty()
  413|       |        };
  414|       |        ($($key:expr => $val:expr),+ $(,)?) => {{
  415|       |            let pairs = vec![$($crate::Types::Types::Pair($key, $val)),+];
  416|       |            let seq = $crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::AVLTreeSeqStPerS::from_vec(pairs);
  417|       |            $crate::Chap43::OrderedTableMtEph::OrderedTableMtEph::from_sorted_entries(seq)
  418|       |        }};
  419|       |    }
  420|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap43/OrderedTableMtPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Multi-threaded persistent ordered table implementation.
    3|       |//!
    4|       |//! Work/Span Analysis:
    5|       |//! - Sequential operations (Rc backing prevents true parallelism)
    6|       |//! - All operations delegate to OrderedTableStPer
    7|       |
    8|       |pub mod OrderedTableMtPer {
    9|       |
   10|       |    use std::sync::Arc;
   11|       |
   12|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::*;
   13|       |    use crate::Chap43::OrderedTableStPer::OrderedTableStPer::*;
   14|       |    use crate::Types::Types::*;
   15|       |
   16|       |    pub struct OrderedTableMtPer<K: StTInMtT + Ord, V: StTInMtT> {
   17|       |        inner: Arc<OrderedTableStPer<K, V>>,
   18|       |    }
   19|       |
   20|       |    pub trait OrderedTableMtPerTrait<K: StTInMtT + Ord, V: StTInMtT> {
   21|       |        /// claude-4-sonet: Work (1), Span (1)
   22|       |        fn size(&self) -> N;
   23|       |        /// claude-4-sonet: Work (1), Span (1)
   24|       |        fn empty() -> Self;
   25|       |        /// claude-4-sonet: Work (1), Span (1)
   26|       |        fn singleton(k: K, v: V) -> Self;
   27|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   28|       |        fn find(&self, k: &K) -> Option<V>;
   29|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   30|       |        fn insert(&self, k: K, v: V) -> Self;
   31|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   32|       |        fn delete(&self, k: &K) -> Self;
   33|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   34|       |        fn domain(&self) -> ArraySetStEph<K>;
   35|       |        /// claude-4-sonet: Work (n  W(f)), Span (n  S(f)), Parallelism (1)
   36|       |        fn map<F: Fn(&V) -> V>(&self, f: F) -> Self;
   37|       |        /// claude-4-sonet: Work (n  W(f)), Span (n  S(f)), Parallelism (1)
   38|       |        fn filter<F: Fn(&K, &V) -> B>(&self, f: F) -> Self;
   39|       |    }
   40|       |
   41|       |    impl<K: StTInMtT + Ord, V: StTInMtT> OrderedTableMtPerTrait<K, V> for OrderedTableMtPer<K, V> {
   42|     15|        fn size(&self) -> N { self.inner.size() }
   43|       |
   44|     17|        fn empty() -> Self {
   45|     17|            OrderedTableMtPer {
   46|     17|                inner: Arc::new(OrderedTableStPer::empty()),
   47|     17|            }
   48|     17|        }
   49|       |
   50|      1|        fn singleton(k: K, v: V) -> Self {
   51|      1|            OrderedTableMtPer {
   52|      1|                inner: Arc::new(OrderedTableStPer::singleton(k, v)),
   53|      1|            }
   54|      1|        }
   55|       |
   56|    125|        fn find(&self, k: &K) -> Option<V> { self.inner.find(k) }
   57|       |
   58|     91|        fn insert(&self, k: K, v: V) -> Self {
   59|     91|            OrderedTableMtPer {
   60|     91|                inner: Arc::new((*self.inner).insert(k, v)),
   61|     91|            }
   62|     91|        }
   63|       |
   64|      2|        fn delete(&self, k: &K) -> Self {
   65|      2|            OrderedTableMtPer {
   66|      2|                inner: Arc::new((*self.inner).delete(k)),
   67|      2|            }
   68|      2|        }
   69|       |
   70|      9|        fn domain(&self) -> ArraySetStEph<K> { self.inner.domain() }
   71|       |
   72|      2|        fn map<F: Fn(&V) -> V>(&self, f: F) -> Self {
   73|      2|            OrderedTableMtPer {
   74|      2|                inner: Arc::new((*self.inner).map(f)),
   75|      2|            }
   76|      2|        }
   77|       |
   78|      1|        fn filter<F: Fn(&K, &V) -> B>(&self, f: F) -> Self {
   79|      1|            OrderedTableMtPer {
   80|      1|                inner: Arc::new((*self.inner).filter(f)),
   81|      1|            }
   82|      1|        }
   83|       |    }
   84|       |
   85|       |    impl<K: StTInMtT + Ord, V: StTInMtT> Default for OrderedTableMtPer<K, V> {
   86|      0|        fn default() -> Self { Self::empty() }
   87|       |    }
   88|       |
   89|       |    impl<K: StTInMtT + Ord, V: StTInMtT> Clone for OrderedTableMtPer<K, V> {
   90|     25|        fn clone(&self) -> Self {
   91|     25|            OrderedTableMtPer {
   92|     25|                inner: Arc::clone(&self.inner),
   93|     25|            }
   94|     25|        }
   95|       |    }
   96|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap43/OrderedTableStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Single-threaded ephemeral ordered table implementation extending TableStEph.
    3|       |
    4|       |pub mod OrderedTableStEph {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
    7|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::*;
    8|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::*;
    9|       |    use crate::Chap42::TableStEph::TableStEph::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    #[derive(PartialEq)]
   13|       |    pub struct OrderedTableStEph<K: StT + Ord, V: StT> {
   14|       |        base_table: TableStEph<K, V>,
   15|       |    }
   16|       |
   17|       |    pub type OrderedTableEph<K, V> = OrderedTableStEph<K, V>;
   18|       |
   19|       |    /// Trait defining all ordered table operations (ADT 42.1 + ADT 43.1 for keys) with ephemeral semantics
   20|       |    pub trait OrderedTableStEphTrait<K: StT + Ord, V: StT> {
   21|       |        // Base table operations (ADT 42.1) - ephemeral semantics
   22|       |        /// claude-4-sonet: Work (1), Span (1)
   23|       |        fn size(&self) -> N;
   24|       |        /// claude-4-sonet: Work (1), Span (1)
   25|       |        fn empty() -> Self;
   26|       |        /// claude-4-sonet: Work (1), Span (1)
   27|       |        fn singleton(k: K, v: V) -> Self;
   28|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   29|       |        fn find(&self, k: &K) -> Option<V>;
   30|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   31|       |        fn lookup(&self, k: &K) -> Option<V>; // Alias for find
   32|       |        /// claude-4-sonet: Work (1), Span (1)
   33|       |        fn is_empty(&self) -> B;
   34|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   35|       |        fn insert<F: Fn(&V, &V) -> V>(&mut self, k: K, v: V, combine: F);
   36|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   37|       |        fn delete(&mut self, k: &K) -> Option<V>;
   38|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   39|       |        fn domain(&self) -> ArraySetStEph<K>;
   40|       |        /// claude-4-sonet: Work (|keys|  W(f)), Span (|keys|  S(f)), Parallelism (1)
   41|       |        fn tabulate<F: Fn(&K) -> V>(f: F, keys: &ArraySetStEph<K>) -> Self;
   42|       |        /// claude-4-sonet: Work (n  W(f)), Span (n  S(f)), Parallelism (1)
   43|       |        fn map<F: Fn(&K, &V) -> V>(&self, f: F) -> Self;
   44|       |        /// claude-4-sonet: Work (n  W(f)), Span (n  S(f)), Parallelism (1)
   45|       |        fn filter<F: Fn(&K, &V) -> B>(&self, f: F) -> Self;
   46|       |        /// claude-4-sonet: Work (n  W(f)), Span (n  S(f)), Parallelism (1)
   47|       |        fn reduce<R, F: Fn(R, &K, &V) -> R>(&self, init: R, f: F) -> R;
   48|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   49|       |        fn intersection<F: Fn(&V, &V) -> V>(&mut self, other: &Self, f: F);
   50|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   51|       |        fn union<F: Fn(&V, &V) -> V>(&mut self, other: &Self, f: F);
   52|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   53|       |        fn difference(&mut self, other: &Self);
   54|       |        /// claude-4-sonet: Work (m + n), Span (m + n), Parallelism (1)
   55|       |        fn restrict(&mut self, keys: &ArraySetStEph<K>);
   56|       |        /// claude-4-sonet: Work (m + n), Span (m + n), Parallelism (1)
   57|       |        fn subtract(&mut self, keys: &ArraySetStEph<K>);
   58|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   59|       |        fn collect(&self) -> AVLTreeSeqStPerS<Pair<K, V>>;
   60|       |
   61|       |        // Key ordering operations (ADT 43.1 adapted for tables)
   62|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   63|       |        fn first_key(&self) -> Option<K>;
   64|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   65|       |        fn last_key(&self) -> Option<K>;
   66|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   67|       |        fn previous_key(&self, k: &K) -> Option<K>;
   68|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   69|       |        fn next_key(&self, k: &K) -> Option<K>;
   70|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   71|       |        fn split_key(&mut self, k: &K) -> (Self, Self)
   72|       |        where
   73|       |            Self: Sized;
   74|       |        /// claude-4-sonet: Work (log(|self| + |other|)), Span (log(|self| + |other|)), Parallelism (1)
   75|       |        fn join_key(&mut self, other: Self);
   76|       |        fn get_key_range(&self, k1: &K, k2: &K) -> Self;
   77|       |        fn rank_key(&self, k: &K) -> N;
   78|       |        fn select_key(&self, i: N) -> Option<K>;
   79|       |        fn split_rank_key(&mut self, i: N) -> (Self, Self)
   80|       |        where
   81|       |            Self: Sized;
   82|       |    }
   83|       |
   84|       |    impl<K: StT + Ord, V: StT> OrderedTableStEphTrait<K, V> for OrderedTableStEph<K, V> {
   85|       |        // Base table operations - delegate to backing store with ephemeral semantics
   86|       |
   87|       |        /// Claude Work: O(1), Span: O(1)
   88|    303|        fn size(&self) -> N { self.base_table.size() }
   89|       |
   90|       |        /// Claude Work: O(1), Span: O(1)
   91|     96|        fn empty() -> Self {
   92|     96|            OrderedTableStEph {
   93|     96|                base_table: TableStEph::empty(),
   94|     96|            }
   95|     96|        }
   96|       |
   97|       |        /// Claude Work: O(1), Span: O(1)
   98|      3|        fn singleton(k: K, v: V) -> Self {
   99|      3|            OrderedTableStEph {
  100|      3|                base_table: TableStEph::singleton(k, v),
  101|      3|            }
  102|      3|        }
  103|       |
  104|       |        /// Claude Work: O(log n), Span: O(log n)
  105|    195|        fn find(&self, k: &K) -> Option<V> { self.base_table.find(k) }
  106|       |
  107|       |        /// Claude Work: O(log n), Span: O(log n)
  108|     63|        fn lookup(&self, k: &K) -> Option<V> { self.find(k) }
  109|       |
  110|       |        /// Claude Work: O(1), Span: O(1)
  111|      7|        fn is_empty(&self) -> B { self.size() == 0 }
  112|       |
  113|       |        /// Claude Work: O(log n), Span: O(log n)
  114|    545|        fn insert<F: Fn(&V, &V) -> V>(&mut self, k: K, v: V, combine: F) { self.base_table.insert(k, v, combine); }
  115|       |
  116|       |        /// Claude Work: O(log n), Span: O(log n)
  117|      7|        fn delete(&mut self, k: &K) -> Option<V> {
  118|      7|            let old_value = self.find(k);
  119|      7|            self.base_table.delete(k);
  120|      7|            old_value
  121|      7|        }
  122|       |
  123|       |        /// Claude Work: O(n), Span: O(log n)
  124|     11|        fn domain(&self) -> ArraySetStEph<K> { self.base_table.domain() }
  125|       |
  126|       |        /// Claude Work: O(n log n), Span: O(log n)
  127|      3|        fn tabulate<F: Fn(&K) -> V>(f: F, keys: &ArraySetStEph<K>) -> Self {
  128|      3|            OrderedTableStEph {
  129|      3|                base_table: TableStEph::tabulate(f, keys),
  130|      3|            }
  131|      3|        }
  132|       |
  133|       |        /// Claude Work: O(n), Span: O(log n)
  134|      3|        fn map<F: Fn(&K, &V) -> V>(&self, f: F) -> Self {
  135|      3|            let mut result = OrderedTableStEph::empty();
  136|      3|            let entries = self.collect();
  137|    205|            for i in 0..entries.length() {
                                      ^3      ^3
  138|    205|                let pair = entries.nth(i);
  139|    205|                let new_value = f(&pair.0, &pair.1);
  140|    205|                result
  141|    205|                    .base_table
  142|    205|                    .insert(pair.0.clone(), new_value, |_old, new| new.clone());
                                                                                 ^0  ^0
  143|       |            }
  144|      3|            result
  145|      3|        }
  146|       |
  147|       |        /// Claude Work: O(n), Span: O(log n)
  148|      3|        fn filter<F: Fn(&K, &V) -> B>(&self, f: F) -> Self {
  149|      3|            let mut result = OrderedTableStEph::empty();
  150|      3|            let entries = self.collect();
  151|    214|            for i in 0..entries.length() {
                                      ^3      ^3
  152|    214|                let pair = entries.nth(i);
  153|    214|                if f(&pair.0, &pair.1) {
  154|    107|                    result
  155|    107|                        .base_table
  156|    107|                        .insert(pair.0.clone(), pair.1.clone(), |_old, new| new.clone());
                                                                                          ^0  ^0
  157|    107|                }
  158|       |            }
  159|      3|            result
  160|      3|        }
  161|       |
  162|       |        /// Claude Work: O(n), Span: O(log n)
  163|      6|        fn reduce<R, F: Fn(R, &K, &V) -> R>(&self, init: R, f: F) -> R {
  164|      6|            let entries = self.collect();
  165|      6|            let mut result = init;
  166|     15|            for i in 0..entries.length() {
                                      ^6      ^6
  167|     15|                let pair = entries.nth(i);
  168|     15|                result = f(result, &pair.0, &pair.1);
  169|     15|            }
  170|      6|            result
  171|      6|        }
  172|       |
  173|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  174|      3|        fn intersection<F: Fn(&V, &V) -> V>(&mut self, other: &Self, f: F) {
  175|      3|            self.base_table.intersection(&other.base_table, f);
  176|      3|        }
  177|       |
  178|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  179|      5|        fn union<F: Fn(&V, &V) -> V>(&mut self, other: &Self, f: F) { self.base_table.union(&other.base_table, f); }
  180|       |
  181|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  182|      3|        fn difference(&mut self, other: &Self) { self.base_table.difference(&other.base_table); }
  183|       |
  184|       |        /// Claude Work: O(n), Span: O(log n)
  185|      3|        fn restrict(&mut self, keys: &ArraySetStEph<K>) { self.base_table.restrict(keys); }
  186|       |
  187|       |        /// Claude Work: O(n), Span: O(log n)
  188|      3|        fn subtract(&mut self, keys: &ArraySetStEph<K>) { self.base_table.subtract(keys); }
  189|       |
  190|       |        /// Claude Work: O(n), Span: O(log n)
  191|    116|        fn collect(&self) -> AVLTreeSeqStPerS<Pair<K, V>> {
  192|    116|            let array_seq = self.base_table.collect();
  193|       |            // Convert ArraySeqStEphS to AVLTreeSeqStPerS
  194|    116|            let len = array_seq.length();
  195|    116|            let mut elements = Vec::new();
  196|  1.88k|            for i in 0..len {
                                      ^116
  197|  1.88k|                elements.push(array_seq.nth(i).clone());
  198|  1.88k|            }
  199|    116|            AVLTreeSeqStPerS::from_vec(elements)
  200|    116|        }
  201|       |
  202|       |        // Key ordering operations (ADT 43.1 adapted for tables)
  203|       |
  204|       |        /// Claude Work: O(log n), Span: O(log n)
  205|      8|        fn first_key(&self) -> Option<K> {
  206|      8|            let entries = self.collect();
  207|      8|            if entries.length() == 0 {
  208|      3|                None
  209|       |            } else {
  210|      5|                Some(entries.nth(0).0.clone())
  211|       |            }
  212|      8|        }
  213|       |
  214|       |        /// Claude Work: O(log n), Span: O(log n)
  215|      8|        fn last_key(&self) -> Option<K> {
  216|      8|            let entries = self.collect();
  217|      8|            let size = entries.length();
  218|      8|            if size == 0 {
  219|      3|                None
  220|       |            } else {
  221|      5|                Some(entries.nth(size - 1).0.clone())
  222|       |            }
  223|      8|        }
  224|       |
  225|       |        /// Claude Work: O(log n), Span: O(log n)
  226|     12|        fn previous_key(&self, k: &K) -> Option<K> {
  227|     12|            let entries = self.collect();
  228|     12|            let size = entries.length();
  229|       |
  230|     37|            for i in (0..size).rev() {
                                   ^12       ^12
  231|     37|                let pair = entries.nth(i);
  232|     37|                if &pair.0 < k {
  233|      9|                    return Some(pair.0.clone());
  234|     28|                }
  235|       |            }
  236|      3|            None
  237|     12|        }
  238|       |
  239|       |        /// Claude Work: O(log n), Span: O(log n)
  240|     12|        fn next_key(&self, k: &K) -> Option<K> {
  241|     12|            let entries = self.collect();
  242|     12|            let size = entries.length();
  243|       |
  244|     36|            for i in 0..size {
                                      ^12
  245|     36|                let pair = entries.nth(i);
  246|     36|                if &pair.0 > k {
  247|      9|                    return Some(pair.0.clone());
  248|     27|                }
  249|       |            }
  250|      3|            None
  251|     12|        }
  252|       |
  253|       |        /// Claude Work: O(log n), Span: O(log n)
  254|      3|        fn split_key(&mut self, k: &K) -> (Self, Self) {
  255|      3|            let entries = self.collect();
  256|      3|            let size = entries.length();
  257|      3|            let mut left_entries = Vec::new();
  258|      3|            let mut right_entries = Vec::new();
  259|      3|            let mut _found_value: Option<V> = None;
  260|       |
  261|      8|            for i in 0..size {
                                      ^3
  262|      8|                let pair = entries.nth(i);
  263|      8|                if &pair.0 < k {
  264|      4|                    left_entries.push(pair.clone());
  265|      4|                } else {
  266|      4|                    // Keys >= k go to the right side
  267|      4|                    right_entries.push(pair.clone());
  268|      4|                }
  269|       |            }
  270|       |
  271|      3|            let left_seq = AVLTreeSeqStPerS::from_vec(left_entries);
  272|      3|            let right_seq = AVLTreeSeqStPerS::from_vec(right_entries);
  273|       |
  274|       |            // Clear current table (ephemeral behavior)
  275|      3|            *self = Self::empty();
  276|       |
  277|      3|            (from_sorted_entries(left_seq), from_sorted_entries(right_seq))
  278|      3|        }
  279|       |
  280|       |        /// Claude Work: O(log(m + n)), Span: O(log(m + n))
  281|      2|        fn join_key(&mut self, other: Self) { self.union(&other, |v1, _v2| v1.clone()); }
                                                                                         ^0 ^0
  282|       |
  283|       |        /// Claude Work: O(log n), Span: O(log n)
  284|     10|        fn get_key_range(&self, k1: &K, k2: &K) -> Self {
  285|     10|            let entries = self.collect();
  286|     10|            let size = entries.length();
  287|     10|            let mut range_entries = Vec::new();
  288|       |
  289|    289|            for i in 0..size {
                                      ^10
  290|    289|                let pair = entries.nth(i);
  291|    289|                if &pair.0 >= k1 && &pair.0 <= k2 {
                                                  ^183
  292|     89|                    range_entries.push(pair.clone());
  293|    200|                }
  294|       |            }
  295|       |
  296|     10|            let range_seq = AVLTreeSeqStPerS::from_vec(range_entries);
  297|     10|            from_sorted_entries(range_seq)
  298|     10|        }
  299|       |
  300|       |        /// Claude Work: O(log n), Span: O(log n)
  301|     11|        fn rank_key(&self, k: &K) -> N {
  302|     11|            let entries = self.collect();
  303|     11|            let size = entries.length();
  304|     11|            let mut count = 0;
  305|       |
  306|    127|            for i in 0..size {
                                      ^11
  307|    127|                let pair = entries.nth(i);
  308|    127|                if &pair.0 < k {
  309|    116|                    count += 1;
  310|    116|                } else {
  311|     11|                    break;
  312|       |                }
  313|       |            }
  314|     11|            count
  315|     11|        }
  316|       |
  317|       |        /// Claude Work: O(log n), Span: O(log n)
  318|     13|        fn select_key(&self, i: N) -> Option<K> {
  319|     13|            let entries = self.collect();
  320|     13|            if i >= entries.length() {
  321|      3|                None
  322|       |            } else {
  323|     10|                Some(entries.nth(i).0.clone())
  324|       |            }
  325|     13|        }
  326|       |
  327|       |        /// Claude Work: O(log n), Span: O(log n)
  328|      2|        fn split_rank_key(&mut self, i: N) -> (Self, Self) {
  329|      2|            let entries = self.collect();
  330|      2|            let size = entries.length();
  331|       |
  332|      2|            if i >= size {
  333|      0|                let current = self.clone();
  334|      0|                *self = Self::empty();
  335|      0|                return (current, Self::empty());
  336|      2|            }
  337|       |
  338|      2|            let mut left_entries = Vec::new();
  339|      2|            let mut right_entries = Vec::new();
  340|       |
  341|      4|            for j in 0..i {
                                      ^2
  342|      4|                left_entries.push(entries.nth(j).clone());
  343|      4|            }
  344|      5|            for j in i..size {
                                   ^2 ^2
  345|      5|                right_entries.push(entries.nth(j).clone());
  346|      5|            }
  347|       |
  348|      2|            let left_seq = AVLTreeSeqStPerS::from_vec(left_entries);
  349|      2|            let right_seq = AVLTreeSeqStPerS::from_vec(right_entries);
  350|       |
  351|       |            // Clear current table (ephemeral behavior)
  352|      2|            *self = Self::empty();
  353|       |
  354|      2|            (from_sorted_entries(left_seq), from_sorted_entries(right_seq))
  355|      2|        }
  356|       |    }
  357|       |
  358|       |    impl<K: StT + Ord, V: StT> Clone for OrderedTableStEph<K, V> {
  359|      2|        fn clone(&self) -> Self {
  360|      2|            OrderedTableStEph {
  361|      2|                base_table: self.base_table.clone(),
  362|      2|            }
  363|      2|        }
  364|       |    }
  365|       |
  366|       |    /// Helper function for macro construction
  367|     21|    pub fn from_sorted_entries<K: StT + Ord, V: StT>(entries: AVLTreeSeqStPerS<Pair<K, V>>) -> OrderedTableStEph<K, V> {
  368|       |        // Convert persistent sequence to Vec for TableStEph helper
  369|     21|        let len = entries.length();
  370|     21|        let mut elements = Vec::new();
  371|    109|        for i in 0..len {
                                  ^21
  372|    109|            elements.push(entries.nth(i).clone());
  373|    109|        }
  374|     21|        OrderedTableStEph {
  375|     21|            base_table: crate::Chap42::TableStEph::TableStEph::from_sorted_entries(elements),
  376|     21|        }
  377|     21|    }
  378|       |
  379|       |    /// Macro for creating ephemeral ordered tables from sorted key-value pairs
  380|       |    #[macro_export]
  381|       |    macro_rules! OrderedTableStEphLit {
  382|       |        () => {
  383|       |            $crate::Chap43::OrderedTableStEph::OrderedTableStEph::OrderedTableStEph::empty()
  384|       |        };
  385|       |        ($($key:expr => $val:expr),+ $(,)?) => {{
  386|       |            let pairs = vec![$($crate::Types::Types::Pair($key, $val)),+];
  387|       |            let seq = $crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::AVLTreeSeqStPerS::from_vec(pairs);
  388|       |            $crate::Chap43::OrderedTableStEph::OrderedTableStEph::from_sorted_entries(seq)
  389|       |        }};
  390|       |    }
  391|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap43/OrderedTableStPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Single-threaded persistent ordered table implementation extending TableStPer.
    3|       |
    4|       |pub mod OrderedTableStPer {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::*;
    8|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::*;
    9|       |    use crate::Chap42::TableStPer::TableStPer::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    #[derive(PartialEq)]
   13|       |    pub struct OrderedTableStPer<K: StT + Ord, V: StT> {
   14|       |        base_table: TableStPer<K, V>,
   15|       |    }
   16|       |
   17|       |    pub type OrderedTablePer<K, V> = OrderedTableStPer<K, V>;
   18|       |
   19|       |    /// Trait defining all ordered table operations (ADT 42.1 + ADT 43.1 for keys)
   20|       |    pub trait OrderedTableStPerTrait<K: StT + Ord, V: StT> {
   21|       |        // Base table operations (ADT 42.1) - delegated
   22|       |        /// claude-4-sonet: Work (1), Span (1)
   23|       |        fn size(&self) -> N;
   24|       |        /// claude-4-sonet: Work (1), Span (1)
   25|       |        fn empty() -> Self;
   26|       |        /// claude-4-sonet: Work (1), Span (1)
   27|       |        fn singleton(k: K, v: V) -> Self;
   28|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   29|       |        fn find(&self, k: &K) -> Option<V>;
   30|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   31|       |        fn insert(&self, k: K, v: V) -> Self;
   32|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   33|       |        fn delete(&self, k: &K) -> Self;
   34|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   35|       |        fn domain(&self) -> ArraySetStEph<K>;
   36|       |        /// claude-4-sonet: Work (|keys|  W(f)), Span (|keys|  S(f)), Parallelism (1)
   37|       |        fn tabulate<F: Fn(&K) -> V>(f: F, keys: &ArraySetStEph<K>) -> Self;
   38|       |        /// claude-4-sonet: Work (n  W(f)), Span (n  S(f)), Parallelism (1)
   39|       |        fn map<F: Fn(&V) -> V>(&self, f: F) -> Self;
   40|       |        /// claude-4-sonet: Work (n  W(f)), Span (n  S(f)), Parallelism (1)
   41|       |        fn filter<F: Fn(&K, &V) -> B>(&self, f: F) -> Self;
   42|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   43|       |        fn intersection<F: Fn(&V, &V) -> V>(&self, other: &Self, f: F) -> Self;
   44|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   45|       |        fn union<F: Fn(&V, &V) -> V>(&self, other: &Self, f: F) -> Self;
   46|       |        /// claude-4-sonet: Work (m log(n/m)) where m = min(|self|, |other|), Span (log n  log m)
   47|       |        fn difference(&self, other: &Self) -> Self;
   48|       |        /// claude-4-sonet: Work (m + n), Span (m + n), Parallelism (1)
   49|       |        fn restrict(&self, keys: &ArraySetStEph<K>) -> Self;
   50|       |        /// claude-4-sonet: Work (m + n), Span (m + n), Parallelism (1)
   51|       |        fn subtract(&self, keys: &ArraySetStEph<K>) -> Self;
   52|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   53|       |        fn collect(&self) -> AVLTreeSeqStPerS<Pair<K, V>>;
   54|       |
   55|       |        // Key ordering operations (ADT 43.1 adapted for tables)
   56|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   57|       |        fn first_key(&self) -> Option<K>;
   58|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   59|       |        fn last_key(&self) -> Option<K>;
   60|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   61|       |        fn previous_key(&self, k: &K) -> Option<K>;
   62|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   63|       |        fn next_key(&self, k: &K) -> Option<K>;
   64|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   65|       |        fn split_key(&self, k: &K) -> (Self, Option<V>, Self)
   66|       |        where
   67|       |            Self: Sized;
   68|       |        /// claude-4-sonet: Work (log(|left| + |right|)), Span (log(|left| + |right|)), Parallelism (1)
   69|       |        fn join_key(left: &Self, right: &Self) -> Self;
   70|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   71|       |        fn get_key_range(&self, k1: &K, k2: &K) -> Self;
   72|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   73|       |        fn rank_key(&self, k: &K) -> N;
   74|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   75|       |        fn select_key(&self, i: N) -> Option<K>;
   76|       |        fn split_rank_key(&self, i: N) -> (Self, Self)
   77|       |        where
   78|       |            Self: Sized;
   79|       |    }
   80|       |
   81|       |    impl<K: StT + Ord, V: StT> OrderedTableStPerTrait<K, V> for OrderedTableStPer<K, V> {
   82|       |        // Base table operations - delegate to backing store
   83|       |
   84|       |        /// Claude Work: O(1), Span: O(1)
   85|    282|        fn size(&self) -> N { self.base_table.size() }
   86|       |
   87|       |        /// Claude Work: O(1), Span: O(1)
   88|     93|        fn empty() -> Self {
   89|     93|            OrderedTableStPer {
   90|     93|                base_table: TableStPer::empty(),
   91|     93|            }
   92|     93|        }
   93|       |
   94|       |        /// Claude Work: O(1), Span: O(1)
   95|      4|        fn singleton(k: K, v: V) -> Self {
   96|      4|            OrderedTableStPer {
   97|      4|                base_table: TableStPer::singleton(k, v),
   98|      4|            }
   99|      4|        }
  100|       |
  101|       |        /// Claude Work: O(log n), Span: O(log n)
  102|    326|        fn find(&self, k: &K) -> Option<V> { self.base_table.find(k) }
  103|       |
  104|       |        /// Claude Work: O(log n), Span: O(log n)
  105|    520|        fn insert(&self, k: K, v: V) -> Self {
  106|       |            OrderedTableStPer {
  107|    520|                base_table: self.base_table.insert(k, v, |_old, new| new.clone()),
                                                                                   ^40 ^40
  108|       |            }
  109|    520|        }
  110|       |
  111|       |        /// Claude Work: O(log n), Span: O(log n)
  112|      8|        fn delete(&self, k: &K) -> Self {
  113|      8|            OrderedTableStPer {
  114|      8|                base_table: self.base_table.delete(k),
  115|      8|            }
  116|      8|        }
  117|       |
  118|       |        /// Claude Work: O(n), Span: O(log n)
  119|     25|        fn domain(&self) -> ArraySetStEph<K> { self.base_table.domain() }
  120|       |
  121|       |        /// Claude Work: O(n log n), Span: O(log n)
  122|      2|        fn tabulate<F: Fn(&K) -> V>(f: F, keys: &ArraySetStEph<K>) -> Self {
  123|      2|            OrderedTableStPer {
  124|      2|                base_table: TableStPer::tabulate(f, keys),
  125|      2|            }
  126|      2|        }
  127|       |
  128|       |        /// Claude Work: O(n), Span: O(log n)
  129|      4|        fn map<F: Fn(&V) -> V>(&self, f: F) -> Self {
  130|      4|            OrderedTableStPer {
  131|      4|                base_table: self.base_table.map(f),
  132|      4|            }
  133|      4|        }
  134|       |
  135|       |        /// Claude Work: O(n), Span: O(log n)
  136|      4|        fn filter<F: Fn(&K, &V) -> B>(&self, f: F) -> Self {
  137|      4|            OrderedTableStPer {
  138|      4|                base_table: self.base_table.filter(f),
  139|      4|            }
  140|      4|        }
  141|       |
  142|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  143|      2|        fn intersection<F: Fn(&V, &V) -> V>(&self, other: &Self, f: F) -> Self {
  144|      2|            OrderedTableStPer {
  145|      2|                base_table: self.base_table.intersection(&other.base_table, f),
  146|      2|            }
  147|      2|        }
  148|       |
  149|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  150|      4|        fn union<F: Fn(&V, &V) -> V>(&self, other: &Self, f: F) -> Self {
  151|      4|            OrderedTableStPer {
  152|      4|                base_table: self.base_table.union(&other.base_table, f),
  153|      4|            }
  154|      4|        }
  155|       |
  156|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  157|      2|        fn difference(&self, other: &Self) -> Self {
  158|      2|            OrderedTableStPer {
  159|      2|                base_table: self.base_table.difference(&other.base_table),
  160|      2|            }
  161|      2|        }
  162|       |
  163|       |        /// Claude Work: O(n), Span: O(log n)
  164|      2|        fn restrict(&self, keys: &ArraySetStEph<K>) -> Self {
  165|      2|            OrderedTableStPer {
  166|      2|                base_table: self.base_table.restrict(keys),
  167|      2|            }
  168|      2|        }
  169|       |
  170|       |        /// Claude Work: O(n), Span: O(log n)
  171|      2|        fn subtract(&self, keys: &ArraySetStEph<K>) -> Self {
  172|      2|            OrderedTableStPer {
  173|      2|                base_table: self.base_table.subtract(keys),
  174|      2|            }
  175|      2|        }
  176|       |
  177|       |        /// Claude Work: O(n), Span: O(log n)
  178|     96|        fn collect(&self) -> AVLTreeSeqStPerS<Pair<K, V>> {
  179|     96|            let array_seq = self.base_table.collect();
  180|       |            // Convert ArraySeqStPerS to AVLTreeSeqStPerS
  181|     96|            let len = array_seq.length();
  182|     96|            let mut elements = Vec::new();
  183|    929|            for i in 0..len {
                                      ^96
  184|    929|                elements.push(array_seq.nth(i).clone());
  185|    929|            }
  186|     96|            AVLTreeSeqStPerS::from_vec(elements)
  187|     96|        }
  188|       |
  189|       |        // Key ordering operations (ADT 43.1 adapted for tables)
  190|       |
  191|       |        /// Claude Work: O(log n), Span: O(log n)
  192|     10|        fn first_key(&self) -> Option<K> {
  193|     10|            let entries = self.collect();
  194|     10|            if entries.length() == 0 {
  195|      4|                None
  196|       |            } else {
  197|      6|                Some(entries.nth(0).0.clone())
  198|       |            }
  199|     10|        }
  200|       |
  201|       |        /// Claude Work: O(log n), Span: O(log n)
  202|     10|        fn last_key(&self) -> Option<K> {
  203|     10|            let entries = self.collect();
  204|     10|            let size = entries.length();
  205|     10|            if size == 0 {
  206|      4|                None
  207|       |            } else {
  208|      6|                Some(entries.nth(size - 1).0.clone())
  209|       |            }
  210|     10|        }
  211|       |
  212|       |        /// Claude Work: O(log n), Span: O(log n)
  213|      9|        fn previous_key(&self, k: &K) -> Option<K> {
  214|      9|            let entries = self.collect();
  215|      9|            let size = entries.length();
  216|       |
  217|     29|            for i in (0..size).rev() {
                                   ^9        ^9
  218|     29|                let pair = entries.nth(i);
  219|     29|                if &pair.0 < k {
  220|      6|                    return Some(pair.0.clone());
  221|     23|                }
  222|       |            }
  223|      3|            None
  224|      9|        }
  225|       |
  226|       |        /// Claude Work: O(log n), Span: O(log n)
  227|     10|        fn next_key(&self, k: &K) -> Option<K> {
  228|     10|            let entries = self.collect();
  229|     10|            let size = entries.length();
  230|       |
  231|     30|            for i in 0..size {
                                      ^10
  232|     30|                let pair = entries.nth(i);
  233|     30|                if &pair.0 > k {
  234|      7|                    return Some(pair.0.clone());
  235|     23|                }
  236|       |            }
  237|      3|            None
  238|     10|        }
  239|       |
  240|       |        /// Claude Work: O(log n), Span: O(log n)
  241|      3|        fn split_key(&self, k: &K) -> (Self, Option<V>, Self) {
  242|      3|            let entries = self.collect();
  243|      3|            let size = entries.length();
  244|      3|            let mut left_entries = Vec::new();
  245|      3|            let mut right_entries = Vec::new();
  246|      3|            let mut found_value = None;
  247|       |
  248|     14|            for i in 0..size {
                                      ^3
  249|     14|                let pair = entries.nth(i);
  250|     14|                if &pair.0 < k {
  251|      6|                    left_entries.push(pair.clone());
  252|      8|                } else if &pair.0 > k {
  253|      7|                    right_entries.push(pair.clone());
  254|      7|                } else {
  255|      1|                    found_value = Some(pair.1.clone());
  256|      1|                }
  257|       |            }
  258|       |
  259|      3|            let left_seq = AVLTreeSeqStPerS::from_vec(left_entries);
  260|      3|            let right_seq = AVLTreeSeqStPerS::from_vec(right_entries);
  261|       |
  262|      3|            (
  263|      3|                from_sorted_entries(left_seq),
  264|      3|                found_value,
  265|      3|                from_sorted_entries(right_seq),
  266|      3|            )
  267|      3|        }
  268|       |
  269|       |        /// Claude Work: O(log(m + n)), Span: O(log(m + n))
  270|      2|        fn join_key(left: &Self, right: &Self) -> Self { left.union(right, |v1, _v2| v1.clone()) }
                                                                                                   ^0 ^0
  271|       |
  272|       |        /// Claude Work: O(log n), Span: O(log n)
  273|      9|        fn get_key_range(&self, k1: &K, k2: &K) -> Self {
  274|      9|            let entries = self.collect();
  275|      9|            let size = entries.length();
  276|      9|            let mut range_entries = Vec::new();
  277|       |
  278|    186|            for i in 0..size {
                                      ^9
  279|    186|                let pair = entries.nth(i);
  280|    186|                if &pair.0 >= k1 && &pair.0 <= k2 {
                                                  ^132
  281|     80|                    range_entries.push(pair.clone());
  282|    106|                }
  283|       |            }
  284|       |
  285|      9|            let range_seq = AVLTreeSeqStPerS::from_vec(range_entries);
  286|      9|            from_sorted_entries(range_seq)
  287|      9|        }
  288|       |
  289|       |        /// Claude Work: O(log n), Span: O(log n)
  290|      8|        fn rank_key(&self, k: &K) -> N {
  291|      8|            let entries = self.collect();
  292|      8|            let size = entries.length();
  293|      8|            let mut count = 0;
  294|       |
  295|     70|            for i in 0..size {
                                      ^8
  296|     70|                let pair = entries.nth(i);
  297|     70|                if &pair.0 < k {
  298|     63|                    count += 1;
  299|     63|                } else {
  300|      7|                    break;
  301|       |                }
  302|       |            }
  303|      8|            count
  304|      8|        }
  305|       |
  306|       |        /// Claude Work: O(log n), Span: O(log n)
  307|      9|        fn select_key(&self, i: N) -> Option<K> {
  308|      9|            let entries = self.collect();
  309|      9|            if i >= entries.length() {
  310|      2|                None
  311|       |            } else {
  312|      7|                Some(entries.nth(i).0.clone())
  313|       |            }
  314|      9|        }
  315|       |
  316|       |        /// Claude Work: O(log n), Span: O(log n)
  317|      4|        fn split_rank_key(&self, i: N) -> (Self, Self) {
  318|      4|            let entries = self.collect();
  319|      4|            let size = entries.length();
  320|       |
  321|      4|            if i >= size {
  322|      1|                return (self.clone(), Self::empty());
  323|      3|            }
  324|       |
  325|      3|            let mut left_entries = Vec::new();
  326|      3|            let mut right_entries = Vec::new();
  327|       |
  328|      4|            for j in 0..i {
                                      ^3
  329|      4|                left_entries.push(entries.nth(j).clone());
  330|      4|            }
  331|     11|            for j in i..size {
                                   ^3 ^3
  332|     11|                right_entries.push(entries.nth(j).clone());
  333|     11|            }
  334|       |
  335|      3|            let left_seq = AVLTreeSeqStPerS::from_vec(left_entries);
  336|      3|            let right_seq = AVLTreeSeqStPerS::from_vec(right_entries);
  337|       |
  338|      3|            (from_sorted_entries(left_seq), from_sorted_entries(right_seq))
  339|      4|        }
  340|       |    }
  341|       |
  342|       |    impl<K: StT + Ord, V: StT> Clone for OrderedTableStPer<K, V> {
  343|      1|        fn clone(&self) -> Self {
  344|      1|            OrderedTableStPer {
  345|      1|                base_table: self.base_table.clone(),
  346|      1|            }
  347|      1|        }
  348|       |    }
  349|       |
  350|       |    /// Helper function for macro construction
  351|     22|    pub fn from_sorted_entries<K: StT + Ord, V: StT>(entries: AVLTreeSeqStPerS<Pair<K, V>>) -> OrderedTableStPer<K, V> {
  352|       |        // Convert AVLTreeSeqStPerS to Vec for TableStPer helper
  353|     22|        let len = entries.length();
  354|     22|        let mut elements = Vec::new();
  355|    111|        for i in 0..len {
                                  ^22
  356|    111|            elements.push(entries.nth(i).clone());
  357|    111|        }
  358|     22|        OrderedTableStPer {
  359|     22|            base_table: crate::Chap42::TableStPer::TableStPer::from_sorted_entries(elements),
  360|     22|        }
  361|     22|    }
  362|       |
  363|       |    /// Macro for creating ordered tables from sorted key-value pairs
  364|       |    #[macro_export]
  365|       |    macro_rules! OrderedTableStPerLit {
  366|       |        () => {
  367|       |            $crate::Chap43::OrderedTableStPer::OrderedTableStPer::OrderedTableStPer::empty()
  368|       |        };
  369|       |        ($($key:expr => $val:expr),+ $(,)?) => {{
  370|       |            let pairs = vec![$($crate::Types::Types::Pair($key, $val)),+];
  371|       |            let seq = $crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::AVLTreeSeqStPerS::from_vec(pairs);
  372|       |            $crate::Chap43::OrderedTableStPer::OrderedTableStPer::from_sorted_entries(seq)
  373|       |        }};
  374|       |    }
  375|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap44/DocumentIndex.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 44: Document Indexing and Searching implementation.
    3|       |
    4|       |pub mod DocumentIndex {
    5|       |
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::*;
   10|       |    use crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::*;
   11|       |    use crate::Chap42::TableStPer::TableStPer::*;
   12|       |    use crate::Types::Types::*;
   13|       |
   14|       |    pub type Word = String;
   15|       |    pub type DocumentId = String;
   16|       |    pub type Contents = String;
   17|       |    pub type DocumentSet = AVLTreeSetStPer<DocumentId>;
   18|       |
   19|       |    /// Document collection type - sequence of (id, contents) pairs
   20|       |    pub type DocumentCollection = ArraySeqStPerS<Pair<DocumentId, Contents>>;
   21|       |
   22|       |    /// Document Index structure implementing Data Type 44.1
   23|       |    #[derive(PartialEq, Clone)]
   24|       |    pub struct DocumentIndex {
   25|       |        word_to_docs: TableStPer<Word, DocumentSet>,
   26|       |    }
   27|       |
   28|       |    /// Trait defining the Document Index ADT (Data Type 44.1)
   29|       |    pub trait DocumentIndexTrait {
   30|       |        /// claude-4-sonet: Work (n log n), Span (log n), Parallelism (n/log n)
   31|       |        /// Creates an index from a sequence of (id, contents) pairs
   32|       |        fn make_index(docs: &DocumentCollection) -> Self;
   33|       |
   34|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   35|       |        /// Finds documents containing the given word
   36|       |        fn find(&self, word: &Word) -> DocumentSet;
   37|       |
   38|       |        /// claude-4-sonet: Work (m log(1 + n/m)), Span (log n + log m)
   39|       |        /// Logical AND: documents in both sets
   40|       |        fn query_and(docs_a: &DocumentSet, docs_b: &DocumentSet) -> DocumentSet;
   41|       |
   42|       |        /// claude-4-sonet: Work (m log(1 + n/m)), Span (log n + log m)
   43|       |        /// Logical OR: documents in either set
   44|       |        fn query_or(docs_a: &DocumentSet, docs_b: &DocumentSet) -> DocumentSet;
   45|       |
   46|       |        /// claude-4-sonet: Work (m log(1 + n/m)), Span (log n + log m)
   47|       |        /// Logical AND NOT: documents in first set but not second
   48|       |        fn query_and_not(docs_a: &DocumentSet, docs_b: &DocumentSet) -> DocumentSet;
   49|       |
   50|       |        /// claude-4-sonet: Work (1), Span (1)
   51|       |        /// Returns the number of documents in the set
   52|       |        fn size(docs: &DocumentSet) -> N;
   53|       |
   54|       |        /// Claude Work: O(n), Span: O(log n)
   55|       |        /// Converts document set to sequence
   56|       |        fn to_seq(docs: &DocumentSet) -> ArraySeqStPerS<DocumentId>;
   57|       |    }
   58|       |
   59|       |    impl DocumentIndexTrait for DocumentIndex {
   60|       |        /// Claude Work: O(n log n), Span: O(log n)
   61|       |        /// Algorithm 44.2: Make Index
   62|       |        /// Cost dominated by Table.collect which performs a sort
   63|     36|        fn make_index(docs: &DocumentCollection) -> Self {
   64|       |            // Step 1: Create word-document pairs using tagWords
   65|     36|            let mut all_pairs = ArraySeqStPerS::empty();
   66|       |
   67|    258|            for i in 0..docs.length() {
                                      ^36  ^36
   68|    258|                let doc = docs.nth(i);
   69|    258|                let doc_id = &doc.0;
   70|    258|                let content = &doc.1;
   71|    258|                let word_tokens = tokens(content);
   72|       |
   73|       |                // Tag each word with the document ID
   74|  1.46k|                for j in 0..word_tokens.length() {
                                          ^258        ^258
   75|  1.46k|                    let word = word_tokens.nth(j);
   76|  1.46k|                    let pair = Pair(word.clone(), doc_id.clone());
   77|  1.46k|                    let single_seq = ArraySeqStPerS::singleton(pair);
   78|  1.46k|                    all_pairs = ArraySeqStPerS::append(&all_pairs, &single_seq);
   79|  1.46k|                }
   80|       |            }
   81|       |
   82|       |            // Step 2: Build table by inserting word-document pairs
   83|     36|            let mut word_table = TableStPer::empty();
   84|       |
   85|  1.46k|            for i in 0..all_pairs.length() {
                                      ^36       ^36
   86|  1.46k|                let pair = all_pairs.nth(i);
   87|  1.46k|                let word = &pair.0;
   88|  1.46k|                let doc_id = &pair.1;
   89|       |
   90|       |                // Insert or update the word entry
   91|  1.46k|                word_table = word_table.insert(word.clone(), doc_id.clone(), |_old_doc, new_doc| {
                                                                                                               ^932
   92|       |                    // This shouldn't happen since we're building from scratch, but just in case
   93|    932|                    new_doc.clone()
   94|    932|                });
   95|       |            }
   96|       |
   97|       |            // Step 3: Convert the table to have sets as values instead of single documents
   98|     36|            let mut final_table = TableStPer::empty();
   99|     36|            let word_entries = word_table.collect();
  100|       |
  101|    533|            for i in 0..word_entries.length() {
                                      ^36          ^36
  102|    533|                let entry = word_entries.nth(i);
  103|    533|                let word = &entry.0;
  104|    533|                let _doc_id = &entry.1; // Single document ID
  105|       |
  106|       |                // Get all documents for this word by collecting from all_pairs
  107|    533|                let mut doc_ids = ArraySeqStPerS::empty();
  108|  18.6k|                for j in 0..all_pairs.length() {
                                          ^533      ^533
  109|  18.6k|                    let pair = all_pairs.nth(j);
  110|  18.6k|                    if &pair.0 == word {
  111|  1.46k|                        let single_seq = ArraySeqStPerS::singleton(pair.1.clone());
  112|  1.46k|                        doc_ids = ArraySeqStPerS::append(&doc_ids, &single_seq);
  113|  17.2k|                    }
  114|       |                }
  115|       |
  116|       |                // Convert ArraySeqStPerS to AVLTreeSeqStPerS
  117|    533|                let mut doc_vec = Vec::new();
  118|  1.46k|                for k in 0..doc_ids.length() {
                                          ^533    ^533
  119|  1.46k|                    let doc_id = doc_ids.nth(k);
  120|  1.46k|                    doc_vec.push(doc_id.clone());
  121|  1.46k|                }
  122|    533|                let avl_seq = AVLTreeSeqStPerS::from_vec(doc_vec);
  123|       |
  124|       |                // Convert sequence to set to eliminate duplicates
  125|    533|                let doc_set = AVLTreeSetStPer::from_seq(avl_seq);
  126|    533|                final_table = final_table.insert(word.clone(), doc_set, |_old, new| new.clone());
                                                                                                  ^0  ^0
  127|       |            }
  128|       |
  129|     36|            DocumentIndex {
  130|     36|                word_to_docs: final_table,
  131|     36|            }
  132|     36|        }
  133|       |
  134|       |        /// Claude Work: O(log n), Span: O(log n)
  135|       |        /// Algorithm 44.3: find function - simple table lookup
  136|     82|        fn find(&self, word: &Word) -> DocumentSet {
  137|     82|            match self.word_to_docs.find(word) {
  138|     72|                | Some(doc_set) => doc_set,
  139|     10|                | None => AVLTreeSetStPer::empty(),
  140|       |            }
  141|     82|        }
  142|       |
  143|       |        /// Claude Work: O(m log(1 + n/m)), Span: O(log n + log m)
  144|       |        /// Algorithm 44.3: queryAnd - set intersection
  145|     14|        fn query_and(docs_a: &DocumentSet, docs_b: &DocumentSet) -> DocumentSet { docs_a.intersection(docs_b) }
  146|       |
  147|       |        /// Claude Work: O(m log(1 + n/m)), Span: O(log n + log m)
  148|       |        /// Algorithm 44.3: queryOr - set union
  149|     12|        fn query_or(docs_a: &DocumentSet, docs_b: &DocumentSet) -> DocumentSet { docs_a.union(docs_b) }
  150|       |
  151|       |        /// Claude Work: O(m log(1 + n/m)), Span: O(log n + log m)
  152|       |        /// Algorithm 44.3: queryAndNot - set difference
  153|      8|        fn query_and_not(docs_a: &DocumentSet, docs_b: &DocumentSet) -> DocumentSet { docs_a.difference(docs_b) }
  154|       |
  155|       |        /// Claude Work: O(1), Span: O(1)
  156|       |        /// Algorithm 44.3: size function
  157|     35|        fn size(docs: &DocumentSet) -> N { docs.size() }
  158|       |
  159|       |        /// Claude Work: O(n), Span: O(log n)
  160|       |        /// Algorithm 44.3: toSeq function
  161|     23|        fn to_seq(docs: &DocumentSet) -> ArraySeqStPerS<DocumentId> {
  162|     23|            let avl_seq = docs.to_seq();
  163|     23|            let mut array_seq = ArraySeqStPerS::empty();
  164|       |
  165|     49|            for i in 0..avl_seq.length() {
                                      ^23     ^23
  166|     49|                let doc_id = avl_seq.nth(i);
  167|     49|                let single_seq = ArraySeqStPerS::singleton(doc_id.clone());
  168|     49|                array_seq = ArraySeqStPerS::append(&array_seq, &single_seq);
  169|     49|            }
  170|       |
  171|     23|            array_seq
  172|     23|        }
  173|       |    }
  174|       |
  175|       |    impl DocumentIndex {
  176|       |        /// Helper function to create an empty index
  177|      0|        pub fn empty() -> Self {
  178|      0|            DocumentIndex {
  179|      0|                word_to_docs: TableStPer::empty(),
  180|      0|            }
  181|      0|        }
  182|       |
  183|       |        /// Get all words in the index
  184|      2|        pub fn get_all_words(&self) -> ArraySeqStPerS<Word> {
  185|      2|            let entries = self.word_to_docs.collect();
  186|      2|            let mut words = ArraySeqStPerS::empty();
  187|       |
  188|     30|            for i in 0..entries.length() {
                                      ^2      ^2
  189|     30|                let entry = entries.nth(i);
  190|     30|                let single_seq = ArraySeqStPerS::singleton(entry.0.clone());
  191|     30|                words = ArraySeqStPerS::append(&words, &single_seq);
  192|     30|            }
  193|       |
  194|      2|            words
  195|      2|        }
  196|       |
  197|       |        /// Get the total number of unique words in the index
  198|      8|        pub fn word_count(&self) -> N { self.word_to_docs.size() }
  199|       |    }
  200|       |
  201|       |    /// Tokenization function: splits content into words
  202|       |    /// Claude Work: O(m), Span: O(1) where m is the length of the content string
  203|    269|    pub fn tokens(content: &Contents) -> ArraySeqStPerS<Word> {
  204|    269|        let mut words = ArraySeqStPerS::empty();
  205|    269|        let content_lower = content.to_lowercase();
  206|       |
  207|       |        // Simple tokenization: split on whitespace and punctuation
  208|    269|        let mut current_word = String::new();
  209|       |
  210|  8.76k|        for ch in content_lower.chars() {
                                ^269          ^269
  211|  8.76k|            if ch.is_alphabetic() {
  212|  6.99k|                current_word.push(ch);
  213|  6.99k|            } else if !current_word.is_empty() {
                                    ^1.77k
  214|  1.34k|                let single_seq = ArraySeqStPerS::singleton(current_word.clone());
  215|  1.34k|                words = ArraySeqStPerS::append(&words, &single_seq);
  216|  1.34k|                current_word = String::new();
  217|  1.34k|            }
                          ^426
  218|       |        }
  219|       |
  220|       |        // Don't forget the last word
  221|    269|        if !current_word.is_empty() {
  222|    165|            let single_seq = ArraySeqStPerS::singleton(current_word);
  223|    165|            words = ArraySeqStPerS::append(&words, &single_seq);
  224|    165|        }
                      ^104
  225|       |
  226|    269|        words
  227|    269|    }
  228|       |
  229|       |    /// Convenience function for staged computation pattern (Example 44.2)
  230|       |    /// Creates a partially applied find function for a given index
  231|      0|    pub fn create_finder(index: &DocumentIndex) -> impl Fn(&Word) -> DocumentSet + '_ {
  232|      0|        move |word: &Word| index.find(word)
  233|      0|    }
  234|       |
  235|       |    impl Display for DocumentIndex {
  236|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  237|      0|            write!(
  238|      0|                f,
  239|      0|                "DocumentIndex(words: {}, total_mappings: {})",
  240|      0|                self.word_count(),
  241|      0|                self.word_to_docs.size()
  242|       |            )
  243|      0|        }
  244|       |    }
  245|       |
  246|       |    impl Debug for DocumentIndex {
  247|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  248|      0|            f.debug_struct("DocumentIndex")
  249|      0|                .field("word_count", &self.word_count())
  250|      0|                .field("word_to_docs", &self.word_to_docs)
  251|      0|                .finish()
  252|      0|        }
  253|       |    }
  254|       |
  255|       |    // Macro for creating document collections
  256|       |    #[macro_export]
  257|       |    macro_rules! DocumentCollectionLit {
  258|       |        ($($id:expr => $content:expr),* $(,)?) => {{
  259|       |            #[allow(unused_mut)]
  260|       |            let mut docs = $crate::Chap19::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS::empty();
  261|       |            $(
  262|       |                let pair = $crate::Types::Types::Pair($id.to_string(), $content.to_string());
  263|       |                let single_seq = $crate::Chap19::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS::singleton(pair);
  264|       |                docs = $crate::Chap19::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS::append(&docs, &single_seq);
  265|       |            )*
  266|       |            docs
  267|       |        }};
  268|       |        () => {{
  269|       |            $crate::Chap19::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS::empty()
  270|       |        }};
  271|       |    }
  272|       |
  273|       |    #[allow(dead_code)]
  274|      0|    fn _document_collection_lit_type_checks() {
  275|      0|        let _: DocumentCollection = DocumentCollectionLit![
  276|      0|            "doc1" => "hello world",
  277|      0|            "doc2" => "world peace"
  278|       |        ];
  279|      0|        let _: DocumentCollection = DocumentCollectionLit![];
  280|      0|    }
  281|       |
  282|       |    /// Complex query builder for chaining operations
  283|       |    pub struct QueryBuilder<'a> {
  284|       |        index: &'a DocumentIndex,
  285|       |    }
  286|       |
  287|       |    impl<'a> QueryBuilder<'a> {
  288|      2|        pub fn new(index: &'a DocumentIndex) -> Self { QueryBuilder { index } }
  289|       |
  290|     11|        pub fn find(&self, word: &Word) -> DocumentSet { self.index.find(word) }
  291|       |
  292|      3|        pub fn and(&self, docs_a: DocumentSet, docs_b: DocumentSet) -> DocumentSet {
  293|      3|            DocumentIndex::query_and(&docs_a, &docs_b)
  294|      3|        }
  295|       |
  296|      2|        pub fn or(&self, docs_a: DocumentSet, docs_b: DocumentSet) -> DocumentSet {
  297|      2|            DocumentIndex::query_or(&docs_a, &docs_b)
  298|      2|        }
  299|       |
  300|      2|        pub fn and_not(&self, docs_a: DocumentSet, docs_b: DocumentSet) -> DocumentSet {
  301|      2|            DocumentIndex::query_and_not(&docs_a, &docs_b)
  302|      2|        }
  303|       |
  304|       |        /// Complex query: (word1 AND word2) OR (word3 AND NOT word4)
  305|      2|        pub fn complex_query(&self, word1: &Word, word2: &Word, word3: &Word, word4: &Word) -> DocumentSet {
  306|      2|            let set1 = self.find(word1);
  307|      2|            let set2 = self.find(word2);
  308|      2|            let set3 = self.find(word3);
  309|      2|            let set4 = self.find(word4);
  310|       |
  311|      2|            let left_side = self.and(set1, set2);
  312|      2|            let right_side = self.and_not(set3, set4);
  313|       |
  314|      2|            self.or(left_side, right_side)
  315|      2|        }
  316|       |    }
  317|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap44/Example44_1.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 44: Example 44.1 - Tweet Document Collection
    3|       |
    4|       |pub mod Example44_1 {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Chap44::DocumentIndex::DocumentIndex::*;
    8|       |    use crate::DocumentCollectionLit;
    9|       |    use crate::Types::Types::*;
   10|       |
   11|     23|    pub fn create_tweet_collection() -> DocumentCollection {
   12|     23|        DocumentCollectionLit![
   13|     23|            "jack" => "chess is fun",
   14|     23|            "mary" => "I had fun in dance club today",
   15|     23|            "nick" => "food at the cafeteria sucks",
   16|     23|            "josefa" => "rock climbing was a blast",
   17|     23|            "peter" => "I had fun at the party, food was great"
   18|       |        ]
   19|     23|    }
   20|       |
   21|       |    /// Creates the document index for the tweet collection
   22|     20|    pub fn create_tweet_index() -> DocumentIndex {
   23|     20|        let tweets = create_tweet_collection();
   24|     20|        DocumentIndex::make_index(&tweets)
   25|     20|    }
   26|       |
   27|       |    /// Example 44.2: Staged computation pattern
   28|       |    /// fw : word  docs = find (makeIndex T)
   29|       |    /// Creates a partially applied find function for the tweet index
   30|      1|    pub fn create_tweet_finder() -> impl Fn(&Word) -> DocumentSet {
   31|      1|        let index = create_tweet_index();
   32|      3|        move |word: &Word| index.find(word)
   33|      1|    }
   34|       |
   35|       |    /// Demonstrates the example queries from the textbook
   36|       |    pub struct TweetQueryExamples {
   37|       |        index: DocumentIndex,
   38|       |        fw: Box<dyn Fn(&Word) -> DocumentSet>,
   39|       |    }
   40|       |
   41|       |    impl TweetQueryExamples {
   42|     14|        pub fn new() -> Self {
   43|     14|            let index = create_tweet_index();
   44|     14|            let index_clone = index.clone();
   45|     28|            let fw = Box::new(move |word: &Word| index_clone.find(word));
                              ^14  ^14
   46|       |
   47|     14|            TweetQueryExamples { index, fw }
   48|     14|        }
   49|       |
   50|       |        /// Example query: searching for 'fun' should return {"jack", "mary", "peter"}
   51|      7|        pub fn search_fun(&self) -> DocumentSet { (self.fw)(&"fun".to_string()) }
   52|       |
   53|       |        /// Example query: searching for 'club' should return {"mary"}
   54|      2|        pub fn search_club(&self) -> DocumentSet { (self.fw)(&"club".to_string()) }
   55|       |
   56|       |        /// Example query: searching for 'food' should return {"nick", "peter"}
   57|      3|        pub fn search_food(&self) -> DocumentSet { (self.fw)(&"food".to_string()) }
   58|       |
   59|       |        /// Example query: searching for 'chess' should return {"jack"}
   60|      2|        pub fn search_chess(&self) -> DocumentSet { (self.fw)(&"chess".to_string()) }
   61|       |
   62|       |        /// Complex query from textbook:
   63|       |        /// toSeq (queryAnd ((fw 'fun'), queryOr ((fw 'food'), (fw 'chess'))))
   64|       |        /// Returns documents that contain 'fun' AND either 'food' OR 'chess'
   65|       |        /// Expected result: 'jack', 'peter'
   66|      2|        pub fn complex_query_fun_and_food_or_chess(&self) -> ArraySeqStPerS<DocumentId> {
   67|      2|            let fun_docs = (self.fw)(&"fun".to_string());
   68|      2|            let food_docs = (self.fw)(&"food".to_string());
   69|      2|            let chess_docs = (self.fw)(&"chess".to_string());
   70|       |
   71|      2|            let food_or_chess = DocumentIndex::query_or(&food_docs, &chess_docs);
   72|      2|            let result = DocumentIndex::query_and(&fun_docs, &food_or_chess);
   73|       |
   74|      2|            DocumentIndex::to_seq(&result)
   75|      2|        }
   76|       |
   77|       |        /// Complex query from textbook:
   78|       |        /// size (queryAndNot ((fw 'fun'), (fw 'chess')))
   79|       |        /// Returns the number of documents that contain 'fun' but not 'chess'
   80|       |        /// Expected result: 2 (mary and peter)
   81|      2|        pub fn count_fun_but_not_chess(&self) -> N {
   82|      2|            let fun_docs = (self.fw)(&"fun".to_string());
   83|      2|            let chess_docs = (self.fw)(&"chess".to_string());
   84|       |
   85|      2|            let result = DocumentIndex::query_and_not(&fun_docs, &chess_docs);
   86|      2|            DocumentIndex::size(&result)
   87|      2|        }
   88|       |
   89|       |        /// Additional example: documents with 'food' OR 'fun'
   90|      1|        pub fn search_food_or_fun(&self) -> DocumentSet {
   91|      1|            let food_docs = (self.fw)(&"food".to_string());
   92|      1|            let fun_docs = (self.fw)(&"fun".to_string());
   93|       |
   94|      1|            DocumentIndex::query_or(&food_docs, &fun_docs)
   95|      1|        }
   96|       |
   97|       |        /// Additional example: documents with 'party' AND 'food'
   98|      1|        pub fn search_party_and_food(&self) -> DocumentSet {
   99|      1|            let party_docs = (self.fw)(&"party".to_string());
  100|      1|            let food_docs = (self.fw)(&"food".to_string());
  101|       |
  102|      1|            DocumentIndex::query_and(&party_docs, &food_docs)
  103|      1|        }
  104|       |
  105|       |        /// Get all unique words in the tweet collection
  106|      1|        pub fn get_all_words(&self) -> ArraySeqStPerS<Word> { self.index.get_all_words() }
  107|       |
  108|       |        /// Get word count statistics
  109|      1|        pub fn get_word_count(&self) -> N { self.index.word_count() }
  110|       |
  111|       |        /// Demonstrate query builder pattern
  112|      1|        pub fn query_builder_example(&self) -> DocumentSet {
  113|      1|            let builder = QueryBuilder::new(&self.index);
  114|       |
  115|       |            // Complex query: (fun AND party) OR (chess AND NOT food)
  116|      1|            builder.complex_query(
  117|      1|                &"fun".to_string(),
  118|      1|                &"party".to_string(),
  119|      1|                &"chess".to_string(),
  120|      1|                &"food".to_string(),
  121|       |            )
  122|      1|        }
  123|       |    }
  124|       |
  125|       |    /// Helper function to convert document set to sorted vector for testing
  126|     11|    pub fn doc_set_to_sorted_vec(docs: &DocumentSet) -> Vec<DocumentId> {
  127|     11|        let seq = DocumentIndex::to_seq(docs);
  128|     11|        let mut result = Vec::new();
  129|       |
  130|     22|        for i in 0..seq.length() {
                                  ^11 ^11
  131|     22|            let doc_id = seq.nth(i);
  132|     22|            result.push(doc_id.clone());
  133|     22|        }
  134|       |
  135|     11|        result.sort();
  136|     11|        result
  137|     11|    }
  138|       |
  139|       |    /// Verify the expected results from the textbook examples
  140|      1|    pub fn verify_textbook_examples() -> bool {
  141|      1|        let examples = TweetQueryExamples::new();
  142|       |
  143|       |        // Test 1: searching for 'fun' should return {"jack", "mary", "peter"}
  144|      1|        let fun_results = doc_set_to_sorted_vec(&examples.search_fun());
  145|      1|        let expected_fun = vec!["jack".to_string(), "mary".to_string(), "peter".to_string()];
  146|      1|        if fun_results != expected_fun {
  147|      0|            return false;
  148|      1|        }
  149|       |
  150|       |        // Test 2: searching for 'club' should return {"mary"}
  151|      1|        let club_results = doc_set_to_sorted_vec(&examples.search_club());
  152|      1|        let expected_club = vec!["mary".to_string()];
  153|      1|        if club_results != expected_club {
  154|      0|            return false;
  155|      1|        }
  156|       |
  157|       |        // Test 3: complex query should return 'jack', 'peter'
  158|      1|        let complex_results = examples.complex_query_fun_and_food_or_chess();
  159|      1|        let mut complex_vec = Vec::new();
  160|      2|        for i in 0..complex_results.length() {
                                  ^1              ^1
  161|      2|            let doc_id = complex_results.nth(i);
  162|      2|            complex_vec.push(doc_id.clone());
  163|      2|        }
  164|      1|        complex_vec.sort();
  165|      1|        let expected_complex = vec!["jack".to_string(), "peter".to_string()];
  166|      1|        if complex_vec != expected_complex {
  167|      0|            return false;
  168|      1|        }
  169|       |
  170|       |        // Test 4: count query should return 2
  171|      1|        let count_result = examples.count_fun_but_not_chess();
  172|      1|        if count_result != 2 {
  173|      0|            return false;
  174|      1|        }
  175|       |
  176|      1|        true
  177|      1|    }
  178|       |
  179|       |    /// Performance demonstration: compare indexed search vs brute force
  180|      1|    pub fn performance_comparison_demo() -> (N, N) {
  181|      1|        let tweets = create_tweet_collection();
  182|      1|        let _index = create_tweet_index();
  183|       |
  184|       |        // Indexed search work: O(log n) for find
  185|      1|        let indexed_work = 1; // Represents O(log n) complexity
  186|       |
  187|       |        // Brute force work: O(n * m) where n is documents, m is average content length
  188|      1|        let brute_force_work = tweets.length(); // Represents O(n) complexity
  189|       |
  190|      1|        (indexed_work, brute_force_work)
  191|      1|    }
  192|       |
  193|       |    /// Demonstrate the tokenization process
  194|      1|    pub fn tokenization_demo() -> ArraySeqStPerS<Word> {
  195|      1|        let sample_content = "I had fun in dance club today!";
  196|      1|        tokens(&sample_content.to_string())
  197|      1|    }
  198|       |
  199|       |    /// Show index statistics for the tweet collection
  200|      1|    pub fn index_statistics() -> (N, N, N) {
  201|      1|        let tweets = create_tweet_collection();
  202|      1|        let index = create_tweet_index();
  203|       |
  204|      1|        let document_count = tweets.length();
  205|      1|        let unique_word_count = index.word_count();
  206|       |
  207|       |        // Calculate total words across all documents
  208|      1|        let mut total_words = 0;
  209|      5|        for i in 0..tweets.length() {
                                  ^1     ^1
  210|      5|            let doc = tweets.nth(i);
  211|      5|            let word_tokens = tokens(&doc.1);
  212|      5|            total_words += word_tokens.length();
  213|      5|        }
  214|       |
  215|      1|        (document_count, unique_word_count, total_words)
  216|      1|    }
  217|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap45/BalancedTreePQ.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 45: Priority Queue implementation using Balanced Trees (AVL Tree)
    3|       |
    4|       |pub mod BalancedTreePQ {
    5|       |
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |
    8|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::*;
    9|       |    use crate::Types::Types::*;
   10|       |
   11|       |    #[derive(PartialEq, Clone, Debug)]
   12|       |    pub struct BalancedTreePQ<T: StT + Ord> {
   13|       |        elements: AVLTreeSeqStPerS<T>,
   14|       |    }
   15|       |
   16|       |    /// Trait defining the Meldable Priority Queue ADT operations (Data Type 45.1)
   17|       |    pub trait BalancedTreePQTrait<T: StT + Ord> {
   18|       |        /// claude-4-sonet: Work (1), Span (1)
   19|       |        fn empty() -> Self;
   20|       |
   21|       |        /// claude-4-sonet: Work (1), Span (1)
   22|       |        fn singleton(element: T) -> Self;
   23|       |
   24|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   25|       |        /// Returns the minimum element (leftmost in balanced tree), or None if empty
   26|       |        fn find_min(&self) -> Option<&T>;
   27|       |
   28|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   29|       |        /// Inserts element into balanced tree maintaining order
   30|       |        fn insert(&self, element: T) -> Self;
   31|       |
   32|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   33|       |        /// Removes minimum element (leftmost) from balanced tree
   34|       |        fn delete_min(&self) -> (Self, Option<T>)
   35|       |        where
   36|       |            Self: Sized;
   37|       |
   38|       |        /// claude-4-sonet: Work (m log(1 + n/m)), Span (log n + log m)
   39|       |        /// Melds two balanced trees using union operation
   40|       |        fn meld(&self, other: &Self) -> Self;
   41|       |
   42|       |        /// claude-4-sonet: Work (n log n), Span (log n), Parallelism (n/log n)
   43|       |        /// Creates priority queue from sequence using balanced tree construction
   44|       |        fn from_seq(seq: &AVLTreeSeqStPerS<T>) -> Self;
   45|       |
   46|       |        /// Helper methods
   47|       |        fn size(&self) -> N;
   48|       |        fn is_empty(&self) -> bool;
   49|       |        fn to_seq(&self) -> AVLTreeSeqStPerS<T>;
   50|       |    }
   51|       |
   52|       |    impl<T: StT + Ord> BalancedTreePQTrait<T> for BalancedTreePQ<T> {
   53|       |        /// Claude Work: (1), Span: (1)
   54|     68|        fn empty() -> Self {
   55|     68|            BalancedTreePQ {
   56|     68|                elements: AVLTreeSeqStPerS::empty(),
   57|     68|            }
   58|     68|        }
   59|       |
   60|       |        /// Claude Work: (1), Span: (1)
   61|      3|        fn singleton(element: T) -> Self {
   62|      3|            BalancedTreePQ {
   63|      3|                elements: AVLTreeSeqStPerS::singleton(element),
   64|      3|            }
   65|      3|        }
   66|       |
   67|       |        /// Claude Work: (log n), Span: (log n)
   68|       |        /// Find minimum element (leftmost in balanced tree)
   69|     21|        fn find_min(&self) -> Option<&T> {
   70|     21|            if self.elements.length() == 0 {
   71|      1|                None
   72|       |            } else {
   73|       |                // Minimum is at index 0 in sorted sequence
   74|     20|                Some(self.elements.nth(0))
   75|       |            }
   76|     21|        }
   77|       |
   78|       |        /// Claude Work: (log n), Span: (log n)
   79|       |        /// Insert element maintaining balanced tree structure
   80|    376|        fn insert(&self, element: T) -> Self {
   81|       |            // Convert to vector, insert in sorted position, rebuild tree
   82|    376|            let mut values = self.elements.values_in_order();
   83|       |
   84|       |            // Find insertion position
   85|    376|            let mut insert_pos = values.len();
   86|  3.20k|            for (i, current) in values.iter().enumerate() {
                                              ^376          ^376
   87|  3.20k|                if element <= *current {
   88|    218|                    insert_pos = i;
   89|    218|                    break;
   90|  2.98k|                }
   91|       |            }
   92|       |
   93|       |            // Insert element at correct position
   94|    376|            values.insert(insert_pos, element);
   95|       |
   96|    376|            BalancedTreePQ {
   97|    376|                elements: AVLTreeSeqStPerS::from_vec(values),
   98|    376|            }
   99|    376|        }
  100|       |
  101|       |        /// Claude Work: (log n), Span: (log n)
  102|       |        /// Remove minimum element (first element in sorted sequence)
  103|    118|        fn delete_min(&self) -> (Self, Option<T>) {
  104|    118|            if self.elements.length() == 0 {
  105|      1|                return (self.clone(), None);
  106|    117|            }
  107|       |
  108|    117|            let min_element = self.elements.nth(0).clone();
  109|       |
  110|       |            // Convert to vector, remove first element, rebuild tree
  111|    117|            let mut values = self.elements.values_in_order();
  112|    117|            values.remove(0);
  113|       |
  114|    117|            let new_pq = BalancedTreePQ {
  115|    117|                elements: AVLTreeSeqStPerS::from_vec(values),
  116|    117|            };
  117|       |
  118|    117|            (new_pq, Some(min_element))
  119|    118|        }
  120|       |
  121|       |        /// Claude Work: (m log(1 + n/m)), Span: (log n + log m)
  122|       |        /// Meld two balanced trees by merging sorted sequences
  123|      5|        fn meld(&self, other: &Self) -> Self {
  124|       |            // Get sorted values from both trees
  125|      5|            let values1 = self.elements.values_in_order();
  126|      5|            let values2 = other.elements.values_in_order();
  127|       |
  128|       |            // Merge the two sorted vectors
  129|      5|            let mut merged = Vec::with_capacity(values1.len() + values2.len());
  130|      5|            let mut i = 0;
  131|      5|            let mut j = 0;
  132|       |
  133|     21|            while i < values1.len() && j < values2.len() {
                                                     ^19
  134|     16|                if values1[i] <= values2[j] {
  135|     10|                    merged.push(values1[i].clone());
  136|     10|                    i += 1;
  137|     10|                } else {
  138|      6|                    merged.push(values2[j].clone());
  139|      6|                    j += 1;
  140|      6|                }
  141|       |            }
  142|       |
  143|       |            // Add remaining elements
  144|      9|            while i < values1.len() {
  145|      4|                merged.push(values1[i].clone());
  146|      4|                i += 1;
  147|      4|            }
  148|      9|            while j < values2.len() {
  149|      4|                merged.push(values2[j].clone());
  150|      4|                j += 1;
  151|      4|            }
  152|       |
  153|      5|            BalancedTreePQ {
  154|      5|                elements: AVLTreeSeqStPerS::from_vec(merged),
  155|      5|            }
  156|      5|        }
  157|       |
  158|       |        /// Claude Work: (n log n), Span: (log n)
  159|       |        /// Create priority queue from sequence by inserting elements one by one
  160|      1|        fn from_seq(seq: &AVLTreeSeqStPerS<T>) -> Self {
  161|      1|            let mut result = Self::empty();
  162|      6|            for i in 0..seq.length() {
                                      ^1  ^1
  163|      6|                let element = seq.nth(i);
  164|      6|                result = result.insert(element.clone());
  165|      6|            }
  166|      1|            result
  167|      1|        }
  168|       |
  169|       |        /// Claude Work: (1), Span: (1)
  170|     32|        fn size(&self) -> N { self.elements.length() }
  171|       |
  172|       |        /// Claude Work: (1), Span: (1)
  173|    123|        fn is_empty(&self) -> bool { self.elements.length() == 0 }
  174|       |
  175|       |        /// Claude Work: (1), Span: (1)
  176|      1|        fn to_seq(&self) -> AVLTreeSeqStPerS<T> { self.elements.clone() }
  177|       |    }
  178|       |
  179|       |    impl<T: StT + Ord> BalancedTreePQ<T> {
  180|       |        /// Get the maximum element (rightmost in balanced tree)
  181|     10|        pub fn find_max(&self) -> Option<&T> {
  182|     10|            if self.elements.length() == 0 {
  183|      1|                None
  184|       |            } else {
  185|      9|                Some(self.elements.nth(self.elements.length() - 1))
  186|       |            }
  187|     10|        }
  188|       |
  189|       |        /// Remove and return maximum element
  190|      3|        pub fn delete_max(&self) -> (Self, Option<T>) {
  191|      3|            if self.elements.length() == 0 {
  192|      1|                return (self.clone(), None);
  193|      2|            }
  194|       |
  195|      2|            let max_index = self.elements.length() - 1;
  196|      2|            let max_element = self.elements.nth(max_index).clone();
  197|       |
  198|       |            // Convert to vector, remove last element, rebuild tree
  199|      2|            let mut values = self.elements.values_in_order();
  200|      2|            values.remove(max_index);
  201|       |
  202|      2|            let new_pq = BalancedTreePQ {
  203|      2|                elements: AVLTreeSeqStPerS::from_vec(values),
  204|      2|            };
  205|       |
  206|      2|            (new_pq, Some(max_element))
  207|      3|        }
  208|       |
  209|       |        /// Insert multiple elements from a sequence
  210|      1|        pub fn insert_all(&self, elements: &AVLTreeSeqStPerS<T>) -> Self {
  211|      1|            let mut result = self.clone();
  212|      4|            for i in 0..elements.length() {
                                      ^1       ^1
  213|      4|                let element = elements.nth(i);
  214|      4|                result = result.insert(element.clone());
  215|      4|            }
  216|      1|            result
  217|      1|        }
  218|       |
  219|       |        /// Extract all elements in sorted order (already sorted)
  220|      1|        pub fn extract_all_sorted(&self) -> AVLTreeSeqStPerS<T> { self.elements.clone() }
  221|       |
  222|       |        /// Check if element exists in the priority queue
  223|     13|        pub fn contains(&self, element: &T) -> bool {
  224|     26|            for i in 0..self.elements.length() {
                                      ^13           ^13
  225|     26|                let current = self.elements.nth(i);
  226|     26|                if current == element {
  227|      7|                    return true;
  228|     19|                }
  229|     19|                if current > element {
  230|       |                    // Since sequence is sorted, we can stop early
  231|      4|                    break;
  232|     15|                }
  233|       |            }
  234|      6|            false
  235|     13|        }
  236|       |
  237|       |        /// Remove a specific element (not necessarily minimum)
  238|      3|        pub fn remove(&self, element: &T) -> (Self, bool) {
  239|      3|            let mut values = self.elements.values_in_order();
  240|       |
  241|      7|            for (i, current) in values.iter().enumerate() {
                                              ^3            ^3
  242|      7|                if current == element {
  243|      2|                    values.remove(i);
  244|      2|                    let new_pq = BalancedTreePQ {
  245|      2|                        elements: AVLTreeSeqStPerS::from_vec(values),
  246|      2|                    };
  247|      2|                    return (new_pq, true);
  248|      5|                }
  249|      5|                if current > element {
  250|       |                    // Element not found (would be here if it existed)
  251|      0|                    break;
  252|      5|                }
  253|       |            }
  254|      1|            (self.clone(), false)
  255|      3|        }
  256|       |
  257|       |        /// Get elements in a range [min_val, max_val]
  258|      2|        pub fn range(&self, min_val: &T, max_val: &T) -> AVLTreeSeqStPerS<T> {
  259|      2|            let values = self.elements.values_in_order();
  260|      2|            let mut range_values = Vec::new();
  261|       |
  262|      7|            for current in values.iter() {
                                         ^2     ^2
  263|      7|                if current >= min_val && current <= max_val {
                                                       ^6
  264|      4|                    range_values.push(current.clone());
  265|      4|                } else if current > max_val {
                                        ^3
  266|       |                    // Since sequence is sorted, we can stop
  267|      2|                    break;
  268|      1|                }
  269|       |            }
  270|       |
  271|      2|            AVLTreeSeqStPerS::from_vec(range_values)
  272|      2|        }
  273|       |    }
  274|       |
  275|       |    impl<T: StT + Ord> Default for BalancedTreePQ<T> {
  276|      1|        fn default() -> Self { Self::empty() }
  277|       |    }
  278|       |
  279|       |    impl<T: StT + Ord> Display for BalancedTreePQ<T> {
  280|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  281|      1|            write!(f, "BalancedTreePQ[")?;
                                                      ^0
  282|      3|            for i in 0..self.elements.length() {
                                      ^1            ^1
  283|      3|                if i > 0 {
  284|      2|                    write!(f, ", ")?;
                                                 ^0
  285|      1|                }
  286|      3|                write!(f, "{}", self.elements.nth(i))?;
                                                                   ^0
  287|       |            }
  288|      1|            write!(f, "]")
  289|      1|        }
  290|       |    }
  291|       |
  292|       |    // Macro for creating balanced tree priority queues
  293|       |    #[macro_export]
  294|       |    macro_rules! BalancedTreePQLit {
  295|       |        () => {
  296|       |            $crate::Chap45::BalancedTreePQ::BalancedTreePQ::BalancedTreePQ::empty()
  297|       |        };
  298|       |        ($($x:expr),* $(,)?) => {{
  299|       |            let mut pq = $crate::Chap45::BalancedTreePQ::BalancedTreePQ::BalancedTreePQ::empty();
  300|       |            $(
  301|       |                pq = pq.insert($x);
  302|       |            )*
  303|       |            pq
  304|       |        }};
  305|       |    }
  306|       |
  307|       |    #[allow(dead_code)]
  308|      0|    fn _balanced_tree_pq_lit_type_checks() {
  309|      0|        let _: BalancedTreePQ<i32> = BalancedTreePQLit![];
  310|      0|        let _: BalancedTreePQ<i32> = BalancedTreePQLit![1, 2, 3];
  311|      0|    }
  312|       |
  313|       |    /// Convenience functions for common operations
  314|       |    impl<T: StT + Ord> BalancedTreePQ<T> {
  315|       |        /// Create priority queue from vector (for testing)
  316|      1|        pub fn from_vec(vec: Vec<T>) -> Self {
  317|      1|            let mut pq = Self::empty();
  318|      6|            for element in vec {
                              ^5
  319|      5|                pq = pq.insert(element);
  320|      5|            }
  321|      1|            pq
  322|      1|        }
  323|       |
  324|       |        /// Convert to vector (for testing)
  325|      2|        pub fn to_vec(&self) -> Vec<T> {
  326|      2|            let mut result = Vec::new();
  327|      8|            for i in 0..self.elements.length() {
                                      ^2            ^2
  328|      8|                result.push(self.elements.nth(i).clone());
  329|      8|            }
  330|      2|            result
  331|      2|        }
  332|       |
  333|       |        /// Get elements in sorted order as vector (for testing)
  334|      1|        pub fn to_sorted_vec(&self) -> Vec<T> {
  335|       |            // Already sorted, just convert to vector
  336|      1|            self.to_vec()
  337|      1|        }
  338|       |
  339|       |        /// Check if the tree maintains sorted order (for testing)
  340|      2|        pub fn is_sorted(&self) -> bool {
  341|      4|            for i in 1..self.elements.length() {
                                      ^2            ^2
  342|      4|                let prev = self.elements.nth(i - 1);
  343|      4|                let curr = self.elements.nth(i);
  344|      4|                if prev > curr {
  345|      0|                    return false;
  346|      4|                }
  347|       |            }
  348|      2|            true
  349|      2|        }
  350|       |
  351|       |        /// Get height of the underlying AVL tree (for testing)
  352|      4|        pub fn height(&self) -> N {
  353|       |            // This would require access to internal tree structure
  354|       |            // For now, return log(n) as expected height
  355|      4|            if self.elements.length() == 0 {
  356|      1|                0
  357|       |            } else {
  358|      3|                ((self.elements.length() as f64).log2().ceil() as N).max(1)
  359|       |            }
  360|      4|        }
  361|       |    }
  362|       |
  363|       |    /// Advanced operations for balanced tree priority queue
  364|       |    impl<T: StT + Ord> BalancedTreePQ<T> {
  365|       |        /// Split the priority queue at a given element
  366|       |        /// Returns (left, found, right) where left < element <= right
  367|      2|        pub fn split(&self, element: &T) -> (Self, bool, Self) {
  368|      2|            let mut left = Self::empty();
  369|      2|            let mut right = Self::empty();
  370|      2|            let mut found = false;
  371|       |
  372|     10|            for i in 0..self.elements.length() {
                                      ^2            ^2
  373|     10|                let current = self.elements.nth(i);
  374|     10|                if current < element {
  375|      4|                    left = left.insert(current.clone());
  376|      6|                } else if current == element {
  377|      1|                    found = true;
  378|      1|                    right = right.insert(current.clone());
  379|      5|                } else {
  380|      5|                    right = right.insert(current.clone());
  381|      5|                }
  382|       |            }
  383|       |
  384|      2|            (left, found, right)
  385|      2|        }
  386|       |
  387|       |        /// Join two priority queues where all elements in left <= all elements in right
  388|      1|        pub fn join(left: &Self, right: &Self) -> Self { left.meld(right) }
  389|       |
  390|       |        /// Filter elements based on a predicate
  391|      2|        pub fn filter<F>(&self, predicate: F) -> Self
  392|      2|        where
  393|      2|            F: Fn(&T) -> bool,
  394|       |        {
  395|      2|            let mut result = Self::empty();
  396|       |
  397|     10|            for i in 0..self.elements.length() {
                                      ^2            ^2
  398|     10|                let current = self.elements.nth(i);
  399|     10|                if predicate(current) {
  400|      4|                    result = result.insert(current.clone());
  401|      6|                }
  402|       |            }
  403|       |
  404|      2|            result
  405|      2|        }
  406|       |
  407|       |        /// Map elements to a new type (maintaining order)
  408|      2|        pub fn map<U, F>(&self, f: F) -> BalancedTreePQ<U>
  409|      2|        where
  410|      2|            U: StT + Ord,
  411|      2|            F: Fn(&T) -> U,
  412|       |        {
  413|      2|            let mut result = BalancedTreePQ::<U>::empty();
  414|       |
  415|      7|            for i in 0..self.elements.length() {
                                      ^2            ^2
  416|      7|                let current = self.elements.nth(i);
  417|      7|                let mapped = f(current);
  418|      7|                result = result.insert(mapped);
  419|      7|            }
  420|       |
  421|      2|            result
  422|      2|        }
  423|       |    }
  424|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap45/BinaryHeapPQ.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 45: Priority Queue implementation using Binary Heap
    3|       |
    4|       |pub mod BinaryHeapPQ {
    5|       |
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |    use crate::Types::Types::*;
   10|       |
   11|       |    #[derive(PartialEq, Clone, Debug)]
   12|       |    pub struct BinaryHeapPQ<T: StT + Ord> {
   13|       |        elements: ArraySeqStPerS<T>,
   14|       |    }
   15|       |
   16|       |    /// Trait defining the Meldable Priority Queue ADT operations (Data Type 45.1)
   17|       |    pub trait BinaryHeapPQTrait<T: StT + Ord> {
   18|       |        /// claude-4-sonet: Work (1), Span (1)
   19|       |        fn empty() -> Self;
   20|       |
   21|       |        /// claude-4-sonet: Work (1), Span (1)
   22|       |        fn singleton(element: T) -> Self;
   23|       |
   24|       |        /// claude-4-sonet: Work (1), Span (1)
   25|       |        /// Returns the minimum element (root of min-heap), or None if empty
   26|       |        fn find_min(&self) -> Option<&T>;
   27|       |
   28|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   29|       |        /// Inserts element and bubbles up to maintain heap property
   30|       |        fn insert(&self, element: T) -> Self;
   31|       |
   32|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   33|       |        /// Removes root (minimum) and bubbles down to maintain heap property
   34|       |        fn delete_min(&self) -> (Self, Option<T>)
   35|       |        where
   36|       |            Self: Sized;
   37|       |
   38|       |        /// claude-4-sonet: Work (m + n), Span (m + n), Parallelism (1)
   39|       |        /// Melds two heaps by concatenating and re-heapifying
   40|       |        fn meld(&self, other: &Self) -> Self;
   41|       |
   42|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   43|       |        /// Creates heap from sequence using bottom-up heapify
   44|       |        fn from_seq(seq: &ArraySeqStPerS<T>) -> Self;
   45|       |
   46|       |        /// Helper methods
   47|       |        fn size(&self) -> N;
   48|       |        fn is_empty(&self) -> bool;
   49|       |        fn to_seq(&self) -> ArraySeqStPerS<T>;
   50|       |    }
   51|       |
   52|       |    impl<T: StT + Ord> BinaryHeapPQ<T> {
   53|       |        /// Helper functions for heap navigation
   54|       |        /// left child of node at index i
   55|  1.55k|        fn left_child(i: N) -> N { 2 * i + 1 }
   56|       |
   57|       |        /// right child of node at index i
   58|  1.55k|        fn right_child(i: N) -> N { 2 * i + 2 }
   59|       |
   60|       |        /// parent of node at index i
   61|    518|        fn parent(i: N) -> N { if i == 0 { 0 } else { (i - 1) / 2 } }
                                                         ^0
   62|       |
   63|       |        /// Check if heap property is satisfied
   64|     28|        fn is_heap(&self) -> bool {
   65|  1.12k|            for i in 0..self.elements.length() {
                                      ^28           ^28
   66|  1.12k|                let left = Self::left_child(i);
   67|  1.12k|                let right = Self::right_child(i);
   68|       |
   69|  1.12k|                if left < self.elements.length() {
   70|    555|                    if self.elements.nth(i) > self.elements.nth(left) {
   71|      0|                        return false;
   72|    555|                    }
   73|    569|                }
   74|       |
   75|  1.12k|                if right < self.elements.length() {
   76|    542|                    if self.elements.nth(i) > self.elements.nth(right) {
   77|      0|                        return false;
   78|    542|                    }
   79|    582|                }
   80|       |            }
   81|     28|            true
   82|     28|        }
   83|       |
   84|       |        /// Bubble up element at index i to maintain heap property
   85|    487|        fn bubble_up(&self, mut i: N) -> ArraySeqStPerS<T> {
   86|    487|            let mut result = self.elements.clone();
   87|       |
   88|    757|            while i > 0 {
   89|    518|                let parent_idx = Self::parent(i);
   90|    518|                let current = result.nth(i);
   91|    518|                let parent = result.nth(parent_idx);
   92|       |
   93|    518|                if current >= parent {
   94|    248|                    break;
   95|    270|                }
   96|       |
   97|       |                // Swap current with parent
   98|    270|                result = self.swap_elements(&result, i, parent_idx);
   99|    270|                i = parent_idx;
  100|       |            }
  101|       |
  102|    487|            result
  103|    487|        }
  104|       |
  105|       |        /// Bubble down element at index i to maintain heap property
  106|    231|        fn bubble_down(&self, mut i: N, heap: &ArraySeqStPerS<T>) -> ArraySeqStPerS<T> {
  107|    231|            let mut result = heap.clone();
  108|       |
  109|       |            loop {
  110|    433|                let left = Self::left_child(i);
  111|    433|                let right = Self::right_child(i);
  112|    433|                let mut smallest = i;
  113|       |
  114|       |                // Find smallest among current, left child, right child
  115|    433|                if left < result.length() && result.nth(left) < result.nth(smallest) {
                                                           ^256               ^256
  116|    189|                    smallest = left;
  117|    244|                }
  118|       |
  119|    433|                if right < result.length() && result.nth(right) < result.nth(smallest) {
                                                            ^177                ^177
  120|     68|                    smallest = right;
  121|    365|                }
  122|       |
  123|    433|                if smallest == i {
  124|    231|                    break; // Heap property satisfied
  125|    202|                }
  126|       |
  127|       |                // Swap current with smallest child
  128|    202|                result = self.swap_elements(&result, i, smallest);
  129|    202|                i = smallest;
  130|       |            }
  131|       |
  132|    231|            result
  133|    231|        }
  134|       |
  135|       |        /// Swap elements at indices i and j
  136|    472|        fn swap_elements(&self, seq: &ArraySeqStPerS<T>, i: N, j: N) -> ArraySeqStPerS<T> {
  137|    472|            let mut result = ArraySeqStPerS::empty();
  138|       |
  139|  11.8k|            for k in 0..seq.length() {
                                      ^472^472
  140|  11.8k|                let element = if k == i {
  141|    472|                    seq.nth(j).clone()
  142|  11.3k|                } else if k == j {
  143|    472|                    seq.nth(i).clone()
  144|       |                } else {
  145|  10.8k|                    seq.nth(k).clone()
  146|       |                };
  147|       |
  148|  11.8k|                let single_seq = ArraySeqStPerS::singleton(element);
  149|  11.8k|                result = ArraySeqStPerS::append(&result, &single_seq);
  150|       |            }
  151|       |
  152|    472|            result
  153|    472|        }
  154|       |
  155|       |        /// Build heap from arbitrary sequence (bottom-up heapify)
  156|      7|        fn heapify(&self, seq: &ArraySeqStPerS<T>) -> ArraySeqStPerS<T> {
  157|      7|            if seq.length() <= 1 {
  158|      0|                return seq.clone();
  159|      7|            }
  160|       |
  161|      7|            let mut result = seq.clone();
  162|       |
  163|       |            // Start from last non-leaf node and bubble down
  164|      7|            let last_non_leaf = if seq.length() >= 2 { (seq.length() - 2) / 2 } else { 0 };
                                                                                                     ^0
  165|       |
  166|     17|            for i in (0..=last_non_leaf).rev() {
                                    ^7                 ^7
  167|     17|                result = self.bubble_down(i, &result);
  168|     17|            }
  169|       |
  170|      7|            result
  171|      7|        }
  172|       |    }
  173|       |
  174|       |    impl<T: StT + Ord> BinaryHeapPQTrait<T> for BinaryHeapPQ<T> {
  175|       |        /// Claude Work: (1), Span: (1)
  176|    243|        fn empty() -> Self {
  177|    243|            BinaryHeapPQ {
  178|    243|                elements: ArraySeqStPerS::empty(),
  179|    243|            }
  180|    243|        }
  181|       |
  182|       |        /// Claude Work: (1), Span: (1)
  183|     96|        fn singleton(element: T) -> Self {
  184|     96|            BinaryHeapPQ {
  185|     96|                elements: ArraySeqStPerS::singleton(element),
  186|     96|            }
  187|     96|        }
  188|       |
  189|       |        /// Claude Work: (1), Span: (1)
  190|       |        /// Minimum is always at the root (index 0)
  191|     21|        fn find_min(&self) -> Option<&T> {
  192|     21|            if self.elements.length() == 0 {
  193|      2|                None
  194|       |            } else {
  195|     19|                Some(self.elements.nth(0))
  196|       |            }
  197|     21|        }
  198|       |
  199|       |        /// Claude Work: (log n), Span: (log n)
  200|       |        /// Add element at end and bubble up to maintain heap property
  201|    487|        fn insert(&self, element: T) -> Self {
  202|       |            // Add element at the end
  203|    487|            let single_seq = ArraySeqStPerS::singleton(element);
  204|    487|            let new_elements = ArraySeqStPerS::append(&self.elements, &single_seq);
  205|       |
  206|       |            // Bubble up from the last position
  207|    487|            let last_index = new_elements.length() - 1;
  208|    487|            let temp_pq = BinaryHeapPQ { elements: new_elements };
  209|    487|            let heapified = temp_pq.bubble_up(last_index);
  210|       |
  211|    487|            BinaryHeapPQ { elements: heapified }
  212|    487|        }
  213|       |
  214|       |        /// Claude Work: (log n), Span: (log n)
  215|       |        /// Replace root with last element and bubble down
  216|    404|        fn delete_min(&self) -> (Self, Option<T>) {
  217|    404|            if self.elements.length() == 0 {
  218|      1|                return (self.clone(), None);
  219|    403|            }
  220|       |
  221|    403|            if self.elements.length() == 1 {
  222|    189|                let min_element = self.elements.nth(0).clone();
  223|    189|                return (Self::empty(), Some(min_element));
  224|    214|            }
  225|       |
  226|    214|            let min_element = self.elements.nth(0).clone();
  227|    214|            let last_element = self.elements.nth(self.elements.length() - 1).clone();
  228|       |
  229|       |            // Create new sequence with last element at root and without the last element
  230|    214|            let mut new_elements = ArraySeqStPerS::singleton(last_element);
  231|  1.29k|            for i in 1..(self.elements.length() - 1) {
                                      ^214
  232|  1.29k|                let elem = self.elements.nth(i);
  233|  1.29k|                let single_seq = ArraySeqStPerS::singleton(elem.clone());
  234|  1.29k|                new_elements = ArraySeqStPerS::append(&new_elements, &single_seq);
  235|  1.29k|            }
  236|       |
  237|       |            // Bubble down from root
  238|    214|            let heapified = self.bubble_down(0, &new_elements);
  239|       |
  240|    214|            let new_pq = BinaryHeapPQ { elements: heapified };
  241|       |
  242|    214|            (new_pq, Some(min_element))
  243|    404|        }
  244|       |
  245|       |        /// Claude Work: (m + n), Span: (m + n)
  246|       |        /// Concatenate arrays and re-heapify
  247|      5|        fn meld(&self, other: &Self) -> Self {
  248|      5|            let merged = ArraySeqStPerS::append(&self.elements, &other.elements);
  249|      5|            let heapified = self.heapify(&merged);
  250|       |
  251|      5|            BinaryHeapPQ { elements: heapified }
  252|      5|        }
  253|       |
  254|       |        /// Claude Work: (n), Span: (n)
  255|       |        /// Build heap using bottom-up heapify (more efficient than repeated insertion)
  256|      2|        fn from_seq(seq: &ArraySeqStPerS<T>) -> Self {
  257|      2|            let heap = Self::empty();
  258|      2|            let heapified = heap.heapify(seq);
  259|       |
  260|      2|            BinaryHeapPQ { elements: heapified }
  261|      2|        }
  262|       |
  263|       |        /// Claude Work: (1), Span: (1)
  264|     19|        fn size(&self) -> N { self.elements.length() }
  265|       |
  266|       |        /// Claude Work: (1), Span: (1)
  267|    509|        fn is_empty(&self) -> bool { self.elements.length() == 0 }
  268|       |
  269|       |        /// Claude Work: (1), Span: (1)
  270|      1|        fn to_seq(&self) -> ArraySeqStPerS<T> { self.elements.clone() }
  271|       |    }
  272|       |
  273|       |    impl<T: StT + Ord> BinaryHeapPQ<T> {
  274|       |        /// Insert multiple elements from a sequence
  275|      1|        pub fn insert_all(&self, elements: &ArraySeqStPerS<T>) -> Self {
  276|      1|            let mut result = self.clone();
  277|      4|            for i in 0..elements.length() {
                                      ^1       ^1
  278|      4|                let element = elements.nth(i);
  279|      4|                result = result.insert(element.clone());
  280|      4|            }
  281|      1|            result
  282|      1|        }
  283|       |
  284|       |        /// Extract all elements in sorted order (heapsort)
  285|      3|        pub fn extract_all_sorted(&self) -> ArraySeqStPerS<T> {
  286|      3|            let mut result = ArraySeqStPerS::empty();
  287|      3|            let mut current_heap = self.clone();
  288|       |
  289|     21|            while !current_heap.is_empty() {
  290|     18|                let (new_heap, min_element) = current_heap.delete_min();
  291|     18|                if let Some(element) = min_element {
  292|     18|                    let single_seq = ArraySeqStPerS::singleton(element);
  293|     18|                    result = ArraySeqStPerS::append(&result, &single_seq);
  294|     18|                }
                              ^0
  295|     18|                current_heap = new_heap;
  296|       |            }
  297|       |
  298|      3|            result
  299|      3|        }
  300|       |
  301|       |        /// Check if the heap property is maintained (for testing)
  302|     28|        pub fn is_valid_heap(&self) -> bool { self.is_heap() }
  303|       |
  304|       |        /// Get the height of the heap (for testing)
  305|      3|        pub fn height(&self) -> N {
  306|      3|            if self.elements.length() == 0 {
  307|      1|                0
  308|       |            } else {
  309|      2|                ((self.elements.length() as f64).log2().floor() as N) + 1
  310|       |            }
  311|      3|        }
  312|       |
  313|       |        /// Get elements at a specific level (for testing)
  314|      2|        pub fn level_elements(&self, level: N) -> ArraySeqStPerS<T> {
  315|      2|            let mut result = ArraySeqStPerS::empty();
  316|      2|            let start_idx = (1 << level) - 1; // 2^level - 1
  317|      2|            let end_idx = ((1 << (level + 1)) - 1).min(self.elements.length()); // 2^(level+1) - 1
  318|       |
  319|      3|            for i in start_idx..end_idx {
                                   ^2         ^2
  320|      3|                if i < self.elements.length() {
  321|      3|                    let elem = self.elements.nth(i);
  322|      3|                    let single_seq = ArraySeqStPerS::singleton(elem.clone());
  323|      3|                    result = ArraySeqStPerS::append(&result, &single_seq);
  324|      3|                }
                              ^0
  325|       |            }
  326|       |
  327|      2|            result
  328|      2|        }
  329|       |    }
  330|       |
  331|       |    impl<T: StT + Ord> Default for BinaryHeapPQ<T> {
  332|      1|        fn default() -> Self { Self::empty() }
  333|       |    }
  334|       |
  335|       |    impl<T: StT + Ord> Display for BinaryHeapPQ<T> {
  336|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  337|      1|            write!(f, "BinaryHeapPQ[")?;
                                                    ^0
  338|      3|            for i in 0..self.elements.length() {
                                      ^1            ^1
  339|      3|                if i > 0 {
  340|      2|                    write!(f, ", ")?;
                                                 ^0
  341|      1|                }
  342|      3|                write!(f, "{}", self.elements.nth(i))?;
                                                                   ^0
  343|       |            }
  344|      1|            write!(f, "]")
  345|      1|        }
  346|       |    }
  347|       |
  348|       |    // Macro for creating binary heap priority queues
  349|       |    #[macro_export]
  350|       |    macro_rules! BinaryHeapPQLit {
  351|       |        () => {
  352|       |            $crate::Chap45::BinaryHeapPQ::BinaryHeapPQ::BinaryHeapPQ::empty()
  353|       |        };
  354|       |        ($($x:expr),* $(,)?) => {{
  355|       |            let mut pq = $crate::Chap45::BinaryHeapPQ::BinaryHeapPQ::BinaryHeapPQ::empty();
  356|       |            $(
  357|       |                pq = pq.insert($x);
  358|       |            )*
  359|       |            pq
  360|       |        }};
  361|       |    }
  362|       |
  363|       |    #[allow(dead_code)]
  364|      0|    fn _binary_heap_pq_lit_type_checks() {
  365|      0|        let _: BinaryHeapPQ<i32> = BinaryHeapPQLit![];
  366|      0|        let _: BinaryHeapPQ<i32> = BinaryHeapPQLit![1, 2, 3];
  367|      0|    }
  368|       |
  369|       |    /// Convenience functions for common operations
  370|       |    impl<T: StT + Ord> BinaryHeapPQ<T> {
  371|       |        /// Create priority queue from vector (for testing)
  372|      1|        pub fn from_vec(vec: Vec<T>) -> Self {
  373|      1|            let mut seq = ArraySeqStPerS::empty();
  374|      6|            for element in vec {
                              ^5
  375|      5|                let single_seq = ArraySeqStPerS::singleton(element);
  376|      5|                seq = ArraySeqStPerS::append(&seq, &single_seq);
  377|      5|            }
  378|      1|            Self::from_seq(&seq)
  379|      1|        }
  380|       |
  381|       |        /// Convert to vector (for testing)
  382|      1|        pub fn to_vec(&self) -> Vec<T> {
  383|      1|            let mut result = Vec::new();
  384|      3|            for i in 0..self.elements.length() {
                                      ^1            ^1
  385|      3|                result.push(self.elements.nth(i).clone());
  386|      3|            }
  387|      1|            result
  388|      1|        }
  389|       |
  390|       |        /// Get elements in sorted order as vector (for testing)
  391|      1|        pub fn to_sorted_vec(&self) -> Vec<T> {
  392|      1|            let sorted_seq = self.extract_all_sorted();
  393|      1|            let mut result = Vec::new();
  394|      5|            for i in 0..sorted_seq.length() {
                                      ^1         ^1
  395|      5|                result.push(sorted_seq.nth(i).clone());
  396|      5|            }
  397|      1|            result
  398|      1|        }
  399|       |    }
  400|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap45/Example45_2.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 45: Example 45.2 - Heapsort Algorithm Demonstrations
    3|       |
    4|       |pub mod Example45_2 {
    5|       |
    6|       |    use crate::Types::Types::*;
    7|       |    use crate::Chap45::HeapsortExample::HeapsortExample::*;
    8|       |
    9|       |    /// Trait for Example 45.2 operations
   10|       |    pub trait Example45_2Trait {
   11|       |        /// Example 45.2: Textbook heapsort demonstration
   12|       |        /// APAS: Work (n log n), Span (n log n)
   13|       |        fn example_45_2_textbook_example() -> HeapsortComparison<i32>;
   14|       |        
   15|       |        /// Example 45.2: Reverse-sorted input demonstration
   16|       |        /// APAS: Work (n log n), Span (n log n)
   17|       |        fn example_45_2_reverse_sorted() -> HeapsortComparison<i32>;
   18|       |        
   19|       |        /// Example 45.2: Already-sorted input demonstration
   20|       |        /// APAS: Work (n log n), Span (n log n)
   21|       |        fn example_45_2_already_sorted() -> HeapsortComparison<i32>;
   22|       |        
   23|       |        /// Example 45.2: Input with duplicates demonstration
   24|       |        /// APAS: Work (n log n), Span (n log n)
   25|       |        fn example_45_2_duplicates() -> HeapsortComparison<i32>;
   26|       |        
   27|       |        /// Example 45.2: Single element demonstration
   28|       |        /// APAS: Work (1), Span (1)
   29|       |        fn example_45_2_single_element() -> HeapsortComparison<i32>;
   30|       |        
   31|       |        /// Example 45.2: Empty input demonstration
   32|       |        /// APAS: Work (1), Span (1)
   33|       |        fn example_45_2_empty() -> HeapsortComparison<i32>;
   34|       |        
   35|       |        /// Example 45.2: Efficiency comparison demonstration
   36|       |        /// APAS: Work (n), Span (n) - dominated by worst implementation
   37|       |        fn example_45_2_efficiency_demonstration() -> Vec<(String, Vec<i32>)>;
   38|       |        
   39|       |        /// Run comprehensive demonstration of Example 45.2
   40|       |        /// APAS: Work (n), Span (n) - dominated by worst implementation
   41|       |        fn run_example_45_2() -> String;
   42|       |    }
   43|       |
   44|       |    /// Example 45.2: Textbook heapsort demonstration
   45|       |    /// Demonstrates heapsort on the standard textbook example dataset
   46|       |    /// APAS: Work (n log n), Span (n log n)
   47|      0|    pub fn example_45_2_textbook_example() -> HeapsortComparison<i32> {
   48|      0|        textbook_example()
   49|      0|    }
   50|       |
   51|       |    /// Example 45.2: Reverse-sorted input demonstration
   52|       |    /// Shows heapsort performance on worst-case input for some algorithms
   53|       |    /// APAS: Work (n log n), Span (n log n)
   54|      0|    pub fn example_45_2_reverse_sorted() -> HeapsortComparison<i32> {
   55|      0|        reverse_sorted_example()
   56|      0|    }
   57|       |
   58|       |    /// Example 45.2: Already-sorted input demonstration
   59|       |    /// Shows heapsort performance on best-case input for some algorithms
   60|       |    /// APAS: Work (n log n), Span (n log n)
   61|      0|    pub fn example_45_2_already_sorted() -> HeapsortComparison<i32> {
   62|      0|        already_sorted_example()
   63|      0|    }
   64|       |
   65|       |    /// Example 45.2: Input with duplicates demonstration
   66|       |    /// Shows heapsort performance on input with repeated elements
   67|       |    /// APAS: Work (n log n), Span (n log n)
   68|      0|    pub fn example_45_2_duplicates() -> HeapsortComparison<i32> {
   69|      0|        duplicates_example()
   70|      0|    }
   71|       |
   72|       |    /// Example 45.2: Single element demonstration
   73|       |    /// Shows heapsort performance on minimal input
   74|       |    /// APAS: Work (1), Span (1)
   75|      0|    pub fn example_45_2_single_element() -> HeapsortComparison<i32> {
   76|      0|        single_element_example()
   77|      0|    }
   78|       |
   79|       |    /// Example 45.2: Empty input demonstration
   80|       |    /// Shows heapsort performance on empty input
   81|       |    /// APAS: Work (1), Span (1)
   82|      0|    pub fn example_45_2_empty() -> HeapsortComparison<i32> {
   83|      0|        empty_example()
   84|      0|    }
   85|       |
   86|       |    /// Example 45.2: Efficiency comparison demonstration
   87|       |    /// Shows the efficiency differences between priority queue implementations
   88|       |    /// APAS: Work (n), Span (n) - dominated by worst implementation
   89|      0|    pub fn example_45_2_efficiency_demonstration() -> Vec<(String, Vec<i32>)> {
   90|      0|        efficiency_demonstration()
   91|      0|    }
   92|       |
   93|       |    /// Run comprehensive demonstration of Example 45.2
   94|       |    /// Shows all heapsort variants and their comparative performance
   95|       |    /// APAS: Work (n), Span (n) - dominated by worst implementation
   96|      0|    pub fn run_example_45_2() -> String {
   97|      0|        let mut output = String::new();
   98|       |        
   99|      0|        output.push_str("=== Example 45.2: Heapsort Algorithm Demonstrations ===\n\n");
  100|       |        
  101|       |        // Textbook Example
  102|      0|        output.push_str("PART 1: Textbook Example Dataset\n");
  103|      0|        let textbook = example_45_2_textbook_example();
  104|      0|        output.push_str(&format!("Input: {:?}\n", textbook.input));
  105|      0|        output.push_str(&format!("All results match: {}\n", textbook.all_results_match()));
  106|      0|        output.push_str(&format!("All results sorted: {}\n", textbook.all_results_sorted()));
  107|      0|        output.push_str(&format!("Binary heap result: {:?}\n\n", textbook.binary_heap_result));
  108|       |        
  109|       |        // Reverse-Sorted Example
  110|      0|        output.push_str("PART 2: Reverse-Sorted Input\n");
  111|      0|        let reverse = example_45_2_reverse_sorted();
  112|      0|        output.push_str(&format!("Input: {:?}\n", reverse.input));
  113|      0|        output.push_str(&format!("All results match: {}\n", reverse.all_results_match()));
  114|      0|        output.push_str(&format!("Binary heap result: {:?}\n\n", reverse.binary_heap_result));
  115|       |        
  116|       |        // Already-Sorted Example
  117|      0|        output.push_str("PART 3: Already-Sorted Input\n");
  118|      0|        let sorted = example_45_2_already_sorted();
  119|      0|        output.push_str(&format!("Input: {:?}\n", sorted.input));
  120|      0|        output.push_str(&format!("All results match: {}\n", sorted.all_results_match()));
  121|      0|        output.push_str(&format!("Binary heap result: {:?}\n\n", sorted.binary_heap_result));
  122|       |        
  123|       |        // Duplicates Example
  124|      0|        output.push_str("PART 4: Input with Duplicates\n");
  125|      0|        let duplicates = example_45_2_duplicates();
  126|      0|        output.push_str(&format!("Input: {:?}\n", duplicates.input));
  127|      0|        output.push_str(&format!("All results match: {}\n", duplicates.all_results_match()));
  128|      0|        output.push_str(&format!("Binary heap result: {:?}\n\n", duplicates.binary_heap_result));
  129|       |        
  130|       |        // Edge Cases
  131|      0|        output.push_str("PART 5: Edge Cases\n");
  132|      0|        let single = example_45_2_single_element();
  133|      0|        let empty = example_45_2_empty();
  134|      0|        output.push_str(&format!("Single element - All match: {}\n", single.all_results_match()));
  135|      0|        output.push_str(&format!("Empty input - All match: {}\n\n", empty.all_results_match()));
  136|       |        
  137|       |        // Efficiency Analysis
  138|      0|        output.push_str("PART 6: Efficiency Comparison\n");
  139|      0|        let efficiency = example_45_2_efficiency_demonstration();
  140|      0|        for (name, data) in efficiency {
  141|      0|            output.push_str(&format!("{}: {} elements\n", name, data.len()));
  142|      0|        }
  143|      0|        output.push_str("\n");
  144|       |        
  145|       |        // Complexity Analysis
  146|      0|        output.push_str("PART 7: Complexity Analysis\n");
  147|      0|        let complexity = complexity_analysis();
  148|      0|        for (impl_name, complexity_str, notes) in complexity {
  149|      0|            output.push_str(&format!("{}: {} - {}\n", impl_name, complexity_str, notes));
  150|      0|        }
  151|      0|        output.push_str("\n");
  152|       |        
  153|       |        // Correctness Verification
  154|      0|        output.push_str("PART 8: Correctness Verification\n");
  155|      0|        let all_correct = correctness_verification();
  156|      0|        output.push_str(&format!("All implementations correct: {}\n", all_correct));
  157|       |        
  158|      0|        output.push_str("\nSummary:\n");
  159|      0|        output.push_str("- Binary heap and leftist heap provide optimal (n log n) performance\n");
  160|      0|        output.push_str("- Balanced tree also achieves (n log n) with good constants\n");
  161|      0|        output.push_str("- Unsorted and sorted list implementations are (n) and impractical\n");
  162|      0|        output.push_str("- All implementations produce identical, correctly sorted results\n");
  163|      0|        output.push_str("- Heapsort is stable across different input patterns\n");
  164|       |        
  165|      0|        output
  166|      0|    }
  167|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap45/HeapsortExample.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 45: Heapsort Example - Algorithm 45.2 using all Priority Queue implementations
    3|       |
    4|       |pub mod HeapsortExample {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::*;
    8|       |    use crate::Chap45::BalancedTreePQ::BalancedTreePQ::*;
    9|       |    use crate::Chap45::BinaryHeapPQ::BinaryHeapPQ::*;
   10|       |    use crate::Chap45::LeftistHeapPQ::LeftistHeapPQ::*;
   11|       |    use crate::Chap45::SortedListPQ::SortedListPQ::*;
   12|       |    use crate::Chap45::UnsortedListPQ::UnsortedListPQ::*;
   13|       |    use crate::Types::Types::*;
   14|       |
   15|       |    // A dummy trait as a minimal type checking comment and space for algorithmic analysis.
   16|       |    pub trait HeapsortTrait {
   17|       |        /// Heapsort using UnsortedListPQ
   18|       |        /// Claude Work: (n), Span: (n) - inefficient due to O(n) deleteMin
   19|       |        fn heapsort_unsorted_list<T: StT + Ord>(sequence: &[T]) -> Vec<T>;
   20|       |
   21|       |        /// Heapsort using SortedListPQ  
   22|       |        /// Claude Work: (n), Span: (n) - inefficient due to O(n) insert
   23|       |        fn heapsort_sorted_list<T: StT + Ord>(sequence: &[T]) -> Vec<T>;
   24|       |
   25|       |        /// Heapsort using BalancedTreePQ
   26|       |        /// Claude Work: (n log n), Span: (n log n) - optimal complexity
   27|       |        fn heapsort_balanced_tree<T: StT + Ord>(sequence: &[T]) -> Vec<T>;
   28|       |
   29|       |        /// Heapsort using BinaryHeapPQ
   30|       |        /// Claude Work: (n log n), Span: (n log n) - optimal complexity
   31|       |        fn heapsort_binary_heap<T: StT + Ord>(sequence: &[T]) -> Vec<T>;
   32|       |
   33|       |        /// Heapsort using LeftistHeapPQ
   34|       |        /// Claude Work: (n log n), Span: (n log n) - optimal complexity
   35|       |        fn heapsort_leftist_heap<T: StT + Ord>(sequence: &[T]) -> Vec<T>;
   36|       |
   37|       |        /// Compare all heapsort implementations on the same input
   38|       |        /// Claude Work: (n), Span: (n) - dominated by worst implementation
   39|       |        fn compare_all_heapsorts<T: StT + Ord>(sequence: &[T]) -> HeapsortComparison<T>;
   40|       |    }
   41|       |
   42|       |    /// Heapsort using UnsortedListPQ
   43|       |    /// Claude Work: (n), Span: (n) - inefficient due to O(n) deleteMin
   44|     14|    pub fn heapsort_unsorted_list<T: StT + Ord>(sequence: &[T]) -> Vec<T> {
   45|     14|        let mut pq = UnsortedListPQ::empty();
   46|     99|        for element in sequence {
                          ^85
   47|     85|            pq = pq.insert(element.clone());
   48|     85|        }
   49|     14|        let mut result = Vec::new();
   50|     99|        while !pq.is_empty() {
   51|     85|            let (new_pq, min_element) = pq.delete_min();
   52|     85|            if let Some(element) = min_element {
   53|     85|                result.push(element);
   54|     85|            }
                          ^0
   55|     85|            pq = new_pq;
   56|       |        }
   57|     14|        result
   58|     14|    }
   59|       |
   60|       |    /// Heapsort using SortedListPQ  
   61|       |    /// Claude Work: (n), Span: (n) - inefficient due to O(n) insert
   62|     14|    pub fn heapsort_sorted_list<T: StT + Ord>(sequence: &[T]) -> Vec<T> {
   63|     14|        let mut pq = SortedListPQ::empty();
   64|     99|        for element in sequence {
                          ^85
   65|     85|            pq = pq.insert(element.clone());
   66|     85|        }
   67|     14|        let mut result = Vec::new();
   68|     99|        while !pq.is_empty() {
   69|     85|            let (new_pq, min_element) = pq.delete_min();
   70|     85|            if let Some(element) = min_element {
   71|     85|                result.push(element);
   72|     85|            }
                          ^0
   73|     85|            pq = new_pq;
   74|       |        }
   75|     14|        result
   76|     14|    }
   77|       |
   78|       |    /// Heapsort using BalancedTreePQ
   79|       |    /// Claude Work: (n log n), Span: (n log n) - optimal complexity
   80|     14|    pub fn heapsort_balanced_tree<T: StT + Ord>(sequence: &[T]) -> Vec<T> {
   81|     14|        let mut pq = BalancedTreePQ::empty();
   82|     99|        for element in sequence {
                          ^85
   83|     85|            pq = pq.insert(element.clone());
   84|     85|        }
   85|     14|        let mut result = Vec::new();
   86|     99|        while !pq.is_empty() {
   87|     85|            let (new_pq, min_element) = pq.delete_min();
   88|     85|            if let Some(element) = min_element {
   89|     85|                result.push(element);
   90|     85|            }
                          ^0
   91|     85|            pq = new_pq;
   92|       |        }
   93|     14|        result
   94|     14|    }
   95|       |
   96|       |    /// Heapsort using BinaryHeapPQ
   97|       |    /// Claude Work: (n log n), Span: (n log n) - optimal complexity
   98|     19|    pub fn heapsort_binary_heap<T: StT + Ord>(sequence: &[T]) -> Vec<T> {
   99|     19|        let mut pq = BinaryHeapPQ::empty();
  100|    123|        for element in sequence {
                          ^104
  101|    104|            pq = pq.insert(element.clone());
  102|    104|        }
  103|     19|        let mut result = Vec::new();
  104|    123|        while !pq.is_empty() {
  105|    104|            let (new_pq, min_element) = pq.delete_min();
  106|    104|            if let Some(element) = min_element {
  107|    104|                result.push(element);
  108|    104|            }
                          ^0
  109|    104|            pq = new_pq;
  110|       |        }
  111|     19|        result
  112|     19|    }
  113|       |
  114|       |    /// Heapsort using LeftistHeapPQ
  115|       |    /// Claude Work: (n log n), Span: (n log n) - optimal complexity with superior meld
  116|     14|    pub fn heapsort_leftist_heap<T: StT + Ord>(sequence: &[T]) -> Vec<T> {
  117|     14|        let mut pq = LeftistHeapPQ::empty();
  118|     99|        for element in sequence {
                          ^85
  119|     85|            pq = pq.insert(element.clone());
  120|     85|        }
  121|     14|        let mut result = Vec::new();
  122|     99|        while !pq.is_empty() {
  123|     85|            let (new_pq, min_element) = pq.delete_min();
  124|     85|            if let Some(element) = min_element {
  125|     85|                result.push(element);
  126|     85|            }
                          ^0
  127|     85|            pq = new_pq;
  128|       |        }
  129|     14|        result
  130|     14|    }
  131|       |
  132|       |    /// Demonstrate all heapsort variants on the same input
  133|     13|    pub fn compare_all_heapsorts<T: StT + Ord>(sequence: &[T]) -> HeapsortComparison<T> {
  134|     13|        HeapsortComparison {
  135|     13|            input: sequence.to_vec(),
  136|     13|            unsorted_list_result: heapsort_unsorted_list(sequence),
  137|     13|            sorted_list_result: heapsort_sorted_list(sequence),
  138|     13|            balanced_tree_result: heapsort_balanced_tree(sequence),
  139|     13|            binary_heap_result: heapsort_binary_heap(sequence),
  140|     13|            leftist_heap_result: heapsort_leftist_heap(sequence),
  141|     13|        }
  142|     13|    }
  143|       |
  144|       |    /// Results of comparing all heapsort implementations
  145|       |    #[derive(Debug, Clone, PartialEq)]
  146|       |    pub struct HeapsortComparison<T: StT + Ord> {
  147|       |        pub input: Vec<T>,
  148|       |        pub unsorted_list_result: Vec<T>,
  149|       |        pub sorted_list_result: Vec<T>,
  150|       |        pub balanced_tree_result: Vec<T>,
  151|       |        pub binary_heap_result: Vec<T>,
  152|       |        pub leftist_heap_result: Vec<T>,
  153|       |    }
  154|       |
  155|       |    impl<T: StT + Ord> HeapsortComparison<T> {
  156|       |        /// Verify that all implementations produce the same sorted result
  157|     13|        pub fn all_results_match(&self) -> bool {
  158|     13|            let expected = &self.binary_heap_result; // Use binary heap as reference
  159|     13|            self.unsorted_list_result == *expected
  160|     13|                && self.sorted_list_result == *expected
  161|     13|                && self.balanced_tree_result == *expected
  162|     13|                && self.leftist_heap_result == *expected
  163|     13|        }
  164|       |
  165|       |        /// Check if all results are properly sorted
  166|     13|        pub fn all_results_sorted(&self) -> bool {
  167|    340|            fn is_sorted<T: Ord>(vec: &[T]) -> bool { vec.windows(2).all(|w| w[0] <= w[1]) }
                          ^65                                       ^65            ^65                   ^65
  168|       |
  169|     13|            is_sorted(&self.unsorted_list_result)
  170|     13|                && is_sorted(&self.sorted_list_result)
  171|     13|                && is_sorted(&self.balanced_tree_result)
  172|     13|                && is_sorted(&self.binary_heap_result)
  173|     13|                && is_sorted(&self.leftist_heap_result)
  174|     13|        }
  175|       |    }
  176|       |
  177|       |    // A dummy trait as a minimal type checking comment and space for algorithmic analysis.
  178|       |    pub trait HeapsortExamplesTrait {
  179|       |        /// Example from textbook - demonstrate heapsort on a small dataset
  180|       |        fn textbook_example() -> HeapsortComparison<i32>;
  181|       |        /// Demonstrate heapsort on reverse-sorted input (worst case for some algorithms)
  182|       |        fn reverse_sorted_example() -> HeapsortComparison<i32>;
  183|       |        /// Demonstrate heapsort on already-sorted input
  184|       |        fn already_sorted_example() -> HeapsortComparison<i32>;
  185|       |        /// Demonstrate heapsort on input with duplicates
  186|       |        fn duplicates_example() -> HeapsortComparison<i32>;
  187|       |        /// Demonstrate heapsort on single element
  188|       |        fn single_element_example() -> HeapsortComparison<i32>;
  189|       |        /// Demonstrate heapsort on empty input
  190|       |        fn empty_example() -> HeapsortComparison<i32>;
  191|       |        /// Generate large example for performance testing
  192|       |        fn large_example(size: usize) -> Vec<i32>;
  193|       |        /// Demonstrate the efficiency difference between implementations
  194|       |        fn efficiency_demonstration() -> Vec<(String, Vec<i32>)>;
  195|       |    }
  196|       |
  197|       |    /// Example from textbook - demonstrate heapsort on a small dataset
  198|      2|    pub fn textbook_example() -> HeapsortComparison<i32> {
  199|      2|        let input = vec![64, 34, 25, 12, 22, 11, 90];
  200|      2|        compare_all_heapsorts(&input)
  201|      2|    }
  202|       |
  203|       |    /// Demonstrate heapsort on reverse-sorted input (worst case for some algorithms)
  204|      2|    pub fn reverse_sorted_example() -> HeapsortComparison<i32> {
  205|      2|        let input = vec![10, 9, 8, 7, 6, 5, 4, 3, 2, 1];
  206|      2|        compare_all_heapsorts(&input)
  207|      2|    }
  208|       |
  209|       |    /// Demonstrate heapsort on already-sorted input
  210|      2|    pub fn already_sorted_example() -> HeapsortComparison<i32> {
  211|      2|        let input = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  212|      2|        compare_all_heapsorts(&input)
  213|      2|    }
  214|       |
  215|       |    /// Demonstrate heapsort on input with duplicates
  216|      2|    pub fn duplicates_example() -> HeapsortComparison<i32> {
  217|      2|        let input = vec![5, 2, 8, 2, 9, 1, 5, 5];
  218|      2|        compare_all_heapsorts(&input)
  219|      2|    }
  220|       |
  221|       |    /// Demonstrate heapsort on single element
  222|      2|    pub fn single_element_example() -> HeapsortComparison<i32> {
  223|      2|        let input = vec![42];
  224|      2|        compare_all_heapsorts(&input)
  225|      2|    }
  226|       |
  227|       |    /// Demonstrate heapsort on empty input
  228|      2|    pub fn empty_example() -> HeapsortComparison<i32> {
  229|      2|        let input = vec![];
  230|      2|        compare_all_heapsorts(&input)
  231|      2|    }
  232|       |
  233|       |    /// Generate a large random-like sequence for performance testing
  234|      4|    pub fn large_example(size: usize) -> Vec<i32> {
  235|       |        // Generate pseudo-random sequence for testing
  236|      4|        let mut result = Vec::with_capacity(size);
  237|      4|        let mut x: i64 = 1;
  238|    230|        for _ in 0..size {
                                  ^4
  239|    230|            x = (x * 1103515245 + 12345) % (1i64 << 31); // Linear congruential generator
  240|    230|            result.push((x % 1000) as i32);
  241|    230|        }
  242|      4|        result
  243|      4|    }
  244|       |
  245|       |    /// Demonstrate the efficiency difference between implementations
  246|      1|    pub fn efficiency_demonstration() -> Vec<(String, Vec<i32>)> {
  247|      1|        let inputs = vec![
  248|      1|            ("Small (7 elements)".to_string(), vec![64, 34, 25, 12, 22, 11, 90]),
  249|      1|            ("Medium (20 elements)".to_string(), large_example(20)),
  250|      1|            ("Large (100 elements)".to_string(), large_example(100)),
  251|       |        ];
  252|       |
  253|      1|        inputs
  254|      1|    }
  255|       |
  256|       |    // A dummy trait as a minimal type checking comment and space for algorithmic analysis.
  257|       |    pub trait HeapsortAnalysisTrait {
  258|       |        /// Analyze the theoretical complexity of each heapsort variant
  259|       |        fn complexity_analysis() -> Vec<(String, String, String)>;
  260|       |        /// Verify that all heapsort implementations produce correct results
  261|       |        fn correctness_verification() -> bool;
  262|       |    }
  263|       |
  264|       |    /// Analyze the theoretical complexity of each heapsort variant
  265|      1|    pub fn complexity_analysis() -> Vec<(String, String, String)> {
  266|      1|        vec![
  267|      1|            (
  268|      1|                "UnsortedListPQ".to_string(),
  269|      1|                "(n)".to_string(),
  270|      1|                "O(n) deleteMin dominates".to_string(),
  271|      1|            ),
  272|      1|            (
  273|      1|                "SortedListPQ".to_string(),
  274|      1|                "(n)".to_string(),
  275|      1|                "O(n) insert dominates".to_string(),
  276|      1|            ),
  277|      1|            (
  278|      1|                "BalancedTreePQ".to_string(),
  279|      1|                "(n log n)".to_string(),
  280|      1|                "O(log n) insert and deleteMin".to_string(),
  281|      1|            ),
  282|      1|            (
  283|      1|                "BinaryHeapPQ".to_string(),
  284|      1|                "(n log n)".to_string(),
  285|      1|                "O(log n) insert and deleteMin".to_string(),
  286|      1|            ),
  287|      1|            (
  288|      1|                "LeftistHeapPQ".to_string(),
  289|      1|                "(n log n)".to_string(),
  290|      1|                "O(log n) insert and deleteMin + superior meld".to_string(),
  291|      1|            ),
  292|       |        ]
  293|      1|    }
  294|       |
  295|       |    /// Verify that all heapsort implementations produce correct results
  296|      1|    pub fn correctness_verification() -> bool {
  297|      1|        let test_cases = vec![
  298|      1|            textbook_example(),
  299|      1|            reverse_sorted_example(),
  300|      1|            already_sorted_example(),
  301|      1|            duplicates_example(),
  302|      1|            single_element_example(),
  303|      1|            empty_example(),
  304|       |        ];
  305|       |
  306|      1|        test_cases
  307|      1|            .iter()
  308|      6|            .all(|comparison| comparison.all_results_match() && comparison.all_results_sorted())
                           ^1
  309|      1|    }
  310|       |
  311|       |    // A dummy trait as a minimal type checking comment and space for algorithmic analysis.
  312|       |    pub trait SequenceUtilsTrait {
  313|       |        /// Convert Vec to ArraySeqStPerS for use with APAS sequence types
  314|       |        fn vec_to_array_seq<T: StT>(vec: &[T]) -> ArraySeqStPerS<T>;
  315|       |        /// Convert Vec to AVLTreeSeqStPerS for use with balanced tree operations
  316|       |        fn vec_to_avl_seq<T: StT>(vec: &[T]) -> AVLTreeSeqStPerS<T>;
  317|       |        /// Check if a sequence is sorted
  318|       |        fn is_sorted<T: Ord>(vec: &[T]) -> bool;
  319|       |        /// Generate test sequences of various patterns
  320|       |        fn generate_test_sequences(size: usize) -> Vec<(String, Vec<i32>)>;
  321|       |    }
  322|       |
  323|       |    /// Convert Vec to ArraySeqStPerS for use with APAS sequence types
  324|      1|    pub fn vec_to_array_seq<T: StT>(vec: &[T]) -> ArraySeqStPerS<T> {
  325|      1|        let mut result = ArraySeqStPerS::empty();
  326|      4|        for element in vec {
                          ^3
  327|      3|            let single_seq = ArraySeqStPerS::singleton(element.clone());
  328|      3|            result = ArraySeqStPerS::append(&result, &single_seq);
  329|      3|        }
  330|      1|        result
  331|      1|    }
  332|       |
  333|       |    /// Convert Vec to AVLTreeSeqStPerS for use with balanced tree operations
  334|      1|    pub fn vec_to_avl_seq<T: StT>(vec: &[T]) -> AVLTreeSeqStPerS<T> { AVLTreeSeqStPerS::from_vec(vec.to_vec()) }
  335|       |
  336|       |    /// Check if a sequence is sorted
  337|      9|    pub fn is_sorted<T: Ord>(vec: &[T]) -> bool { vec.windows(2).all(|w| w[0] <= w[1]) }
                  ^5                                            ^5             ^5                    ^5
  338|       |
  339|       |    /// Generate test sequences of various patterns
  340|      1|    pub fn generate_test_sequences(size: usize) -> Vec<(String, Vec<i32>)> {
  341|      1|        vec![
  342|      1|            ("Random".to_string(), large_example(size)),
  343|      1|            ("Sorted".to_string(), (1..=size as i32).collect()),
  344|      1|            ("Reverse".to_string(), (1..=size as i32).rev().collect()),
  345|      1|            ("AllSame".to_string(), vec![42; size]),
  346|      1|            ("AlmostSorted".to_string(), {
  347|      1|                let mut seq: Vec<i32> = (1..=size as i32).collect();
  348|      1|                if size > 2 {
  349|      1|                    seq.swap(0, size - 1); // Swap first and last
  350|      1|                }
                              ^0
  351|      1|                seq
  352|       |            }),
  353|       |        ]
  354|      1|    }
  355|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap45/LeftistHeapPQ.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 45: Priority Queue implementation using Leftist Heap (Data Structure 45.3)
    3|       |
    4|       |pub mod LeftistHeapPQ {
    5|       |
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |
    8|       |    use crate::Types::Types::*;
    9|       |
   10|       |    #[derive(PartialEq, Clone, Debug)]
   11|       |    pub enum LeftistHeapNode<T: StT + Ord> {
   12|       |        Leaf,
   13|       |        Node {
   14|       |            key: T,
   15|       |            left: Box<LeftistHeapNode<T>>,
   16|       |            right: Box<LeftistHeapNode<T>>,
   17|       |            rank: N, // Distance to nearest leaf (for leftist property)
   18|       |        },
   19|       |    }
   20|       |
   21|       |    /// Priority Queue implemented using Leftist Heap
   22|       |    /// Data Type 45.1: Meldable Priority Queue with efficient O(log n) meld
   23|       |    #[derive(PartialEq, Clone, Debug)]
   24|       |    pub struct LeftistHeapPQ<T: StT + Ord> {
   25|       |        root: LeftistHeapNode<T>,
   26|       |    }
   27|       |
   28|       |    /// Trait defining the Meldable Priority Queue ADT operations (Data Type 45.1)
   29|       |    pub trait LeftistHeapPQTrait<T: StT + Ord> {
   30|       |        /// claude-4-sonet: Work (1), Span (1)
   31|       |        fn empty() -> Self;
   32|       |
   33|       |        /// claude-4-sonet: Work (1), Span (1)
   34|       |        fn singleton(element: T) -> Self;
   35|       |
   36|       |        /// claude-4-sonet: Work (1), Span (1)
   37|       |        /// Returns the minimum element (root of heap), or None if empty
   38|       |        fn find_min(&self) -> Option<&T>;
   39|       |
   40|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   41|       |        /// Inserts element by creating singleton and melding
   42|       |        fn insert(&self, element: T) -> Self;
   43|       |
   44|       |        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)
   45|       |        /// Removes root and melds left and right subtrees
   46|       |        fn delete_min(&self) -> (Self, Option<T>)
   47|       |        where
   48|       |            Self: Sized;
   49|       |
   50|       |        /// Claude Work: (log m + log n), Span: (log m + log n)
   51|       |        /// KEY ADVANTAGE: Efficient meld following right spines
   52|       |        fn meld(&self, other: &Self) -> Self;
   53|       |
   54|       |        /// Claude Work: (n), Span: (n)
   55|       |        /// Creates heap from sequence using reduce with meld
   56|       |
   57|       |        fn from_seq(seq: &[T]) -> Self;
   58|       |
   59|       |        /// Helper methods
   60|       |        fn size(&self) -> N;
   61|       |        fn is_empty(&self) -> bool;
   62|       |    }
   63|       |
   64|       |    impl<T: StT + Ord> LeftistHeapNode<T> {
   65|       |        /// Get the rank (distance to nearest leaf) of a node
   66|  4.42k|        fn rank(&self) -> N {
   67|  4.42k|            match self {
   68|  1.63k|                | LeftistHeapNode::Leaf => 0,
   69|  2.79k|                | LeftistHeapNode::Node { rank, .. } => *rank,
   70|       |            }
   71|  4.42k|        }
   72|       |
   73|       |        /// Create a new node with correct rank and leftist property
   74|    724|        fn make_node(key: T, left: LeftistHeapNode<T>, right: LeftistHeapNode<T>) -> Self {
   75|    724|            let left_rank = left.rank();
   76|    724|            let right_rank = right.rank();
   77|       |
   78|       |            // Ensure leftist property: left subtree has >= rank than right subtree
   79|    724|            let (final_left, final_right) = if left_rank >= right_rank {
   80|    569|                (left, right)
   81|       |            } else {
   82|    155|                (right, left)
   83|       |            };
   84|       |
   85|    724|            let node_rank = final_right.rank() + 1;
   86|       |
   87|    724|            LeftistHeapNode::Node {
   88|    724|                key,
   89|    724|                left: Box::new(final_left),
   90|    724|                right: Box::new(final_right),
   91|    724|                rank: node_rank,
   92|    724|            }
   93|    724|        }
   94|       |
   95|       |        /// Core meld operation - follows right spines (Data Structure 45.3 algorithm)
   96|       |        /// This is the key innovation that makes meld O(log n)!
   97|  1.15k|        fn meld_nodes(a: LeftistHeapNode<T>, b: LeftistHeapNode<T>) -> LeftistHeapNode<T> {
   98|  1.15k|            match (a, b) {
   99|    264|                | (LeftistHeapNode::Leaf, other) => other,
  100|    162|                | (other, LeftistHeapNode::Leaf) => other,
  101|       |                | (
  102|       |                    LeftistHeapNode::Node {
  103|    724|                        key: ka,
  104|    724|                        left: la,
  105|    724|                        right: ra,
  106|       |                        ..
  107|       |                    },
  108|       |                    LeftistHeapNode::Node {
  109|    724|                        key: kb,
  110|    724|                        left: lb,
  111|    724|                        right: rb,
  112|       |                        ..
  113|       |                    },
  114|       |                ) => {
  115|    724|                    if ka <= kb {
  116|       |                        // ka is smaller, so it becomes the root
  117|       |                        // Meld ra (right subtree of a) with entire b
  118|    554|                        let melded_right = Self::meld_nodes(
  119|    554|                            *ra,
  120|    554|                            LeftistHeapNode::Node {
  121|    554|                                key: kb,
  122|    554|                                left: lb,
  123|    554|                                right: rb,
  124|    554|                                rank: 0, // rank will be recalculated
  125|    554|                            },
  126|       |                        );
  127|    554|                        Self::make_node(ka, *la, melded_right)
  128|       |                    } else {
  129|       |                        // kb is smaller, so it becomes the root
  130|       |                        // Meld entire a with rb (right subtree of b)
  131|    170|                        let melded_right = Self::meld_nodes(
  132|    170|                            LeftistHeapNode::Node {
  133|    170|                                key: ka,
  134|    170|                                left: la,
  135|    170|                                right: ra,
  136|    170|                                rank: 0, // rank will be recalculated
  137|    170|                            },
  138|    170|                            *rb,
  139|       |                        );
  140|    170|                        Self::make_node(kb, *lb, melded_right)
  141|       |                    }
  142|       |                }
  143|       |            }
  144|  1.15k|        }
  145|       |
  146|       |        /// Count total number of nodes in the heap
  147|    359|        fn size(&self) -> N {
  148|    359|            match self {
  149|    190|                | LeftistHeapNode::Leaf => 0,
  150|    169|                | LeftistHeapNode::Node { left, right, .. } => 1 + left.size() + right.size(),
  151|       |            }
  152|    359|        }
  153|       |
  154|       |        /// Get height of the heap
  155|     14|        fn height(&self) -> N {
  156|     14|            match self {
  157|      9|                | LeftistHeapNode::Leaf => 0,
  158|      5|                | LeftistHeapNode::Node { left, right, .. } => 1 + left.height().max(right.height()),
  159|       |            }
  160|     14|        }
  161|       |
  162|       |        /// Check if leftist property is maintained
  163|  2.27k|        fn is_leftist(&self) -> bool {
  164|  2.27k|            match self {
  165|  1.15k|                | LeftistHeapNode::Leaf => true,
  166|  1.12k|                | LeftistHeapNode::Node { left, right, .. } => {
  167|  1.12k|                    left.rank() >= right.rank() && left.is_leftist() && right.is_leftist()
  168|       |                }
  169|       |            }
  170|  2.27k|        }
  171|       |
  172|       |        /// Check if heap property is maintained
  173|  2.27k|        fn is_heap(&self) -> bool {
  174|  2.27k|            match self {
  175|  1.15k|                | LeftistHeapNode::Leaf => true,
  176|  1.12k|                | LeftistHeapNode::Node { key, left, right, .. } => {
  177|  1.12k|                    let left_ok = match left.as_ref() {
  178|    714|                        | LeftistHeapNode::Leaf => true,
  179|    411|                        | LeftistHeapNode::Node { key: left_key, .. } => key <= left_key,
  180|       |                    };
  181|  1.12k|                    let right_ok = match right.as_ref() {
  182|    437|                        | LeftistHeapNode::Leaf => true,
  183|    688|                        | LeftistHeapNode::Node { key: right_key, .. } => key <= right_key,
  184|       |                    };
  185|  1.12k|                    left_ok && right_ok && left.is_heap() && right.is_heap()
  186|       |                }
  187|       |            }
  188|  2.27k|        }
  189|       |
  190|       |        /// Convert to vector for testing (in-order traversal)
  191|     22|        fn to_vec(&self) -> Vec<T> {
  192|     22|            match self {
  193|     12|                | LeftistHeapNode::Leaf => Vec::new(),
  194|     10|                | LeftistHeapNode::Node { key, left, right, .. } => {
  195|     10|                    let mut result = left.to_vec();
  196|     10|                    result.push(key.clone());
  197|     10|                    result.extend(right.to_vec());
  198|     10|                    result
  199|       |                }
  200|       |            }
  201|     22|        }
  202|       |    }
  203|       |
  204|       |    impl<T: StT + Ord> LeftistHeapPQTrait<T> for LeftistHeapPQ<T> {
  205|       |        /// Claude Work: (1), Span: (1)
  206|     48|        fn empty() -> Self {
  207|     48|            LeftistHeapPQ {
  208|     48|                root: LeftistHeapNode::Leaf,
  209|     48|            }
  210|     48|        }
  211|       |
  212|       |        /// Claude Work: (1), Span: (1)
  213|    313|        fn singleton(element: T) -> Self {
  214|    313|            LeftistHeapPQ {
  215|    313|                root: LeftistHeapNode::Node {
  216|    313|                    key: element,
  217|    313|                    left: Box::new(LeftistHeapNode::Leaf),
  218|    313|                    right: Box::new(LeftistHeapNode::Leaf),
  219|    313|                    rank: 1,
  220|    313|                },
  221|    313|            }
  222|    313|        }
  223|       |
  224|       |        /// Claude Work: (1), Span: (1)
  225|       |        /// Minimum is always at the root
  226|     22|        fn find_min(&self) -> Option<&T> {
  227|     22|            match &self.root {
  228|      2|                | LeftistHeapNode::Leaf => None,
  229|     20|                | LeftistHeapNode::Node { key, .. } => Some(key),
  230|       |            }
  231|     22|        }
  232|       |
  233|       |        /// Claude Work: (log n), Span: (log n)
  234|       |        /// Create singleton and meld with existing heap
  235|    284|        fn insert(&self, element: T) -> Self {
  236|    284|            let singleton = Self::singleton(element);
  237|    284|            self.meld(&singleton)
  238|    284|        }
  239|       |
  240|       |        /// Claude Work: (log n), Span: (log n)
  241|       |        /// Remove root and meld left and right subtrees
  242|    115|        fn delete_min(&self) -> (Self, Option<T>) {
  243|    115|            match &self.root {
  244|      1|                | LeftistHeapNode::Leaf => (self.clone(), None),
  245|    114|                | LeftistHeapNode::Node { key, left, right, .. } => {
  246|    114|                    let min_element = key.clone();
  247|    114|                    let melded_root = LeftistHeapNode::meld_nodes(left.as_ref().clone(), right.as_ref().clone());
  248|    114|                    let new_heap = LeftistHeapPQ { root: melded_root };
  249|    114|                    (new_heap, Some(min_element))
  250|       |                }
  251|       |            }
  252|    115|        }
  253|       |
  254|       |        /// Claude Work: (log m + log n), Span: (log m + log n)
  255|       |        ///  THE STAR OPERATION: Efficient meld following right spines!
  256|       |        /// This is what makes leftist heaps superior for applications requiring frequent melding
  257|    312|        fn meld(&self, other: &Self) -> Self {
  258|    312|            LeftistHeapPQ {
  259|    312|                root: LeftistHeapNode::meld_nodes(self.root.clone(), other.root.clone()),
  260|    312|            }
  261|    312|        }
  262|       |
  263|       |        /// Claude Work: (n), Span: (n)
  264|       |        /// Build heap using parallel reduce with meld operations
  265|      3|        fn from_seq(seq: &[T]) -> Self {
  266|      3|            if seq.is_empty() {
  267|      0|                return Self::empty();
  268|      3|            }
  269|       |
  270|       |            // Create singletons for each element
  271|     16|            let mut heaps: Vec<Self> = seq.iter().map(|x| Self::singleton(x.clone())).collect();
                              ^3         ^3          ^3  ^3     ^3                                  ^3
  272|       |
  273|       |            // Reduce using meld operations (can be done in parallel)
  274|     12|            while heaps.len() > 1 {
  275|      9|                let mut next_level = Vec::new();
  276|       |
  277|       |                // Pair up heaps and meld them
  278|     18|                for chunk in heaps.chunks(2) {
                                           ^9    ^9
  279|     18|                    if chunk.len() == 2 {
  280|     13|                        next_level.push(chunk[0].meld(&chunk[1]));
  281|     13|                    } else {
  282|      5|                        next_level.push(chunk[0].clone());
  283|      5|                    }
  284|       |                }
  285|       |
  286|      9|                heaps = next_level;
  287|       |            }
  288|       |
  289|      3|            heaps.into_iter().next().unwrap_or_else(Self::empty)
  290|      3|        }
  291|       |
  292|       |        /// Claude Work: (n), Span: (n)
  293|     21|        fn size(&self) -> N { self.root.size() }
  294|       |
  295|       |        /// Claude Work: (1), Span: (1)
  296|    123|        fn is_empty(&self) -> bool { matches!(self.root, LeftistHeapNode::Leaf) }
                                                   ^101
  297|       |    }
  298|       |
  299|       |    impl<T: StT + Ord> LeftistHeapPQ<T> {
  300|       |        /// Extract all elements in sorted order
  301|      2|        pub fn extract_all_sorted(&self) -> Vec<T> {
  302|      2|            let mut result = Vec::new();
  303|      2|            let mut current_heap = self.clone();
  304|       |
  305|     12|            while !current_heap.is_empty() {
  306|     10|                let (new_heap, min_element) = current_heap.delete_min();
  307|     10|                if let Some(element) = min_element {
  308|     10|                    result.push(element);
  309|     10|                }
                              ^0
  310|     10|                current_heap = new_heap;
  311|       |            }
  312|       |
  313|      2|            result
  314|      2|        }
  315|       |
  316|       |        /// Get the height of the heap (for analysis)
  317|      4|        pub fn height(&self) -> N { self.root.height() }
  318|       |
  319|       |        /// Get the rank of the root (for analysis)
  320|      2|        pub fn root_rank(&self) -> N { self.root.rank() }
  321|       |
  322|       |        /// Check if leftist property is maintained (for testing)
  323|     27|        pub fn is_valid_leftist_heap(&self) -> bool { self.root.is_leftist() && self.root.is_heap() }
  324|       |
  325|       |        /// Create priority queue from vector (for testing)
  326|      1|        pub fn from_vec(vec: Vec<T>) -> Self { Self::from_seq(&vec) }
  327|       |
  328|       |        /// Convert to vector (for testing)
  329|      2|        pub fn to_vec(&self) -> Vec<T> { self.root.to_vec() }
  330|       |
  331|       |        /// Get elements in sorted order as vector (for testing)
  332|      1|        pub fn to_sorted_vec(&self) -> Vec<T> { self.extract_all_sorted() }
  333|       |
  334|       |        /// Advanced meld operations for specific use cases
  335|      2|        pub fn meld_multiple(heaps: &[Self]) -> Self {
  336|      2|            if heaps.is_empty() {
  337|      1|                return Self::empty();
  338|      1|            }
  339|       |
  340|      1|            let mut result = heaps[0].clone();
  341|      2|            for heap in &heaps[1..] {
                                       ^1
  342|      2|                result = result.meld(heap);
  343|      2|            }
  344|      1|            result
  345|      2|        }
  346|       |
  347|       |        /// Split heap at a given value (returns (less_than, equal_or_greater))
  348|      1|        pub fn split(&self, value: &T) -> (Self, Self) {
  349|      1|            let mut less_than = Self::empty();
  350|      1|            let mut equal_or_greater = Self::empty();
  351|       |
  352|      1|            let all_elements = self.to_vec();
  353|      8|            for element in all_elements {
                              ^7
  354|      7|                if element < *value {
  355|      3|                    less_than = less_than.insert(element);
  356|      4|                } else {
  357|      4|                    equal_or_greater = equal_or_greater.insert(element);
  358|      4|                }
  359|       |            }
  360|       |
  361|      1|            (less_than, equal_or_greater)
  362|      1|        }
  363|       |    }
  364|       |
  365|       |    impl<T: StT + Ord> Default for LeftistHeapPQ<T> {
  366|      1|        fn default() -> Self { Self::empty() }
  367|       |    }
  368|       |
  369|       |    impl<T: StT + Ord> Display for LeftistHeapPQ<T> {
  370|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  371|      7|            fn format_node<T: StT + Ord>(node: &LeftistHeapNode<T>, f: &mut Formatter<'_>, depth: usize) -> Result {
  372|      7|                match node {
  373|      4|                    | LeftistHeapNode::Leaf => Ok(()),
  374|      3|                    | LeftistHeapNode::Node { key, left, right, rank } => {
  375|      3|                        let indent = "  ".repeat(depth);
  376|      3|                        writeln!(f, "{}{}(rank:{})", indent, key, rank)?;
                                                                                     ^0
  377|      3|                        format_node(left, f, depth + 1)?;
                                                                     ^0
  378|      3|                        format_node(right, f, depth + 1)?;
                                                                      ^0
  379|      3|                        Ok(())
  380|       |                    }
  381|       |                }
  382|      7|            }
  383|       |
  384|      1|            writeln!(f, "LeftistHeapPQ:")?;
                                                       ^0
  385|      1|            format_node(&self.root, f, 0)
  386|      1|        }
  387|       |    }
  388|       |
  389|       |    // Macro for creating leftist heap priority queues
  390|       |    #[macro_export]
  391|       |    macro_rules! LeftistHeapPQLit {
  392|       |        () => {
  393|       |            $crate::Chap45::LeftistHeapPQ::LeftistHeapPQ::LeftistHeapPQ::empty()
  394|       |        };
  395|       |        ($($x:expr),* $(,)?) => {{
  396|       |            let elements = vec![$($x),*];
  397|       |            $crate::Chap45::LeftistHeapPQ::LeftistHeapPQ::LeftistHeapPQ::from_seq(&elements)
  398|       |        }};
  399|       |    }
  400|       |
  401|       |    #[allow(dead_code)]
  402|      0|    fn _leftist_heap_pq_lit_type_checks() {
  403|      0|        let _: LeftistHeapPQ<i32> = LeftistHeapPQLit![];
  404|      0|        let _: LeftistHeapPQ<i32> = LeftistHeapPQLit![1, 2, 3];
  405|      0|    }
  406|       |
  407|       |    // A dummy trait as a minimal type checking comment and space for algorithmic analysis.
  408|       |    pub trait LeftistHeapDemoTrait {
  409|       |        /// Demonstrate the power of O(log n) meld operations
  410|       |        /// This would be much slower with other priority queue implementations!
  411|       |        fn efficient_multi_way_merge<T: StT + Ord>(sequences: Vec<Vec<T>>) -> Vec<T>;
  412|       |        /// Demonstrate parallel heap construction
  413|       |        fn parallel_heap_construction<T: StT + Ord>(elements: Vec<T>) -> LeftistHeapPQ<T>;
  414|       |    }
  415|       |
  416|       |    /// Demonstrate the power of O(log n) meld operations
  417|       |    /// This would be much slower with other priority queue implementations!
  418|      0|    pub fn efficient_multi_way_merge<T: StT + Ord>(sequences: Vec<Vec<T>>) -> Vec<T> {
  419|       |        // Convert each sorted sequence to a leftist heap
  420|      0|        let heaps: Vec<LeftistHeapPQ<T>> = sequences.into_iter().map(|seq| LeftistHeapPQ::from_seq(&seq)).collect();
  421|       |
  422|       |        // Meld all heaps together efficiently
  423|      0|        let merged_heap = LeftistHeapPQ::meld_multiple(&heaps);
  424|       |
  425|       |        // Extract all elements in sorted order
  426|      0|        merged_heap.extract_all_sorted()
  427|      0|    }
  428|       |
  429|       |    /// Demonstrate parallel heap construction
  430|      0|    pub fn parallel_heap_construction<T: StT + Ord>(elements: Vec<T>) -> LeftistHeapPQ<T> {
  431|       |        // This could be parallelized using the reduce pattern
  432|      0|        LeftistHeapPQ::from_seq(&elements)
  433|      0|    }
  434|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap45/SortedListPQ.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 45: Priority Queue implementation using Sorted List
    3|       |
    4|       |pub mod SortedListPQ {
    5|       |
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |    use crate::Types::Types::*;
   10|       |
   11|       |    #[derive(PartialEq, Clone, Debug)]
   12|       |    pub struct SortedListPQ<T: StT + Ord> {
   13|       |        elements: ArraySeqStPerS<T>,
   14|       |    }
   15|       |
   16|       |    /// Trait defining the Meldable Priority Queue ADT operations (Data Type 45.1)
   17|       |    pub trait SortedListPQTrait<T: StT + Ord> {
   18|       |        /// claude-4-sonet: Work (1), Span (1)
   19|       |        fn empty() -> Self;
   20|       |
   21|       |        /// claude-4-sonet: Work (1), Span (1)
   22|       |        fn singleton(element: T) -> Self;
   23|       |
   24|       |        /// claude-4-sonet: Work (1), Span (1)
   25|       |        /// Returns the minimum element (first in sorted list), or None if empty
   26|       |        fn find_min(&self) -> Option<&T>;
   27|       |
   28|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   29|       |        /// Inserts element in correct sorted position
   30|       |        fn insert(&self, element: T) -> Self;
   31|       |
   32|       |        /// claude-4-sonet: Work (1), Span (1)
   33|       |        /// Removes first element (minimum) from sorted list
   34|       |        fn delete_min(&self) -> (Self, Option<T>)
   35|       |        where
   36|       |            Self: Sized;
   37|       |
   38|       |        /// claude-4-sonet: Work (m + n), Span (m + n), Parallelism (1)
   39|       |        /// Melds two sorted priority queues by merging sorted lists
   40|       |        fn meld(&self, other: &Self) -> Self;
   41|       |
   42|       |        /// claude-4-sonet: Work (n log n), Span (n log n), Parallelism (1)
   43|       |        /// Creates priority queue from sequence by sorting
   44|       |        fn from_seq(seq: &ArraySeqStPerS<T>) -> Self;
   45|       |
   46|       |        /// Helper methods
   47|       |        fn size(&self) -> N;
   48|       |        fn is_empty(&self) -> bool;
   49|       |        fn to_seq(&self) -> ArraySeqStPerS<T>;
   50|       |    }
   51|       |
   52|       |    impl<T: StT + Ord> SortedListPQTrait<T> for SortedListPQ<T> {
   53|       |        /// Claude Work: (1), Span: (1)
   54|     42|        fn empty() -> Self {
   55|     42|            SortedListPQ {
   56|     42|                elements: ArraySeqStPerS::empty(),
   57|     42|            }
   58|     42|        }
   59|       |
   60|       |        /// Claude Work: (1), Span: (1)
   61|      3|        fn singleton(element: T) -> Self {
   62|      3|            SortedListPQ {
   63|      3|                elements: ArraySeqStPerS::singleton(element),
   64|      3|            }
   65|      3|        }
   66|       |
   67|       |        /// Claude Work: (1), Span: (1)
   68|       |        /// Minimum is always at the front of sorted list
   69|     30|        fn find_min(&self) -> Option<&T> {
   70|     30|            if self.elements.length() == 0 {
   71|      2|                None
   72|       |            } else {
   73|     28|                Some(self.elements.nth(0))
   74|       |            }
   75|     30|        }
   76|       |
   77|       |        /// Claude Work: (n), Span: (n)
   78|       |        /// Find correct position and insert to maintain sorted order
   79|    307|        fn insert(&self, element: T) -> Self {
   80|       |            // Find insertion position using binary search approach
   81|    307|            let mut insert_pos = 0;
   82|    974|            for i in 0..self.elements.length() {
                                      ^307          ^307
   83|    974|                let current = self.elements.nth(i);
   84|    974|                if element <= *current {
   85|    178|                    break;
   86|    796|                }
   87|    796|                insert_pos = i + 1;
   88|       |            }
   89|       |
   90|       |            // Build new sequence with element inserted at correct position
   91|    307|            let mut new_elements = ArraySeqStPerS::empty();
   92|       |
   93|       |            // Add elements before insertion position
   94|    796|            for i in 0..insert_pos {
                                      ^307
   95|    796|                let elem = self.elements.nth(i);
   96|    796|                let single_seq = ArraySeqStPerS::singleton(elem.clone());
   97|    796|                new_elements = ArraySeqStPerS::append(&new_elements, &single_seq);
   98|    796|            }
   99|       |
  100|       |            // Add the new element
  101|    307|            let new_elem_seq = ArraySeqStPerS::singleton(element);
  102|    307|            new_elements = ArraySeqStPerS::append(&new_elements, &new_elem_seq);
  103|       |
  104|       |            // Add elements after insertion position
  105|  5.17k|            for i in insert_pos..self.elements.length() {
                                   ^307        ^307          ^307
  106|  5.17k|                let elem = self.elements.nth(i);
  107|  5.17k|                let single_seq = ArraySeqStPerS::singleton(elem.clone());
  108|  5.17k|                new_elements = ArraySeqStPerS::append(&new_elements, &single_seq);
  109|  5.17k|            }
  110|       |
  111|    307|            SortedListPQ { elements: new_elements }
  112|    307|        }
  113|       |
  114|       |        /// Claude Work: (1), Span: (1)
  115|       |        /// Remove first element (minimum) from sorted list
  116|    254|        fn delete_min(&self) -> (Self, Option<T>) {
  117|    254|            if self.elements.length() == 0 {
  118|      1|                return (self.clone(), None);
  119|    253|            }
  120|       |
  121|    253|            let min_element = self.elements.nth(0).clone();
  122|       |
  123|       |            // Create new sequence without the first element
  124|    253|            let mut new_elements = ArraySeqStPerS::empty();
  125|  6.51k|            for i in 1..self.elements.length() {
                                      ^253          ^253
  126|  6.51k|                let elem = self.elements.nth(i);
  127|  6.51k|                let single_seq = ArraySeqStPerS::singleton(elem.clone());
  128|  6.51k|                new_elements = ArraySeqStPerS::append(&new_elements, &single_seq);
  129|  6.51k|            }
  130|       |
  131|    253|            let new_pq = SortedListPQ { elements: new_elements };
  132|       |
  133|    253|            (new_pq, Some(min_element))
  134|    254|        }
  135|       |
  136|       |        /// Claude Work: (m + n), Span: (m + n)
  137|       |        /// Merge two sorted lists maintaining sorted order
  138|      5|        fn meld(&self, other: &Self) -> Self {
  139|      5|            let mut result = ArraySeqStPerS::empty();
  140|      5|            let mut i = 0;
  141|      5|            let mut j = 0;
  142|       |
  143|       |            // Merge the two sorted sequences
  144|     61|            while i < self.elements.length() && j < other.elements.length() {
                                                              ^57
  145|     56|                let elem_self = self.elements.nth(i);
  146|     56|                let elem_other = other.elements.nth(j);
  147|       |
  148|     56|                if elem_self <= elem_other {
  149|     29|                    let single_seq = ArraySeqStPerS::singleton(elem_self.clone());
  150|     29|                    result = ArraySeqStPerS::append(&result, &single_seq);
  151|     29|                    i += 1;
  152|     29|                } else {
  153|     27|                    let single_seq = ArraySeqStPerS::singleton(elem_other.clone());
  154|     27|                    result = ArraySeqStPerS::append(&result, &single_seq);
  155|     27|                    j += 1;
  156|     27|                }
  157|       |            }
  158|       |
  159|       |            // Add remaining elements from self
  160|      7|            while i < self.elements.length() {
  161|      2|                let elem = self.elements.nth(i);
  162|      2|                let single_seq = ArraySeqStPerS::singleton(elem.clone());
  163|      2|                result = ArraySeqStPerS::append(&result, &single_seq);
  164|      2|                i += 1;
  165|      2|            }
  166|       |
  167|       |            // Add remaining elements from other
  168|     10|            while j < other.elements.length() {
  169|      5|                let elem = other.elements.nth(j);
  170|      5|                let single_seq = ArraySeqStPerS::singleton(elem.clone());
  171|      5|                result = ArraySeqStPerS::append(&result, &single_seq);
  172|      5|                j += 1;
  173|      5|            }
  174|       |
  175|      5|            SortedListPQ { elements: result }
  176|      5|        }
  177|       |
  178|       |        /// Claude Work: (n log n), Span: (n log n)
  179|       |        /// Create priority queue from sequence by insertion sort
  180|      3|        fn from_seq(seq: &ArraySeqStPerS<T>) -> Self {
  181|      3|            let mut result = Self::empty();
  182|     10|            for i in 0..seq.length() {
                                      ^3  ^3
  183|     10|                let element = seq.nth(i);
  184|     10|                result = result.insert(element.clone());
  185|     10|            }
  186|      3|            result
  187|      3|        }
  188|       |
  189|       |        /// Claude Work: (1), Span: (1)
  190|     21|        fn size(&self) -> N { self.elements.length() }
  191|       |
  192|       |        /// Claude Work: (1), Span: (1)
  193|    111|        fn is_empty(&self) -> bool { self.elements.length() == 0 }
  194|       |
  195|       |        /// Claude Work: (1), Span: (1)
  196|     13|        fn to_seq(&self) -> ArraySeqStPerS<T> { self.elements.clone() }
  197|       |    }
  198|       |
  199|       |    impl<T: StT + Ord> SortedListPQ<T> {
  200|       |        /// Insert multiple elements from a sequence
  201|      0|        pub fn insert_all(&self, elements: &ArraySeqStPerS<T>) -> Self {
  202|      0|            let mut result = self.clone();
  203|      0|            for i in 0..elements.length() {
  204|      0|                let element = elements.nth(i);
  205|      0|                result = result.insert(element.clone());
  206|      0|            }
  207|      0|            result
  208|      0|        }
  209|       |
  210|       |        /// Extract all elements in sorted order (already sorted)
  211|      0|        pub fn extract_all_sorted(&self) -> ArraySeqStPerS<T> { self.elements.clone() }
  212|       |
  213|       |        /// Get the maximum element (last in sorted list)
  214|      0|        pub fn find_max(&self) -> Option<&T> {
  215|      0|            if self.elements.length() == 0 {
  216|      0|                None
  217|       |            } else {
  218|      0|                Some(self.elements.nth(self.elements.length() - 1))
  219|       |            }
  220|      0|        }
  221|       |
  222|       |        /// Remove and return maximum element
  223|      0|        pub fn delete_max(&self) -> (Self, Option<T>) {
  224|      0|            if self.elements.length() == 0 {
  225|      0|                return (self.clone(), None);
  226|      0|            }
  227|       |
  228|      0|            let max_element = self.elements.nth(self.elements.length() - 1).clone();
  229|       |
  230|       |            // Create new sequence without the last element
  231|      0|            let mut new_elements = ArraySeqStPerS::empty();
  232|      0|            for i in 0..(self.elements.length() - 1) {
  233|      0|                let elem = self.elements.nth(i);
  234|      0|                let single_seq = ArraySeqStPerS::singleton(elem.clone());
  235|      0|                new_elements = ArraySeqStPerS::append(&new_elements, &single_seq);
  236|      0|            }
  237|       |
  238|      0|            let new_pq = SortedListPQ { elements: new_elements };
  239|       |
  240|      0|            (new_pq, Some(max_element))
  241|      0|        }
  242|       |    }
  243|       |
  244|       |    impl<T: StT + Ord> Default for SortedListPQ<T> {
  245|      0|        fn default() -> Self { Self::empty() }
  246|       |    }
  247|       |
  248|       |    impl<T: StT + Ord> Display for SortedListPQ<T> {
  249|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  250|      0|            write!(f, "SortedListPQ[")?;
  251|      0|            for i in 0..self.elements.length() {
  252|      0|                if i > 0 {
  253|      0|                    write!(f, ", ")?;
  254|      0|                }
  255|      0|                write!(f, "{}", self.elements.nth(i))?;
  256|       |            }
  257|      0|            write!(f, "]")
  258|      0|        }
  259|       |    }
  260|       |
  261|       |    // Macro for creating sorted list priority queues
  262|       |    #[macro_export]
  263|       |    macro_rules! SortedListPQLit {
  264|       |        () => {
  265|       |            $crate::Chap45::SortedListPQ::SortedListPQ::SortedListPQ::empty()
  266|       |        };
  267|       |        ($($x:expr),* $(,)?) => {{
  268|       |            let mut pq = $crate::Chap45::SortedListPQ::SortedListPQ::SortedListPQ::empty();
  269|       |            $(
  270|       |                pq = pq.insert($x);
  271|       |            )*
  272|       |            pq
  273|       |        }};
  274|       |    }
  275|       |
  276|       |    #[allow(dead_code)]
  277|      0|    fn _sorted_list_pq_lit_type_checks() {
  278|      0|        let _: SortedListPQ<i32> = SortedListPQLit![];
  279|      0|        let _: SortedListPQ<i32> = SortedListPQLit![1, 2, 3];
  280|      0|    }
  281|       |
  282|       |    /// Convenience functions for common operations
  283|       |    impl<T: StT + Ord> SortedListPQ<T> {
  284|       |        /// Create priority queue from vector (for testing)
  285|      0|        pub fn from_vec(vec: Vec<T>) -> Self {
  286|      0|            let mut pq = Self::empty();
  287|      0|            for element in vec {
  288|      0|                pq = pq.insert(element);
  289|      0|            }
  290|      0|            pq
  291|      0|        }
  292|       |
  293|       |        /// Convert to vector (for testing)
  294|      0|        pub fn to_vec(&self) -> Vec<T> {
  295|      0|            let mut result = Vec::new();
  296|      0|            for i in 0..self.elements.length() {
  297|      0|                result.push(self.elements.nth(i).clone());
  298|      0|            }
  299|      0|            result
  300|      0|        }
  301|       |
  302|       |        /// Get elements in sorted order as vector (for testing)
  303|      0|        pub fn to_sorted_vec(&self) -> Vec<T> {
  304|       |            // Already sorted, just convert to vector
  305|      0|            self.to_vec()
  306|      0|        }
  307|       |
  308|       |        /// Check if the list is properly sorted (for testing)
  309|      0|        pub fn is_sorted(&self) -> bool {
  310|      0|            for i in 1..self.elements.length() {
  311|      0|                let prev = self.elements.nth(i - 1);
  312|      0|                let curr = self.elements.nth(i);
  313|      0|                if prev > curr {
  314|      0|                    return false;
  315|      0|                }
  316|       |            }
  317|      0|            true
  318|      0|        }
  319|       |    }
  320|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap45/UnsortedListPQ.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 45: Priority Queue implementation using Unsorted List
    3|       |
    4|       |pub mod UnsortedListPQ {
    5|       |
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |    use crate::Types::Types::*;
   10|       |
   11|       |    #[derive(PartialEq, Clone, Debug)]
   12|       |    pub struct UnsortedListPQ<T: StT + Ord> {
   13|       |        elements: ArraySeqStPerS<T>,
   14|       |    }
   15|       |
   16|       |    /// Trait defining the Meldable Priority Queue ADT operations (Data Type 45.1)
   17|       |    pub trait UnsortedListPQTrait<T: StT + Ord> {
   18|       |        /// claude-4-sonet: Work (1), Span (1)
   19|       |        fn empty() -> Self;
   20|       |
   21|       |        /// claude-4-sonet: Work (1), Span (1)
   22|       |        fn singleton(element: T) -> Self;
   23|       |
   24|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   25|       |        /// Returns the minimum element, or None if empty
   26|       |        fn find_min(&self) -> Option<&T>;
   27|       |
   28|       |        /// claude-4-sonet: Work (1), Span (1)
   29|       |        /// Inserts element into unsorted list
   30|       |        fn insert(&self, element: T) -> Self;
   31|       |
   32|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   33|       |        /// Removes and returns minimum element with new queue
   34|       |        fn delete_min(&self) -> (Self, Option<T>)
   35|       |        where
   36|       |            Self: Sized;
   37|       |
   38|       |        /// claude-4-sonet: Work (m + n), Span (m + n), Parallelism (1)
   39|       |        /// Melds two priority queues by concatenating lists
   40|       |        fn meld(&self, other: &Self) -> Self;
   41|       |
   42|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   43|       |        /// Creates priority queue from sequence
   44|       |        fn from_seq(seq: &ArraySeqStPerS<T>) -> Self;
   45|       |
   46|       |        /// Helper methods
   47|       |        fn size(&self) -> N;
   48|       |        fn is_empty(&self) -> bool;
   49|       |        fn to_seq(&self) -> ArraySeqStPerS<T>;
   50|       |    }
   51|       |
   52|       |    impl<T: StT + Ord> UnsortedListPQTrait<T> for UnsortedListPQ<T> {
   53|       |        /// Claude Work: (1), Span: (1)
   54|     49|        fn empty() -> Self {
   55|     49|            UnsortedListPQ {
   56|     49|                elements: ArraySeqStPerS::empty(),
   57|     49|            }
   58|     49|        }
   59|       |
   60|       |        /// Claude Work: (1), Span: (1)
   61|      5|        fn singleton(element: T) -> Self {
   62|      5|            UnsortedListPQ {
   63|      5|                elements: ArraySeqStPerS::singleton(element),
   64|      5|            }
   65|      5|        }
   66|       |
   67|       |        /// Claude Work: (n), Span: (n)
   68|       |        /// Linear scan to find minimum element
   69|     31|        fn find_min(&self) -> Option<&T> {
   70|     31|            if self.elements.length() == 0 {
   71|      2|                return None;
   72|     29|            }
   73|       |
   74|     29|            let mut min_element = self.elements.nth(0);
   75|    319|            for i in 1..self.elements.length() {
                                      ^29           ^29
   76|    319|                let current = self.elements.nth(i);
   77|    319|                if current < min_element {
   78|    128|                    min_element = current;
   79|    191|                }
   80|       |            }
   81|     29|            Some(min_element)
   82|     31|        }
   83|       |
   84|       |        /// Claude Work: (1), Span: (1)
   85|       |        /// Simply append to end of unsorted list
   86|    437|        fn insert(&self, element: T) -> Self {
   87|    437|            let single_seq = ArraySeqStPerS::singleton(element);
   88|    437|            UnsortedListPQ {
   89|    437|                elements: ArraySeqStPerS::append(&self.elements, &single_seq),
   90|    437|            }
   91|    437|        }
   92|       |
   93|       |        /// Claude Work: (n), Span: (n)
   94|       |        /// Find minimum and remove it, creating new list without that element
   95|    233|        fn delete_min(&self) -> (Self, Option<T>) {
   96|    233|            if self.elements.length() == 0 {
   97|      1|                return (self.clone(), None);
   98|    232|            }
   99|       |
  100|       |            // Find minimum element and its index
  101|    232|            let mut min_element = self.elements.nth(0);
  102|    232|            let mut min_index = 0;
  103|       |
  104|  5.50k|            for i in 1..self.elements.length() {
                                      ^232          ^232
  105|  5.50k|                let current = self.elements.nth(i);
  106|  5.50k|                if current < min_element {
  107|  5.12k|                    min_element = current;
  108|  5.12k|                    min_index = i;
  109|  5.12k|                }
                              ^379
  110|       |            }
  111|       |
  112|       |            // Create new sequence without the minimum element
  113|    232|            let mut new_elements = ArraySeqStPerS::empty();
  114|  5.73k|            for i in 0..self.elements.length() {
                                      ^232          ^232
  115|  5.73k|                if i != min_index {
  116|  5.50k|                    let element = self.elements.nth(i);
  117|  5.50k|                    let single_seq = ArraySeqStPerS::singleton(element.clone());
  118|  5.50k|                    new_elements = ArraySeqStPerS::append(&new_elements, &single_seq);
  119|  5.50k|                }
                              ^232
  120|       |            }
  121|       |
  122|    232|            let new_pq = UnsortedListPQ { elements: new_elements };
  123|       |
  124|    232|            (new_pq, Some(min_element.clone()))
  125|    233|        }
  126|       |
  127|       |        /// Claude Work: (m + n), Span: (m + n)
  128|       |        /// Concatenate the two unsorted lists
  129|      8|        fn meld(&self, other: &Self) -> Self {
  130|      8|            UnsortedListPQ {
  131|      8|                elements: ArraySeqStPerS::append(&self.elements, &other.elements),
  132|      8|            }
  133|      8|        }
  134|       |
  135|       |        /// Claude Work: (n), Span: (n)
  136|       |        /// Create priority queue from existing sequence
  137|      1|        fn from_seq(seq: &ArraySeqStPerS<T>) -> Self { UnsortedListPQ { elements: seq.clone() } }
  138|       |
  139|       |        /// Claude Work: (1), Span: (1)
  140|     42|        fn size(&self) -> N { self.elements.length() }
  141|       |
  142|       |        /// Claude Work: (1), Span: (1)
  143|    153|        fn is_empty(&self) -> bool { self.elements.length() == 0 }
  144|       |
  145|       |        /// Claude Work: (1), Span: (1)
  146|      2|        fn to_seq(&self) -> ArraySeqStPerS<T> { self.elements.clone() }
  147|       |    }
  148|       |
  149|       |    impl<T: StT + Ord> UnsortedListPQ<T> {
  150|       |        /// Insert multiple elements from an iterator
  151|      1|        pub fn insert_all(&self, elements: &ArraySeqStPerS<T>) -> Self {
  152|      1|            let mut result = self.clone();
  153|      5|            for i in 0..elements.length() {
                                      ^1       ^1
  154|      5|                let element = elements.nth(i);
  155|      5|                result = result.insert(element.clone());
  156|      5|            }
  157|      1|            result
  158|      1|        }
  159|       |
  160|       |        /// Extract all elements in sorted order (heapsort-like operation)
  161|      7|        pub fn extract_all_sorted(&self) -> ArraySeqStPerS<T> {
  162|      7|            let mut result = ArraySeqStPerS::empty();
  163|      7|            let mut current_pq = self.clone();
  164|       |
  165|     41|            while !current_pq.is_empty() {
  166|     34|                let (new_pq, min_element) = current_pq.delete_min();
  167|     34|                if let Some(element) = min_element {
  168|     34|                    let single_seq = ArraySeqStPerS::singleton(element);
  169|     34|                    result = ArraySeqStPerS::append(&result, &single_seq);
  170|     34|                }
                              ^0
  171|     34|                current_pq = new_pq;
  172|       |            }
  173|       |
  174|      7|            result
  175|      7|        }
  176|       |    }
  177|       |
  178|       |    impl<T: StT + Ord> Default for UnsortedListPQ<T> {
  179|      0|        fn default() -> Self { Self::empty() }
  180|       |    }
  181|       |
  182|       |    impl<T: StT + Ord> Display for UnsortedListPQ<T> {
  183|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  184|      1|            write!(f, "UnsortedListPQ[")?;
                                                      ^0
  185|      3|            for i in 0..self.elements.length() {
                                      ^1            ^1
  186|      3|                if i > 0 {
  187|      2|                    write!(f, ", ")?;
                                                 ^0
  188|      1|                }
  189|      3|                write!(f, "{}", self.elements.nth(i))?;
                                                                   ^0
  190|       |            }
  191|      1|            write!(f, "]")
  192|      1|        }
  193|       |    }
  194|       |
  195|       |    // Macro for creating unsorted list priority queues
  196|       |    #[macro_export]
  197|       |    macro_rules! UnsortedListPQLit {
  198|       |        () => {
  199|       |            $crate::Chap45::UnsortedListPQ::UnsortedListPQ::UnsortedListPQ::empty()
  200|       |        };
  201|       |        ($($x:expr),* $(,)?) => {{
  202|       |            let mut pq = $crate::Chap45::UnsortedListPQ::UnsortedListPQ::UnsortedListPQ::empty();
  203|       |            $(
  204|       |                pq = pq.insert($x);
  205|       |            )*
  206|       |            pq
  207|       |        }};
  208|       |    }
  209|       |
  210|       |    #[allow(dead_code)]
  211|      0|    fn _unsorted_list_pq_lit_type_checks() {
  212|      0|        let _: UnsortedListPQ<i32> = UnsortedListPQLit![];
  213|      0|        let _: UnsortedListPQ<i32> = UnsortedListPQLit![1, 2, 3];
  214|      0|    }
  215|       |
  216|       |    /// Convenience functions for common operations
  217|       |    impl<T: StT + Ord> UnsortedListPQ<T> {
  218|       |        /// Create priority queue from vector (for testing)
  219|      2|        pub fn from_vec(vec: Vec<T>) -> Self {
  220|      2|            let mut pq = Self::empty();
  221|     12|            for element in vec {
                              ^10
  222|     10|                pq = pq.insert(element);
  223|     10|            }
  224|      2|            pq
  225|      2|        }
  226|       |
  227|       |        /// Convert to vector (for testing)
  228|      3|        pub fn to_vec(&self) -> Vec<T> {
  229|      3|            let mut result = Vec::new();
  230|      9|            for i in 0..self.elements.length() {
                                      ^3            ^3
  231|      9|                result.push(self.elements.nth(i).clone());
  232|      9|            }
  233|      3|            result
  234|      3|        }
  235|       |
  236|       |        /// Get elements in sorted order as vector (for testing)
  237|      3|        pub fn to_sorted_vec(&self) -> Vec<T> {
  238|      3|            let sorted_seq = self.extract_all_sorted();
  239|      3|            let mut result = Vec::new();
  240|     14|            for i in 0..sorted_seq.length() {
                                      ^3         ^3
  241|     14|                result.push(sorted_seq.nth(i).clone());
  242|     14|            }
  243|      3|            result
  244|      3|        }
  245|       |    }
  246|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap47/AdvancedDoubleHashing.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 47: Advanced Double Hashing Strategy with Dual Hash Functions and Relative Prime Validation
    3|       |//! Definition 47.9: Double hashing with h_i(k) = (h1(k) + i * h2(k)) mod m
    4|       |
    5|       |pub mod AdvancedDoubleHashing {
    6|       |
    7|       |use std::fmt::{Debug, Display};
    8|       |
    9|       |use crate::Types::Types::*;
   10|       |use crate::Chap47::FlatHashTable::FlatHashTable::*;
   11|       |use crate::Chap47::HashFunctionTraits::HashFunctionTraits::*;
   12|       |    #[derive(Clone, Debug)]
   13|       |    pub struct AdvancedDoubleHashingStrategy<K: StT, H1: HashFunClone<K>, H2: HashFunClone<K>> {
   14|       |        hash1: H1,
   15|       |        hash2: H2,
   16|       |        clustering_enabled: B,
   17|       |        prime_validation_enabled: B,
   18|       |        _phantom: std::marker::PhantomData<K>,
   19|       |    }
   20|       |
   21|       |    /// Double Hashing Quality Metrics
   22|       |    /// Claude Work: (1), Span: (1)
   23|       |    #[derive(Clone, Debug, PartialEq)]
   24|       |    pub struct DoubleHashingMetrics {
   25|       |        pub probe_sequence_length: N,
   26|       |        pub unique_probe_positions: N,
   27|       |        pub probe_sequence_period: N,
   28|       |        pub hash_function_independence: f64,
   29|       |        pub relative_prime_validation: B,
   30|       |        pub collision_avoidance_score: f64,
   31|       |    }
   32|       |
   33|       |    /// Relative Prime Validator for Double Hashing
   34|       |    /// Claude Work: (log min(a,b)), Span: (log min(a,b))
   35|       |    #[derive(Clone, Debug)]
   36|       |    pub struct RelativePrimeValidator;
   37|       |
   38|       |    impl RelativePrimeValidator {
   39|       |        /// Compute greatest common divisor using Euclidean algorithm
   40|       |        /// Claude Work: O(log min(a,b)), Span: O(log min(a,b))
   41|    436|        pub fn gcd(a: N, b: N) -> N {
   42|    436|            if b == 0 {
   43|    104|                a
   44|       |            } else {
   45|    332|                Self::gcd(b, a % b)
   46|       |            }
   47|    436|        }
   48|       |
   49|       |        /// Check if two numbers are relatively prime (gcd = 1)
   50|       |        /// Claude Work: O(log min(a,b)), Span: O(log min(a,b))
   51|     47|        pub fn are_relatively_prime(a: N, b: N) -> B { Self::gcd(a, b) == 1 }
   52|       |
   53|       |        /// Validate that h2(k) and table_size are relatively prime
   54|       |        /// This ensures the probe sequence visits all table positions
   55|       |        /// Claude Work: O(log min(h2_value, table_size)), Span: O(log min(h2_value, table_size))
   56|     26|        pub fn validate_double_hashing(h2_value: N, table_size: N) -> (B, String) {
   57|     26|            if h2_value == 0 {
   58|      0|                return (false, "h2(k) cannot be zero".to_string());
   59|     26|            }
   60|       |
   61|     26|            if table_size == 0 {
   62|      0|                return (false, "Table size cannot be zero".to_string());
   63|     26|            }
   64|       |
   65|     26|            let is_valid = Self::are_relatively_prime(h2_value, table_size);
   66|     26|            let message = if is_valid {
   67|     24|                format!("h2(k)={} and table_size={} are relatively prime", h2_value, table_size)
   68|       |            } else {
   69|      2|                format!(
   70|      2|                    "h2(k)={} and table_size={} are NOT relatively prime (gcd={})",
   71|       |                    h2_value,
   72|       |                    table_size,
   73|      2|                    Self::gcd(h2_value, table_size)
   74|       |                )
   75|       |            };
   76|       |
   77|     26|            (is_valid, message)
   78|     26|        }
   79|       |
   80|       |        /// Find the period of the probe sequence for given h2_value and table_size
   81|       |        /// The period is table_size / gcd(h2_value, table_size)
   82|       |        /// Claude Work: O(log min(h2_value, table_size)), Span: O(log min(h2_value, table_size))
   83|     50|        pub fn probe_sequence_period(h2_value: N, table_size: N) -> N {
   84|     50|            if h2_value == 0 || table_size == 0 {
   85|      0|                return 0;
   86|     50|            }
   87|     50|            table_size / Self::gcd(h2_value, table_size)
   88|     50|        }
   89|       |
   90|       |        /// Generate a list of h2 values that are relatively prime to table_size
   91|       |        /// Claude Work: O(m * log m), Span: O(m * log m) where m is table_size
   92|      2|        pub fn generate_valid_h2_values(table_size: N, max_count: N) -> Vec<N> {
   93|      2|            let mut valid_values = Vec::new();
   94|      2|            let mut candidate = 1;
   95|       |
   96|     12|            while valid_values.len() < max_count as usize && candidate < table_size {
                                                                           ^10
   97|     10|                if Self::are_relatively_prime(candidate, table_size) {
   98|     10|                    valid_values.push(candidate);
   99|     10|                }
                              ^0
  100|     10|                candidate += 1;
  101|       |            }
  102|       |
  103|      2|            valid_values
  104|      2|        }
  105|       |    }
  106|       |
  107|       |    impl<K: StT, H1: HashFunClone<K>, H2: HashFunClone<K>> AdvancedDoubleHashingStrategy<K, H1, H2> {
  108|       |        /// Create new advanced double hashing strategy
  109|       |        /// Claude Work: (1), Span: (1)
  110|     54|        pub fn new(hash1: H1, hash2: H2) -> Self {
  111|     54|            AdvancedDoubleHashingStrategy {
  112|     54|                hash1,
  113|     54|                hash2,
  114|     54|                clustering_enabled: true,
  115|     54|                prime_validation_enabled: true,
  116|     54|                _phantom: std::marker::PhantomData,
  117|     54|            }
  118|     54|        }
  119|       |
  120|       |        /// Create strategy with validation disabled (for performance comparison)
  121|       |        /// Claude Work: (1), Span: (1)
  122|      1|        pub fn new_minimal(hash1: H1, hash2: H2) -> Self {
  123|      1|            AdvancedDoubleHashingStrategy {
  124|      1|                hash1,
  125|      1|                hash2,
  126|      1|                clustering_enabled: false,
  127|      1|                prime_validation_enabled: false,
  128|      1|                _phantom: std::marker::PhantomData,
  129|      1|            }
  130|      1|        }
  131|       |
  132|       |        /// Analyze double hashing quality for a specific key and table size
  133|       |        /// Claude Work: (m), Span: (m) where m is table size
  134|     20|        pub fn analyze_double_hashing_quality(&self, key: &K, table_size: N) -> DoubleHashingMetrics {
  135|     20|            if !self.clustering_enabled {
  136|      0|                return DoubleHashingMetrics {
  137|      0|                    probe_sequence_length: 0,
  138|      0|                    unique_probe_positions: 0,
  139|      0|                    probe_sequence_period: 0,
  140|      0|                    hash_function_independence: 0.0,
  141|      0|                    relative_prime_validation: false,
  142|      0|                    collision_avoidance_score: 0.0,
  143|      0|                };
  144|     20|            }
  145|       |
  146|     20|            let h1_value = self.hash1.hash(key, table_size);
  147|     20|            let h2_value = self.hash2.hash(key, table_size);
  148|       |
  149|       |            // Ensure h2_value is not zero (would cause infinite loop)
  150|     20|            let h2_value = if h2_value == 0 { 1 } else { h2_value };
                                                            ^3         ^17
  151|       |
  152|       |            // Validate relative primality
  153|     20|            let (relative_prime_validation, _) = RelativePrimeValidator::validate_double_hashing(h2_value, table_size);
  154|       |
  155|       |            // Calculate probe sequence period
  156|     20|            let probe_sequence_period = RelativePrimeValidator::probe_sequence_period(h2_value, table_size);
  157|       |
  158|       |            // Generate probe sequence to analyze uniqueness
  159|     20|            let mut probe_positions = std::collections::HashSet::new();
  160|     20|            let mut current_pos = h1_value;
  161|     20|            let mut probe_count = 0;
  162|       |
  163|       |            // Generate probe sequence until we revisit a position or reach table_size
  164|    290|            while probe_positions.insert(current_pos) && probe_count < table_size {
                                                                       ^270
  165|    270|                probe_count += 1;
  166|    270|                current_pos = (current_pos + h2_value) % table_size;
  167|    270|            }
  168|       |
  169|     20|            let unique_probe_positions = probe_positions.len();
  170|       |
  171|       |            // Measure hash function independence (simplified heuristic)
  172|     20|            let independence_score = if h1_value != h2_value {
  173|      3|                let diff = if h1_value > h2_value {
  174|      0|                    h1_value - h2_value
  175|       |                } else {
  176|      3|                    h2_value - h1_value
  177|       |                };
  178|      3|                (diff as f64) / (table_size as f64)
  179|       |            } else {
  180|     17|                0.0 // Same hash values indicate poor independence
  181|       |            };
  182|       |
  183|       |            // Collision avoidance score based on probe sequence coverage
  184|     20|            let collision_avoidance_score = (unique_probe_positions as f64) / (table_size as f64);
  185|       |
  186|     20|            DoubleHashingMetrics {
  187|     20|                probe_sequence_length: probe_count,
  188|     20|                unique_probe_positions,
  189|     20|                probe_sequence_period,
  190|     20|                hash_function_independence: independence_score,
  191|     20|                relative_prime_validation,
  192|     20|                collision_avoidance_score,
  193|     20|            }
  194|     20|        }
  195|       |
  196|       |        /// Validate configuration for optimal double hashing
  197|       |        /// Claude Work: O(log min(h2_value, table_size)), Span: O(log min(h2_value, table_size))
  198|      2|        pub fn validate_configuration(&self, key: &K, table_size: N) -> (B, String) {
  199|      2|            if !self.prime_validation_enabled {
  200|      0|                return (true, "Validation disabled".to_string());
  201|      2|            }
  202|       |
  203|      2|            let h2_value = self.hash2.hash(key, table_size);
  204|      2|            let h2_value = if h2_value == 0 { 1 } else { h2_value };
                                                            ^1         ^1
  205|       |
  206|      2|            RelativePrimeValidator::validate_double_hashing(h2_value, table_size)
  207|      2|        }
  208|       |
  209|       |        /// Estimate expected probe count for double hashing
  210|       |        /// Based on theoretical analysis: approximately 1/(1-) for unsuccessful search
  211|       |        /// Claude Work: (1), Span: (1)
  212|     36|        pub fn estimate_probe_count(&self, load_factor: f64, is_successful: B) -> f64 {
  213|     36|            if load_factor >= 1.0 {
  214|      0|                return f64::INFINITY;
  215|     36|            }
  216|       |
  217|     36|            if is_successful {
  218|       |                // Successful search: approximately (1/) * ln(1/(1-))
  219|     18|                if load_factor > 0.0 {
  220|     18|                    (1.0 / load_factor) * (1.0 / (1.0 - load_factor)).ln()
  221|       |                } else {
  222|      0|                    1.0
  223|       |                }
  224|       |            } else {
  225|       |                // Unsuccessful search: approximately 1/(1-)
  226|     18|                1.0 / (1.0 - load_factor)
  227|       |            }
  228|     36|        }
  229|       |
  230|       |        /// Check if double hashing configuration is optimal
  231|       |        /// Claude Work: (1), Span: (1)
  232|      1|        pub fn is_configuration_optimal(&self, metrics: &DoubleHashingMetrics, table_size: N) -> B {
  233|      1|            metrics.relative_prime_validation
  234|      1|                && metrics.probe_sequence_period == table_size
  235|      1|                && metrics.hash_function_independence > 0.1
  236|      0|                && metrics.collision_avoidance_score > 0.8
  237|      1|        }
  238|       |
  239|       |        /// Get hash function values for debugging
  240|       |        /// Claude Work: (1), Span: (1)
  241|     29|        pub fn get_hash_values(&self, key: &K, table_size: N) -> (N, N) {
  242|     29|            let h1_value = self.hash1.hash(key, table_size);
  243|     29|            let h2_value = self.hash2.hash(key, table_size);
  244|     29|            (h1_value, h2_value)
  245|     29|        }
  246|       |
  247|       |        /// Generate probe sequence for visualization
  248|       |        /// Claude Work: (min(max_probes, period)), Span: (min(max_probes, period))
  249|     29|        pub fn generate_probe_sequence(&self, key: &K, table_size: N, max_probes: N) -> Vec<N> {
  250|     29|            let h1_value = self.hash1.hash(key, table_size);
  251|     29|            let h2_value = self.hash2.hash(key, table_size);
  252|     29|            let h2_value = if h2_value == 0 { 1 } else { h2_value };
                                                            ^3         ^26
  253|       |
  254|     29|            let mut sequence = Vec::new();
  255|     29|            let mut current_pos = h1_value;
  256|       |
  257|    560|            for _ in 0..max_probes {
                                      ^29
  258|    560|                sequence.push(current_pos);
  259|    560|                current_pos = (current_pos + h2_value) % table_size;
  260|    560|            }
  261|       |
  262|     29|            sequence
  263|     29|        }
  264|       |    }
  265|       |
  266|       |    impl<K: StT, H1: HashFunClone<K>, H2: HashFunClone<K>> ProbeSequence<K> for AdvancedDoubleHashingStrategy<K, H1, H2> {
  267|       |        /// Double hashing: h_i(k) = (h1(k) + i * h2(k)) mod m
  268|       |        /// Claude Work: (1), Span: (1)
  269|     82|        fn probe_hash(&self, key: &K, probe_index: N, table_size: N) -> N {
  270|     82|            let h1_value = self.hash1.hash(key, table_size);
  271|     82|            let h2_value = self.hash2.hash(key, table_size);
  272|       |            // Ensure h2_value is not zero to avoid infinite loops
  273|     82|            let h2_value = if h2_value == 0 { 1 } else { h2_value };
                                                            ^10        ^72
  274|     82|            (h1_value + probe_index * h2_value) % table_size
  275|     82|        }
  276|       |
  277|       |        /// Strategy name for debugging and analysis
  278|       |        /// Claude Work: (1), Span: (1)
  279|      2|        fn strategy_name(&self) -> String { "AdvancedDoubleHashing".to_string() }
  280|       |    }
  281|       |
  282|       |    impl<K: StT, H1: HashFunClone<K>, H2: HashFunClone<K>> Display for AdvancedDoubleHashingStrategy<K, H1, H2> {
  283|      0|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  284|      0|            write!(
  285|      0|                f,
  286|      0|                "AdvancedDoubleHashing(clustering_enabled={}, prime_validation={})",
  287|       |                self.clustering_enabled, self.prime_validation_enabled
  288|       |            )
  289|      0|        }
  290|       |    }
  291|       |
  292|       |    impl Display for DoubleHashingMetrics {
  293|      0|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  294|      0|            writeln!(f, "Double Hashing Quality Metrics:")?;
  295|      0|            writeln!(f, "  Probe sequence length: {}", self.probe_sequence_length)?;
  296|      0|            writeln!(f, "  Unique probe positions: {}", self.unique_probe_positions)?;
  297|      0|            writeln!(f, "  Probe sequence period: {}", self.probe_sequence_period)?;
  298|      0|            writeln!(
  299|      0|                f,
  300|      0|                "  Hash function independence: {:.3}",
  301|       |                self.hash_function_independence
  302|      0|            )?;
  303|      0|            writeln!(f, "  Relative prime validation: {}", self.relative_prime_validation)?;
  304|      0|            write!(f, "  Collision avoidance score: {:.3}", self.collision_avoidance_score)
  305|      0|        }
  306|       |    }
  307|       |
  308|       |    /// Textbook Example: Double Hashing with Relative Prime Validation
  309|       |    /// Demonstrates h1(k) = k mod m, h2(k) = 1 + (k mod (m-1))
  310|       |    /// Claude Work: (m), Span: (m)
  311|      1|    pub fn example_double_hashing_analysis() -> (DoubleHashingMetrics, f64, f64, (B, String)) {
  312|      1|        let hash1 = DefaultHashFunction;
  313|      1|        let hash2 = DefaultHashFunction; // In practice, would use different hash functions
  314|      1|        let strategy: AdvancedDoubleHashingStrategy<String, DefaultHashFunction, DefaultHashFunction> =
  315|      1|            AdvancedDoubleHashingStrategy::new(hash1, hash2);
  316|       |
  317|      1|        let test_key = "example_key".to_string();
  318|      1|        let table_size = 13; // Prime table size
  319|       |
  320|       |        // Analyze double hashing quality
  321|      1|        let metrics = strategy.analyze_double_hashing_quality(&test_key, table_size);
  322|       |
  323|       |        // Estimate probe counts for 50% load factor
  324|      1|        let successful_probes = strategy.estimate_probe_count(0.5, true);
  325|      1|        let unsuccessful_probes = strategy.estimate_probe_count(0.5, false);
  326|       |
  327|       |        // Validate configuration
  328|      1|        let validation = strategy.validate_configuration(&test_key, table_size);
  329|       |
  330|      1|        (metrics, successful_probes, unsuccessful_probes, validation)
  331|      1|    }
  332|       |
  333|       |    /// Example demonstrating probe sequence generation and analysis
  334|       |    /// Claude Work: (m), Span: (m)
  335|      1|    pub fn example_probe_sequence_analysis() -> (Vec<N>, DoubleHashingMetrics, Vec<N>) {
  336|      1|        let hash1 = DefaultHashFunction;
  337|      1|        let hash2 = DefaultHashFunction;
  338|      1|        let strategy: AdvancedDoubleHashingStrategy<String, DefaultHashFunction, DefaultHashFunction> =
  339|      1|            AdvancedDoubleHashingStrategy::new(hash1, hash2);
  340|       |
  341|      1|        let test_key = "probe_test".to_string();
  342|      1|        let table_size = 11; // Prime table size
  343|       |
  344|       |        // Generate probe sequence
  345|      1|        let probe_sequence = strategy.generate_probe_sequence(&test_key, table_size, 15);
  346|       |
  347|       |        // Analyze quality
  348|      1|        let metrics = strategy.analyze_double_hashing_quality(&test_key, table_size);
  349|       |
  350|       |        // Generate valid h2 values for comparison
  351|      1|        let valid_h2_values = RelativePrimeValidator::generate_valid_h2_values(table_size, 5);
  352|       |
  353|      1|        (probe_sequence, metrics, valid_h2_values)
  354|      1|    }
  355|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap47/AdvancedLinearProbing.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 47: Advanced Linear Probing Strategy with Primary Clustering Analysis
    3|       |//! Definition 47.7: Linear probing with h_i(k) = (h(k) + i) mod m
    4|       |
    5|       |pub mod AdvancedLinearProbing {
    6|       |
    7|       |use std::fmt::{Debug, Display};
    8|       |
    9|       |use crate::Types::Types::*;
   10|       |use crate::Chap47::FlatHashTable::FlatHashTable::*;
   11|       |use crate::Chap47::HashFunctionTraits::HashFunctionTraits::*;
   12|       |    #[derive(Clone, Debug)]
   13|       |    pub struct AdvancedLinearProbingStrategy<K: StT, H: HashFunClone<K>> {
   14|       |        base_hash: H,
   15|       |        clustering_enabled: B,
   16|       |        _phantom: std::marker::PhantomData<K>,
   17|       |    }
   18|       |
   19|       |    /// Primary Clustering Metrics
   20|       |    /// Claude Work: (1), Span: (1)
   21|       |    #[derive(Clone, Debug, PartialEq)]
   22|       |    pub struct PrimaryClusteringMetrics {
   23|       |        pub total_clusters: N,
   24|       |        pub max_cluster_size: N,
   25|       |        pub avg_cluster_size: f64,
   26|       |        pub clustering_coefficient: f64,
   27|       |        pub probe_variance: f64,
   28|       |    }
   29|       |
   30|       |    impl<K: StT, H: HashFunClone<K>> AdvancedLinearProbingStrategy<K, H> {
   31|       |        /// Create new advanced linear probing strategy
   32|       |        /// Claude Work: (1), Span: (1)
   33|     66|        pub fn new(hash_fn: H) -> Self {
   34|     66|            AdvancedLinearProbingStrategy {
   35|     66|                base_hash: hash_fn,
   36|     66|                clustering_enabled: true,
   37|     66|                _phantom: std::marker::PhantomData,
   38|     66|            }
   39|     66|        }
   40|       |
   41|       |        /// Create strategy with clustering analysis disabled
   42|       |        /// Claude Work: (1), Span: (1)
   43|      2|        pub fn new_without_clustering(hash_fn: H) -> Self {
   44|      2|            AdvancedLinearProbingStrategy {
   45|      2|                base_hash: hash_fn,
   46|      2|                clustering_enabled: false,
   47|      2|                _phantom: std::marker::PhantomData,
   48|      2|            }
   49|      2|        }
   50|       |
   51|       |        /// Analyze primary clustering in a hash table
   52|       |        /// Claude Work: (m), Span: (m) where m is table size
   53|     22|        pub fn analyze_primary_clustering<V: StT>(&self, table: &FlatHashTable<K, V, Self>) -> PrimaryClusteringMetrics
   54|     22|        where
   55|     22|            Self: ProbeSequence<K> + Clone,
   56|       |        {
   57|     22|            if !self.clustering_enabled {
   58|      1|                return PrimaryClusteringMetrics {
   59|      1|                    total_clusters: 0,
   60|      1|                    max_cluster_size: 0,
   61|      1|                    avg_cluster_size: 0.0,
   62|      1|                    clustering_coefficient: 0.0,
   63|      1|                    probe_variance: 0.0,
   64|      1|                };
   65|     21|            }
   66|       |
   67|     21|            let (load, size) = table.load_and_size();
   68|     21|            if size == 0 {
   69|      0|                return PrimaryClusteringMetrics {
   70|      0|                    total_clusters: 0,
   71|      0|                    max_cluster_size: 0,
   72|      0|                    avg_cluster_size: 0.0,
   73|      0|                    clustering_coefficient: 0.0,
   74|      0|                    probe_variance: 0.0,
   75|      0|                };
   76|     21|            }
   77|       |
   78|     21|            let mut clusters = Vec::new();
   79|     21|            let mut current_cluster_size = 0;
   80|     21|            let mut in_cluster = false;
   81|       |
   82|       |            // Scan table to identify clusters
   83|    308|            for i in 0..size {
                                      ^21
   84|    308|                let is_occupied = self.is_position_occupied(table, i);
   85|       |
   86|    308|                if is_occupied {
   87|     22|                    if !in_cluster {
   88|      4|                        in_cluster = true;
   89|      4|                        current_cluster_size = 1;
   90|     18|                    } else {
   91|     18|                        current_cluster_size += 1;
   92|     18|                    }
   93|       |                } else {
   94|    286|                    if in_cluster {
   95|      4|                        clusters.push(current_cluster_size);
   96|      4|                        in_cluster = false;
   97|      4|                        current_cluster_size = 0;
   98|    282|                    }
   99|       |                }
  100|       |            }
  101|       |
  102|       |            // Handle wrap-around cluster
  103|     21|            if in_cluster {
  104|      0|                clusters.push(current_cluster_size);
  105|     21|            }
  106|       |
  107|     21|            self.compute_clustering_metrics(clusters, load, size)
  108|     22|        }
  109|       |
  110|       |        /// Check if a position in the table is occupied
  111|       |        /// Claude Work: (1), Span: (1)
  112|    308|        fn is_position_occupied<V: StT>(&self, table: &FlatHashTable<K, V, Self>, position: N) -> B
  113|    308|        where
  114|    308|            Self: ProbeSequence<K> + Clone,
  115|       |        {
  116|       |            // This is a simplified check - in practice would need access to table internals
  117|       |            // For now, assume we can check occupancy through table statistics
  118|    308|            let (load, size) = table.load_and_size();
  119|       |            // Simplified heuristic based on load factor
  120|    308|            position < (load * size) / size
  121|    308|        }
  122|       |
  123|       |        /// Compute clustering metrics from cluster sizes
  124|       |        /// Claude Work: (c), Span: (c) where c is number of clusters
  125|     21|        fn compute_clustering_metrics(&self, clusters: Vec<N>, load: N, size: N) -> PrimaryClusteringMetrics {
  126|     21|            if clusters.is_empty() {
  127|     17|                return PrimaryClusteringMetrics {
  128|     17|                    total_clusters: 0,
  129|     17|                    max_cluster_size: 0,
  130|     17|                    avg_cluster_size: 0.0,
  131|     17|                    clustering_coefficient: 0.0,
  132|     17|                    probe_variance: 0.0,
  133|     17|                };
  134|      4|            }
  135|       |
  136|      4|            let total_clusters = clusters.len();
  137|      4|            let max_cluster_size = *clusters.iter().max().unwrap_or(&0);
  138|      4|            let total_cluster_elements: N = clusters.iter().sum();
  139|      4|            let avg_cluster_size = if total_clusters > 0 {
  140|      4|                total_cluster_elements as f64 / total_clusters as f64
  141|       |            } else {
  142|      0|                0.0
  143|       |            };
  144|       |
  145|       |            // Clustering coefficient: how much clustering deviates from uniform distribution
  146|      4|            let expected_avg_cluster_size = if size > 0 { load as f64 / size as f64 } else { 0.0 };
                                                                                                           ^0
  147|      4|            let clustering_coefficient = if expected_avg_cluster_size > 0.0 {
  148|      4|                avg_cluster_size / expected_avg_cluster_size
  149|       |            } else {
  150|      0|                0.0
  151|       |            };
  152|       |
  153|       |            // Probe variance: variance in cluster sizes
  154|      4|            let variance = if total_clusters > 1 {
  155|      0|                let mean = avg_cluster_size;
  156|      0|                let sum_squared_diff: f64 = clusters.iter().map(|&size| (size as f64 - mean).powi(2)).sum();
  157|      0|                sum_squared_diff / (total_clusters - 1) as f64
  158|       |            } else {
  159|      4|                0.0
  160|       |            };
  161|       |
  162|      4|            PrimaryClusteringMetrics {
  163|      4|                total_clusters,
  164|      4|                max_cluster_size,
  165|      4|                avg_cluster_size,
  166|      4|                clustering_coefficient,
  167|      4|                probe_variance: variance,
  168|      4|            }
  169|     21|        }
  170|       |
  171|       |        /// Estimate expected probe count for unsuccessful search
  172|       |        /// Based on textbook analysis: 1 + n(n+1)/2m  n/4 for worst case
  173|       |        /// Claude Work: (1), Span: (1)
  174|     26|        pub fn estimate_unsuccessful_probe_count(&self, load_factor: f64) -> f64 {
  175|     26|            if load_factor >= 1.0 {
  176|      1|                return f64::INFINITY;
  177|     25|            }
  178|       |
  179|       |            // Expected probes for unsuccessful search: 1/(1-)
  180|     25|            1.0 / (1.0 - load_factor)
  181|     26|        }
  182|       |
  183|       |        /// Estimate expected probe count for successful search
  184|       |        /// Claude Work: (1), Span: (1)
  185|     26|        pub fn estimate_successful_probe_count(&self, load_factor: f64) -> f64 {
  186|     26|            if load_factor >= 1.0 {
  187|      1|                return f64::INFINITY;
  188|     25|            }
  189|       |
  190|       |            // Expected probes for successful search: (1/) * ln(1/(1-))
  191|     25|            if load_factor > 0.0 {
  192|      9|                (1.0 / load_factor) * (1.0 / (1.0 - load_factor)).ln()
  193|       |            } else {
  194|     16|                1.0
  195|       |            }
  196|     26|        }
  197|       |
  198|       |        /// Check if clustering is problematic for given load factor
  199|       |        /// Claude Work: (1), Span: (1)
  200|      4|        pub fn is_clustering_problematic(&self, load_factor: f64) -> B {
  201|       |            // Linear probing becomes problematic when load factor > 0.7
  202|      4|            load_factor > 0.7
  203|      4|        }
  204|       |    }
  205|       |
  206|       |    impl<K: StT, H: HashFunClone<K>> ProbeSequence<K> for AdvancedLinearProbingStrategy<K, H> {
  207|       |        /// Linear probing: h_i(k) = (h(k) + i) mod m
  208|       |        /// Claude Work: (1), Span: (1)
  209|    417|        fn probe_hash(&self, key: &K, probe_index: N, table_size: N) -> N {
  210|    417|            let base_hash = self.base_hash.hash(key, table_size);
  211|    417|            (base_hash + probe_index) % table_size
  212|    417|        }
  213|       |
  214|       |        /// Strategy name for debugging and analysis
  215|       |        /// Claude Work: (1), Span: (1)
  216|      1|        fn strategy_name(&self) -> String { "AdvancedLinearProbing".to_string() }
  217|       |    }
  218|       |
  219|       |    impl<K: StT, H: HashFunClone<K>> Display for AdvancedLinearProbingStrategy<K, H> {
  220|      2|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  221|      2|            write!(
  222|      2|                f,
  223|      2|                "AdvancedLinearProbing(clustering_enabled: {})",
  224|       |                self.clustering_enabled
  225|       |            )
  226|      2|        }
  227|       |    }
  228|       |
  229|       |    impl Display for PrimaryClusteringMetrics {
  230|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  231|      1|            writeln!(f, "Primary Clustering Metrics:")?;
                                                                    ^0
  232|      1|            writeln!(f, "  Total clusters: {}", self.total_clusters)?;
                                                                                  ^0
  233|      1|            writeln!(f, "  Max cluster size: {}", self.max_cluster_size)?;
                                                                                      ^0
  234|      1|            writeln!(f, "  Avg cluster size: {:.2}", self.avg_cluster_size)?;
                                                                                         ^0
  235|      1|            writeln!(f, "  Clustering coefficient: {:.3}", self.clustering_coefficient)?;
                                                                                                     ^0
  236|      1|            write!(f, "  Probe variance: {:.3}", self.probe_variance)
  237|      1|        }
  238|       |    }
  239|       |
  240|       |    /// Textbook Example: Primary Clustering Analysis
  241|       |    /// Demonstrates worst-case clustering when  = 1/2
  242|       |    /// Claude Work: (m), Span: (m)
  243|      1|    pub fn example_primary_clustering_analysis() -> (PrimaryClusteringMetrics, f64, f64) {
  244|      1|        let hash_fn = DefaultHashFunction;
  245|      1|        let strategy: AdvancedLinearProbingStrategy<String, DefaultHashFunction> =
  246|      1|            AdvancedLinearProbingStrategy::new(hash_fn);
  247|       |
  248|       |        // Create a table with 50% load factor ( = 1/2)
  249|      1|        let table: FlatHashTable<String, String, AdvancedLinearProbingStrategy<String, DefaultHashFunction>> =
  250|      1|            FlatHashTable::create_table(strategy.clone(), 16);
  251|       |
  252|       |        // Analyze clustering
  253|      1|        let metrics = strategy.analyze_primary_clustering(&table);
  254|       |
  255|       |        // Estimate probe counts
  256|      1|        let unsuccessful_probes = strategy.estimate_unsuccessful_probe_count(0.5);
  257|      1|        let successful_probes = strategy.estimate_successful_probe_count(0.5);
  258|       |
  259|      1|        (metrics, unsuccessful_probes, successful_probes)
  260|      1|    }
  261|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap47/AdvancedQuadraticProbing.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 47: Advanced Quadratic Probing Strategy with Secondary Clustering Avoidance
    3|       |//! Definition 47.8: Quadratic probing with h_i(k) = (h(k) + c1*i + c2*i^2) mod m
    4|       |
    5|       |pub mod AdvancedQuadraticProbing {
    6|       |
    7|       |use std::fmt::{Debug, Display};
    8|       |
    9|       |use crate::Types::Types::*;
   10|       |use crate::Chap47::FlatHashTable::FlatHashTable::*;
   11|       |use crate::Chap47::HashFunctionTraits::HashFunctionTraits::*;
   12|       |    #[derive(Clone, Debug)]
   13|       |    pub struct AdvancedQuadraticProbingStrategy<K: StT, H: HashFunClone<K>> {
   14|       |        base_hash: H,
   15|       |        c1: N,
   16|       |        c2: N,
   17|       |        clustering_enabled: B,
   18|       |        prime_validation_enabled: B,
   19|       |        _phantom: std::marker::PhantomData<K>,
   20|       |    }
   21|       |
   22|       |    /// Secondary Clustering Metrics
   23|       |    /// Claude Work: (1), Span: (1)
   24|       |    #[derive(Clone, Debug, PartialEq)]
   25|       |    pub struct SecondaryClusteringMetrics {
   26|       |        pub collision_chains: N,
   27|       |        pub max_chain_length: N,
   28|       |        pub avg_chain_length: f64,
   29|       |        pub secondary_clustering_coefficient: f64,
   30|       |        pub probe_sequence_diversity: f64,
   31|       |        pub table_size_is_prime: B,
   32|       |    }
   33|       |
   34|       |    /// Prime Table Size Validator
   35|       |    /// Claude Work: (n), Span: (n)
   36|       |    #[derive(Clone, Debug)]
   37|       |    pub struct PrimeValidator;
   38|       |
   39|       |    impl PrimeValidator {
   40|       |        /// Check if a number is prime
   41|       |        /// Claude Work: (n), Span: (n)
   42|     76|        pub fn is_prime(n: N) -> B {
   43|     76|            if n < 2 {
   44|      3|                return false;
   45|     73|            }
   46|     73|            if n == 2 {
   47|      5|                return true;
   48|     68|            }
   49|     68|            if n % 2 == 0 {
   50|     20|                return false;
   51|     48|            }
   52|       |
   53|     48|            let sqrt_n = (n as f64).sqrt() as N;
   54|     48|            for i in (3..=sqrt_n).step_by(2) {
                              ^43
   55|     43|                if n % i == 0 {
   56|      6|                    return false;
   57|     37|                }
   58|       |            }
   59|     42|            true
   60|     76|        }
   61|       |
   62|       |        /// Find next prime greater than or equal to n
   63|       |        /// Claude Work: O(n log log n), Span: O(n log log n)
   64|     10|        pub fn next_prime(n: N) -> N {
   65|     10|            let mut candidate = n;
   66|     22|            while !Self::is_prime(candidate) {
   67|     12|                candidate += 1;
   68|     12|            }
   69|     10|            candidate
   70|     10|        }
   71|       |
   72|       |        /// Validate quadratic probing parameters for given table size
   73|       |        /// For quadratic probing to work well, m should be prime and c2 should be non-zero
   74|       |        /// Claude Work: (m), Span: (m)
   75|      7|        pub fn validate_quadratic_params(table_size: N, _c1: N, c2: N) -> (B, String) {
   76|      7|            let mut issues = Vec::new();
   77|       |
   78|      7|            if !Self::is_prime(table_size) {
   79|      2|                issues.push(format!("Table size {} is not prime", table_size));
   80|      5|            }
   81|       |
   82|      7|            if c2 == 0 {
   83|      1|                issues.push("c2 coefficient is zero (reduces to linear probing)".to_string());
   84|      6|            }
   85|       |
   86|       |            // For prime table size, c2 should be coprime to m
   87|      7|            if Self::is_prime(table_size) && Self::gcd(c2, table_size) != 1 {
                                                           ^5
   88|      2|                issues.push(format!("c2 ({}) is not coprime to table size ({})", c2, table_size));
   89|      5|            }
   90|       |
   91|      7|            let is_valid = issues.is_empty();
   92|      7|            let message = if is_valid {
   93|      3|                "Quadratic probing parameters are valid".to_string()
   94|       |            } else {
   95|      4|                issues.join("; ")
   96|       |            };
   97|       |
   98|      7|            (is_valid, message)
   99|      7|        }
  100|       |
  101|       |        /// Compute greatest common divisor
  102|       |        /// Claude Work: O(log min(a,b)), Span: O(log min(a,b))
  103|     13|        fn gcd(a: N, b: N) -> N {
  104|     13|            if b == 0 {
  105|      5|                a
  106|       |            } else {
  107|      8|                Self::gcd(b, a % b)
  108|       |            }
  109|     13|        }
  110|       |    }
  111|       |
  112|       |    impl<K: StT, H: HashFunClone<K>> AdvancedQuadraticProbingStrategy<K, H> {
  113|       |        /// Create new advanced quadratic probing strategy with default coefficients
  114|       |        /// Uses c1=1, c2=1 which work well with prime table sizes
  115|       |        /// Claude Work: (1), Span: (1)
  116|     25|        pub fn new(hash_fn: H) -> Self {
  117|     25|            AdvancedQuadraticProbingStrategy {
  118|     25|                base_hash: hash_fn,
  119|     25|                c1: 1,
  120|     25|                c2: 1,
  121|     25|                clustering_enabled: true,
  122|     25|                prime_validation_enabled: true,
  123|     25|                _phantom: std::marker::PhantomData,
  124|     25|            }
  125|     25|        }
  126|       |
  127|       |        /// Create strategy with custom coefficients
  128|       |        /// Claude Work: (1), Span: (1)
  129|     42|        pub fn new_with_coefficients(hash_fn: H, c1: N, c2: N) -> Self {
  130|     42|            AdvancedQuadraticProbingStrategy {
  131|     42|                base_hash: hash_fn,
  132|     42|                c1,
  133|     42|                c2,
  134|     42|                clustering_enabled: true,
  135|     42|                prime_validation_enabled: true,
  136|     42|                _phantom: std::marker::PhantomData,
  137|     42|            }
  138|     42|        }
  139|       |
  140|       |        /// Create strategy with all features disabled (for performance comparison)
  141|       |        /// Claude Work: (1), Span: (1)
  142|      4|        pub fn new_minimal(hash_fn: H, c1: N, c2: N) -> Self {
  143|      4|            AdvancedQuadraticProbingStrategy {
  144|      4|                base_hash: hash_fn,
  145|      4|                c1,
  146|      4|                c2,
  147|      4|                clustering_enabled: false,
  148|      4|                prime_validation_enabled: false,
  149|      4|                _phantom: std::marker::PhantomData,
  150|      4|            }
  151|      4|        }
  152|       |
  153|       |        /// Analyze secondary clustering in a hash table
  154|       |        /// Claude Work: (m), Span: (m) where m is table size
  155|     21|        pub fn analyze_secondary_clustering<V: StT>(
  156|     21|            &self,
  157|     21|            table: &FlatHashTable<K, V, Self>,
  158|     21|        ) -> SecondaryClusteringMetrics
  159|     21|        where
  160|     21|            Self: ProbeSequence<K> + Clone,
  161|       |        {
  162|     21|            if !self.clustering_enabled {
  163|      1|                return SecondaryClusteringMetrics {
  164|      1|                    collision_chains: 0,
  165|      1|                    max_chain_length: 0,
  166|      1|                    avg_chain_length: 0.0,
  167|      1|                    secondary_clustering_coefficient: 0.0,
  168|      1|                    probe_sequence_diversity: 0.0,
  169|      1|                    table_size_is_prime: false,
  170|      1|                };
  171|     20|            }
  172|       |
  173|     20|            let (load, size) = table.load_and_size();
  174|     20|            if size == 0 {
  175|      0|                return SecondaryClusteringMetrics {
  176|      0|                    collision_chains: 0,
  177|      0|                    max_chain_length: 0,
  178|      0|                    avg_chain_length: 0.0,
  179|      0|                    secondary_clustering_coefficient: 0.0,
  180|      0|                    probe_sequence_diversity: 0.0,
  181|      0|                    table_size_is_prime: false,
  182|      0|                };
  183|     20|            }
  184|       |
  185|     20|            let table_size_is_prime = PrimeValidator::is_prime(size);
  186|       |
  187|       |            // Analyze collision chains by tracking probe sequences
  188|       |            let collision_chains;
  189|     20|            let mut probe_sequences = std::collections::HashSet::new();
  190|       |
  191|       |            // Simulate probe sequences for different keys to measure diversity
  192|    301|            for i in 0..size.min(100) {
                                      ^20  ^20
  193|       |                // Sample up to 100 positions
  194|    301|                let mut sequence = Vec::new();
  195|  3.28k|                for probe_idx in 0..size {
                                                  ^301
  196|  3.28k|                    let pos = (i + self.c1 * probe_idx + self.c2 * probe_idx * probe_idx) % size;
  197|  3.28k|                    sequence.push(pos);
  198|  3.28k|                    if sequence.len() > 10 {
  199|       |                        // Limit sequence length for analysis
  200|    293|                        break;
  201|  2.99k|                    }
  202|       |                }
  203|    301|                probe_sequences.insert(sequence);
  204|       |            }
  205|       |
  206|       |            // Estimate collision chains based on load factor and probe diversity
  207|     20|            collision_chains = (load as f64 * 0.7) as N; // Heuristic estimate
  208|     20|            let max_chain_length = if collision_chains > 0 {
  209|      2|                load / collision_chains.max(1)
  210|       |            } else {
  211|     18|                0
  212|       |            };
  213|     20|            let avg_chain_length = if collision_chains > 0 {
  214|      2|                load as f64 / collision_chains as f64
  215|       |            } else {
  216|     18|                0.0
  217|       |            };
  218|       |
  219|       |            // Secondary clustering coefficient: how much probe sequences overlap
  220|     20|            let expected_diversity = size.min(100) as f64;
  221|     20|            let actual_diversity = probe_sequences.len() as f64;
  222|     20|            let probe_sequence_diversity = if expected_diversity > 0.0 {
  223|     20|                actual_diversity / expected_diversity
  224|       |            } else {
  225|      0|                0.0
  226|       |            };
  227|       |
  228|       |            // Secondary clustering coefficient based on probe sequence similarity
  229|     20|            let secondary_clustering_coefficient = 1.0 - probe_sequence_diversity;
  230|       |
  231|     20|            SecondaryClusteringMetrics {
  232|     20|                collision_chains,
  233|     20|                max_chain_length,
  234|     20|                avg_chain_length,
  235|     20|                secondary_clustering_coefficient,
  236|     20|                probe_sequence_diversity,
  237|     20|                table_size_is_prime,
  238|     20|            }
  239|     21|        }
  240|       |
  241|       |        /// Validate table size and coefficients for optimal quadratic probing
  242|       |        /// Claude Work: (m), Span: (m)
  243|      4|        pub fn validate_configuration(&self, table_size: N) -> (B, String) {
  244|      4|            if !self.prime_validation_enabled {
  245|      1|                return (true, "Validation disabled".to_string());
  246|      3|            }
  247|       |
  248|      3|            PrimeValidator::validate_quadratic_params(table_size, self.c1, self.c2)
  249|      4|        }
  250|       |
  251|       |        /// Recommend optimal table size for given capacity
  252|       |        /// Claude Work: O(n log log n), Span: O(n log log n)
  253|      3|        pub fn recommend_table_size(&self, capacity: N) -> N {
  254|      3|            if !self.prime_validation_enabled {
  255|      1|                return capacity * 2; // Simple doubling
  256|      2|            }
  257|       |
  258|       |            // Recommend next prime that's at least 2x capacity for good load factor
  259|      2|            let min_size = capacity * 2;
  260|      2|            PrimeValidator::next_prime(min_size)
  261|      3|        }
  262|       |
  263|       |        /// Estimate expected probe count for quadratic probing
  264|       |        /// Based on theoretical analysis for prime table sizes
  265|       |        /// Claude Work: (1), Span: (1)
  266|     46|        pub fn estimate_probe_count(&self, load_factor: f64, is_successful: B) -> f64 {
  267|     46|            if load_factor >= 1.0 {
  268|      2|                return f64::INFINITY;
  269|     44|            }
  270|       |
  271|     44|            if is_successful {
  272|       |                // Successful search: approximately 1 - ln(1-)/
  273|     22|                if load_factor > 0.0 {
  274|      7|                    1.0 - (1.0 - load_factor).ln() / load_factor
  275|       |                } else {
  276|     15|                    1.0
  277|       |                }
  278|       |            } else {
  279|       |                // Unsuccessful search: approximately 1/(1-)
  280|     22|                1.0 / (1.0 - load_factor)
  281|       |            }
  282|     46|        }
  283|       |
  284|       |        /// Check if secondary clustering is problematic
  285|       |        /// Claude Work: (1), Span: (1)
  286|      3|        pub fn is_secondary_clustering_problematic(&self, metrics: &SecondaryClusteringMetrics) -> B {
  287|      3|            metrics.secondary_clustering_coefficient > 0.5 || !metrics.table_size_is_prime
                                                                            ^2
  288|      3|        }
  289|       |
  290|       |        /// Get coefficients for debugging
  291|       |        /// Claude Work: (1), Span: (1)
  292|      2|        pub fn get_coefficients(&self) -> (N, N) { (self.c1, self.c2) }
  293|       |    }
  294|       |
  295|       |    impl<K: StT, H: HashFunClone<K>> ProbeSequence<K> for AdvancedQuadraticProbingStrategy<K, H> {
  296|       |        /// Quadratic probing: h_i(k) = (h(k) + c1*i + c2*i^2) mod m
  297|       |        /// Claude Work: (1), Span: (1)
  298|    450|        fn probe_hash(&self, key: &K, probe_index: N, table_size: N) -> N {
  299|    450|            let base_hash = self.base_hash.hash(key, table_size);
  300|    450|            let quadratic_offset = self.c1 * probe_index + self.c2 * probe_index * probe_index;
  301|    450|            (base_hash + quadratic_offset) % table_size
  302|    450|        }
  303|       |
  304|       |        /// Strategy name for debugging and analysis
  305|       |        /// Claude Work: (1), Span: (1)
  306|      2|        fn strategy_name(&self) -> String { format!("AdvancedQuadraticProbing(c1={}, c2={})", self.c1, self.c2) }
  307|       |    }
  308|       |
  309|       |    impl<K: StT, H: HashFunClone<K>> Display for AdvancedQuadraticProbingStrategy<K, H> {
  310|      4|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  311|      4|            write!(
  312|      4|                f,
  313|      4|                "AdvancedQuadraticProbing(c1={}, c2={}, clustering_enabled={}, prime_validation={})",
  314|       |                self.c1, self.c2, self.clustering_enabled, self.prime_validation_enabled
  315|       |            )
  316|      4|        }
  317|       |    }
  318|       |
  319|       |    impl Display for SecondaryClusteringMetrics {
  320|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  321|      1|            writeln!(f, "Secondary Clustering Metrics:")?;
                                                                      ^0
  322|      1|            writeln!(f, "  Collision chains: {}", self.collision_chains)?;
                                                                                      ^0
  323|      1|            writeln!(f, "  Max chain length: {}", self.max_chain_length)?;
                                                                                      ^0
  324|      1|            writeln!(f, "  Avg chain length: {:.2}", self.avg_chain_length)?;
                                                                                         ^0
  325|      1|            writeln!(
  326|      1|                f,
  327|      1|                "  Secondary clustering coefficient: {:.3}",
  328|       |                self.secondary_clustering_coefficient
  329|      0|            )?;
  330|      1|            writeln!(f, "  Probe sequence diversity: {:.3}", self.probe_sequence_diversity)?;
                                                                                                         ^0
  331|      1|            write!(f, "  Table size is prime: {}", self.table_size_is_prime)
  332|      1|        }
  333|       |    }
  334|       |
  335|       |    /// Textbook Example: Secondary Clustering Analysis with Prime Table Size
  336|       |    /// Demonstrates quadratic probing with m=17 (prime), c1=1, c2=1
  337|       |    /// Claude Work: (m), Span: (m)
  338|      1|    pub fn example_secondary_clustering_analysis() -> (SecondaryClusteringMetrics, f64, f64, (B, String)) {
  339|      1|        let hash_fn = DefaultHashFunction;
  340|      1|        let strategy: AdvancedQuadraticProbingStrategy<String, DefaultHashFunction> =
  341|      1|            AdvancedQuadraticProbingStrategy::new_with_coefficients(hash_fn, 1, 1);
  342|       |
  343|       |        // Create a table with prime size 17
  344|      1|        let table: FlatHashTable<String, String, AdvancedQuadraticProbingStrategy<String, DefaultHashFunction>> =
  345|      1|            FlatHashTable::create_table(strategy.clone(), 17);
  346|       |
  347|       |        // Analyze secondary clustering
  348|      1|        let metrics = strategy.analyze_secondary_clustering(&table);
  349|       |
  350|       |        // Estimate probe counts for 50% load factor
  351|      1|        let successful_probes = strategy.estimate_probe_count(0.5, true);
  352|      1|        let unsuccessful_probes = strategy.estimate_probe_count(0.5, false);
  353|       |
  354|       |        // Validate configuration
  355|      1|        let validation = strategy.validate_configuration(17);
  356|       |
  357|      1|        (metrics, successful_probes, unsuccessful_probes, validation)
  358|      1|    }
  359|       |
  360|       |    /// Example demonstrating the importance of prime table sizes
  361|       |    /// Claude Work: (m), Span: (m)
  362|      1|    pub fn example_prime_vs_composite_table_size() -> (SecondaryClusteringMetrics, SecondaryClusteringMetrics) {
  363|      1|        let hash_fn = DefaultHashFunction;
  364|       |
  365|       |        // Strategy with prime table size (17)
  366|      1|        let strategy_prime: AdvancedQuadraticProbingStrategy<String, DefaultHashFunction> =
  367|      1|            AdvancedQuadraticProbingStrategy::new_with_coefficients(hash_fn.clone(), 1, 1);
  368|      1|        let table_prime: FlatHashTable<String, String, AdvancedQuadraticProbingStrategy<String, DefaultHashFunction>> =
  369|      1|            FlatHashTable::create_table(strategy_prime.clone(), 17);
  370|      1|        let metrics_prime = strategy_prime.analyze_secondary_clustering(&table_prime);
  371|       |
  372|       |        // Strategy with composite table size (16)
  373|      1|        let strategy_composite: AdvancedQuadraticProbingStrategy<String, DefaultHashFunction> =
  374|      1|            AdvancedQuadraticProbingStrategy::new_with_coefficients(hash_fn, 1, 1);
  375|      1|        let table_composite: FlatHashTable<
  376|      1|            String,
  377|      1|            String,
  378|      1|            AdvancedQuadraticProbingStrategy<String, DefaultHashFunction>,
  379|      1|        > = FlatHashTable::create_table(strategy_composite.clone(), 16);
  380|      1|        let metrics_composite = strategy_composite.analyze_secondary_clustering(&table_composite);
  381|       |
  382|      1|        (metrics_prime, metrics_composite)
  383|      1|    }
  384|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap47/ClusteringAnalysis.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 47: Clustering Analysis for Hash Table Probing Strategies
    3|       |//! Comprehensive analysis of primary and secondary clustering phenomena
    4|       |
    5|       |pub mod ClusteringAnalysis {
    6|       |
    7|       |use std::collections::HashMap;
    8|       |use std::fmt::{Debug, Display};
    9|       |
   10|       |use crate::Types::Types::*;
   11|       |use crate::Chap47::AdvancedDoubleHashing::AdvancedDoubleHashing::*;
   12|       |use crate::Chap47::AdvancedLinearProbing::AdvancedLinearProbing::*;
   13|       |use crate::Chap47::AdvancedQuadraticProbing::AdvancedQuadraticProbing::*;
   14|       |use crate::Chap47::FlatHashTable::FlatHashTable::*;
   15|       |use crate::Chap47::HashFunctionTraits::HashFunctionTraits::*;
   16|       |    #[derive(Clone, Debug, PartialEq)]
   17|       |    pub struct ComprehensiveClusteringAnalysis {
   18|       |        pub strategy_name: String,
   19|       |        pub table_size: N,
   20|       |        pub load_factor: f64,
   21|       |        pub primary_clustering: Option<PrimaryClusteringMetrics>,
   22|       |        pub secondary_clustering: Option<SecondaryClusteringMetrics>,
   23|       |        pub double_hashing_quality: Option<DoubleHashingMetrics>,
   24|       |        pub overall_clustering_score: f64,
   25|       |        pub performance_impact: ClusteringPerformanceImpact,
   26|       |    }
   27|       |
   28|       |    /// Performance Impact Assessment
   29|       |    /// Claude Work: (1), Span: (1)
   30|       |    #[derive(Clone, Debug, PartialEq)]
   31|       |    pub struct ClusteringPerformanceImpact {
   32|       |        pub expected_successful_probes: f64,
   33|       |        pub expected_unsuccessful_probes: f64,
   34|       |        pub clustering_severity: ClusteringSeverity,
   35|       |        pub recommended_action: String,
   36|       |    }
   37|       |
   38|       |    /// Clustering Severity Classification
   39|       |    /// Claude Work: (1), Span: (1)
   40|       |    #[derive(Clone, Debug, PartialEq)]
   41|       |    pub enum ClusteringSeverity {
   42|       |        Minimal,  // < 10% performance degradation
   43|       |        Moderate, // 10-30% performance degradation
   44|       |        Severe,   // 30-50% performance degradation
   45|       |        Critical, // > 50% performance degradation
   46|       |    }
   47|       |
   48|       |    /// Clustering Comparison Results
   49|       |    /// Claude Work: (1), Span: (1)
   50|       |    #[derive(Clone, Debug)]
   51|       |    pub struct ClusteringComparison {
   52|       |        pub linear_probing: ComprehensiveClusteringAnalysis,
   53|       |        pub quadratic_probing: ComprehensiveClusteringAnalysis,
   54|       |        pub double_hashing: ComprehensiveClusteringAnalysis,
   55|       |        pub best_strategy: String,
   56|       |        pub worst_strategy: String,
   57|       |        pub performance_ranking: Vec<(String, f64)>,
   58|       |    }
   59|       |
   60|       |    /// Clustering Analysis Engine
   61|       |    /// Claude Work: (1), Span: (1)
   62|       |    #[derive(Clone, Debug)]
   63|       |    pub struct ClusteringAnalyzer {
   64|       |        pub analysis_enabled: B,
   65|       |        pub detailed_metrics: B,
   66|       |    }
   67|       |
   68|       |    impl ClusteringAnalyzer {
   69|       |        /// Create new clustering analyzer
   70|       |        /// Claude Work: (1), Span: (1)
   71|     13|        pub fn new() -> Self {
   72|     13|            ClusteringAnalyzer {
   73|     13|                analysis_enabled: true,
   74|     13|                detailed_metrics: true,
   75|     13|            }
   76|     13|        }
   77|       |
   78|       |        /// Create minimal analyzer for performance testing
   79|       |        /// Claude Work: (1), Span: (1)
   80|      2|        pub fn new_minimal() -> Self {
   81|      2|            ClusteringAnalyzer {
   82|      2|                analysis_enabled: false,
   83|      2|                detailed_metrics: false,
   84|      2|            }
   85|      2|        }
   86|       |
   87|       |        /// Analyze linear probing clustering
   88|       |        /// Claude Work: (m), Span: (m) where m is table size
   89|     20|        pub fn analyze_linear_probing<K: StT, H: HashFunClone<K>>(
   90|     20|            &self,
   91|     20|            strategy: &AdvancedLinearProbingStrategy<K, H>,
   92|     20|            table: &FlatHashTable<K, String, AdvancedLinearProbingStrategy<K, H>>,
   93|     20|        ) -> ComprehensiveClusteringAnalysis
   94|     20|        where
   95|     20|            AdvancedLinearProbingStrategy<K, H>: ProbeSequence<K> + Clone,
   96|       |        {
   97|     20|            if !self.analysis_enabled {
   98|      1|                return self.create_empty_analysis("LinearProbing".to_string(), 0, 0.0);
   99|     19|            }
  100|       |
  101|     19|            let (load, size) = table.load_and_size();
  102|     19|            let load_factor = if size > 0 { load as f64 / size as f64 } else { 0.0 };
                                                                                             ^0
  103|       |
  104|     19|            let primary_clustering = if self.detailed_metrics {
  105|     19|                Some(strategy.analyze_primary_clustering(table))
  106|       |            } else {
  107|      0|                None
  108|       |            };
  109|       |
  110|     19|            let successful_probes = strategy.estimate_successful_probe_count(load_factor);
  111|     19|            let unsuccessful_probes = strategy.estimate_unsuccessful_probe_count(load_factor);
  112|       |
  113|     19|            let clustering_score = self.calculate_linear_clustering_score(&primary_clustering, load_factor);
  114|     19|            let performance_impact =
  115|     19|                self.assess_performance_impact(successful_probes, unsuccessful_probes, clustering_score);
  116|       |
  117|     19|            ComprehensiveClusteringAnalysis {
  118|     19|                strategy_name: "AdvancedLinearProbing".to_string(),
  119|     19|                table_size: size,
  120|     19|                load_factor,
  121|     19|                primary_clustering,
  122|     19|                secondary_clustering: None,
  123|     19|                double_hashing_quality: None,
  124|     19|                overall_clustering_score: clustering_score,
  125|     19|                performance_impact,
  126|     19|            }
  127|     20|        }
  128|       |
  129|       |        /// Analyze quadratic probing clustering
  130|       |        /// Claude Work: (m), Span: (m) where m is table size
  131|     16|        pub fn analyze_quadratic_probing<K: StT, H: HashFunClone<K>>(
  132|     16|            &self,
  133|     16|            strategy: &AdvancedQuadraticProbingStrategy<K, H>,
  134|     16|            table: &FlatHashTable<K, String, AdvancedQuadraticProbingStrategy<K, H>>,
  135|     16|        ) -> ComprehensiveClusteringAnalysis
  136|     16|        where
  137|     16|            AdvancedQuadraticProbingStrategy<K, H>: ProbeSequence<K> + Clone,
  138|       |        {
  139|     16|            if !self.analysis_enabled {
  140|      0|                return self.create_empty_analysis("QuadraticProbing".to_string(), 0, 0.0);
  141|     16|            }
  142|       |
  143|     16|            let (load, size) = table.load_and_size();
  144|     16|            let load_factor = if size > 0 { load as f64 / size as f64 } else { 0.0 };
                                                                                             ^0
  145|       |
  146|     16|            let secondary_clustering = if self.detailed_metrics {
  147|     16|                Some(strategy.analyze_secondary_clustering(table))
  148|       |            } else {
  149|      0|                None
  150|       |            };
  151|       |
  152|     16|            let successful_probes = strategy.estimate_probe_count(load_factor, true);
  153|     16|            let unsuccessful_probes = strategy.estimate_probe_count(load_factor, false);
  154|       |
  155|     16|            let clustering_score = self.calculate_quadratic_clustering_score(&secondary_clustering, load_factor);
  156|     16|            let performance_impact =
  157|     16|                self.assess_performance_impact(successful_probes, unsuccessful_probes, clustering_score);
  158|       |
  159|     16|            ComprehensiveClusteringAnalysis {
  160|     16|                strategy_name: "AdvancedQuadraticProbing".to_string(),
  161|     16|                table_size: size,
  162|     16|                load_factor,
  163|     16|                primary_clustering: None,
  164|     16|                secondary_clustering,
  165|     16|                double_hashing_quality: None,
  166|     16|                overall_clustering_score: clustering_score,
  167|     16|                performance_impact,
  168|     16|            }
  169|     16|        }
  170|       |
  171|       |        /// Analyze double hashing quality
  172|       |        /// Claude Work: (m), Span: (m) where m is table size
  173|     16|        pub fn analyze_double_hashing<K: StT, H1: HashFunClone<K>, H2: HashFunClone<K>>(
  174|     16|            &self,
  175|     16|            strategy: &AdvancedDoubleHashingStrategy<K, H1, H2>,
  176|     16|            key: &K,
  177|     16|            table_size: N,
  178|     16|            load_factor: f64,
  179|     16|        ) -> ComprehensiveClusteringAnalysis {
  180|     16|            if !self.analysis_enabled {
  181|      0|                return self.create_empty_analysis("DoubleHashing".to_string(), table_size, load_factor);
  182|     16|            }
  183|       |
  184|     16|            let double_hashing_quality = if self.detailed_metrics {
  185|     16|                Some(strategy.analyze_double_hashing_quality(key, table_size))
  186|       |            } else {
  187|      0|                None
  188|       |            };
  189|       |
  190|     16|            let successful_probes = strategy.estimate_probe_count(load_factor, true);
  191|     16|            let unsuccessful_probes = strategy.estimate_probe_count(load_factor, false);
  192|       |
  193|     16|            let clustering_score = self.calculate_double_hashing_score(&double_hashing_quality, load_factor);
  194|     16|            let performance_impact =
  195|     16|                self.assess_performance_impact(successful_probes, unsuccessful_probes, clustering_score);
  196|       |
  197|     16|            ComprehensiveClusteringAnalysis {
  198|     16|                strategy_name: "AdvancedDoubleHashing".to_string(),
  199|     16|                table_size,
  200|     16|                load_factor,
  201|     16|                primary_clustering: None,
  202|     16|                secondary_clustering: None,
  203|     16|                double_hashing_quality,
  204|     16|                overall_clustering_score: clustering_score,
  205|     16|                performance_impact,
  206|     16|            }
  207|     16|        }
  208|       |
  209|       |        /// Compare all three probing strategies
  210|       |        /// Claude Work: (m), Span: (m) where m is table size
  211|     14|        pub fn compare_probing_strategies(&self, table_size: N, load_factor: f64) -> ClusteringComparison {
  212|       |            // Create test key for analysis
  213|     14|            let test_key = "clustering_test_key".to_string();
  214|       |
  215|       |            // Analyze linear probing
  216|     14|            let linear_strategy: AdvancedLinearProbingStrategy<String, DefaultHashFunction> =
  217|     14|                AdvancedLinearProbingStrategy::new(DefaultHashFunction);
  218|     14|            let linear_table: FlatHashTable<
  219|     14|                String,
  220|     14|                String,
  221|     14|                AdvancedLinearProbingStrategy<String, DefaultHashFunction>,
  222|     14|            > = FlatHashTable::create_table(linear_strategy.clone(), table_size);
  223|     14|            let linear_analysis = self.analyze_linear_probing(&linear_strategy, &linear_table);
  224|       |
  225|       |            // Analyze quadratic probing
  226|     14|            let quadratic_strategy: AdvancedQuadraticProbingStrategy<String, DefaultHashFunction> =
  227|     14|                AdvancedQuadraticProbingStrategy::new(DefaultHashFunction);
  228|     14|            let quadratic_table: FlatHashTable<
  229|     14|                String,
  230|     14|                String,
  231|     14|                AdvancedQuadraticProbingStrategy<String, DefaultHashFunction>,
  232|     14|            > = FlatHashTable::create_table(quadratic_strategy.clone(), table_size);
  233|     14|            let quadratic_analysis = self.analyze_quadratic_probing(&quadratic_strategy, &quadratic_table);
  234|       |
  235|       |            // Analyze double hashing
  236|     14|            let double_strategy: AdvancedDoubleHashingStrategy<String, DefaultHashFunction, DefaultHashFunction> =
  237|     14|                AdvancedDoubleHashingStrategy::new(DefaultHashFunction, DefaultHashFunction);
  238|     14|            let double_analysis = self.analyze_double_hashing(&double_strategy, &test_key, table_size, load_factor);
  239|       |
  240|       |            // Rank strategies by performance
  241|     14|            let mut performance_ranking = vec![
  242|     14|                ("LinearProbing".to_string(), linear_analysis.overall_clustering_score),
  243|     14|                (
  244|     14|                    "QuadraticProbing".to_string(),
  245|     14|                    quadratic_analysis.overall_clustering_score,
  246|     14|                ),
  247|     14|                ("DoubleHashing".to_string(), double_analysis.overall_clustering_score),
  248|       |            ];
  249|       |
  250|       |            // Sort by clustering score (lower is better)
  251|     32|            performance_ranking.sort_by(|a, b| a.1.partial_cmp(&b.1).unwrap_or(std::cmp::Ordering::Equal));
                          ^14                 ^14
  252|       |
  253|     14|            let best_strategy = performance_ranking[0].0.clone();
  254|     14|            let worst_strategy = performance_ranking[2].0.clone();
  255|       |
  256|     14|            ClusteringComparison {
  257|     14|                linear_probing: linear_analysis,
  258|     14|                quadratic_probing: quadratic_analysis,
  259|     14|                double_hashing: double_analysis,
  260|     14|                best_strategy,
  261|     14|                worst_strategy,
  262|     14|                performance_ranking,
  263|     14|            }
  264|     14|        }
  265|       |
  266|       |        /// Calculate clustering score for linear probing
  267|       |        /// Claude Work: (1), Span: (1)
  268|     19|        fn calculate_linear_clustering_score(
  269|     19|            &self,
  270|     19|            metrics: &Option<PrimaryClusteringMetrics>,
  271|     19|            load_factor: f64,
  272|     19|        ) -> f64 {
  273|     19|            if let Some(m) = metrics {
  274|       |                // Higher clustering coefficient and variance indicate worse clustering
  275|     19|                let base_score = load_factor * 100.0; // Base score from load factor
  276|     19|                let clustering_penalty = m.clustering_coefficient * 50.0;
  277|     19|                let variance_penalty = m.probe_variance.sqrt() * 10.0;
  278|     19|                base_score + clustering_penalty + variance_penalty
  279|       |            } else {
  280|      0|                load_factor * 100.0 // Simple load factor based score
  281|       |            }
  282|     19|        }
  283|       |
  284|       |        /// Calculate clustering score for quadratic probing
  285|       |        /// Claude Work: (1), Span: (1)
  286|     16|        fn calculate_quadratic_clustering_score(
  287|     16|            &self,
  288|     16|            metrics: &Option<SecondaryClusteringMetrics>,
  289|     16|            load_factor: f64,
  290|     16|        ) -> f64 {
  291|     16|            if let Some(m) = metrics {
  292|     16|                let base_score = load_factor * 80.0; // Quadratic probing generally better than linear
  293|     16|                let secondary_penalty = m.secondary_clustering_coefficient * 30.0;
  294|     16|                let prime_bonus = if m.table_size_is_prime { -10.0 } else { 20.0 };
                                                                           ^14            ^2
  295|     16|                let diversity_bonus = (1.0 - m.probe_sequence_diversity) * 15.0;
  296|     16|                base_score + secondary_penalty + prime_bonus + diversity_bonus
  297|       |            } else {
  298|      0|                load_factor * 80.0
  299|       |            }
  300|     16|        }
  301|       |
  302|       |        /// Calculate clustering score for double hashing
  303|       |        /// Claude Work: (1), Span: (1)
  304|     16|        fn calculate_double_hashing_score(&self, metrics: &Option<DoubleHashingMetrics>, load_factor: f64) -> f64 {
  305|     16|            if let Some(m) = metrics {
  306|     16|                let base_score = load_factor * 60.0; // Double hashing generally best
  307|     16|                let independence_bonus = m.hash_function_independence * -20.0;
  308|     16|                let prime_bonus = if m.relative_prime_validation { -15.0 } else { 25.0 };
                                                                                                ^0
  309|     16|                let collision_bonus = m.collision_avoidance_score * -10.0;
  310|     16|                base_score + independence_bonus + prime_bonus + collision_bonus
  311|       |            } else {
  312|      0|                load_factor * 60.0
  313|       |            }
  314|     16|        }
  315|       |
  316|       |        /// Assess performance impact based on probe counts and clustering score
  317|       |        /// Claude Work: (1), Span: (1)
  318|     51|        fn assess_performance_impact(
  319|     51|            &self,
  320|     51|            successful_probes: f64,
  321|     51|            unsuccessful_probes: f64,
  322|     51|            clustering_score: f64,
  323|     51|        ) -> ClusteringPerformanceImpact {
  324|     51|            let severity = if clustering_score < 50.0 {
  325|     47|                ClusteringSeverity::Minimal
  326|      4|            } else if clustering_score < 100.0 {
  327|      0|                ClusteringSeverity::Moderate
  328|      4|            } else if clustering_score < 150.0 {
  329|      0|                ClusteringSeverity::Severe
  330|       |            } else {
  331|      4|                ClusteringSeverity::Critical
  332|       |            };
  333|       |
  334|     51|            let recommended_action = match severity {
  335|     47|                | ClusteringSeverity::Minimal => "Current configuration is optimal".to_string(),
  336|       |                | ClusteringSeverity::Moderate => {
  337|      0|                    "Consider reducing load factor or switching to quadratic probing".to_string()
  338|       |                }
  339|      0|                | ClusteringSeverity::Severe => "Switch to double hashing or resize table".to_string(),
  340|       |                | ClusteringSeverity::Critical => {
  341|      4|                    "Immediate action required: resize table and use double hashing".to_string()
  342|       |                }
  343|       |            };
  344|       |
  345|     51|            ClusteringPerformanceImpact {
  346|     51|                expected_successful_probes: successful_probes,
  347|     51|                expected_unsuccessful_probes: unsuccessful_probes,
  348|     51|                clustering_severity: severity,
  349|     51|                recommended_action,
  350|     51|            }
  351|     51|        }
  352|       |
  353|       |        /// Create empty analysis for disabled analyzer
  354|       |        /// Claude Work: (1), Span: (1)
  355|      1|        fn create_empty_analysis(
  356|      1|            &self,
  357|      1|            strategy_name: String,
  358|      1|            table_size: N,
  359|      1|            load_factor: f64,
  360|      1|        ) -> ComprehensiveClusteringAnalysis {
  361|      1|            ComprehensiveClusteringAnalysis {
  362|      1|                strategy_name,
  363|      1|                table_size,
  364|      1|                load_factor,
  365|      1|                primary_clustering: None,
  366|      1|                secondary_clustering: None,
  367|      1|                double_hashing_quality: None,
  368|      1|                overall_clustering_score: 0.0,
  369|      1|                performance_impact: ClusteringPerformanceImpact {
  370|      1|                    expected_successful_probes: 1.0,
  371|      1|                    expected_unsuccessful_probes: 1.0,
  372|      1|                    clustering_severity: ClusteringSeverity::Minimal,
  373|      1|                    recommended_action: "Analysis disabled".to_string(),
  374|      1|                },
  375|      1|            }
  376|      1|        }
  377|       |    }
  378|       |
  379|       |    impl Display for ComprehensiveClusteringAnalysis {
  380|      0|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  381|      0|            writeln!(f, "=== Comprehensive Clustering Analysis ===")?;
  382|      0|            writeln!(f, "Strategy: {}", self.strategy_name)?;
  383|      0|            writeln!(
  384|      0|                f,
  385|      0|                "Table size: {}, Load factor: {:.3}",
  386|       |                self.table_size, self.load_factor
  387|      0|            )?;
  388|      0|            writeln!(f, "Overall clustering score: {:.2}", self.overall_clustering_score)?;
  389|      0|            writeln!(f)?;
  390|       |
  391|      0|            if let Some(ref primary) = self.primary_clustering {
  392|      0|                writeln!(f, "{}", primary)?;
  393|      0|                writeln!(f)?;
  394|      0|            }
  395|       |
  396|      0|            if let Some(ref secondary) = self.secondary_clustering {
  397|      0|                writeln!(f, "{}", secondary)?;
  398|      0|                writeln!(f)?;
  399|      0|            }
  400|       |
  401|      0|            if let Some(ref double) = self.double_hashing_quality {
  402|      0|                writeln!(f, "{}", double)?;
  403|      0|                writeln!(f)?;
  404|      0|            }
  405|       |
  406|      0|            write!(f, "{}", self.performance_impact)
  407|      0|        }
  408|       |    }
  409|       |
  410|       |    impl Display for ClusteringPerformanceImpact {
  411|      0|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  412|      0|            writeln!(f, "Performance Impact Assessment:")?;
  413|      0|            writeln!(
  414|      0|                f,
  415|      0|                "  Expected successful probes: {:.2}",
  416|       |                self.expected_successful_probes
  417|      0|            )?;
  418|      0|            writeln!(
  419|      0|                f,
  420|      0|                "  Expected unsuccessful probes: {:.2}",
  421|       |                self.expected_unsuccessful_probes
  422|      0|            )?;
  423|      0|            writeln!(f, "  Clustering severity: {:?}", self.clustering_severity)?;
  424|      0|            write!(f, "  Recommended action: {}", self.recommended_action)
  425|      0|        }
  426|       |    }
  427|       |
  428|       |    impl Display for ClusteringComparison {
  429|      0|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  430|      0|            writeln!(f, "=== Probing Strategy Comparison ===")?;
  431|      0|            writeln!(f, "Best strategy: {}", self.best_strategy)?;
  432|      0|            writeln!(f, "Worst strategy: {}", self.worst_strategy)?;
  433|      0|            writeln!(f)?;
  434|      0|            writeln!(f, "Performance ranking:")?;
  435|      0|            for (i, (strategy, score)) in self.performance_ranking.iter().enumerate() {
  436|      0|                writeln!(f, "  {}. {} (score: {:.2})", i + 1, strategy, score)?;
  437|       |            }
  438|      0|            writeln!(f)?;
  439|      0|            writeln!(f, "--- Linear Probing Analysis ---")?;
  440|      0|            writeln!(f, "{}", self.linear_probing)?;
  441|      0|            writeln!(f)?;
  442|      0|            writeln!(f, "--- Quadratic Probing Analysis ---")?;
  443|      0|            writeln!(f, "{}", self.quadratic_probing)?;
  444|      0|            writeln!(f)?;
  445|      0|            writeln!(f, "--- Double Hashing Analysis ---")?;
  446|      0|            write!(f, "{}", self.double_hashing)
  447|      0|        }
  448|       |    }
  449|       |
  450|       |    /// Textbook Example: Comprehensive Clustering Analysis
  451|       |    /// Demonstrates clustering analysis across all three probing strategies
  452|       |    /// Claude Work: (m), Span: (m)
  453|      1|    pub fn example_comprehensive_clustering_analysis() -> ClusteringComparison {
  454|      1|        let analyzer = ClusteringAnalyzer::new();
  455|       |
  456|       |        // Analyze with moderate load factor and prime table size
  457|      1|        analyzer.compare_probing_strategies(17, 0.6)
  458|      1|    }
  459|       |
  460|       |    /// Example: Load Factor Impact Analysis
  461|       |    /// Shows how clustering changes with different load factors
  462|       |    /// Claude Work: (k * m), Span: (k * m) where k is number of load factors tested
  463|      1|    pub fn example_load_factor_impact_analysis() -> Vec<(f64, ClusteringComparison)> {
  464|      1|        let analyzer = ClusteringAnalyzer::new();
  465|      1|        let load_factors = vec![0.25, 0.5, 0.75, 0.9];
  466|      1|        let table_size = 17; // Prime table size
  467|       |
  468|      1|        load_factors
  469|      1|            .into_iter()
  470|      4|            .map(|lf| (lf, analyzer.compare_probing_strategies(table_size, lf)))
                           ^1
  471|      1|            .collect()
  472|      1|    }
  473|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap47/DoubleHashing.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 47: Double Hashing Strategy
    3|       |
    4|       |pub mod DoubleHashing {
    5|       |
    6|       |use crate::Types::Types::*;
    7|       |use crate::Chap47::FlatHashTable::FlatHashTable::*;
    8|       |use crate::Chap47::HashFunctionTraits::HashFunctionTraits::*;
    9|       |    #[derive(Clone, Debug)]
   10|       |    pub struct DoubleHashingStrategy<K: StT, H1: HashFunClone<K>, H2: HashFunClone<K>> {
   11|       |        hash1: H1,
   12|       |        hash2: H2,
   13|       |        _phantom: std::marker::PhantomData<K>,
   14|       |    }
   15|       |
   16|       |    impl<K: StT, H1: HashFunClone<K>, H2: HashFunClone<K>> DoubleHashingStrategy<K, H1, H2> {
   17|     23|        pub fn new(hash1: H1, hash2: H2) -> Self {
   18|     23|            DoubleHashingStrategy {
   19|     23|                hash1,
   20|     23|                hash2,
   21|     23|                _phantom: std::marker::PhantomData,
   22|     23|            }
   23|     23|        }
   24|       |    }
   25|       |
   26|       |    impl<K: StT, H1: HashFunClone<K>, H2: HashFunClone<K>> ProbeSequence<K> for DoubleHashingStrategy<K, H1, H2> {
   27|       |        /// Claude Work: (1), Span: (1)
   28|    390|        fn probe_hash(&self, key: &K, probe_index: N, table_size: N) -> N {
   29|    390|            let h1 = self.hash1.hash(key, table_size);
   30|    390|            let h2 = self.hash2.hash(key, table_size);
   31|       |
   32|       |            // Ensure h2 is not 0 (would cause infinite loop)
   33|    390|            let h2_safe = if h2 == 0 { 1 } else { h2 };
                                                     ^30        ^360
   34|       |
   35|    390|            (h1 + probe_index * h2_safe) % table_size
   36|    390|        }
   37|       |
   38|      3|        fn strategy_name(&self) -> String {
   39|      3|            format!(
   40|      3|                "DoubleHashing({}, {})",
   41|      3|                self.hash1.description(),
   42|      3|                self.hash2.description()
   43|       |            )
   44|      3|        }
   45|       |    }
   46|       |
   47|       |    /// Type alias for double hashing hash table
   48|       |    pub type DoubleHashingHashTable<K, V, H1, H2> = FlatHashTable<K, V, DoubleHashingStrategy<K, H1, H2>>;
   49|       |
   50|       |    /// Constructor functions for double hashing hash tables
   51|       |    /// APAS: Work (1), Span (1)
   52|     11|    pub fn create_double_hashing_string_table<V: StT>(
   53|     11|        initial_size: N,
   54|     11|    ) -> DoubleHashingHashTable<String, V, StringPositionHashFunction, PolynomialHashFunction> {
   55|     11|        let hash1 = StringPositionHashFunction;
   56|     11|        let hash2 = PolynomialHashFunction::new(31); // Common polynomial base
   57|     11|        let probe_strategy = DoubleHashingStrategy::new(hash1, hash2);
   58|     11|        FlatHashTable::create_table(probe_strategy, initial_size)
   59|     11|    }
   60|       |
   61|       |    /// APAS: Work (1), Span (1)
   62|      4|    pub fn create_double_hashing_integer_table<V: StT>(
   63|      4|        initial_size: N,
   64|      4|        seed1: u64,
   65|      4|        seed2: u64,
   66|      4|    ) -> DoubleHashingHashTable<i32, V, UniversalIntegerHashFunction, UniversalIntegerHashFunction> {
   67|      4|        let hash_family = UniversalIntegerHashFamily::new();
   68|      4|        let hash1 = hash_family.generate(seed1);
   69|      4|        let hash2 = hash_family.generate(seed2);
   70|      4|        let probe_strategy = DoubleHashingStrategy::new(hash1, hash2);
   71|      4|        FlatHashTable::create_table(probe_strategy, initial_size)
   72|      4|    }
   73|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap47/FlatHashTable.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 47: Flat Hash Table - Data Structure 47.6 Parametric Implementation
    3|       |
    4|       |pub mod FlatHashTable {
    5|       |
    6|       |use std::fmt::{Debug, Display};
    7|       |
    8|       |use crate::Types::Types::*;
    9|       |use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
   10|       |use crate::Chap47::HashFunctionTraits::HashFunctionTraits::*;
   11|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   12|       |    pub enum Entry<K: StT, V: StT> {
   13|       |        Empty,
   14|       |        Dead,
   15|       |        Live(K, V),
   16|       |    }
   17|       |
   18|       |    impl<K: StT, V: StT> Display for Entry<K, V> {
   19|      3|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   20|      3|            match self {
   21|      1|                | Entry::Empty => write!(f, "Empty"),
   22|      1|                | Entry::Dead => write!(f, "Dead"),
   23|      1|                | Entry::Live(key, value) => write!(f, "Live({}, {})", key, value),
   24|       |            }
   25|      3|        }
   26|       |    }
   27|       |
   28|       |    /// Trait for probe sequence generation
   29|       |    pub trait ProbeSequence<K: StT> {
   30|       |        /// claude-4-sonet: Work (1), Span (1)
   31|       |        /// Generate i-th hash value in probe sequence
   32|       |        fn probe_hash(&self, key: &K, probe_index: N, table_size: N) -> N;
   33|       |
   34|       |        /// Get description of probing strategy
   35|       |        fn strategy_name(&self) -> String;
   36|       |    }
   37|       |
   38|       |    /// Data Structure 47.6: Parametric Flat Hash Table
   39|       |    #[derive(Clone, Debug)]
   40|       |    pub struct FlatHashTable<K: StT, V: StT, P: ProbeSequence<K>> {
   41|       |        table: ArraySeqStPerS<Entry<K, V>>,
   42|       |        probe_sequence: P,
   43|       |        num_elements: N,
   44|       |        num_deleted: N,
   45|       |        load_factor_manager: LoadFactorManager,
   46|       |    }
   47|       |
   48|       |    impl<K: StT, V: StT, P: ProbeSequence<K> + Clone> FlatHashTable<K, V, P> {
   49|       |        /// Claude Work: (m), Span: (m)
   50|    126|        pub fn create_table(probe_seq: P, initial_size: N) -> Self {
   51|    126|            let size = initial_size.max(8);
   52|    126|            let mut table = ArraySeqStPerS::empty();
   53|       |
   54|  1.83k|            for _ in 0..size {
                                      ^126
   55|  1.83k|                let empty_entry = Entry::Empty;
   56|  1.83k|                let single_seq = ArraySeqStPerS::singleton(empty_entry);
   57|  1.83k|                table = ArraySeqStPerS::append(&table, &single_seq);
   58|  1.83k|            }
   59|       |
   60|    126|            FlatHashTable {
   61|    126|                table,
   62|    126|                probe_sequence: probe_seq,
   63|    126|                num_elements: 0,
   64|    126|                num_deleted: 0,
   65|    126|                load_factor_manager: LoadFactorManager::new(0.5, 0.125), // Lower load factor for open addressing
   66|    126|            }
   67|    126|        }
   68|       |
   69|       |        /// Claude Work: 1/(1-) expected, Span: 1/(1-) expected
   70|       |        /// Algorithm from Data Structure 47.6
   71|    295|        pub fn insert(&self, key: K, value: V) -> Self {
   72|    295|            let table_size = self.table.length();
   73|       |            
   74|       |            // Preemptive resize check: if inserting a new key would exceed threshold, resize first
   75|    295|            let total_occupied = self.num_elements + self.num_deleted;
   76|    295|            if self.load_factor_manager.should_grow(total_occupied + 1, table_size) {
   77|     23|                let new_size = self.load_factor_manager.grow_size(table_size);
   78|     23|                return self.resize(new_size).insert(key, value);
   79|    272|            }
   80|       |            
   81|    272|            let mut probe_index = 0;
   82|       |
   83|       |            // Find insertion position
   84|    272|            let mut insertion_pos = None;
   85|    870|            while probe_index < table_size {
   86|    870|                let hash_pos = self.probe_sequence.probe_hash(&key, probe_index, table_size);
   87|    870|                let entry = self.table.nth(hash_pos);
   88|       |
   89|    870|                match entry {
   90|       |                    | Entry::Empty => {
   91|    268|                        insertion_pos = Some(hash_pos);
   92|    268|                        break;
   93|       |                    }
   94|       |                    | Entry::Dead => {
   95|      2|                        if insertion_pos.is_none() {
   96|      2|                            insertion_pos = Some(hash_pos);
   97|      2|                        }
                                      ^0
   98|       |                    }
   99|    600|                    | Entry::Live(existing_key, _) => {
  100|    600|                        if existing_key == &key {
  101|      4|                            insertion_pos = Some(hash_pos);
  102|      4|                            break;
  103|    596|                        }
  104|       |                    }
  105|       |                }
  106|    598|                probe_index += 1;
  107|       |            }
  108|       |
  109|    272|            let pos = insertion_pos.expect("Table should have space for insertion");
  110|       |
  111|       |            // Check if key already exists
  112|    272|            let key_existed = matches!(self.table.nth(pos), Entry::Live(existing_key, _) if existing_key == &key);
                                            ^4                                        ^4                  ^4                 ^4
  113|    272|            let was_dead = matches!(self.table.nth(pos), Entry::Dead);
  114|       |
  115|       |            // Create new table with updated entry
  116|    272|            let mut new_table = ArraySeqStPerS::empty();
  117|  4.94k|            for i in 0..table_size {
                                      ^272
  118|  4.94k|                let entry_to_use = if i == pos {
  119|    272|                    Entry::Live(key.clone(), value.clone())
  120|       |                } else {
  121|  4.67k|                    self.table.nth(i).clone()
  122|       |                };
  123|  4.94k|                let single_seq = ArraySeqStPerS::singleton(entry_to_use);
  124|  4.94k|                new_table = ArraySeqStPerS::append(&new_table, &single_seq);
  125|       |            }
  126|       |
  127|    272|            let new_num_elements = if key_existed {
  128|      4|                self.num_elements
  129|       |            } else {
  130|    268|                self.num_elements + 1
  131|       |            };
  132|       |
  133|    272|            let new_num_deleted = if was_dead {
  134|      0|                self.num_deleted - 1
  135|       |            } else {
  136|    272|                self.num_deleted
  137|       |            };
  138|       |
  139|    272|            let mut result = FlatHashTable {
  140|    272|                table: new_table,
  141|    272|                probe_sequence: self.probe_sequence.clone(),
  142|    272|                num_elements: new_num_elements,
  143|    272|                num_deleted: new_num_deleted,
  144|    272|                load_factor_manager: self.load_factor_manager.clone(),
  145|    272|            };
  146|       |
  147|       |            // Check resize
  148|    272|            let total_occupied = result.num_elements + result.num_deleted;
  149|    272|            if result.load_factor_manager.should_grow(total_occupied, table_size) {
  150|      0|                let new_size = result.load_factor_manager.grow_size(table_size);
  151|      0|                result = result.resize(new_size);
  152|    272|            }
  153|       |
  154|    272|            result
  155|    295|        }
  156|       |
  157|       |        /// Claude Work: 1/(1-) expected for unsuccessful, (1/)ln(1/(1-)) expected for successful
  158|       |        /// Algorithm from Data Structure 47.6
  159|    229|        pub fn lookup(&self, key: &K) -> Option<&V> {
  160|    229|            let table_size = self.table.length();
  161|    229|            let mut probe_index = 0;
  162|       |
  163|    827|            while probe_index < table_size {
  164|    827|                let hash_pos = self.probe_sequence.probe_hash(key, probe_index, table_size);
  165|    827|                let entry = self.table.nth(hash_pos);
  166|       |
  167|    827|                match entry {
  168|     24|                    | Entry::Empty => return None,
  169|     20|                    | Entry::Dead => {
  170|     20|                        // Continue probing
  171|     20|                    }
  172|    783|                    | Entry::Live(existing_key, value) => {
  173|    783|                        if existing_key == key {
  174|    205|                            return Some(value);
  175|    578|                        }
  176|       |                    }
  177|       |                }
  178|    598|                probe_index += 1;
  179|       |            }
  180|       |
  181|      0|            None
  182|    229|        }
  183|       |
  184|       |        /// Claude Work: Similar to lookup, Span: Similar to lookup
  185|       |        /// Algorithm from Data Structure 47.6
  186|     22|        pub fn delete(&self, key: &K) -> (Self, bool) {
  187|     22|            let table_size = self.table.length();
  188|     22|            let mut probe_index = 0;
  189|       |
  190|       |            // Find key position
  191|     22|            while probe_index < table_size {
  192|     22|                let hash_pos = self.probe_sequence.probe_hash(key, probe_index, table_size);
  193|     22|                let entry = self.table.nth(hash_pos);
  194|       |
  195|     22|                match entry {
  196|      5|                    | Entry::Empty => return (self.clone(), false),
  197|      0|                    | Entry::Dead => {
  198|      0|                        // Continue probing
  199|      0|                    }
  200|     17|                    | Entry::Live(existing_key, _) => {
  201|     17|                        if existing_key == key {
  202|       |                            // Mark as dead
  203|     17|                            let mut new_table = ArraySeqStPerS::empty();
  204|    161|                            for i in 0..table_size {
                                                      ^17
  205|    161|                                let entry_to_use = if i == hash_pos {
  206|     17|                                    Entry::Dead
  207|       |                                } else {
  208|    144|                                    self.table.nth(i).clone()
  209|       |                                };
  210|    161|                                let single_seq = ArraySeqStPerS::singleton(entry_to_use);
  211|    161|                                new_table = ArraySeqStPerS::append(&new_table, &single_seq);
  212|       |                            }
  213|       |
  214|     17|                            let mut result = FlatHashTable {
  215|     17|                                table: new_table,
  216|     17|                                probe_sequence: self.probe_sequence.clone(),
  217|     17|                                num_elements: self.num_elements - 1,
  218|     17|                                num_deleted: self.num_deleted + 1,
  219|     17|                                load_factor_manager: self.load_factor_manager.clone(),
  220|     17|                            };
  221|       |
  222|       |                            // Check resize down
  223|     17|                            if result
  224|     17|                                .load_factor_manager
  225|     17|                                .should_shrink(result.num_elements, table_size)
  226|      1|                            {
  227|      1|                                let new_size = result.load_factor_manager.shrink_size(table_size);
  228|      1|                                result = result.resize(new_size);
  229|     16|                            }
  230|       |
  231|     17|                            return (result, true);
  232|      0|                        }
  233|       |                    }
  234|       |                }
  235|      0|                probe_index += 1;
  236|       |            }
  237|       |
  238|      0|            (self.clone(), false)
  239|     22|        }
  240|       |
  241|       |        /// Claude Work: (n), Span: (n)
  242|     25|        pub fn resize(&self, new_size: N) -> Self {
  243|     25|            let actual_new_size = new_size.max(8);
  244|     25|            let mut new_table = Self::create_table(self.probe_sequence.clone(), actual_new_size);
  245|       |
  246|       |            // Rehash all live entries
  247|    342|            for i in 0..self.table.length() {
                                      ^25        ^25
  248|    342|                let entry = self.table.nth(i);
  249|    342|                if let Entry::Live(key, value) = entry {
                                                 ^157 ^157
  250|    157|                    new_table = new_table.insert_without_resize(key.clone(), value.clone());
  251|    185|                }
  252|       |            }
  253|       |
  254|     25|            new_table
  255|     25|        }
  256|       |
  257|    157|        fn insert_without_resize(&self, key: K, value: V) -> Self {
  258|    157|            let table_size = self.table.length();
  259|    157|            let mut probe_index = 0;
  260|       |
  261|    157|            let mut insertion_pos = None;
  262|    523|            while probe_index < table_size {
  263|    523|                let hash_pos = self.probe_sequence.probe_hash(&key, probe_index, table_size);
  264|    523|                let entry = self.table.nth(hash_pos);
  265|       |
  266|    523|                match entry {
  267|       |                    | Entry::Empty => {
  268|    157|                        insertion_pos = Some(hash_pos);
  269|    157|                        break;
  270|       |                    }
  271|       |                    | Entry::Dead => {
  272|      0|                        if insertion_pos.is_none() {
  273|      0|                            insertion_pos = Some(hash_pos);
  274|      0|                        }
  275|       |                    }
  276|    366|                    | Entry::Live(existing_key, _) => {
  277|    366|                        if existing_key == &key {
  278|      0|                            insertion_pos = Some(hash_pos);
  279|      0|                            break;
  280|    366|                        }
  281|       |                    }
  282|       |                }
  283|    366|                probe_index += 1;
  284|       |            }
  285|       |
  286|    157|            let pos = insertion_pos.expect("Table should have space");
  287|    157|            let key_existed = matches!(self.table.nth(pos), Entry::Live(existing_key, _) if existing_key == &key);
                                            ^0                                        ^0                  ^0                 ^0
  288|    157|            let was_dead = matches!(self.table.nth(pos), Entry::Dead);
  289|       |
  290|    157|            let mut new_table = ArraySeqStPerS::empty();
  291|  5.74k|            for i in 0..table_size {
                                      ^157
  292|  5.74k|                let entry_to_use = if i == pos {
  293|    157|                    Entry::Live(key.clone(), value.clone())
  294|       |                } else {
  295|  5.59k|                    self.table.nth(i).clone()
  296|       |                };
  297|  5.74k|                let single_seq = ArraySeqStPerS::singleton(entry_to_use);
  298|  5.74k|                new_table = ArraySeqStPerS::append(&new_table, &single_seq);
  299|       |            }
  300|       |
  301|    157|            let new_num_elements = if key_existed {
  302|      0|                self.num_elements
  303|       |            } else {
  304|    157|                self.num_elements + 1
  305|       |            };
  306|       |
  307|    157|            let new_num_deleted = if was_dead {
  308|      0|                self.num_deleted - 1
  309|       |            } else {
  310|    157|                self.num_deleted
  311|       |            };
  312|       |
  313|    157|            FlatHashTable {
  314|    157|                table: new_table,
  315|    157|                probe_sequence: self.probe_sequence.clone(),
  316|    157|                num_elements: new_num_elements,
  317|    157|                num_deleted: new_num_deleted,
  318|    157|                load_factor_manager: self.load_factor_manager.clone(),
  319|    157|            }
  320|    157|        }
  321|       |
  322|    460|        pub fn load_and_size(&self) -> (N, N) { (self.num_elements, self.table.length()) }
  323|       |
  324|      5|        pub fn statistics(&self) -> HashTableStats {
  325|      5|            HashTableStats::new(self.num_elements, self.table.length()).with_collision_stats(self.num_deleted, 0, 0.0)
  326|       |            // Simplified for flat tables
  327|      5|        }
  328|       |
  329|      8|        pub fn probe_statistics(&self) -> (N, N, f64) {
  330|       |            // (live_entries, dead_entries, load_factor)
  331|      8|            let load_factor = (self.num_elements + self.num_deleted) as f64 / self.table.length() as f64;
  332|      8|            (self.num_elements, self.num_deleted, load_factor)
  333|      8|        }
  334|       |    }
  335|       |
  336|       |    impl<K: StT + Display, V: StT + Display, P: ProbeSequence<K> + Clone> Display for FlatHashTable<K, V, P> {
  337|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  338|      1|            writeln!(f, "FlatHashTable ({}) {{", self.probe_sequence.strategy_name())?;
                                                                                                   ^0
  339|      1|            writeln!(
  340|      1|                f,
  341|      1|                "  elements: {}, size: {}, deleted: {}",
  342|       |                self.num_elements,
  343|      1|                self.table.length(),
  344|       |                self.num_deleted
  345|      0|            )?;
  346|       |
  347|      8|            for i in 0..self.table.length() {
                                      ^1         ^1
  348|      8|                let entry = self.table.nth(i);
  349|      8|                match entry {
  350|      7|                    | Entry::Empty => writeln!(f, "  [{}]: Empty", i)?,
                                                                                   ^0
  351|      0|                    | Entry::Dead => writeln!(f, "  [{}]: Dead", i)?,
  352|      1|                    | Entry::Live(key, value) => writeln!(f, "  [{}]: {}  {}", i, key, value)?,
                                                                                                              ^0
  353|       |                }
  354|       |            }
  355|       |
  356|      1|            write!(f, "}}")
  357|      1|        }
  358|       |    }
  359|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap47/HashExamples.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 47: Hash Table Examples from Textbook
    3|       |
    4|       |pub mod HashExamples {
    5|       |
    6|       |use crate::Types::Types::*;
    7|       |use crate::Chap47::FlatHashTable::FlatHashTable::ProbeSequence;
    8|       |use crate::Chap47::HashFunctionTraits::HashFunctionTraits::*;
    9|       |use crate::Chap47::LinearProbing::LinearProbing::*;
   10|       |use crate::Chap47::SeparateChaining::SeparateChaining::*;
   11|       |    pub trait HashExamplesTrait {
   12|       |        /// Example 47.1: String hash function demonstration
   13|       |        /// APAS: Work (1), Span (1)
   14|       |        fn example_47_1_hash_function() -> StringPositionHashFunction;
   15|       |        
   16|       |        /// Example 47.1: Demonstrate hash function on sample strings
   17|       |        /// APAS: Work (n), Span (1)
   18|       |        fn example_47_1_demonstration() -> Vec<(String, N)>;
   19|       |        
   20|       |        /// Example 47.2: Linear probing hash table demonstration
   21|       |        /// APAS: Work (n), Span (1)
   22|       |        fn example_47_2_linear_probing();
   23|       |        
   24|       |        /// Example 47.3: Separate chaining hash table demonstration
   25|       |        /// APAS: Work (n), Span (1)
   26|       |        fn example_47_3_separate_chaining();
   27|       |        
   28|       |        /// Demonstrate various hash table operations
   29|       |        /// APAS: Work (n), Span (1)
   30|       |        fn demonstrate_hash_operations();
   31|       |    }
   32|       |
   33|       |    /// Example 47.1: String hash function demonstration
   34|      5|    pub fn example_47_1_hash_function() -> StringPositionHashFunction { StringPositionHashFunction }
   35|       |
   36|       |    /// Example 47.1: Demonstrate hash function on sample strings
   37|      2|    pub fn example_47_1_demonstration() -> Vec<(String, N)> {
   38|      2|        let hash_fn = example_47_1_hash_function();
   39|      2|        let table_size = 5;
   40|       |
   41|      2|        let test_strings = vec![
   42|      2|            "aa".to_string(),
   43|      2|            "bb".to_string(),
   44|      2|            "cc".to_string(),
   45|      2|            "dd".to_string(),
   46|      2|            "ee".to_string(),
   47|      2|            "ff".to_string(),
   48|      2|            "gg".to_string(),
   49|      2|            "hh".to_string(),
   50|      2|            "ii".to_string(),
   51|      2|            "jj".to_string(),
   52|       |        ];
   53|       |
   54|      2|        test_strings
   55|      2|            .into_iter()
   56|     20|            .map(|s| {
                           ^2
   57|     20|                let hash_value = hash_fn.hash(&s, table_size);
   58|     20|                (s, hash_value)
   59|     20|            })
   60|      2|            .collect()
   61|      2|    }
   62|       |
   63|       |    /// Example 47.2: Separate chaining demonstration
   64|      4|    pub fn example_47_2_separate_chaining() -> StringSeparateChaining<String> { create_example_47_2_table() }
   65|       |
   66|       |    /// Example 47.4: Flat table probe sequence demonstration
   67|      2|    pub fn example_47_4_probe_sequence() -> Vec<(String, Vec<N>)> {
   68|      2|        let hash_fn = StringPositionHashFunction;
   69|      2|        let table_size = 8;
   70|       |
   71|       |        // Simulate probe sequences for keys from example
   72|      2|        let keys = vec![
   73|      2|            "B".to_string(),
   74|      2|            "D".to_string(),
   75|      2|            "E".to_string(),
   76|      2|            "A".to_string(),
   77|      2|            "F".to_string(),
   78|       |        ];
   79|       |
   80|      2|        keys.into_iter()
   81|     10|            .map(|key| {
                           ^2
   82|     10|                let mut probe_sequence = Vec::new();
   83|     10|                let linear_probe = LinearProbingStrategy::new(hash_fn.clone());
   84|       |
   85|     80|                for i in 0..table_size {
                                          ^10
   86|     80|                    let hash_pos = linear_probe.probe_hash(&key, i, table_size);
   87|     80|                    probe_sequence.push(hash_pos);
   88|     80|                }
   89|       |
   90|     10|                (key, probe_sequence)
   91|     10|            })
   92|      2|            .collect()
   93|      2|    }
   94|       |
   95|       |    /// Example 47.5: Deleted entry handling demonstration
   96|      1|    pub fn example_47_5_deleted_entries() -> LinearProbingHashTable<String, String, StringPositionHashFunction> {
   97|      1|        let mut table = create_linear_probing_string_table(8);
   98|       |
   99|       |        // Insert initial entries
  100|      1|        table = table.insert("B".to_string(), "B_value".to_string());
  101|      1|        table = table.insert("D".to_string(), "D_value".to_string());
  102|      1|        table = table.insert("E".to_string(), "E_value".to_string());
  103|      1|        table = table.insert("A".to_string(), "A_value".to_string());
  104|      1|        table = table.insert("F".to_string(), "F_value".to_string());
  105|       |
  106|       |        // Delete an entry to create a "Dead" slot
  107|      1|        let (table_after_delete, _) = table.delete(&"E".to_string());
  108|       |
  109|      1|        table_after_delete
  110|      1|    }
  111|       |
  112|       |    /// Example 47.6: Insertion with collision handling
  113|      1|    pub fn example_47_6_collision_handling() -> LinearProbingHashTable<String, String, StringPositionHashFunction> {
  114|      1|        let mut table = create_linear_probing_string_table(8);
  115|       |
  116|       |        // Insert entries that will cause collisions
  117|      1|        table = table.insert("B".to_string(), "B_value".to_string());
  118|      1|        table = table.insert("E".to_string(), "E_value".to_string());
  119|      1|        table = table.insert("A".to_string(), "A_value".to_string());
  120|      1|        table = table.insert("F".to_string(), "F_value".to_string());
  121|       |
  122|       |        // Insert D which will probe through occupied slots
  123|      1|        table = table.insert("D".to_string(), "D_value".to_string());
  124|       |
  125|      1|        table
  126|      1|    }
  127|       |
  128|       |    /// Exercise 47.1: Nested table implementation using Table ADT
  129|      2|    pub fn exercise_47_1_nested_implementation() -> String {
  130|      2|        r#"
  131|      2|Exercise 47.1: Nested Hash Table Implementation
  132|      2|
  133|      2|The nested hash table can be implemented using the Table ADT as follows:
  134|      2|
  135|      2|1. Outer Table: Use an array of size m to map hash codes to inner tables
  136|      2|2. Inner Tables: Each position contains a Table ADT instance
  137|      2|3. Hash Function: Maps keys to positions [0, m-1] in the outer array
  138|      2|
  139|      2|Operations:
  140|      2|- createTable(eq_fn, hash_gen, size): Initialize array with empty Table instances
  141|      2|- insert(table, key, value): Hash key to find inner table, insert into that table
  142|      2|- lookup(table, key): Hash key to find inner table, lookup in that table
  143|      2|- resize(table, new_size): Create new table, rehash all key-value pairs
  144|      2|
  145|      2|Cost Analysis:
  146|      2|- With universal hashing, expected inner table size is O(1 + )
  147|      2|- All operations have expected cost O(1 + ) where  = n/m
  148|      2|- Resize operation costs O(n) to rehash all elements
  149|      2|
  150|      2|This implementation is demonstrated in our NestedHashTable module.
  151|      2|        "#
  152|      2|        .to_string()
  153|      2|    }
  154|       |
  155|       |    /// Exercise 47.2: Table size reduction analysis
  156|      2|    pub fn exercise_47_2_size_reduction() -> String {
  157|      2|        r#"
  158|      2|Exercise 47.2: Hash Table Size Reduction
  159|      2|
  160|      2|Yes, it makes sense to reduce hash table size under certain conditions:
  161|      2|
  162|      2|When to Reduce:
  163|      2|1. Load factor  falls below a threshold (e.g.,  < 0.25)
  164|      2|2. Table size is significantly larger than minimum needed
  165|      2|3. Memory usage optimization is important
  166|      2|
  167|      2|How to Reduce:
  168|      2|1. Create new table with size = current_size / 2
  169|      2|2. Rehash all existing elements into new table
  170|      2|3. Ensure minimum table size (e.g., never below 8)
  171|      2|
  172|      2|Benefits:
  173|      2|- Reduced memory usage
  174|      2|- Better cache locality
  175|      2|- Maintained performance with appropriate load factor
  176|      2|
  177|      2|Costs:
  178|      2|- O(n) work to rehash all elements
  179|      2|- Temporary memory overhead during resize
  180|      2|- Amortized analysis still holds with proper thresholds
  181|      2|
  182|      2|Implementation:
  183|      2|- Monitor load factor after deletions
  184|      2|- Use hysteresis (different thresholds for grow/shrink)
  185|      2|- Example: grow at  > 0.75, shrink at  < 0.25
  186|      2|
  187|      2|This is implemented in our LoadFactorManager.
  188|      2|        "#
  189|      2|        .to_string()
  190|      2|    }
  191|       |
  192|       |    /// Exercise 47.3: Resize operation implementation and cost analysis
  193|      1|    pub fn exercise_47_3_resize_implementation() -> String {
  194|      1|        r#"
  195|      1|Exercise 47.3: Resize Operation Implementation
  196|      1|
  197|      1|The resize operation for separate chaining:
  198|      1|
  199|      1|Algorithm:
  200|      1|1. Create new hash table with target size
  201|      1|2. Iterate through all chains in old table
  202|      1|3. For each key-value pair, rehash and insert into new table
  203|      1|4. Return new table
  204|      1|
  205|      1|Cost Analysis:
  206|      1|- Work: (n) where n is number of elements
  207|      1|  - Must visit each element exactly once
  208|      1|  - Each rehash and insert is O(1) expected
  209|      1|- Span: (n) sequential rehashing
  210|      1|  - Could be parallelized to O(log n) span
  211|      1|
  212|      1|amortized Analysis:
  213|      1|- Double when  > threshold (e.g., 0.75)
  214|      1|- Each element pays for future elements
  215|      1|- amortized cost per operation remains O(1)
  216|      1|
  217|      1|Implementation Details:
  218|      1|- Use insert_without_resize to avoid recursive resizing
  219|      1|- Handle both growth and shrinkage
  220|      1|- Maintain minimum table size
  221|      1|- Use appropriate load factor thresholds
  222|      1|
  223|      1|This is fully implemented in our SeparateChaining module.
  224|      1|        "#
  225|      1|        .to_string()
  226|      1|    }
  227|       |
  228|       |    /// Exercise 47.6: Higher-order function implementation
  229|      1|    pub fn exercise_47_6_higher_order() -> String {
  230|      1|        r#"
  231|      1|Exercise 47.6: Higher-Order Function for Flat Hash Tables
  232|      1|
  233|      1|The parametric flat hash table operations can be unified with a single higher-order function:
  234|      1|
  235|      1|```rust
  236|      1|fn probe_operation<K, V, F, R>(
  237|      1|    table: &FlatHashTable<K, V>,
  238|      1|    key: &K,
  239|      1|    operation: F
  240|      1|) -> R
  241|      1|where
  242|      1|    F: Fn(&Entry<K, V>, usize) -> Option<R>
  243|      1|{
  244|      1|    let mut probe_index = 0;
  245|      1|    while probe_index < table.size() {
  246|      1|        let pos = table.probe_hash(key, probe_index);
  247|      1|        let entry = &table[pos];
  248|      1|        
  249|      1|        if let Some(result) = operation(entry, pos) {
  250|      1|            return result;
  251|      1|        }
  252|      1|        
  253|      1|        probe_index += 1;
  254|      1|    }
  255|      1|    // Handle not found case
  256|      1|}
  257|      1|```
  258|      1|
  259|      1|Usage:
  260|      1|- lookup: operation returns Some(value) on Live match, None to continue
  261|      1|- insert: operation returns Some(position) on Empty/Dead/matching Live
  262|      1|- delete: operation returns Some(position) on matching Live
  263|      1|
  264|      1|This unifies the probe logic while allowing different behaviors.
  265|      1|        "#
  266|      1|        .to_string()
  267|      1|    }
  268|       |
  269|       |    /// Exercise 47.7: Complete flat hash table implementation
  270|      1|    pub fn exercise_47_7_complete_implementation() -> String {
  271|      1|        r#"
  272|      1|Exercise 47.7: Complete Flat Hash Table Implementation
  273|      1|
  274|      1|Additional operations for the parametric flat hash table:
  275|      1|
  276|      1|1. resize Operation:
  277|      1|   - Create new table with target size
  278|      1|   - Rehash all Live entries (skip Empty/Dead)
  279|      1|   - Cost: O(n) work, O(n) span
  280|      1|
  281|      1|2. load factor Management:
  282|      1|   - Monitor (live + dead) / table_size
  283|      1|   - resize when threshold exceeded
  284|      1|   - Use lower thresholds than separate chaining
  285|      1|
  286|      1|3. statistics Collection:
  287|      1|   - Track probe distances
  288|      1|   - Monitor clustering effects
  289|      1|   - Measure actual vs. theoretical performance
  290|      1|
  291|      1|4. probe sequence Validation:
  292|      1|   - Ensure probe sequences visit all positions
  293|      1|   - Handle edge cases (h2 = 0 in double hashing)
  294|      1|   - Verify termination conditions
  295|      1|
  296|      1|5. Memory Management:
  297|      1|   - Periodic cleanup of Dead entries
  298|      1|   - Optimize for cache performance
  299|      1|   - Consider Robin Hood hashing variants
  300|      1|
  301|      1|All these features are implemented in our FlatHashTable module
  302|      1|with support for different probing strategies.
  303|      1|        "#
  304|      1|        .to_string()
  305|      1|    }
  306|       |
  307|       |    /// Comprehensive demonstration of all examples
  308|      1|    pub fn run_all_examples() -> String {
  309|      1|        let mut output = String::new();
  310|       |
  311|      1|        output.push_str("=== Chapter 47 Hash Table Examples ===\n\n");
  312|       |
  313|       |        // Example 47.1
  314|      1|        output.push_str("Example 47.1 - Hash Function:\n");
  315|      1|        let hash_demo = example_47_1_demonstration();
  316|     11|        for (key, hash_val) in hash_demo {
                           ^10  ^10
  317|     10|            output.push_str(&format!("  hash('{}') = {}\n", key, hash_val));
  318|     10|        }
  319|      1|        output.push_str("\n");
  320|       |
  321|       |        // Example 47.2
  322|      1|        output.push_str("Example 47.2 - Separate Chaining:\n");
  323|      1|        let sep_chain = example_47_2_separate_chaining();
  324|      1|        let stats = sep_chain.statistics();
  325|      1|        output.push_str(&format!("  {}\n\n", stats));
  326|       |
  327|       |        // Example 47.4
  328|      1|        output.push_str("Example 47.4 - probe Sequences:\n");
  329|      1|        let probe_demo = example_47_4_probe_sequence();
  330|      6|        for (key, sequence) in probe_demo {
                           ^5   ^5
  331|      5|            output.push_str(&format!("  '{}': {:?}\n", key, sequence));
  332|      5|        }
  333|      1|        output.push_str("\n");
  334|       |
  335|       |        // Exercises
  336|      1|        output.push_str("Exercise Solutions:\n");
  337|      1|        output.push_str(&exercise_47_1_nested_implementation());
  338|      1|        output.push_str(&exercise_47_2_size_reduction());
  339|       |
  340|      1|        output
  341|      1|    }
  342|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap47/HashFunctionTraits.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 47: Hash Function Traits and Utilities
    3|       |
    4|       |pub mod HashFunctionTraits {
    5|       |
    6|       |use std::collections::hash_map::DefaultHasher;
    7|       |use std::fmt::{Debug, Display};
    8|       |use std::hash::{Hash, Hasher};
    9|       |
   10|       |use crate::Types::Types::*;
   11|       |    pub trait HashFunction<K> {
   12|       |        /// claude-4-sonet: Work (|key|), Span (|key|), Parallelism (1)
   13|       |        /// Maps a key to a hash code in range [0, table_size)
   14|       |        fn hash(&self, key: &K, table_size: N) -> N;
   15|       |
   16|       |        /// Get a description of this hash function
   17|       |        fn description(&self) -> String;
   18|       |    }
   19|       |
   20|       |    /// Trait for key equality testing
   21|       |    /// Required by Definition 47.1 for hash table operations
   22|       |    pub trait KeyEquality<K> {
   23|       |        /// claude-4-sonet: Work (|key|), Span (|key|), Parallelism (1)
   24|       |        /// Tests if two keys are equal
   25|       |        fn eq(&self, a: &K, b: &K) -> bool;
   26|       |    }
   27|       |
   28|       |    /// Universal hash function family generator
   29|       |    /// Provides theoretical guarantees for collision analysis
   30|       |    pub trait UniversalHashFamily<K> {
   31|       |        type HashFn: HashFunction<K>;
   32|       |
   33|       |        /// Generate a random hash function from the universal family
   34|       |        fn generate(&self, seed: u64) -> Self::HashFn;
   35|       |
   36|       |        /// Get the family description
   37|       |        fn family_description(&self) -> String;
   38|       |    }
   39|       |
   40|       |    /// Simple hash function using Rust's built-in hasher
   41|       |    #[derive(Clone, Debug)]
   42|       |    pub struct DefaultHashFunction;
   43|       |
   44|       |    impl<K: Hash> HashFunction<K> for DefaultHashFunction {
   45|  1.38k|        fn hash(&self, key: &K, table_size: N) -> N {
   46|  1.38k|            let mut hasher = DefaultHasher::new();
   47|  1.38k|            key.hash(&mut hasher);
   48|  1.38k|            (hasher.finish() as N) % table_size
   49|  1.38k|        }
   50|       |
   51|      0|        fn description(&self) -> String { "DefaultHashFunction (Rust built-in)".to_string() }
   52|       |    }
   53|       |
   54|       |    /// String hash function from Example 47.1 in textbook
   55|       |    /// h(x) = ( pos(x[i])) mod m
   56|       |    #[derive(Clone, Debug)]
   57|       |    pub struct StringPositionHashFunction;
   58|       |
   59|       |    impl HashFunction<String> for StringPositionHashFunction {
   60|       |        /// Claude Work: (|string|), Span: (|string|)
   61|       |        /// Example 47.1: Sum character positions modulo table size
   62|  2.40k|        fn hash(&self, key: &String, table_size: N) -> N {
   63|  2.40k|            let mut sum = 0;
   64|  10.9k|            for ch in key.chars() {
                                    ^2.40k^2.40k
   65|       |                // Convert character to position (a=0, b=1, ..., z=25)
   66|  10.9k|                if ch.is_ascii_lowercase() {
   67|  7.96k|                    sum += (ch as u8 - b'a') as N;
   68|  7.96k|                } else if ch.is_ascii_uppercase() {
                                        ^2.99k^2.99k
   69|    104|                    sum += (ch as u8 - b'A') as N;
   70|  2.88k|                }
   71|       |            }
   72|  2.40k|            sum % table_size
   73|  2.40k|        }
   74|       |
   75|     11|        fn description(&self) -> String { "StringPositionHashFunction (Example 47.1)".to_string() }
   76|       |    }
   77|       |
   78|       |    /// Polynomial rolling hash function for strings
   79|       |    /// h(x) = ( x[i] * base^i) mod m
   80|       |    #[derive(Clone, Debug)]
   81|       |    pub struct PolynomialHashFunction {
   82|       |        base: N,
   83|       |    }
   84|       |
   85|       |    impl PolynomialHashFunction {
   86|     32|        pub fn new(base: N) -> Self { PolynomialHashFunction { base } }
   87|       |    }
   88|       |
   89|       |    impl HashFunction<String> for PolynomialHashFunction {
   90|       |        /// Claude Work: (|string|), Span: (|string|)
   91|    396|        fn hash(&self, key: &String, table_size: N) -> N {
   92|    396|            let mut hash_value = 0;
   93|    396|            let mut power = 1;
   94|       |
   95|  1.81k|            for ch in key.chars() {
                                    ^396^396
   96|  1.81k|                hash_value = (hash_value + (ch as N) * power) % table_size;
   97|  1.81k|                power = (power * self.base) % table_size;
   98|  1.81k|            }
   99|       |
  100|    396|            hash_value
  101|    396|        }
  102|       |
  103|      4|        fn description(&self) -> String { format!("PolynomialHashFunction (base={})", self.base) }
  104|       |    }
  105|       |
  106|       |    /// Universal hash function for integers
  107|       |    /// h_a,b(x) = ((ax + b) mod p) mod m
  108|       |    /// where p is a large prime and a, b are random
  109|       |    #[derive(Clone, Debug)]
  110|       |    pub struct UniversalIntegerHashFunction {
  111|       |        a: u64,
  112|       |        b: u64,
  113|       |        p: u64, // Large prime
  114|       |    }
  115|       |
  116|       |    impl UniversalIntegerHashFunction {
  117|     16|        pub fn new(a: u64, b: u64) -> Self {
  118|       |            const LARGE_PRIME: u64 = 1000000007; // 10^9 + 7
  119|     16|            UniversalIntegerHashFunction { a, b, p: LARGE_PRIME }
  120|     16|        }
  121|       |    }
  122|       |
  123|       |    impl HashFunction<i32> for UniversalIntegerHashFunction {
  124|       |        /// Claude Work: (1), Span: (1)
  125|     48|        fn hash(&self, key: &i32, table_size: N) -> N {
  126|     48|            let x = *key as u64;
  127|     48|            let hash_value = ((self.a * x + self.b) % self.p) as N;
  128|     48|            hash_value % table_size
  129|     48|        }
  130|       |
  131|      1|        fn description(&self) -> String {
  132|      1|            format!(
  133|      1|                "UniversalIntegerHashFunction (a={}, b={}, p={})",
  134|       |                self.a, self.b, self.p
  135|       |            )
  136|      1|        }
  137|       |    }
  138|       |
  139|       |    /// Default key equality using Rust's PartialEq
  140|       |    #[derive(Clone, Debug)]
  141|       |    pub struct DefaultKeyEquality;
  142|       |
  143|       |    impl<K: PartialEq> KeyEquality<K> for DefaultKeyEquality {
  144|    219|        fn eq(&self, a: &K, b: &K) -> bool { a == b }
  145|       |    }
  146|       |
  147|       |    /// Case-insensitive string equality
  148|       |    #[derive(Clone, Debug)]
  149|       |    pub struct CaseInsensitiveStringEquality;
  150|       |
  151|       |    impl KeyEquality<String> for CaseInsensitiveStringEquality {
  152|      3|        fn eq(&self, a: &String, b: &String) -> bool { a.to_lowercase() == b.to_lowercase() }
  153|       |    }
  154|       |
  155|       |    /// Universal hash family for integers
  156|       |    pub struct UniversalIntegerHashFamily {
  157|       |        p: u64,
  158|       |    }
  159|       |
  160|       |    impl UniversalIntegerHashFamily {
  161|      9|        pub fn new() -> Self {
  162|       |            const LARGE_PRIME: u64 = 1000000007;
  163|      9|            UniversalIntegerHashFamily { p: LARGE_PRIME }
  164|      9|        }
  165|       |    }
  166|       |
  167|       |    impl UniversalHashFamily<i32> for UniversalIntegerHashFamily {
  168|       |        type HashFn = UniversalIntegerHashFunction;
  169|       |
  170|     14|        fn generate(&self, seed: u64) -> Self::HashFn {
  171|       |            // Use seed to generate pseudo-random a and b
  172|     14|            let a = (seed * 1103515245 + 12345) % (self.p - 1) + 1; // Ensure a != 0
  173|     14|            let b = (a * 1103515245 + 12345) % self.p;
  174|     14|            UniversalIntegerHashFunction::new(a, b)
  175|     14|        }
  176|       |
  177|      1|        fn family_description(&self) -> String { format!("UniversalIntegerHashFamily (p={})", self.p) }
  178|       |    }
  179|       |
  180|       |    /// Hash function combiner for creating probe sequences
  181|       |    /// Used in flat hash tables for open addressing
  182|       |    pub struct ProbeSequenceGenerator<K, H1: HashFunction<K>, H2: HashFunction<K>> {
  183|       |        hash1: H1,
  184|       |        hash2: H2,
  185|       |        _phantom: std::marker::PhantomData<K>,
  186|       |    }
  187|       |
  188|       |    impl<K, H1: HashFunction<K>, H2: HashFunction<K>> ProbeSequenceGenerator<K, H1, H2> {
  189|      1|        pub fn new(hash1: H1, hash2: H2) -> Self {
  190|      1|            ProbeSequenceGenerator {
  191|      1|                hash1,
  192|      1|                hash2,
  193|      1|                _phantom: std::marker::PhantomData,
  194|      1|            }
  195|      1|        }
  196|       |
  197|       |        /// Generate the i-th hash value in the probe sequence
  198|       |        /// For double hashing: h_i(x) = (h1(x) + i * h2(x)) mod m
  199|      3|        pub fn probe_hash(&self, key: &K, probe_index: N, table_size: N) -> N {
  200|      3|            let h1 = self.hash1.hash(key, table_size);
  201|      3|            let h2 = self.hash2.hash(key, table_size);
  202|      3|            (h1 + probe_index * h2) % table_size
  203|      3|        }
  204|       |    }
  205|       |
  206|       |    /// Load factor calculation and management
  207|       |    /// Definition 47.2:  = n/m
  208|       |    #[derive(Clone, Debug)]
  209|       |    pub struct LoadFactorManager {
  210|       |        max_load_factor: f64,
  211|       |        min_load_factor: f64,
  212|       |    }
  213|       |
  214|       |    impl LoadFactorManager {
  215|    153|        pub fn new(max_load: f64, min_load: f64) -> Self {
  216|    153|            LoadFactorManager {
  217|    153|                max_load_factor: max_load,
  218|    153|                min_load_factor: min_load,
  219|    153|            }
  220|    153|        }
  221|       |
  222|       |        /// Calculate current load factor
  223|    706|        pub fn load_factor(&self, num_elements: N, table_size: N) -> f64 {
  224|    706|            if table_size == 0 {
  225|      0|                0.0
  226|       |            } else {
  227|    706|                num_elements as f64 / table_size as f64
  228|       |            }
  229|    706|        }
  230|       |
  231|       |        /// Check if table should be resized up
  232|    693|        pub fn should_grow(&self, num_elements: N, table_size: N) -> bool {
  233|    693|            self.load_factor(num_elements, table_size) > self.max_load_factor
  234|    693|        }
  235|       |
  236|       |        /// Check if table should be resized down
  237|     21|        pub fn should_shrink(&self, num_elements: N, table_size: N) -> bool {
  238|     21|            table_size > 8 && // Don't shrink below minimum size
  239|     10|            self.load_factor(num_elements, table_size) < self.min_load_factor
  240|     21|        }
  241|       |
  242|       |        /// Calculate new table size for growth
  243|     33|        pub fn grow_size(&self, current_size: N) -> N { current_size * 2 }
  244|       |
  245|       |        /// Calculate new table size for shrinkage
  246|      3|        pub fn shrink_size(&self, current_size: N) -> N { (current_size / 2).max(8) }
  247|       |    }
  248|       |
  249|       |    /// Hash table statistics for analysis
  250|       |    #[derive(Debug, Clone)]
  251|       |    pub struct HashTableStats {
  252|       |        pub num_elements: N,
  253|       |        pub table_size: N,
  254|       |        pub load_factor: f64,
  255|       |        pub num_collisions: N,
  256|       |        pub max_chain_length: N,
  257|       |        pub avg_chain_length: f64,
  258|       |    }
  259|       |
  260|       |    impl HashTableStats {
  261|     16|        pub fn new(num_elements: N, table_size: N) -> Self {
  262|     16|            let load_factor = if table_size == 0 {
  263|      0|                0.0
  264|       |            } else {
  265|     16|                num_elements as f64 / table_size as f64
  266|       |            };
  267|     16|            HashTableStats {
  268|     16|                num_elements,
  269|     16|                table_size,
  270|     16|                load_factor,
  271|     16|                num_collisions: 0,
  272|     16|                max_chain_length: 0,
  273|     16|                avg_chain_length: 0.0,
  274|     16|            }
  275|     16|        }
  276|       |
  277|     16|        pub fn with_collision_stats(mut self, collisions: N, max_chain: N, avg_chain: f64) -> Self {
  278|     16|            self.num_collisions = collisions;
  279|     16|            self.max_chain_length = max_chain;
  280|     16|            self.avg_chain_length = avg_chain;
  281|     16|            self
  282|     16|        }
  283|       |    }
  284|       |
  285|       |    impl Display for HashTableStats {
  286|      2|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  287|      2|            write!(
  288|      2|                f,
  289|      2|                "HashTableStats {{ elements: {}, size: {}, load_factor: {:.3}, collisions: {}, max_chain: {}, avg_chain: {:.2} }}",
  290|       |                self.num_elements,
  291|       |                self.table_size,
  292|       |                self.load_factor,
  293|       |                self.num_collisions,
  294|       |                self.max_chain_length,
  295|       |                self.avg_chain_length
  296|       |            )
  297|      2|        }
  298|       |    }
  299|       |
  300|       |    /// Utility functions for hash table implementation
  301|       |    pub struct HashTableUtils;
  302|       |
  303|       |    impl HashTableUtils {
  304|       |        /// Find next prime number >= n (for table sizing)
  305|      4|        pub fn next_prime(n: N) -> N {
  306|      4|            if n <= 2 {
  307|      0|                return 2;
  308|      4|            }
  309|      4|            let mut candidate = if n % 2 == 0 { n + 1 } else { n };
                                                              ^3             ^1
  310|       |
  311|      4|            while !Self::is_prime(candidate) {
  312|      0|                candidate += 2;
  313|      0|            }
  314|      4|            candidate
  315|      4|        }
  316|       |
  317|       |        /// Check if number is prime
  318|     11|        pub fn is_prime(n: N) -> bool {
  319|     11|            if n < 2 {
  320|      1|                return false;
  321|     10|            }
  322|     10|            if n == 2 {
  323|      1|                return true;
  324|      9|            }
  325|      9|            if n % 2 == 0 {
  326|      1|                return false;
  327|      8|            }
  328|       |
  329|      8|            let sqrt_n = (n as f64).sqrt() as N;
  330|      8|            for i in (3..=sqrt_n).step_by(2) {
                              ^6
  331|      6|                if n % i == 0 {
  332|      1|                    return false;
  333|      5|                }
  334|       |            }
  335|      7|            true
  336|     11|        }
  337|       |
  338|       |        /// Generate good table sizes (powers of 2 or primes)
  339|      2|        pub fn good_table_size(desired_size: N, use_prime: bool) -> N {
  340|      2|            if use_prime {
  341|      1|                Self::next_prime(desired_size)
  342|       |            } else {
  343|       |                // Next power of 2
  344|      1|                if desired_size <= 1 {
  345|      0|                    return 2;
  346|      1|                }
  347|      1|                let mut size = 1;
  348|      5|                while size < desired_size {
  349|      4|                    size *= 2;
  350|      4|                }
  351|      1|                size
  352|       |            }
  353|      2|        }
  354|       |    }
  355|       |
  356|       |    /// Macro for creating hash function implementations
  357|       |    #[macro_export]
  358|       |    macro_rules! impl_hash_function {
  359|       |        ($name:ident, $key_type:ty, $hash_expr:expr, $desc:expr) => {
  360|       |            #[derive(Clone, Debug)]
  361|       |            pub struct $name;
  362|       |
  363|       |            impl HashFunction<$key_type> for $name {
  364|     60|                fn hash(&self, key: &$key_type, table_size: N) -> N {
  365|     60|                    let hash_value = $hash_expr(key);
  366|     60|                    hash_value % table_size
  367|     60|                }
  368|       |
  369|      3|                fn description(&self) -> String { $desc.to_string() }
  370|       |            }
  371|       |        };
  372|       |    }
  373|       |
  374|       |    // Example usage of the macro
  375|       |    impl_hash_function!(
  376|       |        SimpleIntegerHash,
  377|       |        i32,
  378|     58|        |key: &i32| (*key as N).wrapping_mul(2654435761), // Knuth's multiplicative hash
  379|       |        "SimpleIntegerHash (Knuth multiplicative)"
  380|       |    );
  381|       |
  382|       |    /// Test utilities for hash functions
  383|       |    pub struct HashFunctionTester;
  384|       |
  385|       |    impl HashFunctionTester {
  386|       |        /// Test hash function distribution
  387|      1|        pub fn test_distribution<K, H: HashFunction<K>>(hash_fn: &H, keys: &[K], table_size: N) -> HashTableStats {
  388|      1|            let mut bucket_counts = vec![0; table_size];
  389|      1|            let mut max_count = 0;
  390|      1|            let mut total_collisions = 0;
  391|       |
  392|      6|            for key in keys {
                              ^5
  393|      5|                let hash_value = hash_fn.hash(key, table_size);
  394|      5|                bucket_counts[hash_value] += 1;
  395|      5|                if bucket_counts[hash_value] > 1 {
  396|      0|                    total_collisions += 1;
  397|      5|                }
  398|      5|                max_count = max_count.max(bucket_counts[hash_value]);
  399|       |            }
  400|       |
  401|      1|            let avg_count = keys.len() as f64 / table_size as f64;
  402|       |
  403|      1|            HashTableStats::new(keys.len(), table_size).with_collision_stats(total_collisions, max_count, avg_count)
  404|      1|        }
  405|       |
  406|       |        /// Measure hash function performance
  407|      1|        pub fn benchmark_hash_function<K, H: HashFunction<K>>(
  408|      1|            hash_fn: &H,
  409|      1|            keys: &[K],
  410|      1|            table_size: N,
  411|      1|        ) -> std::time::Duration {
  412|      1|            let start = std::time::Instant::now();
  413|      6|            for key in keys {
                              ^5
  414|      5|                let _ = hash_fn.hash(key, table_size);
  415|      5|            }
  416|      1|            start.elapsed()
  417|      1|        }
  418|       |    }
  419|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap47/LinearProbing.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 47: Linear Probing Strategy
    3|       |
    4|       |pub mod LinearProbing {
    5|       |
    6|       |use crate::Types::Types::*;
    7|       |use crate::Chap47::FlatHashTable::FlatHashTable::*;
    8|       |use crate::Chap47::HashFunctionTraits::HashFunctionTraits::*;
    9|       |    #[derive(Clone, Debug)]
   10|       |    pub struct LinearProbingStrategy<K: StT, H: HashFunClone<K>> {
   11|       |        base_hash: H,
   12|       |        _phantom: std::marker::PhantomData<K>,
   13|       |    }
   14|       |
   15|       |    impl<K: StT, H: HashFunClone<K>> LinearProbingStrategy<K, H> {
   16|     38|        pub fn new(hash_fn: H) -> Self {
   17|     38|            LinearProbingStrategy {
   18|     38|                base_hash: hash_fn,
   19|     38|                _phantom: std::marker::PhantomData,
   20|     38|            }
   21|     38|        }
   22|       |    }
   23|       |
   24|       |    impl<K: StT, H: HashFunClone<K>> ProbeSequence<K> for LinearProbingStrategy<K, H> {
   25|       |        /// Claude Work: (1), Span: (1)
   26|    875|        fn probe_hash(&self, key: &K, probe_index: N, table_size: N) -> N {
   27|    875|            let base_hash = self.base_hash.hash(key, table_size);
   28|    875|            (base_hash + probe_index) % table_size
   29|    875|        }
   30|       |
   31|      2|        fn strategy_name(&self) -> String { format!("LinearProbing({})", self.base_hash.description()) }
   32|       |    }
   33|       |
   34|       |    /// Type alias for linear probing hash table
   35|       |    pub type LinearProbingHashTable<K, V, H> = FlatHashTable<K, V, LinearProbingStrategy<K, H>>;
   36|       |
   37|       |    /// Constructor functions for linear probing hash tables
   38|       |    /// APAS: Work (1), Span (1)
   39|     11|    pub fn create_linear_probing_string_table<V: StT>(
   40|     11|        initial_size: N,
   41|     11|    ) -> LinearProbingHashTable<String, V, StringPositionHashFunction> {
   42|     11|        let probe_strategy = LinearProbingStrategy::new(StringPositionHashFunction);
   43|     11|        FlatHashTable::create_table(probe_strategy, initial_size)
   44|     11|    }
   45|       |
   46|       |    /// APAS: Work (1), Span (1)
   47|      2|    pub fn create_linear_probing_integer_table<V: StT>(
   48|      2|        initial_size: N,
   49|      2|        seed: u64,
   50|      2|    ) -> LinearProbingHashTable<i32, V, UniversalIntegerHashFunction> {
   51|      2|        let hash_family = UniversalIntegerHashFamily::new();
   52|      2|        let hash_fn = hash_family.generate(seed);
   53|      2|        let probe_strategy = LinearProbingStrategy::new(hash_fn);
   54|      2|        FlatHashTable::create_table(probe_strategy, initial_size)
   55|      2|    }
   56|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap47/NestedHashTable.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 47: Nested Hash Table implementation - Section 1.1 Parametric Design
    3|       |
    4|       |pub mod NestedHashTable {
    5|       |
    6|       |use std::fmt::{Debug, Display, Formatter, Result};
    7|       |
    8|       |use crate::Types::Types::*;
    9|       |use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
   10|       |use crate::Chap47::HashFunctionTraits::HashFunctionTraits::*;
   11|       |    #[derive(Clone, Debug)]
   12|       |    pub struct NestedHashTable<K: StT, V: StT> {
   13|       |        buckets: ArraySeqStPerS<ArraySeqStPerS<Pair<K, V>>>,
   14|       |        num_elements: N,
   15|       |        load_factor_manager: LoadFactorManager,
   16|       |    }
   17|       |
   18|       |    impl<K: StT, V: StT> NestedHashTable<K, V> {
   19|       |        /// Claude Work: (m), Span: (m)
   20|       |        /// Create empty nested hash table with given initial size
   21|      2|        pub fn create_table(initial_size: N) -> Self {
   22|      2|            let size = initial_size.max(8);
   23|      2|            let mut buckets = ArraySeqStPerS::empty();
   24|       |
   25|     20|            for _ in 0..size {
                                      ^2
   26|     20|                let empty_chain = ArraySeqStPerS::empty();
   27|     20|                let single_seq = ArraySeqStPerS::singleton(empty_chain);
   28|     20|                buckets = ArraySeqStPerS::append(&buckets, &single_seq);
   29|     20|            }
   30|       |
   31|      2|            NestedHashTable {
   32|      2|                buckets,
   33|      2|                num_elements: 0,
   34|      2|                load_factor_manager: LoadFactorManager::new(0.75, 0.25),
   35|      2|            }
   36|      2|        }
   37|       |
   38|       |        /// Claude Work: (1 + ) expected, Span: (1 + ) expected
   39|       |        /// Insert key-value pair using default hash function
   40|      2|        pub fn insert(&self, key: K, value: V) -> Self
   41|      2|        where
   42|      2|            K: std::hash::Hash,
   43|       |        {
   44|      2|            let hash_fn = DefaultHashFunction;
   45|      2|            let table_size = self.buckets.length();
   46|      2|            let hash_code = hash_fn.hash(&key, table_size);
   47|      2|            let chain = self.buckets.nth(hash_code);
   48|       |
   49|       |            // Check if key exists and remove old entry
   50|      2|            let mut new_chain = ArraySeqStPerS::empty();
   51|      2|            let mut key_existed = false;
   52|       |
   53|      2|            for i in 0..chain.length() {
                              ^0
   54|      0|                let pair = chain.nth(i);
   55|      0|                if pair.0 != key {
   56|      0|                    let single_seq = ArraySeqStPerS::singleton(pair.clone());
   57|      0|                    new_chain = ArraySeqStPerS::append(&new_chain, &single_seq);
   58|      0|                } else {
   59|      0|                    key_existed = true;
   60|      0|                }
   61|       |            }
   62|       |
   63|       |            // Add new entry at head
   64|      2|            let new_pair = Pair(key, value);
   65|      2|            let new_head = ArraySeqStPerS::singleton(new_pair);
   66|      2|            new_chain = ArraySeqStPerS::append(&new_head, &new_chain);
   67|       |
   68|       |            // Update buckets
   69|      2|            let mut new_buckets = ArraySeqStPerS::empty();
   70|     20|            for i in 0..table_size {
                                      ^2
   71|     20|                let bucket_to_use = if i == hash_code {
   72|      2|                    new_chain.clone()
   73|       |                } else {
   74|     18|                    self.buckets.nth(i).clone()
   75|       |                };
   76|     20|                let single_seq = ArraySeqStPerS::singleton(bucket_to_use);
   77|     20|                new_buckets = ArraySeqStPerS::append(&new_buckets, &single_seq);
   78|       |            }
   79|       |
   80|      2|            let new_num_elements = if key_existed {
   81|      0|                self.num_elements
   82|       |            } else {
   83|      2|                self.num_elements + 1
   84|       |            };
   85|       |
   86|      2|            let mut result = NestedHashTable {
   87|      2|                buckets: new_buckets,
   88|      2|                num_elements: new_num_elements,
   89|      2|                load_factor_manager: self.load_factor_manager.clone(),
   90|      2|            };
   91|       |
   92|       |            // Check resize
   93|      2|            if result.load_factor_manager.should_grow(result.num_elements, table_size) {
   94|      0|                let new_size = result.load_factor_manager.grow_size(table_size);
   95|      0|                result = result.resize(new_size);
   96|      2|            }
   97|       |
   98|      2|            result
   99|      2|        }
  100|       |
  101|       |        /// Claude Work: (1 + ) expected, Span: (1 + ) expected
  102|       |        /// Look up value for given key
  103|      0|        pub fn lookup(&self, key: &K) -> Option<&V>
  104|      0|        where
  105|      0|            K: std::hash::Hash,
  106|       |        {
  107|      0|            let hash_fn = DefaultHashFunction;
  108|      0|            let table_size = self.buckets.length();
  109|      0|            let hash_code = hash_fn.hash(key, table_size);
  110|      0|            let chain = self.buckets.nth(hash_code);
  111|       |
  112|      0|            for i in 0..chain.length() {
  113|      0|                let pair = chain.nth(i);
  114|      0|                if &pair.0 == key {
  115|      0|                    return Some(&pair.1);
  116|      0|                }
  117|       |            }
  118|       |
  119|      0|            None
  120|      0|        }
  121|       |
  122|       |        /// Claude Work: (1 + ) expected, Span: (1 + ) expected
  123|      0|        pub fn delete(&self, key: &K) -> (Self, bool)
  124|      0|        where
  125|      0|            K: std::hash::Hash,
  126|       |        {
  127|      0|            let hash_fn = DefaultHashFunction;
  128|      0|            let table_size = self.buckets.length();
  129|      0|            let hash_code = hash_fn.hash(key, table_size);
  130|      0|            let chain = self.buckets.nth(hash_code);
  131|       |
  132|      0|            let mut new_chain = ArraySeqStPerS::empty();
  133|      0|            let mut was_deleted = false;
  134|       |
  135|      0|            for i in 0..chain.length() {
  136|      0|                let pair = chain.nth(i);
  137|      0|                if &pair.0 != key {
  138|      0|                    let single_seq = ArraySeqStPerS::singleton(pair.clone());
  139|      0|                    new_chain = ArraySeqStPerS::append(&new_chain, &single_seq);
  140|      0|                } else {
  141|      0|                    was_deleted = true;
  142|      0|                }
  143|       |            }
  144|       |
  145|      0|            if !was_deleted {
  146|      0|                return (self.clone(), false);
  147|      0|            }
  148|       |
  149|      0|            let mut new_buckets = ArraySeqStPerS::empty();
  150|      0|            for i in 0..table_size {
  151|      0|                let bucket_to_use = if i == hash_code {
  152|      0|                    new_chain.clone()
  153|       |                } else {
  154|      0|                    self.buckets.nth(i).clone()
  155|       |                };
  156|      0|                let single_seq = ArraySeqStPerS::singleton(bucket_to_use);
  157|      0|                new_buckets = ArraySeqStPerS::append(&new_buckets, &single_seq);
  158|       |            }
  159|       |
  160|      0|            let mut result = NestedHashTable {
  161|      0|                buckets: new_buckets,
  162|      0|                num_elements: self.num_elements - 1,
  163|      0|                load_factor_manager: self.load_factor_manager.clone(),
  164|      0|            };
  165|       |
  166|       |            // Check resize down
  167|      0|            if result
  168|      0|                .load_factor_manager
  169|      0|                .should_shrink(result.num_elements, table_size)
  170|      0|            {
  171|      0|                let new_size = result.load_factor_manager.shrink_size(table_size);
  172|      0|                result = result.resize(new_size);
  173|      0|            }
  174|       |
  175|      0|            (result, true)
  176|      0|        }
  177|       |
  178|       |        /// Claude Work: (n), Span: (n)
  179|      0|        pub fn resize(&self, new_size: N) -> Self
  180|      0|        where
  181|      0|            K: std::hash::Hash,
  182|       |        {
  183|      0|            let actual_new_size = new_size.max(8);
  184|      0|            let mut new_table = Self::create_table(actual_new_size);
  185|       |
  186|       |            // Rehash all elements
  187|      0|            for i in 0..self.buckets.length() {
  188|      0|                let chain = self.buckets.nth(i);
  189|      0|                for j in 0..chain.length() {
  190|      0|                    let pair = chain.nth(j);
  191|      0|                    new_table = new_table.insert_without_resize(pair.0.clone(), pair.1.clone());
  192|      0|                }
  193|       |            }
  194|       |
  195|      0|            new_table
  196|      0|        }
  197|       |
  198|      0|        fn insert_without_resize(&self, key: K, value: V) -> Self
  199|      0|        where
  200|      0|            K: std::hash::Hash,
  201|       |        {
  202|      0|            let hash_fn = DefaultHashFunction;
  203|      0|            let table_size = self.buckets.length();
  204|      0|            let hash_code = hash_fn.hash(&key, table_size);
  205|      0|            let chain = self.buckets.nth(hash_code);
  206|       |
  207|      0|            let mut new_chain = ArraySeqStPerS::empty();
  208|      0|            let mut key_existed = false;
  209|       |
  210|      0|            for i in 0..chain.length() {
  211|      0|                let pair = chain.nth(i);
  212|      0|                if pair.0 != key {
  213|      0|                    let single_seq = ArraySeqStPerS::singleton(pair.clone());
  214|      0|                    new_chain = ArraySeqStPerS::append(&new_chain, &single_seq);
  215|      0|                } else {
  216|      0|                    key_existed = true;
  217|      0|                }
  218|       |            }
  219|       |
  220|      0|            let new_pair = Pair(key, value);
  221|      0|            let new_head = ArraySeqStPerS::singleton(new_pair);
  222|      0|            new_chain = ArraySeqStPerS::append(&new_head, &new_chain);
  223|       |
  224|      0|            let mut new_buckets = ArraySeqStPerS::empty();
  225|      0|            for i in 0..table_size {
  226|      0|                let bucket_to_use = if i == hash_code {
  227|      0|                    new_chain.clone()
  228|       |                } else {
  229|      0|                    self.buckets.nth(i).clone()
  230|       |                };
  231|      0|                let single_seq = ArraySeqStPerS::singleton(bucket_to_use);
  232|      0|                new_buckets = ArraySeqStPerS::append(&new_buckets, &single_seq);
  233|       |            }
  234|       |
  235|      0|            let new_num_elements = if key_existed {
  236|      0|                self.num_elements
  237|       |            } else {
  238|      0|                self.num_elements + 1
  239|       |            };
  240|       |
  241|      0|            NestedHashTable {
  242|      0|                buckets: new_buckets,
  243|      0|                num_elements: new_num_elements,
  244|      0|                load_factor_manager: self.load_factor_manager.clone(),
  245|      0|            }
  246|      0|        }
  247|       |
  248|       |        /// Claude Work: (1), Span: (1)
  249|      0|        pub fn load_and_size(&self) -> (N, N) { (self.num_elements, self.buckets.length()) }
  250|       |
  251|      2|        pub fn size(&self) -> N { self.num_elements }
  252|       |
  253|      0|        pub fn is_empty(&self) -> bool { self.num_elements == 0 }
  254|       |
  255|      0|        pub fn load_factor(&self) -> f64 {
  256|      0|            self.load_factor_manager
  257|      0|                .load_factor(self.num_elements, self.buckets.length())
  258|      0|        }
  259|       |
  260|      0|        pub fn statistics(&self) -> HashTableStats {
  261|      0|            let mut total_collisions = 0;
  262|      0|            let mut max_chain_length = 0;
  263|      0|            let mut non_empty_buckets = 0;
  264|      0|            let mut total_chain_length = 0;
  265|       |
  266|      0|            for i in 0..self.buckets.length() {
  267|      0|                let chain = self.buckets.nth(i);
  268|      0|                let chain_length = chain.length();
  269|       |
  270|      0|                if chain_length > 0 {
  271|      0|                    non_empty_buckets += 1;
  272|      0|                    total_chain_length += chain_length;
  273|       |
  274|      0|                    if chain_length > 1 {
  275|      0|                        total_collisions += chain_length - 1;
  276|      0|                    }
  277|       |
  278|      0|                    max_chain_length = max_chain_length.max(chain_length);
  279|      0|                }
  280|       |            }
  281|       |
  282|      0|            let avg_chain_length = if non_empty_buckets > 0 {
  283|      0|                total_chain_length as f64 / non_empty_buckets as f64
  284|       |            } else {
  285|      0|                0.0
  286|       |            };
  287|       |
  288|      0|            HashTableStats::new(self.num_elements, self.buckets.length()).with_collision_stats(
  289|      0|                total_collisions,
  290|      0|                max_chain_length,
  291|      0|                avg_chain_length,
  292|       |            )
  293|      0|        }
  294|       |    }
  295|       |
  296|       |    impl<K: StT + Display, V: StT + Display> Display for NestedHashTable<K, V> {
  297|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  298|      0|            writeln!(f, "NestedHashTable {{")?;
  299|      0|            writeln!(
  300|      0|                f,
  301|      0|                "  size: {}, load_factor: {:.3}",
  302|       |                self.num_elements,
  303|      0|                self.load_factor()
  304|      0|            )?;
  305|       |
  306|      0|            for i in 0..self.buckets.length() {
  307|      0|                let chain = self.buckets.nth(i);
  308|       |
  309|      0|                if chain.length() > 0 {
  310|      0|                    write!(f, "  bucket[{}]: ", i)?;
  311|      0|                    for j in 0..chain.length() {
  312|      0|                        let pair = chain.nth(j);
  313|      0|                        if j > 0 {
  314|      0|                            write!(f, ", ")?;
  315|      0|                        }
  316|      0|                        write!(f, "({}  {})", pair.0, pair.1)?;
  317|       |                    }
  318|      0|                    writeln!(f)?;
  319|      0|                }
  320|       |            }
  321|       |
  322|      0|            write!(f, "}}")
  323|      0|        }
  324|       |    }
  325|       |
  326|       |    /// Type aliases for common configurations
  327|       |    pub type StringNestedHashTable<V> = NestedHashTable<String, V>;
  328|       |    pub type IntegerNestedHashTable<V> = NestedHashTable<i32, V>;
  329|       |
  330|       |    /// Constructor functions for common nested hash table configurations
  331|       |    /// APAS: Work (1), Span (1)
  332|      0|    pub fn create_string_nested_hash_table<V: StT>(initial_size: N) -> StringNestedHashTable<V> {
  333|      0|        NestedHashTable::create_table(initial_size)
  334|      0|    }
  335|       |
  336|       |    /// APAS: Work (1), Span (1)
  337|      0|    pub fn create_integer_nested_hash_table<V: StT>(initial_size: N) -> IntegerNestedHashTable<V> {
  338|      0|        NestedHashTable::create_table(initial_size)
  339|      0|    }
  340|       |
  341|       |    /// Macro for creating nested hash tables with initial data
  342|       |    #[macro_export]
  343|       |    macro_rules! NestedHashTableLit {
  344|       |        ($size:expr) => {
  345|       |            NestedHashTable::create_table($size)
  346|       |        };
  347|       |        ($size:expr, $(($key:expr, $value:expr)),* $(,)?) => {{
  348|       |            let mut table = NestedHashTable::create_table($size);
  349|       |            $(
  350|       |                table = table.insert($key, $value);
  351|       |            )*
  352|       |            table
  353|       |        }};
  354|       |    }
  355|       |
  356|       |    #[allow(dead_code)]
  357|      0|    fn _nested_hash_table_lit_type_checks() {
  358|      0|        let _: StringNestedHashTable<i32> = NestedHashTableLit!(8, ("key1".to_string(), 1), ("key2".to_string(), 2));
  359|      0|    }
  360|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap47/ProbeSequenceExamples.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 47: Probe Sequence Examples for Advanced Probing Strategies
    3|       |//! Textbook Examples 47.4, 47.5, 47.6 and additional demonstrations
    4|       |
    5|       |pub mod ProbeSequenceExamples {
    6|       |
    7|       |use std::collections::HashMap;
    8|       |use std::fmt::{Debug, Display};
    9|       |
   10|       |use crate::Types::Types::*;
   11|       |use crate::Chap47::AdvancedDoubleHashing::AdvancedDoubleHashing::*;
   12|       |use crate::Chap47::AdvancedLinearProbing::AdvancedLinearProbing::*;
   13|       |use crate::Chap47::AdvancedQuadraticProbing::AdvancedQuadraticProbing::*;
   14|       |use crate::Chap47::FlatHashTable::FlatHashTable::*;
   15|       |use crate::Chap47::HashFunctionTraits::HashFunctionTraits::*;
   16|       |    #[derive(Clone, Debug, PartialEq)]
   17|       |    pub struct ProbeSequenceVisualization {
   18|       |        pub strategy_name: String,
   19|       |        pub key: String,
   20|       |        pub table_size: N,
   21|       |        pub probe_sequence: Vec<N>,
   22|       |        pub sequence_length: N,
   23|       |        pub unique_positions: N,
   24|       |        pub period: N,
   25|       |        pub collision_pattern: String,
   26|       |    }
   27|       |
   28|       |    /// Textbook Example Results
   29|       |    /// Claude Work: (1), Span: (1)
   30|       |    #[derive(Clone, Debug)]
   31|       |    pub struct TextbookExampleResults {
   32|       |        pub example_name: String,
   33|       |        pub description: String,
   34|       |        pub table_size: N,
   35|       |        pub keys: Vec<String>,
   36|       |        pub probe_sequences: Vec<ProbeSequenceVisualization>,
   37|       |        pub clustering_analysis: String,
   38|       |        pub performance_summary: String,
   39|       |    }
   40|       |
   41|       |    /// Probe Sequence Generator and Analyzer
   42|       |    /// Claude Work: (1), Span: (1)
   43|       |    #[derive(Clone, Debug)]
   44|       |    pub struct ProbeSequenceAnalyzer {
   45|       |        pub max_probes: N,
   46|       |        pub visualization_enabled: B,
   47|       |    }
   48|       |
   49|       |    impl ProbeSequenceAnalyzer {
   50|       |        /// Create new probe sequence analyzer
   51|       |        /// Claude Work: (1), Span: (1)
   52|     23|        pub fn new() -> Self {
   53|     23|            ProbeSequenceAnalyzer {
   54|     23|                max_probes: 20,
   55|     23|                visualization_enabled: true,
   56|     23|            }
   57|     23|        }
   58|       |
   59|       |        /// Create minimal analyzer for performance testing
   60|       |        /// Claude Work: (1), Span: (1)
   61|      2|        pub fn new_minimal() -> Self {
   62|      2|            ProbeSequenceAnalyzer {
   63|      2|                max_probes: 10,
   64|      2|                visualization_enabled: false,
   65|      2|            }
   66|      2|        }
   67|       |
   68|       |        /// Analyze linear probing sequence
   69|       |        /// Claude Work: (min(max_probes, m)), Span: (min(max_probes, m))
   70|     31|        pub fn analyze_linear_probing(&self, key: &str, table_size: N) -> ProbeSequenceVisualization {
   71|     31|            let strategy: AdvancedLinearProbingStrategy<String, DefaultHashFunction> =
   72|     31|                AdvancedLinearProbingStrategy::new(DefaultHashFunction);
   73|       |
   74|     31|            let mut probe_sequence = Vec::new();
   75|     31|            let mut unique_positions = std::collections::HashSet::new();
   76|       |
   77|    337|            for i in 0..self.max_probes.min(table_size) {
                                      ^31             ^31 ^31
   78|    337|                let pos = strategy.probe_hash(&key.to_string(), i, table_size);
   79|    337|                probe_sequence.push(pos);
   80|    337|                unique_positions.insert(pos);
   81|       |
   82|       |                // For linear probing, period is table_size
   83|    337|                if i > 0 && pos == probe_sequence[0] {
                                          ^306
   84|      0|                    break;
   85|    337|                }
   86|       |            }
   87|       |
   88|     31|            let collision_pattern = self.analyze_collision_pattern(&probe_sequence);
   89|     31|            let sequence_length = probe_sequence.len();
   90|       |
   91|     31|            ProbeSequenceVisualization {
   92|     31|                strategy_name: "Linear Probing".to_string(),
   93|     31|                key: key.to_string(),
   94|     31|                table_size,
   95|     31|                probe_sequence,
   96|     31|                sequence_length,
   97|     31|                unique_positions: unique_positions.len(),
   98|     31|                period: table_size, // Linear probing always has period = table_size
   99|     31|                collision_pattern,
  100|     31|            }
  101|     31|        }
  102|       |
  103|       |        /// Analyze quadratic probing sequence
  104|       |        /// Claude Work: (min(max_probes, m)), Span: (min(max_probes, m))
  105|     32|        pub fn analyze_quadratic_probing(&self, key: &str, table_size: N, c1: N, c2: N) -> ProbeSequenceVisualization {
  106|     32|            let strategy: AdvancedQuadraticProbingStrategy<String, DefaultHashFunction> =
  107|     32|                AdvancedQuadraticProbingStrategy::new_with_coefficients(DefaultHashFunction, c1, c2);
  108|       |
  109|     32|            let mut probe_sequence = Vec::new();
  110|     32|            let mut unique_positions = std::collections::HashSet::new();
  111|     32|            let mut period = 0;
  112|       |
  113|    420|            for i in 0..self.max_probes.min(table_size) {
                                      ^32             ^32 ^32
  114|    420|                let pos = strategy.probe_hash(&key.to_string(), i, table_size);
  115|    420|                probe_sequence.push(pos);
  116|       |
  117|    420|                if unique_positions.contains(&pos) && period == 0 {
                                                                    ^195
  118|     32|                    period = i;
  119|    388|                }
  120|    420|                unique_positions.insert(pos);
  121|       |            }
  122|       |
  123|     32|            if period == 0 {
  124|      0|                period = probe_sequence.len();
  125|     32|            }
  126|       |
  127|     32|            let collision_pattern = self.analyze_collision_pattern(&probe_sequence);
  128|     32|            let sequence_length = probe_sequence.len();
  129|       |
  130|     32|            ProbeSequenceVisualization {
  131|     32|                strategy_name: format!("Quadratic Probing (c1={}, c2={})", c1, c2),
  132|     32|                key: key.to_string(),
  133|     32|                table_size,
  134|     32|                probe_sequence,
  135|     32|                sequence_length,
  136|     32|                unique_positions: unique_positions.len(),
  137|     32|                period,
  138|     32|                collision_pattern,
  139|     32|            }
  140|     32|        }
  141|       |
  142|       |        /// Analyze double hashing sequence
  143|       |        /// Claude Work: (min(max_probes, m)), Span: (min(max_probes, m))
  144|     27|        pub fn analyze_double_hashing(&self, key: &str, table_size: N) -> ProbeSequenceVisualization {
  145|     27|            let strategy: AdvancedDoubleHashingStrategy<String, DefaultHashFunction, DefaultHashFunction> =
  146|     27|                AdvancedDoubleHashingStrategy::new(DefaultHashFunction, DefaultHashFunction);
  147|       |
  148|     27|            let probe_sequence = strategy.generate_probe_sequence(&key.to_string(), table_size, self.max_probes);
  149|     27|            let unique_positions: std::collections::HashSet<_> = probe_sequence.iter().cloned().collect();
  150|       |
  151|       |            // Calculate period for double hashing
  152|     27|            let (_h1_value, h2_value) = strategy.get_hash_values(&key.to_string(), table_size);
  153|     27|            let h2_value = if h2_value == 0 { 1 } else { h2_value };
                                                            ^2         ^25
  154|     27|            let period = RelativePrimeValidator::probe_sequence_period(h2_value, table_size);
  155|       |
  156|     27|            let collision_pattern = self.analyze_collision_pattern(&probe_sequence);
  157|     27|            let sequence_length = probe_sequence.len();
  158|       |
  159|     27|            ProbeSequenceVisualization {
  160|     27|                strategy_name: "Double Hashing".to_string(),
  161|     27|                key: key.to_string(),
  162|     27|                table_size,
  163|     27|                probe_sequence,
  164|     27|                sequence_length,
  165|     27|                unique_positions: unique_positions.len(),
  166|     27|                period,
  167|     27|                collision_pattern,
  168|     27|            }
  169|     27|        }
  170|       |
  171|       |        /// Analyze collision pattern in probe sequence
  172|       |        /// Claude Work: (n), Span: (n) where n is sequence length
  173|     90|        fn analyze_collision_pattern(&self, sequence: &[N]) -> String {
  174|     90|            if sequence.len() <= 1 {
  175|      1|                return "No collisions".to_string();
  176|     89|            }
  177|       |
  178|     89|            let mut pattern = String::new();
  179|     89|            let mut consecutive_count = 1;
  180|       |
  181|  1.20k|            for i in 1..sequence.len() {
                                      ^89      ^89
  182|  1.20k|                if sequence[i] == (sequence[i - 1] + 1) % sequence.len() {
  183|    370|                    consecutive_count += 1;
  184|    370|                } else {
  185|    837|                    if consecutive_count > 1 {
  186|     32|                        pattern.push_str(&format!("Cluster of {} consecutive positions; ", consecutive_count));
  187|    805|                    }
  188|    837|                    consecutive_count = 1;
  189|       |                }
  190|       |            }
  191|       |
  192|     89|            if consecutive_count > 1 {
  193|     33|                pattern.push_str(&format!("Final cluster of {} consecutive positions", consecutive_count));
  194|     56|            }
  195|       |
  196|     89|            if pattern.is_empty() {
  197|     27|                "Scattered positions (good distribution)".to_string()
  198|       |            } else {
  199|     62|                pattern
  200|       |            }
  201|     90|        }
  202|       |
  203|       |        /// Compare all three probing strategies for a given key and table size
  204|       |        /// Claude Work: (min(max_probes, m)), Span: (min(max_probes, m))
  205|     12|        pub fn compare_probing_strategies(&self, key: &str, table_size: N) -> Vec<ProbeSequenceVisualization> {
  206|     12|            vec![
  207|     12|                self.analyze_linear_probing(key, table_size),
  208|     12|                self.analyze_quadratic_probing(key, table_size, 1, 1),
  209|     12|                self.analyze_double_hashing(key, table_size),
  210|       |            ]
  211|     12|        }
  212|       |    }
  213|       |
  214|       |    impl Display for ProbeSequenceVisualization {
  215|      0|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  216|      0|            writeln!(f, "=== {} ===", self.strategy_name)?;
  217|      0|            writeln!(f, "Key: '{}', Table size: {}", self.key, self.table_size)?;
  218|      0|            writeln!(f, "Probe sequence: {:?}", self.probe_sequence)?;
  219|      0|            writeln!(
  220|      0|                f,
  221|      0|                "Sequence length: {}, Unique positions: {}, Period: {}",
  222|       |                self.sequence_length, self.unique_positions, self.period
  223|      0|            )?;
  224|      0|            write!(f, "Collision pattern: {}", self.collision_pattern)
  225|      0|        }
  226|       |    }
  227|       |
  228|       |    impl Display for TextbookExampleResults {
  229|      0|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  230|      0|            writeln!(f, "=== {} ===", self.example_name)?;
  231|      0|            writeln!(f, "{}", self.description)?;
  232|      0|            writeln!(f, "Table size: {}", self.table_size)?;
  233|      0|            writeln!(f, "Test keys: {:?}", self.keys)?;
  234|      0|            writeln!(f)?;
  235|       |
  236|      0|            for probe_viz in &self.probe_sequences {
  237|      0|                writeln!(f, "{}", probe_viz)?;
  238|      0|                writeln!(f)?;
  239|       |            }
  240|       |
  241|      0|            writeln!(f, "Clustering Analysis:")?;
  242|      0|            writeln!(f, "{}", self.clustering_analysis)?;
  243|      0|            writeln!(f)?;
  244|      0|            writeln!(f, "Performance Summary:")?;
  245|      0|            write!(f, "{}", self.performance_summary)
  246|      0|        }
  247|       |    }
  248|       |
  249|       |    /// Textbook Example 47.4: Linear Probing Demonstration
  250|       |    /// Shows primary clustering with keys that hash to consecutive positions
  251|       |    /// Claude Work: (k * m), Span: (k * m) where k is number of keys
  252|      2|    pub fn example_47_4_linear_probing_clustering() -> TextbookExampleResults {
  253|      2|        let analyzer = ProbeSequenceAnalyzer::new();
  254|      2|        let table_size = 11; // Prime table size
  255|      2|        let keys = vec!["key1".to_string(), "key2".to_string(), "key3".to_string()];
  256|       |
  257|      2|        let mut probe_sequences = Vec::new();
  258|      8|        for key in &keys {
                          ^6
  259|      6|            probe_sequences.push(analyzer.analyze_linear_probing(key, table_size));
  260|      6|        }
  261|       |
  262|      2|        let clustering_analysis = "Linear probing exhibits primary clustering where keys that hash to the same \
  263|      2|             or nearby positions form contiguous clusters. This leads to longer probe sequences \
  264|      2|             as the cluster grows, degrading performance significantly at high load factors."
  265|      2|            .to_string();
  266|       |
  267|      2|        let performance_summary = "Expected probes for unsuccessful search: 1/(1-). For =0.5, this is 2 probes. \
  268|      2|             For =0.9, this increases to 10 probes, showing severe performance degradation."
  269|      2|            .to_string();
  270|       |
  271|      2|        TextbookExampleResults {
  272|      2|            example_name: "Example 47.4: Linear Probing Primary Clustering".to_string(),
  273|      2|            description: "Demonstrates how linear probing creates primary clusters that degrade performance"
  274|      2|                .to_string(),
  275|      2|            table_size,
  276|      2|            keys,
  277|      2|            probe_sequences,
  278|      2|            clustering_analysis,
  279|      2|            performance_summary,
  280|      2|        }
  281|      2|    }
  282|       |
  283|       |    /// Textbook Example 47.5: Quadratic Probing with Prime Table Size
  284|       |    /// Shows how quadratic probing avoids primary clustering but may have secondary clustering
  285|       |    /// Claude Work: (k * m), Span: (k * m) where k is number of keys
  286|      2|    pub fn example_47_5_quadratic_probing_prime_table() -> TextbookExampleResults {
  287|      2|        let analyzer = ProbeSequenceAnalyzer::new();
  288|      2|        let table_size = 17; // Prime table size
  289|      2|        let keys = vec!["alpha".to_string(), "beta".to_string(), "gamma".to_string()];
  290|       |
  291|      2|        let mut probe_sequences = Vec::new();
  292|      8|        for key in &keys {
                          ^6
  293|      6|            probe_sequences.push(analyzer.analyze_quadratic_probing(key, table_size, 1, 1));
  294|      6|        }
  295|       |
  296|      2|        let clustering_analysis = "Quadratic probing with prime table size avoids primary clustering by using \
  297|      2|             h_i(k) = (h(k) + i + i) mod m. Keys that hash to the same position will \
  298|      2|             follow the same probe sequence (secondary clustering), but different initial \
  299|      2|             positions lead to different probe patterns."
  300|      2|            .to_string();
  301|       |
  302|      2|        let performance_summary = "For prime table sizes with c  0, quadratic probing guarantees that the probe \
  303|      2|             sequence will visit at least (m+1)/2 distinct positions before repeating, \
  304|      2|             providing better distribution than linear probing."
  305|      2|            .to_string();
  306|       |
  307|      2|        TextbookExampleResults {
  308|      2|            example_name: "Example 47.5: Quadratic Probing with Prime Table".to_string(),
  309|      2|            description: "Shows quadratic probing behavior with prime table size m=17".to_string(),
  310|      2|            table_size,
  311|      2|            keys,
  312|      2|            probe_sequences,
  313|      2|            clustering_analysis,
  314|      2|            performance_summary,
  315|      2|        }
  316|      2|    }
  317|       |
  318|       |    /// Textbook Example 47.6: Double Hashing Optimal Distribution
  319|       |    /// Demonstrates how double hashing achieves near-optimal probe sequence distribution
  320|       |    /// Claude Work: (k * m), Span: (k * m) where k is number of keys
  321|      2|    pub fn example_47_6_double_hashing_optimal() -> TextbookExampleResults {
  322|      2|        let analyzer = ProbeSequenceAnalyzer::new();
  323|      2|        let table_size = 13; // Prime table size
  324|      2|        let keys = vec!["hash1".to_string(), "hash2".to_string(), "hash3".to_string()];
  325|       |
  326|      2|        let mut probe_sequences = Vec::new();
  327|      8|        for key in &keys {
                          ^6
  328|      6|            probe_sequences.push(analyzer.analyze_double_hashing(key, table_size));
  329|      6|        }
  330|       |
  331|      2|        let clustering_analysis = "Double hashing uses h_i(k) = (h(k) + ih(k)) mod m where h and h are \
  332|      2|             independent hash functions. When gcd(h(k), m) = 1, the probe sequence visits \
  333|      2|             all table positions before repeating, eliminating both primary and secondary clustering."
  334|      2|            .to_string();
  335|       |
  336|      2|        let performance_summary = "Double hashing achieves performance close to uniform hashing: expected probes \
  337|      2|             for unsuccessful search  1/(1-), and for successful search  (1/)ln(1/(1-)). \
  338|      2|             This is optimal among open addressing schemes."
  339|      2|            .to_string();
  340|       |
  341|      2|        TextbookExampleResults {
  342|      2|            example_name: "Example 47.6: Double Hashing Optimal Distribution".to_string(),
  343|      2|            description: "Demonstrates double hashing with h(k) = k mod m, h(k) = 1 + (k mod (m-1))".to_string(),
  344|      2|            table_size,
  345|      2|            keys,
  346|      2|            probe_sequences,
  347|      2|            clustering_analysis,
  348|      2|            performance_summary,
  349|      2|        }
  350|      2|    }
  351|       |
  352|       |    /// Comprehensive Probe Sequence Comparison
  353|       |    /// Compares all three strategies with the same keys and table size
  354|       |    /// Claude Work: (k * m), Span: (k * m) where k is number of keys
  355|      2|    pub fn comprehensive_probe_sequence_comparison() -> TextbookExampleResults {
  356|      2|        let analyzer = ProbeSequenceAnalyzer::new();
  357|      2|        let table_size = 11; // Prime table size
  358|      2|        let test_key = "comparison_test";
  359|       |
  360|      2|        let probe_sequences = analyzer.compare_probing_strategies(test_key, table_size);
  361|       |
  362|      2|        let clustering_analysis = "Comparison shows: (1) Linear probing creates consecutive probe sequences leading \
  363|      2|             to primary clustering. (2) Quadratic probing spreads probes more evenly but keys \
  364|      2|             with same h(k) follow identical sequences. (3) Double hashing provides maximum \
  365|      2|             distribution with different probe patterns for each key."
  366|      2|            .to_string();
  367|       |
  368|      2|        let performance_summary =
  369|      2|            "Performance ranking (best to worst): Double Hashing > Quadratic Probing > Linear Probing. \
  370|      2|             Double hashing maintains good performance even at high load factors, while linear \
  371|      2|             probing degrades rapidly beyond  = 0.7."
  372|      2|                .to_string();
  373|       |
  374|      2|        TextbookExampleResults {
  375|      2|            example_name: "Comprehensive Probe Sequence Comparison".to_string(),
  376|      2|            description: "Side-by-side comparison of all three probing strategies".to_string(),
  377|      2|            table_size,
  378|      2|            keys: vec![test_key.to_string()],
  379|      2|            probe_sequences,
  380|      2|            clustering_analysis,
  381|      2|            performance_summary,
  382|      2|        }
  383|      2|    }
  384|       |
  385|       |    /// Load Factor Impact Analysis
  386|       |    /// Shows how probe sequences change with different load factors
  387|       |    /// Claude Work: (f * k * m), Span: (f * k * m) where f is number of load factors
  388|      2|    pub fn load_factor_impact_analysis() -> Vec<(f64, Vec<ProbeSequenceVisualization>)> {
  389|      2|        let analyzer = ProbeSequenceAnalyzer::new();
  390|      2|        let load_factors = vec![0.25, 0.5, 0.75, 0.9];
  391|      2|        let table_size = 13;
  392|      2|        let test_key = "load_test";
  393|       |
  394|      2|        load_factors
  395|      2|            .into_iter()
  396|      8|            .map(|lf| {
                           ^2
  397|      8|                let sequences = analyzer.compare_probing_strategies(test_key, table_size);
  398|      8|                (lf, sequences)
  399|      8|            })
  400|      2|            .collect()
  401|      2|    }
  402|       |
  403|       |    /// Prime vs Composite Table Size Comparison
  404|       |    /// Demonstrates the importance of prime table sizes for quadratic probing
  405|       |    /// Claude Work: (k * m), Span: (k * m) where k is number of keys
  406|      2|    pub fn prime_vs_composite_table_comparison() -> (TextbookExampleResults, TextbookExampleResults) {
  407|      2|        let analyzer = ProbeSequenceAnalyzer::new();
  408|      2|        let test_key = "prime_test";
  409|       |
  410|       |        // Prime table size analysis
  411|      2|        let prime_size = 17;
  412|      2|        let prime_sequences = vec![analyzer.analyze_quadratic_probing(test_key, prime_size, 1, 1)];
  413|       |
  414|      2|        let prime_results = TextbookExampleResults {
  415|      2|            example_name: "Quadratic Probing with Prime Table Size".to_string(),
  416|      2|            description: format!("Analysis with prime table size m={}", prime_size),
  417|      2|            table_size: prime_size,
  418|      2|            keys: vec![test_key.to_string()],
  419|      2|            probe_sequences: prime_sequences,
  420|      2|            clustering_analysis: "Prime table size ensures good probe sequence distribution".to_string(),
  421|      2|            performance_summary: "Optimal quadratic probing performance".to_string(),
  422|      2|        };
  423|       |
  424|       |        // Composite table size analysis
  425|      2|        let composite_size = 16;
  426|      2|        let composite_sequences = vec![analyzer.analyze_quadratic_probing(test_key, composite_size, 1, 1)];
  427|       |
  428|      2|        let composite_results = TextbookExampleResults {
  429|      2|            example_name: "Quadratic Probing with Composite Table Size".to_string(),
  430|      2|            description: format!("Analysis with composite table size m={}", composite_size),
  431|      2|            table_size: composite_size,
  432|      2|            keys: vec![test_key.to_string()],
  433|      2|            probe_sequences: composite_sequences,
  434|      2|            clustering_analysis: "Composite table size may limit probe sequence coverage".to_string(),
  435|      2|            performance_summary: "Potentially degraded quadratic probing performance".to_string(),
  436|      2|        };
  437|       |
  438|      2|        (prime_results, composite_results)
  439|      2|    }
  440|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap47/QuadraticProbing.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 47: Quadratic Probing Strategy
    3|       |
    4|       |pub mod QuadraticProbing {
    5|       |
    6|       |use crate::Types::Types::*;
    7|       |use crate::Chap47::FlatHashTable::FlatHashTable::*;
    8|       |use crate::Chap47::HashFunctionTraits::HashFunctionTraits::*;
    9|       |    #[derive(Clone, Debug)]
   10|       |    pub struct QuadraticProbingStrategy<K: StT, H: HashFunClone<K>> {
   11|       |        base_hash: H,
   12|       |        c1: N,
   13|       |        c2: N,
   14|       |        _phantom: std::marker::PhantomData<K>,
   15|       |    }
   16|       |
   17|       |    impl<K: StT, H: HashFunClone<K>> QuadraticProbingStrategy<K, H> {
   18|     18|        pub fn new(hash_fn: H, c1: N, c2: N) -> Self {
   19|     18|            QuadraticProbingStrategy {
   20|     18|                base_hash: hash_fn,
   21|     18|                c1,
   22|     18|                c2,
   23|     18|                _phantom: std::marker::PhantomData,
   24|     18|            }
   25|     18|        }
   26|       |
   27|       |        /// Standard quadratic probing with c1=1, c2=1
   28|     13|        pub fn standard(hash_fn: H) -> Self { Self::new(hash_fn, 1, 1) }
   29|       |    }
   30|       |
   31|       |    impl<K: StT, H: HashFunClone<K>> ProbeSequence<K> for QuadraticProbingStrategy<K, H> {
   32|       |        /// Claude Work: (1), Span: (1)
   33|    966|        fn probe_hash(&self, key: &K, probe_index: N, table_size: N) -> N {
   34|    966|            let base_hash = self.base_hash.hash(key, table_size);
   35|    966|            let quadratic_offset = self.c1 * probe_index + self.c2 * probe_index * probe_index;
   36|    966|            (base_hash + quadratic_offset) % table_size
   37|    966|        }
   38|       |
   39|      5|        fn strategy_name(&self) -> String {
   40|      5|            format!(
   41|      5|                "QuadraticProbing({}, c1={}, c2={})",
   42|      5|                self.base_hash.description(),
   43|       |                self.c1,
   44|       |                self.c2
   45|       |            )
   46|      5|        }
   47|       |    }
   48|       |
   49|       |    /// Type alias for quadratic probing hash table
   50|       |    pub type QuadraticProbingHashTable<K, V, H> = FlatHashTable<K, V, QuadraticProbingStrategy<K, H>>;
   51|       |
   52|       |    /// Constructor functions for quadratic probing hash tables
   53|       |    /// APAS: Work (1), Span (1)
   54|     10|    pub fn create_quadratic_probing_string_table<V: StT>(
   55|     10|        initial_size: N,
   56|     10|    ) -> QuadraticProbingHashTable<String, V, StringPositionHashFunction> {
   57|     10|        let probe_strategy = QuadraticProbingStrategy::standard(StringPositionHashFunction);
   58|     10|        FlatHashTable::create_table(probe_strategy, initial_size)
   59|     10|    }
   60|       |
   61|       |    /// APAS: Work (1), Span (1)
   62|      2|    pub fn create_quadratic_probing_integer_table<V: StT>(
   63|      2|        initial_size: N,
   64|      2|        seed: u64,
   65|      2|    ) -> QuadraticProbingHashTable<i32, V, UniversalIntegerHashFunction> {
   66|      2|        let hash_family = UniversalIntegerHashFamily::new();
   67|      2|        let hash_fn = hash_family.generate(seed);
   68|      2|        let probe_strategy = QuadraticProbingStrategy::standard(hash_fn);
   69|      2|        FlatHashTable::create_table(probe_strategy, initial_size)
   70|      2|    }
   71|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap47/SeparateChaining.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 47: Separate Chaining implementation - Definition 47.3
    3|       |
    4|       |pub mod SeparateChaining {
    5|       |
    6|       |use std::fmt::{Debug, Display};
    7|       |
    8|       |use crate::Types::Types::*;
    9|       |use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
   10|       |use crate::Chap47::HashFunctionTraits::HashFunctionTraits::*;
   11|       |    #[derive(Clone, Debug)]
   12|       |    pub struct SeparateChainingHashTable<K, V, H, E>
   13|       |    where
   14|       |        K: StT,
   15|       |        V: StT,
   16|       |        H: HashFunction<K> + Clone,
   17|       |        E: KeyEquality<K> + Clone,
   18|       |    {
   19|       |        buckets: ArraySeqStPerS<ArraySeqStPerS<Pair<K, V>>>,
   20|       |        hash_function: H,
   21|       |        key_equality: E,
   22|       |        num_elements: N,
   23|       |        load_factor_manager: LoadFactorManager,
   24|       |    }
   25|       |
   26|       |    impl<K, V, H, E> SeparateChainingHashTable<K, V, H, E>
   27|       |    where
   28|       |        K: StT,
   29|       |        V: StT,
   30|       |        H: HashFunction<K> + Clone,
   31|       |        E: KeyEquality<K> + Clone,
   32|       |    {
   33|       |        /// Claude Work: (m), Span: (m)
   34|     24|        pub fn create_table(eq_fn: E, hash_fn: H, initial_size: N) -> Self {
   35|     24|            let size = initial_size.max(8);
   36|     24|            let mut buckets = ArraySeqStPerS::empty();
   37|       |
   38|    448|            for _ in 0..size {
                                      ^24
   39|    448|                let empty_chain = ArraySeqStPerS::empty();
   40|    448|                let single_seq = ArraySeqStPerS::singleton(empty_chain);
   41|    448|                buckets = ArraySeqStPerS::append(&buckets, &single_seq);
   42|    448|            }
   43|       |
   44|     24|            SeparateChainingHashTable {
   45|     24|                buckets,
   46|     24|                hash_function: hash_fn,
   47|     24|                key_equality: eq_fn,
   48|     24|                num_elements: 0,
   49|     24|                load_factor_manager: LoadFactorManager::new(0.75, 0.25),
   50|     24|            }
   51|     24|        }
   52|       |
   53|       |        /// Claude Work: (1) expected, Span: (1) expected
   54|       |        /// Insert at head of chain - constant time
   55|    122|        pub fn insert(&self, key: K, value: V) -> Self {
   56|    122|            let table_size = self.buckets.length();
   57|    122|            let hash_code = self.hash_function.hash(&key, table_size);
   58|    122|            let chain = self.buckets.nth(hash_code);
   59|       |
   60|       |            // Check if key exists and remove old entry
   61|    122|            let mut new_chain = ArraySeqStPerS::empty();
   62|    122|            let mut key_existed = false;
   63|       |
   64|    122|            for i in 0..chain.length() {
                              ^70
   65|     70|                let pair = chain.nth(i);
   66|     70|                if !self.key_equality.eq(&pair.0, &key) {
   67|     69|                    let single_seq = ArraySeqStPerS::singleton(pair.clone());
   68|     69|                    new_chain = ArraySeqStPerS::append(&new_chain, &single_seq);
   69|     69|                } else {
   70|      1|                    key_existed = true;
   71|      1|                }
   72|       |            }
   73|       |
   74|       |            // Add new entry at head
   75|    122|            let new_pair = Pair(key, value);
   76|    122|            let new_head = ArraySeqStPerS::singleton(new_pair);
   77|    122|            new_chain = ArraySeqStPerS::append(&new_head, &new_chain);
   78|       |
   79|       |            // Update buckets
   80|    122|            let mut new_buckets = ArraySeqStPerS::empty();
   81|  2.95k|            for i in 0..table_size {
                                      ^122
   82|  2.95k|                let bucket_to_use = if i == hash_code {
   83|    122|                    new_chain.clone()
   84|       |                } else {
   85|  2.83k|                    self.buckets.nth(i).clone()
   86|       |                };
   87|  2.95k|                let single_seq = ArraySeqStPerS::singleton(bucket_to_use);
   88|  2.95k|                new_buckets = ArraySeqStPerS::append(&new_buckets, &single_seq);
   89|       |            }
   90|       |
   91|    122|            let new_num_elements = if key_existed {
   92|      1|                self.num_elements
   93|       |            } else {
   94|    121|                self.num_elements + 1
   95|       |            };
   96|       |
   97|    122|            let mut result = SeparateChainingHashTable {
   98|    122|                buckets: new_buckets,
   99|    122|                hash_function: self.hash_function.clone(),
  100|    122|                key_equality: self.key_equality.clone(),
  101|    122|                num_elements: new_num_elements,
  102|    122|                load_factor_manager: self.load_factor_manager.clone(),
  103|    122|            };
  104|       |
  105|       |            // Check resize
  106|    122|            if result.load_factor_manager.should_grow(result.num_elements, table_size) {
  107|      9|                let new_size = result.load_factor_manager.grow_size(table_size);
  108|      9|                result = result.resize(new_size);
  109|    113|            }
  110|       |
  111|    122|            result
  112|    122|        }
  113|       |
  114|       |        /// Claude Work: (1 + ) expected, Span: (1 + ) expected
  115|       |        /// Linear search through chain
  116|     99|        pub fn lookup(&self, key: &K) -> Option<&V> {
  117|     99|            let table_size = self.buckets.length();
  118|     99|            let hash_code = self.hash_function.hash(key, table_size);
  119|     99|            let chain = self.buckets.nth(hash_code);
  120|       |
  121|    113|            for i in 0..chain.length() {
                                      ^99   ^99
  122|    113|                let pair = chain.nth(i);
  123|    113|                if self.key_equality.eq(&pair.0, key) {
  124|     95|                    return Some(&pair.1);
  125|     18|                }
  126|       |            }
  127|       |
  128|      4|            None
  129|     99|        }
  130|       |
  131|       |        /// Claude Work: (1 + ) expected, Span: (1 + ) expected
  132|      3|        pub fn delete(&self, key: &K) -> (Self, bool) {
  133|      3|            let table_size = self.buckets.length();
  134|      3|            let hash_code = self.hash_function.hash(key, table_size);
  135|      3|            let chain = self.buckets.nth(hash_code);
  136|       |
  137|      3|            let mut new_chain = ArraySeqStPerS::empty();
  138|      3|            let mut was_deleted = false;
  139|       |
  140|      3|            for i in 0..chain.length() {
                              ^2
  141|      2|                let pair = chain.nth(i);
  142|      2|                if !self.key_equality.eq(&pair.0, key) {
  143|      1|                    let single_seq = ArraySeqStPerS::singleton(pair.clone());
  144|      1|                    new_chain = ArraySeqStPerS::append(&new_chain, &single_seq);
  145|      1|                } else {
  146|      1|                    was_deleted = true;
  147|      1|                }
  148|       |            }
  149|       |
  150|      3|            if !was_deleted {
  151|      2|                return (self.clone(), false);
  152|      1|            }
  153|       |
  154|      1|            let mut new_buckets = ArraySeqStPerS::empty();
  155|      8|            for i in 0..table_size {
                                      ^1
  156|      8|                let bucket_to_use = if i == hash_code {
  157|      1|                    new_chain.clone()
  158|       |                } else {
  159|      7|                    self.buckets.nth(i).clone()
  160|       |                };
  161|      8|                let single_seq = ArraySeqStPerS::singleton(bucket_to_use);
  162|      8|                new_buckets = ArraySeqStPerS::append(&new_buckets, &single_seq);
  163|       |            }
  164|       |
  165|      1|            let mut result = SeparateChainingHashTable {
  166|      1|                buckets: new_buckets,
  167|      1|                hash_function: self.hash_function.clone(),
  168|      1|                key_equality: self.key_equality.clone(),
  169|      1|                num_elements: self.num_elements - 1,
  170|      1|                load_factor_manager: self.load_factor_manager.clone(),
  171|      1|            };
  172|       |
  173|       |            // Check resize down
  174|      1|            if result
  175|      1|                .load_factor_manager
  176|      1|                .should_shrink(result.num_elements, table_size)
  177|      0|            {
  178|      0|                let new_size = result.load_factor_manager.shrink_size(table_size);
  179|      0|                result = result.resize(new_size);
  180|      1|            }
  181|       |
  182|      1|            (result, true)
  183|      3|        }
  184|       |
  185|       |        /// Claude Work: (n), Span: (n)
  186|      9|        pub fn resize(&self, new_size: N) -> Self {
  187|      9|            let actual_new_size = new_size.max(8);
  188|      9|            let mut new_table =
  189|      9|                Self::create_table(self.key_equality.clone(), self.hash_function.clone(), actual_new_size);
  190|       |
  191|       |            // Rehash all elements
  192|    160|            for i in 0..self.buckets.length() {
                                      ^9           ^9
  193|    160|                let chain = self.buckets.nth(i);
  194|    160|                for j in 0..chain.length() {
                                  ^129
  195|    129|                    let pair = chain.nth(j);
  196|    129|                    new_table = new_table.insert_without_resize(pair.0.clone(), pair.1.clone());
  197|    129|                }
  198|       |            }
  199|       |
  200|      9|            new_table
  201|      9|        }
  202|       |
  203|    129|        fn insert_without_resize(&self, key: K, value: V) -> Self {
  204|    129|            let table_size = self.buckets.length();
  205|    129|            let hash_code = self.hash_function.hash(&key, table_size);
  206|    129|            let chain = self.buckets.nth(hash_code);
  207|       |
  208|    129|            let mut new_chain = ArraySeqStPerS::empty();
  209|    129|            let mut key_existed = false;
  210|       |
  211|    129|            for i in 0..chain.length() {
                              ^30
  212|     30|                let pair = chain.nth(i);
  213|     30|                if !self.key_equality.eq(&pair.0, &key) {
  214|     30|                    let single_seq = ArraySeqStPerS::singleton(pair.clone());
  215|     30|                    new_chain = ArraySeqStPerS::append(&new_chain, &single_seq);
  216|     30|                } else {
  217|      0|                    key_existed = true;
  218|      0|                }
  219|       |            }
  220|       |
  221|    129|            let new_pair = Pair(key, value);
  222|    129|            let new_head = ArraySeqStPerS::singleton(new_pair);
  223|    129|            new_chain = ArraySeqStPerS::append(&new_head, &new_chain);
  224|       |
  225|    129|            let mut new_buckets = ArraySeqStPerS::empty();
  226|  8.96k|            for i in 0..table_size {
                                      ^129
  227|  8.96k|                let bucket_to_use = if i == hash_code {
  228|    129|                    new_chain.clone()
  229|       |                } else {
  230|  8.83k|                    self.buckets.nth(i).clone()
  231|       |                };
  232|  8.96k|                let single_seq = ArraySeqStPerS::singleton(bucket_to_use);
  233|  8.96k|                new_buckets = ArraySeqStPerS::append(&new_buckets, &single_seq);
  234|       |            }
  235|       |
  236|    129|            let new_num_elements = if key_existed {
  237|      0|                self.num_elements
  238|       |            } else {
  239|    129|                self.num_elements + 1
  240|       |            };
  241|       |
  242|    129|            SeparateChainingHashTable {
  243|    129|                buckets: new_buckets,
  244|    129|                hash_function: self.hash_function.clone(),
  245|    129|                key_equality: self.key_equality.clone(),
  246|    129|                num_elements: new_num_elements,
  247|    129|                load_factor_manager: self.load_factor_manager.clone(),
  248|    129|            }
  249|    129|        }
  250|       |
  251|     12|        pub fn load_and_size(&self) -> (N, N) { (self.num_elements, self.buckets.length()) }
  252|       |
  253|      9|        pub fn statistics(&self) -> HashTableStats {
  254|      9|            let mut total_collisions = 0;
  255|      9|            let mut max_chain_length = 0;
  256|      9|            let mut non_empty_buckets = 0;
  257|      9|            let mut total_chain_length = 0;
  258|       |
  259|    112|            for i in 0..self.buckets.length() {
                                      ^9           ^9
  260|    112|                let chain = self.buckets.nth(i);
  261|    112|                let chain_length = chain.length();
  262|       |
  263|    112|                if chain_length > 0 {
  264|     45|                    non_empty_buckets += 1;
  265|     45|                    total_chain_length += chain_length;
  266|       |
  267|     45|                    if chain_length > 1 {
  268|     10|                        total_collisions += chain_length - 1;
  269|     35|                    }
  270|       |
  271|     45|                    max_chain_length = max_chain_length.max(chain_length);
  272|     67|                }
  273|       |            }
  274|       |
  275|      9|            let avg_chain_length = if non_empty_buckets > 0 {
  276|      7|                total_chain_length as f64 / non_empty_buckets as f64
  277|       |            } else {
  278|      2|                0.0
  279|       |            };
  280|       |
  281|      9|            HashTableStats::new(self.num_elements, self.buckets.length()).with_collision_stats(
  282|      9|                total_collisions,
  283|      9|                max_chain_length,
  284|      9|                avg_chain_length,
  285|       |            )
  286|      9|        }
  287|       |    }
  288|       |
  289|       |    /// Type aliases for common configurations
  290|       |    pub type StringSeparateChaining<V> =
  291|       |        SeparateChainingHashTable<String, V, StringPositionHashFunction, DefaultKeyEquality>;
  292|       |
  293|      5|    pub fn create_example_47_2_table() -> StringSeparateChaining<String> {
  294|      5|        let mut table = SeparateChainingHashTable::create_table(DefaultKeyEquality, StringPositionHashFunction, 5);
  295|       |
  296|       |        // Example 47.2 data
  297|      5|        table = table.insert("aa".to_string(), "a".to_string());
  298|      5|        table = table.insert("bb".to_string(), "b".to_string());
  299|      5|        table = table.insert("cc".to_string(), "c".to_string());
  300|      5|        table = table.insert("dd".to_string(), "d".to_string());
  301|      5|        table = table.insert("ee".to_string(), "e".to_string());
  302|      5|        table = table.insert("ff".to_string(), "f".to_string());
  303|      5|        table = table.insert("gg".to_string(), "g".to_string());
  304|      5|        table = table.insert("hh".to_string(), "h".to_string());
  305|      5|        table = table.insert("ii".to_string(), "i".to_string());
  306|      5|        table = table.insert("jj".to_string(), "j".to_string());
  307|       |
  308|      5|        table
  309|      5|    }
  310|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap47clean/ChainedHashTable.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chained Hash Table - Sequential Ephemeral (Chapter 47).
    3|       |//! Uses separate chaining for collision resolution.
    4|       |
    5|       |pub mod ChainedHashTable {
    6|       |
    7|       |    use crate::Chap47clean::ParaHashTableStEph::ParaHashTableStEph::*;
    8|       |    use crate::Types::Types::*;
    9|       |
   10|       |    /// Parametric entry type for chained hash tables.
   11|       |    /// Container type is abstract - can be Vec, LinkedList, Seq, etc.
   12|       |    #[derive(Clone, Debug, PartialEq)]
   13|       |    pub struct ChainEntry<Key, Value, Container> {
   14|       |        pub chain: Container,
   15|       |        pub _phantom: std::marker::PhantomData<(Key, Value)>,
   16|       |    }
   17|       |
   18|       |    /// Chained Hash Table trait - extends ParaHashTableStEphTrait.
   19|       |    /// Uses separate chaining (linked lists or sequences) for collision resolution.
   20|       |    /// Entry type is parametric - can be ChainEntry, LinkedList, or any type implementing EntryTrait.
   21|       |    pub trait ChainedHashTable<Key: StT, Value: StT, Entry: EntryTrait<Key, Value>, Metrics: Default>:
   22|       |        ParaHashTableStEphTrait<Key, Value, Entry, Metrics>
   23|       |    {
   24|       |        /// Computes the hash index for a key.
   25|       |        /// APAS: Work O(1), Span O(1).
   26|       |        fn hash_index(table: &HashTable<Key, Value, Entry, Metrics>, key: &Key) -> N;
   27|       |
   28|       |        /// Inserts into the chain at the hashed bucket.
   29|       |        /// APAS: Work O(1) expected, Span O(1).
   30|      9|        fn insert_chained(table: &mut HashTable<Key, Value, Entry, Metrics>, key: Key, value: Value) {
   31|      9|            let index = Self::hash_index(table, &key);
   32|      9|            if index < table.table.len() {
   33|      9|                table.table[index].insert(key, value);
   34|      9|            }
                          ^0
   35|      9|        }
   36|       |
   37|       |        /// Looks up in the chain at the hashed bucket.
   38|       |        /// APAS: Work O(1) expected, Span O(1).
   39|      9|        fn lookup_chained(table: &HashTable<Key, Value, Entry, Metrics>, key: &Key) -> Option<Value> {
   40|      9|            let index = Self::hash_index(table, &key);
   41|      9|            if index < table.table.len() {
   42|      9|                table.table[index].lookup(key)
   43|       |            } else {
   44|      0|                None
   45|       |            }
   46|      9|        }
   47|       |
   48|       |        /// Deletes from the chain at the hashed bucket.
   49|       |        /// APAS: Work O(1) expected, Span O(1).
   50|      3|        fn delete_chained(table: &mut HashTable<Key, Value, Entry, Metrics>, key: &Key) -> B {
   51|      3|            let index = Self::hash_index(table, &key);
   52|      3|            if index < table.table.len() {
   53|      3|                table.table[index].delete(key)
   54|       |            } else {
   55|      0|                false
   56|       |            }
   57|      3|        }
   58|       |    }
   59|       |}
   60|       |

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap47clean/DoubleHashFlatHashTable.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Double Hashing Flat Hash Table - Sequential Ephemeral (Chapter 47).
    3|       |//! Uses double hashing for open addressing collision resolution.
    4|       |
    5|       |pub mod DoubleHashFlatHashTable {
    6|       |
    7|       |    use crate::Chap47clean::ParaHashTableStEph::ParaHashTableStEph::*;
    8|       |    use crate::Chap47clean::FlatHashTable::FlatHashTable::*;
    9|       |    use crate::Types::Types::*;
   10|       |
   11|       |    /// Double Hashing Flat Hash Table implementation.
   12|       |    /// Probe sequence: h_i(k) = (h(k) + ihh(k)) mod m
   13|       |    /// Uses two hash functions to avoid both primary and secondary clustering.
   14|       |    pub struct DoubleHashFlatHashTableStEph;
   15|       |
   16|       |    impl DoubleHashFlatHashTableStEph {
   17|       |        /// Compute second hash value for double hashing.
   18|       |        /// APAS: hh(k) must be relatively prime to m.
   19|       |        /// Strategy: Always return an odd number (works for power-of-2 sizes),
   20|       |        /// and for prime sizes, ensure < m and non-zero.
   21|    259|        pub fn second_hash<Key: StT>(key: &Key, table_size: N) -> N {
   22|       |            // APAS: hh(k) must be non-zero and coprime to m
   23|       |            // Use key bytes directly instead of memory address
   24|       |            
   25|    259|            if table_size <= 2 {
   26|      0|                return 1;
   27|    259|            }
   28|       |            
   29|       |            // Compute hash from key bytes using FNV-1a algorithm
   30|    259|            let key_ptr = key as *const Key as *const u8;
   31|    259|            let key_size = std::mem::size_of::<Key>();
   32|    259|            let mut hash: u64 = 0xcbf29ce484222325; // FNV offset basis
   33|       |            
   34|       |            unsafe {
   35|  1.03k|                for i in 0..key_size {
                                          ^259
   36|  1.03k|                    let byte = *key_ptr.add(i);
   37|  1.03k|                    hash ^= byte as u64;
   38|  1.03k|                    hash = hash.wrapping_mul(0x100000001b3); // FNV prime
   39|  1.03k|                }
   40|       |            }
   41|       |            
   42|       |            // For prime table sizes, use: step = 1 + (hash % (m-1))
   43|       |            // This ensures 1 <= step < m and step != 0
   44|    259|            let base = (table_size - 1) as u64;
   45|    259|            let mut step = ((hash % base) + 1) as N;
   46|       |            
   47|       |            // Ensure odd for power-of-2 coprimality
   48|    259|            if step % 2 == 0 && step < table_size - 1 {
                                              ^116
   49|    104|                step += 1;
   50|    155|            }
   51|       |            
   52|    259|            step
   53|    259|        }
   54|       |    }
   55|       |
   56|       |    impl<Key: StT, Value: StT, Metrics: Default> 
   57|       |        ParaHashTableStEphTrait<Key, Value, FlatEntry<Key, Value>, Metrics> 
   58|       |        for DoubleHashFlatHashTableStEph
   59|       |    {
   60|     18|        fn insert(table: &mut HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: Key, value: Value) {
   61|     18|            let slot = Self::find_slot(table, &key);
   62|     18|            match &table.table[slot] {
   63|      1|                FlatEntry::Occupied(k, _) if k == &key => {
   64|      1|                    table.table[slot] = FlatEntry::Occupied(key, value);
   65|      1|                }
   66|     17|                FlatEntry::Empty | FlatEntry::Deleted => {
   67|     17|                    table.table[slot] = FlatEntry::Occupied(key, value);
   68|     17|                    table.num_elements += 1;
   69|     17|                }
   70|      0|                _ => {
   71|      0|                    table.table[slot] = FlatEntry::Occupied(key, value);
   72|      0|                    table.num_elements += 1;
   73|      0|                }
   74|       |            }
   75|     18|        }
   76|       |
   77|     17|        fn lookup(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> Option<Value> {
   78|     17|            let mut attempt = 0;
   79|     19|            while attempt < table.current_size {
   80|     19|                let slot = Self::probe(table, key, attempt);
   81|     19|                match &table.table[slot] {
   82|     14|                    FlatEntry::Occupied(k, v) if k == key => return Some(v.clone()),
   83|      3|                    FlatEntry::Empty => return None,
   84|      2|                    FlatEntry::Deleted | FlatEntry::Occupied(_, _) => {
   85|      2|                        attempt += 1;
   86|      2|                    }
   87|       |                }
   88|       |            }
   89|      0|            None
   90|     17|        }
   91|       |
   92|      3|        fn delete(table: &mut HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> B {
   93|      3|            let mut attempt = 0;
   94|      4|            while attempt < table.current_size {
   95|      4|                let slot = Self::probe(table, key, attempt);
   96|      4|                match &table.table[slot] {
   97|      2|                    FlatEntry::Occupied(k, _) if k == key => {
   98|      2|                        table.table[slot] = FlatEntry::Deleted;
   99|      2|                        table.num_elements -= 1;
  100|      2|                        return true;
  101|       |                    }
  102|      1|                    FlatEntry::Empty => return false,
  103|      1|                    FlatEntry::Deleted | FlatEntry::Occupied(_, _) => {
  104|      1|                        attempt += 1;
  105|      1|                    }
  106|       |                }
  107|       |            }
  108|      0|            false
  109|      3|        }
  110|       |    }
  111|       |
  112|       |    impl<Key: StT, Value: StT, Metrics: Default> 
  113|       |        FlatHashTable<Key, Value, FlatEntry<Key, Value>, Metrics> 
  114|       |        for DoubleHashFlatHashTableStEph
  115|       |    {
  116|     56|        fn probe(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key, attempt: N) -> N {
  117|     56|            let hash1 = (table.hash_fn)(key);
  118|     56|            let step = Self::second_hash(key, table.current_size);
  119|       |            
  120|       |            // Double hashing: (h1(key) + ih2(key)) mod size
  121|     56|            (hash1 + (attempt * step)) % table.current_size
  122|     56|        }
  123|       |
  124|     19|        fn find_slot(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> N {
  125|     19|            let mut attempt = 0;
  126|     19|            while attempt < table.current_size {
  127|     19|                let slot = Self::probe(table, key, attempt);
  128|     19|                match &table.table[slot] {
  129|     18|                    FlatEntry::Empty | FlatEntry::Deleted => return slot,
  130|      1|                    FlatEntry::Occupied(k, _) if k == key => return slot,
  131|      0|                    _ => attempt += 1,
  132|       |                }
  133|       |            }
  134|      0|            Self::probe(table, key, 0)
  135|     19|        }
  136|       |    }
  137|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap47clean/FlatHashTable.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Flat Hash Table - Sequential Ephemeral (Chapter 47).
    3|       |//! Uses open addressing for collision resolution.
    4|       |
    5|       |pub mod FlatHashTable {
    6|       |
    7|       |    use crate::Chap47clean::ParaHashTableStEph::ParaHashTableStEph::*;
    8|       |    use crate::Types::Types::*;
    9|       |
   10|       |    /// Entry type for flat hash tables using open addressing.
   11|       |    /// Represents the three states a slot can be in.
   12|       |    #[derive(Clone, Debug, PartialEq)]
   13|       |    pub enum FlatEntry<Key, Value> {
   14|       |        /// Empty slot - never occupied
   15|       |        Empty,
   16|       |        /// Occupied slot with key-value pair
   17|       |        Occupied(Key, Value),
   18|       |        /// Deleted slot - previously occupied, now available for insertion
   19|       |        Deleted,
   20|       |    }
   21|       |
   22|       |    impl<Key: PartialEq + Clone, Value: Clone> EntryTrait<Key, Value> for FlatEntry<Key, Value> {
   23|      0|        fn new() -> Self { FlatEntry::Empty }
   24|      0|        fn insert(&mut self, key: Key, value: Value) { *self = FlatEntry::Occupied(key, value); }
   25|       |
   26|      0|        fn lookup(&self, key: &Key) -> Option<Value> {
   27|      0|            match self {
   28|      0|                FlatEntry::Occupied(k, v) if k == key => Some(v.clone()),
   29|      0|                _ => None,
   30|       |            }
   31|      0|        }
   32|       |
   33|      0|        fn delete(&mut self, key: &Key) -> B {
   34|      0|            match self {
   35|      0|                FlatEntry::Occupied(k, _) if k == key => {
   36|      0|                    *self = FlatEntry::Deleted;
   37|      0|                    true
   38|       |                }
   39|      0|                _ => false,
   40|       |            }
   41|      0|        }
   42|       |    }
   43|       |
   44|       |    /// Flat Hash Table trait - extends ParaHashTableStEphTrait.
   45|       |    /// Uses open addressing (linear probing, quadratic probing, double hashing).
   46|       |    /// Entry type is parametric - can be FlatEntry or any type implementing EntryTrait.
   47|       |    pub trait FlatHashTable<Key: StT, Value: StT, Entry: EntryTrait<Key, Value>, Metrics: Default>:
   48|       |        ParaHashTableStEphTrait<Key, Value, Entry, Metrics>
   49|       |    {
   50|       |        /// Probes for the next slot in the sequence.
   51|       |        /// APAS: Work O(1), Span O(1).
   52|       |        fn probe(table: &HashTable<Key, Value, Entry, Metrics>, key: &Key, attempt: N) -> N;
   53|       |
   54|       |        /// Finds the first available slot (Empty or Deleted) for insertion.
   55|       |        /// APAS: Work O(1) expected, Span O(1).
   56|       |        fn find_slot(table: &HashTable<Key, Value, Entry, Metrics>, key: &Key) -> N;
   57|       |
   58|       |        /// Inserts using linear probing as default.
   59|       |        /// APAS: Work O(1) expected, Span O(1).
   60|      0|        fn insert_with_probe(table: &mut HashTable<Key, Value, Entry, Metrics>, key: Key, value: Value) {
   61|      0|            let slot = Self::find_slot(table, &key);
   62|      0|            if slot < table.table.len() {
   63|      0|                table.table[slot].insert(key, value);
   64|      0|            }
   65|      0|        }
   66|       |
   67|       |        /// Looks up using probe sequence.
   68|       |        /// APAS: Work O(1) expected, Span O(1).
   69|      0|        fn lookup_with_probe(table: &HashTable<Key, Value, Entry, Metrics>, key: &Key) -> Option<Value> {
   70|      0|            for attempt in 0..table.current_size {
   71|      0|                let slot = Self::probe(table, key, attempt);
   72|      0|                if slot < table.table.len() {
   73|      0|                    if let Some(val) = table.table[slot].lookup(key) {
   74|      0|                        return Some(val);
   75|      0|                    }
   76|      0|                }
   77|       |            }
   78|      0|            None
   79|      0|        }
   80|       |    }
   81|       |}
   82|       |

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap47clean/LinProbFlatHashTable.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Linear Probing Flat Hash Table - Sequential Ephemeral (Chapter 47).
    3|       |//! Uses linear probing for open addressing collision resolution.
    4|       |
    5|       |pub mod LinProbFlatHashTable {
    6|       |
    7|       |    use crate::Chap47clean::ParaHashTableStEph::ParaHashTableStEph::*;
    8|       |    use crate::Chap47clean::FlatHashTable::FlatHashTable::*;
    9|       |    use crate::Types::Types::*;
   10|       |
   11|       |    /// Linear Probing Flat Hash Table implementation.
   12|       |    pub struct LinProbFlatHashTableStEph;
   13|       |
   14|       |    impl<Key: StT, Value: StT, Metrics: Default> 
   15|       |        ParaHashTableStEphTrait<Key, Value, FlatEntry<Key, Value>, Metrics> 
   16|       |        for LinProbFlatHashTableStEph
   17|       |    {
   18|      3|        fn insert(table: &mut HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: Key, value: Value) {
   19|      3|            let slot = Self::find_slot(table, &key);
   20|      3|            match &table.table[slot] {
   21|      0|                FlatEntry::Occupied(k, _) if k == &key => {
   22|      0|                    // Update existing
   23|      0|                    table.table[slot] = FlatEntry::Occupied(key, value);
   24|      0|                }
   25|      3|                FlatEntry::Empty | FlatEntry::Deleted => {
   26|      3|                    // Insert new
   27|      3|                    table.table[slot] = FlatEntry::Occupied(key, value);
   28|      3|                    table.num_elements += 1;
   29|      3|                }
   30|      0|                _ => {
   31|      0|                    // This shouldn't happen if find_slot works correctly
   32|      0|                    table.table[slot] = FlatEntry::Occupied(key, value);
   33|      0|                    table.num_elements += 1;
   34|      0|                }
   35|       |            }
   36|      3|        }
   37|       |
   38|      3|        fn lookup(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> Option<Value> {
   39|      3|            let mut attempt = 0;
   40|      5|            while attempt < table.current_size {
   41|      5|                let slot = Self::probe(table, key, attempt);
   42|      5|                match &table.table[slot] {
   43|      3|                    FlatEntry::Occupied(k, v) if k == key => return Some(v.clone()),
                                                                      ^2          ^2
   44|      1|                    FlatEntry::Empty => return None, // Stop at Empty - key not in table
   45|      2|                    FlatEntry::Deleted | FlatEntry::Occupied(_, _) => {
   46|      2|                        // Continue probing past Deleted or non-matching Occupied
   47|      2|                        attempt += 1;
   48|      2|                    }
   49|       |                }
   50|       |            }
   51|      0|            None
   52|      3|        }
   53|       |
   54|      1|        fn delete(table: &mut HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> B {
   55|      1|            let mut attempt = 0;
   56|      1|            while attempt < table.current_size {
   57|      1|                let slot = Self::probe(table, key, attempt);
   58|      1|                match &table.table[slot] {
   59|      1|                    FlatEntry::Occupied(k, _) if k == key => {
   60|       |                        // Mark as Deleted (tombstone) to maintain probe chain integrity
   61|      1|                        table.table[slot] = FlatEntry::Deleted;
   62|      1|                        table.num_elements -= 1;
   63|      1|                        return true;
   64|       |                    }
   65|      0|                    FlatEntry::Empty => return false, // Key not found, stop at Empty
   66|      0|                    FlatEntry::Deleted | FlatEntry::Occupied(_, _) => {
   67|      0|                        // Continue probing
   68|      0|                        attempt += 1;
   69|      0|                    }
   70|       |                }
   71|       |            }
   72|      0|            false
   73|      1|        }
   74|       |    }
   75|       |
   76|       |    impl<Key: StT, Value: StT, Metrics: Default> 
   77|       |        FlatHashTable<Key, Value, FlatEntry<Key, Value>, Metrics> 
   78|       |        for LinProbFlatHashTableStEph
   79|       |    {
   80|     13|        fn probe(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key, attempt: N) -> N {
   81|     13|            let hash_val = (table.hash_fn)(key);
   82|       |            
   83|       |            // Linear probing: (hash(key) + attempt) mod size
   84|     13|            (hash_val + attempt) % table.current_size
   85|     13|        }
   86|       |
   87|      4|        fn find_slot(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> N {
   88|       |            // Find first Empty or Deleted slot (can reuse Deleted slots for insertion)
   89|      4|            let mut attempt = 0;
   90|      5|            while attempt < table.current_size {
   91|      5|                let slot = Self::probe(table, key, attempt);
   92|      5|                match &table.table[slot] {
   93|      4|                    FlatEntry::Empty | FlatEntry::Deleted => return slot,
   94|      1|                    FlatEntry::Occupied(k, _) if k == key => return slot, // Update existing key
                                                                      ^0          ^0
   95|      1|                    _ => attempt += 1,
   96|       |                }
   97|       |            }
   98|       |            // Table full - return first slot as fallback (shouldn't happen with proper load factor)
   99|      0|            Self::probe(table, key, 0)
  100|      4|        }
  101|       |    }
  102|       |}
  103|       |

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap47clean/LinkedListChainedHashTable.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! LinkedList Chained Hash Table - Sequential Ephemeral (Chapter 47).
    3|       |//! Uses LinkedList for separate chaining collision resolution.
    4|       |
    5|       |pub mod LinkedListChainedHashTable {
    6|       |
    7|       |    use std::collections::LinkedList;
    8|       |    use crate::Chap47clean::ParaHashTableStEph::ParaHashTableStEph::*;
    9|       |    use crate::Chap47clean::ChainedHashTable::ChainedHashTable::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    impl<Key: PartialEq + Clone, Value: Clone> EntryTrait<Key, Value> for LinkedList<(Key, Value)> {
   13|      4|        fn new() -> Self { LinkedList::new() }
   14|       |
   15|      8|        fn insert(&mut self, key: Key, value: Value) {
   16|       |            // Update if key exists, otherwise append
   17|      8|            for (k, v) in self.iter_mut() {
                               ^3 ^3
   18|      3|                if k == &key {
   19|      1|                    *v = value;
   20|      1|                    return;
   21|      2|                }
   22|       |            }
   23|      7|            self.push_back((key, value));
   24|      8|        }
   25|       |
   26|      7|        fn lookup(&self, key: &Key) -> Option<Value> {
   27|      7|            for (k, v) in self.iter() {
   28|      7|                if k == key {
   29|      5|                    return Some(v.clone());
   30|      2|                }
   31|       |            }
   32|      2|            None
   33|      7|        }
   34|       |
   35|      2|        fn delete(&mut self, key: &Key) -> B {
   36|      2|            let mut found_idx = None;
   37|      2|            for (idx, (k, _)) in self.iter().enumerate() {
   38|      2|                if k == key {
   39|      2|                    found_idx = Some(idx);
   40|      2|                    break;
   41|      0|                }
   42|       |            }
   43|      2|            if let Some(idx) = found_idx {
   44|      2|                let mut split_off = self.split_off(idx);
   45|      2|                split_off.pop_front();
   46|      2|                self.append(&mut split_off);
   47|      2|                true
   48|       |            } else {
   49|      0|                false
   50|       |            }
   51|      2|        }
   52|       |    }
   53|       |
   54|       |    /// LinkedList Chained Hash Table implementation.
   55|       |    pub struct LinkedListChainedHashTableStEph;
   56|       |
   57|       |    impl<Key: StT, Value: StT, Metrics: Default> 
   58|       |        ParaHashTableStEphTrait<Key, Value, LinkedList<(Key, Value)>, Metrics> 
   59|       |        for LinkedListChainedHashTableStEph
   60|       |    {
   61|      3|        fn insert(table: &mut HashTable<Key, Value, LinkedList<(Key, Value)>, Metrics>, key: Key, value: Value) {
   62|      3|            Self::insert_chained(table, key, value);
   63|      3|        }
   64|       |
   65|      3|        fn lookup(table: &HashTable<Key, Value, LinkedList<(Key, Value)>, Metrics>, key: &Key) -> Option<Value> {
   66|      3|            Self::lookup_chained(table, key)
   67|      3|        }
   68|       |
   69|      1|        fn delete(table: &mut HashTable<Key, Value, LinkedList<(Key, Value)>, Metrics>, key: &Key) -> B {
   70|      1|            Self::delete_chained(table, key)
   71|      1|        }
   72|       |    }
   73|       |
   74|       |    impl<Key: StT, Value: StT, Metrics: Default> 
   75|       |        ChainedHashTable<Key, Value, LinkedList<(Key, Value)>, Metrics> 
   76|       |        for LinkedListChainedHashTableStEph
   77|       |    {
   78|      7|        fn hash_index(table: &HashTable<Key, Value, LinkedList<(Key, Value)>, Metrics>, _key: &Key) -> N {
   79|       |            // Simple modulo hash - implementers can provide better hash function
   80|      7|            let hash_val = 0; // Placeholder: would use actual hash function
   81|      7|            hash_val % table.current_size
   82|      7|        }
   83|       |    }
   84|       |}
   85|       |

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap47clean/ParaHashTableStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Parametric Nested Hash Table - Sequential Ephemeral (Chapter 47, Section 1.1).
    3|       |//! A parametric implementation of hash tables using nested tables.
    4|       |//! Work: insert O(1), lookup O(1), delete O(1) expected with constant load factor.
    5|       |//! Span: O(1) (sequential).
    6|       |
    7|       |pub mod ParaHashTableStEph {
    8|       |
    9|       |    use std::fmt::Display;
   10|       |    use std::marker::PhantomData;
   11|       |
   12|       |    use crate::Types::Types::*;
   13|       |
   14|       |    pub type HashFun<K> = Box<dyn Fn(&K) -> N>;
   15|       |
   16|       |    #[derive(Clone, Copy, Debug, PartialEq)]
   17|       |    pub struct LoadAndSize {
   18|       |        pub load: f64,
   19|       |        pub size: N,
   20|       |    }
   21|       |
   22|       |    /// Parametric nested hash table structure.
   23|       |    pub struct HashTable<Key, Value, Entry, Metrics> {
   24|       |        pub table: Vec<Entry>,
   25|       |        pub hash_fn: HashFun<Key>,
   26|       |        pub initial_size: N,
   27|       |        pub current_size: N,
   28|       |        pub num_elements: N,
   29|       |        pub metrics: Metrics,
   30|       |        pub _phantom: PhantomData<(Key, Value)>,
   31|       |    }
   32|       |
   33|       |    /// Trait for parametric nested hash tables.
   34|       |    /// Entry type must implement this trait to define how Key and Value are stored.
   35|       |    pub trait EntryTrait<Key, Value> {
   36|       |        fn new() -> Self;
   37|       |        fn insert(&mut self, key: Key, value: Value);
   38|       |        fn lookup(&self, key: &Key) -> Option<Value>;
   39|       |        fn delete(&mut self, key: &Key) -> B;
   40|       |    }
   41|       |
   42|       |    /// Trait for parametric nested hash tables.
   43|       |    pub trait ParaHashTableStEphTrait<Key: StT, Value: StT, Entry: EntryTrait<Key, Value>, Metrics: Default>
   44|       |    {
   45|       |        /// Creates an empty hash table with the given initial size.
   46|       |        /// APAS: Work O(m), Span O(m) where m is initial size.
   47|     29|        fn createTable(hash_fn: HashFun<Key>, initial_size: N) -> HashTable<Key, Value, Entry, Metrics> {
   48|     29|            HashTable {
   49|     29|                table: Vec::<Entry>::with_capacity(initial_size),
   50|     29|                hash_fn,
   51|     29|                initial_size,
   52|     29|                current_size: initial_size,
   53|     29|                num_elements: 0,
   54|     29|                metrics: Metrics::default(),
   55|     29|                _phantom: PhantomData,
   56|     29|            }
   57|     29|        }
   58|       |
   59|       |        /// Inserts a key-value pair into the hash table.
   60|       |        /// APAS: Work O(1) expected, Span O(1).
   61|       |        fn insert(table: &mut HashTable<Key, Value, Entry, Metrics>, key: Key, value: Value);
   62|       |
   63|       |        /// Looks up a key in the hash table, returning its value if found.
   64|       |        /// APAS: Work O(1) expected, Span O(1).
   65|       |        fn lookup(table: &HashTable<Key, Value, Entry, Metrics>, key: &Key) -> Option<Value>;
   66|       |
   67|       |        /// Deletes a key from the hash table if it exists.
   68|       |        /// APAS: Work O(1) expected, Span O(1).
   69|       |        fn delete(table: &mut HashTable<Key, Value, Entry, Metrics>, key: &Key) -> B;
   70|       |
   71|       |        /// Accessor for metrics field.
   72|      1|        fn metrics(table: &HashTable<Key, Value, Entry, Metrics>) -> &Metrics { &table.metrics }
   73|       |
   74|       |        /// Returns the load (number of entries) and size (table capacity).
   75|       |        /// APAS: Work O(1), Span O(1).
   76|       |        /// Load factor  = load/size = num_elements/size
   77|      2|        fn loadAndSize(table: &HashTable<Key, Value, Entry, Metrics>) -> LoadAndSize {
   78|      2|            let load_factor = if table.current_size == 0 {
   79|      0|                0.0
   80|       |            } else {
   81|      2|                table.num_elements as f64 / table.current_size as f64
   82|       |            };
   83|      2|            LoadAndSize {
   84|      2|                load: load_factor,
   85|      2|                size: table.current_size,
   86|      2|            }
   87|      2|        }
   88|       |    }
   89|       |}
   90|       | 

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap47clean/QuadProbFlatHashTable.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Quadratic Probing Flat Hash Table - Sequential Ephemeral (Chapter 47).
    3|       |//! Uses quadratic probing for open addressing collision resolution.
    4|       |
    5|       |pub mod QuadProbFlatHashTable {
    6|       |
    7|       |    use crate::Chap47clean::ParaHashTableStEph::ParaHashTableStEph::*;
    8|       |    use crate::Chap47clean::FlatHashTable::FlatHashTable::*;
    9|       |    use crate::Types::Types::*;
   10|       |
   11|       |    /// Quadratic Probing Flat Hash Table implementation.
   12|       |    /// Probe sequence: h_i(k) = (h(k) + i) mod m
   13|       |    pub struct QuadProbFlatHashTableStEph;
   14|       |
   15|       |    impl<Key: StT, Value: StT, Metrics: Default> 
   16|       |        ParaHashTableStEphTrait<Key, Value, FlatEntry<Key, Value>, Metrics> 
   17|       |        for QuadProbFlatHashTableStEph
   18|       |    {
   19|     30|        fn insert(table: &mut HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: Key, value: Value) {
   20|     30|            let slot = Self::find_slot(table, &key);
   21|     30|            match &table.table[slot] {
   22|      2|                FlatEntry::Occupied(k, _) if k == &key => {
                                                                   ^1
   23|      1|                    // Update existing
   24|      1|                    table.table[slot] = FlatEntry::Occupied(key, value);
   25|      1|                }
   26|     28|                FlatEntry::Empty | FlatEntry::Deleted => {
   27|     28|                    // Insert new
   28|     28|                    table.table[slot] = FlatEntry::Occupied(key, value);
   29|     28|                    table.num_elements += 1;
   30|     28|                }
   31|      1|                _ => {
   32|      1|                    table.table[slot] = FlatEntry::Occupied(key, value);
   33|      1|                    table.num_elements += 1;
   34|      1|                }
   35|       |            }
   36|     30|        }
   37|       |
   38|     19|        fn lookup(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> Option<Value> {
   39|     19|            let mut attempt = 0;
   40|     19|            let max_attempts = (table.current_size + 1) / 2; // APAS Lemma 47.1: first m/2 probes are distinct
   41|     38|            while attempt < max_attempts {
   42|     38|                let slot = Self::probe(table, key, attempt);
   43|     38|                match &table.table[slot] {
   44|     34|                    FlatEntry::Occupied(k, v) if k == key => return Some(v.clone()),
                                                                      ^17         ^17
   45|      2|                    FlatEntry::Empty => return None,
   46|     19|                    FlatEntry::Deleted | FlatEntry::Occupied(_, _) => {
   47|     19|                        attempt += 1;
   48|     19|                    }
   49|       |                }
   50|       |            }
   51|      0|            None
   52|     19|        }
   53|       |
   54|      3|        fn delete(table: &mut HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> B {
   55|      3|            let mut attempt = 0;
   56|      3|            let max_attempts = (table.current_size + 1) / 2; // APAS Lemma 47.1: first m/2 probes are distinct
   57|      5|            while attempt < max_attempts {
   58|      5|                let slot = Self::probe(table, key, attempt);
   59|      5|                match &table.table[slot] {
   60|      3|                    FlatEntry::Occupied(k, _) if k == key => {
                                                                      ^2
   61|      2|                        table.table[slot] = FlatEntry::Deleted;
   62|      2|                        table.num_elements -= 1;
   63|      2|                        return true;
   64|       |                    }
   65|      1|                    FlatEntry::Empty => return false,
   66|      2|                    FlatEntry::Deleted | FlatEntry::Occupied(_, _) => {
   67|      2|                        attempt += 1;
   68|      2|                    }
   69|       |                }
   70|       |            }
   71|      0|            false
   72|      3|        }
   73|       |    }
   74|       |
   75|       |    impl<Key: StT, Value: StT, Metrics: Default> 
   76|       |        FlatHashTable<Key, Value, FlatEntry<Key, Value>, Metrics> 
   77|       |        for QuadProbFlatHashTableStEph
   78|       |    {
   79|    103|        fn probe(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key, attempt: N) -> N {
   80|    103|            let hash_val = (table.hash_fn)(key);
   81|       |            
   82|       |            // Quadratic probing: (hash(key) + i) mod size
   83|    103|            (hash_val + (attempt * attempt)) % table.current_size
   84|    103|        }
   85|       |
   86|     31|        fn find_slot(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> N {
   87|     31|            let mut attempt = 0;
   88|     31|            let max_attempts = (table.current_size + 1) / 2; // APAS Lemma 47.1: first m/2 probes are distinct
   89|     56|            while attempt < max_attempts {
   90|     55|                let slot = Self::probe(table, key, attempt);
   91|     55|                match &table.table[slot] {
   92|     29|                    FlatEntry::Empty | FlatEntry::Deleted => return slot,
   93|     26|                    FlatEntry::Occupied(k, _) if k == key => return slot,
                                                                      ^1          ^1
   94|     25|                    _ => attempt += 1,
   95|       |                }
   96|       |            }
   97|      1|            Self::probe(table, key, 0)
   98|     31|        }
   99|       |    }
  100|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap47clean/StructChainedHashTable.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Struct Chained Hash Table - Sequential Ephemeral (Chapter 47).
    3|       |//! Uses custom linked list struct for separate chaining collision resolution.
    4|       |
    5|       |pub mod StructChainedHashTable {
    6|       |
    7|       |    use crate::Chap47clean::ParaHashTableStEph::ParaHashTableStEph::*;
    8|       |    use crate::Chap47clean::ChainedHashTable::ChainedHashTable::*;
    9|       |    use crate::Types::Types::*;
   10|       |
   11|       |    /// Custom linked list node.
   12|       |    #[derive(Clone, Debug, PartialEq)]
   13|       |    pub struct Node<Key, Value> {
   14|       |        pub key: Key,
   15|       |        pub value: Value,
   16|       |        pub next: Option<Box<Node<Key, Value>>>,
   17|       |    }
   18|       |
   19|       |    /// Custom linked list for chained hash table.
   20|       |    #[derive(Clone, Debug, PartialEq)]
   21|       |    pub struct ChainList<Key, Value> {
   22|       |        pub head: Option<Box<Node<Key, Value>>>,
   23|       |    }
   24|       |
   25|       |    impl<Key, Value> ChainList<Key, Value> {
   26|     26|        pub fn new() -> Self { ChainList { head: None } }
   27|       |    }
   28|       |
   29|       |    impl<Key: PartialEq + Clone, Value: Clone> EntryTrait<Key, Value> for ChainList<Key, Value> {
   30|      5|        fn new() -> Self { ChainList::new() }
   31|       |
   32|     12|        fn insert(&mut self, key: Key, value: Value) {
   33|       |            // Search for existing key and update
   34|     12|            let mut current = &mut self.head;
   35|     17|            while let Some(node) = current {
                                         ^6
   36|      6|                if node.key == key {
   37|      1|                    node.value = value;
   38|      1|                    return;
   39|      5|                }
   40|      5|                current = &mut node.next;
   41|       |            }
   42|       |            // Key not found, insert at head
   43|     11|            let new_node = Box::new(Node {
   44|     11|                key,
   45|     11|                value,
   46|     11|                next: self.head.take(),
   47|     11|            });
   48|     11|            self.head = Some(new_node);
   49|     12|        }
   50|       |
   51|     10|        fn lookup(&self, key: &Key) -> Option<Value> {
   52|     10|            let mut current = &self.head;
   53|     15|            while let Some(node) = current {
                                         ^13
   54|     13|                if &node.key == key {
   55|      8|                    return Some(node.value.clone());
   56|      5|                }
   57|      5|                current = &node.next;
   58|       |            }
   59|      2|            None
   60|     10|        }
   61|       |
   62|      3|        fn delete(&mut self, key: &Key) -> B {
   63|      3|            let mut current = &mut self.head;
   64|       |            loop {
   65|      4|                match current {
   66|      1|                    None => return false,
   67|      4|                    Some(node) if &node.key == key => {
                                                               ^2
   68|      2|                        *current = node.next.take();
   69|      2|                        return true;
   70|       |                    }
   71|      2|                    Some(node) => {
   72|      2|                        current = &mut node.next;
   73|      2|                    }
   74|       |                }
   75|       |            }
   76|      3|        }
   77|       |    }
   78|       |
   79|       |    /// Struct Chained Hash Table implementation.
   80|       |    pub struct StructChainedHashTableStEph;
   81|       |
   82|       |    impl<Key: StT, Value: StT, Metrics: Default> 
   83|       |        ParaHashTableStEphTrait<Key, Value, ChainList<Key, Value>, Metrics> 
   84|       |        for StructChainedHashTableStEph
   85|       |    {
   86|      3|        fn insert(table: &mut HashTable<Key, Value, ChainList<Key, Value>, Metrics>, key: Key, value: Value) {
   87|      3|            Self::insert_chained(table, key, value);
   88|      3|        }
   89|       |
   90|      3|        fn lookup(table: &HashTable<Key, Value, ChainList<Key, Value>, Metrics>, key: &Key) -> Option<Value> {
   91|      3|            Self::lookup_chained(table, key)
   92|      3|        }
   93|       |
   94|      1|        fn delete(table: &mut HashTable<Key, Value, ChainList<Key, Value>, Metrics>, key: &Key) -> B {
   95|      1|            Self::delete_chained(table, key)
   96|      1|        }
   97|       |    }
   98|       |
   99|       |    impl<Key: StT, Value: StT, Metrics: Default> 
  100|       |        ChainedHashTable<Key, Value, ChainList<Key, Value>, Metrics> 
  101|       |        for StructChainedHashTableStEph
  102|       |    {
  103|      7|        fn hash_index(table: &HashTable<Key, Value, ChainList<Key, Value>, Metrics>, _key: &Key) -> N {
  104|       |            // Simple modulo hash - implementers can provide better hash function
  105|      7|            let hash_val = 0; // Placeholder: would use actual hash function
  106|      7|            hash_val % table.current_size
  107|      7|        }
  108|       |    }
  109|       |}
  110|       |

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap47clean/VecChainedHashTable.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Vec Chained Hash Table - Sequential Ephemeral (Chapter 47).
    3|       |//! Uses Vec for separate chaining collision resolution.
    4|       |
    5|       |pub mod VecChainedHashTable {
    6|       |
    7|       |    use crate::Chap47clean::ParaHashTableStEph::ParaHashTableStEph::*;
    8|       |    use crate::Chap47clean::ChainedHashTable::ChainedHashTable::*;
    9|       |    use crate::Types::Types::*;
   10|       |
   11|       |    impl<Key: PartialEq + Clone, Value: Clone> EntryTrait<Key, Value> for Vec<(Key, Value)> {
   12|      4|        fn new() -> Self { Vec::new() }
   13|       |
   14|      8|        fn insert(&mut self, key: Key, value: Value) {
   15|       |            // Update if key exists, otherwise append
   16|      8|            for (k, v) in self.iter_mut() {
                               ^3 ^3
   17|      3|                if k == &key {
   18|      1|                    *v = value;
   19|      1|                    return;
   20|      2|                }
   21|       |            }
   22|      7|            self.push((key, value));
   23|      8|        }
   24|       |
   25|      7|        fn lookup(&self, key: &Key) -> Option<Value> {
   26|      7|            for (k, v) in self.iter() {
   27|      7|                if k == key {
   28|      5|                    return Some(v.clone());
   29|      2|                }
   30|       |            }
   31|      2|            None
   32|      7|        }
   33|       |
   34|      2|        fn delete(&mut self, key: &Key) -> B {
   35|      2|            if let Some(pos) = self.iter().position(|(k, _)| k == key) {
   36|      2|                self.remove(pos);
   37|      2|                true
   38|       |            } else {
   39|      0|                false
   40|       |            }
   41|      2|        }
   42|       |    }
   43|       |
   44|       |    /// Vec Chained Hash Table implementation.
   45|       |    pub struct VecChainedHashTableStEph;
   46|       |
   47|       |    impl<Key: StT, Value: StT, Metrics: Default> 
   48|       |        ParaHashTableStEphTrait<Key, Value, Vec<(Key, Value)>, Metrics> 
   49|       |        for VecChainedHashTableStEph
   50|       |    {
   51|      3|        fn insert(table: &mut HashTable<Key, Value, Vec<(Key, Value)>, Metrics>, key: Key, value: Value) {
   52|      3|            Self::insert_chained(table, key, value);
   53|      3|        }
   54|       |
   55|      3|        fn lookup(table: &HashTable<Key, Value, Vec<(Key, Value)>, Metrics>, key: &Key) -> Option<Value> {
   56|      3|            Self::lookup_chained(table, key)
   57|      3|        }
   58|       |
   59|      1|        fn delete(table: &mut HashTable<Key, Value, Vec<(Key, Value)>, Metrics>, key: &Key) -> B {
   60|      1|            Self::delete_chained(table, key)
   61|      1|        }
   62|       |    }
   63|       |
   64|       |    impl<Key: StT, Value: StT, Metrics: Default> 
   65|       |        ChainedHashTable<Key, Value, Vec<(Key, Value)>, Metrics> 
   66|       |        for VecChainedHashTableStEph
   67|       |    {
   68|      7|        fn hash_index(table: &HashTable<Key, Value, Vec<(Key, Value)>, Metrics>, _key: &Key) -> N {
   69|       |            // Simple modulo hash - implementers can provide better hash function
   70|      7|            let hash_val = 0; // Placeholder: would use actual hash function
   71|      7|            hash_val % table.current_size
   72|      7|        }
   73|       |    }
   74|       |}
   75|       |

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap49/MinEditDistMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 49: Minimum Edit Distance - ephemeral, multi-threaded.
    3|       |
    4|       |pub mod MinEditDistMtEph {
    5|       |
    6|       |    use std::collections::HashMap;
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    8|       |    use std::sync::{Arc, Mutex};
    9|       |    use std::thread;
   10|       |
   11|       |    use crate::ArraySeqMtEphSLit;
   12|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
   13|       |    use crate::Types::Types::*;
   14|       |
   15|       |    #[derive(Clone, Debug)]
   16|       |    pub struct MinEditDistMtEphS<T: MtVal> {
   17|       |        source: ArraySeqMtEphS<T>,
   18|       |        target: ArraySeqMtEphS<T>,
   19|       |        memo: Arc<Mutex<HashMap<(usize, usize), usize>>>,
   20|       |    }
   21|       |
   22|       |    /// Trait for parallel minimum edit distance operations
   23|       |    pub trait MinEditDistMtEphTrait<T: MtVal> {
   24|       |        /// Create new minimum edit distance solver
   25|       |        fn new() -> Self
   26|       |        where
   27|       |            T: Default;
   28|       |
   29|       |        /// Create from source and target sequences
   30|       |        fn from_sequences(source: ArraySeqMtEphS<T>, target: ArraySeqMtEphS<T>) -> Self;
   31|       |
   32|       |        /// claude-4-sonet: Work (|S||T|), Span (|S|+|T|), Parallelism (min(|S|,|T|))
   33|       |        /// Compute minimum edit distance with parallel DP where |S|=source length, |T|=target length
   34|       |        fn min_edit_distance(&mut self) -> usize
   35|       |        where
   36|       |            T: Send + Sync + 'static;
   37|       |
   38|       |        /// Get the source sequence
   39|       |        fn source(&self) -> &ArraySeqMtEphS<T>;
   40|       |
   41|       |        /// Get the target sequence
   42|       |        fn target(&self) -> &ArraySeqMtEphS<T>;
   43|       |
   44|       |        /// Get mutable source sequence (ephemeral allows mutation)
   45|       |        fn source_mut(&mut self) -> &mut ArraySeqMtEphS<T>;
   46|       |
   47|       |        /// Get mutable target sequence (ephemeral allows mutation)
   48|       |        fn target_mut(&mut self) -> &mut ArraySeqMtEphS<T>;
   49|       |
   50|       |        /// Set element in source sequence
   51|       |        fn set_source(&mut self, index: usize, value: T);
   52|       |
   53|       |        /// Set element in target sequence
   54|       |        fn set_target(&mut self, index: usize, value: T);
   55|       |
   56|       |        /// Clear memoization table
   57|       |        fn clear_memo(&mut self);
   58|       |
   59|       |        /// Get memoization table size
   60|       |        fn memo_size(&self) -> usize;
   61|       |    }
   62|       |
   63|       |    impl<T: MtVal> MinEditDistMtEphS<T> {
   64|       |        /// Internal parallel recursive minimum edit distance with shared memoization
   65|       |        /// Claude Work: O(|S|*|T|) - each subproblem computed once across all threads
   66|       |        /// Claude Span: O(|S|+|T|) - maximum recursion depth, parallelism O(min(|S|,|T|))
   67|    241|        fn min_edit_distance_rec(&self, i: usize, j: usize) -> usize
   68|    241|        where
   69|    241|            T: Send + Sync + 'static,
   70|       |        {
   71|       |            // Check memo first (thread-safe)
   72|       |            {
   73|    241|                let memo_guard = self.memo.lock().unwrap();
   74|    241|                if let Some(&result) = memo_guard.get(&(i, j)) {
                                           ^68
   75|     68|                    return result;
   76|    173|                }
   77|       |            }
   78|       |
   79|    173|            let result = match (i, j) {
   80|     27|                | (i, 0) => i, // Base case: need i deletions
   81|     22|                | (0, j) => j, // Base case: need j insertions
   82|    124|                | (i, j) => {
   83|    124|                    let source_char = self.source.nth_cloned(i - 1);
   84|    124|                    let target_char = self.target.nth_cloned(j - 1);
   85|       |
   86|    124|                    if source_char == target_char {
   87|       |                        // Characters match, no edit needed
   88|     23|                        self.min_edit_distance_rec(i - 1, j - 1)
   89|       |                    } else {
   90|       |                        // Parallel evaluation of both operations
   91|    101|                        let self_clone1 = self.clone();
   92|    101|                        let self_clone2 = self.clone();
   93|       |
   94|    101|                        let handle1 = thread::spawn(move || self_clone1.min_edit_distance_rec(i - 1, j));
   95|       |
   96|    101|                        let handle2 = thread::spawn(move || self_clone2.min_edit_distance_rec(i, j - 1));
   97|       |
   98|    101|                        let delete_cost = handle1.join().unwrap();
   99|    101|                        let insert_cost = handle2.join().unwrap();
  100|       |
  101|    101|                        1 + std::cmp::min(delete_cost, insert_cost)
  102|       |                    }
  103|       |                }
  104|       |            };
  105|       |
  106|       |            // Memoize result (thread-safe)
  107|    173|            {
  108|    173|                let mut memo_guard = self.memo.lock().unwrap();
  109|    173|                memo_guard.insert((i, j), result);
  110|    173|            }
  111|       |
  112|    173|            result
  113|    241|        }
  114|       |    }
  115|       |
  116|       |    impl<T: MtVal> MinEditDistMtEphTrait<T> for MinEditDistMtEphS<T> {
  117|      1|        fn new() -> Self
  118|      1|        where
  119|      1|            T: Default,
  120|       |        {
  121|      1|            Self {
  122|      1|                source: ArraySeqMtEphS::new(0, T::default()),
  123|      1|                target: ArraySeqMtEphS::new(0, T::default()),
  124|      1|                memo: Arc::new(Mutex::new(HashMap::new())),
  125|      1|            }
  126|      1|        }
  127|       |
  128|     27|        fn from_sequences(source: ArraySeqMtEphS<T>, target: ArraySeqMtEphS<T>) -> Self {
  129|     27|            Self {
  130|     27|                source,
  131|     27|                target,
  132|     27|                memo: Arc::new(Mutex::new(HashMap::new())),
  133|     27|            }
  134|     27|        }
  135|       |
  136|     16|        fn min_edit_distance(&mut self) -> usize
  137|     16|        where
  138|     16|            T: Send + Sync + 'static,
  139|       |        {
  140|       |            // Clear memo for fresh computation
  141|     16|            {
  142|     16|                let mut memo_guard = self.memo.lock().unwrap();
  143|     16|                memo_guard.clear();
  144|     16|            }
  145|       |
  146|     16|            let source_len = self.source.length();
  147|     16|            let target_len = self.target.length();
  148|       |
  149|     16|            self.min_edit_distance_rec(source_len, target_len)
  150|     16|        }
  151|       |
  152|      9|        fn source(&self) -> &ArraySeqMtEphS<T> { &self.source }
  153|       |
  154|      8|        fn target(&self) -> &ArraySeqMtEphS<T> { &self.target }
  155|       |
  156|      1|        fn source_mut(&mut self) -> &mut ArraySeqMtEphS<T> { &mut self.source }
  157|       |
  158|      1|        fn target_mut(&mut self) -> &mut ArraySeqMtEphS<T> { &mut self.target }
  159|       |
  160|      2|        fn set_source(&mut self, index: usize, value: T) {
  161|      2|            let _ = self.source.set(index, value);
  162|       |            // Clear memo since source changed
  163|      2|            let mut memo_guard = self.memo.lock().unwrap();
  164|      2|            memo_guard.clear();
  165|      2|        }
  166|       |
  167|      1|        fn set_target(&mut self, index: usize, value: T) {
  168|      1|            let _ = self.target.set(index, value);
  169|       |            // Clear memo since target changed
  170|      1|            let mut memo_guard = self.memo.lock().unwrap();
  171|      1|            memo_guard.clear();
  172|      1|        }
  173|       |
  174|      1|        fn clear_memo(&mut self) {
  175|      1|            let mut memo_guard = self.memo.lock().unwrap();
  176|      1|            memo_guard.clear();
  177|      1|        }
  178|       |
  179|      3|        fn memo_size(&self) -> usize {
  180|      3|            let memo_guard = self.memo.lock().unwrap();
  181|      3|            memo_guard.len()
  182|      3|        }
  183|       |    }
  184|       |
  185|       |    impl<T: MtVal> PartialEq for MinEditDistMtEphS<T> {
  186|      2|        fn eq(&self, other: &Self) -> bool { self.source == other.source && self.target == other.target }
  187|       |    }
  188|       |
  189|       |    impl<T: MtVal> Eq for MinEditDistMtEphS<T> {}
  190|       |
  191|       |    impl<T: MtVal> Display for MinEditDistMtEphS<T> {
  192|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  193|      0|            let memo_size = {
  194|      0|                let memo_guard = self.memo.lock().unwrap();
  195|      0|                memo_guard.len()
  196|       |            };
  197|      0|            write!(
  198|      0|                f,
  199|      0|                "MinEditDistMtEph(source: {}, target: {}, memo_entries: {})",
  200|       |                self.source, self.target, memo_size
  201|       |            )
  202|      0|        }
  203|       |    }
  204|       |
  205|       |    // Note: IntoIterator not implemented for ArraySeqMtEphS, so we don't provide it here
  206|       |
  207|       |}
  208|       |
  209|       |#[macro_export]
  210|       |macro_rules! MinEditDistMtEphLit {
  211|       |    (source: [$($s:expr),* $(,)?], target: [$($t:expr),* $(,)?]) => {
  212|       |        $crate::Chap49::MinEditDistMtEph::MinEditDistMtEph::MinEditDistMtEphS::from_sequences(
  213|       |            $crate::ArraySeqMtEphSLit![$($s),*],
  214|       |            $crate::ArraySeqMtEphSLit![$($t),*]
  215|       |        )
  216|       |    };
  217|       |    () => {
  218|       |        $crate::Chap49::MinEditDistMtEph::MinEditDistMtEph::MinEditDistMtEphS::new()
  219|       |    };
  220|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap49/MinEditDistMtPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 49: Minimum Edit Distance - persistent, multi-threaded.
    3|       |
    4|       |pub mod MinEditDistMtPer {
    5|       |
    6|       |    use std::collections::HashMap;
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    8|       |    use std::sync::{Arc, Mutex};
    9|       |    use std::thread;
   10|       |
   11|       |    use crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::*;
   12|       |    use crate::Types::Types::*;
   13|       |
   14|       |    #[derive(Clone, Debug)]
   15|       |    pub struct MinEditDistMtPerS<T: MtVal> {
   16|       |        source: ArraySeqMtPerS<T>,
   17|       |        target: ArraySeqMtPerS<T>,
   18|       |        memo: Arc<Mutex<HashMap<(usize, usize), usize>>>,
   19|       |    }
   20|       |
   21|       |    /// Trait for parallel minimum edit distance operations
   22|       |    pub trait MinEditDistMtPerTrait<T: MtVal> {
   23|       |        /// Create new minimum edit distance solver
   24|       |        fn new() -> Self
   25|       |        where
   26|       |            T: Default;
   27|       |
   28|       |        /// Create from source and target sequences
   29|       |        fn from_sequences(source: ArraySeqMtPerS<T>, target: ArraySeqMtPerS<T>) -> Self;
   30|       |
   31|       |        /// claude-4-sonet: Work (|S||T|), Span (|S|+|T|), Parallelism (min(|S|,|T|))
   32|       |        /// Compute minimum edit distance with parallel DP where |S|=source length, |T|=target length
   33|       |        fn min_edit_distance(&self) -> usize
   34|       |        where
   35|       |            T: Send + Sync + 'static;
   36|       |
   37|       |        /// Get the source sequence
   38|       |        fn source(&self) -> &ArraySeqMtPerS<T>;
   39|       |
   40|       |        /// Get the target sequence
   41|       |        fn target(&self) -> &ArraySeqMtPerS<T>;
   42|       |
   43|       |        /// Get memoization table size
   44|       |        fn memo_size(&self) -> usize;
   45|       |    }
   46|       |
   47|       |    impl<T: MtVal> MinEditDistMtPerS<T> {
   48|       |        /// Internal parallel recursive minimum edit distance with shared memoization
   49|       |        /// Claude Work: O(|S|*|T|) - each subproblem computed once across all threads
   50|       |        /// Claude Span: O(|S|+|T|) - maximum recursion depth, parallelism O(min(|S|,|T|))
   51|    239|        fn min_edit_distance_rec(&self, i: usize, j: usize) -> usize
   52|    239|        where
   53|    239|            T: Send + Sync + 'static,
   54|       |        {
   55|       |            // Check memo first (thread-safe)
   56|       |            {
   57|    239|                let memo_guard = self.memo.lock().unwrap();
   58|    239|                if let Some(&result) = memo_guard.get(&(i, j)) {
                                           ^99
   59|     99|                    return result;
   60|    140|                }
   61|       |            }
   62|       |
   63|    140|            let result = match (i, j) {
   64|     10|                | (i, 0) => i, // Base case: need i deletions
   65|      7|                | (0, j) => j, // Base case: need j insertions
   66|    123|                | (i, j) => {
   67|    123|                    let source_char = self.source.nth(i - 1);
   68|    123|                    let target_char = self.target.nth(j - 1);
   69|       |
   70|    123|                    if source_char == target_char {
   71|       |                        // Characters match, no edit needed
   72|     16|                        self.min_edit_distance_rec(i - 1, j - 1)
   73|       |                    } else {
   74|       |                        // Parallel evaluation of both operations
   75|    107|                        let self_clone1 = self.clone();
   76|    107|                        let self_clone2 = self.clone();
   77|       |
   78|    107|                        let handle1 = thread::spawn(move || self_clone1.min_edit_distance_rec(i - 1, j));
   79|       |
   80|    107|                        let handle2 = thread::spawn(move || self_clone2.min_edit_distance_rec(i, j - 1));
   81|       |
   82|    107|                        let delete_cost = handle1.join().unwrap();
   83|    107|                        let insert_cost = handle2.join().unwrap();
   84|       |
   85|    107|                        1 + std::cmp::min(delete_cost, insert_cost)
   86|       |                    }
   87|       |                }
   88|       |            };
   89|       |
   90|       |            // Memoize result (thread-safe)
   91|    140|            {
   92|    140|                let mut memo_guard = self.memo.lock().unwrap();
   93|    140|                memo_guard.insert((i, j), result);
   94|    140|            }
   95|       |
   96|    140|            result
   97|    239|        }
   98|       |    }
   99|       |
  100|       |    impl<T: MtVal> MinEditDistMtPerTrait<T> for MinEditDistMtPerS<T> {
  101|      1|        fn new() -> Self
  102|      1|        where
  103|      1|            T: Default,
  104|       |        {
  105|      1|            Self {
  106|      1|                source: ArraySeqMtPerS::new(0, T::default()),
  107|      1|                target: ArraySeqMtPerS::new(0, T::default()),
  108|      1|                memo: Arc::new(Mutex::new(HashMap::new())),
  109|      1|            }
  110|      1|        }
  111|       |
  112|      6|        fn from_sequences(source: ArraySeqMtPerS<T>, target: ArraySeqMtPerS<T>) -> Self {
  113|      6|            Self {
  114|      6|                source,
  115|      6|                target,
  116|      6|                memo: Arc::new(Mutex::new(HashMap::new())),
  117|      6|            }
  118|      6|        }
  119|       |
  120|      9|        fn min_edit_distance(&self) -> usize
  121|      9|        where
  122|      9|            T: Send + Sync + 'static,
  123|       |        {
  124|       |            // Clear memo for fresh computation
  125|      9|            {
  126|      9|                let mut memo_guard = self.memo.lock().unwrap();
  127|      9|                memo_guard.clear();
  128|      9|            }
  129|       |
  130|      9|            let source_len = self.source.length();
  131|      9|            let target_len = self.target.length();
  132|       |
  133|      9|            self.min_edit_distance_rec(source_len, target_len)
  134|      9|        }
  135|       |
  136|      2|        fn source(&self) -> &ArraySeqMtPerS<T> { &self.source }
  137|       |
  138|      2|        fn target(&self) -> &ArraySeqMtPerS<T> { &self.target }
  139|       |
  140|      0|        fn memo_size(&self) -> usize {
  141|      0|            let memo_guard = self.memo.lock().unwrap();
  142|      0|            memo_guard.len()
  143|      0|        }
  144|       |    }
  145|       |
  146|       |    impl<T: MtVal> PartialEq for MinEditDistMtPerS<T> {
  147|      0|        fn eq(&self, other: &Self) -> bool { self.source == other.source && self.target == other.target }
  148|       |    }
  149|       |
  150|       |    impl<T: MtVal> Eq for MinEditDistMtPerS<T> {}
  151|       |
  152|       |    impl<T: MtVal> Display for MinEditDistMtPerS<T> {
  153|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  154|      0|            let memo_size = {
  155|      0|                let memo_guard = self.memo.lock().unwrap();
  156|      0|                memo_guard.len()
  157|       |            };
  158|      0|            write!(
  159|      0|                f,
  160|      0|                "MinEditDistMtPer(source: {}, target: {}, memo_entries: {})",
  161|       |                self.source, self.target, memo_size
  162|       |            )
  163|      0|        }
  164|       |    }
  165|       |
  166|       |    // Note: IntoIterator not implemented for ArraySeqMtPerS, so we don't provide it here
  167|       |
  168|       |}
  169|       |
  170|       |#[macro_export]
  171|       |macro_rules! MinEditDistMtPerLit {
  172|       |    (source: [$($s:expr),* $(,)?], target: [$($t:expr),* $(,)?]) => {
  173|       |        $crate::Chap49::MinEditDistMtPer::MinEditDistMtPer::MinEditDistMtPerS::from_sequences(
  174|       |            $crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::ArraySeqMtPerS::from_vec(vec![$($s),*]),
  175|       |            $crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::ArraySeqMtPerS::from_vec(vec![$($t),*])
  176|       |        )
  177|       |    };
  178|       |    () => {
  179|       |        $crate::Chap49::MinEditDistMtPer::MinEditDistMtPer::MinEditDistMtPerS::new()
  180|       |    };
  181|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap49/MinEditDistStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 49: Minimum Edit Distance - ephemeral, single-threaded.
    3|       |
    4|       |pub mod MinEditDistStEph {
    5|       |
    6|       |    use std::collections::HashMap;
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    8|       |
    9|       |    use crate::ArraySeqStEphS;
   10|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   11|       |    use crate::Types::Types::*;
   12|       |
   13|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   14|       |    pub struct MinEditDistStEphS<T: StT> {
   15|       |        source: ArraySeqStEphS<T>,
   16|       |        target: ArraySeqStEphS<T>,
   17|       |        memo: HashMap<(usize, usize), usize>,
   18|       |    }
   19|       |
   20|       |    /// Trait for minimum edit distance operations
   21|       |    pub trait MinEditDistStEphTrait<T: StT> {
   22|       |        /// Create new minimum edit distance solver
   23|       |        fn new() -> Self
   24|       |        where
   25|       |            T: Default;
   26|       |
   27|       |        /// Create from source and target sequences
   28|       |        fn from_sequences(source: ArraySeqStEphS<T>, target: ArraySeqStEphS<T>) -> Self;
   29|       |
   30|       |        /// claude-4-sonet: Work (|S||T|), Span (|S|+|T|), Parallelism (1)
   31|       |        /// Compute minimum edit distance where |S|=source length, |T|=target length
   32|       |        fn min_edit_distance(&mut self) -> usize;
   33|       |
   34|       |        /// Get the source sequence
   35|       |        fn source(&self) -> &ArraySeqStEphS<T>;
   36|       |
   37|       |        /// Get the target sequence
   38|       |        fn target(&self) -> &ArraySeqStEphS<T>;
   39|       |
   40|       |        /// Get mutable source sequence (ephemeral allows mutation)
   41|       |        fn source_mut(&mut self) -> &mut ArraySeqStEphS<T>;
   42|       |
   43|       |        /// Get mutable target sequence (ephemeral allows mutation)
   44|       |        fn target_mut(&mut self) -> &mut ArraySeqStEphS<T>;
   45|       |
   46|       |        /// Set element in source sequence
   47|       |        fn set_source(&mut self, index: usize, value: T);
   48|       |
   49|       |        /// Set element in target sequence
   50|       |        fn set_target(&mut self, index: usize, value: T);
   51|       |
   52|       |        /// Clear memoization table
   53|       |        fn clear_memo(&mut self);
   54|       |
   55|       |        /// Get memoization table size
   56|       |        fn memo_size(&self) -> usize;
   57|       |    }
   58|       |
   59|       |    impl<T: StT> MinEditDistStEphS<T> {
   60|       |        /// Internal recursive minimum edit distance with memoization
   61|       |        /// Claude Work: O(|S|*|T|) - each subproblem computed once
   62|       |        /// Claude Span: O(|S|+|T|) - maximum recursion depth
   63|  1.07k|        fn min_edit_distance_rec(&mut self, i: usize, j: usize) -> usize {
   64|       |            // Check memo first
   65|  1.07k|            if let Some(&result) = self.memo.get(&(i, j)) {
                                       ^391
   66|    391|                return result;
   67|    682|            }
   68|       |
   69|    682|            let result = match (i, j) {
   70|     67|                | (i, 0) => i, // Base case: need i deletions
   71|     65|                | (0, j) => j, // Base case: need j insertions
   72|    550|                | (i, j) => {
   73|    550|                    let source_char = self.source.nth(i - 1);
   74|    550|                    let target_char = self.target.nth(j - 1);
   75|       |
   76|    550|                    if source_char == target_char {
   77|       |                        // Characters match, no edit needed
   78|     56|                        self.min_edit_distance_rec(i - 1, j - 1)
   79|       |                    } else {
   80|       |                        // Characters don't match, try both operations
   81|    494|                        let delete_cost = self.min_edit_distance_rec(i - 1, j);
   82|    494|                        let insert_cost = self.min_edit_distance_rec(i, j - 1);
   83|       |
   84|    494|                        1 + std::cmp::min(delete_cost, insert_cost)
   85|       |                    }
   86|       |                }
   87|       |            };
   88|       |
   89|       |            // Memoize result
   90|    682|            self.memo.insert((i, j), result);
   91|    682|            result
   92|  1.07k|        }
   93|       |    }
   94|       |
   95|       |    impl<T: StT> MinEditDistStEphTrait<T> for MinEditDistStEphS<T> {
   96|      1|        fn new() -> Self
   97|      1|        where
   98|      1|            T: Default,
   99|       |        {
  100|      1|            Self {
  101|      1|                source: ArraySeqStEphS::new(0, T::default()),
  102|      1|                target: ArraySeqStEphS::new(0, T::default()),
  103|      1|                memo: HashMap::new(),
  104|      1|            }
  105|      1|        }
  106|       |
  107|     30|        fn from_sequences(source: ArraySeqStEphS<T>, target: ArraySeqStEphS<T>) -> Self {
  108|     30|            Self {
  109|     30|                source,
  110|     30|                target,
  111|     30|                memo: HashMap::new(),
  112|     30|            }
  113|     30|        }
  114|       |
  115|     29|        fn min_edit_distance(&mut self) -> usize {
  116|       |            // Clear memo for fresh computation
  117|     29|            self.memo.clear();
  118|       |
  119|     29|            let source_len = self.source.length();
  120|     29|            let target_len = self.target.length();
  121|       |
  122|     29|            self.min_edit_distance_rec(source_len, target_len)
  123|     29|        }
  124|       |
  125|      8|        fn source(&self) -> &ArraySeqStEphS<T> { &self.source }
  126|       |
  127|      8|        fn target(&self) -> &ArraySeqStEphS<T> { &self.target }
  128|       |
  129|      2|        fn source_mut(&mut self) -> &mut ArraySeqStEphS<T> { &mut self.source }
  130|       |
  131|      2|        fn target_mut(&mut self) -> &mut ArraySeqStEphS<T> { &mut self.target }
  132|       |
  133|      3|        fn set_source(&mut self, index: usize, value: T) {
  134|      3|            let _ = self.source.set(index, value);
  135|       |            // Clear memo since source changed
  136|      3|            self.memo.clear();
  137|      3|        }
  138|       |
  139|      3|        fn set_target(&mut self, index: usize, value: T) {
  140|      3|            let _ = self.target.set(index, value);
  141|       |            // Clear memo since target changed
  142|      3|            self.memo.clear();
  143|      3|        }
  144|       |
  145|      3|        fn clear_memo(&mut self) { self.memo.clear(); }
  146|       |
  147|      8|        fn memo_size(&self) -> usize { self.memo.len() }
  148|       |    }
  149|       |
  150|       |    impl<T: StT> Display for MinEditDistStEphS<T> {
  151|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  152|      0|            write!(
  153|      0|                f,
  154|      0|                "MinEditDistStEph(source: {}, target: {}, memo_entries: {})",
  155|       |                self.source,
  156|       |                self.target,
  157|      0|                self.memo.len()
  158|       |            )
  159|      0|        }
  160|       |    }
  161|       |
  162|       |    impl<T: StT> IntoIterator for MinEditDistStEphS<T> {
  163|       |        type Item = Pair<T, T>;
  164|       |        type IntoIter = std::iter::Map<
  165|       |            std::iter::Zip<
  166|       |                <ArraySeqStEphS<T> as IntoIterator>::IntoIter,
  167|       |                <ArraySeqStEphS<T> as IntoIterator>::IntoIter,
  168|       |            >,
  169|       |            fn((T, T)) -> Pair<T, T>,
  170|       |        >;
  171|       |
  172|      0|        fn into_iter(self) -> Self::IntoIter {
  173|      0|            self.source
  174|      0|                .into_iter()
  175|      0|                .zip(self.target.into_iter())
  176|      0|                .map(|(a, b)| Pair(a, b))
  177|      0|        }
  178|       |    }
  179|       |
  180|       |    impl<T: StT> IntoIterator for &MinEditDistStEphS<T> {
  181|       |        type Item = Pair<T, T>;
  182|       |        type IntoIter = std::iter::Map<
  183|       |            std::iter::Zip<
  184|       |                <ArraySeqStEphS<T> as IntoIterator>::IntoIter,
  185|       |                <ArraySeqStEphS<T> as IntoIterator>::IntoIter,
  186|       |            >,
  187|       |            fn((T, T)) -> Pair<T, T>,
  188|       |        >;
  189|       |
  190|      0|        fn into_iter(self) -> Self::IntoIter {
  191|      0|            self.source
  192|      0|                .clone()
  193|      0|                .into_iter()
  194|      0|                .zip(self.target.clone().into_iter())
  195|      0|                .map(|(a, b)| Pair(a, b))
  196|      0|        }
  197|       |    }
  198|       |
  199|       |    impl<T: StT> IntoIterator for &mut MinEditDistStEphS<T> {
  200|       |        type Item = Pair<T, T>;
  201|       |        type IntoIter = std::iter::Map<
  202|       |            std::iter::Zip<
  203|       |                <ArraySeqStEphS<T> as IntoIterator>::IntoIter,
  204|       |                <ArraySeqStEphS<T> as IntoIterator>::IntoIter,
  205|       |            >,
  206|       |            fn((T, T)) -> Pair<T, T>,
  207|       |        >;
  208|       |
  209|      0|        fn into_iter(self) -> Self::IntoIter {
  210|      0|            self.source
  211|      0|                .clone()
  212|      0|                .into_iter()
  213|      0|                .zip(self.target.clone().into_iter())
  214|      0|                .map(|(a, b)| Pair(a, b))
  215|      0|        }
  216|       |    }
  217|       |
  218|       |}
  219|       |
  220|       |#[macro_export]
  221|       |macro_rules! MinEditDistStEphLit {
  222|       |    (source: [$($s:expr),* $(,)?], target: [$($t:expr),* $(,)?]) => {
  223|       |        $crate::Chap49::MinEditDistStEph::MinEditDistStEph::MinEditDistStEphS::from_sequences(
  224|       |            $crate::ArraySeqStEphS![$($s),*],
  225|       |            $crate::ArraySeqStEphS![$($t),*]
  226|       |        )
  227|       |    };
  228|       |    () => {
  229|       |        $crate::Chap49::MinEditDistStEph::MinEditDistStEph::MinEditDistStEphS::new()
  230|       |    };
  231|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap49/MinEditDistStPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 49: Minimum Edit Distance - persistent, single-threaded.
    3|       |
    4|       |pub mod MinEditDistStPer {
    5|       |
    6|       |    use std::collections::HashMap;
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    8|       |
    9|       |    use crate::ArraySeqStPerS;
   10|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
   11|       |    use crate::Types::Types::*;
   12|       |
   13|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   14|       |    pub struct MinEditDistStPerS<T: StT> {
   15|       |        source: ArraySeqStPerS<T>,
   16|       |        target: ArraySeqStPerS<T>,
   17|       |        memo: HashMap<(usize, usize), usize>,
   18|       |    }
   19|       |
   20|       |    /// Trait for minimum edit distance operations
   21|       |    pub trait MinEditDistStPerTrait<T: StT> {
   22|       |        /// Create new minimum edit distance solver
   23|       |        fn new() -> Self
   24|       |        where
   25|       |            T: Default;
   26|       |
   27|       |        /// Create from source and target sequences
   28|       |        fn from_sequences(source: ArraySeqStPerS<T>, target: ArraySeqStPerS<T>) -> Self;
   29|       |
   30|       |        /// Compute minimum edit distance between sequences
   31|       |        /// claude-4-sonet: Work (|S||T|), Span (|S|+|T|), Parallelism (1)
   32|       |        fn min_edit_distance(&self) -> usize;
   33|       |
   34|       |        /// Get the source sequence
   35|       |        fn source(&self) -> &ArraySeqStPerS<T>;
   36|       |
   37|       |        /// Get the target sequence
   38|       |        fn target(&self) -> &ArraySeqStPerS<T>;
   39|       |
   40|       |        /// Get memoization table size
   41|       |        fn memo_size(&self) -> usize;
   42|       |    }
   43|       |
   44|       |    impl<T: StT> MinEditDistStPerS<T> {
   45|       |        /// Internal recursive minimum edit distance with memoization
   46|       |        /// Claude Work: O(|S|*|T|) - each subproblem computed once
   47|       |        /// Claude Span: O(|S|+|T|) - maximum recursion depth
   48|    326|        fn min_edit_distance_rec(&mut self, i: usize, j: usize) -> usize {
   49|       |            // Check memo first
   50|    326|            if let Some(&result) = self.memo.get(&(i, j)) {
                                       ^87
   51|     87|                return result;
   52|    239|            }
   53|       |
   54|    239|            let result = match (i, j) {
   55|     38|                | (i, 0) => i, // Base case: need i deletions
   56|     28|                | (0, j) => j, // Base case: need j insertions
   57|    173|                | (i, j) => {
   58|    173|                    let source_char = self.source.nth(i - 1);
   59|    173|                    let target_char = self.target.nth(j - 1);
   60|       |
   61|    173|                    if source_char == target_char {
   62|       |                        // Characters match, no edit needed
   63|     39|                        self.min_edit_distance_rec(i - 1, j - 1)
   64|       |                    } else {
   65|       |                        // Characters don't match, try both operations
   66|    134|                        let delete_cost = self.min_edit_distance_rec(i - 1, j);
   67|    134|                        let insert_cost = self.min_edit_distance_rec(i, j - 1);
   68|       |
   69|    134|                        1 + std::cmp::min(delete_cost, insert_cost)
   70|       |                    }
   71|       |                }
   72|       |            };
   73|       |
   74|       |            // Memoize result
   75|    239|            self.memo.insert((i, j), result);
   76|    239|            result
   77|    326|        }
   78|       |    }
   79|       |
   80|       |    impl<T: StT> MinEditDistStPerTrait<T> for MinEditDistStPerS<T> {
   81|      1|        fn new() -> Self
   82|      1|        where
   83|      1|            T: Default,
   84|       |        {
   85|      1|            Self {
   86|      1|                source: ArraySeqStPerS::new(0, T::default()),
   87|      1|                target: ArraySeqStPerS::new(0, T::default()),
   88|      1|                memo: HashMap::new(),
   89|      1|            }
   90|      1|        }
   91|       |
   92|     25|        fn from_sequences(source: ArraySeqStPerS<T>, target: ArraySeqStPerS<T>) -> Self {
   93|     25|            Self {
   94|     25|                source,
   95|     25|                target,
   96|     25|                memo: HashMap::new(),
   97|     25|            }
   98|     25|        }
   99|       |
  100|     19|        fn min_edit_distance(&self) -> usize {
  101|       |            // Create mutable copy for memoization
  102|     19|            let mut solver = self.clone();
  103|     19|            solver.memo.clear(); // Fresh memo for each query
  104|       |
  105|     19|            let source_len = solver.source.length();
  106|     19|            let target_len = solver.target.length();
  107|       |
  108|     19|            solver.min_edit_distance_rec(source_len, target_len)
  109|     19|        }
  110|       |
  111|      3|        fn source(&self) -> &ArraySeqStPerS<T> { &self.source }
  112|       |
  113|      3|        fn target(&self) -> &ArraySeqStPerS<T> { &self.target }
  114|       |
  115|      1|        fn memo_size(&self) -> usize { self.memo.len() }
  116|       |    }
  117|       |
  118|       |    impl<T: StT> Display for MinEditDistStPerS<T> {
  119|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  120|      1|            write!(
  121|      1|                f,
  122|      1|                "MinEditDistStPer(source: {}, target: {}, memo_entries: {})",
  123|       |                self.source,
  124|       |                self.target,
  125|      1|                self.memo.len()
  126|       |            )
  127|      1|        }
  128|       |    }
  129|       |
  130|       |    impl<T: StT> IntoIterator for MinEditDistStPerS<T> {
  131|       |        type Item = Pair<T, T>;
  132|       |        type IntoIter = std::iter::Map<
  133|       |            std::iter::Zip<
  134|       |                <ArraySeqStPerS<T> as IntoIterator>::IntoIter,
  135|       |                <ArraySeqStPerS<T> as IntoIterator>::IntoIter,
  136|       |            >,
  137|       |            fn((T, T)) -> Pair<T, T>,
  138|       |        >;
  139|       |
  140|      1|        fn into_iter(self) -> Self::IntoIter {
  141|      1|            self.source
  142|      1|                .into_iter()
  143|      1|                .zip(self.target.into_iter())
  144|      2|                .map(|(a, b)| Pair(a, b))
                               ^1
  145|      1|        }
  146|       |    }
  147|       |
  148|       |    impl<T: StT> IntoIterator for &MinEditDistStPerS<T> {
  149|       |        type Item = Pair<T, T>;
  150|       |        type IntoIter = std::iter::Map<
  151|       |            std::iter::Zip<
  152|       |                <ArraySeqStPerS<T> as IntoIterator>::IntoIter,
  153|       |                <ArraySeqStPerS<T> as IntoIterator>::IntoIter,
  154|       |            >,
  155|       |            fn((T, T)) -> Pair<T, T>,
  156|       |        >;
  157|       |
  158|      0|        fn into_iter(self) -> Self::IntoIter {
  159|      0|            self.source
  160|      0|                .clone()
  161|      0|                .into_iter()
  162|      0|                .zip(self.target.clone().into_iter())
  163|      0|                .map(|(a, b)| Pair(a, b))
  164|      0|        }
  165|       |    }
  166|       |
  167|       |}
  168|       |
  169|       |#[macro_export]
  170|       |macro_rules! MinEditDistStPerLit {
  171|       |    (source: [$($s:expr),* $(,)?], target: [$($t:expr),* $(,)?]) => {
  172|       |        $crate::Chap49::MinEditDistStPer::MinEditDistStPer::MinEditDistStPerS::from_sequences(
  173|       |            $crate::ArraySeqStPerS![$($s),*],
  174|       |            $crate::ArraySeqStPerS![$($t),*]
  175|       |        )
  176|       |    };
  177|       |    () => {
  178|       |        $crate::Chap49::MinEditDistStPer::MinEditDistStPer::MinEditDistStPerS::new()
  179|       |    };
  180|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap49/SubsetSumMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 49: Subset Sum - ephemeral, multi-threaded.
    3|       |
    4|       |pub mod SubsetSumMtEph {
    5|       |
    6|       |    use std::collections::HashMap;
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    8|       |    use std::sync::{Arc, Mutex};
    9|       |    use std::thread;
   10|       |
   11|       |    use crate::ArraySeqMtEphSLit;
   12|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
   13|       |    use crate::Types::Types::*;
   14|       |
   15|       |    #[derive(Clone, Debug)]
   16|       |    pub struct SubsetSumMtEphS<T: MtVal> {
   17|       |        multiset: ArraySeqMtEphS<T>,
   18|       |        memo: Arc<Mutex<HashMap<(usize, i32), bool>>>,
   19|       |    }
   20|       |
   21|       |    /// Trait for parallel subset sum operations
   22|       |    pub trait SubsetSumMtEphTrait<T: MtVal> {
   23|       |        /// Create new subset sum solver
   24|       |        fn new() -> Self
   25|       |        where
   26|       |            T: Default;
   27|       |
   28|       |        /// Create from multiset
   29|       |        fn from_multiset(multiset: ArraySeqMtEphS<T>) -> Self;
   30|       |
   31|       |        /// claude-4-sonet: Work (k|S|), Span (|S|), Parallelism (k)
   32|       |        /// Solve subset sum problem with parallel DP where k=target, |S|=multiset size
   33|       |        fn subset_sum(&mut self, target: i32) -> bool
   34|       |        where
   35|       |            T: Into<i32> + Copy + Send + Sync + 'static;
   36|       |
   37|       |        /// Get the multiset
   38|       |        fn multiset(&self) -> &ArraySeqMtEphS<T>;
   39|       |
   40|       |        /// Get mutable multiset (ephemeral allows mutation)
   41|       |        fn multiset_mut(&mut self) -> &mut ArraySeqMtEphS<T>;
   42|       |
   43|       |        /// Set element at index (ephemeral mutation)
   44|       |        fn set(&mut self, index: usize, value: T);
   45|       |
   46|       |        /// Clear memoization table
   47|       |        fn clear_memo(&mut self);
   48|       |
   49|       |        /// Get memoization table size
   50|       |        fn memo_size(&self) -> usize;
   51|       |    }
   52|       |
   53|       |    impl<T: MtVal> SubsetSumMtEphS<T> {
   54|       |        /// Internal parallel recursive subset sum with shared memoization
   55|       |        /// Claude Work: O(k*|S|) - each subproblem computed once across all threads
   56|       |        /// Claude Span: O(|S|) - maximum recursion depth, parallelism O(k)
   57|    114|        fn subset_sum_rec(&self, i: usize, j: i32) -> bool
   58|    114|        where
   59|    114|            T: Into<i32> + Copy + Send + Sync + 'static,
   60|       |        {
   61|       |            // Check memo first (thread-safe)
   62|       |            {
   63|    114|                let memo_guard = self.memo.lock().unwrap();
   64|    114|                if let Some(&result) = memo_guard.get(&(i, j)) {
                                           ^0
   65|      0|                    return result;
   66|    114|                }
   67|       |            }
   68|       |
   69|    114|            let result = match (i, j) {
   70|      7|                | (_, 0) => true,  // Base case: target sum is 0
   71|     48|                | (0, _) => false, // Base case: no elements left, target > 0
   72|     59|                | (i, j) => {
   73|     59|                    let element_value: i32 = self.multiset.nth_cloned(i - 1).into();
   74|     59|                    if element_value > j {
   75|       |                        // Element too large, skip it
   76|     14|                        self.subset_sum_rec(i - 1, j)
   77|       |                    } else {
   78|       |                        // Parallel evaluation of both branches
   79|     45|                        let self_clone1 = self.clone();
   80|     45|                        let self_clone2 = self.clone();
   81|       |
   82|     45|                        let handle1 = thread::spawn(move || self_clone1.subset_sum_rec(i - 1, j - element_value));
   83|       |
   84|     45|                        let handle2 = thread::spawn(move || self_clone2.subset_sum_rec(i - 1, j));
   85|       |
   86|     45|                        let result1 = handle1.join().unwrap();
   87|     45|                        let result2 = handle2.join().unwrap();
   88|       |
   89|     45|                        result1 || result2
                                                 ^31
   90|       |                    }
   91|       |                }
   92|       |            };
   93|       |
   94|       |            // Memoize result (thread-safe)
   95|    114|            {
   96|    114|                let mut memo_guard = self.memo.lock().unwrap();
   97|    114|                memo_guard.insert((i, j), result);
   98|    114|            }
   99|       |
  100|    114|            result
  101|    114|        }
  102|       |    }
  103|       |
  104|       |    impl<T: MtVal> SubsetSumMtEphTrait<T> for SubsetSumMtEphS<T> {
  105|      1|        fn new() -> Self
  106|      1|        where
  107|      1|            T: Default,
  108|       |        {
  109|      1|            Self {
  110|      1|                multiset: ArraySeqMtEphS::new(0, T::default()),
  111|      1|                memo: Arc::new(Mutex::new(HashMap::new())),
  112|      1|            }
  113|      1|        }
  114|       |
  115|      7|        fn from_multiset(multiset: ArraySeqMtEphS<T>) -> Self {
  116|      7|            Self {
  117|      7|                multiset,
  118|      7|                memo: Arc::new(Mutex::new(HashMap::new())),
  119|      7|            }
  120|      7|        }
  121|       |
  122|     10|        fn subset_sum(&mut self, target: i32) -> bool
  123|     10|        where
  124|     10|            T: Into<i32> + Copy + Send + Sync + 'static,
  125|       |        {
  126|     10|            if target < 0 {
  127|      0|                return false;
  128|     10|            }
  129|       |
  130|       |            // Clear memo for fresh computation
  131|     10|            {
  132|     10|                let mut memo_guard = self.memo.lock().unwrap();
  133|     10|                memo_guard.clear();
  134|     10|            }
  135|       |
  136|     10|            let n = self.multiset.length();
  137|     10|            self.subset_sum_rec(n, target)
  138|     10|        }
  139|       |
  140|      3|        fn multiset(&self) -> &ArraySeqMtEphS<T> { &self.multiset }
  141|       |
  142|      0|        fn multiset_mut(&mut self) -> &mut ArraySeqMtEphS<T> { &mut self.multiset }
  143|       |
  144|      1|        fn set(&mut self, index: usize, value: T) {
  145|      1|            let _ = self.multiset.set(index, value);
  146|       |            // Clear memo since multiset changed
  147|      1|            let mut memo_guard = self.memo.lock().unwrap();
  148|      1|            memo_guard.clear();
  149|      1|        }
  150|       |
  151|      1|        fn clear_memo(&mut self) {
  152|      1|            let mut memo_guard = self.memo.lock().unwrap();
  153|      1|            memo_guard.clear();
  154|      1|        }
  155|       |
  156|      2|        fn memo_size(&self) -> usize {
  157|      2|            let memo_guard = self.memo.lock().unwrap();
  158|      2|            memo_guard.len()
  159|      2|        }
  160|       |    }
  161|       |
  162|       |    impl<T: MtVal> PartialEq for SubsetSumMtEphS<T> {
  163|      0|        fn eq(&self, other: &Self) -> bool { self.multiset == other.multiset }
  164|       |    }
  165|       |
  166|       |    impl<T: MtVal> Eq for SubsetSumMtEphS<T> {}
  167|       |
  168|       |    impl<T: MtVal> Display for SubsetSumMtEphS<T> {
  169|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  170|      0|            let memo_size = {
  171|      0|                let memo_guard = self.memo.lock().unwrap();
  172|      0|                memo_guard.len()
  173|       |            };
  174|      0|            write!(
  175|      0|                f,
  176|      0|                "SubsetSumMtEph(multiset: {}, memo_entries: {})",
  177|       |                self.multiset, memo_size
  178|       |            )
  179|      0|        }
  180|       |    }
  181|       |
  182|       |    // Note: IntoIterator not implemented for ArraySeqMtEphS, so we don't provide it here
  183|       |
  184|       |}
  185|       |
  186|       |#[macro_export]
  187|       |macro_rules! SubsetSumMtEphLit {
  188|       |    ($($x:expr),* $(,)?) => {
  189|       |        $crate::Chap49::SubsetSumMtEph::SubsetSumMtEph::SubsetSumMtEphS::from_multiset(
  190|       |            $crate::ArraySeqMtEphSLit![$($x),*]
  191|       |        )
  192|       |    };
  193|       |    () => {
  194|       |        $crate::Chap49::SubsetSumMtEph::SubsetSumMtEph::SubsetSumMtEphS::new()
  195|       |    };
  196|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap49/SubsetSumMtPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 49: Subset Sum - persistent, multi-threaded.
    3|       |
    4|       |pub mod SubsetSumMtPer {
    5|       |
    6|       |    use std::collections::HashMap;
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    8|       |    use std::sync::{Arc, Mutex};
    9|       |    use std::thread;
   10|       |
   11|       |    use crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::*;
   12|       |    use crate::Types::Types::*;
   13|       |
   14|       |    #[derive(Clone, Debug)]
   15|       |    pub struct SubsetSumMtPerS<T: MtVal> {
   16|       |        multiset: ArraySeqMtPerS<T>,
   17|       |        memo: Arc<Mutex<HashMap<(usize, i32), bool>>>,
   18|       |    }
   19|       |
   20|       |    /// Trait for parallel subset sum operations
   21|       |    pub trait SubsetSumMtPerTrait<T: MtVal> {
   22|       |        /// Create new subset sum solver
   23|       |        fn new() -> Self
   24|       |        where
   25|       |            T: Default;
   26|       |
   27|       |        /// Create from multiset
   28|       |        fn from_multiset(multiset: ArraySeqMtPerS<T>) -> Self;
   29|       |
   30|       |        /// claude-4-sonet: Work (k|S|), Span (|S|), Parallelism (k)
   31|       |        /// Solve subset sum problem with parallel DP where k=target, |S|=multiset size
   32|       |        fn subset_sum(&self, target: i32) -> bool
   33|       |        where
   34|       |            T: Into<i32> + Copy + Send + Sync + 'static;
   35|       |
   36|       |        /// Get the multiset
   37|       |        fn multiset(&self) -> &ArraySeqMtPerS<T>;
   38|       |
   39|       |        /// Get memoization table size
   40|       |        fn memo_size(&self) -> usize;
   41|       |    }
   42|       |
   43|       |    impl<T: MtVal> SubsetSumMtPerS<T> {
   44|       |        /// Internal parallel recursive subset sum with shared memoization
   45|       |        /// Claude Work: O(k*|S|) - each subproblem computed once across all threads
   46|       |        /// Claude Span: O(|S|) - maximum recursion depth, parallelism O(k)
   47|    247|        fn subset_sum_rec(&self, i: usize, j: i32) -> bool
   48|    247|        where
   49|    247|            T: Into<i32> + Copy + Send + Sync + 'static,
   50|       |        {
   51|       |            // Check memo first (thread-safe)
   52|       |            {
   53|    247|                let memo_guard = self.memo.lock().unwrap();
   54|    247|                if let Some(&result) = memo_guard.get(&(i, j)) {
                                           ^57
   55|     57|                    return result;
   56|    190|                }
   57|       |            }
   58|       |
   59|    190|            let result = match (i, j) {
   60|      9|                | (_, 0) => true,  // Base case: target sum is 0
   61|     54|                | (0, _) => false, // Base case: no elements left, target > 0
   62|    127|                | (i, j) => {
   63|    127|                    let element_value: i32 = self.multiset.nth(i - 1).clone().into();
   64|    127|                    if element_value > j {
   65|       |                        // Element too large, skip it
   66|     19|                        self.subset_sum_rec(i - 1, j)
   67|       |                    } else {
   68|       |                        // Parallel evaluation of both branches
   69|    108|                        let self_clone1 = self.clone();
   70|    108|                        let self_clone2 = self.clone();
   71|       |
   72|    108|                        let handle1 = thread::spawn(move || self_clone1.subset_sum_rec(i - 1, j - element_value));
   73|       |
   74|    108|                        let handle2 = thread::spawn(move || self_clone2.subset_sum_rec(i - 1, j));
   75|       |
   76|    108|                        let result1 = handle1.join().unwrap();
   77|    108|                        let result2 = handle2.join().unwrap();
   78|       |
   79|    108|                        result1 || result2
                                                 ^64
   80|       |                    }
   81|       |                }
   82|       |            };
   83|       |
   84|       |            // Memoize result (thread-safe)
   85|    190|            {
   86|    190|                let mut memo_guard = self.memo.lock().unwrap();
   87|    190|                memo_guard.insert((i, j), result);
   88|    190|            }
   89|       |
   90|    190|            result
   91|    247|        }
   92|       |    }
   93|       |
   94|       |    impl<T: MtVal> SubsetSumMtPerTrait<T> for SubsetSumMtPerS<T> {
   95|      1|        fn new() -> Self
   96|      1|        where
   97|      1|            T: Default,
   98|       |        {
   99|      1|            Self {
  100|      1|                multiset: ArraySeqMtPerS::new(0, T::default()),
  101|      1|                memo: Arc::new(Mutex::new(HashMap::new())),
  102|      1|            }
  103|      1|        }
  104|       |
  105|      5|        fn from_multiset(multiset: ArraySeqMtPerS<T>) -> Self {
  106|      5|            Self {
  107|      5|                multiset,
  108|      5|                memo: Arc::new(Mutex::new(HashMap::new())),
  109|      5|            }
  110|      5|        }
  111|       |
  112|     12|        fn subset_sum(&self, target: i32) -> bool
  113|     12|        where
  114|     12|            T: Into<i32> + Copy + Send + Sync + 'static,
  115|       |        {
  116|     12|            if target < 0 {
  117|      0|                return false;
  118|     12|            }
  119|       |
  120|       |            // Clear memo for fresh computation
  121|     12|            {
  122|     12|                let mut memo_guard = self.memo.lock().unwrap();
  123|     12|                memo_guard.clear();
  124|     12|            }
  125|       |
  126|     12|            let n = self.multiset.length();
  127|     12|            self.subset_sum_rec(n, target)
  128|     12|        }
  129|       |
  130|      2|        fn multiset(&self) -> &ArraySeqMtPerS<T> { &self.multiset }
  131|       |
  132|      0|        fn memo_size(&self) -> usize {
  133|      0|            let memo_guard = self.memo.lock().unwrap();
  134|      0|            memo_guard.len()
  135|      0|        }
  136|       |    }
  137|       |
  138|       |    impl<T: MtVal> PartialEq for SubsetSumMtPerS<T> {
  139|      0|        fn eq(&self, other: &Self) -> bool { self.multiset == other.multiset }
  140|       |    }
  141|       |
  142|       |    impl<T: MtVal> Eq for SubsetSumMtPerS<T> {}
  143|       |
  144|       |    impl<T: MtVal> Display for SubsetSumMtPerS<T> {
  145|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  146|      0|            let memo_size = {
  147|      0|                let memo_guard = self.memo.lock().unwrap();
  148|      0|                memo_guard.len()
  149|       |            };
  150|      0|            write!(
  151|      0|                f,
  152|      0|                "SubsetSumMtPer(multiset: {}, memo_entries: {})",
  153|       |                self.multiset, memo_size
  154|       |            )
  155|      0|        }
  156|       |    }
  157|       |
  158|       |    // Note: IntoIterator not implemented for ArraySeqMtPerS, so we don't provide it here
  159|       |
  160|       |}
  161|       |
  162|       |#[macro_export]
  163|       |macro_rules! SubsetSumMtPerLit {
  164|       |    ($($x:expr),* $(,)?) => {
  165|       |        $crate::Chap49::SubsetSumMtPer::SubsetSumMtPer::SubsetSumMtPerS::from_multiset(
  166|       |            $crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::ArraySeqMtPerS::from_vec(vec![$($x),*])
  167|       |        )
  168|       |    };
  169|       |    () => {
  170|       |        $crate::Chap49::SubsetSumMtPer::SubsetSumMtPer::SubsetSumMtPerS::new()
  171|       |    };
  172|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap49/SubsetSumStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 49: Subset Sum - ephemeral, single-threaded.
    3|       |
    4|       |pub mod SubsetSumStEph {
    5|       |
    6|       |    use std::collections::HashMap;
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    8|       |
    9|       |    use crate::ArraySeqStEphS;
   10|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   11|       |    use crate::Types::Types::*;
   12|       |
   13|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   14|       |    pub struct SubsetSumStEphS<T: StT> {
   15|       |        multiset: ArraySeqStEphS<T>,
   16|       |        memo: HashMap<(usize, i32), bool>,
   17|       |    }
   18|       |
   19|       |    /// Trait for subset sum operations
   20|       |    pub trait SubsetSumStEphTrait<T: StT> {
   21|       |        /// Create new subset sum solver
   22|       |        fn new() -> Self
   23|       |        where
   24|       |            T: Default;
   25|       |
   26|       |        /// Create from multiset
   27|       |        fn from_multiset(multiset: ArraySeqStEphS<T>) -> Self;
   28|       |
   29|       |        /// claude-4-sonet: Work (k|S|), Span (|S|), Parallelism (1)
   30|       |        /// Solve subset sum problem where k=target, |S|=multiset size
   31|       |        fn subset_sum(&mut self, target: i32) -> bool
   32|       |        where
   33|       |            T: Into<i32> + Copy;
   34|       |
   35|       |        /// Get the multiset
   36|       |        fn multiset(&self) -> &ArraySeqStEphS<T>;
   37|       |
   38|       |        /// Get mutable multiset (ephemeral allows mutation)
   39|       |        fn multiset_mut(&mut self) -> &mut ArraySeqStEphS<T>;
   40|       |
   41|       |        /// Set element at index (ephemeral mutation)
   42|       |        fn set(&mut self, index: usize, value: T);
   43|       |
   44|       |        /// Clear memoization table
   45|       |        fn clear_memo(&mut self);
   46|       |
   47|       |        /// Get memoization table size
   48|       |        fn memo_size(&self) -> usize;
   49|       |    }
   50|       |
   51|       |    impl<T: StT> SubsetSumStEphS<T> {
   52|       |        /// Internal recursive subset sum with memoization
   53|       |        /// Claude Work: O(k*|S|) - each subproblem computed once
   54|       |        /// Claude Span: O(|S|) - maximum recursion depth
   55|    131|        fn subset_sum_rec(&mut self, i: usize, j: i32) -> bool
   56|    131|        where
   57|    131|            T: Into<i32> + Copy,
   58|       |        {
   59|       |            // Check memo first
   60|    131|            if let Some(&result) = self.memo.get(&(i, j)) {
                                       ^0
   61|      0|                return result;
   62|    131|            }
   63|       |
   64|    131|            let result = match (i, j) {
   65|     14|                | (_, 0) => true,  // Base case: target sum is 0
   66|     31|                | (0, _) => false, // Base case: no elements left, target > 0
   67|     86|                | (i, j) => {
   68|     86|                    let element_value: i32 = (*self.multiset.nth(i - 1)).into();
   69|     86|                    if element_value > j {
   70|       |                        // Element too large, skip it
   71|     25|                        self.subset_sum_rec(i - 1, j)
   72|       |                    } else {
   73|       |                        // Try both including and excluding the element
   74|     61|                        self.subset_sum_rec(i - 1, j - element_value) || self.subset_sum_rec(i - 1, j)
                                                                                       ^24  ^24            ^24    ^24
   75|       |                    }
   76|       |                }
   77|       |            };
   78|       |
   79|       |            // Memoize result
   80|    131|            self.memo.insert((i, j), result);
   81|    131|            result
   82|    131|        }
   83|       |    }
   84|       |
   85|       |    impl<T: StT> SubsetSumStEphTrait<T> for SubsetSumStEphS<T> {
   86|      1|        fn new() -> Self
   87|      1|        where
   88|      1|            T: Default,
   89|       |        {
   90|      1|            Self {
   91|      1|                multiset: ArraySeqStEphS::new(0, T::default()),
   92|      1|                memo: HashMap::new(),
   93|      1|            }
   94|      1|        }
   95|       |
   96|     12|        fn from_multiset(multiset: ArraySeqStEphS<T>) -> Self {
   97|     12|            Self {
   98|     12|                multiset,
   99|     12|                memo: HashMap::new(),
  100|     12|            }
  101|     12|        }
  102|       |
  103|     21|        fn subset_sum(&mut self, target: i32) -> bool
  104|     21|        where
  105|     21|            T: Into<i32> + Copy,
  106|       |        {
  107|     21|            if target < 0 {
  108|      0|                return false;
  109|     21|            }
  110|       |
  111|       |            // Clear memo for fresh computation
  112|     21|            self.memo.clear();
  113|       |
  114|     21|            let n = self.multiset.length();
  115|     21|            self.subset_sum_rec(n, target)
  116|     21|        }
  117|       |
  118|      4|        fn multiset(&self) -> &ArraySeqStEphS<T> { &self.multiset }
  119|       |
  120|      0|        fn multiset_mut(&mut self) -> &mut ArraySeqStEphS<T> { &mut self.multiset }
  121|       |
  122|      3|        fn set(&mut self, index: usize, value: T) {
  123|      3|            let _ = self.multiset.set(index, value);
  124|       |            // Clear memo since multiset changed
  125|      3|            self.memo.clear();
  126|      3|        }
  127|       |
  128|      2|        fn clear_memo(&mut self) { self.memo.clear(); }
  129|       |
  130|      3|        fn memo_size(&self) -> usize { self.memo.len() }
  131|       |    }
  132|       |
  133|       |    impl<T: StT> Display for SubsetSumStEphS<T> {
  134|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  135|      0|            write!(
  136|      0|                f,
  137|      0|                "SubsetSumStEph(multiset: {}, memo_entries: {})",
  138|       |                self.multiset,
  139|      0|                self.memo.len()
  140|       |            )
  141|      0|        }
  142|       |    }
  143|       |
  144|       |    impl<T: StT> IntoIterator for SubsetSumStEphS<T> {
  145|       |        type Item = T;
  146|       |        type IntoIter = <ArraySeqStEphS<T> as IntoIterator>::IntoIter;
  147|       |
  148|      0|        fn into_iter(self) -> Self::IntoIter { self.multiset.into_iter() }
  149|       |    }
  150|       |
  151|       |    impl<T: StT> IntoIterator for &SubsetSumStEphS<T> {
  152|       |        type Item = T;
  153|       |        type IntoIter = <ArraySeqStEphS<T> as IntoIterator>::IntoIter;
  154|       |
  155|      0|        fn into_iter(self) -> Self::IntoIter { self.multiset.clone().into_iter() }
  156|       |    }
  157|       |
  158|       |    impl<T: StT> IntoIterator for &mut SubsetSumStEphS<T> {
  159|       |        type Item = T;
  160|       |        type IntoIter = <ArraySeqStEphS<T> as IntoIterator>::IntoIter;
  161|       |
  162|      0|        fn into_iter(self) -> Self::IntoIter { self.multiset.clone().into_iter() }
  163|       |    }
  164|       |
  165|       |}
  166|       |
  167|       |#[macro_export]
  168|       |macro_rules! SubsetSumStEphLit {
  169|       |    ($($x:expr),* $(,)?) => {
  170|       |        $crate::Chap49::SubsetSumStEph::SubsetSumStEph::SubsetSumStEphS::from_multiset(
  171|       |            $crate::ArraySeqStEphS![$($x),*]
  172|       |        )
  173|       |    };
  174|       |    () => {
  175|       |        $crate::Chap49::SubsetSumStEph::SubsetSumStEph::SubsetSumStEphS::new()
  176|       |    };
  177|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap49/SubsetSumStPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 49: Subset Sum - persistent, single-threaded.
    3|       |
    4|       |pub mod SubsetSumStPer {
    5|       |
    6|       |    use std::collections::HashMap;
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    8|       |
    9|       |    use crate::ArraySeqStPerS;
   10|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
   11|       |    use crate::Types::Types::*;
   12|       |
   13|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   14|       |    pub struct SubsetSumStPerS<T: StT> {
   15|       |        multiset: ArraySeqStPerS<T>,
   16|       |        memo: HashMap<(usize, i32), bool>,
   17|       |    }
   18|       |
   19|       |    /// Trait for subset sum operations
   20|       |    pub trait SubsetSumStPerTrait<T: StT> {
   21|       |        /// Create new subset sum solver
   22|       |        fn new() -> Self
   23|       |        where
   24|       |            T: Default;
   25|       |
   26|       |        /// Create from multiset
   27|       |        fn from_multiset(multiset: ArraySeqStPerS<T>) -> Self;
   28|       |
   29|       |        /// Solve subset sum problem
   30|       |        /// claude-4-sonet: Work (k|S|), Span (|S|), Parallelism (1)
   31|       |        fn subset_sum(&self, target: i32) -> bool
   32|       |        where
   33|       |            T: Into<i32> + Copy;
   34|       |
   35|       |        /// Get the multiset
   36|       |        fn multiset(&self) -> &ArraySeqStPerS<T>;
   37|       |
   38|       |        /// Get memoization table size
   39|       |        fn memo_size(&self) -> usize;
   40|       |    }
   41|       |
   42|       |    impl<T: StT> SubsetSumStPerS<T> {
   43|       |        /// Internal recursive subset sum with memoization
   44|       |        /// Claude Work: O(k*|S|) - each subproblem computed once
   45|       |        /// Claude Span: O(|S|) - maximum recursion depth
   46|    199|        fn subset_sum_rec(&mut self, i: usize, j: i32) -> bool
   47|    199|        where
   48|    199|            T: Into<i32> + Copy,
   49|       |        {
   50|       |            // Check memo first
   51|    199|            if let Some(&result) = self.memo.get(&(i, j)) {
                                       ^16
   52|     16|                return result;
   53|    183|            }
   54|       |
   55|    183|            let result = match (i, j) {
   56|     19|                | (_, 0) => true,  // Base case: target sum is 0
   57|     50|                | (0, _) => false, // Base case: no elements left, target > 0
   58|    114|                | (i, j) => {
   59|    114|                    let element_value: i32 = (*self.multiset.nth(i - 1)).into();
   60|    114|                    if element_value > j {
   61|       |                        // Element too large, skip it
   62|     19|                        self.subset_sum_rec(i - 1, j)
   63|       |                    } else {
   64|       |                        // Try both including and excluding the element
   65|     95|                        self.subset_sum_rec(i - 1, j - element_value) || self.subset_sum_rec(i - 1, j)
                                                                                       ^59  ^59            ^59    ^59
   66|       |                    }
   67|       |                }
   68|       |            };
   69|       |
   70|       |            // Memoize result
   71|    183|            self.memo.insert((i, j), result);
   72|    183|            result
   73|    199|        }
   74|       |    }
   75|       |
   76|       |    impl<T: StT> SubsetSumStPerTrait<T> for SubsetSumStPerS<T> {
   77|      1|        fn new() -> Self
   78|      1|        where
   79|      1|            T: Default,
   80|       |        {
   81|      1|            Self {
   82|      1|                multiset: ArraySeqStPerS::new(0, T::default()),
   83|      1|                memo: HashMap::new(),
   84|      1|            }
   85|      1|        }
   86|       |
   87|     16|        fn from_multiset(multiset: ArraySeqStPerS<T>) -> Self {
   88|     16|            Self {
   89|     16|                multiset,
   90|     16|                memo: HashMap::new(),
   91|     16|            }
   92|     16|        }
   93|       |
   94|     27|        fn subset_sum(&self, target: i32) -> bool
   95|     27|        where
   96|     27|            T: Into<i32> + Copy,
   97|       |        {
   98|     27|            if target < 0 {
   99|      1|                return false;
  100|     26|            }
  101|       |
  102|       |            // Create mutable copy for memoization
  103|     26|            let mut solver = self.clone();
  104|     26|            solver.memo.clear(); // Fresh memo for each query
  105|       |
  106|     26|            let n = solver.multiset.length();
  107|     26|            solver.subset_sum_rec(n, target)
  108|     27|        }
  109|       |
  110|      3|        fn multiset(&self) -> &ArraySeqStPerS<T> { &self.multiset }
  111|       |
  112|      1|        fn memo_size(&self) -> usize { self.memo.len() }
  113|       |    }
  114|       |
  115|       |    impl<T: StT> Display for SubsetSumStPerS<T> {
  116|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  117|      1|            write!(
  118|      1|                f,
  119|      1|                "SubsetSumStPer(multiset: {}, memo_entries: {})",
  120|       |                self.multiset,
  121|      1|                self.memo.len()
  122|       |            )
  123|      1|        }
  124|       |    }
  125|       |
  126|       |    impl<T: StT> IntoIterator for SubsetSumStPerS<T> {
  127|       |        type Item = T;
  128|       |        type IntoIter = <ArraySeqStPerS<T> as IntoIterator>::IntoIter;
  129|       |
  130|      1|        fn into_iter(self) -> Self::IntoIter { self.multiset.into_iter() }
  131|       |    }
  132|       |
  133|       |    impl<T: StT> IntoIterator for &SubsetSumStPerS<T> {
  134|       |        type Item = T;
  135|       |        type IntoIter = <ArraySeqStPerS<T> as IntoIterator>::IntoIter;
  136|       |
  137|      0|        fn into_iter(self) -> Self::IntoIter { self.multiset.clone().into_iter() }
  138|       |    }
  139|       |
  140|       |}
  141|       |
  142|       |#[macro_export]
  143|       |macro_rules! SubsetSumStPerLit {
  144|       |    ($($x:expr),* $(,)?) => {
  145|       |        $crate::Chap49::SubsetSumStPer::SubsetSumStPer::SubsetSumStPerS::from_multiset(
  146|       |            $crate::ArraySeqStPerS![$($x),*]
  147|       |        )
  148|       |    };
  149|       |    () => {
  150|       |        $crate::Chap49::SubsetSumStPer::SubsetSumStPer::SubsetSumStPerS::new()
  151|       |    };
  152|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap50/MatrixChainMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Multi-threaded ephemeral matrix chain multiplication implementation using Vec and Arc<Mutex<Vec>> for mutable thread safety.
    3|       |
    4|       |pub mod MatrixChainMtEph {
    5|       |
    6|       |    use std::collections::HashMap;
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    8|       |    use std::sync::{Arc, Mutex};
    9|       |    use std::thread;
   10|       |
   11|       |    use crate::Types::Types::*;
   12|       |
   13|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   14|       |    pub struct MatrixDim {
   15|       |        pub rows: usize,
   16|       |        pub cols: usize,
   17|       |    }
   18|       |
   19|       |    /// Ephemeral multi-threaded matrix chain multiplication solver using parallel dynamic programming
   20|       |    #[derive(Clone, Debug)]
   21|       |    pub struct MatrixChainMtEphS {
   22|       |        dimensions: Arc<Mutex<Vec<MatrixDim>>>,
   23|       |        memo: Arc<Mutex<HashMap<(usize, usize), usize>>>,
   24|       |    }
   25|       |
   26|       |    /// Trait for parallel matrix chain multiplication operations
   27|       |    pub trait MatrixChainMtEphTrait {
   28|       |        /// Create new matrix chain solver
   29|       |        fn new() -> Self;
   30|       |
   31|       |        /// Create from matrix dimensions
   32|       |        fn from_dimensions(dimensions: Vec<MatrixDim>) -> Self;
   33|       |
   34|       |        /// Create from dimension pairs (rows, cols)
   35|       |        fn from_dim_pairs(dim_pairs: Vec<Pair<usize, usize>>) -> Self;
   36|       |
   37|       |        /// claude-4-sonet: Work (n), Span (n log n), Parallelism (n/log n)
   38|       |        /// Compute optimal matrix chain multiplication cost where n=number of matrices
   39|       |        fn optimal_cost(&mut self) -> usize;
   40|       |
   41|       |        /// Get a copy of the matrix dimensions (thread-safe)
   42|       |        fn dimensions(&self) -> Vec<MatrixDim>;
   43|       |
   44|       |        /// Set matrix dimension at index
   45|       |        fn set_dimension(&mut self, index: usize, dim: MatrixDim);
   46|       |
   47|       |        /// Update matrix dimensions
   48|       |        fn update_dimension(&mut self, index: usize, rows: usize, cols: usize);
   49|       |
   50|       |        /// Get number of matrices
   51|       |        fn num_matrices(&self) -> usize;
   52|       |
   53|       |        /// Clear memoization table
   54|       |        fn clear_memo(&mut self);
   55|       |
   56|       |        /// Get memoization table size
   57|       |        fn memo_size(&self) -> usize;
   58|       |    }
   59|       |
   60|       |    impl MatrixChainMtEphS {
   61|       |        /// Calculate cost of multiplying matrices from i to j with split at k
   62|       |        /// Cost = rows[i] * cols[k] * cols[j] (scalar multiplications)
   63|     63|        fn multiply_cost(&self, i: usize, k: usize, j: usize) -> usize {
   64|     63|            let dimensions_guard = self.dimensions.lock().unwrap();
   65|     63|            let left_rows = dimensions_guard[i].rows;
   66|     63|            let split_cols = dimensions_guard[k].cols;
   67|     63|            let right_cols = dimensions_guard[j].cols;
   68|     63|            left_rows * split_cols * right_cols
   69|     63|        }
   70|       |
   71|       |        /// Parallel reduction to find minimum cost among split choices
   72|       |        /// Claude Work: O(n) - n comparisons
   73|       |        /// Claude Span: O(log n) - parallel reduction tree
   74|     91|        fn parallel_min_reduction(&self, costs: Vec<usize>) -> usize {
   75|     91|            if costs.is_empty() {
   76|      0|                return 0;
   77|     91|            }
   78|     91|            if costs.len() == 1 {
   79|     63|                return costs[0];
   80|     28|            }
   81|       |
   82|     28|            let mid = costs.len() / 2;
   83|     28|            let left_costs = costs[..mid].to_vec();
   84|     28|            let right_costs = costs[mid..].to_vec();
   85|       |
   86|     28|            let self_clone1 = self.clone();
   87|     28|            let self_clone2 = self.clone();
   88|       |
   89|     28|            let handle1 = thread::spawn(move || self_clone1.parallel_min_reduction(left_costs));
   90|       |
   91|     28|            let handle2 = thread::spawn(move || self_clone2.parallel_min_reduction(right_costs));
   92|       |
   93|     28|            let left_min = handle1.join().unwrap();
   94|     28|            let right_min = handle2.join().unwrap();
   95|       |
   96|     28|            left_min.min(right_min)
   97|     91|        }
   98|       |
   99|       |        /// Internal recursive matrix chain with memoization and parallel reduction
  100|       |        /// Claude Work: O(n) - O(n) subproblems, each O(n) work
  101|       |        /// Claude Span: O(n log n) - maximum recursion depth O(n), each level O(log n) parallel reduction
  102|    134|        fn matrix_chain_rec(&self, i: usize, j: usize) -> usize {
  103|       |            // Check memo first (thread-safe)
  104|       |            {
  105|    134|                let memo_guard = self.memo.lock().unwrap();
  106|    134|                if let Some(&result) = memo_guard.get(&(i, j)) {
                                           ^73
  107|     73|                    return result;
  108|     61|                }
  109|       |            }
  110|       |
  111|     61|            let result = if i == j {
  112|     26|                0 // Base case: single matrix, no multiplication needed
  113|       |            } else {
  114|       |                // Compute costs for each possible split in parallel
  115|     35|                let costs: Vec<usize> = (i..j)
  116|     63|                    .map(|k| {
                                   ^35
  117|     63|                        let left_cost = self.matrix_chain_rec(i, k);
  118|     63|                        let right_cost = self.matrix_chain_rec(k + 1, j);
  119|     63|                        let split_cost = self.multiply_cost(i, k, j);
  120|     63|                        left_cost + right_cost + split_cost
  121|     63|                    })
  122|     35|                    .collect();
  123|       |
  124|       |                // Use parallel reduction to find minimum
  125|     35|                self.parallel_min_reduction(costs)
  126|       |            };
  127|       |
  128|       |            // Memoize result (thread-safe)
  129|     61|            {
  130|     61|                let mut memo_guard = self.memo.lock().unwrap();
  131|     61|                memo_guard.insert((i, j), result);
  132|     61|            }
  133|       |
  134|     61|            result
  135|    134|        }
  136|       |    }
  137|       |
  138|       |    impl MatrixChainMtEphTrait for MatrixChainMtEphS {
  139|      2|        fn new() -> Self {
  140|      2|            Self {
  141|      2|                dimensions: Arc::new(Mutex::new(Vec::new())),
  142|      2|                memo: Arc::new(Mutex::new(HashMap::new())),
  143|      2|            }
  144|      2|        }
  145|       |
  146|      1|        fn from_dimensions(dimensions: Vec<MatrixDim>) -> Self {
  147|      1|            Self {
  148|      1|                dimensions: Arc::new(Mutex::new(dimensions)),
  149|      1|                memo: Arc::new(Mutex::new(HashMap::new())),
  150|      1|            }
  151|      1|        }
  152|       |
  153|     19|        fn from_dim_pairs(dim_pairs: Vec<Pair<usize, usize>>) -> Self {
  154|     19|            let dimensions: Vec<MatrixDim> = dim_pairs
  155|     19|                .into_iter()
  156|     19|                .map(|pair| MatrixDim {
  157|     51|                    rows: pair.0,
  158|     51|                    cols: pair.1,
  159|     51|                })
  160|     19|                .collect();
  161|       |
  162|     19|            Self {
  163|     19|                dimensions: Arc::new(Mutex::new(dimensions)),
  164|     19|                memo: Arc::new(Mutex::new(HashMap::new())),
  165|     19|            }
  166|     19|        }
  167|       |
  168|     10|        fn optimal_cost(&mut self) -> usize {
  169|     10|            let dimensions_len = {
  170|     10|                let dimensions_guard = self.dimensions.lock().unwrap();
  171|     10|                dimensions_guard.len()
  172|       |            };
  173|       |
  174|     10|            if dimensions_len <= 1 {
  175|      2|                return 0;
  176|      8|            }
  177|       |
  178|       |            // Clear memo for fresh computation
  179|      8|            {
  180|      8|                let mut memo_guard = self.memo.lock().unwrap();
  181|      8|                memo_guard.clear();
  182|      8|            }
  183|       |
  184|      8|            self.matrix_chain_rec(0, dimensions_len - 1)
  185|     10|        }
  186|       |
  187|      8|        fn dimensions(&self) -> Vec<MatrixDim> {
  188|      8|            let dimensions_guard = self.dimensions.lock().unwrap();
  189|      8|            dimensions_guard.clone()
  190|      8|        }
  191|       |
  192|      1|        fn set_dimension(&mut self, index: usize, dim: MatrixDim) {
  193|      1|            {
  194|      1|                let mut dimensions_guard = self.dimensions.lock().unwrap();
  195|      1|                dimensions_guard[index] = dim;
  196|      1|            }
  197|       |            // Clear memo since dimensions changed
  198|      1|            let mut memo_guard = self.memo.lock().unwrap();
  199|      1|            memo_guard.clear();
  200|      1|        }
  201|       |
  202|      1|        fn update_dimension(&mut self, index: usize, rows: usize, cols: usize) {
  203|      1|            let dim = MatrixDim { rows, cols };
  204|      1|            {
  205|      1|                let mut dimensions_guard = self.dimensions.lock().unwrap();
  206|      1|                dimensions_guard[index] = dim;
  207|      1|            }
  208|       |            // Clear memo since dimensions changed
  209|      1|            let mut memo_guard = self.memo.lock().unwrap();
  210|      1|            memo_guard.clear();
  211|      1|        }
  212|       |
  213|      7|        fn num_matrices(&self) -> usize {
  214|      7|            let dimensions_guard = self.dimensions.lock().unwrap();
  215|      7|            dimensions_guard.len()
  216|      7|        }
  217|       |
  218|      1|        fn clear_memo(&mut self) {
  219|      1|            let mut memo_guard = self.memo.lock().unwrap();
  220|      1|            memo_guard.clear();
  221|      1|        }
  222|       |
  223|      6|        fn memo_size(&self) -> usize {
  224|      6|            let memo_guard = self.memo.lock().unwrap();
  225|      6|            memo_guard.len()
  226|      6|        }
  227|       |    }
  228|       |
  229|       |    impl PartialEq for MatrixChainMtEphS {
  230|      1|        fn eq(&self, other: &Self) -> bool {
  231|       |            // Compare the contents of the Arc<Mutex<Vec>>
  232|      1|            let self_dims = self.dimensions.lock().unwrap();
  233|      1|            let other_dims = other.dimensions.lock().unwrap();
  234|      1|            *self_dims == *other_dims
  235|      1|        }
  236|       |    }
  237|       |
  238|       |    impl Eq for MatrixChainMtEphS {}
  239|       |
  240|       |    impl Display for MatrixChainMtEphS {
  241|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  242|      1|            let memo_size = {
  243|      1|                let memo_guard = self.memo.lock().unwrap();
  244|      1|                memo_guard.len()
  245|       |            };
  246|      1|            let dimensions_len = {
  247|      1|                let dimensions_guard = self.dimensions.lock().unwrap();
  248|      1|                dimensions_guard.len()
  249|       |            };
  250|      1|            write!(
  251|      1|                f,
  252|      1|                "MatrixChainMtEph(matrices: {}, memo_entries: {})",
  253|       |                dimensions_len, memo_size
  254|       |            )
  255|      1|        }
  256|       |    }
  257|       |
  258|       |    impl IntoIterator for MatrixChainMtEphS {
  259|       |        type Item = MatrixDim;
  260|       |        type IntoIter = std::vec::IntoIter<MatrixDim>;
  261|       |
  262|      0|        fn into_iter(self) -> Self::IntoIter {
  263|       |            // Extract Vec from Arc<Mutex<Vec>> - this consumes the Arc
  264|      0|            match Arc::try_unwrap(self.dimensions) {
  265|      0|                | Ok(mutex) => mutex.into_inner().unwrap().into_iter(),
  266|      0|                | Err(arc) => {
  267|      0|                    let dimensions_guard = arc.lock().unwrap();
  268|      0|                    dimensions_guard.clone().into_iter()
  269|       |                }
  270|       |            }
  271|      0|        }
  272|       |    }
  273|       |
  274|       |    impl<'a> IntoIterator for &'a MatrixChainMtEphS {
  275|       |        type Item = MatrixDim;
  276|       |        type IntoIter = std::vec::IntoIter<MatrixDim>;
  277|       |
  278|      0|        fn into_iter(self) -> Self::IntoIter {
  279|      0|            let dimensions_guard = self.dimensions.lock().unwrap();
  280|      0|            dimensions_guard.clone().into_iter()
  281|      0|        }
  282|       |    }
  283|       |
  284|       |    impl<'a> IntoIterator for &'a mut MatrixChainMtEphS {
  285|       |        type Item = MatrixDim;
  286|       |        type IntoIter = std::vec::IntoIter<MatrixDim>;
  287|       |
  288|      0|        fn into_iter(self) -> Self::IntoIter {
  289|      0|            let dimensions_guard = self.dimensions.lock().unwrap();
  290|      0|            dimensions_guard.clone().into_iter()
  291|      0|        }
  292|       |    }
  293|       |
  294|       |    impl Display for MatrixDim {
  295|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { write!(f, "{}{}", self.rows, self.cols) }
  296|       |    }
  297|       |
  298|       |    #[macro_export]
  299|       |    macro_rules! MatrixChainMtEphLit {
  300|       |        (dims: [$(($r:expr, $c:expr)),* $(,)?]) => {
  301|       |            $crate::Chap50::MatrixChainMtEph::MatrixChainMtEph::MatrixChainMtEphS::from_dim_pairs(
  302|       |                vec![$($crate::Types::Types::Pair($r, $c)),*]
  303|       |            )
  304|       |        };
  305|       |        () => {
  306|       |            $crate::Chap50::MatrixChainMtEph::MatrixChainMtEph::MatrixChainMtEphS::new()
  307|       |        };
  308|       |    }
  309|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap50/MatrixChainMtPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Multi-threaded persistent matrix chain multiplication implementation using Vec and Arc for thread safety.
    3|       |
    4|       |pub mod MatrixChainMtPer {
    5|       |
    6|       |    use std::collections::HashMap;
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    8|       |    use std::sync::{Arc, Mutex};
    9|       |    use std::thread;
   10|       |
   11|       |    use crate::Types::Types::*;
   12|       |
   13|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   14|       |    pub struct MatrixDim {
   15|       |        pub rows: usize,
   16|       |        pub cols: usize,
   17|       |    }
   18|       |
   19|       |    /// Persistent multi-threaded matrix chain multiplication solver using parallel dynamic programming
   20|       |    #[derive(Clone, Debug)]
   21|       |    pub struct MatrixChainMtPerS {
   22|       |        dimensions: Arc<Vec<MatrixDim>>,
   23|       |        memo: Arc<Mutex<HashMap<(usize, usize), usize>>>,
   24|       |    }
   25|       |
   26|       |    /// Trait for parallel matrix chain multiplication operations
   27|       |    pub trait MatrixChainMtPerTrait {
   28|       |        /// Create new matrix chain solver
   29|       |        fn new() -> Self;
   30|       |
   31|       |        /// Create from matrix dimensions
   32|       |        fn from_dimensions(dimensions: Vec<MatrixDim>) -> Self;
   33|       |
   34|       |        /// Create from dimension pairs (rows, cols)
   35|       |        fn from_dim_pairs(dim_pairs: Vec<Pair<usize, usize>>) -> Self;
   36|       |
   37|       |        /// claude-4-sonet: Work (n), Span (n log n), Parallelism (n/log n)
   38|       |        /// Compute optimal matrix chain multiplication cost where n=number of matrices
   39|       |        fn optimal_cost(&self) -> usize;
   40|       |
   41|       |        /// Get the matrix dimensions
   42|       |        fn dimensions(&self) -> &Arc<Vec<MatrixDim>>;
   43|       |
   44|       |        /// Get number of matrices
   45|       |        fn num_matrices(&self) -> usize;
   46|       |
   47|       |        /// Get memoization table size
   48|       |        fn memo_size(&self) -> usize;
   49|       |    }
   50|       |
   51|       |    impl MatrixChainMtPerS {
   52|       |        /// Calculate cost of multiplying matrices from i to j with split at k
   53|       |        /// Cost = rows[i] * cols[k] * cols[j] (scalar multiplications)
   54|     68|        fn multiply_cost(&self, i: usize, k: usize, j: usize) -> usize {
   55|     68|            let left_rows = self.dimensions[i].rows;
   56|     68|            let split_cols = self.dimensions[k].cols;
   57|     68|            let right_cols = self.dimensions[j].cols;
   58|     68|            left_rows * split_cols * right_cols
   59|     68|        }
   60|       |
   61|       |        /// Parallel reduction to find minimum cost among split choices
   62|       |        /// Claude Work: O(n) - n comparisons
   63|       |        /// Claude Span: O(log n) - parallel reduction tree
   64|     97|        fn parallel_min_reduction(&self, costs: Vec<usize>) -> usize {
   65|     97|            if costs.is_empty() {
   66|      0|                return 0;
   67|     97|            }
   68|     97|            if costs.len() == 1 {
   69|     68|                return costs[0];
   70|     29|            }
   71|       |
   72|     29|            let mid = costs.len() / 2;
   73|     29|            let left_costs = costs[..mid].to_vec();
   74|     29|            let right_costs = costs[mid..].to_vec();
   75|       |
   76|     29|            let self_clone1 = self.clone();
   77|     29|            let self_clone2 = self.clone();
   78|       |
   79|     29|            let handle1 = thread::spawn(move || self_clone1.parallel_min_reduction(left_costs));
   80|       |
   81|     29|            let handle2 = thread::spawn(move || self_clone2.parallel_min_reduction(right_costs));
   82|       |
   83|     29|            let left_min = handle1.join().unwrap();
   84|     29|            let right_min = handle2.join().unwrap();
   85|       |
   86|     29|            left_min.min(right_min)
   87|     97|        }
   88|       |
   89|       |        /// Internal recursive matrix chain with memoization and parallel reduction
   90|       |        /// Claude Work: O(n) - O(n) subproblems, each O(n) work
   91|       |        /// Claude Span: O(n log n) - maximum recursion depth O(n), each level O(log n) parallel reduction
   92|    146|        fn matrix_chain_rec(&self, i: usize, j: usize) -> usize {
   93|       |            // Check memo first (thread-safe)
   94|       |            {
   95|    146|                let memo_guard = self.memo.lock().unwrap();
   96|    146|                if let Some(&result) = memo_guard.get(&(i, j)) {
                                           ^76
   97|     76|                    return result;
   98|     70|                }
   99|       |            }
  100|       |
  101|     70|            let result = if i == j {
  102|     31|                0 // Base case: single matrix, no multiplication needed
  103|       |            } else {
  104|       |                // Compute costs for each possible split in parallel
  105|     39|                let costs: Vec<usize> = (i..j)
  106|     68|                    .map(|k| {
                                   ^39
  107|     68|                        let left_cost = self.matrix_chain_rec(i, k);
  108|     68|                        let right_cost = self.matrix_chain_rec(k + 1, j);
  109|     68|                        let split_cost = self.multiply_cost(i, k, j);
  110|     68|                        left_cost + right_cost + split_cost
  111|     68|                    })
  112|     39|                    .collect();
  113|       |
  114|       |                // Use parallel reduction to find minimum
  115|     39|                self.parallel_min_reduction(costs)
  116|       |            };
  117|       |
  118|       |            // Memoize result (thread-safe)
  119|     70|            {
  120|     70|                let mut memo_guard = self.memo.lock().unwrap();
  121|     70|                memo_guard.insert((i, j), result);
  122|     70|            }
  123|       |
  124|     70|            result
  125|    146|        }
  126|       |    }
  127|       |
  128|       |    impl MatrixChainMtPerTrait for MatrixChainMtPerS {
  129|      2|        fn new() -> Self {
  130|      2|            Self {
  131|      2|                dimensions: Arc::new(Vec::new()),
  132|      2|                memo: Arc::new(Mutex::new(HashMap::new())),
  133|      2|            }
  134|      2|        }
  135|       |
  136|      1|        fn from_dimensions(dimensions: Vec<MatrixDim>) -> Self {
  137|      1|            Self {
  138|      1|                dimensions: Arc::new(dimensions),
  139|      1|                memo: Arc::new(Mutex::new(HashMap::new())),
  140|      1|            }
  141|      1|        }
  142|       |
  143|     17|        fn from_dim_pairs(dim_pairs: Vec<Pair<usize, usize>>) -> Self {
  144|     17|            let dimensions: Vec<MatrixDim> = dim_pairs
  145|     17|                .into_iter()
  146|     17|                .map(|pair| MatrixDim {
  147|     47|                    rows: pair.0,
  148|     47|                    cols: pair.1,
  149|     47|                })
  150|     17|                .collect();
  151|       |
  152|     17|            Self {
  153|     17|                dimensions: Arc::new(dimensions),
  154|     17|                memo: Arc::new(Mutex::new(HashMap::new())),
  155|     17|            }
  156|     17|        }
  157|       |
  158|     12|        fn optimal_cost(&self) -> usize {
  159|     12|            if self.dimensions.len() <= 1 {
  160|      2|                return 0;
  161|     10|            }
  162|       |
  163|       |            // Clear memo for fresh computation
  164|     10|            {
  165|     10|                let mut memo_guard = self.memo.lock().unwrap();
  166|     10|                memo_guard.clear();
  167|     10|            }
  168|       |
  169|     10|            let n = self.dimensions.len();
  170|     10|            self.matrix_chain_rec(0, n - 1)
  171|     12|        }
  172|       |
  173|      6|        fn dimensions(&self) -> &Arc<Vec<MatrixDim>> { &self.dimensions }
  174|       |
  175|     12|        fn num_matrices(&self) -> usize { self.dimensions.len() }
  176|       |
  177|      0|        fn memo_size(&self) -> usize {
  178|      0|            let memo_guard = self.memo.lock().unwrap();
  179|      0|            memo_guard.len()
  180|      0|        }
  181|       |    }
  182|       |
  183|       |    impl PartialEq for MatrixChainMtPerS {
  184|      1|        fn eq(&self, other: &Self) -> bool { self.dimensions == other.dimensions }
  185|       |    }
  186|       |
  187|       |    impl Eq for MatrixChainMtPerS {}
  188|       |
  189|       |    impl Display for MatrixChainMtPerS {
  190|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  191|      1|            let memo_size = {
  192|      1|                let memo_guard = self.memo.lock().unwrap();
  193|      1|                memo_guard.len()
  194|       |            };
  195|      1|            write!(
  196|      1|                f,
  197|      1|                "MatrixChainMtPer(matrices: {}, memo_entries: {})",
  198|      1|                self.dimensions.len(),
  199|       |                memo_size
  200|       |            )
  201|      1|        }
  202|       |    }
  203|       |
  204|       |    impl IntoIterator for MatrixChainMtPerS {
  205|       |        type Item = MatrixDim;
  206|       |        type IntoIter = std::vec::IntoIter<MatrixDim>;
  207|       |
  208|      0|        fn into_iter(self) -> Self::IntoIter {
  209|       |            // Extract Vec from Arc - this consumes the Arc
  210|      0|            match Arc::try_unwrap(self.dimensions) {
  211|      0|                | Ok(vec) => vec.into_iter(),
  212|      0|                | Err(arc) => (*arc).clone().into_iter(),
  213|       |            }
  214|      0|        }
  215|       |    }
  216|       |
  217|       |    impl<'a> IntoIterator for &'a MatrixChainMtPerS {
  218|       |        type Item = MatrixDim;
  219|       |        type IntoIter = std::iter::Cloned<std::slice::Iter<'a, MatrixDim>>;
  220|       |
  221|      0|        fn into_iter(self) -> Self::IntoIter { self.dimensions.iter().cloned() }
  222|       |    }
  223|       |
  224|       |    impl Display for MatrixDim {
  225|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { write!(f, "{}{}", self.rows, self.cols) }
  226|       |    }
  227|       |
  228|       |    #[macro_export]
  229|       |    macro_rules! MatrixChainMtPerLit {
  230|       |        (dims: [$(($r:expr, $c:expr)),* $(,)?]) => {
  231|       |            $crate::Chap50::MatrixChainMtPer::MatrixChainMtPer::MatrixChainMtPerS::from_dim_pairs(
  232|       |                vec![$($crate::Types::Types::Pair($r, $c)),*]
  233|       |            )
  234|       |        };
  235|       |        () => {
  236|       |            $crate::Chap50::MatrixChainMtPer::MatrixChainMtPer::MatrixChainMtPerS::new()
  237|       |        };
  238|       |    }
  239|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap50/MatrixChainStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 50: Matrix Chain Multiplication - ephemeral, single-threaded.
    3|       |
    4|       |pub mod MatrixChainStEph {
    5|       |
    6|       |    use std::collections::HashMap;
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    8|       |
    9|       |    use crate::Types::Types::*;
   10|       |
   11|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   12|       |    pub struct MatrixDim {
   13|       |        pub rows: usize,
   14|       |        pub cols: usize,
   15|       |    }
   16|       |
   17|       |    /// Ephemeral single-threaded matrix chain multiplication solver using dynamic programming
   18|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   19|       |    pub struct MatrixChainStEphS {
   20|       |        dimensions: Vec<MatrixDim>,
   21|       |        memo: HashMap<(usize, usize), usize>,
   22|       |    }
   23|       |
   24|       |    /// Trait for matrix chain multiplication operations
   25|       |    pub trait MatrixChainStEphTrait {
   26|       |        /// Create new matrix chain solver
   27|       |        fn new() -> Self;
   28|       |
   29|       |        /// Create from matrix dimensions
   30|       |        fn from_dimensions(dimensions: Vec<MatrixDim>) -> Self;
   31|       |
   32|       |        /// Create from dimension pairs (rows, cols)
   33|       |        fn from_dim_pairs(dim_pairs: Vec<Pair<usize, usize>>) -> Self;
   34|       |
   35|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   36|       |        /// Compute optimal matrix chain multiplication cost where n=number of matrices
   37|       |        fn optimal_cost(&mut self) -> usize;
   38|       |
   39|       |        /// Get the matrix dimensions
   40|       |        fn dimensions(&self) -> &Vec<MatrixDim>;
   41|       |
   42|       |        /// Get mutable dimensions (ephemeral allows mutation)
   43|       |        fn dimensions_mut(&mut self) -> &mut Vec<MatrixDim>;
   44|       |
   45|       |        /// Set matrix dimension at index
   46|       |        fn set_dimension(&mut self, index: usize, dim: MatrixDim);
   47|       |
   48|       |        /// Update matrix dimensions
   49|       |        fn update_dimension(&mut self, index: usize, rows: usize, cols: usize);
   50|       |
   51|       |        /// Get number of matrices
   52|       |        fn num_matrices(&self) -> usize;
   53|       |
   54|       |        /// Clear memoization table
   55|       |        fn clear_memo(&mut self);
   56|       |
   57|       |        /// Get memoization table size
   58|       |        fn memo_size(&self) -> usize;
   59|       |    }
   60|       |
   61|       |    impl MatrixChainStEphS {
   62|       |        /// Calculate cost of multiplying matrices from i to j with split at k
   63|       |        /// Cost = rows[i] * cols[k] * cols[j] (scalar multiplications)
   64|      6|        fn multiply_cost(&self, i: usize, k: usize, j: usize) -> usize {
   65|      6|            let left_rows = self.dimensions[i].rows;
   66|      6|            let split_cols = self.dimensions[k].cols;
   67|      6|            let right_cols = self.dimensions[j].cols;
   68|      6|            left_rows * split_cols * right_cols
   69|      6|        }
   70|       |
   71|       |        /// Internal recursive matrix chain with memoization
   72|       |        /// Claude Work: O(n) - O(n) subproblems, each O(n) work
   73|       |        /// Claude Span: O(n) - maximum recursion depth O(n), each level O(n) work
   74|     15|        fn matrix_chain_rec(&mut self, i: usize, j: usize) -> usize {
   75|       |            // Check memo first
   76|     15|            if let Some(&result) = self.memo.get(&(i, j)) {
                                       ^3
   77|      3|                return result;
   78|     12|            }
   79|       |
   80|     12|            let result = if i == j {
   81|      7|                0 // Base case: single matrix, no multiplication needed
   82|       |            } else {
   83|       |                // Try each possible split point and find minimum cost
   84|      5|                (i..j)
   85|      6|                    .map(|k| {
                                   ^5
   86|      6|                        let left_cost = self.matrix_chain_rec(i, k);
   87|      6|                        let right_cost = self.matrix_chain_rec(k + 1, j);
   88|      6|                        let split_cost = self.multiply_cost(i, k, j);
   89|      6|                        left_cost + right_cost + split_cost
   90|      6|                    })
   91|      5|                    .min()
   92|      5|                    .unwrap_or(0)
   93|       |            };
   94|       |
   95|       |            // Memoize result
   96|     12|            self.memo.insert((i, j), result);
   97|     12|            result
   98|     15|        }
   99|       |    }
  100|       |
  101|       |    impl MatrixChainStEphTrait for MatrixChainStEphS {
  102|      2|        fn new() -> Self {
  103|      2|            Self {
  104|      2|                dimensions: Vec::new(),
  105|      2|                memo: HashMap::new(),
  106|      2|            }
  107|      2|        }
  108|       |
  109|      4|        fn from_dimensions(dimensions: Vec<MatrixDim>) -> Self {
  110|      4|            Self {
  111|      4|                dimensions,
  112|      4|                memo: HashMap::new(),
  113|      4|            }
  114|      4|        }
  115|       |
  116|     10|        fn from_dim_pairs(dim_pairs: Vec<Pair<usize, usize>>) -> Self {
  117|     10|            let dimensions = dim_pairs
  118|     10|                .into_iter()
  119|     10|                .map(|pair| MatrixDim {
  120|     24|                    rows: pair.0,
  121|     24|                    cols: pair.1,
  122|     24|                })
  123|     10|                .collect();
  124|       |
  125|     10|            Self {
  126|     10|                dimensions,
  127|     10|                memo: HashMap::new(),
  128|     10|            }
  129|     10|        }
  130|       |
  131|      5|        fn optimal_cost(&mut self) -> usize {
  132|      5|            if self.dimensions.len() <= 1 {
  133|      2|                return 0;
  134|      3|            }
  135|       |
  136|       |            // Clear memo for fresh computation
  137|      3|            self.memo.clear();
  138|       |
  139|      3|            let n = self.dimensions.len();
  140|      3|            self.matrix_chain_rec(0, n - 1)
  141|      5|        }
  142|       |
  143|      9|        fn dimensions(&self) -> &Vec<MatrixDim> { &self.dimensions }
  144|       |
  145|      2|        fn dimensions_mut(&mut self) -> &mut Vec<MatrixDim> { &mut self.dimensions }
  146|       |
  147|      2|        fn set_dimension(&mut self, index: usize, dim: MatrixDim) {
  148|      2|            if index < self.dimensions.len() {
  149|      2|                self.dimensions[index] = dim;
  150|      2|            }
                          ^0
  151|       |            // Clear memo since dimensions changed
  152|      2|            self.memo.clear();
  153|      2|        }
  154|       |
  155|      1|        fn update_dimension(&mut self, index: usize, rows: usize, cols: usize) {
  156|      1|            let dim = MatrixDim { rows, cols };
  157|      1|            if index < self.dimensions.len() {
  158|      1|                self.dimensions[index] = dim;
  159|      1|            }
                          ^0
  160|       |            // Clear memo since dimensions changed
  161|      1|            self.memo.clear();
  162|      1|        }
  163|       |
  164|      7|        fn num_matrices(&self) -> usize { self.dimensions.len() }
  165|       |
  166|      1|        fn clear_memo(&mut self) { self.memo.clear(); }
  167|       |
  168|      4|        fn memo_size(&self) -> usize { self.memo.len() }
  169|       |    }
  170|       |
  171|       |    impl Display for MatrixChainStEphS {
  172|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  173|      0|            write!(
  174|      0|                f,
  175|      0|                "MatrixChainStEph(matrices: {}, memo_entries: {})",
  176|      0|                self.dimensions.len(),
  177|      0|                self.memo.len()
  178|       |            )
  179|      0|        }
  180|       |    }
  181|       |
  182|       |    impl IntoIterator for MatrixChainStEphS {
  183|       |        type Item = MatrixDim;
  184|       |        type IntoIter = std::vec::IntoIter<MatrixDim>;
  185|       |
  186|      1|        fn into_iter(self) -> Self::IntoIter { self.dimensions.into_iter() }
  187|       |    }
  188|       |
  189|       |    impl<'a> IntoIterator for &'a MatrixChainStEphS {
  190|       |        type Item = MatrixDim;
  191|       |        type IntoIter = std::iter::Cloned<std::slice::Iter<'a, MatrixDim>>;
  192|       |
  193|      0|        fn into_iter(self) -> Self::IntoIter { self.dimensions.iter().cloned() }
  194|       |    }
  195|       |
  196|       |    impl<'a> IntoIterator for &'a mut MatrixChainStEphS {
  197|       |        type Item = MatrixDim;
  198|       |        type IntoIter = std::iter::Cloned<std::slice::Iter<'a, MatrixDim>>;
  199|       |
  200|      0|        fn into_iter(self) -> Self::IntoIter { self.dimensions.iter().cloned() }
  201|       |    }
  202|       |
  203|       |    impl Display for MatrixDim {
  204|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { write!(f, "{}{}", self.rows, self.cols) }
  205|       |    }
  206|       |
  207|       |    #[macro_export]
  208|       |    macro_rules! MatrixChainStEphLit {
  209|       |        (dims: [$(($r:expr, $c:expr)),* $(,)?]) => {
  210|       |            $crate::Chap50::MatrixChainStEph::MatrixChainStEph::MatrixChainStEphS::from_dim_pairs(
  211|       |                vec![$($crate::Types::Types::Pair($r, $c)),*]
  212|       |            )
  213|       |        };
  214|       |        () => {
  215|       |            $crate::Chap50::MatrixChainStEph::MatrixChainStEph::MatrixChainStEphS::new()
  216|       |        };
  217|       |    }
  218|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap50/MatrixChainStPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 50: Matrix Chain Multiplication - persistent, single-threaded.
    3|       |
    4|       |pub mod MatrixChainStPer {
    5|       |
    6|       |    use std::collections::HashMap;
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    8|       |
    9|       |    use crate::Types::Types::*;
   10|       |
   11|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   12|       |    pub struct MatrixDim {
   13|       |        pub rows: usize,
   14|       |        pub cols: usize,
   15|       |    }
   16|       |
   17|       |    /// Persistent single-threaded matrix chain multiplication solver using dynamic programming
   18|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   19|       |    pub struct MatrixChainStPerS {
   20|       |        dimensions: Vec<MatrixDim>,
   21|       |        memo: HashMap<(usize, usize), usize>,
   22|       |    }
   23|       |
   24|       |    /// Trait for matrix chain multiplication operations
   25|       |    pub trait MatrixChainStPerTrait {
   26|       |        /// Create new matrix chain solver
   27|       |        fn new() -> Self;
   28|       |
   29|       |        /// Create from matrix dimensions
   30|       |        fn from_dimensions(dimensions: Vec<MatrixDim>) -> Self;
   31|       |
   32|       |        /// Create from dimension pairs (rows, cols)
   33|       |        fn from_dim_pairs(dim_pairs: Vec<Pair<usize, usize>>) -> Self;
   34|       |
   35|       |        /// Compute optimal matrix chain multiplication cost using dynamic programming
   36|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   37|       |        fn optimal_cost(&self) -> usize;
   38|       |
   39|       |        /// Get the matrix dimensions
   40|       |        fn dimensions(&self) -> &Vec<MatrixDim>;
   41|       |
   42|       |        /// Get number of matrices
   43|       |        fn num_matrices(&self) -> usize;
   44|       |
   45|       |        /// Get memoization table size
   46|       |        fn memo_size(&self) -> usize;
   47|       |    }
   48|       |
   49|       |    impl MatrixChainStPerS {
   50|       |        /// Calculate cost of multiplying matrices from i to j with split at k
   51|       |        /// Cost = rows[i] * cols[k] * cols[j] (scalar multiplications)
   52|     50|        fn multiply_cost(&self, i: usize, k: usize, j: usize) -> usize {
   53|     50|            let left_rows = self.dimensions[i].rows;
   54|     50|            let split_cols = self.dimensions[k].cols;
   55|     50|            let right_cols = self.dimensions[j].cols;
   56|     50|            left_rows * split_cols * right_cols
   57|     50|        }
   58|       |
   59|       |        /// Internal recursive matrix chain with memoization
   60|       |        /// Claude Work: O(n) - O(n) subproblems, each O(n) work
   61|       |        /// Claude Span: O(n) - maximum recursion depth O(n), each level O(n) work
   62|    110|        fn matrix_chain_rec(&mut self, i: usize, j: usize) -> usize {
   63|       |            // Check memo first
   64|    110|            if let Some(&result) = self.memo.get(&(i, j)) {
                                       ^49
   65|     49|                return result;
   66|     61|            }
   67|       |
   68|     61|            let result = if i == j {
   69|     29|                0 // Base case: single matrix, no multiplication needed
   70|       |            } else {
   71|       |                // Try each possible split point and find minimum cost
   72|     32|                (i..j)
   73|     50|                    .map(|k| {
                                   ^32
   74|     50|                        let left_cost = self.matrix_chain_rec(i, k);
   75|     50|                        let right_cost = self.matrix_chain_rec(k + 1, j);
   76|     50|                        let split_cost = self.multiply_cost(i, k, j);
   77|     50|                        left_cost + right_cost + split_cost
   78|     50|                    })
   79|     32|                    .min()
   80|     32|                    .unwrap_or(0)
   81|       |            };
   82|       |
   83|       |            // Memoize result
   84|     61|            self.memo.insert((i, j), result);
   85|     61|            result
   86|    110|        }
   87|       |    }
   88|       |
   89|       |    impl MatrixChainStPerTrait for MatrixChainStPerS {
   90|      3|        fn new() -> Self {
   91|      3|            Self {
   92|      3|                dimensions: Vec::new(),
   93|      3|                memo: HashMap::new(),
   94|      3|            }
   95|      3|        }
   96|       |
   97|      7|        fn from_dimensions(dimensions: Vec<MatrixDim>) -> Self {
   98|      7|            Self {
   99|      7|                dimensions,
  100|      7|                memo: HashMap::new(),
  101|      7|            }
  102|      7|        }
  103|       |
  104|     10|        fn from_dim_pairs(dim_pairs: Vec<Pair<usize, usize>>) -> Self {
  105|     10|            let dimensions = dim_pairs
  106|     10|                .into_iter()
  107|     10|                .map(|pair| MatrixDim {
  108|     26|                    rows: pair.0,
  109|     26|                    cols: pair.1,
  110|     26|                })
  111|     10|                .collect();
  112|       |
  113|     10|            Self {
  114|     10|                dimensions,
  115|     10|                memo: HashMap::new(),
  116|     10|            }
  117|     10|        }
  118|       |
  119|     14|        fn optimal_cost(&self) -> usize {
  120|     14|            if self.dimensions.len() <= 1 {
  121|      4|                return 0;
  122|     10|            }
  123|       |
  124|       |            // Create mutable copy for memoization
  125|     10|            let mut solver = self.clone();
  126|     10|            solver.memo.clear(); // Fresh memo for each query
  127|       |
  128|     10|            let n = solver.dimensions.len();
  129|     10|            solver.matrix_chain_rec(0, n - 1)
  130|     14|        }
  131|       |
  132|      1|        fn dimensions(&self) -> &Vec<MatrixDim> { &self.dimensions }
  133|       |
  134|     12|        fn num_matrices(&self) -> usize { self.dimensions.len() }
  135|       |
  136|      0|        fn memo_size(&self) -> usize { self.memo.len() }
  137|       |    }
  138|       |
  139|       |    impl Display for MatrixChainStPerS {
  140|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  141|      0|            write!(
  142|      0|                f,
  143|      0|                "MatrixChainStPer(matrices: {}, memo_entries: {})",
  144|      0|                self.dimensions.len(),
  145|      0|                self.memo.len()
  146|       |            )
  147|      0|        }
  148|       |    }
  149|       |
  150|       |    impl IntoIterator for MatrixChainStPerS {
  151|       |        type Item = MatrixDim;
  152|       |        type IntoIter = std::vec::IntoIter<MatrixDim>;
  153|       |
  154|      1|        fn into_iter(self) -> Self::IntoIter { self.dimensions.into_iter() }
  155|       |    }
  156|       |
  157|       |    impl<'a> IntoIterator for &'a MatrixChainStPerS {
  158|       |        type Item = MatrixDim;
  159|       |        type IntoIter = std::iter::Cloned<std::slice::Iter<'a, MatrixDim>>;
  160|       |
  161|      0|        fn into_iter(self) -> Self::IntoIter { self.dimensions.iter().cloned() }
  162|       |    }
  163|       |
  164|       |    impl Display for MatrixDim {
  165|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { write!(f, "{}{}", self.rows, self.cols) }
  166|       |    }
  167|       |
  168|       |}
  169|       |
  170|       |#[macro_export]
  171|       |macro_rules! MatrixChainStPerLit {
  172|       |    (dims: [$(($r:expr, $c:expr)),* $(,)?]) => {
  173|       |        $crate::Chap50::MatrixChainStPer::MatrixChainStPer::MatrixChainStPerS::from_dim_pairs(
  174|       |            vec![$($crate::Types::Types::Pair($r, $c)),*]
  175|       |        )
  176|       |    };
  177|       |    () => {
  178|       |        $crate::Chap50::MatrixChainStPer::MatrixChainStPer::MatrixChainStPerS::new()
  179|       |    };
  180|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap50/OptBinSearchTreeMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Multi-threaded ephemeral optimal binary search tree implementation using Vec and Arc<Mutex<Vec>> for mutable thread safety.
    3|       |
    4|       |pub mod OptBinSearchTreeMtEph {
    5|       |
    6|       |    use std::collections::HashMap;
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    8|       |    use std::sync::{Arc, Mutex};
    9|       |    use std::thread;
   10|       |
   11|       |    use crate::Chap50::Probability::Probability::Probability;
   12|       |    use crate::Types::Types::*;
   13|       |
   14|       |    #[derive(Clone, Debug)]
   15|       |    pub struct KeyProb<T: MtVal> {
   16|       |        pub key: T,
   17|       |        pub prob: Probability,
   18|       |    }
   19|       |
   20|       |    /// Ephemeral multi-threaded optimal binary search tree solver using parallel dynamic programming
   21|       |    #[derive(Clone, Debug)]
   22|       |    pub struct OBSTMtEphS<T: MtVal> {
   23|       |        keys: Arc<Mutex<Vec<KeyProb<T>>>>,
   24|       |        memo: Arc<Mutex<HashMap<(usize, usize), Probability>>>,
   25|       |    }
   26|       |
   27|       |    /// Trait for parallel optimal BST operations
   28|       |    pub trait OBSTMtEphTrait<T: MtVal> {
   29|       |        /// Create new optimal BST solver
   30|       |        fn new() -> Self;
   31|       |
   32|       |        /// Create from keys and probabilities
   33|       |        fn from_keys_probs(keys: Vec<T>, probs: Vec<Probability>) -> Self;
   34|       |
   35|       |        /// Create from key-probability pairs
   36|       |        fn from_key_probs(key_probs: Vec<KeyProb<T>>) -> Self;
   37|       |
   38|       |        /// claude-4-sonet: Work (n), Span (n log n), Parallelism (n/log n)
   39|       |        /// Compute optimal BST cost where n=number of keys
   40|       |        fn optimal_cost(&mut self) -> Probability
   41|       |        where
   42|       |            T: Send + Sync + 'static;
   43|       |
   44|       |        /// Get a copy of the keys with probabilities (thread-safe)
   45|       |        fn keys(&self) -> Vec<KeyProb<T>>;
   46|       |
   47|       |        /// Set key-probability pair at index
   48|       |        fn set_key_prob(&mut self, index: usize, key_prob: KeyProb<T>);
   49|       |
   50|       |        /// Update probability for key at index
   51|       |        fn update_prob(&mut self, index: usize, prob: Probability);
   52|       |
   53|       |        /// Get number of keys
   54|       |        fn num_keys(&self) -> usize;
   55|       |
   56|       |        /// Clear memoization table
   57|       |        fn clear_memo(&mut self);
   58|       |
   59|       |        /// Get memoization table size
   60|       |        fn memo_size(&self) -> usize;
   61|       |    }
   62|       |
   63|       |    impl<T: MtVal> OBSTMtEphS<T> {
   64|       |        /// Parallel reduction to find minimum cost among root choices
   65|       |        /// Claude Work: O(n) - n comparisons
   66|       |        /// Claude Span: O(log n) - parallel reduction tree
   67|    287|        fn parallel_min_reduction(&self, costs: Vec<Probability>) -> Probability {
   68|    287|            if costs.is_empty() {
   69|      0|                return Probability::infinity();
   70|    287|            }
   71|    287|            if costs.len() == 1 {
   72|    179|                return costs[0];
   73|    108|            }
   74|       |
   75|    108|            let mid = costs.len() / 2;
   76|    108|            let left_costs = costs[..mid].to_vec();
   77|    108|            let right_costs = costs[mid..].to_vec();
   78|       |
   79|    108|            let self_clone1 = self.clone();
   80|    108|            let self_clone2 = self.clone();
   81|       |
   82|    108|            let handle1 = thread::spawn(move || self_clone1.parallel_min_reduction(left_costs));
   83|       |
   84|    108|            let handle2 = thread::spawn(move || self_clone2.parallel_min_reduction(right_costs));
   85|       |
   86|    108|            let left_min = handle1.join().unwrap();
   87|    108|            let right_min = handle2.join().unwrap();
   88|       |
   89|    108|            std::cmp::min(left_min, right_min)
   90|    287|        }
   91|       |
   92|       |        /// Internal recursive optimal BST with memoization and parallel reduction
   93|       |        /// Claude Work: O(n) - O(n) subproblems, each O(n) work
   94|       |        /// Claude Span: O(n log n) - maximum recursion depth O(n), each level O(log n) parallel reduction
   95|    366|        fn obst_rec(&self, i: usize, l: usize) -> Probability
   96|    366|        where
   97|    366|            T: Send + Sync + 'static,
   98|       |        {
   99|       |            // Check memo first (thread-safe)
  100|       |            {
  101|    366|                let memo_guard = self.memo.lock().unwrap();
  102|    366|                if let Some(&result) = memo_guard.get(&(i, l)) {
                                           ^261
  103|    261|                    return result;
  104|    105|                }
  105|       |            }
  106|       |
  107|    105|            let result = if l == 0 {
  108|     34|                Probability::zero() // Base case: empty subsequence
  109|       |            } else {
  110|       |                // Sum probabilities for this subsequence (thread-safe access)
  111|     71|                let prob_sum: Probability = {
  112|     71|                    let keys_guard = self.keys.lock().unwrap();
  113|     71|                    (0..l)
  114|    179|                        .map(|k| keys_guard[i + k].prob)
                                       ^71
  115|    179|                        .fold(Probability::zero(), |acc, p| acc + p)
                                       ^71  ^71
  116|       |                };
  117|       |
  118|       |                // Compute costs for each possible root in parallel
  119|     71|                let costs: Vec<Probability> = (0..l)
  120|    179|                    .map(|k| {
                                   ^71
  121|    179|                        let left_cost = self.obst_rec(i, k);
  122|    179|                        let right_cost = self.obst_rec(i + k + 1, l - k - 1);
  123|    179|                        left_cost + right_cost
  124|    179|                    })
  125|     71|                    .collect();
  126|       |
  127|       |                // Use parallel reduction to find minimum
  128|     71|                let min_cost = self.parallel_min_reduction(costs);
  129|       |
  130|     71|                prob_sum + min_cost
  131|       |            };
  132|       |
  133|       |            // Memoize result (thread-safe)
  134|    105|            {
  135|    105|                let mut memo_guard = self.memo.lock().unwrap();
  136|    105|                memo_guard.insert((i, l), result);
  137|    105|            }
  138|       |
  139|    105|            result
  140|    366|        }
  141|       |    }
  142|       |
  143|       |    impl<T: MtVal> OBSTMtEphTrait<T> for OBSTMtEphS<T> {
  144|      2|        fn new() -> Self {
  145|      2|            Self {
  146|      2|                keys: Arc::new(Mutex::new(Vec::new())),
  147|      2|                memo: Arc::new(Mutex::new(HashMap::new())),
  148|      2|            }
  149|      2|        }
  150|       |
  151|     22|        fn from_keys_probs(keys: Vec<T>, probs: Vec<Probability>) -> Self {
  152|     22|            let key_probs: Vec<KeyProb<T>> = keys
  153|     22|                .into_iter()
  154|     22|                .zip(probs.into_iter())
  155|     68|                .map(|(key, prob)| KeyProb { key, prob })
                               ^22
  156|     22|                .collect();
  157|       |
  158|     22|            Self {
  159|     22|                keys: Arc::new(Mutex::new(key_probs)),
  160|     22|                memo: Arc::new(Mutex::new(HashMap::new())),
  161|     22|            }
  162|     22|        }
  163|       |
  164|      1|        fn from_key_probs(key_probs: Vec<KeyProb<T>>) -> Self {
  165|      1|            Self {
  166|      1|                keys: Arc::new(Mutex::new(key_probs)),
  167|      1|                memo: Arc::new(Mutex::new(HashMap::new())),
  168|      1|            }
  169|      1|        }
  170|       |
  171|      9|        fn optimal_cost(&mut self) -> Probability
  172|      9|        where
  173|      9|            T: Send + Sync + 'static,
  174|       |        {
  175|      9|            let keys_len = {
  176|      9|                let keys_guard = self.keys.lock().unwrap();
  177|      9|                keys_guard.len()
  178|       |            };
  179|       |
  180|      9|            if keys_len == 0 {
  181|      1|                return Probability::zero();
  182|      8|            }
  183|       |
  184|       |            // Clear memo for fresh computation
  185|      8|            {
  186|      8|                let mut memo_guard = self.memo.lock().unwrap();
  187|      8|                memo_guard.clear();
  188|      8|            }
  189|       |
  190|      8|            self.obst_rec(0, keys_len)
  191|      9|        }
  192|       |
  193|      9|        fn keys(&self) -> Vec<KeyProb<T>> {
  194|      9|            let keys_guard = self.keys.lock().unwrap();
  195|      9|            keys_guard.clone()
  196|      9|        }
  197|       |
  198|      1|        fn set_key_prob(&mut self, index: usize, key_prob: KeyProb<T>) {
  199|      1|            {
  200|      1|                let mut keys_guard = self.keys.lock().unwrap();
  201|      1|                keys_guard[index] = key_prob;
  202|      1|            }
  203|       |            // Clear memo since keys changed
  204|      1|            let mut memo_guard = self.memo.lock().unwrap();
  205|      1|            memo_guard.clear();
  206|      1|        }
  207|       |
  208|      1|        fn update_prob(&mut self, index: usize, prob: Probability) {
  209|      1|            {
  210|      1|                let mut keys_guard = self.keys.lock().unwrap();
  211|      1|                keys_guard[index].prob = prob;
  212|      1|            }
  213|       |            // Clear memo since probabilities changed
  214|      1|            let mut memo_guard = self.memo.lock().unwrap();
  215|      1|            memo_guard.clear();
  216|      1|        }
  217|       |
  218|      6|        fn num_keys(&self) -> usize {
  219|      6|            let keys_guard = self.keys.lock().unwrap();
  220|      6|            keys_guard.len()
  221|      6|        }
  222|       |
  223|      1|        fn clear_memo(&mut self) {
  224|      1|            let mut memo_guard = self.memo.lock().unwrap();
  225|      1|            memo_guard.clear();
  226|      1|        }
  227|       |
  228|      4|        fn memo_size(&self) -> usize {
  229|      4|            let memo_guard = self.memo.lock().unwrap();
  230|      4|            memo_guard.len()
  231|      4|        }
  232|       |    }
  233|       |
  234|       |    impl<T: MtVal> PartialEq for OBSTMtEphS<T> {
  235|      1|        fn eq(&self, other: &Self) -> bool {
  236|       |            // Compare the contents of the Arc<Mutex<Vec>>
  237|      1|            let self_keys = self.keys.lock().unwrap();
  238|      1|            let other_keys = other.keys.lock().unwrap();
  239|      1|            *self_keys == *other_keys
  240|      1|        }
  241|       |    }
  242|       |
  243|       |    impl<T: MtVal> Eq for OBSTMtEphS<T> {}
  244|       |
  245|       |    impl<T: MtVal> Display for OBSTMtEphS<T> {
  246|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  247|      1|            let memo_size = {
  248|      1|                let memo_guard = self.memo.lock().unwrap();
  249|      1|                memo_guard.len()
  250|       |            };
  251|      1|            let keys_len = {
  252|      1|                let keys_guard = self.keys.lock().unwrap();
  253|      1|                keys_guard.len()
  254|       |            };
  255|      1|            write!(f, "OBSTMtEph(keys: {}, memo_entries: {})", keys_len, memo_size)
  256|      1|        }
  257|       |    }
  258|       |
  259|       |    impl<T: MtVal> IntoIterator for OBSTMtEphS<T> {
  260|       |        type Item = KeyProb<T>;
  261|       |        type IntoIter = std::vec::IntoIter<KeyProb<T>>;
  262|       |
  263|      1|        fn into_iter(self) -> Self::IntoIter {
  264|       |            // Extract Vec from Arc<Mutex<Vec>> - this consumes the Arc
  265|      1|            match Arc::try_unwrap(self.keys) {
  266|      1|                | Ok(mutex) => mutex.into_inner().unwrap().into_iter(),
  267|      0|                | Err(arc) => {
  268|      0|                    let keys_guard = arc.lock().unwrap();
  269|      0|                    keys_guard.clone().into_iter()
  270|       |                }
  271|       |            }
  272|      1|        }
  273|       |    }
  274|       |
  275|       |    impl<'a, T: MtVal> IntoIterator for &'a OBSTMtEphS<T> {
  276|       |        type Item = KeyProb<T>;
  277|       |        type IntoIter = std::vec::IntoIter<KeyProb<T>>;
  278|       |
  279|      1|        fn into_iter(self) -> Self::IntoIter {
  280|      1|            let keys_guard = self.keys.lock().unwrap();
  281|      1|            keys_guard.clone().into_iter()
  282|      1|        }
  283|       |    }
  284|       |
  285|       |    impl<'a, T: MtVal> IntoIterator for &'a mut OBSTMtEphS<T> {
  286|       |        type Item = KeyProb<T>;
  287|       |        type IntoIter = std::vec::IntoIter<KeyProb<T>>;
  288|       |
  289|      0|        fn into_iter(self) -> Self::IntoIter {
  290|      0|            let keys_guard = self.keys.lock().unwrap();
  291|      0|            keys_guard.clone().into_iter()
  292|      0|        }
  293|       |    }
  294|       |
  295|       |    impl<T: MtVal + PartialEq> PartialEq for KeyProb<T> {
  296|      2|        fn eq(&self, other: &Self) -> bool {
  297|      2|            self.key == other.key && (self.prob.value() - other.prob.value()).abs() < f64::EPSILON
  298|      2|        }
  299|       |    }
  300|       |
  301|       |    impl<T: MtVal> Eq for KeyProb<T> {}
  302|       |
  303|       |    impl<T: MtVal + Display> Display for KeyProb<T> {
  304|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { write!(f, "({}: {:.3})", self.key, self.prob) }
  305|       |    }
  306|       |
  307|       |    #[macro_export]
  308|       |    macro_rules! OBSTMtEphLit {
  309|       |        (keys: [$($k:expr),* $(,)?], probs: [$($p:expr),* $(,)?]) => {
  310|       |            $crate::Chap50::OptBinSearchTreeMtEph::OptBinSearchTreeMtEph::OBSTMtEphS::from_keys_probs(
  311|       |                vec![$($k),*],
  312|       |                vec![$($crate::Chap50::Probability::Probability::Probability::new($p)),*]
  313|       |            )
  314|       |        };
  315|       |        () => {
  316|       |            $crate::Chap50::OptBinSearchTreeMtEph::OptBinSearchTreeMtEph::OBSTMtEphS::new()
  317|       |        };
  318|       |    }
  319|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap50/OptBinSearchTreeMtPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Multi-threaded persistent optimal binary search tree implementation using Vec and Arc for thread safety.
    3|       |
    4|       |pub mod OptBinSearchTreeMtPer {
    5|       |
    6|       |    use std::collections::HashMap;
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    8|       |    use std::sync::{Arc, Mutex};
    9|       |    use std::thread;
   10|       |
   11|       |    use crate::Chap50::Probability::Probability::Probability;
   12|       |    use crate::Types::Types::*;
   13|       |
   14|       |    #[derive(Clone, Debug)]
   15|       |    pub struct KeyProb<T: MtVal> {
   16|       |        pub key: T,
   17|       |        pub prob: Probability,
   18|       |    }
   19|       |
   20|       |    /// Persistent multi-threaded optimal binary search tree solver using parallel dynamic programming
   21|       |    #[derive(Clone, Debug)]
   22|       |    pub struct OBSTMtPerS<T: MtVal> {
   23|       |        keys: Arc<Vec<KeyProb<T>>>,
   24|       |        memo: Arc<Mutex<HashMap<(usize, usize), Probability>>>,
   25|       |    }
   26|       |
   27|       |    /// Trait for parallel optimal BST operations
   28|       |    pub trait OBSTMtPerTrait<T: MtVal> {
   29|       |        /// Create new optimal BST solver
   30|       |        fn new() -> Self;
   31|       |
   32|       |        /// Create from keys and probabilities
   33|       |        fn from_keys_probs(keys: Vec<T>, probs: Vec<Probability>) -> Self;
   34|       |
   35|       |        /// Create from key-probability pairs
   36|       |        fn from_key_probs(key_probs: Vec<KeyProb<T>>) -> Self;
   37|       |
   38|       |        /// claude-4-sonet: Work (n), Span (n log n), Parallelism (n/log n)
   39|       |        /// Compute optimal BST cost where n=number of keys
   40|       |        fn optimal_cost(&self) -> Probability
   41|       |        where
   42|       |            T: Send + Sync + 'static;
   43|       |
   44|       |        /// Get the keys with probabilities
   45|       |        fn keys(&self) -> &Arc<Vec<KeyProb<T>>>;
   46|       |
   47|       |        /// Get number of keys
   48|       |        fn num_keys(&self) -> usize;
   49|       |
   50|       |        /// Get memoization table size
   51|       |        fn memo_size(&self) -> usize;
   52|       |    }
   53|       |
   54|       |    impl<T: MtVal> OBSTMtPerS<T> {
   55|       |        /// Parallel reduction to find minimum cost among root choices
   56|       |        /// Claude Work: O(n) - n comparisons
   57|       |        /// Claude Span: O(log n) - parallel reduction tree
   58|    168|        fn parallel_min_reduction(&self, costs: Vec<Probability>) -> Probability {
   59|    168|            if costs.is_empty() {
   60|      0|                return Probability::infinity();
   61|    168|            }
   62|    168|            if costs.len() == 1 {
   63|    114|                return costs[0];
   64|     54|            }
   65|       |
   66|     54|            let mid = costs.len() / 2;
   67|     54|            let left_costs = costs[..mid].to_vec();
   68|     54|            let right_costs = costs[mid..].to_vec();
   69|       |
   70|     54|            let self_clone1 = self.clone();
   71|     54|            let self_clone2 = self.clone();
   72|       |
   73|     54|            let handle1 = thread::spawn(move || self_clone1.parallel_min_reduction(left_costs));
   74|       |
   75|     54|            let handle2 = thread::spawn(move || self_clone2.parallel_min_reduction(right_costs));
   76|       |
   77|     54|            let left_min = handle1.join().unwrap();
   78|     54|            let right_min = handle2.join().unwrap();
   79|       |
   80|     54|            std::cmp::min(left_min, right_min)
   81|    168|        }
   82|       |
   83|       |        /// Internal recursive optimal BST with memoization and parallel reduction
   84|       |        /// Claude Work: O(n) - O(n) subproblems, each O(n) work
   85|       |        /// Claude Span: O(n log n) - maximum recursion depth O(n), each level O(log n) parallel reduction
   86|    237|        fn obst_rec(&self, i: usize, l: usize) -> Probability
   87|    237|        where
   88|    237|            T: Send + Sync + 'static,
   89|       |        {
   90|       |            // Check memo first (thread-safe)
   91|       |            {
   92|    237|                let memo_guard = self.memo.lock().unwrap();
   93|    237|                if let Some(&result) = memo_guard.get(&(i, l)) {
                                           ^141
   94|    141|                    return result;
   95|     96|                }
   96|       |            }
   97|       |
   98|     96|            let result = if l == 0 {
   99|     36|                Probability::zero() // Base case: empty subsequence
  100|       |            } else {
  101|       |                // Sum probabilities for this subsequence
  102|     60|                let prob_sum: Probability = (0..l)
  103|    114|                    .map(|k| self.keys[i + k].prob)
                                   ^60
  104|    114|                    .fold(Probability::zero(), |acc, p| acc + p);
                                   ^60  ^60
  105|       |
  106|       |                // Compute costs for each possible root in parallel
  107|     60|                let costs: Vec<Probability> = (0..l)
  108|    114|                    .map(|k| {
                                   ^60
  109|    114|                        let left_cost = self.obst_rec(i, k);
  110|    114|                        let right_cost = self.obst_rec(i + k + 1, l - k - 1);
  111|    114|                        left_cost + right_cost
  112|    114|                    })
  113|     60|                    .collect();
  114|       |
  115|       |                // Use parallel reduction to find minimum
  116|     60|                let min_cost = self.parallel_min_reduction(costs);
  117|       |
  118|     60|                prob_sum + min_cost
  119|       |            };
  120|       |
  121|       |            // Memoize result (thread-safe)
  122|     96|            {
  123|     96|                let mut memo_guard = self.memo.lock().unwrap();
  124|     96|                memo_guard.insert((i, l), result);
  125|     96|            }
  126|       |
  127|     96|            result
  128|    237|        }
  129|       |    }
  130|       |
  131|       |    impl<T: MtVal> OBSTMtPerTrait<T> for OBSTMtPerS<T> {
  132|      1|        fn new() -> Self {
  133|      1|            Self {
  134|      1|                keys: Arc::new(Vec::new()),
  135|      1|                memo: Arc::new(Mutex::new(HashMap::new())),
  136|      1|            }
  137|      1|        }
  138|       |
  139|     12|        fn from_keys_probs(keys: Vec<T>, probs: Vec<Probability>) -> Self {
  140|     12|            let key_probs: Vec<KeyProb<T>> = keys
  141|     12|                .into_iter()
  142|     12|                .zip(probs.into_iter())
  143|     34|                .map(|(key, prob)| KeyProb { key, prob })
                               ^12
  144|     12|                .collect();
  145|       |
  146|     12|            Self {
  147|     12|                keys: Arc::new(key_probs),
  148|     12|                memo: Arc::new(Mutex::new(HashMap::new())),
  149|     12|            }
  150|     12|        }
  151|       |
  152|      1|        fn from_key_probs(key_probs: Vec<KeyProb<T>>) -> Self {
  153|      1|            Self {
  154|      1|                keys: Arc::new(key_probs),
  155|      1|                memo: Arc::new(Mutex::new(HashMap::new())),
  156|      1|            }
  157|      1|        }
  158|       |
  159|     10|        fn optimal_cost(&self) -> Probability
  160|     10|        where
  161|     10|            T: Send + Sync + 'static,
  162|       |        {
  163|     10|            if self.keys.is_empty() {
  164|      1|                return Probability::zero();
  165|      9|            }
  166|       |
  167|       |            // Clear memo for fresh computation
  168|      9|            {
  169|      9|                let mut memo_guard = self.memo.lock().unwrap();
  170|      9|                memo_guard.clear();
  171|      9|            }
  172|       |
  173|      9|            let n = self.keys.len();
  174|      9|            self.obst_rec(0, n)
  175|     10|        }
  176|       |
  177|      0|        fn keys(&self) -> &Arc<Vec<KeyProb<T>>> { &self.keys }
  178|       |
  179|      9|        fn num_keys(&self) -> usize { self.keys.len() }
  180|       |
  181|      1|        fn memo_size(&self) -> usize {
  182|      1|            let memo_guard = self.memo.lock().unwrap();
  183|      1|            memo_guard.len()
  184|      1|        }
  185|       |    }
  186|       |
  187|       |    impl<T: MtVal> PartialEq for OBSTMtPerS<T> {
  188|      1|        fn eq(&self, other: &Self) -> bool { self.keys == other.keys }
  189|       |    }
  190|       |
  191|       |    impl<T: MtVal> Eq for OBSTMtPerS<T> {}
  192|       |
  193|       |    impl<T: MtVal> Display for OBSTMtPerS<T> {
  194|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  195|      1|            let memo_size = {
  196|      1|                let memo_guard = self.memo.lock().unwrap();
  197|      1|                memo_guard.len()
  198|       |            };
  199|      1|            write!(f, "OBSTMtPer(keys: {}, memo_entries: {})", self.keys.len(), memo_size)
  200|      1|        }
  201|       |    }
  202|       |
  203|       |    impl<T: MtVal> IntoIterator for OBSTMtPerS<T> {
  204|       |        type Item = KeyProb<T>;
  205|       |        type IntoIter = std::vec::IntoIter<KeyProb<T>>;
  206|       |
  207|      0|        fn into_iter(self) -> Self::IntoIter {
  208|       |            // Extract Vec from Arc - this consumes the Arc
  209|      0|            match Arc::try_unwrap(self.keys) {
  210|      0|                | Ok(vec) => vec.into_iter(),
  211|      0|                | Err(arc) => (*arc).clone().into_iter(),
  212|       |            }
  213|      0|        }
  214|       |    }
  215|       |
  216|       |    impl<'a, T: MtVal> IntoIterator for &'a OBSTMtPerS<T> {
  217|       |        type Item = KeyProb<T>;
  218|       |        type IntoIter = std::iter::Cloned<std::slice::Iter<'a, KeyProb<T>>>;
  219|       |
  220|      1|        fn into_iter(self) -> Self::IntoIter { self.keys.iter().cloned() }
  221|       |    }
  222|       |
  223|       |    impl<T: MtVal + PartialEq> PartialEq for KeyProb<T> {
  224|      2|        fn eq(&self, other: &Self) -> bool {
  225|      2|            self.key == other.key && (self.prob.value() - other.prob.value()).abs() < f64::EPSILON
  226|      2|        }
  227|       |    }
  228|       |
  229|       |    impl<T: MtVal> Eq for KeyProb<T> {}
  230|       |
  231|       |    impl<T: MtVal + Display> Display for KeyProb<T> {
  232|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { write!(f, "({}: {:.3})", self.key, self.prob) }
  233|       |    }
  234|       |
  235|       |}
  236|       |
  237|       |#[macro_export]
  238|       |macro_rules! OBSTMtPerLit {
  239|       |    (keys: [$($k:expr),* $(,)?], probs: [$($p:expr),* $(,)?]) => {
  240|       |        $crate::Chap50::OptBinSearchTreeMtPer::OptBinSearchTreeMtPer::OBSTMtPerS::from_keys_probs(
  241|       |            vec![$($k),*],
  242|       |            vec![$($crate::Chap50::Probability::Probability::Probability::new($p)),*]
  243|       |        )
  244|       |    };
  245|       |    () => {
  246|       |        $crate::Chap50::OptBinSearchTreeMtPer::OptBinSearchTreeMtPer::OBSTMtPerS::new()
  247|       |    };
  248|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap50/OptBinSearchTreeStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 50: Optimal Binary Search Tree - ephemeral, single-threaded.
    3|       |
    4|       |pub mod OptBinSearchTreeStEph {
    5|       |
    6|       |    use std::collections::HashMap;
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    8|       |
    9|       |    use crate::Chap50::Probability::Probability::Probability;
   10|       |    use crate::Types::Types::*;
   11|       |    use crate::prob;
   12|       |
   13|       |    #[derive(Clone, Debug, PartialEq)]
   14|       |    pub struct KeyProb<T: StT> {
   15|       |        pub key: T,
   16|       |        pub prob: Probability,
   17|       |    }
   18|       |
   19|       |    /// Ephemeral single-threaded optimal binary search tree solver using dynamic programming
   20|       |    #[derive(Clone, Debug, PartialEq)]
   21|       |    pub struct OBSTStEphS<T: StT> {
   22|       |        keys: Vec<KeyProb<T>>,
   23|       |        memo: HashMap<(usize, usize), Probability>,
   24|       |    }
   25|       |
   26|       |    /// Trait for optimal BST operations
   27|       |    pub trait OBSTStEphTrait<T: StT> {
   28|       |        /// Create new optimal BST solver
   29|       |        fn new() -> Self;
   30|       |
   31|       |        /// Create from keys and probabilities
   32|       |        fn from_keys_probs(keys: Vec<T>, probs: Vec<Probability>) -> Self;
   33|       |
   34|       |        /// Create from key-probability pairs
   35|       |        fn from_key_probs(key_probs: Vec<KeyProb<T>>) -> Self;
   36|       |
   37|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   38|       |        /// Compute optimal BST cost where n=number of keys
   39|       |        fn optimal_cost(&mut self) -> Probability;
   40|       |
   41|       |        /// Get the keys with probabilities
   42|       |        fn keys(&self) -> &Vec<KeyProb<T>>;
   43|       |
   44|       |        /// Get mutable keys (ephemeral allows mutation)
   45|       |        fn keys_mut(&mut self) -> &mut Vec<KeyProb<T>>;
   46|       |
   47|       |        /// Set key-probability pair at index
   48|       |        fn set_key_prob(&mut self, index: usize, key_prob: KeyProb<T>);
   49|       |
   50|       |        /// Update probability for key at index
   51|       |        fn update_prob(&mut self, index: usize, prob: Probability);
   52|       |
   53|       |        /// Get number of keys
   54|       |        fn num_keys(&self) -> usize;
   55|       |
   56|       |        /// Clear memoization table
   57|       |        fn clear_memo(&mut self);
   58|       |
   59|       |        /// Get memoization table size
   60|       |        fn memo_size(&self) -> usize;
   61|       |    }
   62|       |
   63|       |    impl<T: StT> OBSTStEphS<T> {
   64|       |        /// Internal recursive optimal BST with memoization
   65|       |        /// Claude Work: O(n) - O(n) subproblems, each O(n) work
   66|       |        /// Claude Span: O(n) - maximum recursion depth O(n), each level O(n) work
   67|    783|        fn obst_rec(&mut self, i: usize, l: usize) -> Probability {
   68|       |            // Check memo first
   69|    783|            if let Some(&result) = self.memo.get(&(i, l)) {
                                       ^551
   70|    551|                return result;
   71|    232|            }
   72|       |
   73|    232|            let result = if l == 0 {
   74|     81|                Probability::zero() // Base case: empty subsequence
   75|       |            } else {
   76|       |                // Sum probabilities for this subsequence
   77|    151|                let prob_sum: Probability = (0..l)
   78|    381|                    .map(|k| self.keys[i + k].prob)
                                   ^151
   79|    381|                    .fold(Probability::zero(), |acc, p| acc + p);
                                   ^151 ^151
   80|       |
   81|       |                // Try each key as root and find minimum cost
   82|    151|                let min_cost = (0..l)
   83|    381|                    .map(|k| {
                                   ^151
   84|    381|                        let left_cost = self.obst_rec(i, k);
   85|    381|                        let right_cost = self.obst_rec(i + k + 1, l - k - 1);
   86|    381|                        left_cost + right_cost
   87|    381|                    })
   88|    151|                    .fold(Probability::infinity(), std::cmp::min);
   89|       |
   90|    151|                prob_sum + min_cost
   91|       |            };
   92|       |
   93|       |            // Memoize result
   94|    232|            self.memo.insert((i, l), result);
   95|    232|            result
   96|    783|        }
   97|       |    }
   98|       |
   99|       |    impl<T: StT> OBSTStEphTrait<T> for OBSTStEphS<T> {
  100|      4|        fn new() -> Self {
  101|      4|            Self {
  102|      4|                keys: Vec::new(),
  103|      4|                memo: HashMap::new(),
  104|      4|            }
  105|      4|        }
  106|       |
  107|     27|        fn from_keys_probs(keys: Vec<T>, probs: Vec<Probability>) -> Self {
  108|     27|            let key_probs = keys
  109|     27|                .into_iter()
  110|     27|                .zip(probs.into_iter())
  111|     73|                .map(|(key, prob)| KeyProb { key, prob })
                               ^27
  112|     27|                .collect();
  113|       |
  114|     27|            Self {
  115|     27|                keys: key_probs,
  116|     27|                memo: HashMap::new(),
  117|     27|            }
  118|     27|        }
  119|       |
  120|      2|        fn from_key_probs(key_probs: Vec<KeyProb<T>>) -> Self {
  121|      2|            Self {
  122|      2|                keys: key_probs,
  123|      2|                memo: HashMap::new(),
  124|      2|            }
  125|      2|        }
  126|       |
  127|     23|        fn optimal_cost(&mut self) -> Probability {
  128|     23|            if self.keys.is_empty() {
  129|      2|                return Probability::zero();
  130|     21|            }
  131|       |
  132|       |            // Clear memo for fresh computation
  133|     21|            self.memo.clear();
  134|       |
  135|     21|            let n = self.keys.len();
  136|     21|            self.obst_rec(0, n)
  137|     23|        }
  138|       |
  139|     13|        fn keys(&self) -> &Vec<KeyProb<T>> { &self.keys }
  140|       |
  141|      1|        fn keys_mut(&mut self) -> &mut Vec<KeyProb<T>> { &mut self.keys }
  142|       |
  143|      1|        fn set_key_prob(&mut self, index: usize, key_prob: KeyProb<T>) {
  144|      1|            if index < self.keys.len() {
  145|      1|                self.keys[index] = key_prob;
  146|      1|            }
                          ^0
  147|       |            // Clear memo since keys changed
  148|      1|            self.memo.clear();
  149|      1|        }
  150|       |
  151|      3|        fn update_prob(&mut self, index: usize, prob: Probability) {
  152|      3|            if index < self.keys.len() {
  153|      3|                self.keys[index].prob = prob;
  154|      3|            }
                          ^0
  155|       |            // Clear memo since probabilities changed
  156|      3|            self.memo.clear();
  157|      3|        }
  158|       |
  159|     14|        fn num_keys(&self) -> usize { self.keys.len() }
  160|       |
  161|      2|        fn clear_memo(&mut self) { self.memo.clear(); }
  162|       |
  163|      8|        fn memo_size(&self) -> usize { self.memo.len() }
  164|       |    }
  165|       |
  166|       |    impl<T: StT> Display for OBSTStEphS<T> {
  167|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  168|      0|            write!(
  169|      0|                f,
  170|      0|                "OBSTStEph(keys: {}, memo_entries: {})",
  171|      0|                self.keys.len(),
  172|      0|                self.memo.len()
  173|       |            )
  174|      0|        }
  175|       |    }
  176|       |
  177|       |    impl<T: StT> IntoIterator for OBSTStEphS<T> {
  178|       |        type Item = KeyProb<T>;
  179|       |        type IntoIter = std::vec::IntoIter<KeyProb<T>>;
  180|       |
  181|      0|        fn into_iter(self) -> Self::IntoIter { self.keys.into_iter() }
  182|       |    }
  183|       |
  184|       |    impl<'a, T: StT> IntoIterator for &'a OBSTStEphS<T> {
  185|       |        type Item = KeyProb<T>;
  186|       |        type IntoIter = std::iter::Cloned<std::slice::Iter<'a, KeyProb<T>>>;
  187|       |
  188|      0|        fn into_iter(self) -> Self::IntoIter { self.keys.iter().cloned() }
  189|       |    }
  190|       |
  191|       |    impl<'a, T: StT> IntoIterator for &'a mut OBSTStEphS<T> {
  192|       |        type Item = KeyProb<T>;
  193|       |        type IntoIter = std::iter::Cloned<std::slice::Iter<'a, KeyProb<T>>>;
  194|       |
  195|      0|        fn into_iter(self) -> Self::IntoIter { self.keys.iter().cloned() }
  196|       |    }
  197|       |
  198|       |    impl<T: StT> Display for KeyProb<T> {
  199|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { write!(f, "({}: {:.3})", self.key, self.prob) }
  200|       |    }
  201|       |
  202|       |    impl<T: StT> Eq for KeyProb<T> {}
  203|       |
  204|       |}
  205|       |
  206|       |#[macro_export]
  207|       |macro_rules! OBSTStEphLit {
  208|       |    (keys: [$($k:expr),* $(,)?], probs: [$($p:expr),* $(,)?]) => {
  209|       |        $crate::Chap50::OptBinSearchTreeStEph::OptBinSearchTreeStEph::OBSTStEphS::from_keys_probs(
  210|       |            vec![$($k),*],
  211|       |            vec![$(prob!($p)),*]
  212|       |        )
  213|       |    };
  214|       |    () => {
  215|       |        $crate::Chap50::OptBinSearchTreeStEph::OptBinSearchTreeStEph::OBSTStEphS::new()
  216|       |    };
  217|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap50/OptBinSearchTreeStPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 50: Optimal Binary Search Tree - persistent, single-threaded.
    3|       |
    4|       |pub mod OptBinSearchTreeStPer {
    5|       |
    6|       |    use std::collections::HashMap;
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    8|       |
    9|       |    use crate::Chap50::Probability::Probability::Probability;
   10|       |    use crate::Types::Types::*;
   11|       |    use crate::prob;
   12|       |
   13|       |    #[derive(Clone, Debug, PartialEq)]
   14|       |    pub struct KeyProb<T: StT> {
   15|       |        pub key: T,
   16|       |        pub prob: Probability,
   17|       |    }
   18|       |
   19|       |    /// Persistent single-threaded optimal binary search tree solver using dynamic programming
   20|       |    #[derive(Clone, Debug, PartialEq)]
   21|       |    pub struct OBSTStPerS<T: StT> {
   22|       |        keys: Vec<KeyProb<T>>,
   23|       |        memo: HashMap<(usize, usize), Probability>,
   24|       |    }
   25|       |
   26|       |    /// Trait for optimal BST operations
   27|       |    pub trait OBSTStPerTrait<T: StT> {
   28|       |        /// Create new optimal BST solver
   29|       |        fn new() -> Self;
   30|       |
   31|       |        /// Create from keys and probabilities
   32|       |        fn from_keys_probs(keys: Vec<T>, probs: Vec<Probability>) -> Self;
   33|       |
   34|       |        /// Create from key-probability pairs
   35|       |        fn from_key_probs(key_probs: Vec<KeyProb<T>>) -> Self;
   36|       |
   37|       |        /// Compute optimal BST cost using dynamic programming
   38|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   39|       |        fn optimal_cost(&self) -> Probability;
   40|       |
   41|       |        /// Get the keys with probabilities
   42|       |        fn keys(&self) -> &Vec<KeyProb<T>>;
   43|       |
   44|       |        /// Get number of keys
   45|       |        fn num_keys(&self) -> usize;
   46|       |
   47|       |        /// Get memoization table size
   48|       |        fn memo_size(&self) -> usize;
   49|       |    }
   50|       |
   51|       |    impl<T: StT> OBSTStPerS<T> {
   52|       |        /// Internal recursive optimal BST with memoization
   53|       |        /// Claude Work: O(n) - O(n) subproblems, each O(n) work
   54|       |        /// Claude Span: O(n) - maximum recursion depth O(n), each level O(n) work
   55|    185|        fn obst_rec(&mut self, i: usize, l: usize) -> Probability {
   56|       |            // Check memo first
   57|    185|            if let Some(&result) = self.memo.get(&(i, l)) {
                                       ^98
   58|     98|                return result;
   59|     87|            }
   60|       |
   61|     87|            let result = if l == 0 {
   62|     37|                Probability::zero() // Base case: empty subsequence
   63|       |            } else {
   64|       |                // Sum probabilities for this subsequence
   65|     50|                let prob_sum: Probability = (0..l)
   66|     87|                    .map(|k| self.keys[i + k].prob)
                                   ^50
   67|     87|                    .fold(Probability::zero(), |acc, p| acc + p);
                                   ^50  ^50
   68|       |
   69|       |                // Try each key as root and find minimum cost
   70|     50|                let min_cost = (0..l)
   71|     87|                    .map(|k| {
                                   ^50
   72|     87|                        let left_cost = self.obst_rec(i, k);
   73|     87|                        let right_cost = self.obst_rec(i + k + 1, l - k - 1);
   74|     87|                        left_cost + right_cost
   75|     87|                    })
   76|     50|                    .fold(Probability::infinity(), std::cmp::min);
   77|       |
   78|     50|                prob_sum + min_cost
   79|       |            };
   80|       |
   81|       |            // Memoize result
   82|     87|            self.memo.insert((i, l), result);
   83|     87|            result
   84|    185|        }
   85|       |    }
   86|       |
   87|       |    impl<T: StT> OBSTStPerTrait<T> for OBSTStPerS<T> {
   88|      3|        fn new() -> Self {
   89|      3|            Self {
   90|      3|                keys: Vec::new(),
   91|      3|                memo: HashMap::new(),
   92|      3|            }
   93|      3|        }
   94|       |
   95|     18|        fn from_keys_probs(keys: Vec<T>, probs: Vec<Probability>) -> Self {
   96|     18|            let key_probs = keys
   97|     18|                .into_iter()
   98|     18|                .zip(probs.into_iter())
   99|     45|                .map(|(key, prob)| KeyProb { key, prob })
                               ^18
  100|     18|                .collect();
  101|       |
  102|     18|            Self {
  103|     18|                keys: key_probs,
  104|     18|                memo: HashMap::new(),
  105|     18|            }
  106|     18|        }
  107|       |
  108|      2|        fn from_key_probs(key_probs: Vec<KeyProb<T>>) -> Self {
  109|      2|            Self {
  110|      2|                keys: key_probs,
  111|      2|                memo: HashMap::new(),
  112|      2|            }
  113|      2|        }
  114|       |
  115|     13|        fn optimal_cost(&self) -> Probability {
  116|     13|            if self.keys.is_empty() {
  117|      2|                return Probability::zero();
  118|     11|            }
  119|       |
  120|       |            // Create mutable copy for memoization
  121|     11|            let mut solver = self.clone();
  122|     11|            solver.memo.clear(); // Fresh memo for each query
  123|       |
  124|     11|            let n = solver.keys.len();
  125|     11|            solver.obst_rec(0, n)
  126|     13|        }
  127|       |
  128|      5|        fn keys(&self) -> &Vec<KeyProb<T>> { &self.keys }
  129|       |
  130|     14|        fn num_keys(&self) -> usize { self.keys.len() }
  131|       |
  132|      1|        fn memo_size(&self) -> usize { self.memo.len() }
  133|       |    }
  134|       |
  135|       |    impl<T: StT> Display for OBSTStPerS<T> {
  136|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  137|      0|            write!(
  138|      0|                f,
  139|      0|                "OBSTStPer(keys: {}, memo_entries: {})",
  140|      0|                self.keys.len(),
  141|      0|                self.memo.len()
  142|       |            )
  143|      0|        }
  144|       |    }
  145|       |
  146|       |    impl<T: StT> IntoIterator for OBSTStPerS<T> {
  147|       |        type Item = KeyProb<T>;
  148|       |        type IntoIter = std::vec::IntoIter<KeyProb<T>>;
  149|       |
  150|      1|        fn into_iter(self) -> Self::IntoIter { self.keys.into_iter() }
  151|       |    }
  152|       |
  153|       |    impl<'a, T: StT> IntoIterator for &'a OBSTStPerS<T> {
  154|       |        type Item = KeyProb<T>;
  155|       |        type IntoIter = std::iter::Cloned<std::slice::Iter<'a, KeyProb<T>>>;
  156|       |
  157|      0|        fn into_iter(self) -> Self::IntoIter { self.keys.iter().cloned() }
  158|       |    }
  159|       |
  160|       |    impl<T: StT> Display for KeyProb<T> {
  161|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { write!(f, "({}: {:.3})", self.key, self.prob) }
  162|       |    }
  163|       |
  164|       |    impl<T: StT> Eq for KeyProb<T> {}
  165|       |
  166|       |}
  167|       |
  168|       |#[macro_export]
  169|       |macro_rules! OBSTStPerLit {
  170|       |    (keys: [$($k:expr),* $(,)?], probs: [$($p:expr),* $(,)?]) => {
  171|       |        $crate::Chap50::OptBinSearchTreeStPer::OptBinSearchTreeStPer::OBSTStPerS::from_keys_probs(
  172|       |            vec![$($k),*],
  173|       |            vec![$(prob!($p)),*]
  174|       |        )
  175|       |    };
  176|       |    () => {
  177|       |        $crate::Chap50::OptBinSearchTreeStPer::OptBinSearchTreeStPer::OBSTStPerS::new()
  178|       |    };
  179|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap50/Probability.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 50: Probability wrapper type for OBST algorithms.
    3|       |//!
    4|       |//! Note: Provides a probability wrapper that implements Eq/Ord for f64 values
    5|       |//! while maintaining compatibility with APAS MtVal trait requirements.
    6|       |
    7|       |pub mod Probability {
    8|       |
    9|       |    use std::cmp::Ordering;
   10|       |    use std::fmt::{Debug, Display, Formatter, Result as FmtResult};
   11|       |    use std::hash::{Hash, Hasher};
   12|       |
   13|       |    use crate::Types::Types::*;
   14|       |
   15|       |    /// Trait for probability operations
   16|       |    pub trait ProbabilityTrait {
   17|       |        /// Create new probability from f64
   18|       |        /// APAS: Work (1), Span (1)
   19|       |        fn new(value: f64) -> Self;
   20|       |
   21|       |        /// Get the underlying f64 value
   22|       |        /// APAS: Work (1), Span (1)
   23|       |        fn value(&self) -> f64;
   24|       |    }
   25|       |
   26|       |    #[derive(Clone, Copy)]
   27|       |    pub struct Probability(pub f64);
   28|       |
   29|       |    impl Probability {
   30|       |        /// Create a new probability value
   31|       |        /// Claude Work: O(1) - constant time construction
   32|       |        /// Claude Span: O(1) - constant time construction
   33|    285|        pub fn new(value: f64) -> Self {
   34|    285|            debug_assert!(value >= 0.0, "Probability must be non-negative");
                                                      ^0
   35|       |            // Allow values > 1.0 for costs in dynamic programming
   36|    285|            Probability(value)
   37|    285|        }
   38|       |
   39|       |        /// Get the inner f64 value
   40|       |        /// Claude Work: O(1) - constant time access
   41|       |        /// Claude Span: O(1) - constant time access
   42|     54|        pub fn value(&self) -> f64 { self.0 }
   43|       |
   44|       |        /// Create infinity value for fold operations
   45|       |        /// Claude Work: O(1) - constant time construction
   46|       |        /// Claude Span: O(1) - constant time construction
   47|    203|        pub fn infinity() -> Self { Probability(f64::INFINITY) }
   48|       |
   49|       |        /// Create zero probability
   50|       |        /// Claude Work: O(1) - constant time construction
   51|       |        /// Claude Span: O(1) - constant time construction
   52|    531|        pub fn zero() -> Self { Probability(0.0) }
   53|       |    }
   54|       |
   55|       |    impl Default for Probability {
   56|      0|        fn default() -> Self { Probability::zero() }
   57|       |    }
   58|       |
   59|       |    impl PartialEq for Probability {
   60|     36|        fn eq(&self, other: &Self) -> bool {
   61|       |            // Use bit-level comparison for exact equality
   62|     36|            self.0.to_bits() == other.0.to_bits()
   63|     36|        }
   64|       |    }
   65|       |
   66|       |    impl Eq for Probability {}
   67|       |
   68|       |    impl PartialOrd for Probability {
   69|    632|        fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(self.cmp(other)) }
   70|       |    }
   71|       |
   72|       |    impl Ord for Probability {
   73|    632|        fn cmp(&self, other: &Self) -> Ordering {
   74|       |            // Handle NaN and infinity cases properly
   75|    632|            match (self.0.is_nan(), other.0.is_nan()) {
   76|      0|                | (true, true) => Ordering::Equal,
   77|      0|                | (true, false) => Ordering::Greater, // NaN > everything
   78|      0|                | (false, true) => Ordering::Less,    // everything < NaN
   79|       |                | (false, false) => {
   80|    632|                    if self.0 < other.0 {
   81|    379|                        Ordering::Less
   82|    253|                    } else if self.0 > other.0 {
   83|    167|                        Ordering::Greater
   84|       |                    } else {
   85|     86|                        Ordering::Equal
   86|       |                    }
   87|       |                }
   88|       |            }
   89|    632|        }
   90|       |    }
   91|       |
   92|       |    impl Hash for Probability {
   93|      0|        fn hash<H: Hasher>(&self, state: &mut H) { self.0.to_bits().hash(state); }
   94|       |    }
   95|       |
   96|       |    impl Debug for Probability {
   97|      2|        fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult { write!(f, "Probability({})", self.0) }
   98|       |    }
   99|       |
  100|       |    impl Display for Probability {
  101|      4|        fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult { write!(f, "{}", self.0) }
  102|       |    }
  103|       |
  104|       |    impl From<f64> for Probability {
  105|      0|        fn from(value: f64) -> Self { Probability(value) }
  106|       |    }
  107|       |
  108|       |    impl From<Probability> for f64 {
  109|      0|        fn from(prob: Probability) -> Self { prob.0 }
  110|       |    }
  111|       |
  112|       |    // Arithmetic operations
  113|       |    impl std::ops::Add for Probability {
  114|       |        type Output = Self;
  115|       |
  116|  1.85k|        fn add(self, other: Self) -> Self { Probability(self.0 + other.0) }
  117|       |    }
  118|       |
  119|       |    impl std::ops::Sub for Probability {
  120|       |        type Output = Self;
  121|       |
  122|      2|        fn sub(self, other: Self) -> Self { Probability(self.0 - other.0) }
  123|       |    }
  124|       |
  125|       |    impl std::ops::Mul for Probability {
  126|       |        type Output = Self;
  127|       |
  128|      1|        fn mul(self, other: Self) -> Self { Probability(self.0 * other.0) }
  129|       |    }
  130|       |
  131|       |    impl std::ops::Div for Probability {
  132|       |        type Output = Self;
  133|       |
  134|      1|        fn div(self, other: Self) -> Self { Probability(self.0 / other.0) }
  135|       |    }
  136|       |
  137|       |    // APAS trait implementations are automatic due to blanket impl in Types.rs
  138|       |    // Probability implements Eq + Clone + Display + Debug + Sized, so it gets StT automatically
  139|       |    // Probability implements StT + Send + Sync, so it gets StTInMtT automatically
  140|       |    // Probability implements StTInMtT + 'static, so it gets MtVal automatically
  141|       |
  142|       |    // Convenience macro for creating probability literals
  143|       |    #[macro_export]
  144|       |    macro_rules! prob {
  145|       |        ($value:expr) => {
  146|       |            $crate::Chap50::Probability::Probability::Probability::new($value)
  147|       |        };
  148|       |    }
  149|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap51/BottomUpDPMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Bottom-Up Dynamic Programming - Ephemeral Multi-Threaded Implementation
    3|       |//!
    4|       |//! This module implements the bottom-up approach to dynamic programming using
    5|       |//! parallel diagonal pebbling with in-place mutations for multi-threaded computation.
    6|       |
    7|       |pub mod BottomUpDPMtEph {
    8|       |
    9|       |    use std::cmp::{max, min};
   10|       |    use std::fmt::{Debug, Display};
   11|       |    use std::sync::{Arc, Mutex};
   12|       |    use std::thread;
   13|       |
   14|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
   15|       |    use crate::Types::Types::*;
   16|       |
   17|       |    /// Trait for bottom-up dynamic programming operations
   18|       |    pub trait BottomUpDPMtEphTrait<T: MtVal> {
   19|       |        /// Create new bottom-up DP solver
   20|       |        /// APAS: Work (1), Span (1)
   21|       |        fn new() -> Self;
   22|       |
   23|       |        /// Solve DP problem
   24|       |        /// APAS: Work O(n), Span O(n)
   25|       |        fn solve(&self, input: &[T]) -> T;
   26|       |    }
   27|       |
   28|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   29|       |    pub struct BottomUpDPMtEphS {
   30|       |        /// Input sequence S
   31|       |        seq_s: ArraySeqMtEphS<char>,
   32|       |        /// Input sequence T  
   33|       |        seq_t: ArraySeqMtEphS<char>,
   34|       |    }
   35|       |
   36|       |    impl BottomUpDPMtEphS {
   37|       |        /// claude-4-sonet: Work (1), Span (1)
   38|     12|        pub fn new(s: ArraySeqMtEphS<char>, t: ArraySeqMtEphS<char>) -> Self { BottomUpDPMtEphS { seq_s: s, seq_t: t } }
   39|       |
   40|       |        /// Compute minimum edit distance using parallel bottom-up diagonal pebbling
   41|       |        /// claude-4-sonet: Work (|S||T|), Span (|S|+|T|), Parallelism (min(|S|,|T|))
   42|      3|        pub fn med_bottom_up_parallel(&mut self) -> usize {
   43|      3|            let s_len = self.seq_s.length();
   44|      3|            let t_len = self.seq_t.length();
   45|       |
   46|       |            // Create shared mutable DP table for parallel computation
   47|      3|            let table = Arc::new(Mutex::new(self.initialize_base_cases()));
   48|       |
   49|       |            // Process diagonals with parallel computation within each diagonal
   50|     13|            for k in 1..=(s_len + t_len) {
                                       ^3
   51|     13|                self.compute_diagonal_parallel(Arc::clone(&table), k);
   52|     13|            }
   53|       |
   54|       |            // Extract result from bottom-right corner
   55|      3|            let final_table = table.lock().unwrap();
   56|      3|            final_table[s_len][t_len]
   57|      3|        }
   58|       |
   59|       |        /// Initialize base cases for DP table
   60|       |        /// claude-4-sonet: Work (|S|+|T|), Span (|S|+|T|)
   61|      3|        fn initialize_base_cases(&self) -> Vec<Vec<usize>> {
   62|      3|            let s_len = self.seq_s.length();
   63|      3|            let t_len = self.seq_t.length();
   64|       |
   65|       |            // Initialize with zeros - using Vec for 2D table as Mt sequences lack nested mutation
   66|      3|            let mut table = vec![vec![0usize; t_len + 1]; s_len + 1];
   67|       |
   68|       |            // Set base cases: empty string transformations
   69|     10|            for i in 0..=s_len {
                                       ^3
   70|     10|                table[i][0] = i;
   71|     10|            }
   72|      9|            for j in 0..=t_len {
                                       ^3
   73|      9|                table[0][j] = j;
   74|      9|            }
   75|       |
   76|      3|            table
   77|      3|        }
   78|       |
   79|       |        /// Compute one diagonal of the DP table in parallel
   80|       |        /// claude-4-sonet: Work (min(|S|,|T|)), Span (1), Parallelism (min(|S|,|T|))
   81|     13|        fn compute_diagonal_parallel(&self, table: Arc<Mutex<Vec<Vec<usize>>>>, k: usize) {
   82|     13|            let s_len = self.seq_s.length();
   83|     13|            let t_len = self.seq_t.length();
   84|       |
   85|     13|            let start = max(1, k.saturating_sub(t_len));
   86|     13|            let end = min(k, s_len);
   87|       |
   88|       |            // Collect diagonal positions
   89|     13|            let positions: Vec<(usize, usize)> = (start..=end)
   90|     28|                .filter_map(|i| {
                               ^13
   91|     28|                    let j = k - i;
   92|     28|                    if j > 0 && j <= t_len { Some((i, j)) } else { None }
                                              ^21          ^21                   ^7
   93|     28|                })
   94|     13|                .collect();
   95|       |
   96|       |            // Process diagonal elements in parallel
   97|     13|            let handles: Vec<_> = positions
   98|     13|                .into_iter()
   99|     21|                .map(|(i, j)| {
                               ^13
  100|     21|                    let table_clone = Arc::clone(&table);
  101|     21|                    let seq_s_clone = self.seq_s.clone();
  102|     21|                    let seq_t_clone = self.seq_t.clone();
  103|       |
  104|     21|                    thread::spawn(move || {
  105|     21|                        let new_value = Self::compute_cell_value_static(&seq_s_clone, &seq_t_clone, &table_clone, i, j);
  106|     21|                        (i, j, new_value)
  107|     21|                    })
  108|     21|                })
  109|     13|                .collect();
  110|       |
  111|       |            // Collect results from all threads FIRST (without holding lock)
  112|     13|            let results: Vec<(usize, usize, usize)> =
  113|     21|                handles.into_iter().map(|handle| handle.join().unwrap()).collect();
                              ^13     ^13         ^13                                  ^13
  114|       |
  115|       |            // Then acquire lock once and write all results in-place
  116|     13|            let mut table_guard = table.lock().unwrap();
  117|     34|            for (i, j, new_value) in results {
                               ^21^21^21
  118|     21|                table_guard[i][j] = new_value;
  119|     21|            }
  120|     13|        }
  121|       |
  122|       |        /// Static method to compute value for a single DP table cell
  123|       |        /// Claude Work: O(1) - constant time per cell
  124|       |        /// Claude Span: O(1) - constant time per cell
  125|     21|        fn compute_cell_value_static(
  126|     21|            seq_s: &ArraySeqMtEphS<char>,
  127|     21|            seq_t: &ArraySeqMtEphS<char>,
  128|     21|            table: &Arc<Mutex<Vec<Vec<usize>>>>,
  129|     21|            i: usize,
  130|     21|            j: usize,
  131|     21|        ) -> usize {
  132|       |            // Access sequences using nth_cloned as nth() not available for MtEph
  133|     21|            let s_char = seq_s.nth_cloned(i - 1);
  134|     21|            let t_char = seq_t.nth_cloned(j - 1);
  135|       |
  136|     21|            let table_guard = table.lock().unwrap();
  137|       |
  138|     21|            if s_char == t_char {
  139|       |                // Characters match: take diagonal value
  140|      7|                table_guard[i - 1][j - 1]
  141|       |            } else {
  142|       |                // Characters don't match: take minimum of insert/delete + 1
  143|     14|                let delete_cost = table_guard[i - 1][j];
  144|     14|                let insert_cost = table_guard[i][j - 1];
  145|     14|                1 + min(delete_cost, insert_cost)
  146|       |            }
  147|     21|        }
  148|       |
  149|       |        /// Get the length of sequence S
  150|       |        /// Claude Work: O(1) - constant time access
  151|       |        /// Claude Span: O(1) - constant time access
  152|      4|        pub fn s_length(&self) -> usize { self.seq_s.length() }
  153|       |
  154|       |        /// Get the length of sequence T
  155|       |        /// Claude Work: O(1) - constant time access
  156|       |        /// Claude Span: O(1) - constant time access
  157|      4|        pub fn t_length(&self) -> usize { self.seq_t.length() }
  158|       |
  159|       |        /// Check if sequences are empty
  160|       |        /// Claude Work: O(1) - constant time check
  161|       |        /// Claude Span: O(1) - constant time check
  162|      2|        pub fn is_empty(&self) -> bool { self.seq_s.length() == 0usize && self.seq_t.length() == 0usize }
                                                                                        ^1
  163|       |
  164|       |        /// Mutably update sequence S
  165|       |        /// Claude Work: O(1) - constant time update
  166|       |        /// Claude Span: O(1) - constant time update
  167|      0|        pub fn set_s(&mut self, s: ArraySeqMtEphS<char>) { self.seq_s = s; }
  168|       |
  169|       |        /// Mutably update sequence T
  170|       |        /// Claude Work: O(1) - constant time update
  171|       |        /// Claude Span: O(1) - constant time update
  172|      0|        pub fn set_t(&mut self, t: ArraySeqMtEphS<char>) { self.seq_t = t; }
  173|       |    }
  174|       |
  175|       |    impl Default for BottomUpDPMtEphS {
  176|      1|        fn default() -> Self {
  177|      1|            let empty_s = ArraySeqMtEphS::new(0, ' ');
  178|      1|            let empty_t = ArraySeqMtEphS::new(0, ' ');
  179|      1|            Self::new(empty_s, empty_t)
  180|      1|        }
  181|       |    }
  182|       |
  183|       |    impl Display for BottomUpDPMtEphS {
  184|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  185|      1|            write!(
  186|      1|                f,
  187|      1|                "BottomUpDPMtEph(s_len={}, t_len={})",
  188|      1|                self.s_length(),
  189|      1|                self.t_length()
  190|       |            )
  191|      1|        }
  192|       |    }
  193|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap51/BottomUpDPMtPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Bottom-Up Dynamic Programming - Persistent Multi-Threaded Implementation
    3|       |//!
    4|       |//! This module implements the bottom-up approach to dynamic programming using
    5|       |//! parallel diagonal pebbling for multi-threaded computation.
    6|       |
    7|       |pub mod BottomUpDPMtPer {
    8|       |
    9|       |    use std::cmp::{max, min};
   10|       |    use std::fmt::{Debug, Display};
   11|       |    use std::sync::{Arc, Mutex};
   12|       |    use std::thread;
   13|       |
   14|       |    use crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::*;
   15|       |    use crate::Types::Types::*;
   16|       |
   17|       |    /// Trait for bottom-up dynamic programming operations
   18|       |    pub trait BottomUpDPMtPerTrait<T: MtVal> {
   19|       |        /// Create new bottom-up DP solver
   20|       |        /// APAS: Work (1), Span (1)
   21|       |        fn new() -> Self;
   22|       |
   23|       |        /// Solve DP problem
   24|       |        /// APAS: Work O(n), Span O(lg n)
   25|       |        fn solve(&self, input: &[T]) -> T;
   26|       |    }
   27|       |
   28|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   29|       |    pub struct BottomUpDPMtPerS {
   30|       |        /// Input sequence S
   31|       |        seq_s: ArraySeqMtPerS<char>,
   32|       |        /// Input sequence T  
   33|       |        seq_t: ArraySeqMtPerS<char>,
   34|       |    }
   35|       |
   36|       |    impl BottomUpDPMtPerS {
   37|       |        /// claude-4-sonet: Work (1), Span (1)
   38|     13|        pub fn new(s: ArraySeqMtPerS<char>, t: ArraySeqMtPerS<char>) -> Self { BottomUpDPMtPerS { seq_s: s, seq_t: t } }
   39|       |
   40|       |        /// Compute minimum edit distance using parallel bottom-up diagonal pebbling
   41|       |        /// claude-4-sonet: Work (|S||T|), Span (|S|+|T|), Parallelism (min(|S|,|T|))
   42|      4|        pub fn med_bottom_up_parallel(&self) -> usize {
   43|      4|            let s_len = self.seq_s.length();
   44|      4|            let t_len = self.seq_t.length();
   45|       |
   46|       |            // Create shared DP table for parallel computation
   47|      4|            let table = Arc::new(Mutex::new(self.initialize_base_cases()));
   48|       |
   49|       |            // Process diagonals with parallel computation within each diagonal
   50|     16|            for k in 1..=(s_len + t_len) {
                                       ^4
   51|     16|                self.compute_diagonal_parallel(Arc::clone(&table), k);
   52|     16|            }
   53|       |
   54|       |            // Extract result from bottom-right corner
   55|      4|            let final_table = table.lock().unwrap();
   56|      4|            final_table[s_len][t_len]
   57|      4|        }
   58|       |
   59|       |        /// Initialize base cases for DP table
   60|       |        /// claude-4-sonet: Work (|S|+|T|), Span (|S|+|T|)
   61|      4|        fn initialize_base_cases(&self) -> Vec<Vec<usize>> {
   62|      4|            let s_len = self.seq_s.length();
   63|      4|            let t_len = self.seq_t.length();
   64|       |
   65|       |            // Initialize with zeros - using Vec for 2D table as Mt sequences lack method-call API
   66|      4|            let mut table = vec![vec![0usize; t_len + 1]; s_len + 1];
   67|       |
   68|       |            // Set base cases: empty string transformations
   69|     14|            for i in 0..=s_len {
                                       ^4
   70|     14|                table[i][0] = i;
   71|     14|            }
   72|     10|            for j in 0..=t_len {
                                       ^4
   73|     10|                table[0][j] = j;
   74|     10|            }
   75|       |
   76|      4|            table
   77|      4|        }
   78|       |
   79|       |        /// Compute one diagonal of the DP table in parallel
   80|       |        /// claude-4-sonet: Work (min(|S|,|T|)), Span (1), Parallelism (min(|S|,|T|))
   81|     16|        fn compute_diagonal_parallel(&self, table: Arc<Mutex<Vec<Vec<usize>>>>, k: usize) {
   82|     16|            let s_len = self.seq_s.length();
   83|     16|            let t_len = self.seq_t.length();
   84|       |
   85|     16|            let start = max(1, k.saturating_sub(t_len));
   86|     16|            let end = min(k, s_len);
   87|       |
   88|       |            // Collect diagonal positions
   89|     16|            let positions: Vec<(usize, usize)> = (start..=end)
   90|     31|                .filter_map(|i| {
                               ^16
   91|     31|                    let j = k - i;
   92|     31|                    if j > 0 && j <= t_len { Some((i, j)) } else { None }
                                              ^21          ^21                   ^10
   93|     31|                })
   94|     16|                .collect();
   95|       |
   96|       |            // Process diagonal elements in parallel
   97|     16|            let handles: Vec<_> = positions
   98|     16|                .into_iter()
   99|     21|                .map(|(i, j)| {
                               ^16
  100|     21|                    let table_clone = Arc::clone(&table);
  101|     21|                    let seq_s_clone = self.seq_s.clone();
  102|     21|                    let seq_t_clone = self.seq_t.clone();
  103|       |
  104|     21|                    thread::spawn(move || {
  105|     21|                        let new_value = Self::compute_cell_value_static(&seq_s_clone, &seq_t_clone, &table_clone, i, j);
  106|     21|                        (i, j, new_value)
  107|     21|                    })
  108|     21|                })
  109|     16|                .collect();
  110|       |
  111|       |            // Collect results from all threads FIRST (without holding lock)
  112|     16|            let results: Vec<(usize, usize, usize)> =
  113|     21|                handles.into_iter().map(|handle| handle.join().unwrap()).collect();
                              ^16     ^16         ^16                                  ^16
  114|       |
  115|       |            // Then acquire lock once and write all results
  116|     16|            let mut table_guard = table.lock().unwrap();
  117|     37|            for (i, j, new_value) in results {
                               ^21^21^21
  118|     21|                table_guard[i][j] = new_value;
  119|     21|            }
  120|     16|        }
  121|       |
  122|       |        /// Static method to compute value for a single DP table cell
  123|       |        /// Claude Work: O(1) - constant time per cell
  124|       |        /// Claude Span: O(1) - constant time per cell
  125|     21|        fn compute_cell_value_static(
  126|     21|            seq_s: &ArraySeqMtPerS<char>,
  127|     21|            seq_t: &ArraySeqMtPerS<char>,
  128|     21|            table: &Arc<Mutex<Vec<Vec<usize>>>>,
  129|     21|            i: usize,
  130|     21|            j: usize,
  131|     21|        ) -> usize {
  132|     21|            let s_char = *seq_s.nth(i - 1);
  133|     21|            let t_char = *seq_t.nth(j - 1);
  134|       |
  135|     21|            let table_guard = table.lock().unwrap();
  136|       |
  137|     21|            if s_char == t_char {
  138|       |                // Characters match: take diagonal value
  139|      7|                table_guard[i - 1][j - 1]
  140|       |            } else {
  141|       |                // Characters don't match: take minimum of insert/delete + 1
  142|     14|                let delete_cost = table_guard[i - 1][j];
  143|     14|                let insert_cost = table_guard[i][j - 1];
  144|     14|                1 + min(delete_cost, insert_cost)
  145|       |            }
  146|     21|        }
  147|       |
  148|       |        /// Get the length of sequence S
  149|       |        /// Claude Work: O(1) - constant time access
  150|       |        /// Claude Span: O(1) - constant time access
  151|      4|        pub fn s_length(&self) -> usize { self.seq_s.length() }
  152|       |
  153|       |        /// Get the length of sequence T
  154|       |        /// Claude Work: O(1) - constant time access
  155|       |        /// Claude Span: O(1) - constant time access
  156|      4|        pub fn t_length(&self) -> usize { self.seq_t.length() }
  157|       |
  158|       |        /// Check if sequences are empty
  159|       |        /// Claude Work: O(1) - constant time check
  160|       |        /// Claude Span: O(1) - constant time check
  161|      2|        pub fn is_empty(&self) -> bool { self.seq_s.length() == 0usize && self.seq_t.length() == 0usize }
                                                                                        ^1
  162|       |    }
  163|       |
  164|       |    impl Default for BottomUpDPMtPerS {
  165|      1|        fn default() -> Self {
  166|      1|            let empty_s = ArraySeqMtPerS::new(0, ' ');
  167|      1|            let empty_t = ArraySeqMtPerS::new(0, ' ');
  168|      1|            Self::new(empty_s, empty_t)
  169|      1|        }
  170|       |    }
  171|       |
  172|       |    impl Display for BottomUpDPMtPerS {
  173|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  174|      1|            write!(
  175|      1|                f,
  176|      1|                "BottomUpDPMtPer(s_len={}, t_len={})",
  177|      1|                self.s_length(),
  178|      1|                self.t_length()
  179|       |            )
  180|      1|        }
  181|       |    }
  182|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap51/BottomUpDPStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Bottom-Up Dynamic Programming - Ephemeral Single-Threaded Implementation
    3|       |//!
    4|       |//! This module implements the bottom-up approach to dynamic programming using
    5|       |//! diagonal pebbling strategy with in-place mutations for efficiency.
    6|       |
    7|       |pub mod BottomUpDPStEph {
    8|       |
    9|       |    use std::cmp::{max, min};
   10|       |    use std::fmt::{Debug, Display};
   11|       |
   12|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   13|       |    use crate::Types::Types::*;
   14|       |
   15|       |    /// Trait for bottom-up dynamic programming operations
   16|       |    pub trait BottomUpDPStEphTrait<T: StT> {
   17|       |        /// Create new bottom-up DP solver
   18|       |        /// APAS: Work (1), Span (1)
   19|       |        fn new() -> Self;
   20|       |
   21|       |        /// Solve DP problem
   22|       |        /// APAS: Work O(n), Span O(n)
   23|       |        fn solve(&self, input: &[T]) -> T;
   24|       |    }
   25|       |
   26|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   27|       |    pub struct BottomUpDPStEphS {
   28|       |        /// Input sequence S
   29|       |        seq_s: ArraySeqStEphS<char>,
   30|       |        /// Input sequence T  
   31|       |        seq_t: ArraySeqStEphS<char>,
   32|       |    }
   33|       |
   34|       |    impl BottomUpDPStEphS {
   35|       |        /// claude-4-sonet: Work (1), Span (1)
   36|     14|        pub fn new(s: ArraySeqStEphS<char>, t: ArraySeqStEphS<char>) -> Self { BottomUpDPStEphS { seq_s: s, seq_t: t } }
   37|       |
   38|       |        /// Compute minimum edit distance using bottom-up diagonal pebbling
   39|       |        /// claude-4-sonet: Work (|S||T|), Span (|S|+|T|), Parallelism (1)
   40|      3|        pub fn med_bottom_up(&mut self) -> usize {
   41|      3|            let s_len = self.seq_s.length();
   42|      3|            let t_len = self.seq_t.length();
   43|       |
   44|       |            // Create mutable DP table for computation
   45|      3|            let mut table = self.initialize_base_cases();
   46|       |
   47|       |            // Process diagonals from top-left to bottom-right
   48|     13|            for k in 1..=(s_len + t_len) {
                                       ^3
   49|     13|                self.compute_diagonal(&mut table, k);
   50|     13|            }
   51|       |
   52|       |            // Extract result from bottom-right corner
   53|      3|            table[s_len][t_len]
   54|      3|        }
   55|       |
   56|       |        /// Initialize base cases for DP table
   57|       |        /// claude-4-sonet: Work (|S|+|T|), Span (|S|+|T|)
   58|      3|        fn initialize_base_cases(&self) -> Vec<Vec<usize>> {
   59|      3|            let s_len = self.seq_s.length();
   60|      3|            let t_len = self.seq_t.length();
   61|       |
   62|       |            // Initialize with zeros - using Vec for 2D table as sequences lack nested mutation
   63|      3|            let mut table = vec![vec![0usize; t_len + 1]; s_len + 1];
   64|       |
   65|       |            // Set base cases: empty string transformations
   66|     10|            for i in 0..=s_len {
                                       ^3
   67|     10|                table[i][0] = i;
   68|     10|            }
   69|      9|            for j in 0..=t_len {
                                       ^3
   70|      9|                table[0][j] = j;
   71|      9|            }
   72|       |
   73|      3|            table
   74|      3|        }
   75|       |
   76|       |        /// Compute one diagonal of the DP table
   77|       |        /// Claude Work: O(min(|S|,|T|)) - diagonal length
   78|       |        /// Claude Span: O(min(|S|,|T|)) - sequential diagonal computation
   79|     13|        fn compute_diagonal(&self, table: &mut Vec<Vec<usize>>, k: usize) {
   80|     13|            let s_len = self.seq_s.length();
   81|     13|            let t_len = self.seq_t.length();
   82|       |
   83|     13|            let start = max(1, k.saturating_sub(t_len));
   84|     13|            let end = min(k, s_len);
   85|       |
   86|     28|            for i in start..=end {
                                   ^13     ^13
   87|     28|                let j = k - i;
   88|     28|                if j > 0 && j <= t_len {
                                          ^21
   89|     21|                    let new_value = self.compute_cell_value(table, i, j);
   90|     21|                    table[i][j] = new_value;
   91|     21|                }
                              ^7
   92|       |            }
   93|     13|        }
   94|       |
   95|       |        /// Compute value for a single DP table cell
   96|       |        /// Claude Work: O(1) - constant time per cell
   97|       |        /// Claude Span: O(1) - constant time per cell
   98|     21|        fn compute_cell_value(&self, table: &Vec<Vec<usize>>, i: usize, j: usize) -> usize {
   99|     21|            let s_char = *self.seq_s.nth(i - 1);
  100|     21|            let t_char = *self.seq_t.nth(j - 1);
  101|       |
  102|     21|            if s_char == t_char {
  103|       |                // Characters match: take diagonal value
  104|      7|                table[i - 1][j - 1]
  105|       |            } else {
  106|       |                // Characters don't match: take minimum of insert/delete + 1
  107|     14|                let delete_cost = table[i - 1][j];
  108|     14|                let insert_cost = table[i][j - 1];
  109|     14|                1 + min(delete_cost, insert_cost)
  110|       |            }
  111|     21|        }
  112|       |
  113|       |        /// Get the length of sequence S
  114|       |        /// Claude Work: O(1) - constant time access
  115|       |        /// Claude Span: O(1) - constant time access
  116|      5|        pub fn s_length(&self) -> usize { self.seq_s.length() }
  117|       |
  118|       |        /// Get the length of sequence T
  119|       |        /// Claude Work: O(1) - constant time access
  120|       |        /// Claude Span: O(1) - constant time access
  121|      5|        pub fn t_length(&self) -> usize { self.seq_t.length() }
  122|       |
  123|       |        /// Check if sequences are empty
  124|       |        /// Claude Work: O(1) - constant time check
  125|       |        /// Claude Span: O(1) - constant time check
  126|      2|        pub fn is_empty(&self) -> bool { self.seq_s.length() == 0usize && self.seq_t.length() == 0usize }
                                                                                        ^1
  127|       |
  128|       |        /// Mutably update sequence S
  129|       |        /// Claude Work: O(1) - constant time update
  130|       |        /// Claude Span: O(1) - constant time update
  131|      1|        pub fn set_s(&mut self, s: ArraySeqStEphS<char>) { self.seq_s = s; }
  132|       |
  133|       |        /// Mutably update sequence T
  134|       |        /// Claude Work: O(1) - constant time update
  135|       |        /// Claude Span: O(1) - constant time update
  136|      1|        pub fn set_t(&mut self, t: ArraySeqStEphS<char>) { self.seq_t = t; }
  137|       |    }
  138|       |
  139|       |    impl Default for BottomUpDPStEphS {
  140|      3|        fn default() -> Self {
  141|      3|            let empty_s = ArraySeqStEphS::new(0, ' ');
  142|      3|            let empty_t = ArraySeqStEphS::new(0, ' ');
  143|      3|            Self::new(empty_s, empty_t)
  144|      3|        }
  145|       |    }
  146|       |
  147|       |    impl Display for BottomUpDPStEphS {
  148|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  149|      1|            write!(
  150|      1|                f,
  151|      1|                "BottomUpDPStEph(s_len={}, t_len={})",
  152|      1|                self.s_length(),
  153|      1|                self.t_length()
  154|       |            )
  155|      1|        }
  156|       |    }
  157|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap51/BottomUpDPStPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Bottom-Up Dynamic Programming - Persistent Single-Threaded Implementation
    3|       |//!
    4|       |//! This module implements the bottom-up approach to dynamic programming using
    5|       |//! diagonal pebbling strategy for efficient computation of DP tables.
    6|       |
    7|       |pub mod BottomUpDPStPer {
    8|       |
    9|       |    use std::cmp::{max, min};
   10|       |    use std::fmt::{Debug, Display};
   11|       |
   12|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
   13|       |    use crate::Types::Types::*;
   14|       |
   15|       |    /// Trait for bottom-up dynamic programming operations
   16|       |    pub trait BottomUpDPStPerTrait<T: StT> {
   17|       |        /// Create new bottom-up DP solver
   18|       |        /// APAS: Work (1), Span (1)
   19|       |        fn new() -> Self;
   20|       |
   21|       |        /// Solve DP problem
   22|       |        /// APAS: Work O(n), Span O(n)
   23|       |        fn solve(&self, input: &[T]) -> T;
   24|       |    }
   25|       |
   26|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   27|       |    pub struct BottomUpDPStPerS {
   28|       |        /// Input sequence S
   29|       |        seq_s: ArraySeqStPerS<char>,
   30|       |        /// Input sequence T  
   31|       |        seq_t: ArraySeqStPerS<char>,
   32|       |    }
   33|       |
   34|       |    impl BottomUpDPStPerS {
   35|       |        /// claude-4-sonet: Work (1), Span (1)
   36|     17|        pub fn new(s: ArraySeqStPerS<char>, t: ArraySeqStPerS<char>) -> Self { BottomUpDPStPerS { seq_s: s, seq_t: t } }
   37|       |
   38|       |        /// Compute minimum edit distance using bottom-up diagonal pebbling
   39|       |        /// claude-4-sonet: Work (|S||T|), Span (|S|+|T|), Parallelism (1)
   40|      6|        pub fn med_bottom_up(&self) -> usize {
   41|      6|            let s_len = self.seq_s.length();
   42|      6|            let t_len = self.seq_t.length();
   43|       |
   44|       |            // Create mutable copy for computation
   45|      6|            let mut table = self.initialize_base_cases();
   46|       |
   47|       |            // Process diagonals from top-left to bottom-right
   48|     20|            for k in 1..=(s_len + t_len) {
                                       ^6
   49|     20|                table = self.compute_diagonal(table, k);
   50|     20|            }
   51|       |
   52|       |            // Extract result from bottom-right corner
   53|      6|            table[s_len][t_len]
   54|      6|        }
   55|       |
   56|       |        /// Initialize base cases for DP table
   57|       |        /// claude-4-sonet: Work (|S|+|T|), Span (|S|+|T|)
   58|      6|        fn initialize_base_cases(&self) -> Vec<Vec<usize>> {
   59|      6|            let s_len = self.seq_s.length();
   60|      6|            let t_len = self.seq_t.length();
   61|       |
   62|       |            // Initialize with zeros - using Vec for 2D table as sequences lack nested indexing
   63|      6|            let mut table = vec![vec![0usize; t_len + 1]; s_len + 1];
   64|       |
   65|       |            // Set base cases: empty string transformations
   66|     18|            for i in 0..=s_len {
                                       ^6
   67|     18|                table[i][0] = i;
   68|     18|            }
   69|     14|            for j in 0..=t_len {
                                       ^6
   70|     14|                table[0][j] = j;
   71|     14|            }
   72|       |
   73|      6|            table
   74|      6|        }
   75|       |
   76|       |        /// Compute one diagonal of the DP table
   77|       |        /// Claude Work: O(min(|S|,|T|)) - diagonal length
   78|       |        /// Claude Span: O(min(|S|,|T|)) - sequential diagonal computation
   79|     20|        fn compute_diagonal(&self, mut table: Vec<Vec<usize>>, k: usize) -> Vec<Vec<usize>> {
   80|     20|            let s_len = self.seq_s.length();
   81|     20|            let t_len = self.seq_t.length();
   82|       |
   83|     20|            let start = max(1, k.saturating_sub(t_len));
   84|     20|            let end = min(k, s_len);
   85|       |
   86|     35|            for i in start..=end {
                                   ^20     ^20
   87|     35|                let j = k - i;
   88|     35|                if j > 0 && j <= t_len {
                                          ^23
   89|     23|                    let new_value = self.compute_cell_value(&table, i, j);
   90|     23|                    table[i][j] = new_value;
   91|     23|                }
                              ^12
   92|       |            }
   93|       |
   94|     20|            table
   95|     20|        }
   96|       |
   97|       |        /// Compute value for a single DP table cell
   98|       |        /// Claude Work: O(1) - constant time per cell
   99|       |        /// Claude Span: O(1) - constant time per cell
  100|     23|        fn compute_cell_value(&self, table: &Vec<Vec<usize>>, i: usize, j: usize) -> usize {
  101|     23|            let s_char = *self.seq_s.nth(i - 1);
  102|     23|            let t_char = *self.seq_t.nth(j - 1);
  103|       |
  104|     23|            if s_char == t_char {
  105|       |                // Characters match: take diagonal value
  106|      8|                table[i - 1][j - 1]
  107|       |            } else {
  108|       |                // Characters don't match: take minimum of insert/delete + 1
  109|     15|                let delete_cost = table[i - 1][j];
  110|     15|                let insert_cost = table[i][j - 1];
  111|     15|                1 + min(delete_cost, insert_cost)
  112|       |            }
  113|     23|        }
  114|       |
  115|       |        /// Get the length of sequence S
  116|       |        /// Claude Work: O(1) - constant time access
  117|       |        /// Claude Span: O(1) - constant time access
  118|      4|        pub fn s_length(&self) -> usize { self.seq_s.length() }
  119|       |
  120|       |        /// Get the length of sequence T
  121|       |        /// Claude Work: O(1) - constant time access
  122|       |        /// Claude Span: O(1) - constant time access
  123|      4|        pub fn t_length(&self) -> usize { self.seq_t.length() }
  124|       |
  125|       |        /// Check if sequences are empty
  126|       |        /// Claude Work: O(1) - constant time check
  127|       |        /// Claude Span: O(1) - constant time check
  128|      2|        pub fn is_empty(&self) -> bool { self.seq_s.length() == 0usize && self.seq_t.length() == 0usize }
                                                                                        ^1
  129|       |    }
  130|       |
  131|       |    impl Default for BottomUpDPStPerS {
  132|      1|        fn default() -> Self {
  133|      1|            let empty_s = ArraySeqStPerS::new(0, ' ');
  134|      1|            let empty_t = ArraySeqStPerS::new(0, ' ');
  135|      1|            Self::new(empty_s, empty_t)
  136|      1|        }
  137|       |    }
  138|       |
  139|       |    impl Display for BottomUpDPStPerS {
  140|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  141|      1|            write!(
  142|      1|                f,
  143|      1|                "BottomUpDPStPer(s_len={}, t_len={})",
  144|      1|                self.s_length(),
  145|      1|                self.t_length()
  146|       |            )
  147|      1|        }
  148|       |    }
  149|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap51/TopDownDPMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Top-Down Dynamic Programming - Ephemeral Multi-Threaded Implementation
    3|       |//!
    4|       |//! This module implements the top-down (memoization) approach to dynamic programming
    5|       |//! using concurrent HashMap with in-place mutations for thread-safe subproblem caching.
    6|       |
    7|       |pub mod TopDownDPMtEph {
    8|       |
    9|       |    use std::collections::HashMap;
   10|       |    use std::fmt::{Debug, Display};
   11|       |    use std::sync::{Arc, Mutex};
   12|       |    use std::thread;
   13|       |
   14|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
   15|       |    use crate::Types::Types::*;
   16|       |
   17|       |    /// Trait for top-down dynamic programming operations
   18|       |    pub trait TopDownDPMtEphTrait<T: MtVal> {
   19|       |        /// Create new top-down DP solver
   20|       |        /// APAS: Work (1), Span (1)
   21|       |        fn new() -> Self;
   22|       |
   23|       |        /// Solve DP problem with memoization
   24|       |        /// APAS: Work O(n), Span O(n)
   25|       |        fn solve(&self, input: &[T]) -> T;
   26|       |    }
   27|       |
   28|       |    #[derive(Clone, Debug)]
   29|       |    pub struct TopDownDPMtEphS {
   30|       |        /// Input sequence S
   31|       |        seq_s: ArraySeqMtEphS<char>,
   32|       |        /// Input sequence T  
   33|       |        seq_t: ArraySeqMtEphS<char>,
   34|       |        /// Concurrent memoization table for subproblem results
   35|       |        memo_table: Arc<Mutex<HashMap<(usize, usize), usize>>>,
   36|       |    }
   37|       |
   38|       |    impl TopDownDPMtEphS {
   39|       |        /// claude-4-sonet: Work (1), Span (1)
   40|     16|        pub fn new(s: ArraySeqMtEphS<char>, t: ArraySeqMtEphS<char>) -> Self {
   41|     16|            TopDownDPMtEphS {
   42|     16|                seq_s: s,
   43|     16|                seq_t: t,
   44|     16|                memo_table: Arc::new(Mutex::new(HashMap::new())),
   45|     16|            }
   46|     16|        }
   47|       |
   48|       |        /// Compute minimum edit distance using concurrent top-down memoization
   49|       |        /// claude-4-sonet: Work (|S||T|), Span (|S|+|T|), Parallelism (min(|S|,|T|))
   50|      2|        pub fn med_memoized_concurrent(&mut self) -> usize {
   51|      2|            let s_len = self.seq_s.length();
   52|      2|            let t_len = self.seq_t.length();
   53|       |
   54|      2|            self.med_recursive_concurrent(s_len, t_len)
   55|      2|        }
   56|       |
   57|       |        /// Recursive helper with concurrent memoization
   58|       |        /// claude-4-sonet: Work (1) amortized per call, (|S||T|) total; Span (|S|+|T|)
   59|     24|        fn med_recursive_concurrent(&self, i: usize, j: usize) -> usize {
   60|       |            // Check memo table first
   61|       |            {
   62|     24|                let memo_guard = self.memo_table.lock().unwrap();
   63|     24|                if let Some(&cached_result) = memo_guard.get(&(i, j)) {
                                           ^9
   64|      9|                    return cached_result;
   65|     15|                }
   66|       |            }
   67|       |
   68|       |            // Base cases
   69|     15|            let result = match (i, j) {
   70|      3|                | (0, j) => j, // Insert all remaining characters from T
   71|      2|                | (i, 0) => i, // Delete all remaining characters from S
   72|     10|                | (i, j) => {
   73|     10|                    let s_char = self.seq_s.nth_cloned(i - 1);
   74|     10|                    let t_char = self.seq_t.nth_cloned(j - 1);
   75|       |
   76|     10|                    if s_char == t_char {
   77|       |                        // Characters match: no edit needed
   78|      4|                        self.med_recursive_concurrent(i - 1, j - 1)
   79|       |                    } else {
   80|       |                        // Characters don't match: try insert, delete, or substitute
   81|      6|                        let insert_cost = 1 + self.med_recursive_concurrent(i, j - 1);
   82|      6|                        let delete_cost = 1 + self.med_recursive_concurrent(i - 1, j);
   83|      6|                        let substitute_cost = 1 + self.med_recursive_concurrent(i - 1, j - 1);
   84|       |
   85|      6|                        insert_cost.min(delete_cost).min(substitute_cost)
   86|       |                    }
   87|       |                }
   88|       |            };
   89|       |
   90|       |            // Store result in memo table
   91|     15|            {
   92|     15|                let mut memo_guard = self.memo_table.lock().unwrap();
   93|     15|                memo_guard.insert((i, j), result);
   94|     15|            }
   95|       |
   96|     15|            result
   97|     24|        }
   98|       |
   99|       |        /// Compute minimum edit distance with parallel subproblem exploration
  100|       |        /// Claude Work: O(|S|*|T|) where |S|=source length, |T|=target length
  101|       |        /// Claude Span: O(log(|S|+|T|)) with aggressive parallelism
  102|      1|        pub fn med_memoized_parallel(&mut self) -> usize {
  103|      1|            let s_len = self.seq_s.length();
  104|      1|            let t_len = self.seq_t.length();
  105|       |
  106|      1|            self.med_recursive_parallel(s_len, t_len)
  107|      1|        }
  108|       |
  109|       |        /// Recursive helper with parallel branch exploration
  110|       |        /// Claude Work: O(1) per call with memoization, O(|S|*|T|) total
  111|       |        /// Claude Span: O(log(|S|+|T|)) - parallel recursive branches
  112|     73|        fn med_recursive_parallel(&self, i: usize, j: usize) -> usize {
  113|       |            // Check memo table first
  114|       |            {
  115|     73|                let memo_guard = self.memo_table.lock().unwrap();
  116|     73|                if let Some(&cached_result) = memo_guard.get(&(i, j)) {
                                           ^42
  117|     42|                    return cached_result;
  118|     31|                }
  119|       |            }
  120|       |
  121|       |            // Base cases
  122|     31|            let result = match (i, j) {
  123|      4|                | (0, j) => j, // Insert all remaining characters from T
  124|      3|                | (i, 0) => i, // Delete all remaining characters from S
  125|     24|                | (i, j) => {
  126|     24|                    let s_char = self.seq_s.nth_cloned(i - 1);
  127|     24|                    let t_char = self.seq_t.nth_cloned(j - 1);
  128|       |
  129|     24|                    if s_char == t_char {
  130|       |                        // Characters match: no edit needed
  131|      0|                        self.med_recursive_parallel(i - 1, j - 1)
  132|       |                    } else {
  133|       |                        // Characters don't match: explore branches in parallel
  134|     24|                        let self_clone1 = self.clone();
  135|     24|                        let self_clone2 = self.clone();
  136|     24|                        let self_clone3 = self.clone();
  137|       |
  138|     24|                        let handle1 = thread::spawn(move || 1 + self_clone1.med_recursive_parallel(i, j - 1));
  139|       |
  140|     24|                        let handle2 = thread::spawn(move || 1 + self_clone2.med_recursive_parallel(i - 1, j));
  141|       |
  142|     24|                        let handle3 = thread::spawn(move || 1 + self_clone3.med_recursive_parallel(i - 1, j - 1));
  143|       |
  144|     24|                        let insert_cost = handle1.join().unwrap();
  145|     24|                        let delete_cost = handle2.join().unwrap();
  146|     24|                        let substitute_cost = handle3.join().unwrap();
  147|       |
  148|     24|                        insert_cost.min(delete_cost).min(substitute_cost)
  149|       |                    }
  150|       |                }
  151|       |            };
  152|       |
  153|       |            // Store result in memo table
  154|     31|            {
  155|     31|                let mut memo_guard = self.memo_table.lock().unwrap();
  156|     31|                memo_guard.insert((i, j), result);
  157|     31|            }
  158|       |
  159|     31|            result
  160|     73|        }
  161|       |
  162|       |        /// Get current memoization table size
  163|       |        /// Claude Work: O(1) - constant time access
  164|       |        /// Claude Span: O(1) - constant time access
  165|      4|        pub fn memo_size(&self) -> usize {
  166|      4|            let memo_guard = self.memo_table.lock().unwrap();
  167|      4|            memo_guard.len()
  168|      4|        }
  169|       |
  170|       |        /// Check if subproblem is memoized
  171|       |        /// Claude Work: O(1) - constant time lookup
  172|       |        /// Claude Span: O(1) - constant time lookup
  173|      1|        pub fn is_memoized(&self, i: usize, j: usize) -> bool {
  174|      1|            let memo_guard = self.memo_table.lock().unwrap();
  175|      1|            memo_guard.contains_key(&(i, j))
  176|      1|        }
  177|       |
  178|       |        /// Get memoized result if available
  179|       |        /// Claude Work: O(1) - constant time lookup
  180|       |        /// Claude Span: O(1) - constant time lookup
  181|      1|        pub fn get_memoized(&self, i: usize, j: usize) -> Option<usize> {
  182|      1|            let memo_guard = self.memo_table.lock().unwrap();
  183|      1|            memo_guard.get(&(i, j)).copied()
  184|      1|        }
  185|       |
  186|       |        /// Insert memoized result
  187|       |        /// Claude Work: O(1) - constant time insertion
  188|       |        /// Claude Span: O(1) - constant time insertion
  189|      0|        pub fn insert_memo(&mut self, i: usize, j: usize, value: usize) {
  190|      0|            let mut memo_guard = self.memo_table.lock().unwrap();
  191|      0|            memo_guard.insert((i, j), value);
  192|      0|        }
  193|       |
  194|       |        /// Get the length of sequence S
  195|       |        /// Claude Work: O(1) - constant time access
  196|       |        /// Claude Span: O(1) - constant time access
  197|      4|        pub fn s_length(&self) -> usize { self.seq_s.length() }
  198|       |
  199|       |        /// Get the length of sequence T
  200|       |        /// Claude Work: O(1) - constant time access
  201|       |        /// Claude Span: O(1) - constant time access
  202|      4|        pub fn t_length(&self) -> usize { self.seq_t.length() }
  203|       |
  204|       |        /// Check if sequences are empty
  205|       |        /// Claude Work: O(1) - constant time check
  206|       |        /// Claude Span: O(1) - constant time check
  207|      2|        pub fn is_empty(&self) -> bool { self.seq_s.length() == 0usize && self.seq_t.length() == 0usize }
                                                                                        ^1
  208|       |
  209|       |        /// Clear memoization table
  210|       |        /// Claude Work: O(1) - constant time clear
  211|       |        /// Claude Span: O(1) - constant time clear
  212|      1|        pub fn clear_memo(&mut self) {
  213|      1|            let mut memo_guard = self.memo_table.lock().unwrap();
  214|      1|            memo_guard.clear();
  215|      1|        }
  216|       |
  217|       |        /// Mutably update sequence S
  218|       |        /// Claude Work: O(1) - constant time update
  219|       |        /// Claude Span: O(1) - constant time update
  220|      0|        pub fn set_s(&mut self, s: ArraySeqMtEphS<char>) {
  221|      0|            self.seq_s = s;
  222|      0|            self.clear_memo(); // Clear memo when sequences change
  223|      0|        }
  224|       |
  225|       |        /// Mutably update sequence T
  226|       |        /// Claude Work: O(1) - constant time update
  227|       |        /// Claude Span: O(1) - constant time update
  228|      0|        pub fn set_t(&mut self, t: ArraySeqMtEphS<char>) {
  229|      0|            self.seq_t = t;
  230|      0|            self.clear_memo(); // Clear memo when sequences change
  231|      0|        }
  232|       |    }
  233|       |
  234|       |    impl PartialEq for TopDownDPMtEphS {
  235|      1|        fn eq(&self, other: &Self) -> bool {
  236|      1|            let self_memo = self.memo_table.lock().unwrap();
  237|      1|            let other_memo = other.memo_table.lock().unwrap();
  238|      1|            self.seq_s == other.seq_s && self.seq_t == other.seq_t && *self_memo == *other_memo
  239|      1|        }
  240|       |    }
  241|       |
  242|       |    impl Default for TopDownDPMtEphS {
  243|      4|        fn default() -> Self {
  244|      4|            let empty_s = ArraySeqMtEphS::new(0, ' ');
  245|      4|            let empty_t = ArraySeqMtEphS::new(0, ' ');
  246|      4|            Self::new(empty_s, empty_t)
  247|      4|        }
  248|       |    }
  249|       |
  250|       |    impl Display for TopDownDPMtEphS {
  251|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  252|      1|            write!(
  253|      1|                f,
  254|      1|                "TopDownDPMtEph(s_len={}, t_len={}, memo_size={})",
  255|      1|                self.s_length(),
  256|      1|                self.t_length(),
  257|      1|                self.memo_size()
  258|       |            )
  259|      1|        }
  260|       |    }
  261|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap51/TopDownDPMtPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Top-Down Dynamic Programming - Persistent Multi-Threaded Implementation
    3|       |//!
    4|       |//! This module implements the top-down (memoization) approach to dynamic programming
    5|       |//! using concurrent HashMap for thread-safe subproblem caching.
    6|       |
    7|       |pub mod TopDownDPMtPer {
    8|       |
    9|       |    use std::collections::HashMap;
   10|       |    use std::fmt::{Debug, Display};
   11|       |    use std::sync::{Arc, Mutex};
   12|       |    use std::thread;
   13|       |
   14|       |    use crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::*;
   15|       |    use crate::Types::Types::*;
   16|       |
   17|       |    /// Trait for top-down dynamic programming operations
   18|       |    pub trait TopDownDPMtPerTrait<T: MtVal> {
   19|       |        /// Create new top-down DP solver
   20|       |        /// APAS: Work (1), Span (1)
   21|       |        fn new() -> Self;
   22|       |
   23|       |        /// Solve DP problem with memoization
   24|       |        /// APAS: Work O(n), Span O(lg n)
   25|       |        fn solve(&self, input: &[T]) -> T;
   26|       |    }
   27|       |
   28|       |    #[derive(Clone, Debug)]
   29|       |    pub struct TopDownDPMtPerS {
   30|       |        /// Input sequence S
   31|       |        seq_s: ArraySeqMtPerS<char>,
   32|       |        /// Input sequence T  
   33|       |        seq_t: ArraySeqMtPerS<char>,
   34|       |        /// Concurrent memoization table for subproblem results
   35|       |        memo_table: Arc<Mutex<HashMap<(usize, usize), usize>>>,
   36|       |    }
   37|       |
   38|       |    impl TopDownDPMtPerS {
   39|       |        /// claude-4-sonet: Work (1), Span (1)
   40|     16|        pub fn new(s: ArraySeqMtPerS<char>, t: ArraySeqMtPerS<char>) -> Self {
   41|     16|            TopDownDPMtPerS {
   42|     16|                seq_s: s,
   43|     16|                seq_t: t,
   44|     16|                memo_table: Arc::new(Mutex::new(HashMap::new())),
   45|     16|            }
   46|     16|        }
   47|       |
   48|       |        /// Compute minimum edit distance using concurrent top-down memoization
   49|       |        /// claude-4-sonet: Work (|S||T|), Span (|S|+|T|), Parallelism (min(|S|,|T|))
   50|      2|        pub fn med_memoized_concurrent(&self) -> usize {
   51|      2|            let s_len = self.seq_s.length();
   52|      2|            let t_len = self.seq_t.length();
   53|       |
   54|      2|            self.med_recursive_concurrent(s_len, t_len)
   55|      2|        }
   56|       |
   57|       |        /// Recursive helper with concurrent memoization
   58|       |        /// claude-4-sonet: Work (1) amortized per call, (|S||T|) total; Span (|S|+|T|)
   59|     24|        fn med_recursive_concurrent(&self, i: usize, j: usize) -> usize {
   60|       |            // Check memo table first
   61|       |            {
   62|     24|                let memo_guard = self.memo_table.lock().unwrap();
   63|     24|                if let Some(&cached_result) = memo_guard.get(&(i, j)) {
                                           ^9
   64|      9|                    return cached_result;
   65|     15|                }
   66|       |            }
   67|       |
   68|       |            // Base cases
   69|     15|            let result = match (i, j) {
   70|      3|                | (0, j) => j, // Insert all remaining characters from T
   71|      2|                | (i, 0) => i, // Delete all remaining characters from S
   72|     10|                | (i, j) => {
   73|     10|                    let s_char = *self.seq_s.nth(i - 1);
   74|     10|                    let t_char = *self.seq_t.nth(j - 1);
   75|       |
   76|     10|                    if s_char == t_char {
   77|       |                        // Characters match: no edit needed
   78|      4|                        self.med_recursive_concurrent(i - 1, j - 1)
   79|       |                    } else {
   80|       |                        // Characters don't match: try insert, delete, or substitute
   81|       |                        // For better parallelism, we could spawn threads for each branch
   82|       |                        // but dependencies limit effectiveness
   83|      6|                        let insert_cost = 1 + self.med_recursive_concurrent(i, j - 1);
   84|      6|                        let delete_cost = 1 + self.med_recursive_concurrent(i - 1, j);
   85|      6|                        let substitute_cost = 1 + self.med_recursive_concurrent(i - 1, j - 1);
   86|       |
   87|      6|                        insert_cost.min(delete_cost).min(substitute_cost)
   88|       |                    }
   89|       |                }
   90|       |            };
   91|       |
   92|       |            // Store result in memo table
   93|     15|            {
   94|     15|                let mut memo_guard = self.memo_table.lock().unwrap();
   95|     15|                memo_guard.insert((i, j), result);
   96|     15|            }
   97|       |
   98|     15|            result
   99|     24|        }
  100|       |
  101|       |        /// Compute minimum edit distance with parallel subproblem exploration
  102|       |        /// Claude Work: O(|S|*|T|) where |S|=source length, |T|=target length
  103|       |        /// Claude Span: O(log(|S|+|T|)) with aggressive parallelism
  104|      1|        pub fn med_memoized_parallel(&self) -> usize {
  105|      1|            let s_len = self.seq_s.length();
  106|      1|            let t_len = self.seq_t.length();
  107|       |
  108|      1|            self.med_recursive_parallel(s_len, t_len)
  109|      1|        }
  110|       |
  111|       |        /// Recursive helper with parallel branch exploration
  112|       |        /// Claude Work: O(1) per call with memoization, O(|S|*|T|) total
  113|       |        /// Claude Span: O(log(|S|+|T|)) - parallel recursive branches
  114|     91|        fn med_recursive_parallel(&self, i: usize, j: usize) -> usize {
  115|       |            // Check memo table first
  116|       |            {
  117|     91|                let memo_guard = self.memo_table.lock().unwrap();
  118|     91|                if let Some(&cached_result) = memo_guard.get(&(i, j)) {
                                           ^54
  119|     54|                    return cached_result;
  120|     37|                }
  121|       |            }
  122|       |
  123|       |            // Base cases
  124|     37|            let result = match (i, j) {
  125|      4|                | (0, j) => j, // Insert all remaining characters from T
  126|      3|                | (i, 0) => i, // Delete all remaining characters from S
  127|     30|                | (i, j) => {
  128|     30|                    let s_char = *self.seq_s.nth(i - 1);
  129|     30|                    let t_char = *self.seq_t.nth(j - 1);
  130|       |
  131|     30|                    if s_char == t_char {
  132|       |                        // Characters match: no edit needed
  133|      0|                        self.med_recursive_parallel(i - 1, j - 1)
  134|       |                    } else {
  135|       |                        // Characters don't match: explore branches in parallel
  136|     30|                        let self_clone1 = self.clone();
  137|     30|                        let self_clone2 = self.clone();
  138|     30|                        let self_clone3 = self.clone();
  139|       |
  140|     30|                        let handle1 = thread::spawn(move || 1 + self_clone1.med_recursive_parallel(i, j - 1));
  141|       |
  142|     30|                        let handle2 = thread::spawn(move || 1 + self_clone2.med_recursive_parallel(i - 1, j));
  143|       |
  144|     30|                        let handle3 = thread::spawn(move || 1 + self_clone3.med_recursive_parallel(i - 1, j - 1));
  145|       |
  146|     30|                        let insert_cost = handle1.join().unwrap();
  147|     30|                        let delete_cost = handle2.join().unwrap();
  148|     30|                        let substitute_cost = handle3.join().unwrap();
  149|       |
  150|     30|                        insert_cost.min(delete_cost).min(substitute_cost)
  151|       |                    }
  152|       |                }
  153|       |            };
  154|       |
  155|       |            // Store result in memo table
  156|     37|            {
  157|     37|                let mut memo_guard = self.memo_table.lock().unwrap();
  158|     37|                memo_guard.insert((i, j), result);
  159|     37|            }
  160|       |
  161|     37|            result
  162|     91|        }
  163|       |
  164|       |        /// Create new instance with updated memoization table
  165|       |        /// Claude Work: O(1) - constant time update
  166|       |        /// Claude Span: O(1) - constant time update
  167|      0|        pub fn with_memo_table(self, memo: HashMap<(usize, usize), usize>) -> Self {
  168|      0|            TopDownDPMtPerS {
  169|      0|                seq_s: self.seq_s,
  170|      0|                seq_t: self.seq_t,
  171|      0|                memo_table: Arc::new(Mutex::new(memo)),
  172|      0|            }
  173|      0|        }
  174|       |
  175|       |        /// Get current memoization table size
  176|       |        /// Claude Work: O(1) - constant time access
  177|       |        /// Claude Span: O(1) - constant time access
  178|      4|        pub fn memo_size(&self) -> usize {
  179|      4|            let memo_guard = self.memo_table.lock().unwrap();
  180|      4|            memo_guard.len()
  181|      4|        }
  182|       |
  183|       |        /// Check if subproblem is memoized
  184|       |        /// Claude Work: O(1) - constant time lookup
  185|       |        /// Claude Span: O(1) - constant time lookup
  186|      1|        pub fn is_memoized(&self, i: usize, j: usize) -> bool {
  187|      1|            let memo_guard = self.memo_table.lock().unwrap();
  188|      1|            memo_guard.contains_key(&(i, j))
  189|      1|        }
  190|       |
  191|       |        /// Get memoized result if available
  192|       |        /// Claude Work: O(1) - constant time lookup
  193|       |        /// Claude Span: O(1) - constant time lookup
  194|      1|        pub fn get_memoized(&self, i: usize, j: usize) -> Option<usize> {
  195|      1|            let memo_guard = self.memo_table.lock().unwrap();
  196|      1|            memo_guard.get(&(i, j)).copied()
  197|      1|        }
  198|       |
  199|       |        /// Get the length of sequence S
  200|       |        /// Claude Work: O(1) - constant time access
  201|       |        /// Claude Span: O(1) - constant time access
  202|      4|        pub fn s_length(&self) -> usize { self.seq_s.length() }
  203|       |
  204|       |        /// Get the length of sequence T
  205|       |        /// Claude Work: O(1) - constant time access
  206|       |        /// Claude Span: O(1) - constant time access
  207|      4|        pub fn t_length(&self) -> usize { self.seq_t.length() }
  208|       |
  209|       |        /// Check if sequences are empty
  210|       |        /// Claude Work: O(1) - constant time check
  211|       |        /// Claude Span: O(1) - constant time check
  212|      2|        pub fn is_empty(&self) -> bool { self.seq_s.length() == 0usize && self.seq_t.length() == 0usize }
                                                                                        ^1
  213|       |
  214|       |        /// Clear memoization table
  215|       |        /// Claude Work: O(1) - constant time clear
  216|       |        /// Claude Span: O(1) - constant time clear
  217|      1|        pub fn clear_memo(self) -> Self {
  218|      1|            TopDownDPMtPerS {
  219|      1|                seq_s: self.seq_s,
  220|      1|                seq_t: self.seq_t,
  221|      1|                memo_table: Arc::new(Mutex::new(HashMap::new())),
  222|      1|            }
  223|      1|        }
  224|       |    }
  225|       |
  226|       |    impl PartialEq for TopDownDPMtPerS {
  227|      1|        fn eq(&self, other: &Self) -> bool {
  228|      1|            let self_memo = self.memo_table.lock().unwrap();
  229|      1|            let other_memo = other.memo_table.lock().unwrap();
  230|      1|            self.seq_s == other.seq_s && self.seq_t == other.seq_t && *self_memo == *other_memo
  231|      1|        }
  232|       |    }
  233|       |
  234|       |    impl Default for TopDownDPMtPerS {
  235|      4|        fn default() -> Self {
  236|      4|            let empty_s = ArraySeqMtPerS::new(0, ' ');
  237|      4|            let empty_t = ArraySeqMtPerS::new(0, ' ');
  238|      4|            Self::new(empty_s, empty_t)
  239|      4|        }
  240|       |    }
  241|       |
  242|       |    impl Display for TopDownDPMtPerS {
  243|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  244|      1|            write!(
  245|      1|                f,
  246|      1|                "TopDownDPMtPer(s_len={}, t_len={}, memo_size={})",
  247|      1|                self.s_length(),
  248|      1|                self.t_length(),
  249|      1|                self.memo_size()
  250|       |            )
  251|      1|        }
  252|       |    }
  253|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap51/TopDownDPStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Top-Down Dynamic Programming - Ephemeral Single-Threaded Implementation
    3|       |//!
    4|       |//! This module implements the top-down (memoization) approach to dynamic programming
    5|       |//! using HashMap with in-place mutations for efficient subproblem caching.
    6|       |
    7|       |pub mod TopDownDPStEph {
    8|       |
    9|       |    use std::collections::HashMap;
   10|       |    use std::fmt::{Debug, Display};
   11|       |
   12|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   13|       |    use crate::Types::Types::*;
   14|       |
   15|       |    /// Trait for top-down dynamic programming operations
   16|       |    pub trait TopDownDPStEphTrait<T: StT> {
   17|       |        /// Create new top-down DP solver
   18|       |        /// APAS: Work (1), Span (1)
   19|       |        fn new() -> Self;
   20|       |
   21|       |        /// Solve DP problem with memoization
   22|       |        /// APAS: Work O(n), Span O(n)
   23|       |        fn solve(&self, input: &[T]) -> T;
   24|       |    }
   25|       |
   26|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   27|       |    pub struct TopDownDPStEphS {
   28|       |        /// Input sequence S
   29|       |        seq_s: ArraySeqStEphS<char>,
   30|       |        /// Input sequence T  
   31|       |        seq_t: ArraySeqStEphS<char>,
   32|       |        /// Memoization table for subproblem results
   33|       |        memo_table: HashMap<(usize, usize), usize>,
   34|       |    }
   35|       |
   36|       |    impl TopDownDPStEphS {
   37|       |        /// claude-4-sonet: Work (1), Span (1)
   38|     16|        pub fn new(s: ArraySeqStEphS<char>, t: ArraySeqStEphS<char>) -> Self {
   39|     16|            TopDownDPStEphS {
   40|     16|                seq_s: s,
   41|     16|                seq_t: t,
   42|     16|                memo_table: HashMap::new(),
   43|     16|            }
   44|     16|        }
   45|       |
   46|       |        /// Compute minimum edit distance using top-down memoization
   47|       |        /// claude-4-sonet: Work (|S||T|), Span (|S|+|T|), Parallelism (1)
   48|      3|        pub fn med_memoized(&mut self) -> usize {
   49|      3|            let s_len = self.seq_s.length();
   50|      3|            let t_len = self.seq_t.length();
   51|       |
   52|      3|            self.med_recursive(s_len, t_len)
   53|      3|        }
   54|       |
   55|       |        /// Recursive helper with memoization
   56|       |        /// claude-4-sonet: Work (1) amortized per call, (|S||T|) total; Span (|S|+|T|)
   57|     28|        fn med_recursive(&mut self, i: usize, j: usize) -> usize {
   58|       |            // Check memo table first
   59|     28|            if let Some(&cached_result) = self.memo_table.get(&(i, j)) {
                                       ^9
   60|      9|                return cached_result;
   61|     19|            }
   62|       |
   63|       |            // Base cases
   64|     19|            let result = match (i, j) {
   65|      4|                | (0, j) => j, // Insert all remaining characters from T
   66|      2|                | (i, 0) => i, // Delete all remaining characters from S
   67|     13|                | (i, j) => {
   68|     13|                    let s_char = *self.seq_s.nth(i - 1);
   69|     13|                    let t_char = *self.seq_t.nth(j - 1);
   70|       |
   71|     13|                    if s_char == t_char {
   72|       |                        // Characters match: no edit needed
   73|      7|                        self.med_recursive(i - 1, j - 1)
   74|       |                    } else {
   75|       |                        // Characters don't match: try insert, delete, or substitute
   76|      6|                        let insert_cost = 1 + self.med_recursive(i, j - 1);
   77|      6|                        let delete_cost = 1 + self.med_recursive(i - 1, j);
   78|      6|                        let substitute_cost = 1 + self.med_recursive(i - 1, j - 1);
   79|       |
   80|      6|                        insert_cost.min(delete_cost).min(substitute_cost)
   81|       |                    }
   82|       |                }
   83|       |            };
   84|       |
   85|       |            // Store result in memo table
   86|     19|            self.memo_table.insert((i, j), result);
   87|     19|            result
   88|     28|        }
   89|       |
   90|       |        /// Get current memoization table size
   91|       |        /// Claude Work: O(1) - constant time access
   92|       |        /// Claude Span: O(1) - constant time access
   93|      4|        pub fn memo_size(&self) -> usize { self.memo_table.len() }
   94|       |
   95|       |        /// Check if subproblem is memoized
   96|       |        /// Claude Work: O(1) - constant time lookup
   97|       |        /// Claude Span: O(1) - constant time lookup
   98|      1|        pub fn is_memoized(&self, i: usize, j: usize) -> bool { self.memo_table.contains_key(&(i, j)) }
   99|       |
  100|       |        /// Get memoized result if available
  101|       |        /// Claude Work: O(1) - constant time lookup
  102|       |        /// Claude Span: O(1) - constant time lookup
  103|      1|        pub fn get_memoized(&self, i: usize, j: usize) -> Option<usize> { self.memo_table.get(&(i, j)).copied() }
  104|       |
  105|       |        /// Insert memoized result
  106|       |        /// Claude Work: O(1) - constant time insertion
  107|       |        /// Claude Span: O(1) - constant time insertion
  108|      0|        pub fn insert_memo(&mut self, i: usize, j: usize, value: usize) { self.memo_table.insert((i, j), value); }
  109|       |
  110|       |        /// Get the length of sequence S
  111|       |        /// Claude Work: O(1) - constant time access
  112|       |        /// Claude Span: O(1) - constant time access
  113|      4|        pub fn s_length(&self) -> usize { self.seq_s.length() }
  114|       |
  115|       |        /// Get the length of sequence T
  116|       |        /// Claude Work: O(1) - constant time access
  117|       |        /// Claude Span: O(1) - constant time access
  118|      4|        pub fn t_length(&self) -> usize { self.seq_t.length() }
  119|       |
  120|       |        /// Check if sequences are empty
  121|       |        /// Claude Work: O(1) - constant time check
  122|       |        /// Claude Span: O(1) - constant time check
  123|      2|        pub fn is_empty(&self) -> bool { self.seq_s.length() == 0usize && self.seq_t.length() == 0usize }
                                                                                        ^1
  124|       |
  125|       |        /// Clear memoization table
  126|       |        /// Claude Work: O(1) - constant time clear
  127|       |        /// Claude Span: O(1) - constant time clear
  128|      1|        pub fn clear_memo(&mut self) { self.memo_table.clear(); }
  129|       |
  130|       |        /// Mutably update sequence S
  131|       |        /// Claude Work: O(1) - constant time update
  132|       |        /// Claude Span: O(1) - constant time update
  133|      0|        pub fn set_s(&mut self, s: ArraySeqStEphS<char>) {
  134|      0|            self.seq_s = s;
  135|      0|            self.clear_memo(); // Clear memo when sequences change
  136|      0|        }
  137|       |
  138|       |        /// Mutably update sequence T
  139|       |        /// Claude Work: O(1) - constant time update
  140|       |        /// Claude Span: O(1) - constant time update
  141|      0|        pub fn set_t(&mut self, t: ArraySeqStEphS<char>) {
  142|      0|            self.seq_t = t;
  143|      0|            self.clear_memo(); // Clear memo when sequences change
  144|      0|        }
  145|       |    }
  146|       |
  147|       |    impl Default for TopDownDPStEphS {
  148|      4|        fn default() -> Self {
  149|      4|            let empty_s = ArraySeqStEphS::new(0, ' ');
  150|      4|            let empty_t = ArraySeqStEphS::new(0, ' ');
  151|      4|            Self::new(empty_s, empty_t)
  152|      4|        }
  153|       |    }
  154|       |
  155|       |    impl Display for TopDownDPStEphS {
  156|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  157|      1|            write!(
  158|      1|                f,
  159|      1|                "TopDownDPStEph(s_len={}, t_len={}, memo_size={})",
  160|      1|                self.s_length(),
  161|      1|                self.t_length(),
  162|      1|                self.memo_size()
  163|       |            )
  164|      1|        }
  165|       |    }
  166|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap51/TopDownDPStPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Top-Down Dynamic Programming - Persistent Single-Threaded Implementation.
    3|       |//!
    4|       |//! This module implements the top-down (memoization) approach to dynamic programming
    5|       |//! using HashMap for efficient subproblem caching.
    6|       |
    7|       |pub mod TopDownDPStPer {
    8|       |
    9|       |    use std::collections::HashMap;
   10|       |    use std::fmt::{Debug, Display};
   11|       |
   12|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
   13|       |    use crate::Types::Types::*;
   14|       |
   15|       |    /// Trait for top-down dynamic programming operations
   16|       |    pub trait TopDownDPStPerTrait<T: StT> {
   17|       |        /// Create new top-down DP solver
   18|       |        /// APAS: Work (1), Span (1)
   19|       |        fn new() -> Self;
   20|       |
   21|       |        /// Solve DP problem with memoization
   22|       |        /// APAS: Work O(n), Span O(n)
   23|       |        fn solve(&self, input: &[T]) -> T;
   24|       |    }
   25|       |
   26|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   27|       |    pub struct TopDownDPStPerS {
   28|       |        /// Input sequence S
   29|       |        seq_s: ArraySeqStPerS<char>,
   30|       |        /// Input sequence T  
   31|       |        seq_t: ArraySeqStPerS<char>,
   32|       |        /// Memoization table for subproblem results
   33|       |        memo_table: HashMap<(usize, usize), usize>,
   34|       |    }
   35|       |
   36|       |    impl TopDownDPStPerS {
   37|       |        /// claude-4-sonet: Work (1), Span (1)
   38|     16|        pub fn new(s: ArraySeqStPerS<char>, t: ArraySeqStPerS<char>) -> Self {
   39|     16|            TopDownDPStPerS {
   40|     16|                seq_s: s,
   41|     16|                seq_t: t,
   42|     16|                memo_table: HashMap::new(),
   43|     16|            }
   44|     16|        }
   45|       |
   46|       |        /// Compute minimum edit distance using top-down memoization
   47|       |        /// claude-4-sonet: Work (|S||T|), Span (|S|+|T|), Parallelism (1)
   48|      3|        pub fn med_memoized(&self) -> usize {
   49|      3|            let s_len = self.seq_s.length();
   50|      3|            let t_len = self.seq_t.length();
   51|       |
   52|       |            // Create mutable copy of memo table for computation
   53|      3|            let mut memo = self.memo_table.clone();
   54|       |
   55|      3|            self.med_recursive(s_len, t_len, &mut memo)
   56|      3|        }
   57|       |
   58|       |        /// Recursive helper with memoization
   59|       |        /// claude-4-sonet: Work (1) amortized per call, (|S||T|) total; Span (|S|+|T|)
   60|     28|        fn med_recursive(&self, i: usize, j: usize, memo: &mut HashMap<(usize, usize), usize>) -> usize {
   61|       |            // Check memo table first
   62|     28|            if let Some(&cached_result) = memo.get(&(i, j)) {
                                       ^9
   63|      9|                return cached_result;
   64|     19|            }
   65|       |
   66|       |            // Base cases
   67|     19|            let result = match (i, j) {
   68|      4|                | (0, j) => j, // Insert all remaining characters from T
   69|      2|                | (i, 0) => i, // Delete all remaining characters from S
   70|     13|                | (i, j) => {
   71|     13|                    let s_char = *self.seq_s.nth(i - 1);
   72|     13|                    let t_char = *self.seq_t.nth(j - 1);
   73|       |
   74|     13|                    if s_char == t_char {
   75|       |                        // Characters match: no edit needed
   76|      7|                        self.med_recursive(i - 1, j - 1, memo)
   77|       |                    } else {
   78|       |                        // Characters don't match: try insert, delete, or substitute
   79|      6|                        let insert_cost = 1 + self.med_recursive(i, j - 1, memo);
   80|      6|                        let delete_cost = 1 + self.med_recursive(i - 1, j, memo);
   81|      6|                        let substitute_cost = 1 + self.med_recursive(i - 1, j - 1, memo);
   82|       |
   83|      6|                        insert_cost.min(delete_cost).min(substitute_cost)
   84|       |                    }
   85|       |                }
   86|       |            };
   87|       |
   88|       |            // Store result in memo table
   89|     19|            memo.insert((i, j), result);
   90|     19|            result
   91|     28|        }
   92|       |
   93|       |        /// Create new instance with updated memoization table
   94|       |        /// Claude Work: O(1) - constant time update
   95|       |        /// Claude Span: O(1) - constant time update
   96|      1|        pub fn with_memo_table(self, memo: HashMap<(usize, usize), usize>) -> Self {
   97|      1|            TopDownDPStPerS {
   98|      1|                seq_s: self.seq_s,
   99|      1|                seq_t: self.seq_t,
  100|      1|                memo_table: memo,
  101|      1|            }
  102|      1|        }
  103|       |
  104|       |        /// Get current memoization table size
  105|       |        /// Claude Work: O(1) - constant time access
  106|       |        /// Claude Span: O(1) - constant time access
  107|      5|        pub fn memo_size(&self) -> usize { self.memo_table.len() }
  108|       |
  109|       |        /// Check if subproblem is memoized
  110|       |        /// Claude Work: O(1) - constant time lookup
  111|       |        /// Claude Span: O(1) - constant time lookup
  112|      1|        pub fn is_memoized(&self, i: usize, j: usize) -> bool { self.memo_table.contains_key(&(i, j)) }
  113|       |
  114|       |        /// Get memoized result if available
  115|       |        /// Claude Work: O(1) - constant time lookup
  116|       |        /// Claude Span: O(1) - constant time lookup
  117|      1|        pub fn get_memoized(&self, i: usize, j: usize) -> Option<usize> { self.memo_table.get(&(i, j)).copied() }
  118|       |
  119|       |        /// Get the length of sequence S
  120|       |        /// Claude Work: O(1) - constant time access
  121|       |        /// Claude Span: O(1) - constant time access
  122|      4|        pub fn s_length(&self) -> usize { self.seq_s.length() }
  123|       |
  124|       |        /// Get the length of sequence T
  125|       |        /// Claude Work: O(1) - constant time access
  126|       |        /// Claude Span: O(1) - constant time access
  127|      4|        pub fn t_length(&self) -> usize { self.seq_t.length() }
  128|       |
  129|       |        /// Check if sequences are empty
  130|       |        /// Claude Work: O(1) - constant time check
  131|       |        /// Claude Span: O(1) - constant time check
  132|      2|        pub fn is_empty(&self) -> bool { self.seq_s.length() == 0usize && self.seq_t.length() == 0usize }
                                                                                        ^1
  133|       |
  134|       |        /// Clear memoization table
  135|       |        /// Claude Work: O(1) - constant time clear
  136|       |        /// Claude Span: O(1) - constant time clear
  137|      1|        pub fn clear_memo(self) -> Self {
  138|      1|            TopDownDPStPerS {
  139|      1|                seq_s: self.seq_s,
  140|      1|                seq_t: self.seq_t,
  141|      1|                memo_table: HashMap::new(),
  142|      1|            }
  143|      1|        }
  144|       |    }
  145|       |
  146|       |    impl Default for TopDownDPStPerS {
  147|      4|        fn default() -> Self {
  148|      4|            let empty_s = ArraySeqStPerS::new(0, ' ');
  149|      4|            let empty_t = ArraySeqStPerS::new(0, ' ');
  150|      4|            Self::new(empty_s, empty_t)
  151|      4|        }
  152|       |    }
  153|       |
  154|       |    impl Display for TopDownDPStPerS {
  155|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  156|      1|            write!(
  157|      1|                f,
  158|      1|                "TopDownDPStPer(s_len={}, t_len={}, memo_size={})",
  159|      1|                self.s_length(),
  160|      1|                self.t_length(),
  161|      1|                self.memo_size()
  162|       |            )
  163|      1|        }
  164|       |    }
  165|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap52/AdjMatrixGraphStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 52: Adjacency Matrix Graph (ephemeral, single-threaded).
    3|       |
    4|       |pub mod AdjMatrixGraphStEph {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
    7|       |    use crate::Types::Types::*;
    8|       |
    9|       |    #[derive(Clone)]
   10|       |    pub struct AdjMatrixGraphStEph {
   11|       |        matrix: ArraySeqStEphS<ArraySeqStEphS<bool>>,
   12|       |        n: N,
   13|       |    }
   14|       |
   15|       |    pub trait AdjMatrixGraphStEphTrait {
   16|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   17|       |        fn new(n: N) -> Self;
   18|       |        /// claude-4-sonet: Work (1), Span (1)
   19|       |        fn from_matrix(matrix: ArraySeqStEphS<ArraySeqStEphS<bool>>) -> Self;
   20|       |        /// claude-4-sonet: Work (1), Span (1)
   21|       |        fn num_vertices(&self) -> N;
   22|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   23|       |        fn num_edges(&self) -> N;
   24|       |        /// claude-4-sonet: Work (1), Span (1)
   25|       |        fn has_edge(&self, u: N, v: N) -> B;
   26|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   27|       |        fn out_neighbors(&self, u: N) -> ArraySeqStEphS<N>;
   28|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   29|       |        fn out_degree(&self, u: N) -> N;
   30|       |        /// claude-4-sonet: Work (1), Span (1)
   31|       |        fn set_edge(&mut self, u: N, v: N, exists: B);
   32|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   33|       |        fn complement(&self) -> Self;
   34|       |    }
   35|       |
   36|       |    impl AdjMatrixGraphStEphTrait for AdjMatrixGraphStEph {
   37|     10|        fn new(n: N) -> Self {
   38|     10|            let false_row = ArraySeqStEphS::from_vec(vec![false; n]);
   39|     10|            let mut matrix_rows = Vec::with_capacity(n);
   40|     38|            for _ in 0..n {
                                      ^10
   41|     38|                matrix_rows.push(false_row.clone());
   42|     38|            }
   43|     10|            AdjMatrixGraphStEph {
   44|     10|                matrix: ArraySeqStEphS::from_vec(matrix_rows),
   45|     10|                n,
   46|     10|            }
   47|     10|        }
   48|       |
   49|      0|        fn from_matrix(matrix: ArraySeqStEphS<ArraySeqStEphS<bool>>) -> Self {
   50|      0|            let n = matrix.length();
   51|      0|            AdjMatrixGraphStEph { matrix, n }
   52|      0|        }
   53|       |
   54|      1|        fn num_vertices(&self) -> N { self.n }
   55|       |
   56|      3|        fn num_edges(&self) -> N {
   57|      3|            let mut count = 0;
   58|     13|            for i in 0..self.n {
                                      ^3
   59|     13|                let row = self.matrix.nth(i);
   60|     57|                for j in 0..self.n {
                                          ^13
   61|     57|                    if *row.nth(j) {
   62|     14|                        count += 1;
   63|     43|                    }
   64|       |                }
   65|       |            }
   66|      3|            count
   67|      3|        }
   68|       |
   69|      6|        fn has_edge(&self, u: N, v: N) -> B {
   70|      6|            if u >= self.n || v >= self.n {
   71|      0|                return false;
   72|      6|            }
   73|      6|            *self.matrix.nth(u).nth(v)
   74|      6|        }
   75|       |
   76|      1|        fn out_neighbors(&self, u: N) -> ArraySeqStEphS<N> {
   77|      1|            if u >= self.n {
   78|      0|                return ArraySeqStEphS::empty();
   79|      1|            }
   80|      1|            let row = self.matrix.nth(u);
   81|      1|            let mut neighbors = Vec::new();
   82|      4|            for v in 0..self.n {
                                      ^1
   83|      4|                if *row.nth(v) {
   84|      2|                    neighbors.push(v);
   85|      2|                }
   86|       |            }
   87|      1|            ArraySeqStEphS::from_vec(neighbors)
   88|      1|        }
   89|       |
   90|      1|        fn out_degree(&self, u: N) -> N {
   91|      1|            if u >= self.n {
   92|      0|                return 0;
   93|      1|            }
   94|      1|            let row = self.matrix.nth(u);
   95|      1|            let mut count = 0;
   96|      4|            for v in 0..self.n {
                                      ^1
   97|      4|                if *row.nth(v) {
   98|      2|                    count += 1;
   99|      2|                }
  100|       |            }
  101|      1|            count
  102|      1|        }
  103|       |
  104|     23|        fn set_edge(&mut self, u: N, v: N, exists: B) {
  105|     23|            if u >= self.n || v >= self.n {
  106|      0|                return;
  107|     23|            }
  108|     23|            let mut row = self.matrix.nth(u).clone();
  109|     23|            let _ = row.set(v, exists);
  110|     23|            let _ = self.matrix.set(u, row);
  111|     23|        }
  112|       |
  113|      1|        fn complement(&self) -> Self {
  114|      1|            let mut new_matrix_vec = Vec::with_capacity(self.n);
  115|      3|            for i in 0..self.n {
                                      ^1
  116|      3|                let row = self.matrix.nth(i);
  117|      3|                let mut new_row_vec = Vec::with_capacity(self.n);
  118|      9|                for j in 0..self.n {
                                          ^3
  119|      9|                    if i == j {
  120|      3|                        new_row_vec.push(false);
  121|      6|                    } else {
  122|      6|                        new_row_vec.push(!*row.nth(j));
  123|      6|                    }
  124|       |                }
  125|      3|                new_matrix_vec.push(ArraySeqStEphS::from_vec(new_row_vec));
  126|       |            }
  127|      1|            AdjMatrixGraphStEph {
  128|      1|                matrix: ArraySeqStEphS::from_vec(new_matrix_vec),
  129|      1|                n: self.n,
  130|      1|            }
  131|      1|        }
  132|       |    }
  133|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap52/AdjMatrixGraphStPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 52: Adjacency Matrix Graph (persistent, single-threaded).
    3|       |//! G = (bool seq) seq - for enumerable vertex sets V = {0, 1, ..., n-1}.
    4|       |
    5|       |pub mod AdjMatrixGraphStPer {
    6|       |
    7|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    8|       |    use crate::Types::Types::*;
    9|       |
   10|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   11|       |    pub struct AdjMatrixGraphStPer {
   12|       |        matrix: ArraySeqStPerS<ArraySeqStPerS<bool>>,
   13|       |        n: N,
   14|       |    }
   15|       |
   16|       |    pub trait AdjMatrixGraphStPerTrait {
   17|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   18|       |        fn new(n: N) -> Self;
   19|       |        /// claude-4-sonet: Work (1), Span (1)
   20|       |        fn from_matrix(matrix: ArraySeqStPerS<ArraySeqStPerS<bool>>) -> Self;
   21|       |        /// claude-4-sonet: Work (1), Span (1)
   22|       |        fn num_vertices(&self) -> N;
   23|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   24|       |        fn num_edges(&self) -> N;
   25|       |        /// claude-4-sonet: Work (1), Span (1)
   26|       |        fn has_edge(&self, u: N, v: N) -> B;
   27|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   28|       |        fn out_neighbors(&self, u: N) -> ArraySeqStPerS<N>;
   29|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   30|       |        fn out_degree(&self, u: N) -> N;
   31|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   32|       |        fn set_edge(&self, u: N, v: N, exists: B) -> Self;
   33|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   34|       |        fn complement(&self) -> Self;
   35|       |    }
   36|       |
   37|       |    impl AdjMatrixGraphStPerTrait for AdjMatrixGraphStPer {
   38|       |        // Work: (n), Span: (n) - create nn matrix of false
   39|      8|        fn new(n: N) -> Self {
   40|      8|            let false_row = ArraySeqStPerS::from_vec(vec![false; n]);
   41|      8|            let mut matrix_rows = Vec::with_capacity(n);
   42|     29|            for _ in 0..n {
                                      ^8
   43|     29|                matrix_rows.push(false_row.clone());
   44|     29|            }
   45|      8|            AdjMatrixGraphStPer {
   46|      8|                matrix: ArraySeqStPerS::from_vec(matrix_rows),
   47|      8|                n,
   48|      8|            }
   49|      8|        }
   50|       |
   51|      0|        fn from_matrix(matrix: ArraySeqStPerS<ArraySeqStPerS<bool>>) -> Self {
   52|      0|            let n = matrix.length();
   53|      0|            AdjMatrixGraphStPer { matrix, n }
   54|      0|        }
   55|       |
   56|       |        // Work: (1), Span: (1)
   57|      1|        fn num_vertices(&self) -> N { self.n }
   58|       |
   59|       |        // Work: (n), Span: (n) - count all true entries
   60|      1|        fn num_edges(&self) -> N {
   61|      1|            let mut count = 0;
   62|      4|            for i in 0..self.n {
                                      ^1
   63|      4|                let row = self.matrix.nth(i);
   64|     16|                for j in 0..self.n {
                                          ^4
   65|     16|                    if *row.nth(j) {
   66|      2|                        count += 1;
   67|     14|                    }
   68|       |                }
   69|       |            }
   70|      1|            count
   71|      1|        }
   72|       |
   73|       |        // Work: (1), Span: (1) - direct array access
   74|      7|        fn has_edge(&self, u: N, v: N) -> B {
   75|      7|            if u >= self.n || v >= self.n {
   76|      0|                return false;
   77|      7|            }
   78|      7|            *self.matrix.nth(u).nth(v)
   79|      7|        }
   80|       |
   81|       |        // Work: (n), Span: (n) - scan row for true entries
   82|      1|        fn out_neighbors(&self, u: N) -> ArraySeqStPerS<N> {
   83|      1|            if u >= self.n {
   84|      0|                return ArraySeqStPerS::empty();
   85|      1|            }
   86|      1|            let row = self.matrix.nth(u);
   87|      1|            let mut neighbors = Vec::new();
   88|      4|            for v in 0..self.n {
                                      ^1
   89|      4|                if *row.nth(v) {
   90|      2|                    neighbors.push(v);
   91|      2|                }
   92|       |            }
   93|      1|            ArraySeqStPerS::from_vec(neighbors)
   94|      1|        }
   95|       |
   96|       |        // Work: (n), Span: (n)
   97|      1|        fn out_degree(&self, u: N) -> N {
   98|      1|            if u >= self.n {
   99|      0|                return 0;
  100|      1|            }
  101|      1|            let row = self.matrix.nth(u);
  102|      1|            let mut count = 0;
  103|      4|            for v in 0..self.n {
                                      ^1
  104|      4|                if *row.nth(v) {
  105|      2|                    count += 1;
  106|      2|                }
  107|       |            }
  108|      1|            count
  109|      1|        }
  110|       |
  111|       |        // Work: (n), Span: (n) - copy row and update
  112|     11|        fn set_edge(&self, u: N, v: N, exists: B) -> Self {
  113|     11|            if u >= self.n || v >= self.n {
  114|      0|                return self.clone();
  115|     11|            }
  116|     11|            let old_row = self.matrix.nth(u);
  117|     11|            let mut new_row_vec = Vec::with_capacity(self.n);
  118|     39|            for j in 0..self.n {
                                      ^11
  119|     39|                if j == v {
  120|     11|                    new_row_vec.push(exists);
  121|     28|                } else {
  122|     28|                    new_row_vec.push(*old_row.nth(j));
  123|     28|                }
  124|       |            }
  125|     11|            let new_row = ArraySeqStPerS::from_vec(new_row_vec);
  126|       |
  127|     11|            let mut new_matrix_vec = Vec::with_capacity(self.n);
  128|     39|            for i in 0..self.n {
                                      ^11
  129|     39|                if i == u {
  130|     11|                    new_matrix_vec.push(new_row.clone());
  131|     28|                } else {
  132|     28|                    new_matrix_vec.push(self.matrix.nth(i).clone());
  133|     28|                }
  134|       |            }
  135|     11|            AdjMatrixGraphStPer {
  136|     11|                matrix: ArraySeqStPerS::from_vec(new_matrix_vec),
  137|     11|                n: self.n,
  138|     11|            }
  139|     11|        }
  140|       |
  141|       |        // Work: (n), Span: (1) with parallel - Exercise 52.6
  142|      1|        fn complement(&self) -> Self {
  143|      1|            let mut new_matrix_vec = Vec::with_capacity(self.n);
  144|      3|            for i in 0..self.n {
                                      ^1
  145|      3|                let row = self.matrix.nth(i);
  146|      3|                let mut new_row_vec = Vec::with_capacity(self.n);
  147|      9|                for j in 0..self.n {
                                          ^3
  148|       |                    // Complement: flip all entries except diagonal
  149|      9|                    if i == j {
  150|      3|                        new_row_vec.push(false);
  151|      6|                    } else {
  152|      6|                        new_row_vec.push(!*row.nth(j));
  153|      6|                    }
  154|       |                }
  155|      3|                new_matrix_vec.push(ArraySeqStPerS::from_vec(new_row_vec));
  156|       |            }
  157|      1|            AdjMatrixGraphStPer {
  158|      1|                matrix: ArraySeqStPerS::from_vec(new_matrix_vec),
  159|      1|                n: self.n,
  160|      1|            }
  161|      1|        }
  162|       |    }
  163|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap52/AdjSeqGraphStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 52: Adjacency Sequence Graph (ephemeral, single-threaded).
    3|       |
    4|       |pub mod AdjSeqGraphStEph {
    5|       |
    6|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
    7|       |    use crate::Types::Types::*;
    8|       |
    9|       |    #[derive(Clone)]
   10|       |    pub struct AdjSeqGraphStEph {
   11|       |        adj: ArraySeqStEphS<ArraySeqStEphS<N>>,
   12|       |    }
   13|       |
   14|       |    pub trait AdjSeqGraphStEphTrait {
   15|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   16|       |        fn new(n: N) -> Self;
   17|       |        /// claude-4-sonet: Work (1), Span (1)
   18|       |        fn from_seq(adj: ArraySeqStEphS<ArraySeqStEphS<N>>) -> Self;
   19|       |        /// claude-4-sonet: Work (1), Span (1)
   20|       |        fn num_vertices(&self) -> N;
   21|       |        /// claude-4-sonet: Work ( deg(v)), Span ( deg(v)), Parallelism (1)
   22|       |        fn num_edges(&self) -> N;
   23|       |        /// claude-4-sonet: Work (deg(u)), Span (deg(u)), Parallelism (1)
   24|       |        fn has_edge(&self, u: N, v: N) -> B;
   25|       |        /// claude-4-sonet: Work (1), Span (1)
   26|       |        fn out_neighbors(&self, u: N) -> ArraySeqStEphS<N>;
   27|       |        /// claude-4-sonet: Work (1), Span (1)
   28|       |        fn out_degree(&self, u: N) -> N;
   29|       |        /// claude-4-sonet: Work (1), Span (1)
   30|       |        fn set_neighbors(&mut self, v: N, neighbors: ArraySeqStEphS<N>);
   31|       |        /// claude-4-sonet: Work (deg(u)), Span (deg(u)), Parallelism (1)
   32|       |        fn set_edge(&mut self, u: N, v: N, exists: B);
   33|       |    }
   34|       |
   35|       |    impl AdjSeqGraphStEphTrait for AdjSeqGraphStEph {
   36|      9|        fn new(n: N) -> Self {
   37|      9|            let empty_list = ArraySeqStEphS::empty();
   38|      9|            let mut adj_lists = Vec::with_capacity(n);
   39|     35|            for _ in 0..n {
                                      ^9
   40|     35|                adj_lists.push(empty_list.clone());
   41|     35|            }
   42|      9|            AdjSeqGraphStEph {
   43|      9|                adj: ArraySeqStEphS::from_vec(adj_lists),
   44|      9|            }
   45|      9|        }
   46|       |
   47|      0|        fn from_seq(adj: ArraySeqStEphS<ArraySeqStEphS<N>>) -> Self { AdjSeqGraphStEph { adj } }
   48|       |
   49|      1|        fn num_vertices(&self) -> N { self.adj.length() }
   50|       |
   51|      2|        fn num_edges(&self) -> N {
   52|      2|            let n = self.adj.length();
   53|      2|            let mut count = 0;
   54|      9|            for i in 0..n {
                                      ^2
   55|      9|                count += self.adj.nth(i).length();
   56|      9|            }
   57|      2|            count
   58|      2|        }
   59|       |
   60|      7|        fn has_edge(&self, u: N, v: N) -> B {
   61|      7|            if u >= self.adj.length() {
   62|      0|                return false;
   63|      7|            }
   64|      7|            let neighbors = self.adj.nth(u);
   65|      7|            for i in 0..neighbors.length() {
                              ^6
   66|      6|                if *neighbors.nth(i) == v {
   67|      5|                    return true;
   68|      1|                }
   69|       |            }
   70|      2|            false
   71|      7|        }
   72|       |
   73|      1|        fn out_neighbors(&self, u: N) -> ArraySeqStEphS<N> { self.adj.nth(u).clone() }
   74|       |
   75|      1|        fn out_degree(&self, u: N) -> N { self.adj.nth(u).length() }
   76|       |
   77|      0|        fn set_neighbors(&mut self, v: N, neighbors: ArraySeqStEphS<N>) {
   78|      0|            if v < self.adj.length() {
   79|      0|                let _ = self.adj.set(v, neighbors);
   80|      0|            }
   81|      0|        }
   82|       |
   83|     12|        fn set_edge(&mut self, u: N, v: N, exists: B) {
   84|     12|            if u >= self.adj.length() || v >= self.adj.length() {
   85|      0|                return;
   86|     12|            }
   87|     12|            let old_neighbors = self.adj.nth(u);
   88|     12|            if exists {
   89|       |                // Add edge if not present
   90|     11|                let mut found = false;
   91|     11|                for i in 0..old_neighbors.length() {
                                  ^3
   92|      3|                    if *old_neighbors.nth(i) == v {
   93|      0|                        found = true;
   94|      0|                        break;
   95|      3|                    }
   96|       |                }
   97|     11|                if !found {
   98|     11|                    let mut new_neighbors_vec: Vec<N> = Vec::with_capacity(old_neighbors.length() + 1);
   99|     11|                    for i in 0..old_neighbors.length() {
                                      ^3
  100|      3|                        new_neighbors_vec.push(*old_neighbors.nth(i));
  101|      3|                    }
  102|     11|                    new_neighbors_vec.push(v);
  103|     11|                    let _ = self.adj.set(u, ArraySeqStEphS::from_vec(new_neighbors_vec));
  104|      0|                }
  105|       |            } else {
  106|       |                // Remove edge if present
  107|      1|                let mut new_neighbors_vec: Vec<N> = Vec::new();
  108|      1|                for i in 0..old_neighbors.length() {
  109|      1|                    let neighbor = *old_neighbors.nth(i);
  110|      1|                    if neighbor != v {
  111|      0|                        new_neighbors_vec.push(neighbor);
  112|      1|                    }
  113|       |                }
  114|      1|                let _ = self.adj.set(u, ArraySeqStEphS::from_vec(new_neighbors_vec));
  115|       |            }
  116|     12|        }
  117|       |    }
  118|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap52/AdjSeqGraphStPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 52: Adjacency Sequence Graph (persistent, single-threaded).
    3|       |//! G = (int seq) seq - for enumerable vertex sets V = {0, 1, ..., n-1}.
    4|       |
    5|       |pub mod AdjSeqGraphStPer {
    6|       |
    7|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    8|       |    use crate::Types::Types::*;
    9|       |
   10|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   11|       |    pub struct AdjSeqGraphStPer {
   12|       |        adj: ArraySeqStPerS<ArraySeqStPerS<N>>,
   13|       |    }
   14|       |
   15|       |    pub trait AdjSeqGraphStPerTrait {
   16|       |        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)
   17|       |        fn new(n: N) -> Self;
   18|       |        /// claude-4-sonet: Work (1), Span (1)
   19|       |        fn from_seq(adj: ArraySeqStPerS<ArraySeqStPerS<N>>) -> Self;
   20|       |        /// claude-4-sonet: Work (1), Span (1)
   21|       |        fn num_vertices(&self) -> N;
   22|       |        /// claude-4-sonet: Work ( deg(v)), Span ( deg(v)), Parallelism (1)
   23|       |        fn num_edges(&self) -> N;
   24|       |        /// claude-4-sonet: Work (deg(u)), Span (deg(u)), Parallelism (1)
   25|       |        fn has_edge(&self, u: N, v: N) -> B;
   26|       |        /// claude-4-sonet: Work (1), Span (1)
   27|       |        fn out_neighbors(&self, u: N) -> &ArraySeqStPerS<N>;
   28|       |        /// claude-4-sonet: Work (1), Span (1)
   29|       |        fn out_degree(&self, u: N) -> N;
   30|       |        /// claude-4-sonet: Work (1 + deg(u)), Span (1 + deg(u)), Parallelism (1)
   31|       |        fn insert_edge(&self, u: N, v: N) -> Self;
   32|       |        /// claude-4-sonet: Work (deg(u)), Span (deg(u)), Parallelism (1)
   33|       |        fn delete_edge(&self, u: N, v: N) -> Self;
   34|       |    }
   35|       |
   36|       |    impl AdjSeqGraphStPerTrait for AdjSeqGraphStPer {
   37|       |        // Work: (n), Span: (n) - create n empty neighbor lists
   38|      9|        fn new(n: N) -> Self {
   39|      9|            let empty_list = ArraySeqStPerS::empty();
   40|      9|            let mut adj_lists = Vec::with_capacity(n);
   41|     35|            for _ in 0..n {
                                      ^9
   42|     35|                adj_lists.push(empty_list.clone());
   43|     35|            }
   44|      9|            AdjSeqGraphStPer {
   45|      9|                adj: ArraySeqStPerS::from_vec(adj_lists),
   46|      9|            }
   47|      9|        }
   48|       |
   49|      0|        fn from_seq(adj: ArraySeqStPerS<ArraySeqStPerS<N>>) -> Self { AdjSeqGraphStPer { adj } }
   50|       |
   51|       |        // Work: (1), Span: (1)
   52|      1|        fn num_vertices(&self) -> N { self.adj.length() }
   53|       |
   54|       |        // Work: (n), Span: (n) - sum all neighbor list lengths
   55|      2|        fn num_edges(&self) -> N {
   56|      2|            let n = self.adj.length();
   57|      2|            let mut count = 0;
   58|      9|            for i in 0..n {
                                      ^2
   59|      9|                count += self.adj.nth(i).length();
   60|      9|            }
   61|      2|            count
   62|      2|        }
   63|       |
   64|       |        // Work: (d(u)), Span: (d(u)) - linear search in neighbor list
   65|      8|        fn has_edge(&self, u: N, v: N) -> B {
   66|      8|            if u >= self.adj.length() {
   67|      0|                return false;
   68|      8|            }
   69|      8|            let neighbors = self.adj.nth(u);
   70|      8|            for i in 0..neighbors.length() {
                              ^6
   71|      6|                if *neighbors.nth(i) == v {
   72|      5|                    return true;
   73|      1|                }
   74|       |            }
   75|      3|            false
   76|      8|        }
   77|       |
   78|       |        // Work: (1), Span: (1) - direct access
   79|      1|        fn out_neighbors(&self, u: N) -> &ArraySeqStPerS<N> { self.adj.nth(u) }
   80|       |
   81|       |        // Work: (1), Span: (1)
   82|      1|        fn out_degree(&self, u: N) -> N { self.adj.nth(u).length() }
   83|       |
   84|       |        // Work: (n), Span: (n) - must copy entire sequence to update
   85|     11|        fn insert_edge(&self, u: N, v: N) -> Self {
   86|     11|            if u >= self.adj.length() || v >= self.adj.length() {
   87|      0|                return self.clone();
   88|     11|            }
   89|     11|            let old_neighbors = self.adj.nth(u);
   90|       |            // Check if edge already exists
   91|     11|            for i in 0..old_neighbors.length() {
                              ^3
   92|      3|                if *old_neighbors.nth(i) == v {
   93|      0|                    return self.clone();
   94|      3|                }
   95|       |            }
   96|       |            // Add v to u's neighbor list
   97|     11|            let mut new_neighbors_vec: Vec<N> = Vec::with_capacity(old_neighbors.length() + 1);
   98|     11|            for i in 0..old_neighbors.length() {
                              ^3
   99|      3|                new_neighbors_vec.push(*old_neighbors.nth(i));
  100|      3|            }
  101|     11|            new_neighbors_vec.push(v);
  102|     11|            let new_neighbors = ArraySeqStPerS::from_vec(new_neighbors_vec);
  103|       |
  104|       |            // Update adjacency list
  105|     11|            let mut new_adj_vec = Vec::with_capacity(self.adj.length());
  106|     41|            for i in 0..self.adj.length() {
                                      ^11      ^11
  107|     41|                if i == u {
  108|     11|                    new_adj_vec.push(new_neighbors.clone());
  109|     30|                } else {
  110|     30|                    new_adj_vec.push(self.adj.nth(i).clone());
  111|     30|                }
  112|       |            }
  113|     11|            AdjSeqGraphStPer {
  114|     11|                adj: ArraySeqStPerS::from_vec(new_adj_vec),
  115|     11|            }
  116|     11|        }
  117|       |
  118|       |        // Work: (n), Span: (n)
  119|      1|        fn delete_edge(&self, u: N, v: N) -> Self {
  120|      1|            if u >= self.adj.length() {
  121|      0|                return self.clone();
  122|      1|            }
  123|      1|            let old_neighbors = self.adj.nth(u);
  124|      1|            let mut new_neighbors_vec: Vec<N> = Vec::new();
  125|      1|            for i in 0..old_neighbors.length() {
  126|      1|                let neighbor = *old_neighbors.nth(i);
  127|      1|                if neighbor != v {
  128|      0|                    new_neighbors_vec.push(neighbor);
  129|      1|                }
  130|       |            }
  131|      1|            let new_neighbors = ArraySeqStPerS::from_vec(new_neighbors_vec);
  132|       |
  133|      1|            let mut new_adj_vec = Vec::with_capacity(self.adj.length());
  134|      3|            for i in 0..self.adj.length() {
                                      ^1       ^1
  135|      3|                if i == u {
  136|      1|                    new_adj_vec.push(new_neighbors.clone());
  137|      2|                } else {
  138|      2|                    new_adj_vec.push(self.adj.nth(i).clone());
  139|      2|                }
  140|       |            }
  141|      1|            AdjSeqGraphStPer {
  142|      1|                adj: ArraySeqStPerS::from_vec(new_adj_vec),
  143|      1|            }
  144|      1|        }
  145|       |    }
  146|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap52/AdjTableGraphMtPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 52: Adjacency Table Graph representation (persistent, multi-threaded with TRUE parallelism).
    3|       |//! G = (V, A:) where the graph is represented as a table mapping vertices to their out-neighbor sets.
    4|       |
    5|       |pub mod AdjTableGraphMtPer {
    6|       |
    7|       |    use crate::Chap41::AVLTreeSetMtPer::AVLTreeSetMtPer::*;
    8|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::ArraySetStEphTrait;
    9|       |    use crate::Chap43::OrderedTableMtPer::OrderedTableMtPer::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    #[derive(Clone)]
   13|       |    pub struct AdjTableGraphMtPer<V: StTInMtT + Ord + 'static> {
   14|       |        adj: OrderedTableMtPer<V, AVLTreeSetMtPer<V>>,
   15|       |    }
   16|       |
   17|       |    pub trait AdjTableGraphMtPerTrait<V: StTInMtT + Ord + 'static> {
   18|       |        /// claude-4-sonet: Work (1), Span (1)
   19|       |        fn empty() -> Self;
   20|       |        /// claude-4-sonet: Work (1), Span (1)
   21|       |        fn num_vertices(&self) -> N;
   22|       |        /// claude-4-sonet: Work (|V| + |E|), Span (log |V|  log |E|), Parallelism (|E|/log |V|)
   23|       |        fn num_edges(&self) -> N;
   24|       |        /// claude-4-sonet: Work (log |V| + log |E|), Span (log |V| + log |E|), Parallelism (1)
   25|       |        fn has_edge(&self, u: &V, v: &V) -> B;
   26|       |        /// claude-4-sonet: Work (log |V|), Span (log |V|), Parallelism (1)
   27|       |        fn out_neighbors(&self, u: &V) -> AVLTreeSetMtPer<V>;
   28|       |        /// claude-4-sonet: Work (log |V|), Span (log |V|), Parallelism (1)
   29|       |        fn out_degree(&self, u: &V) -> N;
   30|       |        /// claude-4-sonet: Work (log |V|), Span (log |V|), Parallelism (1)
   31|       |        fn insert_vertex(&self, v: V) -> Self;
   32|       |        /// claude-4-sonet: Work ((|V| + |E|) log |V|), Span (log |V| + log |E|), Parallelism (|E|/log |V|)
   33|       |        fn delete_vertex(&self, v: &V) -> Self;
   34|       |        /// claude-4-sonet: Work (log |V|), Span (log |V|), Parallelism (1)
   35|       |        fn insert_edge(&self, u: V, v: V) -> Self;
   36|       |        /// claude-4-sonet: Work (log |V| + log |E|), Span (log |V| + log |E|), Parallelism (1)
   37|       |        fn delete_edge(&self, u: &V, v: &V) -> Self;
   38|       |    }
   39|       |
   40|       |    impl<V: StTInMtT + Ord + 'static> AdjTableGraphMtPerTrait<V> for AdjTableGraphMtPer<V> {
   41|     10|        fn empty() -> Self {
   42|     10|            AdjTableGraphMtPer {
   43|     10|                adj: OrderedTableMtPer::empty(),
   44|     10|            }
   45|     10|        }
   46|       |
   47|      6|        fn num_vertices(&self) -> N { self.adj.size() }
   48|       |
   49|      8|        fn num_edges(&self) -> N {
   50|      8|            let domain = self.adj.domain();
   51|      8|            let domain_seq = domain.to_seq();
   52|      8|            let mut count = 0;
   53|     19|            for i in 0..domain.size() {
                                      ^8     ^8
   54|     19|                let v = domain_seq.nth(i);
   55|     19|                if let Some(neighbors) = self.adj.find(v) {
   56|     19|                    count += neighbors.size();
   57|     19|                }
                              ^0
   58|       |            }
   59|      8|            count
   60|      8|        }
   61|       |
   62|     16|        fn has_edge(&self, u: &V, v: &V) -> B { self.adj.find(u).map_or(false, |neighbors| neighbors.find(v)) }
                                                                                                         ^15       ^15  ^15
   63|       |
   64|      8|        fn out_neighbors(&self, u: &V) -> AVLTreeSetMtPer<V> {
   65|      8|            self.adj.find(u).unwrap_or_else(|| AVLTreeSetMtPer::empty())
                                                             ^2
   66|      8|        }
   67|       |
   68|      4|        fn out_degree(&self, u: &V) -> N { self.out_neighbors(u).size() }
   69|       |
   70|      3|        fn insert_vertex(&self, v: V) -> Self {
   71|      3|            if self.adj.find(&v).is_some() {
   72|      0|                return self.clone();
   73|      3|            }
   74|      3|            AdjTableGraphMtPer {
   75|      3|                adj: self.adj.insert(v, AVLTreeSetMtPer::empty()),
   76|      3|            }
   77|      3|        }
   78|       |
   79|      1|        fn delete_vertex(&self, v: &V) -> Self {
   80|      1|            let new_adj = self.adj.delete(v);
   81|      1|            let v_clone = v.clone();
   82|       |            // Remove v from all adjacency lists
   83|      2|            let new_adj = new_adj.map(|neighbors| neighbors.delete(&v_clone));
                              ^1        ^1      ^1
   84|      1|            AdjTableGraphMtPer { adj: new_adj }
   85|      1|        }
   86|       |
   87|     24|        fn insert_edge(&self, u: V, v: V) -> Self {
   88|     24|            let mut new_adj = self.adj.clone();
   89|       |            // Ensure both vertices exist
   90|     24|            if new_adj.find(&u).is_none() {
   91|      8|                new_adj = new_adj.insert(u.clone(), AVLTreeSetMtPer::empty());
   92|     16|            }
   93|     24|            if new_adj.find(&v).is_none() {
   94|     16|                new_adj = new_adj.insert(v.clone(), AVLTreeSetMtPer::empty());
   95|     16|            }
                          ^8
   96|       |            // Add v to u's adjacency list
   97|     24|            let u_neighbors = new_adj.find(&u).unwrap_or_else(|| AVLTreeSetMtPer::empty());
                                                                               ^0
   98|     24|            let new_u_neighbors = u_neighbors.insert(v);
   99|     24|            AdjTableGraphMtPer {
  100|     24|                adj: new_adj.insert(u, new_u_neighbors),
  101|     24|            }
  102|     24|        }
  103|       |
  104|      1|        fn delete_edge(&self, u: &V, v: &V) -> Self {
  105|      1|            if let Some(u_neighbors) = self.adj.find(u) {
  106|      1|                let new_u_neighbors = u_neighbors.delete(v);
  107|      1|                AdjTableGraphMtPer {
  108|      1|                    adj: self.adj.insert(u.clone(), new_u_neighbors),
  109|      1|                }
  110|       |            } else {
  111|      0|                self.clone()
  112|       |            }
  113|      1|        }
  114|       |    }
  115|       |
  116|       |    impl<V: StTInMtT + Ord + 'static> Default for AdjTableGraphMtPer<V> {
  117|      0|        fn default() -> Self { Self::empty() }
  118|       |    }
  119|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap52/AdjTableGraphStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 52: Adjacency Table Graph representation (ephemeral, single-threaded).
    3|       |
    4|       |pub mod AdjTableGraphStEph {
    5|       |
    6|       |    use crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::AVLTreeSeqStEphTrait;
    7|       |    use crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::*;
    8|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::ArraySetStEphTrait;
    9|       |    use crate::Chap43::OrderedTableStEph::OrderedTableStEph::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    #[derive(Clone)]
   13|       |    pub struct AdjTableGraphStEph<V: StT + Ord> {
   14|       |        adj: OrderedTableStEph<V, AVLTreeSetStEph<V>>,
   15|       |    }
   16|       |
   17|       |    pub trait AdjTableGraphStEphTrait<V: StT + Ord> {
   18|       |        /// claude-4-sonet: Work (1), Span (1)
   19|       |        fn empty() -> Self;
   20|       |        /// claude-4-sonet: Work (1), Span (1)
   21|       |        fn from_table(table: OrderedTableStEph<V, AVLTreeSetStEph<V>>) -> Self;
   22|       |        /// claude-4-sonet: Work (1), Span (1)
   23|       |        fn num_vertices(&self) -> N;
   24|       |        /// claude-4-sonet: Work (|V| + |E|), Span (|V| + |E|), Parallelism (1)
   25|       |        fn num_edges(&self) -> N;
   26|       |        /// claude-4-sonet: Work (|V|), Span (|V|), Parallelism (1)
   27|       |        fn vertices(&self) -> AVLTreeSetStEph<V>;
   28|       |        /// claude-4-sonet: Work (log |V| + log |E|), Span (log |V| + log |E|), Parallelism (1)
   29|       |        fn has_edge(&self, u: &V, v: &V) -> B;
   30|       |        /// claude-4-sonet: Work (log |V|), Span (log |V|), Parallelism (1)
   31|       |        fn out_neighbors(&self, u: &V) -> AVLTreeSetStEph<V>;
   32|       |        /// claude-4-sonet: Work (log |V|), Span (log |V|), Parallelism (1)
   33|       |        fn out_degree(&self, u: &V) -> N;
   34|       |        /// claude-4-sonet: Work (log |V|), Span (log |V|), Parallelism (1)
   35|       |        fn insert_vertex(&mut self, v: V);
   36|       |        /// claude-4-sonet: Work ((|V| + |E|) log |V|), Span ((|V| + |E|) log |V|), Parallelism (1)
   37|       |        fn delete_vertex(&mut self, v: &V);
   38|       |        /// claude-4-sonet: Work (log |V| + log |E|), Span (log |V| + log |E|), Parallelism (1)
   39|       |        fn insert_edge(&mut self, u: V, v: V);
   40|       |        /// claude-4-sonet: Work (log |V| + log |E|), Span (log |V| + log |E|), Parallelism (1)
   41|       |        fn delete_edge(&mut self, u: &V, v: &V);
   42|       |    }
   43|       |
   44|       |    impl<V: StT + Ord> AdjTableGraphStEphTrait<V> for AdjTableGraphStEph<V> {
   45|     10|        fn empty() -> Self {
   46|     10|            AdjTableGraphStEph {
   47|     10|                adj: OrderedTableStEph::empty(),
   48|     10|            }
   49|     10|        }
   50|       |
   51|      0|        fn from_table(table: OrderedTableStEph<V, AVLTreeSetStEph<V>>) -> Self { AdjTableGraphStEph { adj: table } }
   52|       |
   53|      6|        fn num_vertices(&self) -> N { self.adj.size() }
   54|       |
   55|      6|        fn num_edges(&self) -> N {
   56|      6|            let domain = self.adj.domain();
   57|      6|            let mut count = 0;
   58|     13|            for i in 0..domain.size() {
                                      ^6     ^6
   59|       |                // Get vertex from domain via to_seq
   60|     13|                let seq = domain.to_seq();
   61|     13|                if i < seq.length() {
   62|     13|                    let v = seq.nth(i);
   63|     13|                    if let Some(neighbors) = self.adj.find(v) {
   64|     13|                        count += neighbors.size();
   65|     13|                    }
                                  ^0
   66|      0|                }
   67|       |            }
   68|      6|            count
   69|      6|        }
   70|       |
   71|      1|        fn vertices(&self) -> AVLTreeSetStEph<V> {
   72|      1|            let domain = self.adj.domain();
   73|      1|            let seq = domain.to_seq();
   74|      1|            let mut result = AVLTreeSetStEph::empty();
   75|      3|            for i in 0..seq.length() {
                                      ^1  ^1
   76|      3|                result.insert(seq.nth(i).clone());
   77|      3|            }
   78|      1|            result
   79|      1|        }
   80|       |
   81|     14|        fn has_edge(&self, u: &V, v: &V) -> B {
   82|     14|            match self.adj.find(u) {
   83|     13|                | Some(neighbors) => neighbors.find(v),
   84|      1|                | None => false,
   85|       |            }
   86|     14|        }
   87|       |
   88|      8|        fn out_neighbors(&self, u: &V) -> AVLTreeSetStEph<V> {
   89|      8|            match self.adj.find(u) {
   90|      6|                | Some(neighbors) => neighbors.clone(),
   91|      2|                | None => AVLTreeSetStEph::empty(),
   92|       |            }
   93|      8|        }
   94|       |
   95|      4|        fn out_degree(&self, u: &V) -> N { self.out_neighbors(u).size() }
   96|       |
   97|      6|        fn insert_vertex(&mut self, v: V) { self.adj.insert(v, AVLTreeSetStEph::empty(), |_, new| new.clone()); }
                                                                                                                ^0  ^0
   98|       |
   99|      1|        fn delete_vertex(&mut self, v: &V) {
  100|      1|            let v_clone = v.clone();
  101|       |            // Get all vertices before deleting
  102|      1|            let domain = self.adj.domain();
  103|      1|            let seq = domain.to_seq();
  104|      3|            let vertices: Vec<V> = (0..seq.length()).map(|i| seq.nth(i).clone()).collect();
                              ^1        ^1       ^1                ^1                          ^1
  105|       |
  106|      1|            self.adj.delete(&v_clone);
  107|       |            // Remove v from all neighbor sets
  108|      4|            for u in vertices {
                              ^3
  109|      3|                if let Some(neighbors) = self.adj.find(&u) {
                                          ^2
  110|      2|                    let mut neighbors = neighbors.clone();
  111|      2|                    neighbors.delete(&v_clone);
  112|      2|                    self.adj.insert(u, neighbors, |_, new| new.clone());
  113|      1|                }
  114|       |            }
  115|      1|        }
  116|       |
  117|     21|        fn insert_edge(&mut self, u: V, v: V) {
  118|     21|            let neighbors = match self.adj.find(&u) {
  119|     14|                | Some(ns) => {
  120|     14|                    let mut ns = ns.clone();
  121|     14|                    ns.insert(v.clone());
  122|     14|                    ns
  123|       |                }
  124|      7|                | None => AVLTreeSetStEph::singleton(v.clone()),
  125|       |            };
  126|     21|            self.adj.insert(u, neighbors, |_, new| new.clone());
                                                                 ^14 ^14
  127|       |            // Ensure v is in vertex set
  128|     21|            if self.adj.find(&v).is_none() {
  129|     14|                self.adj.insert(v, AVLTreeSetStEph::empty(), |_, new| new.clone());
                                                                                    ^0  ^0
  130|      7|            }
  131|     21|        }
  132|       |
  133|      1|        fn delete_edge(&mut self, u: &V, v: &V) {
  134|      1|            if let Some(neighbors) = self.adj.find(u) {
  135|      1|                let mut neighbors = neighbors.clone();
  136|      1|                neighbors.delete(v);
  137|      1|                self.adj.insert(u.clone(), neighbors, |_, new| new.clone());
  138|      0|            }
  139|      1|        }
  140|       |    }
  141|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap52/AdjTableGraphStPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 52: Adjacency Table Graph representation (persistent, single-threaded).
    3|       |//! G = (V  V set) table - maps vertices to sets of their out-neighbors.
    4|       |
    5|       |pub mod AdjTableGraphStPer {
    6|       |
    7|       |    use crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::*;
    8|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::*;
    9|       |    use crate::Chap43::OrderedTableStPer::OrderedTableStPer::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    #[derive(Clone)]
   13|       |    pub struct AdjTableGraphStPer<V: StT + Ord> {
   14|       |        adj: OrderedTableStPer<V, AVLTreeSetStPer<V>>,
   15|       |    }
   16|       |
   17|       |    pub trait AdjTableGraphStPerTrait<V: StT + Ord> {
   18|       |        /// claude-4-sonet: Work (1), Span (1)
   19|       |        fn empty() -> Self;
   20|       |        /// claude-4-sonet: Work (1), Span (1)
   21|       |        fn from_table(table: OrderedTableStPer<V, AVLTreeSetStPer<V>>) -> Self;
   22|       |        /// claude-4-sonet: Work (1), Span (1)
   23|       |        fn num_vertices(&self) -> N;
   24|       |        /// claude-4-sonet: Work (|V| + |E|), Span (|V| + |E|), Parallelism (1)
   25|       |        fn num_edges(&self) -> N;
   26|       |        /// claude-4-sonet: Work (|V|), Span (|V|), Parallelism (1)
   27|       |        fn vertices(&self) -> AVLTreeSetStPer<V>;
   28|       |        /// claude-4-sonet: Work (log |V| + log |E|), Span (log |V| + log |E|), Parallelism (1)
   29|       |        fn has_edge(&self, u: &V, v: &V) -> B;
   30|       |        /// claude-4-sonet: Work (log |V|), Span (log |V|), Parallelism (1)
   31|       |        fn out_neighbors(&self, u: &V) -> AVLTreeSetStPer<V>;
   32|       |        /// claude-4-sonet: Work (log |V|), Span (log |V|), Parallelism (1)
   33|       |        fn out_degree(&self, u: &V) -> N;
   34|       |        /// claude-4-sonet: Work (log |V|), Span (log |V|), Parallelism (1)
   35|       |        fn insert_vertex(&self, v: V) -> Self;
   36|       |        /// claude-4-sonet: Work ((|V| + |E|) log |V|), Span ((|V| + |E|) log |V|), Parallelism (1)
   37|       |        fn delete_vertex(&self, v: &V) -> Self;
   38|       |        /// claude-4-sonet: Work (log |V| + log |E|), Span (log |V| + log |E|), Parallelism (1)
   39|       |        fn insert_edge(&self, u: V, v: V) -> Self;
   40|       |        /// claude-4-sonet: Work (log |V| + log |E|), Span (log |V| + log |E|), Parallelism (1)
   41|       |        fn delete_edge(&self, u: &V, v: &V) -> Self;
   42|       |    }
   43|       |
   44|       |    impl<V: StT + Ord> AdjTableGraphStPerTrait<V> for AdjTableGraphStPer<V> {
   45|     14|        fn empty() -> Self {
   46|     14|            AdjTableGraphStPer {
   47|     14|                adj: OrderedTableStPer::empty(),
   48|     14|            }
   49|     14|        }
   50|       |
   51|      1|        fn from_table(table: OrderedTableStPer<V, AVLTreeSetStPer<V>>) -> Self { AdjTableGraphStPer { adj: table } }
   52|       |
   53|       |        // Work: (1), Span: (1) - table size
   54|     12|        fn num_vertices(&self) -> N { self.adj.size() }
   55|       |
   56|       |        // Work: (n), Span: (log n) - sum all neighbor set sizes
   57|      7|        fn num_edges(&self) -> N {
   58|      7|            let domain = self.adj.domain();
   59|      7|            let seq = domain.to_seq();
   60|      7|            let mut count = 0;
   61|     14|            for i in 0..seq.length() {
                                      ^7  ^7
   62|     14|                let v = seq.nth(i);
   63|     14|                if let Some(neighbors) = self.adj.find(v) {
   64|     14|                    count += neighbors.size();
   65|     14|                }
                              ^0
   66|       |            }
   67|      7|            count
   68|      7|        }
   69|       |
   70|      5|        fn vertices(&self) -> AVLTreeSetStPer<V> {
   71|      5|            let domain_set = self.adj.domain();
   72|      5|            let seq = domain_set.to_seq();
   73|      5|            let mut vertices = AVLTreeSetStPer::empty();
   74|      8|            for i in 0..seq.length() {
                                      ^5  ^5
   75|      8|                vertices = vertices.insert(seq.nth(i).clone());
   76|      8|            }
   77|      5|            vertices
   78|      5|        }
   79|       |
   80|       |        // Work: (log n), Span: (log n) - table lookup + set membership
   81|      9|        fn has_edge(&self, u: &V, v: &V) -> B {
   82|      9|            match self.adj.find(u) {
   83|      7|                | Some(neighbors) => neighbors.find(v),
   84|      2|                | None => false,
   85|       |            }
   86|      9|        }
   87|       |
   88|       |        // Work: (log n), Span: (log n) - table lookup
   89|      9|        fn out_neighbors(&self, u: &V) -> AVLTreeSetStPer<V> {
   90|      9|            match self.adj.find(u) {
   91|      7|                | Some(neighbors) => neighbors.clone(),
   92|      2|                | None => AVLTreeSetStPer::empty(),
   93|       |            }
   94|      9|        }
   95|       |
   96|       |        // Work: (log n), Span: (log n) - lookup + size
   97|      7|        fn out_degree(&self, u: &V) -> N { self.out_neighbors(u).size() }
   98|       |
   99|       |        // Work: (log n), Span: (log n) - insert empty neighbor set
  100|      8|        fn insert_vertex(&self, v: V) -> Self {
  101|      8|            let new_adj = self.adj.insert(v, AVLTreeSetStPer::empty());
  102|      8|            AdjTableGraphStPer { adj: new_adj }
  103|      8|        }
  104|       |
  105|       |        // Work: (n log n), Span: (log n) - remove vertex and all incident edges
  106|      1|        fn delete_vertex(&self, v: &V) -> Self {
  107|      1|            let v_clone = v.clone();
  108|      1|            let new_adj = self.adj.delete(&v_clone);
  109|       |            // Remove v from all neighbor sets
  110|      1|            let domain = new_adj.domain();
  111|      1|            let seq = domain.to_seq();
  112|      1|            let mut result_adj = new_adj;
  113|      2|            for i in 0..seq.length() {
                                      ^1  ^1
  114|      2|                let u = seq.nth(i);
  115|      2|                if let Some(neighbors) = result_adj.find(u) {
  116|      2|                    let new_neighbors = neighbors.delete(&v_clone);
  117|      2|                    result_adj = result_adj.insert(u.clone(), new_neighbors);
  118|      2|                }
                              ^0
  119|       |            }
  120|      1|            AdjTableGraphStPer { adj: result_adj }
  121|      1|        }
  122|       |
  123|       |        // Work: (log n), Span: (log n) - update neighbor set
  124|     19|        fn insert_edge(&self, u: V, v: V) -> Self {
  125|     19|            let neighbors = match self.adj.find(&u) {
  126|     10|                | Some(ns) => ns.insert(v.clone()),
  127|      9|                | None => AVLTreeSetStPer::singleton(v.clone()),
  128|       |            };
  129|     19|            let new_adj = self.adj.insert(u, neighbors);
  130|       |            // Ensure v is in vertex set
  131|     19|            let final_adj = if new_adj.find(&v).is_none() {
  132|     17|                new_adj.insert(v, AVLTreeSetStPer::empty())
  133|       |            } else {
  134|      2|                new_adj
  135|       |            };
  136|     19|            AdjTableGraphStPer { adj: final_adj }
  137|     19|        }
  138|       |
  139|       |        // Work: (log n), Span: (log n)
  140|      2|        fn delete_edge(&self, u: &V, v: &V) -> Self {
  141|      2|            match self.adj.find(u) {
  142|      2|                | Some(neighbors) => {
  143|      2|                    let new_neighbors = neighbors.delete(v);
  144|      2|                    let new_adj = self.adj.insert(u.clone(), new_neighbors);
  145|      2|                    AdjTableGraphStPer { adj: new_adj }
  146|       |                }
  147|      0|                | None => self.clone(),
  148|       |            }
  149|      2|        }
  150|       |    }
  151|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap52/EdgeSetGraphMtPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 52: Edge Set Graph representation (persistent, multi-threaded with TRUE parallelism).
    3|       |//! G = (V, A:) where V is a set of vertices and A:  V  V is a set of directed arcs.
    4|       |//!
    5|       |//! Uses AVLTreeSetMtPer with Arc-based backing for PARALLEL operations.
    6|       |
    7|       |pub mod EdgeSetGraphMtPer {
    8|       |
    9|       |    use crate::Chap37::AVLTreeSeqMtPer::AVLTreeSeqMtPer::AVLTreeSeqMtPerTrait;
   10|       |    use crate::Chap41::AVLTreeSetMtPer::AVLTreeSetMtPer::*;
   11|       |    use crate::Types::Types::*;
   12|       |
   13|       |    #[derive(Clone)]
   14|       |    pub struct EdgeSetGraphMtPer<V: StTInMtT + Ord + 'static> {
   15|       |        vertices: AVLTreeSetMtPer<V>,
   16|       |        edges: AVLTreeSetMtPer<Pair<V, V>>,
   17|       |    }
   18|       |
   19|       |    pub trait EdgeSetGraphMtPerTrait<V: StTInMtT + Ord + 'static> {
   20|       |        /// claude-4-sonet: Work (1), Span (1)
   21|       |        fn empty() -> Self;
   22|       |        /// claude-4-sonet: Work (1), Span (1)
   23|       |        fn from_vertices_and_edges(v: AVLTreeSetMtPer<V>, e: AVLTreeSetMtPer<Pair<V, V>>) -> Self;
   24|       |        /// claude-4-sonet: Work (1), Span (1)
   25|       |        fn num_vertices(&self) -> N;
   26|       |        /// claude-4-sonet: Work (1), Span (1)
   27|       |        fn num_edges(&self) -> N;
   28|       |        /// claude-4-sonet: Work (1), Span (1)
   29|       |        fn vertices(&self) -> &AVLTreeSetMtPer<V>;
   30|       |        /// claude-4-sonet: Work (1), Span (1)
   31|       |        fn edges(&self) -> &AVLTreeSetMtPer<Pair<V, V>>;
   32|       |        /// claude-4-sonet: Work (log |E|), Span (log |E|), Parallelism (1)
   33|       |        fn has_edge(&self, u: &V, v: &V) -> B;
   34|       |        /// claude-4-sonet: Work (|E| log |V|), Span (log |E|  log |V|), Parallelism (|E|/log |E|)
   35|       |        fn out_neighbors(&self, u: &V) -> AVLTreeSetMtPer<V>;
   36|       |        /// claude-4-sonet: Work (|E|), Span (log |E|), Parallelism (|E|/log |E|)
   37|       |        fn out_degree(&self, u: &V) -> N;
   38|       |        /// claude-4-sonet: Work (log |V|), Span (log |V|), Parallelism (1)
   39|       |        fn insert_vertex(&self, v: V) -> Self;
   40|       |        /// claude-4-sonet: Work (|E| log |V| + |E| log |E|), Span (log |E|  log |V|), Parallelism (|E|/log |E|)
   41|       |        fn delete_vertex(&self, v: &V) -> Self;
   42|       |        /// claude-4-sonet: Work (log |V| + log |E|), Span (log |V| + log |E|), Parallelism (1)
   43|       |        fn insert_edge(&self, u: V, v: V) -> Self;
   44|       |        /// claude-4-sonet: Work (log |E|), Span (log |E|), Parallelism (1)
   45|       |        fn delete_edge(&self, u: &V, v: &V) -> Self;
   46|       |    }
   47|       |
   48|       |    impl<V: StTInMtT + Ord + 'static> EdgeSetGraphMtPerTrait<V> for EdgeSetGraphMtPer<V> {
   49|      7|        fn empty() -> Self {
   50|      7|            EdgeSetGraphMtPer {
   51|      7|                vertices: AVLTreeSetMtPer::empty(),
   52|      7|                edges: AVLTreeSetMtPer::empty(),
   53|      7|            }
   54|      7|        }
   55|       |
   56|      0|        fn from_vertices_and_edges(v: AVLTreeSetMtPer<V>, e: AVLTreeSetMtPer<Pair<V, V>>) -> Self {
   57|      0|            EdgeSetGraphMtPer { vertices: v, edges: e }
   58|      0|        }
   59|       |
   60|      4|        fn num_vertices(&self) -> N { self.vertices.size() }
   61|       |
   62|      5|        fn num_edges(&self) -> N { self.edges.size() }
   63|       |
   64|      0|        fn vertices(&self) -> &AVLTreeSetMtPer<V> { &self.vertices }
   65|       |
   66|      0|        fn edges(&self) -> &AVLTreeSetMtPer<Pair<V, V>> { &self.edges }
   67|       |
   68|       |        // Work: (log |E|), Span: (log |E|)
   69|      3|        fn has_edge(&self, u: &V, v: &V) -> B { self.edges.find(&Pair(u.clone(), v.clone())) }
   70|       |
   71|       |        // PARALLEL: Work: (|E|), Span: (log |E|) - TRUE parallel filter
   72|      3|        fn out_neighbors(&self, u: &V) -> AVLTreeSetMtPer<V> {
   73|      3|            let u_clone = u.clone();
   74|      6|            let filtered = self.edges.filter(move |edge| &edge.0 == &u_clone);
                              ^3         ^3         ^3
   75|      3|            let mut neighbors = AVLTreeSetMtPer::empty();
   76|      3|            let seq = filtered.to_seq();
   77|      4|            for i in 0..seq.length() {
                                      ^3  ^3
   78|      4|                let Pair(_, v) = seq.nth(i);
   79|      4|                neighbors = neighbors.insert(v.clone());
   80|      4|            }
   81|      3|            neighbors
   82|      3|        }
   83|       |
   84|       |        // Work: (|E|), Span: (log |E|)
   85|      2|        fn out_degree(&self, u: &V) -> N { self.out_neighbors(u).size() }
   86|       |
   87|       |        // Work: (log |V|), Span: (log |V|)
   88|     14|        fn insert_vertex(&self, v: V) -> Self {
   89|     14|            EdgeSetGraphMtPer {
   90|     14|                vertices: self.vertices.insert(v),
   91|     14|                edges: self.edges.clone(),
   92|     14|            }
   93|     14|        }
   94|       |
   95|       |        // PARALLEL: Work: (|E| log |E|), Span: (log |E|) - TRUE parallel filter
   96|      1|        fn delete_vertex(&self, v: &V) -> Self {
   97|      1|            let v_clone = v.clone();
   98|      1|            let new_vertices = self.vertices.delete(&v_clone);
   99|      1|            let v_clone2 = v_clone.clone();
  100|      1|            let new_edges = self.edges.filter(move |edge| {
  101|      1|                let Pair(u, w) = edge;
  102|      1|                u != &v_clone2 && w != &v_clone2
                                                ^0
  103|      1|            });
  104|      1|            EdgeSetGraphMtPer {
  105|      1|                vertices: new_vertices,
  106|      1|                edges: new_edges,
  107|      1|            }
  108|      1|        }
  109|       |
  110|       |        // Work: (log |V| + log |E|), Span: (log |V| + log |E|)
  111|      7|        fn insert_edge(&self, u: V, v: V) -> Self {
  112|      7|            let new_vertices = self.vertices.insert(u.clone()).insert(v.clone());
  113|      7|            let new_edges = self.edges.insert(Pair(u, v));
  114|      7|            EdgeSetGraphMtPer {
  115|      7|                vertices: new_vertices,
  116|      7|                edges: new_edges,
  117|      7|            }
  118|      7|        }
  119|       |
  120|       |        // Work: (log |E|), Span: (log |E|)
  121|      1|        fn delete_edge(&self, u: &V, v: &V) -> Self {
  122|      1|            EdgeSetGraphMtPer {
  123|      1|                vertices: self.vertices.clone(),
  124|      1|                edges: self.edges.delete(&Pair(u.clone(), v.clone())),
  125|      1|            }
  126|      1|        }
  127|       |    }
  128|       |
  129|       |    impl<V: StTInMtT + Ord + 'static> Default for EdgeSetGraphMtPer<V> {
  130|      0|        fn default() -> Self { Self::empty() }
  131|       |    }
  132|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap52/EdgeSetGraphStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 52: Edge Set Graph representation (ephemeral, single-threaded).
    3|       |
    4|       |pub mod EdgeSetGraphStEph {
    5|       |
    6|       |    use crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::AVLTreeSeqStEphTrait;
    7|       |    use crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::*;
    8|       |    use crate::Types::Types::*;
    9|       |
   10|       |    #[derive(Clone)]
   11|       |    pub struct EdgeSetGraphStEph<V: StT + Ord> {
   12|       |        vertices: AVLTreeSetStEph<V>,
   13|       |        edges: AVLTreeSetStEph<Pair<V, V>>,
   14|       |    }
   15|       |
   16|       |    pub trait EdgeSetGraphStEphTrait<V: StT + Ord> {
   17|       |        /// claude-4-sonet: Work (1), Span (1)
   18|       |        fn empty() -> Self;
   19|       |        /// claude-4-sonet: Work (1), Span (1)
   20|       |        fn from_vertices_and_edges(v: AVLTreeSetStEph<V>, e: AVLTreeSetStEph<Pair<V, V>>) -> Self;
   21|       |        /// claude-4-sonet: Work (1), Span (1)
   22|       |        fn num_vertices(&self) -> N;
   23|       |        /// claude-4-sonet: Work (1), Span (1)
   24|       |        fn num_edges(&self) -> N;
   25|       |        /// claude-4-sonet: Work (1), Span (1)
   26|       |        fn vertices(&self) -> &AVLTreeSetStEph<V>;
   27|       |        /// claude-4-sonet: Work (1), Span (1)
   28|       |        fn edges(&self) -> &AVLTreeSetStEph<Pair<V, V>>;
   29|       |        /// claude-4-sonet: Work (log |E|), Span (log |E|), Parallelism (1)
   30|       |        fn has_edge(&self, u: &V, v: &V) -> B;
   31|       |        /// claude-4-sonet: Work (|E| log |V|), Span (|E| log |V|), Parallelism (1)
   32|       |        fn out_neighbors(&self, u: &V) -> AVLTreeSetStEph<V>;
   33|       |        /// claude-4-sonet: Work (|E|), Span (|E|), Parallelism (1)
   34|       |        fn out_degree(&self, u: &V) -> N;
   35|       |        /// claude-4-sonet: Work (log |V|), Span (log |V|), Parallelism (1)
   36|       |        fn insert_vertex(&mut self, v: V);
   37|       |        /// claude-4-sonet: Work (|E| log |E|), Span (|E| log |E|), Parallelism (1)
   38|       |        fn delete_vertex(&mut self, v: &V);
   39|       |        /// claude-4-sonet: Work (log |V| + log |E|), Span (log |V| + log |E|), Parallelism (1)
   40|       |        fn insert_edge(&mut self, u: V, v: V);
   41|       |        /// claude-4-sonet: Work (log |E|), Span (log |E|), Parallelism (1)
   42|       |        fn delete_edge(&mut self, u: &V, v: &V);
   43|       |    }
   44|       |
   45|       |    impl<V: StT + Ord> EdgeSetGraphStEphTrait<V> for EdgeSetGraphStEph<V> {
   46|      7|        fn empty() -> Self {
   47|      7|            EdgeSetGraphStEph {
   48|      7|                vertices: AVLTreeSetStEph::empty(),
   49|      7|                edges: AVLTreeSetStEph::empty(),
   50|      7|            }
   51|      7|        }
   52|       |
   53|      0|        fn from_vertices_and_edges(v: AVLTreeSetStEph<V>, e: AVLTreeSetStEph<Pair<V, V>>) -> Self {
   54|      0|            EdgeSetGraphStEph { vertices: v, edges: e }
   55|      0|        }
   56|       |
   57|      4|        fn num_vertices(&self) -> N { self.vertices.size() }
   58|       |
   59|      5|        fn num_edges(&self) -> N { self.edges.size() }
   60|       |
   61|      0|        fn vertices(&self) -> &AVLTreeSetStEph<V> { &self.vertices }
   62|       |
   63|      0|        fn edges(&self) -> &AVLTreeSetStEph<Pair<V, V>> { &self.edges }
   64|       |
   65|      3|        fn has_edge(&self, u: &V, v: &V) -> B { self.edges.find(&Pair(u.clone(), v.clone())) }
   66|       |
   67|      3|        fn out_neighbors(&self, u: &V) -> AVLTreeSetStEph<V> {
   68|      3|            let u_clone = u.clone();
   69|      6|            let filtered = self.edges.filter(|edge| &edge.0 == &u_clone);
                              ^3         ^3         ^3
   70|      3|            let mut neighbors = AVLTreeSetStEph::empty();
   71|      3|            let seq = filtered.to_seq();
   72|      4|            for i in 0..seq.length() {
                                      ^3  ^3
   73|      4|                let Pair(_, v) = seq.nth(i);
   74|      4|                neighbors.insert(v.clone());
   75|      4|            }
   76|      3|            neighbors
   77|      3|        }
   78|       |
   79|      2|        fn out_degree(&self, u: &V) -> N { self.out_neighbors(u).size() }
   80|       |
   81|     14|        fn insert_vertex(&mut self, v: V) { self.vertices.insert(v); }
   82|       |
   83|      1|        fn delete_vertex(&mut self, v: &V) {
   84|      1|            let v_clone = v.clone();
   85|      1|            self.vertices.delete(&v_clone);
   86|      1|            let edges_to_remove: Vec<Pair<V, V>> = {
   87|      1|                let seq = self.edges.to_seq();
   88|      1|                let mut to_remove = Vec::new();
   89|      1|                for i in 0..seq.length() {
   90|      1|                    let edge = seq.nth(i);
   91|      1|                    let Pair(u, w) = edge;
   92|      1|                    if u == &v_clone || w == &v_clone {
                                                      ^0
   93|      1|                        to_remove.push(edge.clone());
   94|      1|                    }
                                  ^0
   95|       |                }
   96|      1|                to_remove
   97|       |            };
   98|      2|            for edge in edges_to_remove {
                              ^1
   99|      1|                self.edges.delete(&edge);
  100|      1|            }
  101|      1|        }
  102|       |
  103|      7|        fn insert_edge(&mut self, u: V, v: V) {
  104|      7|            self.vertices.insert(u.clone());
  105|      7|            self.vertices.insert(v.clone());
  106|      7|            self.edges.insert(Pair(u, v));
  107|      7|        }
  108|       |
  109|      1|        fn delete_edge(&mut self, u: &V, v: &V) { self.edges.delete(&Pair(u.clone(), v.clone())); }
  110|       |    }
  111|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap52/EdgeSetGraphStPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 52: Edge Set Graph representation (persistent, single-threaded).
    3|       |//! G = (V, E) where V is a set of vertices and E  V  V is a set of edges.
    4|       |
    5|       |pub mod EdgeSetGraphStPer {
    6|       |
    7|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::AVLTreeSeqStPerTrait;
    8|       |    use crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::*;
    9|       |    use crate::Types::Types::*;
   10|       |
   11|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   12|       |    pub struct EdgeSetGraphStPer<V: StT + Ord> {
   13|       |        vertices: AVLTreeSetStPer<V>,
   14|       |        edges: AVLTreeSetStPer<Pair<V, V>>,
   15|       |    }
   16|       |
   17|       |    pub trait EdgeSetGraphStPerTrait<V: StT + Ord> {
   18|       |        /// claude-4-sonet: Work (1), Span (1)
   19|       |        fn empty() -> Self;
   20|       |        /// claude-4-sonet: Work (1), Span (1)
   21|       |        fn from_vertices_and_edges(v: AVLTreeSetStPer<V>, e: AVLTreeSetStPer<Pair<V, V>>) -> Self;
   22|       |        /// claude-4-sonet: Work (1), Span (1)
   23|       |        fn num_vertices(&self) -> N;
   24|       |        /// claude-4-sonet: Work (1), Span (1)
   25|       |        fn num_edges(&self) -> N;
   26|       |        /// claude-4-sonet: Work (1), Span (1)
   27|       |        fn vertices(&self) -> &AVLTreeSetStPer<V>;
   28|       |        /// claude-4-sonet: Work (1), Span (1)
   29|       |        fn edges(&self) -> &AVLTreeSetStPer<Pair<V, V>>;
   30|       |        /// claude-4-sonet: Work (log |E|), Span (log |E|), Parallelism (1)
   31|       |        fn has_edge(&self, u: &V, v: &V) -> B;
   32|       |        /// claude-4-sonet: Work (|E| log |V|), Span (|E| log |V|), Parallelism (1)
   33|       |        fn out_neighbors(&self, u: &V) -> AVLTreeSetStPer<V>;
   34|       |        /// claude-4-sonet: Work (|E|), Span (|E|), Parallelism (1)
   35|       |        fn out_degree(&self, u: &V) -> N;
   36|       |        /// claude-4-sonet: Work (log |V|), Span (log |V|), Parallelism (1)
   37|       |        fn insert_vertex(&self, v: V) -> Self;
   38|       |        /// claude-4-sonet: Work (|E| log |E|), Span (|E| log |E|), Parallelism (1)
   39|       |        fn delete_vertex(&self, v: &V) -> Self;
   40|       |        /// claude-4-sonet: Work (log |V| + log |E|), Span (log |V| + log |E|), Parallelism (1)
   41|       |        fn insert_edge(&self, u: V, v: V) -> Self;
   42|       |        /// claude-4-sonet: Work (log |E|), Span (log |E|), Parallelism (1)
   43|       |        fn delete_edge(&self, u: &V, v: &V) -> Self;
   44|       |    }
   45|       |
   46|       |    impl<V: StT + Ord> EdgeSetGraphStPerTrait<V> for EdgeSetGraphStPer<V> {
   47|      7|        fn empty() -> Self {
   48|      7|            EdgeSetGraphStPer {
   49|      7|                vertices: AVLTreeSetStPer::empty(),
   50|      7|                edges: AVLTreeSetStPer::empty(),
   51|      7|            }
   52|      7|        }
   53|       |
   54|      0|        fn from_vertices_and_edges(v: AVLTreeSetStPer<V>, e: AVLTreeSetStPer<Pair<V, V>>) -> Self {
   55|      0|            EdgeSetGraphStPer { vertices: v, edges: e }
   56|      0|        }
   57|       |
   58|      5|        fn num_vertices(&self) -> N { self.vertices.size() }
   59|       |
   60|      7|        fn num_edges(&self) -> N { self.edges.size() }
   61|       |
   62|      0|        fn vertices(&self) -> &AVLTreeSetStPer<V> { &self.vertices }
   63|       |
   64|      0|        fn edges(&self) -> &AVLTreeSetStPer<Pair<V, V>> { &self.edges }
   65|       |
   66|       |        // Work: (log |E|), Span: (log |E|)
   67|      7|        fn has_edge(&self, u: &V, v: &V) -> B { self.edges.find(&Pair(u.clone(), v.clone())) }
   68|       |
   69|       |        // Work: (|E|), Span: (log |E|) - filter over all edges
   70|      3|        fn out_neighbors(&self, u: &V) -> AVLTreeSetStPer<V> {
   71|      3|            let u_clone = u.clone();
   72|      7|            let filtered = self.edges.filter(|edge| &edge.0 == &u_clone);
                              ^3         ^3         ^3
   73|      3|            let mut neighbors = AVLTreeSetStPer::empty();
   74|      3|            let seq = filtered.to_seq();
   75|      4|            for i in 0..seq.length() {
                                      ^3  ^3
   76|      4|                let Pair(_, v) = seq.nth(i);
   77|      4|                neighbors = neighbors.insert(v.clone());
   78|      4|            }
   79|      3|            neighbors
   80|      3|        }
   81|       |
   82|       |        // Work: (|E|), Span: (log |E|)
   83|      2|        fn out_degree(&self, u: &V) -> N { self.out_neighbors(u).size() }
   84|       |
   85|       |        // Work: (log |V|), Span: (log |V|)
   86|      2|        fn insert_vertex(&self, v: V) -> Self {
   87|      2|            EdgeSetGraphStPer {
   88|      2|                vertices: self.vertices.insert(v),
   89|      2|                edges: self.edges.clone(),
   90|      2|            }
   91|      2|        }
   92|       |
   93|       |        // Work: (|E| log |E|), Span: (log |E|) - must remove all incident edges
   94|      1|        fn delete_vertex(&self, v: &V) -> Self {
   95|      1|            let v_clone = v.clone();
   96|      1|            let new_vertices = self.vertices.delete(&v_clone);
   97|      3|            let new_edges = self.edges.filter(|edge| {
                              ^1          ^1         ^1
   98|      3|                let Pair(u, w) = edge;
   99|      3|                u != &v_clone && w != &v_clone
                                               ^2
  100|      3|            });
  101|      1|            EdgeSetGraphStPer {
  102|      1|                vertices: new_vertices,
  103|      1|                edges: new_edges,
  104|      1|            }
  105|      1|        }
  106|       |
  107|       |        // Work: (log |V| + log |E|), Span: (log |V| + log |E|)
  108|     11|        fn insert_edge(&self, u: V, v: V) -> Self {
  109|     11|            let new_vertices = self.vertices.insert(u.clone()).insert(v.clone());
  110|     11|            let new_edges = self.edges.insert(Pair(u, v));
  111|     11|            EdgeSetGraphStPer {
  112|     11|                vertices: new_vertices,
  113|     11|                edges: new_edges,
  114|     11|            }
  115|     11|        }
  116|       |
  117|       |        // Work: (log |E|), Span: (log |E|)
  118|      1|        fn delete_edge(&self, u: &V, v: &V) -> Self {
  119|      1|            let new_edges = self.edges.delete(&Pair(u.clone(), v.clone()));
  120|      1|            EdgeSetGraphStPer {
  121|      1|                vertices: self.vertices.clone(),
  122|      1|                edges: new_edges,
  123|      1|            }
  124|      1|        }
  125|       |    }
  126|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap53/GraphSearchMtPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 53: Generic Graph Search (persistent, multi-threaded).
    3|       |//!
    4|       |//! Note: This is a SEQUENTIAL implementation using thread-safe types.
    5|       |//! True parallelism would require more complex lifetime management for the graph closure.
    6|       |//! The parallel algorithm concept is demonstrated via use of AVLTreeSetMtPer which has
    7|       |//! true parallel operations (filter, union, intersection).
    8|       |
    9|       |pub mod GraphSearchMtPer {
   10|       |
   11|       |    use crate::Chap37::AVLTreeSeqMtPer::AVLTreeSeqMtPer::AVLTreeSeqMtPerTrait;
   12|       |    use crate::Chap41::AVLTreeSetMtPer::AVLTreeSetMtPer::*;
   13|       |    use crate::Types::Types::*;
   14|       |
   15|       |    #[derive(Clone, Debug)]
   16|       |    pub struct SearchResult<V: StTInMtT + Ord + 'static> {
   17|       |        pub visited: AVLTreeSetMtPer<V>,
   18|       |        pub parent: Option<AVLTreeSetMtPer<Pair<V, V>>>,
   19|       |    }
   20|       |
   21|       |    pub trait SelectionStrategy<V: StTInMtT + Ord + 'static> {
   22|       |        fn select(&self, frontier: &AVLTreeSetMtPer<V>) -> (AVLTreeSetMtPer<V>, B);
   23|       |    }
   24|       |
   25|       |    pub struct SelectAll;
   26|       |    impl<V: StTInMtT + Ord + 'static> SelectionStrategy<V> for SelectAll {
   27|     11|        fn select(&self, frontier: &AVLTreeSetMtPer<V>) -> (AVLTreeSetMtPer<V>, B) { (frontier.clone(), false) }
   28|       |    }
   29|       |
   30|       |    pub struct SelectOne;
   31|       |    impl<V: StTInMtT + Ord + 'static> SelectionStrategy<V> for SelectOne {
   32|      2|        fn select(&self, frontier: &AVLTreeSetMtPer<V>) -> (AVLTreeSetMtPer<V>, B) {
   33|      2|            if frontier.size() == 0 {
   34|      0|                (AVLTreeSetMtPer::empty(), false)
   35|       |            } else {
   36|      2|                let seq = frontier.to_seq();
   37|      2|                let first = seq.nth(0).clone();
   38|      2|                (AVLTreeSetMtPer::singleton(first), false)
   39|       |            }
   40|      2|        }
   41|       |    }
   42|       |
   43|       |    pub trait GraphSearchMtPerTrait<V: StTInMtT + Ord + 'static> {
   44|       |        /// claude-4-sonet: Work (|V| + |E|), Span (|V|  log |V|), Parallelism (|E|/|V|)
   45|       |        /// Graph search using thread-safe persistent sets with parallel set operations.
   46|       |        fn graph_search<G, S>(graph: &G, source: V, strategy: &S) -> SearchResult<V>
   47|       |        where
   48|       |            G: Fn(&V) -> AVLTreeSetMtPer<V>,
   49|       |            S: SelectionStrategy<V>;
   50|       |
   51|       |        fn graph_search_multi<G, S>(graph: &G, sources: AVLTreeSetMtPer<V>, strategy: &S) -> SearchResult<V>
   52|       |        where
   53|       |            G: Fn(&V) -> AVLTreeSetMtPer<V>,
   54|       |            S: SelectionStrategy<V>;
   55|       |
   56|       |        fn reachable<G>(graph: &G, source: V) -> AVLTreeSetMtPer<V>
   57|       |        where
   58|       |            G: Fn(&V) -> AVLTreeSetMtPer<V>;
   59|       |    }
   60|       |
   61|       |    /// Generic graph search starting from single source.
   62|       |    /// claude-4-sonet: Work (|V| + |E|), Span (|V|  log |V|), Parallelism (|E|/|V|)
   63|       |    /// Graph search using thread-safe persistent sets with parallel set operations.
   64|      6|    pub fn graph_search<V: StTInMtT + Ord + 'static, G, S>(graph: &G, source: V, strategy: &S) -> SearchResult<V>
   65|      6|    where
   66|      6|        G: Fn(&V) -> AVLTreeSetMtPer<V>,
   67|      6|        S: SelectionStrategy<V>,
   68|       |    {
   69|      6|        let sources = AVLTreeSetMtPer::singleton(source);
   70|      6|        graph_search_multi(graph, sources, strategy)
   71|      6|    }
   72|       |
   73|       |    /// Generic graph search starting from multiple sources.
   74|       |    /// claude-4-sonet: Work (|V| + |E|), Span (|V|  log |V|), Parallelism (|E|/|V|)
   75|      7|    pub fn graph_search_multi<V: StTInMtT + Ord + 'static, G, S>(graph: &G, sources: AVLTreeSetMtPer<V>, strategy: &S) -> SearchResult<V>
   76|      7|    where
   77|      7|        G: Fn(&V) -> AVLTreeSetMtPer<V>,
   78|      7|        S: SelectionStrategy<V>,
   79|       |    {
   80|     20|        fn explore<V, G, S>(
   81|     20|            graph: &G,
   82|     20|            strategy: &S,
   83|     20|            visited: AVLTreeSetMtPer<V>,
   84|     20|            frontier: AVLTreeSetMtPer<V>,
   85|     20|        ) -> AVLTreeSetMtPer<V>
   86|     20|        where
   87|     20|            V: StTInMtT + Ord + 'static,
   88|     20|            G: Fn(&V) -> AVLTreeSetMtPer<V>,
   89|     20|            S: SelectionStrategy<V>,
   90|       |        {
   91|     20|            if frontier.size() == 0 {
   92|      7|                return visited;
   93|     13|            }
   94|       |
   95|     13|            let (selected, _) = strategy.select(&frontier);
   96|       |            // Parallel union via AVLTreeSetMtPer's parallel implementation
   97|     13|            let visited_new = visited.union(&selected);
   98|       |
   99|       |            // Compute out-neighbors (sequential loop, but union is parallel)
  100|     13|            let mut new_neighbors = AVLTreeSetMtPer::empty();
  101|     13|            let selected_seq = selected.to_seq();
  102|     14|            for i in 0..selected_seq.length() {
                                      ^13          ^13
  103|     14|                let v = selected_seq.nth(i);
  104|     14|                let neighbors = graph(v);
  105|     14|                // Parallel union operation
  106|     14|                new_neighbors = new_neighbors.union(&neighbors);
  107|     14|            }
  108|       |
  109|       |            // Parallel difference operation
  110|     13|            let frontier_new = new_neighbors.difference(&visited_new);
  111|     13|            explore(graph, strategy, visited_new, frontier_new)
  112|     20|        }
  113|       |
  114|      7|        let visited = explore(graph, strategy, AVLTreeSetMtPer::empty(), sources);
  115|       |
  116|      7|        SearchResult { visited, parent: None }
  117|      7|    }
  118|       |
  119|       |    /// Find all vertices reachable from source using breadth-first search.
  120|       |    /// claude-4-sonet: Work (|V| + |E|), Span (|V|  log |V|), Parallelism (|E|/|V|)
  121|      4|    pub fn reachable<V: StTInMtT + Ord + 'static, G>(graph: &G, source: V) -> AVLTreeSetMtPer<V>
  122|      4|    where
  123|      4|        G: Fn(&V) -> AVLTreeSetMtPer<V>,
  124|       |    {
  125|      4|        let result = graph_search(graph, source, &SelectAll);
  126|      4|        result.visited
  127|      4|    }
  128|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap53/GraphSearchStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 53: Generic Graph Search (ephemeral, single-threaded).
    3|       |
    4|       |pub mod GraphSearchStEph {
    5|       |
    6|       |    use crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::AVLTreeSeqStEphTrait;
    7|       |    use crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::*;
    8|       |    use crate::Types::Types::*;
    9|       |
   10|       |    #[derive(Clone, Debug)]
   11|       |    pub struct SearchResult<V: StT + Ord> {
   12|       |        pub visited: AVLTreeSetStEph<V>,
   13|       |        pub parent: Option<AVLTreeSetStEph<Pair<V, V>>>,
   14|       |    }
   15|       |
   16|       |    pub trait SelectionStrategy<V: StT + Ord> {
   17|       |        fn select(&self, frontier: &AVLTreeSetStEph<V>) -> (AVLTreeSetStEph<V>, B);
   18|       |    }
   19|       |
   20|       |    pub struct SelectAll;
   21|       |    impl<V: StT + Ord> SelectionStrategy<V> for SelectAll {
   22|     11|        fn select(&self, frontier: &AVLTreeSetStEph<V>) -> (AVLTreeSetStEph<V>, B) { (frontier.clone(), false) }
   23|       |    }
   24|       |
   25|       |    pub struct SelectOne;
   26|       |    impl<V: StT + Ord> SelectionStrategy<V> for SelectOne {
   27|      2|        fn select(&self, frontier: &AVLTreeSetStEph<V>) -> (AVLTreeSetStEph<V>, B) {
   28|      2|            if frontier.size() == 0 {
   29|      0|                (AVLTreeSetStEph::empty(), false)
   30|       |            } else {
   31|      2|                let seq = frontier.to_seq();
   32|      2|                let first = seq.nth(0).clone();
   33|      2|                (AVLTreeSetStEph::singleton(first), false)
   34|       |            }
   35|      2|        }
   36|       |    }
   37|       |
   38|       |    pub trait GraphSearchStEphTrait<V: StT + Ord> {
   39|       |        /// claude-4-sonet: Work (|V| + |E|), Span (|V|), Parallelism (1)
   40|       |        fn graph_search<G, S>(graph: &G, source: V, strategy: &S) -> SearchResult<V>
   41|       |        where
   42|       |            G: Fn(&V) -> AVLTreeSetStEph<V>,
   43|       |            S: SelectionStrategy<V>;
   44|       |
   45|       |        /// claude-4-sonet: Work (|V| + |E|), Span (|V|), Parallelism (1)
   46|       |        fn graph_search_multi<G, S>(graph: &G, sources: AVLTreeSetStEph<V>, strategy: &S) -> SearchResult<V>
   47|       |        where
   48|       |            G: Fn(&V) -> AVLTreeSetStEph<V>,
   49|       |            S: SelectionStrategy<V>;
   50|       |
   51|       |        /// claude-4-sonet: Work (|V| + |E|), Span (|V|), Parallelism (1)
   52|       |        fn reachable<G>(graph: &G, source: V) -> AVLTreeSetStEph<V>
   53|       |        where
   54|       |            G: Fn(&V) -> AVLTreeSetStEph<V>;
   55|       |    }
   56|       |
   57|       |    /// Generic graph search starting from single source.
   58|       |    /// claude-4-sonet: Work (|V| + |E|), Span (|V|), Parallelism (1)
   59|      6|    pub fn graph_search<V: StT + Ord, G, S>(graph: &G, source: V, strategy: &S) -> SearchResult<V>
   60|      6|    where
   61|      6|        G: Fn(&V) -> AVLTreeSetStEph<V>,
   62|      6|        S: SelectionStrategy<V>,
   63|       |    {
   64|      6|        let sources = AVLTreeSetStEph::singleton(source);
   65|      6|        graph_search_multi(graph, sources, strategy)
   66|      6|    }
   67|       |
   68|       |    /// Generic graph search starting from multiple sources.
   69|       |    /// claude-4-sonet: Work (|V| + |E|), Span (|V|), Parallelism (1)
   70|      7|    pub fn graph_search_multi<V: StT + Ord, G, S>(graph: &G, sources: AVLTreeSetStEph<V>, strategy: &S) -> SearchResult<V>
   71|      7|    where
   72|      7|        G: Fn(&V) -> AVLTreeSetStEph<V>,
   73|      7|        S: SelectionStrategy<V>,
   74|       |    {
   75|     20|        fn explore<V, G, S>(
   76|     20|            graph: &G,
   77|     20|            strategy: &S,
   78|     20|            visited: AVLTreeSetStEph<V>,
   79|     20|            frontier: AVLTreeSetStEph<V>,
   80|     20|        ) -> AVLTreeSetStEph<V>
   81|     20|        where
   82|     20|            V: StT + Ord,
   83|     20|            G: Fn(&V) -> AVLTreeSetStEph<V>,
   84|     20|            S: SelectionStrategy<V>,
   85|       |        {
   86|     20|            if frontier.size() == 0 {
   87|      7|                return visited;
   88|     13|            }
   89|       |
   90|     13|            let (selected, _) = strategy.select(&frontier);
   91|     13|            let visited_new = visited.union(&selected);
   92|       |
   93|     13|            let mut new_neighbors = AVLTreeSetStEph::empty();
   94|     13|            let selected_seq = selected.to_seq();
   95|     14|            for i in 0..selected_seq.length() {
                                      ^13          ^13
   96|     14|                let v = selected_seq.nth(i);
   97|     14|                let neighbors = graph(v);
   98|     14|                new_neighbors = new_neighbors.union(&neighbors);
   99|     14|            }
  100|       |
  101|     13|            let frontier_new = new_neighbors.difference(&visited_new);
  102|     13|            explore(graph, strategy, visited_new, frontier_new)
  103|     20|        }
  104|       |
  105|      7|        let visited = explore(graph, strategy, AVLTreeSetStEph::empty(), sources);
  106|       |
  107|      7|        SearchResult { visited, parent: None }
  108|      7|    }
  109|       |
  110|       |    /// Find all vertices reachable from source using breadth-first search.
  111|       |    /// claude-4-sonet: Work (|V| + |E|), Span (|V|), Parallelism (1)
  112|      4|    pub fn reachable<V: StT + Ord, G>(graph: &G, source: V) -> AVLTreeSetStEph<V>
  113|      4|    where
  114|      4|        G: Fn(&V) -> AVLTreeSetStEph<V>,
  115|       |    {
  116|      4|        let result = graph_search(graph, source, &SelectAll);
  117|      4|        result.visited
  118|      4|    }
  119|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap53/GraphSearchStPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 53: Generic Graph Search (persistent, single-threaded).
    3|       |//!
    4|       |//! Implements Algorithm 53.4 - Generic Graph Search with pluggable frontier selection.
    5|       |
    6|       |pub mod GraphSearchStPer {
    7|       |
    8|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::AVLTreeSeqStPerTrait;
    9|       |    use crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    #[derive(Clone, Debug)]
   13|       |    pub struct SearchResult<V: StT + Ord> {
   14|       |        pub visited: AVLTreeSetStPer<V>,
   15|       |        pub parent: Option<AVLTreeSetStPer<Pair<V, V>>>, // (child, parent) edges
   16|       |    }
   17|       |
   18|       |    /// Strategy for selecting which frontier vertices to visit next.
   19|       |    pub trait SelectionStrategy<V: StT + Ord> {
   20|       |        /// Select subset U  F where |U|  1.
   21|       |        /// Returns (selected vertices, should_track_parents).
   22|       |        fn select(&self, frontier: &AVLTreeSetStPer<V>) -> (AVLTreeSetStPer<V>, B);
   23|       |    }
   24|       |
   25|       |    /// Select all vertices in frontier (breadth-first style).
   26|       |    pub struct SelectAll;
   27|       |
   28|       |    impl<V: StT + Ord> SelectionStrategy<V> for SelectAll {
   29|     20|        fn select(&self, frontier: &AVLTreeSetStPer<V>) -> (AVLTreeSetStPer<V>, B) { (frontier.clone(), false) }
   30|       |    }
   31|       |
   32|       |    /// Select single arbitrary vertex (depth-first style).
   33|       |    pub struct SelectOne;
   34|       |
   35|       |    impl<V: StT + Ord> SelectionStrategy<V> for SelectOne {
   36|      3|        fn select(&self, frontier: &AVLTreeSetStPer<V>) -> (AVLTreeSetStPer<V>, B) {
   37|      3|            if frontier.size() == 0 {
   38|      0|                (AVLTreeSetStPer::empty(), false)
   39|       |            } else {
   40|      3|                let seq = frontier.to_seq();
   41|      3|                let first = seq.nth(0).clone();
   42|      3|                (AVLTreeSetStPer::singleton(first), false)
   43|       |            }
   44|      3|        }
   45|       |    }
   46|       |
   47|       |    pub trait GraphSearchStPerTrait<V: StT + Ord> {
   48|       |        /// claude-4-sonet: Work (|V| + |E|), Span (|V|), Parallelism (1)
   49|       |        /// Generic graph search starting from single source.
   50|       |        fn graph_search<G, S>(graph: &G, source: V, strategy: &S) -> SearchResult<V>
   51|       |        where
   52|       |            G: Fn(&V) -> AVLTreeSetStPer<V>,
   53|       |            S: SelectionStrategy<V>;
   54|       |
   55|       |        /// Multi-source graph search (Exercise 53.3).
   56|       |        /// Work: O(|V| + |E|), Span: O(|V|) (sequential rounds).
   57|       |        fn graph_search_multi<G, S>(graph: &G, sources: AVLTreeSetStPer<V>, strategy: &S) -> SearchResult<V>
   58|       |        where
   59|       |            G: Fn(&V) -> AVLTreeSetStPer<V>,
   60|       |            S: SelectionStrategy<V>;
   61|       |
   62|       |        /// Reachability: find all vertices reachable from source.
   63|       |        /// Work: O(|V| + |E|), Span: O(|V|).
   64|       |        fn reachable<G>(graph: &G, source: V) -> AVLTreeSetStPer<V>
   65|       |        where
   66|       |            G: Fn(&V) -> AVLTreeSetStPer<V>;
   67|       |    }
   68|       |
   69|       |    /// Generic graph search starting from single source.
   70|       |    /// claude-4-sonet: Work (|V| + |E|), Span (|V|), Parallelism (1)
   71|      8|    pub fn graph_search<V: StT + Ord, G, S>(graph: &G, source: V, strategy: &S) -> SearchResult<V>
   72|      8|    where
   73|      8|        G: Fn(&V) -> AVLTreeSetStPer<V>,
   74|      8|        S: SelectionStrategy<V>,
   75|       |    {
   76|      8|        let sources = AVLTreeSetStPer::singleton(source);
   77|      8|        graph_search_multi(graph, sources, strategy)
   78|      8|    }
   79|       |
   80|       |    /// Generic graph search starting from multiple sources.
   81|       |    /// claude-4-sonet: Work (|V| + |E|), Span (|V|), Parallelism (1)
   82|      9|    pub fn graph_search_multi<V: StT + Ord, G, S>(graph: &G, sources: AVLTreeSetStPer<V>, strategy: &S) -> SearchResult<V>
   83|      9|    where
   84|      9|        G: Fn(&V) -> AVLTreeSetStPer<V>,
   85|      9|        S: SelectionStrategy<V>,
   86|       |    {
   87|       |            // Algorithm 53.4: Generic Graph Search
   88|     32|            fn explore<V, G, S>(
   89|     32|                graph: &G,
   90|     32|                strategy: &S,
   91|     32|                visited: AVLTreeSetStPer<V>,
   92|     32|                frontier: AVLTreeSetStPer<V>,
   93|     32|            ) -> AVLTreeSetStPer<V>
   94|     32|            where
   95|     32|                V: StT + Ord,
   96|     32|                G: Fn(&V) -> AVLTreeSetStPer<V>,
   97|     32|                S: SelectionStrategy<V>,
   98|       |            {
   99|       |                // Line 4: if |F| = 0 then X
  100|     32|                if frontier.size() == 0 {
  101|      9|                    return visited;
  102|     23|                }
  103|       |
  104|       |                // Line 7: choose U  F such that |U|  1
  105|     23|                let (selected, _) = strategy.select(&frontier);
  106|       |
  107|       |                // Line 9: X' = X  U
  108|     23|                let visited_new = visited.union(&selected);
  109|       |
  110|       |                // Line 10: F' = N+(X') \ X'
  111|       |                // Compute out-neighbors of all newly visited vertices
  112|     23|                let mut new_neighbors = AVLTreeSetStPer::empty();
  113|     23|                let selected_seq = selected.to_seq();
  114|     28|                for i in 0..selected_seq.length() {
                                          ^23          ^23
  115|     28|                    let v = selected_seq.nth(i);
  116|     28|                    let neighbors = graph(v);
  117|     28|                    new_neighbors = new_neighbors.union(&neighbors);
  118|     28|                }
  119|       |
  120|       |                // Remove already visited vertices
  121|     23|                let frontier_new = new_neighbors.difference(&visited_new);
  122|       |
  123|       |                // Line 11: explore X' F'
  124|     23|                explore(graph, strategy, visited_new, frontier_new)
  125|     32|            }
  126|       |
  127|       |            // Line 13: explore {} {s}
  128|      9|            let visited = explore(graph, strategy, AVLTreeSetStPer::empty(), sources);
  129|       |
  130|      9|            SearchResult { visited, parent: None }
  131|      9|        }
  132|       |
  133|       |    /// Find all vertices reachable from source using breadth-first search.
  134|       |    /// claude-4-sonet: Work (|V| + |E|), Span (|V|), Parallelism (1)
  135|      1|    pub fn reachable<V: StT + Ord, G>(graph: &G, source: V) -> AVLTreeSetStPer<V>
  136|      1|    where
  137|      1|        G: Fn(&V) -> AVLTreeSetStPer<V>,
  138|       |    {
  139|      1|        let result = graph_search(graph, source, &SelectAll);
  140|      1|        result.visited
  141|      1|    }
  142|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap53/PQMinMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 53: Min-Priority Queue Search - ephemeral, multi-threaded.
    3|       |//!
    4|       |//! Note: This uses AVLTreeSetMtEph which wraps mutable state with Arc<Mutex<...>>.
    5|       |//! Priority selection is sequential, but set operations benefit from thread-safe structures.
    6|       |
    7|       |pub mod PQMinMtEph {
    8|       |
    9|       |    use crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::AVLTreeSeqStEphTrait;
   10|       |    use crate::Chap41::AVLTreeSetMtEph::AVLTreeSetMtEph::*;
   11|       |    use crate::Types::Types::*;
   12|       |
   13|       |    #[derive(Clone, Debug)]
   14|       |    pub struct PQMinResult<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static> {
   15|       |        pub visited: AVLTreeSetMtEph<V>,
   16|       |        pub priorities: AVLTreeSetMtEph<Pair<V, P>>,
   17|       |        pub parent: Option<AVLTreeSetMtEph<Pair<V, V>>>,
   18|       |    }
   19|       |
   20|       |    /// Priority function: maps vertices to their priorities.
   21|       |    /// Lower priority values = higher priority (visited first).
   22|       |    pub trait PriorityFn<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static>: Send + Sync + 'static {
   23|       |        fn priority(&self, v: &V) -> P;
   24|       |    }
   25|       |
   26|       |    /// Simple wrapper for closure-based priority functions.
   27|       |    pub struct ClosurePriority<
   28|       |        V: StTInMtT + Ord + 'static,
   29|       |        P: StTInMtT + Ord + 'static,
   30|       |        F: Fn(&V) -> P + Send + Sync + 'static,
   31|       |    > {
   32|       |        f: F,
   33|       |        _phantom: std::marker::PhantomData<(V, P)>,
   34|       |    }
   35|       |
   36|       |    impl<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static, F: Fn(&V) -> P + Send + Sync + 'static>
   37|       |        ClosurePriority<V, P, F>
   38|       |    {
   39|      7|        pub fn new(f: F) -> Self {
   40|      7|            Self {
   41|      7|                f,
   42|      7|                _phantom: std::marker::PhantomData,
   43|      7|            }
   44|      7|        }
   45|       |    }
   46|       |
   47|       |    impl<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static, F: Fn(&V) -> P + Send + Sync + 'static>
   48|       |        PriorityFn<V, P> for ClosurePriority<V, P, F>
   49|       |    {
   50|     70|        fn priority(&self, v: &V) -> P { (self.f)(v) }
   51|       |    }
   52|       |
   53|       |    pub trait PQMinMtEphTrait<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static> {
   54|       |        /// Min-Priority Queue Search from a single source.
   55|       |        /// claude-4-sonet: Work ((|V| + |E|) log |V|), Span (|V| log |V|), Parallelism (1)
   56|       |        /// Work: O((|V| + |E|) log |V|), Span: O(|V| log |V|) sequential rounds.
   57|       |        /// Set operations use thread-safe structures.
   58|       |        fn pq_min<G, PF>(graph: G, source: V, priority_fn: PF) -> PQMinResult<V, P>
   59|       |        where
   60|       |            G: Fn(&V) -> AVLTreeSetMtEph<V> + Send + Sync + 'static,
   61|       |            PF: PriorityFn<V, P>;
   62|       |
   63|       |        /// Min-Priority Queue Search from multiple sources.
   64|       |        fn pq_min_multi<G, PF>(graph: G, sources: AVLTreeSetMtEph<V>, priority_fn: PF) -> PQMinResult<V, P>
   65|       |        where
   66|       |            G: Fn(&V) -> AVLTreeSetMtEph<V> + Send + Sync + 'static,
   67|       |            PF: PriorityFn<V, P>;
   68|       |    }
   69|       |
   70|       |    /// Priority queue minimum search starting from single source.
   71|       |    /// claude-4-sonet: Work (|V| log |V| + |E|), Span (|V| log |V|), Parallelism (1)
   72|      6|    pub fn pq_min<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static, G, PF>(graph: G, source: V, priority_fn: PF) -> PQMinResult<V, P>
   73|      6|    where
   74|      6|        G: Fn(&V) -> AVLTreeSetMtEph<V> + Send + Sync + 'static,
   75|      6|        PF: PriorityFn<V, P>,
   76|       |    {
   77|      6|        let sources = AVLTreeSetMtEph::singleton(source);
   78|      6|        pq_min_multi(graph, sources, priority_fn)
   79|      6|    }
   80|       |
   81|       |    /// Priority queue minimum search starting from multiple sources.
   82|       |    /// claude-4-sonet: Work (|V| log |V| + |E|), Span (|V| log |V|), Parallelism (1)
   83|      7|    pub fn pq_min_multi<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static, G, PF>(graph: G, sources: AVLTreeSetMtEph<V>, priority_fn: PF) -> PQMinResult<V, P>
   84|      7|    where
   85|      7|        G: Fn(&V) -> AVLTreeSetMtEph<V> + Send + Sync + 'static,
   86|      7|        PF: PriorityFn<V, P>,
   87|       |    {
   88|       |            // Helper: find minimum priority vertex in frontier
   89|     30|            fn find_min_priority<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static>(
   90|     30|                frontier: &AVLTreeSetMtEph<Pair<Pair<P, V>, V>>,
   91|     30|            ) -> Option<V> {
   92|     30|                if frontier.size() == 0 {
   93|      7|                    None
   94|       |                } else {
   95|     23|                    let seq = frontier.to_seq();
   96|     23|                    Some(seq.nth(0).1.clone())
   97|       |                }
   98|     30|            }
   99|       |
  100|      7|            let mut visited = AVLTreeSetMtEph::empty();
  101|       |
  102|       |            // Initialize frontier with sources
  103|      7|            let mut frontier = AVLTreeSetMtEph::empty();
  104|      7|            let sources_seq = sources.to_seq();
  105|      8|            for i in 0..sources_seq.length() {
                                      ^7          ^7
  106|      8|                let v = sources_seq.nth(i);
  107|      8|                let p = priority_fn.priority(v);
  108|      8|                let entry = Pair(Pair(p.clone(), v.clone()), v.clone());
  109|      8|                frontier.insert(entry);
  110|      8|            }
  111|       |
  112|       |            // Main search loop
  113|     30|            while let Some(v) = find_min_priority(&frontier) {
                                         ^23
  114|       |                // Remove selected vertex from frontier
  115|     23|                let p = priority_fn.priority(&v);
  116|     23|                let entry = Pair(Pair(p.clone(), v.clone()), v.clone());
  117|     23|                frontier.delete(&entry);
  118|       |
  119|       |                // Add to visited
  120|     23|                visited.insert(v.clone());
  121|       |
  122|       |                // Get neighbors and add unvisited ones to frontier
  123|     23|                let neighbors = graph(&v);
  124|     23|                let neighbors_seq = neighbors.to_seq();
  125|       |
  126|     23|                for i in 0..neighbors_seq.length() {
                                  ^17
  127|     17|                    let neighbor = neighbors_seq.nth(i);
  128|     17|                    if !visited.find(neighbor) {
  129|     16|                        let neighbor_p = priority_fn.priority(neighbor);
  130|     16|                        let neighbor_entry = Pair(Pair(neighbor_p.clone(), neighbor.clone()), neighbor.clone());
  131|     16|                        frontier.insert(neighbor_entry);
  132|     16|                    }
                                  ^1
  133|       |                }
  134|       |            }
  135|       |
  136|       |            // Build priority set from visited vertices
  137|      7|            let mut priorities = AVLTreeSetMtEph::empty();
  138|      7|            let visited_seq = visited.to_seq();
  139|     23|            for i in 0..visited_seq.length() {
                                      ^7          ^7
  140|     23|                let v = visited_seq.nth(i);
  141|     23|                let p = priority_fn.priority(v);
  142|     23|                priorities.insert(Pair(v.clone(), p));
  143|     23|            }
  144|       |
  145|      7|            PQMinResult {
  146|      7|                visited,
  147|      7|                priorities,
  148|      7|                parent: None,
  149|      7|            }
  150|      7|        }
  151|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap53/PQMinMtPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 53: Min-Priority Queue Search - persistent, multi-threaded.
    3|       |//!
    4|       |//! Note: Parallel priority selection would require concurrent priority queues.
    5|       |//! This implementation uses thread-safe sets (AVLTreeSetMtPer) which support
    6|       |//! parallel set operations, but the priority selection itself remains sequential.
    7|       |
    8|       |pub mod PQMinMtPer {
    9|       |
   10|       |    use crate::Chap37::AVLTreeSeqMtPer::AVLTreeSeqMtPer::AVLTreeSeqMtPerTrait;
   11|       |    use crate::Chap41::AVLTreeSetMtPer::AVLTreeSetMtPer::*;
   12|       |    use crate::Types::Types::*;
   13|       |
   14|       |    #[derive(Clone, Debug)]
   15|       |    pub struct PQMinResult<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static> {
   16|       |        pub visited: AVLTreeSetMtPer<V>,
   17|       |        pub priorities: AVLTreeSetMtPer<Pair<V, P>>,
   18|       |        pub parent: Option<AVLTreeSetMtPer<Pair<V, V>>>,
   19|       |    }
   20|       |
   21|       |    pub trait PriorityFn<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static> {
   22|       |        fn priority(&self, v: &V) -> P;
   23|       |    }
   24|       |
   25|       |    pub struct ClosurePriority<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static, F: Fn(&V) -> P> {
   26|       |        f: F,
   27|       |        _phantom: std::marker::PhantomData<(V, P)>,
   28|       |    }
   29|       |
   30|       |    impl<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static, F: Fn(&V) -> P> ClosurePriority<V, P, F> {
   31|     13|        pub fn new(f: F) -> Self {
   32|     13|            Self {
   33|     13|                f,
   34|     13|                _phantom: std::marker::PhantomData,
   35|     13|            }
   36|     13|        }
   37|       |    }
   38|       |
   39|       |    impl<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static, F: Fn(&V) -> P> PriorityFn<V, P>
   40|       |        for ClosurePriority<V, P, F>
   41|       |    {
   42|    145|        fn priority(&self, v: &V) -> P { (self.f)(v) }
   43|       |    }
   44|       |
   45|       |    pub trait PQMinMtPerTrait<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static> {
   46|       |        /// claude-4-sonet: Work ((|V| + |E|) log |V|), Span (|V| log |V|), Parallelism (1)
   47|       |        /// Priority-First Search using thread-safe persistent sets.
   48|       |        /// Set operations (union, difference, filter) use parallel implementations.
   49|       |        fn pq_min<G, PF>(graph: &G, source: V, priority_fn: &PF) -> PQMinResult<V, P>
   50|       |        where
   51|       |            G: Fn(&V) -> AVLTreeSetMtPer<V>,
   52|       |            PF: PriorityFn<V, P>;
   53|       |
   54|       |        fn pq_min_multi<G, PF>(graph: &G, sources: AVLTreeSetMtPer<V>, priority_fn: &PF) -> PQMinResult<V, P>
   55|       |        where
   56|       |            G: Fn(&V) -> AVLTreeSetMtPer<V>,
   57|       |            PF: PriorityFn<V, P>;
   58|       |    }
   59|       |
   60|       |    /// Priority queue minimum search starting from single source.
   61|       |    /// claude-4-sonet: Work (|V| log |V| + |E|), Span (|V| log |V|), Parallelism (1)
   62|     12|    pub fn pq_min<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static, G, PF>(graph: &G, source: V, priority_fn: &PF) -> PQMinResult<V, P>
   63|     12|    where
   64|     12|        G: Fn(&V) -> AVLTreeSetMtPer<V>,
   65|     12|        PF: PriorityFn<V, P>,
   66|       |    {
   67|     12|        let sources = AVLTreeSetMtPer::singleton(source);
   68|     12|        pq_min_multi(graph, sources, priority_fn)
   69|     12|    }
   70|       |
   71|       |    /// Priority queue minimum search starting from multiple sources.
   72|       |    /// claude-4-sonet: Work (|V| log |V| + |E|), Span (|V| log |V|), Parallelism (1)
   73|     13|    pub fn pq_min_multi<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static, G, PF>(graph: &G, sources: AVLTreeSetMtPer<V>, priority_fn: &PF) -> PQMinResult<V, P>
   74|     13|    where
   75|     13|        G: Fn(&V) -> AVLTreeSetMtPer<V>,
   76|     13|        PF: PriorityFn<V, P>,
   77|       |    {
   78|     60|            fn find_min_priority<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static>(
   79|     60|                frontier: &AVLTreeSetMtPer<Pair<Pair<P, V>, V>>,
   80|     60|            ) -> Option<V> {
   81|     60|                if frontier.size() == 0 {
   82|     13|                    None
   83|       |                } else {
   84|     47|                    let seq = frontier.to_seq();
   85|     47|                    Some(seq.nth(0).1.clone())
   86|       |                }
   87|     60|            }
   88|       |
   89|     60|            fn explore<V, P, G, PF>(
   90|     60|                graph: &G,
   91|     60|                priority_fn: &PF,
   92|     60|                visited: AVLTreeSetMtPer<V>,
   93|     60|                frontier: AVLTreeSetMtPer<Pair<Pair<P, V>, V>>,
   94|     60|            ) -> (AVLTreeSetMtPer<V>, AVLTreeSetMtPer<Pair<V, P>>)
   95|     60|            where
   96|     60|                V: StTInMtT + Ord + 'static,
   97|     60|                P: StTInMtT + Ord + 'static,
   98|     60|                G: Fn(&V) -> AVLTreeSetMtPer<V>,
   99|     60|                PF: PriorityFn<V, P>,
  100|       |            {
  101|     60|                if let Some(v) = find_min_priority(&frontier) {
                                          ^47
  102|     47|                    let p = priority_fn.priority(&v);
  103|     47|                    let entry = Pair(Pair(p.clone(), v.clone()), v.clone());
  104|       |                    // Parallel difference operation
  105|     47|                    let frontier_new = frontier.difference(&AVLTreeSetMtPer::singleton(entry));
  106|       |
  107|       |                    // Parallel union operation
  108|     47|                    let visited_new = visited.union(&AVLTreeSetMtPer::singleton(v.clone()));
  109|       |
  110|     47|                    let neighbors = graph(&v);
  111|     47|                    let mut frontier_updated = frontier_new;
  112|     47|                    let neighbors_seq = neighbors.to_seq();
  113|       |
  114|     47|                    for i in 0..neighbors_seq.length() {
                                      ^45
  115|     45|                        let neighbor = neighbors_seq.nth(i);
  116|     45|                        if !visited_new.find(neighbor) {
  117|     37|                            let neighbor_p = priority_fn.priority(neighbor);
  118|     37|                            let neighbor_entry = Pair(Pair(neighbor_p.clone(), neighbor.clone()), neighbor.clone());
  119|     37|                            // Parallel union for each new frontier element
  120|     37|                            frontier_updated = frontier_updated.union(&AVLTreeSetMtPer::singleton(neighbor_entry));
  121|     37|                        }
                                      ^8
  122|       |                    }
  123|       |
  124|     47|                    explore(graph, priority_fn, visited_new, frontier_updated)
  125|       |                } else {
  126|     13|                    let mut priorities = AVLTreeSetMtPer::empty();
  127|     13|                    let visited_seq = visited.to_seq();
  128|     47|                    for i in 0..visited_seq.length() {
                                              ^13         ^13
  129|     47|                        let v = visited_seq.nth(i);
  130|     47|                        let p = priority_fn.priority(v);
  131|     47|                        // Parallel union for priority set construction
  132|     47|                        priorities = priorities.union(&AVLTreeSetMtPer::singleton(Pair(v.clone(), p)));
  133|     47|                    }
  134|     13|                    (visited, priorities)
  135|       |                }
  136|     60|            }
  137|       |
  138|     13|            let mut initial_frontier = AVLTreeSetMtPer::empty();
  139|     13|            let sources_seq = sources.to_seq();
  140|     14|            for i in 0..sources_seq.length() {
                                      ^13         ^13
  141|     14|                let v = sources_seq.nth(i);
  142|     14|                let p = priority_fn.priority(v);
  143|     14|                let entry = Pair(Pair(p.clone(), v.clone()), v.clone());
  144|     14|                initial_frontier = initial_frontier.union(&AVLTreeSetMtPer::singleton(entry));
  145|     14|            }
  146|       |
  147|     13|            let (visited, priorities) = explore(graph, priority_fn, AVLTreeSetMtPer::empty(), initial_frontier);
  148|       |
  149|     13|            PQMinResult {
  150|     13|                visited,
  151|     13|                priorities,
  152|     13|                parent: None,
  153|     13|            }
  154|     13|        }
  155|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap53/PQMinStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 53: Min-Priority Queue Search - ephemeral, single-threaded.
    3|       |
    4|       |pub mod PQMinStEph {
    5|       |
    6|       |    use crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::AVLTreeSeqStEphTrait;
    7|       |    use crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::*;
    8|       |    use crate::Types::Types::*;
    9|       |
   10|       |    #[derive(Clone, Debug)]
   11|       |    pub struct PQMinResult<V: StT + Ord, P: StT + Ord> {
   12|       |        pub visited: AVLTreeSetStEph<V>,
   13|       |        pub priorities: AVLTreeSetStEph<Pair<V, P>>,
   14|       |        pub parent: Option<AVLTreeSetStEph<Pair<V, V>>>,
   15|       |    }
   16|       |
   17|       |    pub trait PriorityFn<V: StT + Ord, P: StT + Ord> {
   18|       |        fn priority(&self, v: &V) -> P;
   19|       |    }
   20|       |
   21|       |    pub struct ClosurePriority<V: StT + Ord, P: StT + Ord, F: Fn(&V) -> P> {
   22|       |        f: F,
   23|       |        _phantom: std::marker::PhantomData<(V, P)>,
   24|       |    }
   25|       |
   26|       |    impl<V: StT + Ord, P: StT + Ord, F: Fn(&V) -> P> ClosurePriority<V, P, F> {
   27|     13|        pub fn new(f: F) -> Self {
   28|     13|            Self {
   29|     13|                f,
   30|     13|                _phantom: std::marker::PhantomData,
   31|     13|            }
   32|     13|        }
   33|       |    }
   34|       |
   35|       |    impl<V: StT + Ord, P: StT + Ord, F: Fn(&V) -> P> PriorityFn<V, P> for ClosurePriority<V, P, F> {
   36|    145|        fn priority(&self, v: &V) -> P { (self.f)(v) }
   37|       |    }
   38|       |
   39|       |    pub trait PQMinStEphTrait<V: StT + Ord, P: StT + Ord> {
   40|       |        /// claude-4-sonet: Work ((|V| + |E|) log |V|), Span (|V| log |V|), Parallelism (1)
   41|       |        fn pq_min<G, PF>(graph: &G, source: V, priority_fn: &PF) -> PQMinResult<V, P>
   42|       |        where
   43|       |            G: Fn(&V) -> AVLTreeSetStEph<V>,
   44|       |            PF: PriorityFn<V, P>;
   45|       |
   46|       |        /// claude-4-sonet: Work ((|V| + |E|) log |V|), Span (|V| log |V|), Parallelism (1)
   47|       |        fn pq_min_multi<G, PF>(graph: &G, sources: AVLTreeSetStEph<V>, priority_fn: &PF) -> PQMinResult<V, P>
   48|       |        where
   49|       |            G: Fn(&V) -> AVLTreeSetStEph<V>,
   50|       |            PF: PriorityFn<V, P>;
   51|       |    }
   52|       |
   53|       |    /// Priority queue minimum search starting from single source.
   54|       |    /// claude-4-sonet: Work (|V| log |V| + |E|), Span (|V| log |V|), Parallelism (1)
   55|     12|    pub fn pq_min<V: StT + Ord, P: StT + Ord, G, PF>(graph: &G, source: V, priority_fn: &PF) -> PQMinResult<V, P>
   56|     12|    where
   57|     12|        G: Fn(&V) -> AVLTreeSetStEph<V>,
   58|     12|        PF: PriorityFn<V, P>,
   59|       |    {
   60|     12|        let sources = AVLTreeSetStEph::singleton(source);
   61|     12|        pq_min_multi(graph, sources, priority_fn)
   62|     12|    }
   63|       |
   64|       |    /// Priority queue minimum search starting from multiple sources.
   65|       |    /// claude-4-sonet: Work (|V| log |V| + |E|), Span (|V| log |V|), Parallelism (1)
   66|     13|    pub fn pq_min_multi<V: StT + Ord, P: StT + Ord, G, PF>(graph: &G, sources: AVLTreeSetStEph<V>, priority_fn: &PF) -> PQMinResult<V, P>
   67|     13|    where
   68|     13|        G: Fn(&V) -> AVLTreeSetStEph<V>,
   69|     13|        PF: PriorityFn<V, P>,
   70|       |    {
   71|     60|            fn find_min_priority<V: StT + Ord, P: StT + Ord>(
   72|     60|                frontier: &AVLTreeSetStEph<Pair<Pair<P, V>, V>>,
   73|     60|            ) -> Option<V> {
   74|     60|                if frontier.size() == 0 {
   75|     13|                    None
   76|       |                } else {
   77|     47|                    let seq = frontier.to_seq();
   78|     47|                    Some(seq.nth(0).1.clone())
   79|       |                }
   80|     60|            }
   81|       |
   82|     60|            fn explore<V, P, G, PF>(
   83|     60|                graph: &G,
   84|     60|                priority_fn: &PF,
   85|     60|                visited: AVLTreeSetStEph<V>,
   86|     60|                frontier: AVLTreeSetStEph<Pair<Pair<P, V>, V>>,
   87|     60|            ) -> (AVLTreeSetStEph<V>, AVLTreeSetStEph<Pair<V, P>>)
   88|     60|            where
   89|     60|                V: StT + Ord,
   90|     60|                P: StT + Ord,
   91|     60|                G: Fn(&V) -> AVLTreeSetStEph<V>,
   92|     60|                PF: PriorityFn<V, P>,
   93|       |            {
   94|     60|                if let Some(v) = find_min_priority(&frontier) {
                                          ^47
   95|     47|                    let p = priority_fn.priority(&v);
   96|     47|                    let entry = Pair(Pair(p.clone(), v.clone()), v.clone());
   97|     47|                    let frontier_new = frontier.difference(&AVLTreeSetStEph::singleton(entry));
   98|       |
   99|     47|                    let visited_new = visited.union(&AVLTreeSetStEph::singleton(v.clone()));
  100|       |
  101|     47|                    let neighbors = graph(&v);
  102|     47|                    let mut frontier_updated = frontier_new;
  103|     47|                    let neighbors_seq = neighbors.to_seq();
  104|       |
  105|     47|                    for i in 0..neighbors_seq.length() {
                                      ^45
  106|     45|                        let neighbor = neighbors_seq.nth(i);
  107|     45|                        if !visited_new.find(neighbor) {
  108|     37|                            let neighbor_p = priority_fn.priority(neighbor);
  109|     37|                            let neighbor_entry = Pair(Pair(neighbor_p.clone(), neighbor.clone()), neighbor.clone());
  110|     37|                            frontier_updated = frontier_updated.union(&AVLTreeSetStEph::singleton(neighbor_entry));
  111|     37|                        }
                                      ^8
  112|       |                    }
  113|       |
  114|     47|                    explore(graph, priority_fn, visited_new, frontier_updated)
  115|       |                } else {
  116|     13|                    let mut priorities = AVLTreeSetStEph::empty();
  117|     13|                    let visited_seq = visited.to_seq();
  118|     47|                    for i in 0..visited_seq.length() {
                                              ^13         ^13
  119|     47|                        let v = visited_seq.nth(i);
  120|     47|                        let p = priority_fn.priority(v);
  121|     47|                        priorities = priorities.union(&AVLTreeSetStEph::singleton(Pair(v.clone(), p)));
  122|     47|                    }
  123|     13|                    (visited, priorities)
  124|       |                }
  125|     60|            }
  126|       |
  127|     13|            let mut initial_frontier = AVLTreeSetStEph::empty();
  128|     13|            let sources_seq = sources.to_seq();
  129|     14|            for i in 0..sources_seq.length() {
                                      ^13         ^13
  130|     14|                let v = sources_seq.nth(i);
  131|     14|                let p = priority_fn.priority(v);
  132|     14|                let entry = Pair(Pair(p.clone(), v.clone()), v.clone());
  133|     14|                initial_frontier = initial_frontier.union(&AVLTreeSetStEph::singleton(entry));
  134|     14|            }
  135|       |
  136|     13|            let (visited, priorities) = explore(graph, priority_fn, AVLTreeSetStEph::empty(), initial_frontier);
  137|       |
  138|     13|            PQMinResult {
  139|     13|                visited,
  140|     13|                priorities,
  141|     13|                parent: None,
  142|     13|            }
  143|     13|        }
  144|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap53/PQMinStPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 53: Min-Priority Queue Search - persistent, single-threaded.
    3|       |//!
    4|       |//! Implements Algorithm 53.7 - Priority Queue Search framework.
    5|       |//! Selects minimum priority vertices first (lower priority = higher urgency).
    6|       |
    7|       |pub mod PQMinStPer {
    8|       |
    9|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::AVLTreeSeqStPerTrait;
   10|       |    use crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::*;
   11|       |    use crate::Types::Types::*;
   12|       |
   13|       |    #[derive(Clone, Debug)]
   14|       |    pub struct PQMinResult<V: StT + Ord, P: StT + Ord> {
   15|       |        pub visited: AVLTreeSetStPer<V>,
   16|       |        pub priorities: AVLTreeSetStPer<Pair<V, P>>,     // (vertex, priority)
   17|       |        pub parent: Option<AVLTreeSetStPer<Pair<V, V>>>, // (child, parent)
   18|       |    }
   19|       |
   20|       |    /// Priority function: maps vertices to their priorities.
   21|       |    /// Lower priority values = higher priority (visited first).
   22|       |    pub trait PriorityFn<V: StT + Ord, P: StT + Ord> {
   23|       |        fn priority(&self, v: &V) -> P;
   24|       |    }
   25|       |
   26|       |    /// Simple wrapper for closure-based priority functions.
   27|       |    pub struct ClosurePriority<V: StT + Ord, P: StT + Ord, F: Fn(&V) -> P> {
   28|       |        f: F,
   29|       |        _phantom: std::marker::PhantomData<(V, P)>,
   30|       |    }
   31|       |
   32|       |    impl<V: StT + Ord, P: StT + Ord, F: Fn(&V) -> P> ClosurePriority<V, P, F> {
   33|      7|        pub fn new(f: F) -> Self {
   34|      7|            Self {
   35|      7|                f,
   36|      7|                _phantom: std::marker::PhantomData,
   37|      7|            }
   38|      7|        }
   39|       |    }
   40|       |
   41|       |    impl<V: StT + Ord, P: StT + Ord, F: Fn(&V) -> P> PriorityFn<V, P> for ClosurePriority<V, P, F> {
   42|     70|        fn priority(&self, v: &V) -> P { (self.f)(v) }
   43|       |    }
   44|       |
   45|       |    pub trait PQMinStPerTrait<V: StT + Ord, P: StT + Ord> {
   46|       |        /// claude-4-sonet: Work ((|V| + |E|) log |V|), Span (|V| log |V|), Parallelism (1)
   47|       |        /// Priority Queue Search from a single source.
   48|       |        fn pq_min<G, PF>(graph: &G, source: V, priority_fn: &PF) -> PQMinResult<V, P>
   49|       |        where
   50|       |            G: Fn(&V) -> AVLTreeSetStPer<V>,
   51|       |            PF: PriorityFn<V, P>;
   52|       |
   53|       |        /// Priority Queue Search from multiple sources.
   54|       |        fn pq_min_multi<G, PF>(graph: &G, sources: AVLTreeSetStPer<V>, priority_fn: &PF) -> PQMinResult<V, P>
   55|       |        where
   56|       |            G: Fn(&V) -> AVLTreeSetStPer<V>,
   57|       |            PF: PriorityFn<V, P>;
   58|       |    }
   59|       |
   60|       |    /// Priority queue minimum search starting from single source.
   61|       |    /// claude-4-sonet: Work (|V| log |V| + |E|), Span (|V| log |V|), Parallelism (1)
   62|      6|    pub fn pq_min<V: StT + Ord, P: StT + Ord, G, PF>(graph: &G, source: V, priority_fn: &PF) -> PQMinResult<V, P>
   63|      6|    where
   64|      6|        G: Fn(&V) -> AVLTreeSetStPer<V>,
   65|      6|        PF: PriorityFn<V, P>,
   66|       |    {
   67|      6|        let sources = AVLTreeSetStPer::singleton(source);
   68|      6|        pq_min_multi(graph, sources, priority_fn)
   69|      6|    }
   70|       |
   71|       |    /// Priority queue minimum search starting from multiple sources.
   72|       |    /// claude-4-sonet: Work (|V| log |V| + |E|), Span (|V| log |V|), Parallelism (1)
   73|      7|    pub fn pq_min_multi<V: StT + Ord, P: StT + Ord, G, PF>(graph: &G, sources: AVLTreeSetStPer<V>, priority_fn: &PF) -> PQMinResult<V, P>
   74|      7|    where
   75|      7|        G: Fn(&V) -> AVLTreeSetStPer<V>,
   76|      7|        PF: PriorityFn<V, P>,
   77|       |    {
   78|       |            // Helper: find minimum priority vertex in frontier
   79|     30|            fn find_min_priority<V: StT + Ord, P: StT + Ord>(
   80|     30|                frontier: &AVLTreeSetStPer<Pair<Pair<P, V>, V>>,
   81|     30|            ) -> Option<V> {
   82|     30|                if frontier.size() == 0 {
   83|      7|                    None
   84|       |                } else {
   85|     23|                    let seq = frontier.to_seq();
   86|       |                    // First element has minimum priority (sorted by (P, V) pair)
   87|     23|                    let min_entry = seq.nth(0);
   88|     23|                    Some(min_entry.1.clone())
   89|       |                }
   90|     30|            }
   91|       |
   92|     30|            fn explore<V, P, G, PF>(
   93|     30|                graph: &G,
   94|     30|                priority_fn: &PF,
   95|     30|                visited: AVLTreeSetStPer<V>,
   96|     30|                frontier: AVLTreeSetStPer<Pair<Pair<P, V>, V>>, // ((priority, vertex), vertex)
   97|     30|            ) -> (AVLTreeSetStPer<V>, AVLTreeSetStPer<Pair<V, P>>)
   98|     30|            where
   99|     30|                V: StT + Ord,
  100|     30|                P: StT + Ord,
  101|     30|                G: Fn(&V) -> AVLTreeSetStPer<V>,
  102|     30|                PF: PriorityFn<V, P>,
  103|       |            {
  104|       |                // Select vertex with minimum priority
  105|     30|                if let Some(v) = find_min_priority(&frontier) {
                                          ^23
  106|       |                    // Remove selected vertex from frontier
  107|     23|                    let p = priority_fn.priority(&v);
  108|     23|                    let entry = Pair(Pair(p.clone(), v.clone()), v.clone());
  109|     23|                    let frontier_new = frontier.difference(&AVLTreeSetStPer::singleton(entry));
  110|       |
  111|       |                    // Add to visited
  112|     23|                    let visited_new = visited.union(&AVLTreeSetStPer::singleton(v.clone()));
  113|       |
  114|       |                    // Get neighbors and add unvisited ones to frontier
  115|     23|                    let neighbors = graph(&v);
  116|     23|                    let mut frontier_updated = frontier_new;
  117|     23|                    let neighbors_seq = neighbors.to_seq();
  118|       |
  119|     23|                    for i in 0..neighbors_seq.length() {
                                      ^17
  120|     17|                        let neighbor = neighbors_seq.nth(i);
  121|     17|                        if !visited_new.find(neighbor) {
  122|     16|                            let neighbor_p = priority_fn.priority(neighbor);
  123|     16|                            let neighbor_entry = Pair(Pair(neighbor_p.clone(), neighbor.clone()), neighbor.clone());
  124|     16|                            frontier_updated = frontier_updated.union(&AVLTreeSetStPer::singleton(neighbor_entry));
  125|     16|                        }
                                      ^1
  126|       |                    }
  127|       |
  128|     23|                    explore(graph, priority_fn, visited_new, frontier_updated)
  129|       |                } else {
  130|       |                    // Build priority set from visited vertices
  131|      7|                    let mut priorities = AVLTreeSetStPer::empty();
  132|      7|                    let visited_seq = visited.to_seq();
  133|     23|                    for i in 0..visited_seq.length() {
                                              ^7          ^7
  134|     23|                        let v = visited_seq.nth(i);
  135|     23|                        let p = priority_fn.priority(v);
  136|     23|                        priorities = priorities.union(&AVLTreeSetStPer::singleton(Pair(v.clone(), p)));
  137|     23|                    }
  138|      7|                    (visited, priorities)
  139|       |                }
  140|     30|            }
  141|       |
  142|       |            // Initialize frontier with sources
  143|      7|            let mut initial_frontier = AVLTreeSetStPer::empty();
  144|      7|            let sources_seq = sources.to_seq();
  145|      8|            for i in 0..sources_seq.length() {
                                      ^7          ^7
  146|      8|                let v = sources_seq.nth(i);
  147|      8|                let p = priority_fn.priority(v);
  148|      8|                let entry = Pair(Pair(p.clone(), v.clone()), v.clone());
  149|      8|                initial_frontier = initial_frontier.union(&AVLTreeSetStPer::singleton(entry));
  150|      8|            }
  151|       |
  152|      7|            let (visited, priorities) = explore(graph, priority_fn, AVLTreeSetStPer::empty(), initial_frontier);
  153|       |
  154|      7|            PQMinResult {
  155|      7|                visited,
  156|      7|                priorities,
  157|      7|                parent: None,
  158|      7|            }
  159|      7|        }
  160|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap54/BFSMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Breadth-First Search - Parallel Ephemeral (Chapter 54).
    3|       |//! Layer-by-layer parallel BFS for finding distances and reachability.
    4|       |//! Work: O(|V| + |E|), Span: O(dlg n) where d is diameter.
    5|       |
    6|       |pub mod BFSMtEph {
    7|       |
    8|       |    use std::collections::VecDeque;
    9|       |
   10|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
   11|       |    use crate::ParaPair;
   12|       |    use crate::Types::Types::*;
   13|       |
   14|       |    pub trait BFSMtEphTrait {
   15|       |        /// Performs parallel BFS from source vertex s on adjacency list graph G
   16|       |        /// APAS: Work O(|V| + |E|), Span O(dlg n) where d is diameter
   17|       |        fn bfs(graph: &ArraySeqMtEphS<ArraySeqMtEphS<N>>, source: N) -> ArraySeqMtEphS<N>;
   18|       |    }
   19|       |
   20|       |    const UNREACHABLE: N = N::MAX;
   21|       |
   22|       |    /// Performs parallel BFS from source vertex s on adjacency list graph G.
   23|       |    /// Graph is represented as sequence of sequences (adjacency list).
   24|       |    /// Returns array where result[v] = distance if reachable, UNREACHABLE otherwise.
   25|      7|    pub fn bfs(graph: &ArraySeqMtEphS<ArraySeqMtEphS<N>>, source: N) -> ArraySeqMtEphS<N> {
   26|      7|        let n = graph.length();
   27|      7|        if source >= n {
   28|      2|            return ArraySeqMtEphS::tabulate(&|_| UNREACHABLE, n);
   29|      5|        }
   30|       |
   31|      5|        let mut distances = ArraySeqMtEphS::tabulate(&|_| UNREACHABLE, n);
   32|      5|        let _ = distances.set(source, 0);
   33|       |
   34|      5|        let mut current_layer = VecDeque::new();
   35|      5|        current_layer.push_back(source);
   36|      5|        let mut current_dist = 0;
   37|       |
   38|     19|        while !current_layer.is_empty() {
   39|     14|            let layer_size = current_layer.len();
   40|     14|            let mut next_layer = VecDeque::new();
   41|       |
   42|     14|            for _ in 0..layer_size {
   43|     17|                if let Some(u) = current_layer.pop_front() {
   44|     17|                    let neighbors = graph.nth_cloned(u);
   45|     18|                    for i in 0..neighbors.length() {
                                              ^17       ^17
   46|     18|                        let v = neighbors.nth_cloned(i);
   47|     18|                        if distances.nth_cloned(v) == UNREACHABLE {
   48|     12|                            let _ = distances.set(v, current_dist + 1);
   49|     12|                            next_layer.push_back(v);
   50|     12|                        }
                                      ^6
   51|       |                    }
   52|      0|                }
   53|       |            }
   54|       |
   55|     14|            current_layer = next_layer;
   56|     14|            current_dist += 1;
   57|       |        }
   58|       |
   59|      5|        distances
   60|      7|    }
   61|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap54/BFSMtPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Breadth-First Search - Parallel Persistent (Chapter 54).
    3|       |//! Layer-by-layer parallel BFS for finding distances and reachability.
    4|       |//! Work: O(|V| + |E|), Span: O(dlg n) where d is diameter.
    5|       |
    6|       |pub mod BFSMtPer {
    7|       |
    8|       |    use std::collections::VecDeque;
    9|       |
   10|       |    use crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::*;
   11|       |    use crate::ParaPair;
   12|       |    use crate::Types::Types::*;
   13|       |
   14|       |    pub trait BFSMtPerTrait {
   15|       |        /// Performs parallel BFS from source vertex s on adjacency list graph G
   16|       |        /// APAS: Work O(|V| + |E|), Span O(dlg n) where d is diameter
   17|       |        fn bfs(graph: &ArraySeqMtPerS<ArraySeqMtPerS<N>>, source: N) -> ArraySeqMtPerS<N>;
   18|       |    }
   19|       |
   20|       |    const UNREACHABLE: N = N::MAX;
   21|       |
   22|       |    /// Performs parallel BFS from source vertex s on adjacency list graph G.
   23|       |    /// Graph is represented as sequence of sequences (adjacency list).
   24|       |    /// Returns array where result[v] = distance if reachable, UNREACHABLE otherwise.
   25|      7|    pub fn bfs(graph: &ArraySeqMtPerS<ArraySeqMtPerS<N>>, source: N) -> ArraySeqMtPerS<N> {
   26|      7|        let n = graph.length();
   27|      7|        if source >= n {
   28|      2|            return ArraySeqMtPerS::tabulate(&|_| UNREACHABLE, n);
   29|      5|        }
   30|       |
   31|      5|        let mut distances = ArraySeqMtPerS::tabulate(&|_| UNREACHABLE, n);
   32|      5|        distances = ArraySeqMtPerS::update(&distances, Pair(source, 0));
   33|       |
   34|      5|        let mut current_layer = VecDeque::new();
   35|      5|        current_layer.push_back(source);
   36|      5|        let mut current_dist = 0;
   37|       |
   38|     19|        while !current_layer.is_empty() {
   39|     14|            let layer_size = current_layer.len();
   40|     14|            let mut next_layer = VecDeque::new();
   41|       |
   42|     14|            for _ in 0..layer_size {
   43|     17|                if let Some(u) = current_layer.pop_front() {
   44|     17|                    let neighbors = graph.nth(u);
   45|     18|                    for i in 0..neighbors.length() {
                                              ^17       ^17
   46|     18|                        let v = *neighbors.nth(i);
   47|     18|                        if *distances.nth(v) == UNREACHABLE {
   48|     12|                            distances = ArraySeqMtPerS::update(&distances, Pair(v, current_dist + 1));
   49|     12|                            next_layer.push_back(v);
   50|     12|                        }
                                      ^6
   51|       |                    }
   52|      0|                }
   53|       |            }
   54|       |
   55|     14|            current_layer = next_layer;
   56|     14|            current_dist += 1;
   57|       |        }
   58|       |
   59|      5|        distances
   60|      7|    }
   61|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap54/BFSStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Breadth-First Search - Sequential Ephemeral (Chapter 54, Algorithm 54.3).
    3|       |//! Queue-based BFS for finding distances and reachability from a source vertex.
    4|       |//! Work: O(|V| + |E|), Span: O(|V| + |E|).
    5|       |
    6|       |pub mod BFSStEph {
    7|       |
    8|       |    use std::collections::VecDeque;
    9|       |
   10|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   11|       |    use crate::Types::Types::*;
   12|       |
   13|       |    pub trait BFSStEphTrait {
   14|       |        /// Performs BFS from source vertex s on adjacency list graph G
   15|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   16|       |        fn bfs(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>, source: N) -> ArraySeqStEphS<N>;
   17|       |    }
   18|       |
   19|       |    const UNREACHABLE: N = N::MAX;
   20|       |
   21|       |    /// Performs BFS from source vertex s on adjacency list graph G.
   22|       |    /// Graph is represented as sequence of sequences (adjacency list).
   23|       |    /// Returns array where result[v] = distance if reachable, UNREACHABLE otherwise.
   24|      7|    pub fn bfs(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>, source: N) -> ArraySeqStEphS<N> {
   25|      7|        let n = graph.length();
   26|      7|        if source >= n {
   27|      2|            return ArraySeqStEphS::tabulate(&|_| UNREACHABLE, n);
   28|      5|        }
   29|       |
   30|      5|        let mut distances = ArraySeqStEphS::tabulate(&|_| UNREACHABLE, n);
   31|      5|        let _ = distances.set(source, 0);
   32|       |
   33|      5|        let mut queue = VecDeque::new();
   34|      5|        queue.push_back(source);
   35|       |
   36|     22|        while let Some(u) = queue.pop_front() {
                                     ^17
   37|     17|            let dist = *distances.nth(u);
   38|     17|            if dist != UNREACHABLE {
   39|     17|                let neighbors = graph.nth(u);
   40|     18|                for i in 0..neighbors.length() {
                                          ^17       ^17
   41|     18|                    let v = *neighbors.nth(i);
   42|     18|                    if *distances.nth(v) == UNREACHABLE {
   43|     12|                        let _ = distances.set(v, dist + 1);
   44|     12|                        queue.push_back(v);
   45|     12|                    }
                                  ^6
   46|       |                }
   47|      0|            }
   48|       |        }
   49|       |
   50|      5|        distances
   51|      7|    }
   52|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap54/BFSStPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Breadth-First Search - Sequential Persistent (Chapter 54, Algorithm 54.3).
    3|       |//! Queue-based BFS for finding distances and reachability from a source vertex.
    4|       |//! Work: O(|V| + |E|), Span: O(|V| + |E|).
    5|       |
    6|       |pub mod BFSStPer {
    7|       |
    8|       |    use std::collections::VecDeque;
    9|       |
   10|       |    use crate::Chap19::ArraySeqStPer::ArraySeqStPer::*;
   11|       |    use crate::Types::Types::*;
   12|       |
   13|       |    pub trait BFSStPerTrait {
   14|       |        /// Performs BFS from source vertex s on adjacency list graph G
   15|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   16|       |        fn bfs(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>, source: N) -> ArraySeqStPerS<N>;
   17|       |    }
   18|       |
   19|       |    const UNREACHABLE: N = N::MAX;
   20|       |
   21|       |    /// Performs BFS from source vertex s on adjacency list graph G.
   22|       |    /// Graph is represented as sequence of sequences (adjacency list).
   23|       |    /// Returns array where result[v] = distance if reachable, UNREACHABLE otherwise.
   24|      7|    pub fn bfs(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>, source: N) -> ArraySeqStPerS<N> {
   25|      7|        let n = graph.length();
   26|      7|        if source >= n {
   27|      2|            return ArraySeqStPerS::tabulate(&|_| UNREACHABLE, n);
   28|      5|        }
   29|       |
   30|      5|        let mut distances = ArraySeqStPerS::tabulate(&|_| UNREACHABLE, n);
   31|      5|        distances = ArraySeqStPerS::update(&distances, source, 0);
   32|       |
   33|      5|        let mut queue = VecDeque::new();
   34|      5|        queue.push_back(source);
   35|       |
   36|     22|        while let Some(u) = queue.pop_front() {
                                     ^17
   37|     17|            let dist = *distances.nth(u);
   38|     17|            if dist != UNREACHABLE {
   39|     17|                let neighbors = graph.nth(u);
   40|     18|                for i in 0..neighbors.length() {
                                          ^17       ^17
   41|     18|                    let v = *neighbors.nth(i);
   42|     18|                    if *distances.nth(v) == UNREACHABLE {
   43|     12|                        distances = ArraySeqStPerS::update(&distances, v, dist + 1);
   44|     12|                        queue.push_back(v);
   45|     12|                    }
                                  ^6
   46|       |                }
   47|      0|            }
   48|       |        }
   49|       |
   50|      5|        distances
   51|      7|    }
   52|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap55/CycleDetectStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Cycle Detection - Sequential Ephemeral (Chapter 55, Algorithm 55.10).
    3|       |//! Detects cycles in directed graphs using ephemeral ancestor tracking.
    4|       |//! Work: O(|V| + |E|), Span: O(|V| + |E|).
    5|       |
    6|       |pub mod CycleDetectStEph {
    7|       |
    8|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::{ArraySeqStEphS, ArraySeqStEphTrait};
    9|       |    use crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    pub trait CycleDetectStEphTrait {
   13|       |        /// Detects if a directed graph contains a cycle
   14|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   15|       |        fn has_cycle(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>) -> B;
   16|       |    }
   17|       |
   18|       |    /// Detects if a directed graph contains a cycle.
   19|       |    /// Returns true if a cycle exists, false otherwise.
   20|      7|    pub fn has_cycle(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>) -> B {
   21|      7|        let n = graph.length();
   22|      7|        let mut visited = ArraySeqStEphS::tabulate(&|_| false, n);
   23|       |
   24|     11|        for start in 0..n {
                                      ^7
   25|     11|            if !*visited.nth(start) {
   26|      6|                let mut ancestors = AVLTreeSetStEph::empty();
   27|      6|                if dfs_check_cycle(graph, &mut visited, &mut ancestors, start) {
   28|      3|                    return true;
   29|      3|                }
   30|      5|            }
   31|       |        }
   32|      4|        false
   33|      7|    }
   34|       |
   35|     19|    fn dfs_check_cycle(
   36|     19|        graph: &ArraySeqStEphS<ArraySeqStEphS<N>>,
   37|     19|        visited: &mut ArraySeqStEphS<B>,
   38|     19|        ancestors: &mut AVLTreeSetStEph<N>,
   39|     19|        vertex: N,
   40|     19|    ) -> B {
   41|     19|        if ancestors.find(&vertex) {
   42|      3|            return true;
   43|     16|        }
   44|       |
   45|     16|        if *visited.nth(vertex) {
   46|      1|            return false;
   47|     15|        }
   48|       |
   49|     15|        let _ = visited.set(vertex, true);
   50|     15|        ancestors.insert(vertex);
   51|       |
   52|     15|        let neighbors = graph.nth(vertex);
   53|     15|        for i in 0..neighbors.length() {
                          ^13
   54|     13|            let neighbor = *neighbors.nth(i);
   55|     13|            if dfs_check_cycle(graph, visited, ancestors, neighbor) {
   56|      7|                ancestors.delete(&vertex);
   57|      7|                return true;
   58|      6|            }
   59|       |        }
   60|       |
   61|      8|        ancestors.delete(&vertex);
   62|      8|        false
   63|     19|    }
   64|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap55/CycleDetectStPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Cycle Detection - Sequential Persistent (Chapter 55, Algorithm 55.10).
    3|       |//! Detects cycles in directed graphs using ancestor tracking.
    4|       |//! Work: O(|V| + |E|), Span: O(|V| + |E|).
    5|       |
    6|       |pub mod CycleDetectStPer {
    7|       |
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::{ArraySeqStPerS, ArraySeqStPerTrait};
    9|       |    use crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    pub trait CycleDetectStPerTrait {
   13|       |        /// Detects if a directed graph contains a cycle
   14|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   15|       |        fn has_cycle(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>) -> B;
   16|       |    }
   17|       |
   18|       |    /// Detects if a directed graph contains a cycle.
   19|       |    /// Returns true if a cycle exists, false otherwise.
   20|      7|    pub fn has_cycle(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>) -> B {
   21|      7|        let n = graph.length();
   22|      7|        let mut visited = AVLTreeSetStPer::empty();
   23|       |
   24|     11|        for start in 0..n {
                                      ^7
   25|     11|            if !visited.find(&start) {
   26|      6|                let (found_cycle, new_visited) = dfs_check_cycle(graph, visited, AVLTreeSetStPer::empty(), start);
   27|      6|                if found_cycle {
   28|      3|                    return true;
   29|      3|                }
   30|      3|                visited = new_visited;
   31|      5|            }
   32|       |        }
   33|      4|        false
   34|      7|    }
   35|       |
   36|     19|    fn dfs_check_cycle(
   37|     19|        graph: &ArraySeqStPerS<ArraySeqStPerS<N>>,
   38|     19|        visited: AVLTreeSetStPer<N>,
   39|     19|        ancestors: AVLTreeSetStPer<N>,
   40|     19|        vertex: N,
   41|     19|    ) -> (B, AVLTreeSetStPer<N>) {
   42|     19|        if ancestors.find(&vertex) {
   43|      3|            return (true, visited);
   44|     16|        }
   45|       |
   46|     16|        if visited.find(&vertex) {
   47|      1|            return (false, visited);
   48|     15|        }
   49|       |
   50|     15|        let visited = visited.insert(vertex);
   51|     15|        let ancestors = ancestors.insert(vertex);
   52|     15|        let neighbors = graph.nth(vertex);
   53|       |
   54|     15|        let mut visited = visited;
   55|     15|        for i in 0..neighbors.length() {
                          ^13
   56|     13|            let neighbor = *neighbors.nth(i);
   57|     13|            let (found_cycle, new_visited) = dfs_check_cycle(graph, visited, ancestors.clone(), neighbor);
   58|     13|            if found_cycle {
   59|      7|                return (true, new_visited);
   60|      6|            }
   61|      6|            visited = new_visited;
   62|       |        }
   63|       |
   64|      8|        (false, visited)
   65|     19|    }
   66|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap55/DFSStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Depth-First Search - Sequential Ephemeral (Chapter 55, Algorithm 55.7).
    3|       |//! Recursive DFS using ephemeral arrays for efficient visited tracking.
    4|       |//! Work: O(|V| + |E|), Span: O(|V| + |E|).
    5|       |
    6|       |pub mod DFSStEph {
    7|       |
    8|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::{ArraySeqStEphS, ArraySeqStEphTrait};
    9|       |    use crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    pub trait DFSStEphTrait {
   13|       |        /// Performs DFS from source vertex s on adjacency list graph G
   14|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   15|       |        fn dfs(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>, source: N) -> AVLTreeSetStEph<N>;
   16|       |    }
   17|       |
   18|       |    /// Performs DFS from source vertex s on adjacency list graph G.
   19|       |    /// Returns the set of all vertices reachable from s.
   20|      6|    pub fn dfs(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>, source: N) -> AVLTreeSetStEph<N> {
   21|      6|        let n = graph.length();
   22|      6|        if source >= n {
   23|      1|            return AVLTreeSetStEph::empty();
   24|      5|        }
   25|       |
   26|      5|        let mut visited = ArraySeqStEphS::tabulate(&|_| false, n);
   27|      5|        let mut result = AVLTreeSetStEph::empty();
   28|      5|        dfs_recursive(graph, &mut visited, &mut result, source);
   29|      5|        result
   30|      6|    }
   31|       |
   32|     15|    fn dfs_recursive(
   33|     15|        graph: &ArraySeqStEphS<ArraySeqStEphS<N>>,
   34|     15|        visited: &mut ArraySeqStEphS<B>,
   35|     15|        result: &mut AVLTreeSetStEph<N>,
   36|     15|        vertex: N,
   37|     15|    ) {
   38|     15|        if *visited.nth(vertex) {
   39|      2|            return;
   40|     13|        }
   41|       |
   42|     13|        let _ = visited.set(vertex, true);
   43|     13|        result.insert(vertex);
   44|       |
   45|     13|        let neighbors = graph.nth(vertex);
   46|     13|        for i in 0..neighbors.length() {
                          ^10
   47|     10|            let neighbor = *neighbors.nth(i);
   48|     10|            dfs_recursive(graph, visited, result, neighbor);
   49|     10|        }
   50|     15|    }
   51|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap55/DFSStPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Depth-First Search - Sequential Persistent (Chapter 55, Algorithm 55.2).
    3|       |//! Recursive DFS for finding reachable vertices from a source vertex.
    4|       |//! Work: O(|V| + |E|), Span: O(|V| + |E|).
    5|       |
    6|       |pub mod DFSStPer {
    7|       |
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::{ArraySeqStPerS, ArraySeqStPerTrait};
    9|       |    use crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    pub trait DFSStPerTrait {
   13|       |        /// Performs DFS from source vertex s on adjacency list graph G
   14|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   15|       |        fn dfs(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>, source: N) -> AVLTreeSetStPer<N>;
   16|       |    }
   17|       |
   18|       |    /// Performs DFS from source vertex s on adjacency list graph G.
   19|       |    /// Returns the set of all vertices reachable from s.
   20|      7|    pub fn dfs(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>, source: N) -> AVLTreeSetStPer<N> {
   21|      7|        let n = graph.length();
   22|      7|        if source >= n {
   23|      2|            return AVLTreeSetStPer::empty();
   24|      5|        }
   25|      5|        dfs_recursive(graph, AVLTreeSetStPer::empty(), source)
   26|      7|    }
   27|       |
   28|     15|    fn dfs_recursive(
   29|     15|        graph: &ArraySeqStPerS<ArraySeqStPerS<N>>,
   30|     15|        visited: AVLTreeSetStPer<N>,
   31|     15|        vertex: N,
   32|     15|    ) -> AVLTreeSetStPer<N> {
   33|     15|        if visited.find(&vertex) {
   34|      2|            return visited;
   35|     13|        }
   36|       |
   37|     13|        let visited = visited.insert(vertex);
   38|     13|        let neighbors = graph.nth(vertex);
   39|       |
   40|     13|        let mut visited = visited;
   41|     13|        for i in 0..neighbors.length() {
                          ^10
   42|     10|            let neighbor = *neighbors.nth(i);
   43|     10|            visited = dfs_recursive(graph, visited, neighbor);
   44|     10|        }
   45|       |
   46|     13|        visited
   47|     15|    }
   48|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap55/SCCStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Strongly Connected Components - Sequential Ephemeral (Chapter 55, Algorithm 55.18).
    3|       |//! Finds all strongly connected components using ephemeral structures.
    4|       |//! Work: O(|V| + |E|), Span: O(|V| + |E|).
    5|       |
    6|       |pub mod SCCStEph {
    7|       |
    8|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::{ArraySeqStEphS, ArraySeqStEphTrait};
    9|       |    use crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::{AVLTreeSeqStEphS, AVLTreeSeqStEphTrait};
   10|       |    use crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::*;
   11|       |    use crate::Types::Types::*;
   12|       |
   13|       |    pub trait SCCStEphTrait {
   14|       |        /// Finds strongly connected components in a directed graph
   15|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   16|       |        fn scc(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>) -> AVLTreeSeqStEphS<AVLTreeSetStEph<N>>;
   17|       |    }
   18|       |
   19|       |    /// Finds strongly connected components in a directed graph.
   20|       |    /// Returns sequence of components, each component is a set of vertices.
   21|      7|    pub fn scc(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>) -> AVLTreeSeqStEphS<AVLTreeSetStEph<N>> {
   22|      7|        let finish_order = compute_finish_order(graph);
   23|      7|        let transposed = transpose_graph(graph);
   24|       |
   25|      7|        let n = graph.length();
   26|      7|        let mut visited = ArraySeqStEphS::tabulate(&|_| false, n);
   27|      7|        let mut components: AVLTreeSeqStEphS<AVLTreeSetStEph<N>> = AVLTreeSeqStEphS::empty();
   28|       |
   29|     20|        for i in 0..finish_order.length() {
                                  ^7           ^7
   30|     20|            let vertex = *finish_order.nth(i);
   31|     20|            if !*visited.nth(vertex) {
   32|     12|                let mut component = AVLTreeSetStEph::empty();
   33|     12|                dfs_reach(&transposed, &mut visited, &mut component, vertex);
   34|     12|                if component.size() > 0 {
   35|     12|                    let mut vec = Vec::new();
   36|     12|                    for i in 0..components.length() {
                                      ^6
   37|      6|                        vec.push(components.nth(i).clone());
   38|      6|                    }
   39|     12|                    vec.push(component);
   40|     12|                    components = AVLTreeSeqStEphS::from_vec(vec);
   41|      0|                }
   42|      8|            }
   43|       |        }
   44|      7|        components
   45|      7|    }
   46|       |
   47|      7|    fn compute_finish_order(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>) -> AVLTreeSeqStEphS<N> {
   48|      7|        let n = graph.length();
   49|      7|        let mut visited = ArraySeqStEphS::tabulate(&|_| false, n);
   50|      7|        let mut result = Vec::new();
   51|       |
   52|     20|        for start in 0..n {
                                      ^7
   53|     20|            if !*visited.nth(start) {
   54|      9|                dfs_finish_order(graph, &mut visited, &mut result, start);
   55|     11|            }
   56|       |        }
   57|      7|        AVLTreeSeqStEphS::from_vec(result)
   58|      7|    }
   59|       |
   60|     27|    fn dfs_finish_order(
   61|     27|        graph: &ArraySeqStEphS<ArraySeqStEphS<N>>,
   62|     27|        visited: &mut ArraySeqStEphS<B>,
   63|     27|        result: &mut Vec<N>,
   64|     27|        vertex: N,
   65|     27|    ) {
   66|     27|        if *visited.nth(vertex) {
   67|      7|            return;
   68|     20|        }
   69|       |
   70|     20|        let _ = visited.set(vertex, true);
   71|     20|        let neighbors = graph.nth(vertex);
   72|       |
   73|     20|        for i in 0..neighbors.length() {
                          ^18
   74|     18|            let neighbor = *neighbors.nth(i);
   75|     18|            dfs_finish_order(graph, visited, result, neighbor);
   76|     18|        }
   77|       |
   78|     20|        result.insert(0, vertex);
   79|     27|    }
   80|       |
   81|      7|    fn transpose_graph(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>) -> ArraySeqStEphS<ArraySeqStEphS<N>> {
   82|      7|        let n = graph.length();
   83|      7|        let mut adj_vecs: Vec<Vec<N>> = vec![Vec::new(); n];
   84|       |
   85|     20|        for u in 0..n {
                                  ^7
   86|     20|            let neighbors = graph.nth(u);
   87|     20|            for i in 0..neighbors.length() {
                              ^18
   88|     18|                let v = *neighbors.nth(i);
   89|     18|                adj_vecs[v].push(u);
   90|     18|            }
   91|       |        }
   92|       |
   93|     20|        ArraySeqStEphS::tabulate(&|i| ArraySeqStEphS::from_vec(adj_vecs[i].clone()), n)
                      ^7                                                                           ^7
   94|      7|    }
   95|       |
   96|     30|    fn dfs_reach(
   97|     30|        graph: &ArraySeqStEphS<ArraySeqStEphS<N>>,
   98|     30|        visited: &mut ArraySeqStEphS<B>,
   99|     30|        component: &mut AVLTreeSetStEph<N>,
  100|     30|        vertex: N,
  101|     30|    ) {
  102|     30|        if *visited.nth(vertex) {
  103|     10|            return;
  104|     20|        }
  105|       |
  106|     20|        let _ = visited.set(vertex, true);
  107|     20|        component.insert(vertex);
  108|       |
  109|     20|        let neighbors = graph.nth(vertex);
  110|     20|        for i in 0..neighbors.length() {
                          ^18
  111|     18|            let neighbor = *neighbors.nth(i);
  112|     18|            dfs_reach(graph, visited, component, neighbor);
  113|     18|        }
  114|     30|    }
  115|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap55/SCCStPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Strongly Connected Components - Sequential Persistent (Chapter 55, Algorithm 55.18).
    3|       |//! Finds all strongly connected components using transpose and DFS.
    4|       |//! Work: O(|V| + |E|), Span: O(|V| + |E|).
    5|       |
    6|       |pub mod SCCStPer {
    7|       |
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::{ArraySeqStPerS, ArraySeqStPerTrait};
    9|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::{AVLTreeSeqStPerS, AVLTreeSeqStPerTrait};
   10|       |    use crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::*;
   11|       |    use crate::Types::Types::*;
   12|       |
   13|       |    pub trait SCCStPerTrait {
   14|       |        /// Finds strongly connected components in a directed graph
   15|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   16|       |        fn scc(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>) -> AVLTreeSeqStPerS<AVLTreeSetStPer<N>>;
   17|       |    }
   18|       |
   19|       |    /// Finds strongly connected components in a directed graph.
   20|       |    /// Returns sequence of components, each component is a set of vertices.
   21|      7|    pub fn scc(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>) -> AVLTreeSeqStPerS<AVLTreeSetStPer<N>> {
   22|      7|        let finish_order = compute_finish_order(graph);
   23|      7|        let transposed = transpose_graph(graph);
   24|       |
   25|      7|        let mut visited = AVLTreeSetStPer::empty();
   26|      7|        let mut components = AVLTreeSeqStPerS::empty();
   27|       |
   28|     20|        for i in 0..finish_order.length() {
                                  ^7           ^7
   29|     20|            let vertex = *finish_order.nth(i);
   30|     20|            if !visited.find(&vertex) {
   31|     12|                let (new_visited, component) = dfs_reach(&transposed, visited, vertex);
   32|     12|                visited = new_visited;
   33|     12|                if component.size() > 0 {
   34|     12|                    let mut vec = components.values_in_order();
   35|     12|                    vec.push(component);
   36|     12|                    components = AVLTreeSeqStPerS::from_vec(vec);
   37|     12|                }
                              ^0
   38|      8|            }
   39|       |        }
   40|      7|        components
   41|      7|    }
   42|       |
   43|      7|    fn compute_finish_order(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>) -> AVLTreeSeqStPerS<N> {
   44|      7|        let n = graph.length();
   45|      7|        let mut visited = AVLTreeSetStPer::empty();
   46|      7|        let mut result = Vec::new();
   47|       |
   48|     20|        for start in 0..n {
                                      ^7
   49|     20|            if !visited.find(&start) {
   50|      9|                let (new_visited, new_result) = dfs_finish_order(graph, visited, result, start);
   51|      9|                visited = new_visited;
   52|      9|                result = new_result;
   53|     11|            }
   54|       |        }
   55|      7|        AVLTreeSeqStPerS::from_vec(result)
   56|      7|    }
   57|       |
   58|     27|    fn dfs_finish_order(
   59|     27|        graph: &ArraySeqStPerS<ArraySeqStPerS<N>>,
   60|     27|        visited: AVLTreeSetStPer<N>,
   61|     27|        mut result: Vec<N>,
   62|     27|        vertex: N,
   63|     27|    ) -> (AVLTreeSetStPer<N>, Vec<N>) {
   64|     27|        if visited.find(&vertex) {
   65|      7|            return (visited, result);
   66|     20|        }
   67|       |
   68|     20|        let visited = visited.insert(vertex);
   69|     20|        let neighbors = graph.nth(vertex);
   70|       |
   71|     20|        let mut visited = visited;
   72|     20|        for i in 0..neighbors.length() {
                          ^18
   73|     18|            let neighbor = *neighbors.nth(i);
   74|     18|            let (new_visited, new_result) = dfs_finish_order(graph, visited, result, neighbor);
   75|     18|            visited = new_visited;
   76|     18|            result = new_result;
   77|     18|        }
   78|       |
   79|     20|        result.insert(0, vertex);
   80|     20|        (visited, result)
   81|     27|    }
   82|       |
   83|      7|    fn transpose_graph(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>) -> ArraySeqStPerS<ArraySeqStPerS<N>> {
   84|      7|        let n = graph.length();
   85|      7|        let mut adj_vecs: Vec<Vec<N>> = vec![Vec::new(); n];
   86|       |
   87|     20|        for u in 0..n {
                                  ^7
   88|     20|            let neighbors = graph.nth(u);
   89|     20|            for i in 0..neighbors.length() {
                              ^18
   90|     18|                let v = *neighbors.nth(i);
   91|     18|                adj_vecs[v].push(u);
   92|     18|            }
   93|       |        }
   94|       |
   95|     20|        ArraySeqStPerS::tabulate(&|i| ArraySeqStPerS::from_vec(adj_vecs[i].clone()), n)
                      ^7                                                                           ^7
   96|      7|    }
   97|       |
   98|     30|    fn dfs_reach(
   99|     30|        graph: &ArraySeqStPerS<ArraySeqStPerS<N>>,
  100|     30|        visited: AVLTreeSetStPer<N>,
  101|     30|        vertex: N,
  102|     30|    ) -> (AVLTreeSetStPer<N>, AVLTreeSetStPer<N>) {
  103|     30|        if visited.find(&vertex) {
  104|     10|            return (visited, AVLTreeSetStPer::empty());
  105|     20|        }
  106|       |
  107|     20|        let visited = visited.insert(vertex);
  108|     20|        let mut component = AVLTreeSetStPer::singleton(vertex);
  109|     20|        let neighbors = graph.nth(vertex);
  110|       |
  111|     20|        let mut visited = visited;
  112|     20|        for i in 0..neighbors.length() {
                          ^18
  113|     18|            let neighbor = *neighbors.nth(i);
  114|     18|            let (new_visited, sub_component) = dfs_reach(graph, visited, neighbor);
  115|     18|            visited = new_visited;
  116|     18|            component = component.union(&sub_component);
  117|     18|        }
  118|       |
  119|     20|        (visited, component)
  120|     30|    }
  121|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap55/TopoSortStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Topological Sort - Sequential Ephemeral (Chapter 55, Algorithm 55.13).
    3|       |//! Sorts DAG vertices in topological order using ephemeral structures.
    4|       |//! Work: O(|V| + |E|), Span: O(|V| + |E|).
    5|       |
    6|       |pub mod TopoSortStEph {
    7|       |
    8|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::{ArraySeqStEphS, ArraySeqStEphTrait};
    9|       |    use crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::*;
   10|       |    use crate::Types::Types::*;
   11|       |
   12|       |    pub trait TopoSortStEphTrait {
   13|       |        /// Computes topological sort of a DAG
   14|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   15|       |        fn topo_sort(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>) -> AVLTreeSeqStEphS<N>;
   16|       |    }
   17|       |
   18|       |    /// Computes topological sort of a DAG.
   19|       |    /// Returns Some(sequence) if graph is acyclic, None if contains a cycle.
   20|      7|    pub fn topological_sort_opt(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>) -> Option<AVLTreeSeqStEphS<N>> {
   21|      7|        let n = graph.length();
   22|      7|        let mut visited = ArraySeqStEphS::tabulate(&|_| false, n);
   23|      7|        let mut rec_stack = ArraySeqStEphS::tabulate(&|_| false, n);
   24|      7|        let mut result = Vec::new();
   25|       |
   26|     14|        for start in 0..n {
                                      ^7
   27|     14|            if !*visited.nth(start) {
   28|      7|                if !dfs_finish_order_cycle_detect(graph, &mut visited, &mut rec_stack, &mut result, start) {
   29|      2|                    return None; // Cycle detected
   30|      5|                }
   31|      7|            }
   32|       |        }
   33|      5|        Some(AVLTreeSeqStEphS::from_vec(result))
   34|      7|    }
   35|       |
   36|       |    /// Computes topological sort of a DAG.
   37|       |    /// Returns sequence of vertices in topological order (respecting edge directions).
   38|      0|    pub fn topo_sort(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>) -> AVLTreeSeqStEphS<N> {
   39|      0|        let n = graph.length();
   40|      0|        let mut visited = ArraySeqStEphS::tabulate(&|_| false, n);
   41|      0|        let mut result = Vec::new();
   42|       |
   43|      0|        for start in 0..n {
   44|      0|            if !*visited.nth(start) {
   45|      0|                dfs_finish_order(graph, &mut visited, &mut result, start);
   46|      0|            }
   47|       |        }
   48|      0|        AVLTreeSeqStEphS::from_vec(result)
   49|      0|    }
   50|       |
   51|     19|    fn dfs_finish_order_cycle_detect(
   52|     19|        graph: &ArraySeqStEphS<ArraySeqStEphS<N>>,
   53|     19|        visited: &mut ArraySeqStEphS<B>,
   54|     19|        rec_stack: &mut ArraySeqStEphS<B>,
   55|     19|        result: &mut Vec<N>,
   56|     19|        vertex: N,
   57|     19|    ) -> bool {
   58|     19|        if *rec_stack.nth(vertex) {
   59|      2|            return false; // Cycle detected
   60|     17|        }
   61|     17|        if *visited.nth(vertex) {
   62|      1|            return true;
   63|     16|        }
   64|       |
   65|     16|        let _ = visited.set(vertex, true);
   66|     16|        let _ = rec_stack.set(vertex, true);
   67|     16|        let neighbors = graph.nth(vertex);
   68|       |
   69|     16|        for i in 0..neighbors.length() {
                          ^12
   70|     12|            let neighbor = *neighbors.nth(i);
   71|     12|            if !dfs_finish_order_cycle_detect(graph, visited, rec_stack, result, neighbor) {
   72|      4|                return false; // Cycle detected
   73|      8|            }
   74|       |        }
   75|       |
   76|     12|        let _ = rec_stack.set(vertex, false);
   77|     12|        result.insert(0, vertex);
   78|     12|        true
   79|     19|    }
   80|       |
   81|      0|    fn dfs_finish_order(
   82|      0|        graph: &ArraySeqStEphS<ArraySeqStEphS<N>>,
   83|      0|        visited: &mut ArraySeqStEphS<B>,
   84|      0|        result: &mut Vec<N>,
   85|      0|        vertex: N,
   86|      0|    ) {
   87|      0|        if *visited.nth(vertex) {
   88|      0|            return;
   89|      0|        }
   90|       |
   91|      0|        let _ = visited.set(vertex, true);
   92|      0|        let neighbors = graph.nth(vertex);
   93|       |
   94|      0|        for i in 0..neighbors.length() {
   95|      0|            let neighbor = *neighbors.nth(i);
   96|      0|            dfs_finish_order(graph, visited, result, neighbor);
   97|      0|        }
   98|       |
   99|      0|        result.insert(0, vertex);
  100|      0|    }
  101|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap55/TopoSortStPer.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Topological Sort - Sequential Persistent (Chapter 55, Algorithm 55.13).
    3|       |//! Sorts DAG vertices in topological order using decreasing finish times.
    4|       |//! Work: O(|V| + |E|), Span: O(|V| + |E|).
    5|       |
    6|       |pub mod TopoSortStPer {
    7|       |
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::{ArraySeqStPerS, ArraySeqStPerTrait};
    9|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::{AVLTreeSeqStPerS, AVLTreeSeqStPerTrait};
   10|       |    use crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::*;
   11|       |    use crate::Types::Types::*;
   12|       |
   13|       |    pub trait TopoSortStPerTrait {
   14|       |        /// Computes topological sort of a DAG
   15|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   16|       |        fn topo_sort(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>) -> AVLTreeSeqStPerS<N>;
   17|       |    }
   18|       |
   19|       |    /// Computes topological sort of a DAG.
   20|       |    /// Returns Some(sequence) if graph is acyclic, None if contains a cycle.
   21|      7|    pub fn topological_sort_opt(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>) -> Option<AVLTreeSeqStPerS<N>> {
   22|      7|        let n = graph.length();
   23|      7|        let mut visited = AVLTreeSetStPer::empty();
   24|      7|        let mut rec_stack = AVLTreeSetStPer::empty();
   25|      7|        let mut result = Vec::new();
   26|       |
   27|     14|        for start in 0..n {
                                      ^7
   28|     14|            if !visited.find(&start) {
   29|      7|                match dfs_finish_order_cycle_detect(graph, visited, rec_stack, result, start) {
   30|      5|                    Some((new_visited, new_rec_stack, new_result)) => {
   31|      5|                        visited = new_visited;
   32|      5|                        rec_stack = new_rec_stack;
   33|      5|                        result = new_result;
   34|      5|                    }
   35|      2|                    None => return None, // Cycle detected
   36|       |                }
   37|      7|            }
   38|       |        }
   39|      5|        Some(AVLTreeSeqStPerS::from_vec(result))
   40|      7|    }
   41|       |
   42|       |    /// Computes topological sort of a DAG.
   43|       |    /// Returns sequence of vertices in topological order (respecting edge directions).
   44|      0|    pub fn topo_sort(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>) -> AVLTreeSeqStPerS<N> {
   45|      0|        let n = graph.length();
   46|      0|        let mut visited = AVLTreeSetStPer::empty();
   47|      0|        let mut result = Vec::new();
   48|       |
   49|      0|        for start in 0..n {
   50|      0|            if !visited.find(&start) {
   51|      0|                let (new_visited, new_result) = dfs_finish_order(graph, visited, result, start);
   52|      0|                visited = new_visited;
   53|      0|                result = new_result;
   54|      0|            }
   55|       |        }
   56|      0|        AVLTreeSeqStPerS::from_vec(result)
   57|      0|    }
   58|       |
   59|     19|    fn dfs_finish_order_cycle_detect(
   60|     19|        graph: &ArraySeqStPerS<ArraySeqStPerS<N>>,
   61|     19|        visited: AVLTreeSetStPer<N>,
   62|     19|        rec_stack: AVLTreeSetStPer<N>,
   63|     19|        mut result: Vec<N>,
   64|     19|        vertex: N,
   65|     19|    ) -> Option<(AVLTreeSetStPer<N>, AVLTreeSetStPer<N>, Vec<N>)> {
   66|     19|        if rec_stack.find(&vertex) {
   67|      2|            return None; // Cycle detected
   68|     17|        }
   69|     17|        if visited.find(&vertex) {
   70|      1|            return Some((visited, rec_stack, result));
   71|     16|        }
   72|       |
   73|     16|        let visited = visited.insert(vertex);
   74|     16|        let rec_stack = rec_stack.insert(vertex);
   75|     16|        let neighbors = graph.nth(vertex);
   76|       |
   77|     16|        let mut visited = visited;
   78|     16|        let mut rec_stack = rec_stack;
   79|     16|        for i in 0..neighbors.length() {
                          ^12
   80|     12|            let neighbor = *neighbors.nth(i);
   81|     12|            match dfs_finish_order_cycle_detect(graph, visited, rec_stack, result, neighbor) {
   82|      8|                Some((new_visited, new_rec_stack, new_result)) => {
   83|      8|                    visited = new_visited;
   84|      8|                    rec_stack = new_rec_stack;
   85|      8|                    result = new_result;
   86|      8|                }
   87|      4|                None => return None, // Cycle detected
   88|       |            }
   89|       |        }
   90|       |
   91|     12|        let rec_stack = rec_stack.delete(&vertex);
   92|     12|        result.insert(0, vertex);
   93|     12|        Some((visited, rec_stack, result))
   94|     19|    }
   95|       |
   96|      0|    fn dfs_finish_order(
   97|      0|        graph: &ArraySeqStPerS<ArraySeqStPerS<N>>,
   98|      0|        visited: AVLTreeSetStPer<N>,
   99|      0|        mut result: Vec<N>,
  100|      0|        vertex: N,
  101|      0|    ) -> (AVLTreeSetStPer<N>, Vec<N>) {
  102|      0|        if visited.find(&vertex) {
  103|      0|            return (visited, result);
  104|      0|        }
  105|       |
  106|      0|        let visited = visited.insert(vertex);
  107|      0|        let neighbors = graph.nth(vertex);
  108|       |
  109|      0|        let mut visited = visited;
  110|      0|        for i in 0..neighbors.length() {
  111|      0|            let neighbor = *neighbors.nth(i);
  112|      0|            let (new_visited, new_result) = dfs_finish_order(graph, visited, result, neighbor);
  113|      0|            visited = new_visited;
  114|      0|            result = new_result;
  115|      0|        }
  116|       |
  117|      0|        result.insert(0, vertex);
  118|      0|        (visited, result)
  119|      0|    }
  120|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap56/AllPairsResultStEphFloat.rs:
    1|       |//! Copyright  2025 APAS-VERUS. All rights reserved.
    2|       |//!
    3|       |//! All-Pairs Shortest Path Result Structure - Sequential Ephemeral (Float Weights)
    4|       |//!
    5|       |//! Data structure for storing the result of all-pairs shortest path algorithms
    6|       |//! with floating-point edge weights. Stores distance matrix and predecessor matrix for path reconstruction.
    7|       |//!
    8|       |//! Uses ephemeral array sequences for efficient in-place updates.
    9|       |//! Uses `OrderedF64` (OrderedFloat<f64>) for weights to ensure Eq/Hash traits.
   10|       |//!
   11|       |//! **Algorithmic Analysis:**
   12|       |//! - `new`: Work O(n), Span O(n) for n vertices
   13|       |//! - `get_distance`: Work O(1), Span O(1)
   14|       |//! - `extract_path`: Work O(k), Span O(k) where k is path length
   15|       |
   16|       |pub mod AllPairsResultStEphFloat {
   17|       |
   18|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS;
   19|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS;
   20|       |    use crate::Types::Types::*;
   21|       |    use ordered_float::OrderedFloat;
   22|       |
   23|       |    const UNREACHABLE: OrderedF64 = OrderedFloat(f64::INFINITY);
   24|       |    const NO_PREDECESSOR: usize = usize::MAX;
   25|       |
   26|       |    /// Trait for all-pairs shortest path result operations
   27|       |    pub trait AllPairsResultStEphFloatTrait {
   28|       |        /// Create new all-pairs result
   29|       |        /// APAS: Work (n), Span (n)
   30|       |        fn new(n: N) -> Self;
   31|       |
   32|       |        /// Get distance between vertices
   33|       |        /// APAS: Work (1), Span (1)
   34|       |        fn distance(&self, u: N, v: N) -> Option<OrderedF64>;
   35|       |
   36|       |        /// Check if path exists
   37|       |        /// APAS: Work (1), Span (1)
   38|       |        fn has_path(&self, u: N, v: N) -> B;
   39|       |    }
   40|       |
   41|       |    /// Result structure for all-pairs shortest paths with floating-point weights.
   42|       |    pub struct AllPairsResultStEphFloat {
   43|       |        /// Distance matrix: distances.nth(u).nth(v) is the distance from u to v.
   44|       |        pub distances: ArraySeqStEphS<ArraySeqStEphS<OrderedF64>>,
   45|       |        /// Predecessor matrix: predecessors.nth(u).nth(v) is the predecessor of v on shortest path from u.
   46|       |        pub predecessors: ArraySeqStEphS<ArraySeqStEphS<usize>>,
   47|       |        /// Number of vertices.
   48|       |        pub n: usize,
   49|       |    }
   50|       |
   51|       |    impl AllPairsResultStEphFloat {
   52|       |        /// Creates a new all-pairs result structure initialized for n vertices.
   53|       |        /// All distances are set to UNREACHABLE except diagonal (0.0), all predecessors to NO_PREDECESSOR.
   54|      5|        pub fn new(n: usize) -> Self {
   55|      5|            let mut dist_matrix = Vec::with_capacity(n);
   56|     16|            for i in 0..n {
                                      ^5
   57|     16|                let mut row = vec![UNREACHABLE; n];
   58|     16|                row[i] = OrderedFloat(0.0);
   59|     16|                dist_matrix.push(ArraySeqStEphS::from_vec(row));
   60|     16|            }
   61|      5|            let distances = ArraySeqStEphS::from_vec(dist_matrix);
   62|       |
   63|      5|            let pred_matrix = vec![ArraySeqStEphS::new(n, NO_PREDECESSOR); n];
   64|      5|            let predecessors = ArraySeqStEphS::from_vec(pred_matrix);
   65|      5|            AllPairsResultStEphFloat {
   66|      5|                distances,
   67|      5|                predecessors,
   68|      5|                n,
   69|      5|            }
   70|      5|        }
   71|       |
   72|       |        /// Returns the distance from vertex u to vertex v.
   73|     48|        pub fn get_distance(&self, u: usize, v: usize) -> OrderedF64 {
   74|     48|            if u >= self.n || v >= self.n {
   75|      0|                return UNREACHABLE;
   76|     48|            }
   77|     48|            *self.distances.nth(u).nth(v)
   78|     48|        }
   79|       |
   80|       |        /// Sets the distance from vertex u to vertex v.
   81|      5|        pub fn set_distance(&mut self, u: usize, v: usize, dist: OrderedF64) {
   82|      5|            if u < self.n && v < self.n {
   83|      5|                let mut row = self.distances.nth(u).clone();
   84|      5|                let _ = row.set(v, dist);
   85|      5|                let _ = self.distances.set(u, row);
   86|      5|            }
                          ^0
   87|      5|        }
   88|       |
   89|       |        /// Returns the predecessor of vertex v in the shortest path from u.
   90|      2|        pub fn get_predecessor(&self, u: usize, v: usize) -> Option<usize> {
   91|      2|            if u >= self.n || v >= self.n {
   92|      0|                return None;
   93|      2|            }
   94|      2|            let pred = *self.predecessors.nth(u).nth(v);
   95|      2|            if pred == NO_PREDECESSOR { None } else { Some(pred) }
                                                      ^0
   96|      2|        }
   97|       |
   98|       |        /// Sets the predecessor of vertex v in the shortest path from u.
   99|      5|        pub fn set_predecessor(&mut self, u: usize, v: usize, pred: usize) {
  100|      5|            if u < self.n && v < self.n {
  101|      5|                let mut row = self.predecessors.nth(u).clone();
  102|      5|                let _ = row.set(v, pred);
  103|      5|                let _ = self.predecessors.set(u, row);
  104|      5|            }
                          ^0
  105|      5|        }
  106|       |
  107|       |        /// Checks if vertex v is reachable from vertex u.
  108|      4|        pub fn is_reachable(&self, u: usize, v: usize) -> bool { self.get_distance(u, v).is_finite() }
  109|       |
  110|       |        /// Extracts the shortest path from u to v by following predecessors.
  111|       |        /// Returns None if v is unreachable from u, otherwise returns the path as a sequence.
  112|      2|        pub fn extract_path(&self, u: usize, v: usize) -> Option<ArraySeqStPerS<usize>> {
  113|      2|            if u == v {
  114|      0|                return Some(ArraySeqStPerS::from_vec(vec![u]));
  115|      2|            }
  116|      2|            if !self.is_reachable(u, v) {
  117|      1|                return None;
  118|      1|            }
  119|       |
  120|      1|            let mut path = Vec::new();
  121|      1|            let mut current = v;
  122|      1|            path.push(current);
  123|       |
  124|      4|            while current != u {
  125|      3|                let pred = *self.predecessors.nth(u).nth(current);
  126|      3|                if pred == NO_PREDECESSOR {
  127|      0|                    return None;
  128|      3|                }
  129|      3|                path.push(pred);
  130|      3|                current = pred;
  131|       |            }
  132|       |
  133|      1|            path.reverse();
  134|      1|            Some(ArraySeqStPerS::from_vec(path))
  135|      2|        }
  136|       |    }
  137|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap56/AllPairsResultStEphInt.rs:
    1|       |//! Copyright  2025 APAS-VERUS. All rights reserved.
    2|       |//!
    3|       |//! All-Pairs Shortest Path Result Structure - Sequential Ephemeral (Integer Weights)
    4|       |//!
    5|       |//! Data structure for storing the result of all-pairs shortest path algorithms
    6|       |//! with integer edge weights. Stores distance matrix and predecessor matrix for path reconstruction.
    7|       |//!
    8|       |//! Uses ephemeral array sequences for efficient in-place updates.
    9|       |//!
   10|       |//! **Algorithmic Analysis:**
   11|       |//! - `new`: Work O(n), Span O(n) for n vertices
   12|       |//! - `get_distance`: Work O(1), Span O(1)
   13|       |//! - `extract_path`: Work O(k), Span O(k) where k is path length
   14|       |
   15|       |pub mod AllPairsResultStEphInt {
   16|       |
   17|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS;
   18|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS;
   19|       |    use crate::Types::Types::*;
   20|       |
   21|       |    const UNREACHABLE: i64 = i64::MAX;
   22|       |    const NO_PREDECESSOR: usize = usize::MAX;
   23|       |
   24|       |    /// Trait for all-pairs shortest path result operations
   25|       |    pub trait AllPairsResultStEphIntTrait {
   26|       |        /// Create new all-pairs result
   27|       |        /// APAS: Work (n), Span (n)
   28|       |        fn new(n: N) -> Self;
   29|       |
   30|       |        /// Get distance between vertices
   31|       |        /// APAS: Work (1), Span (1)
   32|       |        fn distance(&self, u: N, v: N) -> Option<i32>;
   33|       |
   34|       |        /// Check if path exists
   35|       |        /// APAS: Work (1), Span (1)
   36|       |        fn has_path(&self, u: N, v: N) -> B;
   37|       |    }
   38|       |
   39|       |    /// Result structure for all-pairs shortest paths with integer weights.
   40|       |    pub struct AllPairsResultStEphInt {
   41|       |        /// Distance matrix: distances.nth(u).nth(v) is the distance from u to v.
   42|       |        pub distances: ArraySeqStEphS<ArraySeqStEphS<i64>>,
   43|       |        /// Predecessor matrix: predecessors.nth(u).nth(v) is the predecessor of v on shortest path from u.
   44|       |        pub predecessors: ArraySeqStEphS<ArraySeqStEphS<usize>>,
   45|       |        /// Number of vertices.
   46|       |        pub n: usize,
   47|       |    }
   48|       |
   49|       |    impl AllPairsResultStEphInt {
   50|       |        /// Creates a new all-pairs result structure initialized for n vertices.
   51|       |        /// All distances are set to UNREACHABLE except diagonal (0), all predecessors to NO_PREDECESSOR.
   52|      5|        pub fn new(n: usize) -> Self {
   53|      5|            let mut dist_matrix = Vec::with_capacity(n);
   54|     16|            for i in 0..n {
                                      ^5
   55|     16|                let mut row = vec![UNREACHABLE; n];
   56|     16|                row[i] = 0;
   57|     16|                dist_matrix.push(ArraySeqStEphS::from_vec(row));
   58|     16|            }
   59|      5|            let distances = ArraySeqStEphS::from_vec(dist_matrix);
   60|       |
   61|      5|            let pred_matrix = vec![ArraySeqStEphS::new(n, NO_PREDECESSOR); n];
   62|      5|            let predecessors = ArraySeqStEphS::from_vec(pred_matrix);
   63|      5|            AllPairsResultStEphInt {
   64|      5|                distances,
   65|      5|                predecessors,
   66|      5|                n,
   67|      5|            }
   68|      5|        }
   69|       |
   70|       |        /// Returns the distance from vertex u to vertex v.
   71|     64|        pub fn get_distance(&self, u: usize, v: usize) -> i64 {
   72|     64|            if u >= self.n || v >= self.n {
   73|      0|                return UNREACHABLE;
   74|     64|            }
   75|     64|            *self.distances.nth(u).nth(v)
   76|     64|        }
   77|       |
   78|       |        /// Sets the distance from vertex u to vertex v.
   79|      5|        pub fn set_distance(&mut self, u: usize, v: usize, dist: i64) {
   80|      5|            if u < self.n && v < self.n {
   81|      5|                let mut row = self.distances.nth(u).clone();
   82|      5|                let _ = row.set(v, dist);
   83|      5|                let _ = self.distances.set(u, row);
   84|      5|            }
                          ^0
   85|      5|        }
   86|       |
   87|       |        /// Returns the predecessor of vertex v in the shortest path from u.
   88|      2|        pub fn get_predecessor(&self, u: usize, v: usize) -> Option<usize> {
   89|      2|            if u >= self.n || v >= self.n {
   90|      0|                return None;
   91|      2|            }
   92|      2|            let pred = *self.predecessors.nth(u).nth(v);
   93|      2|            if pred == NO_PREDECESSOR { None } else { Some(pred) }
                                                      ^0
   94|      2|        }
   95|       |
   96|       |        /// Sets the predecessor of vertex v in the shortest path from u.
   97|      5|        pub fn set_predecessor(&mut self, u: usize, v: usize, pred: usize) {
   98|      5|            if u < self.n && v < self.n {
   99|      5|                let mut row = self.predecessors.nth(u).clone();
  100|      5|                let _ = row.set(v, pred);
  101|      5|                let _ = self.predecessors.set(u, row);
  102|      5|            }
                          ^0
  103|      5|        }
  104|       |
  105|       |        /// Checks if vertex v is reachable from vertex u.
  106|      4|        pub fn is_reachable(&self, u: usize, v: usize) -> bool { self.get_distance(u, v) != UNREACHABLE }
  107|       |
  108|       |        /// Extracts the shortest path from u to v by following predecessors.
  109|       |        /// Returns None if v is unreachable from u, otherwise returns the path as a sequence.
  110|      2|        pub fn extract_path(&self, u: usize, v: usize) -> Option<ArraySeqStPerS<usize>> {
  111|      2|            if u == v {
  112|      0|                return Some(ArraySeqStPerS::from_vec(vec![u]));
  113|      2|            }
  114|      2|            if !self.is_reachable(u, v) {
  115|      1|                return None;
  116|      1|            }
  117|       |
  118|      1|            let mut path = Vec::new();
  119|      1|            let mut current = v;
  120|      1|            path.push(current);
  121|       |
  122|      4|            while current != u {
  123|      3|                let pred = *self.predecessors.nth(u).nth(current);
  124|      3|                if pred == NO_PREDECESSOR {
  125|      0|                    return None;
  126|      3|                }
  127|      3|                path.push(pred);
  128|      3|                current = pred;
  129|       |            }
  130|       |
  131|      1|            path.reverse();
  132|      1|            Some(ArraySeqStPerS::from_vec(path))
  133|      2|        }
  134|       |    }
  135|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap56/AllPairsResultStPerFloat.rs:
    1|       |//! Copyright  2025 APAS-VERUS. All rights reserved.
    2|       |//!
    3|       |//! All-Pairs Shortest Path Result Structure - Sequential Persistent (Float Weights)
    4|       |//!
    5|       |//! Data structure for storing the result of all-pairs shortest path algorithms
    6|       |//! with floating-point edge weights. Stores distance matrix and predecessor matrix for path reconstruction.
    7|       |//!
    8|       |//! Uses persistent array sequences for functional-style immutability.
    9|       |//! Uses `OrderedF64` (OrderedFloat<f64>) for weights to ensure Eq/Hash traits.
   10|       |//!
   11|       |//! **Algorithmic Analysis:**
   12|       |//! - `new`: Work O(n), Span O(n) for n vertices
   13|       |//! - `get_distance`: Work O(1), Span O(1)
   14|       |//! - `extract_path`: Work O(k), Span O(k) where k is path length
   15|       |
   16|       |pub mod AllPairsResultStPerFloat {
   17|       |
   18|       |    use crate::Chap19::ArraySeqStPer::ArraySeqStPer::*;
   19|       |    use crate::Types::Types::*;
   20|       |    use ordered_float::OrderedFloat;
   21|       |
   22|       |    const UNREACHABLE: OrderedF64 = OrderedFloat(f64::INFINITY);
   23|       |    const NO_PREDECESSOR: usize = usize::MAX;
   24|       |
   25|       |    /// Trait for all-pairs shortest path result operations
   26|       |    pub trait AllPairsResultStPerFloatTrait {
   27|       |        /// Create new all-pairs result
   28|       |        /// APAS: Work (n), Span (n)
   29|       |        fn new(n: N) -> Self;
   30|       |
   31|       |        /// Get distance between vertices
   32|       |        /// APAS: Work (1), Span (1)
   33|       |        fn distance(&self, u: N, v: N) -> Option<OrderedF64>;
   34|       |
   35|       |        /// Check if path exists
   36|       |        /// APAS: Work (1), Span (1)
   37|       |        fn has_path(&self, u: N, v: N) -> B;
   38|       |    }
   39|       |
   40|       |    /// Result structure for all-pairs shortest paths with floating-point weights (persistent).
   41|       |    pub struct AllPairsResultStPerFloat {
   42|       |        /// Distance matrix: distances.nth(u).nth(v) is the distance from u to v.
   43|       |        pub distances: ArraySeqStPerS<ArraySeqStPerS<OrderedF64>>,
   44|       |        /// Predecessor matrix: predecessors.nth(u).nth(v) is the predecessor of v on shortest path from u.
   45|       |        pub predecessors: ArraySeqStPerS<ArraySeqStPerS<usize>>,
   46|       |        /// Number of vertices.
   47|       |        pub n: usize,
   48|       |    }
   49|       |
   50|       |    impl AllPairsResultStPerFloat {
   51|       |        /// Creates a new all-pairs result structure initialized for n vertices.
   52|       |        /// All distances are set to UNREACHABLE except diagonal (0.0), all predecessors to NO_PREDECESSOR.
   53|      5|        pub fn new(n: usize) -> Self {
   54|      5|            let distances = ArraySeqStPerS::tabulate(
   55|     52|                &|i| ArraySeqStPerS::tabulate(&|j| if i == j { OrderedFloat(0.0) } else { UNREACHABLE }, n),
                                   ^16                                       ^16                        ^36            ^16
   56|      5|                n,
   57|       |            );
   58|     16|            let predecessors = ArraySeqStPerS::tabulate(&|_| ArraySeqStPerS::tabulate(&|_| NO_PREDECESSOR, n), n);
                              ^5             ^5                                                                              ^5
   59|      5|            AllPairsResultStPerFloat {
   60|      5|                distances,
   61|      5|                predecessors,
   62|      5|                n,
   63|      5|            }
   64|      5|        }
   65|       |
   66|       |        /// Returns the distance from vertex u to vertex v.
   67|      8|        pub fn get_distance(&self, u: usize, v: usize) -> OrderedF64 {
   68|      8|            if u >= self.n || v >= self.n {
   69|      0|                return UNREACHABLE;
   70|      8|            }
   71|      8|            self.distances.nth(u).nth(v).clone()
   72|      8|        }
   73|       |
   74|       |        /// Sets the distance from vertex u to vertex v, returning a new structure.
   75|      5|        pub fn set_distance(self, u: usize, v: usize, dist: OrderedF64) -> Self {
   76|      5|            if u >= self.n || v >= self.n {
   77|      0|                return self;
   78|      5|            }
   79|      5|            let updated_row = ArraySeqStPerS::update(self.distances.nth(u), v, dist);
   80|      5|            AllPairsResultStPerFloat {
   81|      5|                distances: ArraySeqStPerS::update(&self.distances, u, updated_row),
   82|      5|                predecessors: self.predecessors,
   83|      5|                n: self.n,
   84|      5|            }
   85|      5|        }
   86|       |
   87|       |        /// Returns the predecessor of vertex v in the shortest path from u.
   88|      2|        pub fn get_predecessor(&self, u: usize, v: usize) -> Option<usize> {
   89|      2|            if u >= self.n || v >= self.n {
   90|      0|                return None;
   91|      2|            }
   92|      2|            let pred = self.predecessors.nth(u).nth(v).clone();
   93|      2|            if pred == NO_PREDECESSOR { None } else { Some(pred) }
                                                      ^0
   94|      2|        }
   95|       |
   96|       |        /// Sets the predecessor of vertex v in the shortest path from u, returning a new structure.
   97|      5|        pub fn set_predecessor(self, u: usize, v: usize, pred: usize) -> Self {
   98|      5|            if u >= self.n || v >= self.n {
   99|      0|                return self;
  100|      5|            }
  101|      5|            let updated_row = ArraySeqStPerS::update(self.predecessors.nth(u), v, pred);
  102|      5|            AllPairsResultStPerFloat {
  103|      5|                distances: self.distances,
  104|      5|                predecessors: ArraySeqStPerS::update(&self.predecessors, u, updated_row),
  105|      5|                n: self.n,
  106|      5|            }
  107|      5|        }
  108|       |
  109|       |        /// Checks if vertex v is reachable from vertex u.
  110|      4|        pub fn is_reachable(&self, u: usize, v: usize) -> bool { self.get_distance(u, v).is_finite() }
  111|       |
  112|       |        /// Extracts the shortest path from u to v by following predecessors.
  113|       |        /// Returns None if v is unreachable from u, otherwise returns the path as a sequence.
  114|      2|        pub fn extract_path(&self, u: usize, v: usize) -> Option<ArraySeqStPerS<usize>> {
  115|      2|            if u == v {
  116|      0|                return Some(ArraySeqStPerS::from_vec(vec![u]));
  117|      2|            }
  118|      2|            if !self.is_reachable(u, v) {
  119|      1|                return None;
  120|      1|            }
  121|       |
  122|      1|            let mut path = Vec::new();
  123|      1|            let mut current = v;
  124|      1|            path.push(current);
  125|       |
  126|      4|            while current != u {
  127|      3|                let pred = *self.predecessors.nth(u).nth(current);
  128|      3|                if pred == NO_PREDECESSOR {
  129|      0|                    return None;
  130|      3|                }
  131|      3|                path.push(pred);
  132|      3|                current = pred;
  133|       |            }
  134|       |
  135|      1|            path.reverse();
  136|      1|            Some(ArraySeqStPerS::from_vec(path))
  137|      2|        }
  138|       |    }
  139|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap56/AllPairsResultStPerInt.rs:
    1|       |//! Copyright  2025 APAS-VERUS. All rights reserved.
    2|       |//!
    3|       |//! All-Pairs Shortest Path Result Structure - Sequential Persistent (Integer Weights)
    4|       |//!
    5|       |//! Data structure for storing the result of all-pairs shortest path algorithms
    6|       |//! with integer edge weights. Stores distance matrix and predecessor matrix for path reconstruction.
    7|       |//!
    8|       |//! Uses persistent array sequences for functional-style immutability.
    9|       |//!
   10|       |//! **Algorithmic Analysis:**
   11|       |//! - `new`: Work O(n), Span O(n) for n vertices
   12|       |//! - `get_distance`: Work O(1), Span O(1)
   13|       |//! - `extract_path`: Work O(k), Span O(k) where k is path length
   14|       |
   15|       |pub mod AllPairsResultStPerInt {
   16|       |
   17|       |    use crate::Chap19::ArraySeqStPer::ArraySeqStPer::*;
   18|       |    use crate::Types::Types::*;
   19|       |
   20|       |    const UNREACHABLE: i64 = i64::MAX;
   21|       |    const NO_PREDECESSOR: usize = usize::MAX;
   22|       |
   23|       |    /// Trait for all-pairs shortest path result operations
   24|       |    pub trait AllPairsResultStPerIntTrait {
   25|       |        /// Create new all-pairs result
   26|       |        /// APAS: Work (n), Span (n)
   27|       |        fn new(n: N) -> Self;
   28|       |
   29|       |        /// Get distance between vertices
   30|       |        /// APAS: Work (1), Span (1)
   31|       |        fn distance(&self, u: N, v: N) -> Option<i32>;
   32|       |
   33|       |        /// Check if path exists
   34|       |        /// APAS: Work (1), Span (1)
   35|       |        fn has_path(&self, u: N, v: N) -> B;
   36|       |    }
   37|       |
   38|       |    /// Result structure for all-pairs shortest paths with integer weights (persistent).
   39|       |    pub struct AllPairsResultStPerInt {
   40|       |        /// Distance matrix: distances.nth(u).nth(v) is the distance from u to v.
   41|       |        pub distances: ArraySeqStPerS<ArraySeqStPerS<i64>>,
   42|       |        /// Predecessor matrix: predecessors.nth(u).nth(v) is the predecessor of v on shortest path from u.
   43|       |        pub predecessors: ArraySeqStPerS<ArraySeqStPerS<usize>>,
   44|       |        /// Number of vertices.
   45|       |        pub n: usize,
   46|       |    }
   47|       |
   48|       |    impl AllPairsResultStPerInt {
   49|       |        /// Creates a new all-pairs result structure initialized for n vertices.
   50|       |        /// All distances are set to UNREACHABLE except diagonal (0), all predecessors to NO_PREDECESSOR.
   51|      5|        pub fn new(n: usize) -> Self {
   52|      5|            let distances = ArraySeqStPerS::tabulate(
   53|     52|                &|i| ArraySeqStPerS::tabulate(&|j| if i == j { 0 } else { UNREACHABLE }, n),
                                   ^16                                       ^16        ^36            ^16
   54|      5|                n,
   55|       |            );
   56|     16|            let predecessors = ArraySeqStPerS::tabulate(&|_| ArraySeqStPerS::tabulate(&|_| NO_PREDECESSOR, n), n);
                              ^5             ^5                                                                              ^5
   57|      5|            AllPairsResultStPerInt {
   58|      5|                distances,
   59|      5|                predecessors,
   60|      5|                n,
   61|      5|            }
   62|      5|        }
   63|       |
   64|       |        /// Returns the distance from vertex u to vertex v.
   65|      8|        pub fn get_distance(&self, u: usize, v: usize) -> i64 {
   66|      8|            if u >= self.n || v >= self.n {
   67|      0|                return UNREACHABLE;
   68|      8|            }
   69|      8|            self.distances.nth(u).nth(v).clone()
   70|      8|        }
   71|       |
   72|       |        /// Sets the distance from vertex u to vertex v, returning a new structure.
   73|      5|        pub fn set_distance(self, u: usize, v: usize, dist: i64) -> Self {
   74|      5|            if u >= self.n || v >= self.n {
   75|      0|                return self;
   76|      5|            }
   77|      5|            let updated_row = ArraySeqStPerS::update(self.distances.nth(u), v, dist);
   78|      5|            AllPairsResultStPerInt {
   79|      5|                distances: ArraySeqStPerS::update(&self.distances, u, updated_row),
   80|      5|                predecessors: self.predecessors,
   81|      5|                n: self.n,
   82|      5|            }
   83|      5|        }
   84|       |
   85|       |        /// Returns the predecessor of vertex v in the shortest path from u.
   86|      2|        pub fn get_predecessor(&self, u: usize, v: usize) -> Option<usize> {
   87|      2|            if u >= self.n || v >= self.n {
   88|      0|                return None;
   89|      2|            }
   90|      2|            let pred = self.predecessors.nth(u).nth(v).clone();
   91|      2|            if pred == NO_PREDECESSOR { None } else { Some(pred) }
                                                      ^0
   92|      2|        }
   93|       |
   94|       |        /// Sets the predecessor of vertex v in the shortest path from u, returning a new structure.
   95|      5|        pub fn set_predecessor(self, u: usize, v: usize, pred: usize) -> Self {
   96|      5|            if u >= self.n || v >= self.n {
   97|      0|                return self;
   98|      5|            }
   99|      5|            let updated_row = ArraySeqStPerS::update(self.predecessors.nth(u), v, pred);
  100|      5|            AllPairsResultStPerInt {
  101|      5|                distances: self.distances,
  102|      5|                predecessors: ArraySeqStPerS::update(&self.predecessors, u, updated_row),
  103|      5|                n: self.n,
  104|      5|            }
  105|      5|        }
  106|       |
  107|       |        /// Checks if vertex v is reachable from vertex u.
  108|      4|        pub fn is_reachable(&self, u: usize, v: usize) -> bool { self.get_distance(u, v) != UNREACHABLE }
  109|       |
  110|       |        /// Extracts the shortest path from u to v by following predecessors.
  111|       |        /// Returns None if v is unreachable from u, otherwise returns the path as a sequence.
  112|      2|        pub fn extract_path(&self, u: usize, v: usize) -> Option<ArraySeqStPerS<usize>> {
  113|      2|            if u == v {
  114|      0|                return Some(ArraySeqStPerS::from_vec(vec![u]));
  115|      2|            }
  116|      2|            if !self.is_reachable(u, v) {
  117|      1|                return None;
  118|      1|            }
  119|       |
  120|      1|            let mut path = Vec::new();
  121|      1|            let mut current = v;
  122|      1|            path.push(current);
  123|       |
  124|      4|            while current != u {
  125|      3|                let pred = *self.predecessors.nth(u).nth(current);
  126|      3|                if pred == NO_PREDECESSOR {
  127|      0|                    return None;
  128|      3|                }
  129|      3|                path.push(pred);
  130|      3|                current = pred;
  131|       |            }
  132|       |
  133|      1|            path.reverse();
  134|      1|            Some(ArraySeqStPerS::from_vec(path))
  135|      2|        }
  136|       |    }
  137|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap56/Example56_1.rs:
    1|       |//! Copyright  2025 APAS-VERUS. All rights reserved.
    2|       |//!
    3|       |//! Example 56.1 - Path Weight Computation
    4|       |//!
    5|       |//! Demonstrates computing the weight of a path in a weighted graph.
    6|       |//! Shows path weight calculation for simple paths with both positive and negative weights.
    7|       |
    8|       |pub mod Example56_1 {
    9|       |
   10|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS;
   11|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS;
   12|       |    use crate::Chap56::PathWeightUtilsStEph::PathWeightUtilsStEph::*;
   13|       |    use ordered_float::OrderedFloat;
   14|       |
   15|       |    pub trait Example56_1Trait {
   16|       |        /// Claude Work: O(1), Span: O(1)
   17|       |        /// Example demonstrating path weight computation with integer weights.
   18|       |        fn example_path_weight_int();
   19|       |
   20|       |        /// Claude Work: O(1), Span: O(1)
   21|       |        /// Example demonstrating path weight computation with floating-point weights.
   22|       |        fn example_path_weight_float();
   23|       |
   24|       |        /// Claude Work: O(1), Span: O(1)
   25|       |        /// Example with negative edge weights.
   26|       |        fn example_negative_weights();
   27|       |    }
   28|       |
   29|       |    /// Example demonstrating path weight computation with integer weights.
   30|      1|    pub fn example_path_weight_int() {
   31|      1|        let weights = ArraySeqStEphS::from_vec(vec![
   32|      1|            ArraySeqStEphS::from_vec(vec![0, 5, 10, i64::MAX]),
   33|      1|            ArraySeqStEphS::from_vec(vec![i64::MAX, 0, 3, i64::MAX]),
   34|      1|            ArraySeqStEphS::from_vec(vec![i64::MAX, i64::MAX, 0, 1]),
   35|      1|            ArraySeqStEphS::from_vec(vec![i64::MAX, i64::MAX, i64::MAX, 0]),
   36|       |        ]);
   37|       |
   38|      1|        let path = ArraySeqStPerS::from_vec(vec![0, 1, 2, 3]);
   39|      1|        match path_weight_int(&path, &weights) {
   40|      1|            | Some(w) => println!("Path 0123 has weight: {}", w),
   41|      0|            | None => println!("Invalid path"),
   42|       |        }
   43|      1|    }
   44|       |
   45|       |    /// Example demonstrating path weight computation with floating-point weights.
   46|      1|    pub fn example_path_weight_float() {
   47|      1|        let weights = ArraySeqStEphS::from_vec(vec![
   48|      1|            ArraySeqStEphS::from_vec(vec![
   49|      1|                OrderedFloat(0.0),
   50|      1|                OrderedFloat(2.5),
   51|      1|                OrderedFloat(5.0),
   52|      1|                OrderedFloat(f64::INFINITY),
   53|       |            ]),
   54|      1|            ArraySeqStEphS::from_vec(vec![
   55|      1|                OrderedFloat(f64::INFINITY),
   56|      1|                OrderedFloat(0.0),
   57|      1|                OrderedFloat(1.5),
   58|      1|                OrderedFloat(f64::INFINITY),
   59|       |            ]),
   60|      1|            ArraySeqStEphS::from_vec(vec![
   61|      1|                OrderedFloat(f64::INFINITY),
   62|      1|                OrderedFloat(f64::INFINITY),
   63|      1|                OrderedFloat(0.0),
   64|      1|                OrderedFloat(0.5),
   65|       |            ]),
   66|      1|            ArraySeqStEphS::from_vec(vec![
   67|      1|                OrderedFloat(f64::INFINITY),
   68|      1|                OrderedFloat(f64::INFINITY),
   69|      1|                OrderedFloat(f64::INFINITY),
   70|      1|                OrderedFloat(0.0),
   71|       |            ]),
   72|       |        ]);
   73|       |
   74|      1|        let path = ArraySeqStPerS::from_vec(vec![0, 1, 2, 3]);
   75|      1|        match path_weight_float(&path, &weights) {
   76|      1|            | Some(w) => println!("Path 0123 has weight: {:.1}", w.0),
   77|      0|            | None => println!("Invalid path"),
   78|       |        }
   79|      1|    }
   80|       |
   81|       |    /// Example with negative edge weights.
   82|      1|    pub fn example_negative_weights() {
   83|      1|        let weights = ArraySeqStEphS::from_vec(vec![
   84|      1|            ArraySeqStEphS::from_vec(vec![0, 10, i64::MAX]),
   85|      1|            ArraySeqStEphS::from_vec(vec![i64::MAX, 0, -5]),
   86|      1|            ArraySeqStEphS::from_vec(vec![i64::MAX, i64::MAX, 0]),
   87|       |        ]);
   88|       |
   89|      1|        let path = ArraySeqStPerS::from_vec(vec![0, 1, 2]);
   90|      1|        match path_weight_int(&path, &weights) {
   91|      1|            | Some(w) => println!("Path 012 with negative weight has total: {}", w),
   92|      0|            | None => println!("Invalid path"),
   93|       |        }
   94|      1|    }
   95|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap56/Example56_3.rs:
    1|       |//! Copyright  2025 APAS-VERUS. All rights reserved.
    2|       |//!
    3|       |//! Example 56.3 - Negative Weight Cycles
    4|       |//!
    5|       |//! Demonstrates how negative weight cycles affect shortest path calculations.
    6|       |//! When a graph has a negative weight cycle, distances to vertices reachable through
    7|       |//! the cycle become arbitrarily small (approach negative infinity).
    8|       |
    9|       |pub mod Example56_3 {
   10|       |
   11|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS;
   12|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS;
   13|       |    use crate::Chap56::PathWeightUtilsStEph::PathWeightUtilsStEph::path_weight_int;
   14|       |
   15|       |    pub trait Example56_3Trait {
   16|       |        /// Example demonstrating a negative weight cycle
   17|       |        /// APAS: Work O(|V| + |E|), Span O(1)
   18|       |        fn example_negative_cycle();
   19|       |
   20|       |        /// Example showing that shortest paths are undefined in presence of negative cycles
   21|       |        /// APAS: Work O(|E|), Span O(1)
   22|       |        fn example_undefined_shortest_path();
   23|       |    }
   24|       |
   25|       |    /// Example demonstrating a negative weight cycle.
   26|       |    /// Graph: 0 -> 1 -> 2 -> 1 (cycle with negative total weight).
   27|      1|    pub fn example_negative_cycle() {
   28|      1|        let weights = ArraySeqStEphS::from_vec(vec![
   29|      1|            ArraySeqStEphS::from_vec(vec![0, 1, i64::MAX]),
   30|      1|            ArraySeqStEphS::from_vec(vec![i64::MAX, 0, 2]),
   31|      1|            ArraySeqStEphS::from_vec(vec![i64::MAX, -4, 0]),
   32|       |        ]);
   33|       |
   34|      1|        println!("Graph with negative cycle 1->2->1 (weight = 2 + (-4) = -2):");
   35|       |
   36|      1|        let simple_path = ArraySeqStPerS::from_vec(vec![0, 1]);
   37|      1|        match path_weight_int(&simple_path, &weights) {
   38|      1|            | Some(w) => println!("  Path 01: {}", w),
   39|      0|            | None => println!("  Invalid path"),
   40|       |        }
   41|       |
   42|      1|        let one_cycle = ArraySeqStPerS::from_vec(vec![0, 1, 2, 1]);
   43|      1|        match path_weight_int(&one_cycle, &weights) {
   44|      1|            | Some(w) => println!("  Path 0121 (one cycle): {}", w),
   45|      0|            | None => println!("  Invalid path"),
   46|       |        }
   47|       |
   48|      1|        let two_cycles = ArraySeqStPerS::from_vec(vec![0, 1, 2, 1, 2, 1]);
   49|      1|        match path_weight_int(&two_cycles, &weights) {
   50|      1|            | Some(w) => println!("  Path 012121 (two cycles): {}", w),
   51|      0|            | None => println!("  Invalid path"),
   52|       |        }
   53|       |
   54|      1|        println!("  Each cycle around 121 subtracts 2, approaching -");
   55|      1|    }
   56|       |
   57|       |    /// Example showing that shortest paths are undefined in presence of negative cycles.
   58|      1|    pub fn example_undefined_shortest_path() {
   59|      1|        let _weights = ArraySeqStEphS::from_vec(vec![
   60|      1|            ArraySeqStEphS::from_vec(vec![0, 1, i64::MAX, i64::MAX]),
   61|      1|            ArraySeqStEphS::from_vec(vec![i64::MAX, 0, 1, 1]),
   62|      1|            ArraySeqStEphS::from_vec(vec![i64::MAX, -3, 0, i64::MAX]),
   63|      1|            ArraySeqStEphS::from_vec(vec![i64::MAX, i64::MAX, i64::MAX, 0]),
   64|       |        ]);
   65|       |
   66|      1|        println!("\nGraph with cycle 1->2->1 (weight = 1 + (-3) = -2):");
   67|      1|        println!("  Shortest path from 0 to 1 is undefined (can traverse cycle repeatedly)");
   68|      1|        println!("  Shortest path from 0 to 3 through 1 is also undefined");
   69|      1|    }
   70|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap56/PathWeightUtilsStEph.rs:
    1|       |//! Copyright  2025 APAS-VERUS. All rights reserved.
    2|       |//!
    3|       |//! Shortest Path Utility Functions - Sequential Ephemeral (Integer Weights)
    4|       |//!
    5|       |//! Provides utility functions for computing path weights and validating
    6|       |//! the sub-paths property for shortest paths with integer edge weights.
    7|       |//!
    8|       |//! Uses ephemeral data structures for path manipulation.
    9|       |//!
   10|       |//! **Algorithmic Analysis:**
   11|       |//! - `path_weight`: Work O(k), Span O(k) where k is path length
   12|       |//! - `validate_subpath_property`: Work O(k), Span O(k) for k-vertex path
   13|       |
   14|       |pub mod PathWeightUtilsStEph {
   15|       |
   16|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS;
   17|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS;
   18|       |    use crate::Types::Types::*;
   19|       |    
   20|       |    use ordered_float::OrderedFloat;
   21|       |
   22|       |    pub trait PathWeightUtilsStEphTrait {
   23|       |        /// Claude Work: O(k), Span: O(k) where k is path length
   24|       |        /// Computes the total weight of a path given edge weights (integer).
   25|       |        fn path_weight_int(path: &ArraySeqStPerS<usize>, weights: &ArraySeqStEphS<ArraySeqStEphS<i64>>) -> Option<i64>;
   26|       |
   27|       |        /// Claude Work: O(k), Span: O(k) where k is path length
   28|       |        /// Computes the total weight of a path with floating-point weights.
   29|       |        fn path_weight_float(
   30|       |            path: &ArraySeqStPerS<usize>,
   31|       |            weights: &ArraySeqStEphS<ArraySeqStEphS<OrderedF64>>,
   32|       |        ) -> Option<OrderedF64>;
   33|       |
   34|       |        /// Claude Work: O(k), Span: O(k) for k-vertex path
   35|       |        /// Validates the sub-paths property for integer weights.
   36|       |        fn validate_subpath_property_int(
   37|       |            path: &ArraySeqStPerS<usize>,
   38|       |            distances: &ArraySeqStEphS<i64>,
   39|       |            weights: &ArraySeqStEphS<ArraySeqStEphS<i64>>,
   40|       |        ) -> bool;
   41|       |
   42|       |        /// Claude Work: O(k), Span: O(k) for k-vertex path
   43|       |        /// Validates the sub-paths property for floating-point weights.
   44|       |        fn validate_subpath_property_float(
   45|       |            path: &ArraySeqStPerS<usize>,
   46|       |            distances: &ArraySeqStEphS<OrderedF64>,
   47|       |            weights: &ArraySeqStEphS<ArraySeqStEphS<OrderedF64>>,
   48|       |        ) -> bool;
   49|       |    }
   50|       |
   51|       |    /// Computes the total weight of a path given edge weights.
   52|       |    /// Path is a sequence of vertices [v0, v1, ..., vk].
   53|       |    /// Weights is an adjacency matrix where weights.nth(i).nth(j) is the weight of edge (i,j).
   54|       |    /// Returns the sum of weights along the path, or None if path is invalid.
   55|      7|    pub fn path_weight_int(path: &ArraySeqStPerS<usize>, weights: &ArraySeqStEphS<ArraySeqStEphS<i64>>) -> Option<i64> {
   56|      7|        let k = path.length();
   57|      7|        if k < 2 {
   58|      0|            return Some(0);
   59|      7|        }
   60|       |
   61|      7|        let mut total = 0i64;
   62|     18|        for i in 0..k - 1 {
                                  ^7
   63|     18|            let u = *path.nth(i);
   64|     18|            let v = *path.nth(i + 1);
   65|     18|            if u >= weights.length() || v >= weights.nth(u).length() {
   66|      0|                return None;
   67|     18|            }
   68|     18|            let edge_weight = *weights.nth(u).nth(v);
   69|     18|            total = total.saturating_add(edge_weight);
   70|       |        }
   71|      7|        Some(total)
   72|      7|    }
   73|       |
   74|       |    /// Computes the total weight of a path with floating-point weights.
   75|      2|    pub fn path_weight_float(
   76|      2|        path: &ArraySeqStPerS<usize>,
   77|      2|        weights: &ArraySeqStEphS<ArraySeqStEphS<OrderedF64>>,
   78|      2|    ) -> Option<OrderedF64> {
   79|      2|        let k = path.length();
   80|      2|        if k < 2 {
   81|      0|            return Some(OrderedFloat(0.0));
   82|      2|        }
   83|       |
   84|      2|        let mut total = OrderedFloat(0.0);
   85|      5|        for i in 0..k - 1 {
                                  ^2
   86|      5|            let u = *path.nth(i);
   87|      5|            let v = *path.nth(i + 1);
   88|      5|            if u >= weights.length() || v >= weights.nth(u).length() {
   89|      0|                return None;
   90|      5|            }
   91|      5|            let edge_weight = *weights.nth(u).nth(v);
   92|      5|            total += edge_weight;
   93|       |        }
   94|      2|        Some(total)
   95|      2|    }
   96|       |
   97|       |    /// Validates the sub-paths property: every sub-path of a shortest path is itself a shortest path.
   98|       |    /// Given a path and distances for all vertices from source, check if all sub-paths are optimal.
   99|       |    /// This is a validation utility, not used in actual shortest path algorithms.
  100|      1|    pub fn validate_subpath_property_int(
  101|      1|        path: &ArraySeqStPerS<usize>,
  102|      1|        distances: &ArraySeqStEphS<i64>,
  103|      1|        weights: &ArraySeqStEphS<ArraySeqStEphS<i64>>,
  104|      1|    ) -> bool {
  105|      1|        let k = path.length();
  106|      1|        if k < 2 {
  107|      0|            return true;
  108|      1|        }
  109|       |
  110|      2|        for i in 0..k - 1 {
                                  ^1
  111|      2|            let u = *path.nth(i);
  112|      2|            let v = *path.nth(i + 1);
  113|      2|            if u >= distances.length() || v >= distances.length() {
  114|      0|                return false;
  115|      2|            }
  116|      2|            let dist_u = *distances.nth(u);
  117|      2|            let dist_v = *distances.nth(v);
  118|      2|            let edge_weight = *weights.nth(u).nth(v);
  119|       |
  120|      2|            if dist_u != i64::MAX && dist_v != dist_u.saturating_add(edge_weight) {
  121|      0|                return false;
  122|      2|            }
  123|       |        }
  124|      1|        true
  125|      1|    }
  126|       |
  127|       |    /// Validates the sub-paths property for floating-point weights.
  128|      1|    pub fn validate_subpath_property_float(
  129|      1|        path: &ArraySeqStPerS<usize>,
  130|      1|        distances: &ArraySeqStEphS<OrderedF64>,
  131|      1|        weights: &ArraySeqStEphS<ArraySeqStEphS<OrderedF64>>,
  132|      1|    ) -> bool {
  133|      1|        let k = path.length();
  134|      1|        if k < 2 {
  135|      0|            return true;
  136|      1|        }
  137|       |
  138|      1|        let epsilon = 1e-9;
  139|      2|        for i in 0..k - 1 {
                                  ^1
  140|      2|            let u = *path.nth(i);
  141|      2|            let v = *path.nth(i + 1);
  142|      2|            if u >= distances.length() || v >= distances.length() {
  143|      0|                return false;
  144|      2|            }
  145|      2|            let dist_u = *distances.nth(u);
  146|      2|            let dist_v = *distances.nth(v);
  147|      2|            let edge_weight = *weights.nth(u).nth(v);
  148|       |
  149|      2|            if dist_u.is_finite() && ((dist_v - (dist_u + edge_weight)).abs() > epsilon) {
  150|      0|                return false;
  151|      2|            }
  152|       |        }
  153|      1|        true
  154|      1|    }
  155|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap56/PathWeightUtilsStPer.rs:
    1|       |//! Copyright  2025 APAS-VERUS. All rights reserved.
    2|       |//!
    3|       |//! Shortest Path Utility Functions - Sequential Persistent
    4|       |//!
    5|       |//! Provides utility functions for computing path weights and validating
    6|       |//! the sub-paths property for shortest paths with both integer and float weights.
    7|       |//!
    8|       |//! Uses persistent data structures for path manipulation.
    9|       |//!
   10|       |//! **Algorithmic Analysis:**
   11|       |//! - `path_weight`: Work O(k), Span O(k) where k is path length
   12|       |//! - `validate_subpath_property`: Work O(k), Span O(k) for k-vertex path
   13|       |
   14|       |pub mod PathWeightUtilsStPer {
   15|       |
   16|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS;
   17|       |    use crate::Types::Types::*;
   18|       |    
   19|       |    use ordered_float::OrderedFloat;
   20|       |
   21|       |    pub trait PathWeightUtilsStPerTrait {
   22|       |        /// Claude Work: O(k), Span: O(k) where k is path length
   23|       |        /// Computes the total weight of a path given edge weights (integer).
   24|       |        fn path_weight_int(path: &ArraySeqStPerS<usize>, weights: &ArraySeqStPerS<ArraySeqStPerS<i64>>) -> Option<i64>;
   25|       |
   26|       |        /// Claude Work: O(k), Span: O(k) where k is path length
   27|       |        /// Computes the total weight of a path with floating-point weights.
   28|       |        fn path_weight_float(
   29|       |            path: &ArraySeqStPerS<usize>,
   30|       |            weights: &ArraySeqStPerS<ArraySeqStPerS<OrderedF64>>,
   31|       |        ) -> Option<OrderedF64>;
   32|       |
   33|       |        /// Claude Work: O(k), Span: O(k) for k-vertex path
   34|       |        /// Validates the sub-paths property for integer weights.
   35|       |        fn validate_subpath_property_int(
   36|       |            path: &ArraySeqStPerS<usize>,
   37|       |            distances: &ArraySeqStPerS<i64>,
   38|       |            weights: &ArraySeqStPerS<ArraySeqStPerS<i64>>,
   39|       |        ) -> bool;
   40|       |
   41|       |        /// Claude Work: O(k), Span: O(k) for k-vertex path
   42|       |        /// Validates the sub-paths property for floating-point weights.
   43|       |        fn validate_subpath_property_float(
   44|       |            path: &ArraySeqStPerS<usize>,
   45|       |            distances: &ArraySeqStPerS<OrderedF64>,
   46|       |            weights: &ArraySeqStPerS<ArraySeqStPerS<OrderedF64>>,
   47|       |        ) -> bool;
   48|       |    }
   49|       |
   50|       |    /// Computes the total weight of a path given edge weights (integer version).
   51|       |    /// Path is a sequence of vertices [v0, v1, ..., vk].
   52|       |    /// Weights is an adjacency matrix where weights.nth(i).nth(j) is the weight of edge (i,j).
   53|       |    /// Returns the sum of weights along the path, or None if path is invalid.
   54|      2|    pub fn path_weight_int(path: &ArraySeqStPerS<usize>, weights: &ArraySeqStPerS<ArraySeqStPerS<i64>>) -> Option<i64> {
   55|      2|        let k = path.length();
   56|      2|        if k < 2 {
   57|      0|            return Some(0);
   58|      2|        }
   59|       |
   60|      2|        let mut total = 0i64;
   61|      4|        for i in 0..k - 1 {
                                  ^2
   62|      4|            let u = *path.nth(i);
   63|      4|            let v = *path.nth(i + 1);
   64|      4|            if u >= weights.length() || v >= weights.nth(u).length() {
   65|      0|                return None;
   66|      4|            }
   67|      4|            let edge_weight = weights.nth(u).nth(v).clone();
   68|      4|            total = total.saturating_add(edge_weight);
   69|       |        }
   70|      2|        Some(total)
   71|      2|    }
   72|       |
   73|       |    /// Computes the total weight of a path with floating-point weights.
   74|      1|    pub fn path_weight_float(
   75|      1|        path: &ArraySeqStPerS<usize>,
   76|      1|        weights: &ArraySeqStPerS<ArraySeqStPerS<OrderedF64>>,
   77|      1|    ) -> Option<OrderedF64> {
   78|      1|        let k = path.length();
   79|      1|        if k < 2 {
   80|      0|            return Some(OrderedFloat(0.0));
   81|      1|        }
   82|       |
   83|      1|        let mut total = OrderedFloat(0.0);
   84|      2|        for i in 0..k - 1 {
                                  ^1
   85|      2|            let u = *path.nth(i);
   86|      2|            let v = *path.nth(i + 1);
   87|      2|            if u >= weights.length() || v >= weights.nth(u).length() {
   88|      0|                return None;
   89|      2|            }
   90|      2|            let edge_weight = weights.nth(u).nth(v).clone();
   91|      2|            total += edge_weight;
   92|       |        }
   93|      1|        Some(total)
   94|      1|    }
   95|       |
   96|       |    /// Validates the sub-paths property: every sub-path of a shortest path is itself a shortest path.
   97|       |    /// Given a path and distances for all vertices from source, check if all sub-paths are optimal.
   98|       |    /// This is a validation utility, not used in actual shortest path algorithms.
   99|      1|    pub fn validate_subpath_property_int(
  100|      1|        path: &ArraySeqStPerS<usize>,
  101|      1|        distances: &ArraySeqStPerS<i64>,
  102|      1|        weights: &ArraySeqStPerS<ArraySeqStPerS<i64>>,
  103|      1|    ) -> bool {
  104|      1|        let k = path.length();
  105|      1|        if k < 2 {
  106|      0|            return true;
  107|      1|        }
  108|       |
  109|      2|        for i in 0..k - 1 {
                                  ^1
  110|      2|            let u = *path.nth(i);
  111|      2|            let v = *path.nth(i + 1);
  112|      2|            if u >= distances.length() || v >= distances.length() {
  113|      0|                return false;
  114|      2|            }
  115|      2|            let dist_u = distances.nth(u).clone();
  116|      2|            let dist_v = distances.nth(v).clone();
  117|      2|            let edge_weight = weights.nth(u).nth(v).clone();
  118|       |
  119|      2|            if dist_u != i64::MAX && dist_v != dist_u.saturating_add(edge_weight) {
  120|      0|                return false;
  121|      2|            }
  122|       |        }
  123|      1|        true
  124|      1|    }
  125|       |
  126|       |    /// Validates the sub-paths property for floating-point weights.
  127|      1|    pub fn validate_subpath_property_float(
  128|      1|        path: &ArraySeqStPerS<usize>,
  129|      1|        distances: &ArraySeqStPerS<OrderedF64>,
  130|      1|        weights: &ArraySeqStPerS<ArraySeqStPerS<OrderedF64>>,
  131|      1|    ) -> bool {
  132|      1|        let k = path.length();
  133|      1|        if k < 2 {
  134|      0|            return true;
  135|      1|        }
  136|       |
  137|      1|        let epsilon = 1e-9;
  138|      2|        for i in 0..k - 1 {
                                  ^1
  139|      2|            let u = *path.nth(i);
  140|      2|            let v = *path.nth(i + 1);
  141|      2|            if u >= distances.length() || v >= distances.length() {
  142|      0|                return false;
  143|      2|            }
  144|      2|            let dist_u = distances.nth(u).clone();
  145|      2|            let dist_v = distances.nth(v).clone();
  146|      2|            let edge_weight = weights.nth(u).nth(v).clone();
  147|       |
  148|      2|            if dist_u.is_finite() && ((dist_v - (dist_u + edge_weight)).abs() > epsilon) {
  149|      0|                return false;
  150|      2|            }
  151|       |        }
  152|      1|        true
  153|      1|    }
  154|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap56/SSSPResultStEphFloat.rs:
    1|       |//! Copyright  2025 APAS-VERUS. All rights reserved.
    2|       |//!
    3|       |//! Single-Source Shortest Path Result Structure - Sequential Ephemeral (Float Weights)
    4|       |//!
    5|       |//! Data structure for storing the result of single-source shortest path algorithms
    6|       |//! with floating-point edge weights. Stores distance and predecessor arrays for path reconstruction.
    7|       |//!
    8|       |//! Uses ephemeral array sequences for efficient in-place updates.
    9|       |//! Uses `OrderedF64` (OrderedFloat<f64>) for weights to ensure Eq/Hash traits.
   10|       |//!
   11|       |//! **Algorithmic Analysis:**
   12|       |//! - `new`: Work O(n), Span O(n) for n vertices
   13|       |//! - `get_distance`: Work O(1), Span O(1)
   14|       |//! - `extract_path`: Work O(k), Span O(k) where k is path length
   15|       |
   16|       |pub mod SSSPResultStEphFloat {
   17|       |
   18|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS;
   19|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS;
   20|       |    use crate::Types::Types::*;
   21|       |    use ordered_float::OrderedFloat;
   22|       |
   23|       |    const UNREACHABLE: OrderedF64 = OrderedFloat(f64::INFINITY);
   24|       |    const NO_PREDECESSOR: usize = usize::MAX;
   25|       |
   26|       |    /// Trait for single-source shortest path result operations
   27|       |    pub trait SSSPResultStEphFloatTrait {
   28|       |        /// Create new SSSP result
   29|       |        /// APAS: Work (n), Span (n)
   30|       |        fn new(n: N, source: N) -> Self;
   31|       |
   32|       |        /// Get distance to vertex
   33|       |        /// APAS: Work (1), Span (1)
   34|       |        fn distance(&self, v: N) -> Option<OrderedF64>;
   35|       |
   36|       |        /// Check if vertex is reachable
   37|       |        /// APAS: Work (1), Span (1)
   38|       |        fn is_reachable(&self, v: N) -> B;
   39|       |    }
   40|       |
   41|       |    /// Result structure for single-source shortest paths with floating-point weights.
   42|       |    pub struct SSSPResultStEphFloat {
   43|       |        /// Distance from source to each vertex (OrderedFloat(f64::INFINITY) for unreachable).
   44|       |        pub distances: ArraySeqStEphS<OrderedF64>,
   45|       |        /// Predecessor of each vertex in shortest path tree (usize::MAX for source/unreachable).
   46|       |        pub predecessors: ArraySeqStEphS<usize>,
   47|       |        /// Source vertex.
   48|       |        pub source: usize,
   49|       |    }
   50|       |
   51|       |    impl SSSPResultStEphFloat {
   52|       |        /// Creates a new SSSP result structure initialized for n vertices from given source.
   53|       |        /// All distances are set to UNREACHABLE, all predecessors to NO_PREDECESSOR.
   54|     71|        pub fn new(n: usize, source: usize) -> Self {
   55|     71|            let mut dist_vec = vec![UNREACHABLE; n];
   56|     71|            dist_vec[source] = OrderedFloat(0.0);
   57|     71|            let distances = ArraySeqStEphS::from_vec(dist_vec);
   58|     71|            let predecessors = ArraySeqStEphS::new(n, NO_PREDECESSOR);
   59|     71|            SSSPResultStEphFloat {
   60|     71|                distances,
   61|     71|                predecessors,
   62|     71|                source,
   63|     71|            }
   64|     71|        }
   65|       |
   66|       |        /// Returns the distance from source to vertex v.
   67|    279|        pub fn get_distance(&self, v: usize) -> OrderedF64 {
   68|    279|            if v >= self.distances.length() {
   69|      0|                return UNREACHABLE;
   70|    279|            }
   71|    279|            *self.distances.nth(v)
   72|    279|        }
   73|       |
   74|       |        /// Sets the distance from source to vertex v.
   75|    173|        pub fn set_distance(&mut self, v: usize, dist: OrderedF64) {
   76|    173|            if v < self.distances.length() {
   77|    173|                let _ = self.distances.set(v, dist);
   78|    173|            }
                          ^0
   79|    173|        }
   80|       |
   81|       |        /// Returns the predecessor of vertex v in the shortest path from source.
   82|      2|        pub fn get_predecessor(&self, v: usize) -> Option<usize> {
   83|      2|            if v >= self.predecessors.length() {
   84|      0|                return None;
   85|      2|            }
   86|      2|            let pred = *self.predecessors.nth(v);
   87|      2|            if pred == NO_PREDECESSOR { None } else { Some(pred) }
                                                      ^0
   88|      2|        }
   89|       |
   90|       |        /// Sets the predecessor of vertex v in the shortest path from source.
   91|    120|        pub fn set_predecessor(&mut self, v: usize, pred: usize) {
   92|    120|            if v < self.predecessors.length() {
   93|    120|                let _ = self.predecessors.set(v, pred);
   94|    120|            }
                          ^0
   95|    120|        }
   96|       |
   97|       |        /// Checks if vertex v is reachable from source.
   98|      4|        pub fn is_reachable(&self, v: usize) -> bool { self.get_distance(v).is_finite() }
   99|       |
  100|       |        /// Extracts the shortest path from source to vertex v by following predecessors.
  101|       |        /// Returns None if v is unreachable, otherwise returns the path as a sequence.
  102|      2|        pub fn extract_path(&self, v: usize) -> Option<ArraySeqStPerS<usize>> {
  103|      2|            if !self.is_reachable(v) {
  104|      1|                return None;
  105|      1|            }
  106|       |
  107|      1|            let mut path = Vec::new();
  108|      1|            let mut current = v;
  109|      1|            path.push(current);
  110|       |
  111|      4|            while current != self.source {
  112|      3|                let pred = *self.predecessors.nth(current);
  113|      3|                if pred == NO_PREDECESSOR {
  114|      0|                    return None;
  115|      3|                }
  116|      3|                path.push(pred);
  117|      3|                current = pred;
  118|       |            }
  119|       |
  120|      1|            path.reverse();
  121|      1|            Some(ArraySeqStPerS::from_vec(path))
  122|      2|        }
  123|       |    }
  124|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap56/SSSPResultStEphInt.rs:
    1|       |//! Copyright  2025 APAS-VERUS. All rights reserved.
    2|       |//!
    3|       |//! Single-Source Shortest Path Result Structure - Sequential Ephemeral (Integer Weights)
    4|       |//!
    5|       |//! Data structure for storing the result of single-source shortest path algorithms
    6|       |//! with integer edge weights. Stores distance and predecessor arrays for path reconstruction.
    7|       |//!
    8|       |//! Uses ephemeral array sequences for efficient in-place updates.
    9|       |//!
   10|       |//! **Algorithmic Analysis:**
   11|       |//! - `new`: Work O(n), Span O(n) for n vertices
   12|       |//! - `get_distance`: Work O(1), Span O(1)
   13|       |//! - `extract_path`: Work O(k), Span O(k) where k is path length
   14|       |
   15|       |pub mod SSSPResultStEphInt {
   16|       |
   17|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS;
   18|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS;
   19|       |    use crate::Types::Types::*;
   20|       |
   21|       |    const UNREACHABLE: i64 = i64::MAX;
   22|       |    const NO_PREDECESSOR: usize = usize::MAX;
   23|       |
   24|       |    /// Trait for single-source shortest path result operations
   25|       |    pub trait SSSPResultStEphIntTrait {
   26|       |        /// Create new SSSP result
   27|       |        /// APAS: Work (n), Span (n)
   28|       |        fn new(n: N, source: N) -> Self;
   29|       |
   30|       |        /// Get distance to vertex
   31|       |        /// APAS: Work (1), Span (1)
   32|       |        fn distance(&self, v: N) -> Option<i32>;
   33|       |
   34|       |        /// Check if vertex is reachable
   35|       |        /// APAS: Work (1), Span (1)
   36|       |        fn is_reachable(&self, v: N) -> B;
   37|       |    }
   38|       |
   39|       |    /// Result structure for single-source shortest paths with integer weights.
   40|       |    pub struct SSSPResultStEphInt {
   41|       |        /// Distance from source to each vertex (i64::MAX for unreachable).
   42|       |        pub distances: ArraySeqStEphS<i64>,
   43|       |        /// Predecessor of each vertex in shortest path tree (usize::MAX for source/unreachable).
   44|       |        pub predecessors: ArraySeqStEphS<usize>,
   45|       |        /// Source vertex.
   46|       |        pub source: usize,
   47|       |    }
   48|       |
   49|       |    impl SSSPResultStEphInt {
   50|       |        /// Creates a new SSSP result structure initialized for n vertices from given source.
   51|       |        /// All distances are set to UNREACHABLE, all predecessors to NO_PREDECESSOR.
   52|     61|        pub fn new(n: usize, source: usize) -> Self {
   53|     61|            let mut dist_vec = vec![UNREACHABLE; n];
   54|     61|            dist_vec[source] = 0;
   55|     61|            let distances = ArraySeqStEphS::from_vec(dist_vec);
   56|     61|            let predecessors = ArraySeqStEphS::new(n, NO_PREDECESSOR);
   57|     61|            SSSPResultStEphInt {
   58|     61|                distances,
   59|     61|                predecessors,
   60|     61|                source,
   61|     61|            }
   62|     61|        }
   63|       |
   64|       |        /// Returns the distance from source to vertex v.
   65|    269|        pub fn get_distance(&self, v: usize) -> i64 {
   66|    269|            if v >= self.distances.length() {
   67|      0|                return UNREACHABLE;
   68|    269|            }
   69|    269|            *self.distances.nth(v)
   70|    269|        }
   71|       |
   72|       |        /// Sets the distance from source to vertex v.
   73|    175|        pub fn set_distance(&mut self, v: usize, dist: i64) {
   74|    175|            if v < self.distances.length() {
   75|    175|                let _ = self.distances.set(v, dist);
   76|    175|            }
                          ^0
   77|    175|        }
   78|       |
   79|       |        /// Returns the predecessor of vertex v in the shortest path from source.
   80|      2|        pub fn get_predecessor(&self, v: usize) -> Option<usize> {
   81|      2|            if v >= self.predecessors.length() {
   82|      0|                return None;
   83|      2|            }
   84|      2|            let pred = *self.predecessors.nth(v);
   85|      2|            if pred == NO_PREDECESSOR { None } else { Some(pred) }
                                                      ^0
   86|      2|        }
   87|       |
   88|       |        /// Sets the predecessor of vertex v in the shortest path from source.
   89|    136|        pub fn set_predecessor(&mut self, v: usize, pred: usize) {
   90|    136|            if v < self.predecessors.length() {
   91|    136|                let _ = self.predecessors.set(v, pred);
   92|    136|            }
                          ^0
   93|    136|        }
   94|       |
   95|       |        /// Checks if vertex v is reachable from source.
   96|      8|        pub fn is_reachable(&self, v: usize) -> bool { self.get_distance(v) != UNREACHABLE }
   97|       |
   98|       |        /// Extracts the shortest path from source to vertex v by following predecessors.
   99|       |        /// Returns None if v is unreachable, otherwise returns the path as a sequence.
  100|      5|        pub fn extract_path(&self, v: usize) -> Option<ArraySeqStPerS<usize>> {
  101|      5|            if !self.is_reachable(v) {
  102|      1|                return None;
  103|      4|            }
  104|       |
  105|      4|            let mut path = Vec::new();
  106|      4|            let mut current = v;
  107|      4|            path.push(current);
  108|       |
  109|     15|            while current != self.source {
  110|     11|                let pred = *self.predecessors.nth(current);
  111|     11|                if pred == NO_PREDECESSOR {
  112|      0|                    return None;
  113|     11|                }
  114|     11|                path.push(pred);
  115|     11|                current = pred;
  116|       |            }
  117|       |
  118|      4|            path.reverse();
  119|      4|            Some(ArraySeqStPerS::from_vec(path))
  120|      5|        }
  121|       |    }
  122|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap56/SSSPResultStPerFloat.rs:
    1|       |//! Copyright  2025 APAS-VERUS. All rights reserved.
    2|       |//!
    3|       |//! Single-Source Shortest Path Result Structure - Sequential Persistent (Float Weights)
    4|       |//!
    5|       |//! Data structure for storing the result of single-source shortest path algorithms
    6|       |//! with floating-point edge weights. Stores distance and predecessor arrays for path reconstruction.
    7|       |//!
    8|       |//! Uses persistent array sequences for functional-style immutability.
    9|       |//! Uses `OrderedF64` (OrderedFloat<f64>) for weights to ensure Eq/Hash traits.
   10|       |//!
   11|       |//! **Algorithmic Analysis:**
   12|       |//! - `new`: Work O(n), Span O(n) for n vertices
   13|       |//! - `get_distance`: Work O(1), Span O(1)
   14|       |//! - `extract_path`: Work O(k), Span O(k) where k is path length
   15|       |
   16|       |pub mod SSSPResultStPerFloat {
   17|       |
   18|       |    use crate::Chap19::ArraySeqStPer::ArraySeqStPer::*;
   19|       |    
   20|       |    use crate::Types::Types::*;
   21|       |    use ordered_float::OrderedFloat;
   22|       |
   23|       |    const UNREACHABLE: OrderedF64 = OrderedFloat(f64::INFINITY);
   24|       |    const NO_PREDECESSOR: usize = usize::MAX;
   25|       |
   26|       |    /// Trait for single-source shortest path result operations
   27|       |    pub trait SSSPResultStPerFloatTrait {
   28|       |        /// Create new SSSP result
   29|       |        /// APAS: Work (n), Span (n)
   30|       |        fn new(n: N, source: N) -> Self;
   31|       |
   32|       |        /// Get distance to vertex
   33|       |        /// APAS: Work (1), Span (1)
   34|       |        fn distance(&self, v: N) -> Option<OrderedF64>;
   35|       |
   36|       |        /// Check if vertex is reachable
   37|       |        /// APAS: Work (1), Span (1)
   38|       |        fn is_reachable(&self, v: N) -> B;
   39|       |    }
   40|       |
   41|       |    /// Result structure for single-source shortest paths with floating-point weights (persistent).
   42|       |    pub struct SSSPResultStPerFloat {
   43|       |        /// Distance from source to each vertex (OrderedFloat(f64::INFINITY) for unreachable).
   44|       |        pub distances: ArraySeqStPerS<OrderedF64>,
   45|       |        /// Predecessor of each vertex in shortest path tree (usize::MAX for source/unreachable).
   46|       |        pub predecessors: ArraySeqStPerS<usize>,
   47|       |        /// Source vertex.
   48|       |        pub source: usize,
   49|       |    }
   50|       |
   51|       |    impl SSSPResultStPerFloat {
   52|       |        /// Creates a new SSSP result structure initialized for n vertices from given source.
   53|       |        /// All distances are set to UNREACHABLE, all predecessors to NO_PREDECESSOR.
   54|      5|        pub fn new(n: usize, source: usize) -> Self {
   55|     18|            let distances = ArraySeqStPerS::tabulate(&|i| if i == source { OrderedFloat(0.0) } else { UNREACHABLE }, n);
                              ^5          ^5                                             ^5                         ^13            ^5
   56|      5|            let predecessors = ArraySeqStPerS::tabulate(&|_| NO_PREDECESSOR, n);
   57|      5|            SSSPResultStPerFloat {
   58|      5|                distances,
   59|      5|                predecessors,
   60|      5|                source,
   61|      5|            }
   62|      5|        }
   63|       |
   64|       |        /// Returns the distance from source to vertex v.
   65|      8|        pub fn get_distance(&self, v: usize) -> OrderedF64 {
   66|      8|            if v >= self.distances.length() {
   67|      0|                return UNREACHABLE;
   68|      8|            }
   69|      8|            self.distances.nth(v).clone()
   70|      8|        }
   71|       |
   72|       |        /// Sets the distance from source to vertex v, returning a new structure.
   73|      5|        pub fn set_distance(self, v: usize, dist: OrderedF64) -> Self {
   74|      5|            if v >= self.distances.length() {
   75|      0|                return self;
   76|      5|            }
   77|      5|            SSSPResultStPerFloat {
   78|      5|                distances: ArraySeqStPerS::update(&self.distances, v, dist),
   79|      5|                predecessors: self.predecessors,
   80|      5|                source: self.source,
   81|      5|            }
   82|      5|        }
   83|       |
   84|       |        /// Returns the predecessor of vertex v in the shortest path from source.
   85|      2|        pub fn get_predecessor(&self, v: usize) -> Option<usize> {
   86|      2|            if v >= self.predecessors.length() {
   87|      0|                return None;
   88|      2|            }
   89|      2|            let pred = self.predecessors.nth(v).clone();
   90|      2|            if pred == NO_PREDECESSOR { None } else { Some(pred) }
                                                      ^0
   91|      2|        }
   92|       |
   93|       |        /// Sets the predecessor of vertex v, returning a new structure.
   94|      5|        pub fn set_predecessor(self, v: usize, pred: usize) -> Self {
   95|      5|            if v >= self.predecessors.length() {
   96|      0|                return self;
   97|      5|            }
   98|      5|            SSSPResultStPerFloat {
   99|      5|                distances: self.distances,
  100|      5|                predecessors: ArraySeqStPerS::update(&self.predecessors, v, pred),
  101|      5|                source: self.source,
  102|      5|            }
  103|      5|        }
  104|       |
  105|       |        /// Checks if vertex v is reachable from source.
  106|      4|        pub fn is_reachable(&self, v: usize) -> bool { self.get_distance(v).is_finite() }
  107|       |
  108|       |        /// Extracts the shortest path from source to vertex v by following predecessors.
  109|       |        /// Returns None if v is unreachable, otherwise returns the path as a sequence.
  110|      2|        pub fn extract_path(&self, v: usize) -> Option<ArraySeqStPerS<usize>> {
  111|      2|            if !self.is_reachable(v) {
  112|      1|                return None;
  113|      1|            }
  114|       |
  115|      1|            let mut path = Vec::new();
  116|      1|            let mut current = v;
  117|      1|            path.push(current);
  118|       |
  119|      4|            while current != self.source {
  120|      3|                let pred = *self.predecessors.nth(current);
  121|      3|                if pred == NO_PREDECESSOR {
  122|      0|                    return None;
  123|      3|                }
  124|      3|                path.push(pred);
  125|      3|                current = pred;
  126|       |            }
  127|       |
  128|      1|            path.reverse();
  129|      1|            Some(ArraySeqStPerS::from_vec(path))
  130|      2|        }
  131|       |    }
  132|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap56/SSSPResultStPerInt.rs:
    1|       |//! Copyright  2025 APAS-VERUS. All rights reserved.
    2|       |//!
    3|       |//! Single-Source Shortest Path Result Structure - Sequential Persistent (Integer Weights)
    4|       |//!
    5|       |//! Data structure for storing the result of single-source shortest path algorithms
    6|       |//! with integer edge weights. Stores distance and predecessor arrays for path reconstruction.
    7|       |//!
    8|       |//! Uses persistent array sequences for functional-style immutability.
    9|       |//!
   10|       |//! **Algorithmic Analysis:**
   11|       |//! - `new`: Work O(n), Span O(n) for n vertices
   12|       |//! - `get_distance`: Work O(1), Span O(1)
   13|       |//! - `extract_path`: Work O(k), Span O(k) where k is path length
   14|       |
   15|       |pub mod SSSPResultStPerInt {
   16|       |
   17|       |    use crate::Chap19::ArraySeqStPer::ArraySeqStPer::*;
   18|       |    use crate::Types::Types::*;
   19|       |
   20|       |    const UNREACHABLE: i64 = i64::MAX;
   21|       |    const NO_PREDECESSOR: usize = usize::MAX;
   22|       |
   23|       |    /// Trait for single-source shortest path result operations
   24|       |    pub trait SSSPResultStPerIntTrait {
   25|       |        /// Create new SSSP result
   26|       |        /// APAS: Work (n), Span (n)
   27|       |        fn new(n: N, source: N) -> Self;
   28|       |
   29|       |        /// Get distance to vertex
   30|       |        /// APAS: Work (1), Span (1)
   31|       |        fn distance(&self, v: N) -> Option<i32>;
   32|       |
   33|       |        /// Check if vertex is reachable
   34|       |        /// APAS: Work (1), Span (1)
   35|       |        fn is_reachable(&self, v: N) -> B;
   36|       |    }
   37|       |
   38|       |    /// Result structure for single-source shortest paths with integer weights (persistent).
   39|       |    pub struct SSSPResultStPerInt {
   40|       |        /// Distance from source to each vertex (i64::MAX for unreachable).
   41|       |        pub distances: ArraySeqStPerS<i64>,
   42|       |        /// Predecessor of each vertex in shortest path tree (usize::MAX for source/unreachable).
   43|       |        pub predecessors: ArraySeqStPerS<usize>,
   44|       |        /// Source vertex.
   45|       |        pub source: usize,
   46|       |    }
   47|       |
   48|       |    impl SSSPResultStPerInt {
   49|       |        /// Creates a new SSSP result structure initialized for n vertices from given source.
   50|       |        /// All distances are set to UNREACHABLE, all predecessors to NO_PREDECESSOR.
   51|      5|        pub fn new(n: usize, source: usize) -> Self {
   52|     18|            let distances = ArraySeqStPerS::tabulate(&|i| if i == source { 0 } else { UNREACHABLE }, n);
                              ^5          ^5                                             ^5         ^13            ^5
   53|      5|            let predecessors = ArraySeqStPerS::tabulate(&|_| NO_PREDECESSOR, n);
   54|      5|            SSSPResultStPerInt {
   55|      5|                distances,
   56|      5|                predecessors,
   57|      5|                source,
   58|      5|            }
   59|      5|        }
   60|       |
   61|       |        /// Returns the distance from source to vertex v.
   62|      8|        pub fn get_distance(&self, v: usize) -> i64 {
   63|      8|            if v >= self.distances.length() {
   64|      0|                return UNREACHABLE;
   65|      8|            }
   66|      8|            self.distances.nth(v).clone()
   67|      8|        }
   68|       |
   69|       |        /// Sets the distance from source to vertex v, returning a new structure.
   70|      5|        pub fn set_distance(self, v: usize, dist: i64) -> Self {
   71|      5|            if v >= self.distances.length() {
   72|      0|                return self;
   73|      5|            }
   74|      5|            SSSPResultStPerInt {
   75|      5|                distances: ArraySeqStPerS::update(&self.distances, v, dist),
   76|      5|                predecessors: self.predecessors,
   77|      5|                source: self.source,
   78|      5|            }
   79|      5|        }
   80|       |
   81|       |        /// Returns the predecessor of vertex v in the shortest path from source.
   82|      2|        pub fn get_predecessor(&self, v: usize) -> Option<usize> {
   83|      2|            if v >= self.predecessors.length() {
   84|      0|                return None;
   85|      2|            }
   86|      2|            let pred = self.predecessors.nth(v).clone();
   87|      2|            if pred == NO_PREDECESSOR { None } else { Some(pred) }
                                                      ^0
   88|      2|        }
   89|       |
   90|       |        /// Sets the predecessor of vertex v, returning a new structure.
   91|      5|        pub fn set_predecessor(self, v: usize, pred: usize) -> Self {
   92|      5|            if v >= self.predecessors.length() {
   93|      0|                return self;
   94|      5|            }
   95|      5|            SSSPResultStPerInt {
   96|      5|                distances: self.distances,
   97|      5|                predecessors: ArraySeqStPerS::update(&self.predecessors, v, pred),
   98|      5|                source: self.source,
   99|      5|            }
  100|      5|        }
  101|       |
  102|       |        /// Checks if vertex v is reachable from source.
  103|      4|        pub fn is_reachable(&self, v: usize) -> bool { self.get_distance(v) != UNREACHABLE }
  104|       |
  105|       |        /// Extracts the shortest path from source to vertex v by following predecessors.
  106|       |        /// Returns None if v is unreachable, otherwise returns the path as a sequence.
  107|      2|        pub fn extract_path(&self, v: usize) -> Option<ArraySeqStPerS<usize>> {
  108|      2|            if !self.is_reachable(v) {
  109|      1|                return None;
  110|      1|            }
  111|       |
  112|      1|            let mut path = Vec::new();
  113|      1|            let mut current = v;
  114|      1|            path.push(current);
  115|       |
  116|      4|            while current != self.source {
  117|      3|                let pred = *self.predecessors.nth(current);
  118|      3|                if pred == NO_PREDECESSOR {
  119|      0|                    return None;
  120|      3|                }
  121|      3|                path.push(pred);
  122|      3|                current = pred;
  123|       |            }
  124|       |
  125|      1|            path.reverse();
  126|      1|            Some(ArraySeqStPerS::from_vec(path))
  127|      2|        }
  128|       |    }
  129|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap57/DijkstraStEphFloat.rs:
    1|       |//! Copyright  2025 APAS-VERUS. All rights reserved.
    2|       |//!
    3|       |//! Dijkstra's Algorithm - Single Source Shortest Path (SSSP+) for non-negative float edge weights
    4|       |//!
    5|       |//! Implements Algorithm 57.2 from the textbook using priority queues.
    6|       |//!
    7|       |//! **Algorithmic Analysis:**
    8|       |//! - Dijkstra: Work O(m log n), Span O(m log n) where m = |E|, n = |V|
    9|       |
   10|       |pub mod DijkstraStEphFloat {
   11|       |
   12|       |    use std::cmp::Ordering;
   13|       |    use std::collections::HashMap;
   14|       |    use std::fmt::{Debug, Display, Formatter, Result as FmtResult};
   15|       |
   16|       |    use crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::LabDirGraphStEphTrait;
   17|       |    use crate::Chap06::WeightedDirGraphStEphFloat::WeightedDirGraphStEphFloat::WeightedDirGraphStEphFloat;
   18|       |    use crate::Chap45::BinaryHeapPQ::BinaryHeapPQ::*;
   19|       |    use crate::Chap56::SSSPResultStEphFloat::SSSPResultStEphFloat::SSSPResultStEphFloat;
   20|       |    use crate::Types::Types::*;
   21|       |
   22|       |    pub trait DijkstraStEphFloatTrait {
   23|       |        /// Dijkstra's single source shortest path algorithm
   24|       |        /// APAS: Work O(m log n), Span O(m log n) where m = |E|, n = |V|
   25|       |        fn dijkstra(graph: &WeightedDirGraphStEphFloat<usize>, source: usize) -> SSSPResultStEphFloat;
   26|       |    }
   27|       |
   28|       |    /// Priority queue entry: (distance, vertex)
   29|       |    /// Ordered by distance (min-heap)
   30|       |    #[derive(Clone, Eq, PartialEq, Debug)]
   31|       |    struct PQEntry {
   32|       |        dist: OrderedF64,
   33|       |        vertex: usize,
   34|       |    }
   35|       |
   36|       |    impl PQEntry {
   37|    111|        fn new(dist: OrderedF64, vertex: usize) -> Self { PQEntry { dist, vertex } }
   38|       |    }
   39|       |
   40|       |    impl Ord for PQEntry {
   41|     38|        fn cmp(&self, other: &Self) -> Ordering {
   42|       |            // Min-heap: smaller distance has higher priority
   43|     38|            self.dist.cmp(&other.dist)
   44|     38|        }
   45|       |    }
   46|       |
   47|       |    impl PartialOrd for PQEntry {
   48|     38|        fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(self.cmp(other)) }
   49|       |    }
   50|       |
   51|       |    impl Display for PQEntry {
   52|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult { write!(f, "({}, {})", self.dist, self.vertex) }
   53|       |    }
   54|       |
   55|       |    /// Runs Dijkstra's algorithm on a weighted directed graph
   56|       |    /// Computes single-source shortest paths for non-negative edge weights
   57|       |    ///
   58|       |    /// **Algorithm 57.2**: Priority-First Search using Priority Queue
   59|       |    ///
   60|       |    /// Work: O(m log n), Span: O(m log n)
   61|       |    /// where n = number of vertices, m = number of edges
   62|       |    ///
   63|       |    /// # Arguments
   64|       |    /// * `graph` - Weighted directed graph with non-negative float weights (usize vertices)
   65|       |    /// * `source` - Source vertex (0-indexed)
   66|       |    ///
   67|       |    /// # Returns
   68|       |    /// SSSPResultStEphFloat with distances and predecessors
   69|     47|    pub fn dijkstra(graph: &WeightedDirGraphStEphFloat<usize>, source: usize) -> SSSPResultStEphFloat {
   70|     47|        let n = graph.vertices().size();
   71|       |
   72|       |        // Initialize result with all distances = infinity except source = 0
   73|     47|        let mut result = SSSPResultStEphFloat::new(n, source);
   74|       |
   75|       |        // Track visited vertices (X in the algorithm)
   76|     47|        let mut visited: HashMap<usize, OrderedF64> = HashMap::new();
   77|       |
   78|       |        // Priority queue Q: stores PQEntry(distance, vertex)
   79|       |        // BinaryHeapPQ is a min-heap
   80|     47|        let mut pq: BinaryHeapPQ<PQEntry> = BinaryHeapPQ::singleton(PQEntry::new(OrderedF64::from(0.0), source));
   81|       |
   82|       |        // Main loop: deleteMin until queue is empty
   83|    158|        while !pq.is_empty() {
   84|       |            // deleteMin from priority queue
   85|    111|            let (new_pq, min_elem) = pq.delete_min();
   86|    111|            pq = new_pq;
   87|       |
   88|    111|            if let Some(entry) = min_elem {
   89|    111|                let dist = entry.dist;
   90|    111|                let v = entry.vertex;
   91|       |
   92|       |                // Skip if already visited (handles duplicate entries)
   93|    111|                if visited.contains_key(&v) {
   94|     14|                    continue;
   95|     97|                }
   96|       |
   97|       |                // Mark v as visited with distance dist
   98|     97|                visited.insert(v, dist);
   99|     97|                result.set_distance(v, dist);
  100|       |
  101|       |                // Relax all out-neighbors: add PQEntry(d + w, u) to PQ
  102|     97|                let neighbors = graph.out_neighbors_weighted(&v);
  103|     97|                for neighbor in neighbors.iter() {
                                  ^70
  104|     70|                    let (u, weight) = neighbor;
  105|     70|                    let u_idx = *u;
  106|       |
  107|       |                    // Skip if already visited
  108|     70|                    if visited.contains_key(&u_idx) {
  109|      6|                        continue;
  110|     64|                    }
  111|       |
  112|     64|                    let new_dist = OrderedF64::from(dist.0 + weight.0);
  113|     64|                    pq = pq.insert(PQEntry::new(new_dist, u_idx));
  114|       |
  115|       |                    // Update predecessor if this is a better path
  116|       |                    // (First time we reach u with minimum distance through PQ ordering)
  117|     64|                    if result.get_distance(u_idx) > new_dist {
  118|     64|                        result.set_predecessor(u_idx, v);
  119|     64|                    }
                                  ^0
  120|       |                }
  121|      0|            }
  122|       |        }
  123|       |
  124|     47|        result
  125|     47|    }
  126|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap57/DijkstraStEphInt.rs:
    1|       |//! Copyright  2025 APAS-VERUS. All rights reserved.
    2|       |//!
    3|       |//! Dijkstra's Algorithm - Single Source Shortest Path (SSSP+) for non-negative integer edge weights
    4|       |//!
    5|       |//! Implements Algorithm 57.2 from the textbook using priority queues.
    6|       |//!
    7|       |//! **Algorithmic Analysis:**
    8|       |//! - Dijkstra: Work O(m log n), Span O(m log n) where m = |E|, n = |V|
    9|       |
   10|       |pub mod DijkstraStEphInt {
   11|       |
   12|       |    use std::cmp::Ordering;
   13|       |    use std::collections::HashMap;
   14|       |    use std::fmt::{Debug, Display, Formatter, Result as FmtResult};
   15|       |
   16|       |    use crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::LabDirGraphStEphTrait;
   17|       |    use crate::Chap06::WeightedDirGraphStEphInt::WeightedDirGraphStEphInt::WeightedDirGraphStEphInt;
   18|       |    use crate::Chap45::BinaryHeapPQ::BinaryHeapPQ::*;
   19|       |    use crate::Chap56::SSSPResultStEphInt::SSSPResultStEphInt::SSSPResultStEphInt;
   20|       |    use crate::Types::Types::*;
   21|       |
   22|       |    pub trait DijkstraStEphIntTrait {
   23|       |        /// Dijkstra's single source shortest path algorithm
   24|       |        /// APAS: Work O(m log n), Span O(m log n) where m = |E|, n = |V|
   25|       |        fn dijkstra(graph: &WeightedDirGraphStEphInt<usize>, source: usize) -> SSSPResultStEphInt;
   26|       |    }
   27|       |
   28|       |    /// Priority queue entry: (distance, vertex)
   29|       |    /// Ordered by distance (min-heap)
   30|       |    #[derive(Clone, Eq, PartialEq, Debug)]
   31|       |    struct PQEntry {
   32|       |        dist: i64,
   33|       |        vertex: usize,
   34|       |    }
   35|       |
   36|       |    impl PQEntry {
   37|    117|        fn new(dist: i64, vertex: usize) -> Self { PQEntry { dist, vertex } }
   38|       |    }
   39|       |
   40|       |    impl Ord for PQEntry {
   41|     63|        fn cmp(&self, other: &Self) -> Ordering {
   42|       |            // Min-heap: smaller distance has higher priority
   43|     63|            self.dist.cmp(&other.dist)
   44|     63|        }
   45|       |    }
   46|       |
   47|       |    impl PartialOrd for PQEntry {
   48|     63|        fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(self.cmp(other)) }
   49|       |    }
   50|       |
   51|       |    impl Display for PQEntry {
   52|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult { write!(f, "({}, {})", self.dist, self.vertex) }
   53|       |    }
   54|       |
   55|       |    /// Runs Dijkstra's algorithm on a weighted directed graph
   56|       |    /// Computes single-source shortest paths for non-negative edge weights
   57|       |    ///
   58|       |    /// **Algorithm 57.2**: Priority-First Search using Priority Queue
   59|       |    ///
   60|       |    /// Work: O(m log n), Span: O(m log n)
   61|       |    /// where n = number of vertices, m = number of edges
   62|       |    ///
   63|       |    /// # Arguments
   64|       |    /// * `graph` - Weighted directed graph with non-negative integer weights (usize vertices)
   65|       |    /// * `source` - Source vertex (0-indexed)
   66|       |    ///
   67|       |    /// # Returns
   68|       |    /// SSSPResultStEphInt with distances and predecessors
   69|     37|    pub fn dijkstra(graph: &WeightedDirGraphStEphInt<usize>, source: usize) -> SSSPResultStEphInt {
   70|     37|        let n = graph.vertices().size();
   71|       |
   72|       |        // Initialize result with all distances = infinity except source = 0
   73|     37|        let mut result = SSSPResultStEphInt::new(n, source);
   74|       |
   75|       |        // Track visited vertices (X in the algorithm)
   76|     37|        let mut visited: HashMap<usize, i64> = HashMap::new();
   77|       |
   78|       |        // Priority queue Q: stores PQEntry(distance, vertex)
   79|       |        // BinaryHeapPQ is a min-heap
   80|     37|        let mut pq: BinaryHeapPQ<PQEntry> = BinaryHeapPQ::singleton(PQEntry::new(0, source));
   81|       |
   82|       |        // Main loop: deleteMin until queue is empty
   83|    154|        while !pq.is_empty() {
   84|       |            // deleteMin from priority queue
   85|    117|            let (new_pq, min_elem) = pq.delete_min();
   86|    117|            pq = new_pq;
   87|       |
   88|    117|            if let Some(entry) = min_elem {
   89|    117|                let dist = entry.dist;
   90|    117|                let v = entry.vertex;
   91|       |
   92|       |                // Skip if already visited (handles duplicate entries)
   93|    117|                if visited.contains_key(&v) {
   94|     18|                    continue;
   95|     99|                }
   96|       |
   97|       |                // Mark v as visited with distance dist
   98|     99|                visited.insert(v, dist);
   99|     99|                result.set_distance(v, dist);
  100|       |
  101|       |                // Relax all out-neighbors: add PQEntry(d + w, u) to PQ
  102|     99|                let neighbors = graph.out_neighbors_weighted(&v);
  103|    105|                for neighbor in neighbors.iter() {
                                              ^99       ^99
  104|    105|                    let (u, weight) = neighbor;
  105|    105|                    let u_idx = *u;
  106|       |
  107|       |                    // Skip if already visited
  108|    105|                    if visited.contains_key(&u_idx) {
  109|     25|                        continue;
  110|     80|                    }
  111|       |
  112|     80|                    let new_dist = dist + (*weight as i64);
  113|     80|                    pq = pq.insert(PQEntry::new(new_dist, u_idx));
  114|       |
  115|       |                    // Update predecessor if this is a better path
  116|       |                    // (First time we reach u with minimum distance through PQ ordering)
  117|     80|                    if result.get_distance(u_idx) > new_dist {
  118|     80|                        result.set_predecessor(u_idx, v);
  119|     80|                    }
                                  ^0
  120|       |                }
  121|      0|            }
  122|       |        }
  123|       |
  124|     37|        result
  125|     37|    }
  126|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap57/StackStEph.rs:
    1|       |//! Copyright  2025 APAS-VERUS. All rights reserved.
    2|       |//!
    3|       |//! Stack - Sequential Ephemeral implementation
    4|       |//!
    5|       |//! A stack is a Last-In-First-Out (LIFO) data structure.
    6|       |//!
    7|       |//! **Algorithmic Analysis:**
    8|       |//! - `new`: Work O(1), Span O(1)
    9|       |//! - `push`: Work O(1) amortized, Span O(1) amortized
   10|       |//! - `pop`: Work O(1) amortized, Span O(1) amortized
   11|       |//! - `peek`: Work O(1), Span O(1)
   12|       |//! - `is_empty`: Work O(1), Span O(1)
   13|       |//! - `size`: Work O(1), Span O(1)
   14|       |
   15|       |pub mod StackStEph {
   16|       |
   17|       |    use crate::Types::Types::*;
   18|       |
   19|       |    /// Trait for stack operations
   20|       |    pub trait StackStEphTrait<T: StT> {
   21|       |        /// Create new empty stack
   22|       |        /// APAS: Work (1), Span (1)
   23|       |        fn new() -> Self;
   24|       |
   25|       |        /// Push element onto stack
   26|       |        /// APAS: Work (1), Span (1)
   27|       |        fn push(&mut self, item: T);
   28|       |
   29|       |        /// Pop element from stack
   30|       |        /// APAS: Work (1), Span (1)
   31|       |        fn pop(&mut self) -> Option<T>;
   32|       |
   33|       |        /// Check if stack is empty
   34|       |        /// APAS: Work (1), Span (1)
   35|       |        fn is_empty(&self) -> B;
   36|       |    }
   37|       |
   38|       |    #[derive(Debug, Clone)]
   39|       |    pub struct StackStEph<T: StT> {
   40|       |        /// Backing storage using Vec for efficient push/pop
   41|       |        elements: Vec<T>,
   42|       |    }
   43|       |
   44|       |    impl<T: StT> StackStEph<T> {
   45|       |        /// Creates a new empty stack
   46|       |        /// Work O(1), Span O(1)
   47|     10|        pub fn new() -> Self { StackStEph { elements: Vec::new() } }
   48|       |
   49|       |        /// Pushes an item onto the stack
   50|       |        /// Work O(1) amortized, Span O(1) amortized
   51|     28|        pub fn push(&mut self, item: T) { self.elements.push(item); }
   52|       |
   53|       |        /// Pops and returns the top item from the stack
   54|       |        /// Returns None if the stack is empty
   55|       |        /// Work O(1) amortized, Span O(1) amortized
   56|     20|        pub fn pop(&mut self) -> Option<T> { self.elements.pop() }
   57|       |
   58|       |        /// Returns a reference to the top item without removing it
   59|       |        /// Returns None if the stack is empty
   60|       |        /// Work O(1), Span O(1)
   61|      7|        pub fn peek(&self) -> Option<&T> { self.elements.last() }
   62|       |
   63|       |        /// Checks if the stack is empty
   64|       |        /// Work O(1), Span O(1)
   65|      5|        pub fn is_empty(&self) -> bool { self.elements.is_empty() }
   66|       |
   67|       |        /// Returns the number of elements in the stack
   68|       |        /// Work O(1), Span O(1)
   69|     26|        pub fn size(&self) -> N { self.elements.len() }
   70|       |    }
   71|       |
   72|       |    impl<T: StT> Default for StackStEph<T> {
   73|      1|        fn default() -> Self { Self::new() }
   74|       |    }
   75|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap58/BellmanFordStEphFloat.rs:
    1|       |//! Copyright  2025 APAS-VERUS. All rights reserved.
    2|       |//!
    3|       |//! Bellman-Ford's Algorithm - Single Source Shortest Path with arbitrary edge weights (float)
    4|       |//!
    5|       |//! Implements Algorithm 58.2 from the textbook.
    6|       |//! Handles negative edge weights and detects negative-weight cycles.
    7|       |//!
    8|       |//! **Algorithmic Analysis:**
    9|       |//! - Bellman-Ford: Work O(nm), Span O(n lg n) where n = |V|, m = |E|
   10|       |//! - Parallelizable: Lines 5-6 parallelize over vertices
   11|       |
   12|       |pub mod BellmanFordStEphFloat {
   13|       |
   14|       |    use std::collections::HashMap;
   15|       |
   16|       |    use crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::LabDirGraphStEphTrait;
   17|       |    use crate::Chap06::WeightedDirGraphStEphFloat::WeightedDirGraphStEphFloat::WeightedDirGraphStEphFloat;
   18|       |    use crate::Chap56::SSSPResultStEphFloat::SSSPResultStEphFloat::SSSPResultStEphFloat;
   19|       |    use crate::Types::Types::*;
   20|       |
   21|       |    pub trait BellmanFordStEphFloatTrait {
   22|       |        /// Bellman-Ford single source shortest path algorithm
   23|       |        /// APAS: Work O(nm), Span O(n lg n) where n = |V|, m = |E|
   24|       |        fn bellman_ford(graph: &WeightedDirGraphStEphFloat<usize>, source: usize) -> SSSPResultStEphFloat;
   25|       |    }
   26|       |
   27|       |    /// Runs Bellman-Ford algorithm on a weighted directed graph
   28|       |    /// Computes single-source shortest paths for arbitrary edge weights (including negative)
   29|       |    ///
   30|       |    /// **Algorithm 58.2**: Iterative k-hop distance computation
   31|       |    ///
   32|       |    /// Work: O(nm), Span: O(n lg n) where n = |V|, m = |E|
   33|       |    ///
   34|       |    /// # Arguments
   35|       |    /// * `graph` - Weighted directed graph with float weights (can be negative)
   36|       |    /// * `source` - Source vertex (0-indexed)
   37|       |    ///
   38|       |    /// # Returns
   39|       |    /// * `Ok(SSSPResultStEphFloat)` - Shortest paths if no negative-weight cycles
   40|       |    /// * `Err(String)` - Error message if negative-weight cycle detected
   41|       |    ///
   42|       |    /// # Algorithm
   43|       |    /// 1. Initialize distances: d(s) = 0, d(v) =  for v  s
   44|       |    /// 2. For each round k = 0 to |V|-1:
   45|       |    ///    - For each vertex v in parallel:
   46|       |    ///      - Compute Din(v) = min over u  N(v) of (d[u] + w(u,v))
   47|       |    ///      - Update d'[v] = min(d[v], Din(v))
   48|       |    ///    - If no distances changed, return (converged)
   49|       |    /// 3. If |V| rounds completed without convergence, negative cycle exists
   50|     20|    pub fn bellman_ford(
   51|     20|        graph: &WeightedDirGraphStEphFloat<usize>,
   52|     20|        source: usize,
   53|     20|    ) -> Result<SSSPResultStEphFloat, String> {
   54|     20|        let n = graph.vertices().size();
   55|       |
   56|       |        // Initialize distances: source = 0, others = infinity
   57|     20|        let mut distances: HashMap<usize, OrderedF64> = HashMap::new();
   58|     74|        for v in 0..n {
                                  ^20
   59|     74|            distances.insert(
   60|     74|                v,
   61|     74|                if v == source {
   62|     20|                    OrderedF64::from(0.0)
   63|       |                } else {
   64|     54|                    OrderedF64::from(f64::INFINITY)
   65|       |                },
   66|       |            );
   67|       |        }
   68|       |
   69|       |        // Iterate up to |V| rounds
   70|     49|        for round in 0..n {
                                      ^20
   71|     49|            let mut changed = false;
   72|     49|            let mut new_distances: HashMap<usize, OrderedF64> = HashMap::new();
   73|       |
   74|       |            // For each vertex, compute minimum distance through in-neighbors (Line 5)
   75|    183|            for v in 0..n {
                                      ^49
   76|    183|                let current_dist = *distances.get(&v).unwrap_or(&OrderedF64::from(f64::INFINITY));
   77|    183|                let mut min_dist = current_dist;
   78|       |
   79|       |                // Compute Din(v) = min over u in N(v) of (d[u] + w(u,v))
   80|    183|                let in_neighbors = graph.in_neighbors_weighted(&v);
   81|    228|                for (u, weight) in in_neighbors.iter() {
                                                 ^183         ^183
   82|    228|                    let u_dist = *distances.get(u).unwrap_or(&OrderedF64::from(f64::INFINITY));
   83|    228|                    if u_dist.0 != f64::INFINITY {
   84|    183|                        let new_dist = OrderedF64::from(u_dist.0 + weight.0);
   85|    183|                        if new_dist < min_dist {
   86|     59|                            min_dist = new_dist;
   87|    124|                        }
   88|     45|                    }
   89|       |                }
   90|       |
   91|       |                // Update distance (Line 6)
   92|    183|                new_distances.insert(v, min_dist);
   93|    183|                if min_dist != current_dist {
   94|     59|                    changed = true;
   95|    124|                }
   96|       |            }
   97|       |
   98|       |            // Update distances for next round
   99|     49|            distances = new_distances;
  100|       |
  101|       |            // Check for convergence (Line 9-10)
  102|     49|            if !changed {
  103|       |                // No changes, converged - build result
  104|     19|                let mut result = SSSPResultStEphFloat::new(n, source);
  105|     71|                for v in 0..n {
                                          ^19
  106|     71|                    let dist = *distances.get(&v).unwrap_or(&OrderedF64::from(f64::INFINITY));
  107|     71|                    result.set_distance(v, dist);
  108|     71|                }
  109|       |
  110|       |                // Reconstruct predecessors
  111|     19|                reconstruct_predecessors(graph, &distances, &mut result, source);
  112|       |
  113|     19|                return Ok(result);
  114|     30|            }
  115|       |
  116|       |            // Check if we've reached |V| rounds without convergence (Line 8)
  117|     30|            if round == n - 1 {
  118|      1|                return Err("Negative-weight cycle detected".to_string());
  119|     29|            }
  120|       |        }
  121|       |
  122|       |        // Should not reach here, but handle it
  123|      0|        Err("Algorithm error: max rounds exceeded".to_string())
  124|     20|    }
  125|       |
  126|       |    /// Reconstruct predecessor tree from final distances
  127|       |    /// For each vertex v, find the in-neighbor u that achieves the shortest path
  128|     19|    fn reconstruct_predecessors(
  129|     19|        graph: &WeightedDirGraphStEphFloat<usize>,
  130|     19|        distances: &HashMap<usize, OrderedF64>,
  131|     19|        result: &mut SSSPResultStEphFloat,
  132|     19|        source: usize,
  133|     19|    ) {
  134|     19|        let n = graph.vertices().size();
  135|     71|        for v in 0..n {
                                  ^19
  136|     71|            if v == source {
  137|     19|                continue;
  138|     52|            }
  139|       |
  140|     52|            let v_dist = *distances.get(&v).unwrap_or(&OrderedF64::from(f64::INFINITY));
  141|     52|            if v_dist.0 == f64::INFINITY {
  142|      1|                continue; // Unreachable
  143|     51|            }
  144|       |
  145|       |            // Find which in-neighbor u gave us the shortest path
  146|     51|            let in_neighbors = graph.in_neighbors_weighted(&v);
  147|     69|            for (u, weight) in in_neighbors.iter() {
                                             ^51          ^51
  148|     69|                let u_dist = *distances.get(u).unwrap_or(&OrderedF64::from(f64::INFINITY));
  149|     69|                if u_dist.0 != f64::INFINITY {
  150|     69|                    let path_dist = OrderedF64::from(u_dist.0 + weight.0);
  151|     69|                    if path_dist == v_dist {
  152|     51|                        result.set_predecessor(v, *u);
  153|     51|                        break; // Found the predecessor
  154|     18|                    }
  155|      0|                }
  156|       |            }
  157|       |        }
  158|     19|    }
  159|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap58/BellmanFordStEphInt.rs:
    1|       |//! Copyright  2025 APAS-VERUS. All rights reserved.
    2|       |//!
    3|       |//! Bellman-Ford's Algorithm - Single Source Shortest Path with arbitrary edge weights (integer)
    4|       |//!
    5|       |//! Implements Algorithm 58.2 from the textbook.
    6|       |//! Handles negative edge weights and detects negative-weight cycles.
    7|       |//!
    8|       |//! **Algorithmic Analysis:**
    9|       |//! - Bellman-Ford: Work O(nm), Span O(n lg n) where n = |V|, m = |E|
   10|       |//! - Parallelizable: Lines 5-6 parallelize over vertices
   11|       |
   12|       |pub mod BellmanFordStEphInt {
   13|       |
   14|       |    use std::collections::HashMap;
   15|       |
   16|       |    use crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::LabDirGraphStEphTrait;
   17|       |    use crate::Chap06::WeightedDirGraphStEphInt::WeightedDirGraphStEphInt::WeightedDirGraphStEphInt;
   18|       |    use crate::Chap56::SSSPResultStEphInt::SSSPResultStEphInt::SSSPResultStEphInt;
   19|       |    use crate::Types::Types::*;
   20|       |
   21|       |    pub trait BellmanFordStEphIntTrait {
   22|       |        /// Bellman-Ford single source shortest path algorithm
   23|       |        /// APAS: Work O(nm), Span O(n lg n) where n = |V|, m = |E|
   24|       |        fn bellman_ford(graph: &WeightedDirGraphStEphInt<usize>, source: usize) -> Result<SSSPResultStEphInt, String>;
   25|       |    }
   26|       |
   27|       |    /// Runs Bellman-Ford algorithm on a weighted directed graph
   28|       |    /// Computes single-source shortest paths for arbitrary edge weights (including negative)
   29|       |    ///
   30|       |    /// **Algorithm 58.2**: Iterative k-hop distance computation
   31|       |    ///
   32|       |    /// Work: O(nm), Span: O(n lg n) where n = |V|, m = |E|
   33|       |    ///
   34|       |    /// # Arguments
   35|       |    /// * `graph` - Weighted directed graph with integer weights (can be negative)
   36|       |    /// * `source` - Source vertex (0-indexed)
   37|       |    ///
   38|       |    /// # Returns
   39|       |    /// * `Ok(SSSPResultStEphInt)` - Shortest paths if no negative-weight cycles
   40|       |    /// * `Err(String)` - Error message if negative-weight cycle detected
   41|       |    ///
   42|       |    /// # Algorithm
   43|       |    /// 1. Initialize distances: d(s) = 0, d(v) =  for v  s
   44|       |    /// 2. For each round k = 0 to |V|-1:
   45|       |    ///    - For each vertex v in parallel:
   46|       |    ///      - Compute Din(v) = min over u  N(v) of (d[u] + w(u,v))
   47|       |    ///      - Update d'[v] = min(d[v], Din(v))
   48|       |    ///    - If no distances changed, return (converged)
   49|       |    /// 3. If |V| rounds completed without convergence, negative cycle exists
   50|     20|    pub fn bellman_ford(graph: &WeightedDirGraphStEphInt<usize>, source: usize) -> Result<SSSPResultStEphInt, String> {
   51|     20|        let n = graph.vertices().size();
   52|       |
   53|       |        // Initialize distances: source = 0, others = infinity
   54|     20|        let mut distances: HashMap<usize, i64> = HashMap::new();
   55|     75|        for v in 0..n {
                                  ^20
   56|     75|            distances.insert(v, if v == source { 0 } else { i64::MAX });
                                                               ^20        ^55
   57|       |        }
   58|       |
   59|       |        // Iterate up to |V| rounds
   60|     57|        for round in 0..n {
                                      ^20
   61|     57|            let mut changed = false;
   62|     57|            let mut new_distances: HashMap<usize, i64> = HashMap::new();
   63|       |
   64|       |            // For each vertex, compute minimum distance through in-neighbors (Line 5)
   65|    224|            for v in 0..n {
                                      ^57
   66|    224|                let current_dist = *distances.get(&v).unwrap_or(&i64::MAX);
   67|    224|                let mut min_dist = current_dist;
   68|       |
   69|       |                // Compute Din(v) = min over u in N(v) of (d[u] + w(u,v))
   70|    224|                let in_neighbors = graph.in_neighbors_weighted(&v);
   71|    301|                for (u, weight) in in_neighbors.iter() {
                                                 ^224         ^224
   72|    301|                    let u_dist = *distances.get(u).unwrap_or(&i64::MAX);
   73|    301|                    if u_dist != i64::MAX {
   74|       |                        // Check for overflow before adding
   75|    239|                        let new_dist = u_dist.saturating_add(*weight as i64);
   76|    239|                        if new_dist < min_dist {
   77|     67|                            min_dist = new_dist;
   78|    172|                        }
   79|     62|                    }
   80|       |                }
   81|       |
   82|       |                // Update distance (Line 6)
   83|    224|                new_distances.insert(v, min_dist);
   84|    224|                if min_dist != current_dist {
   85|     65|                    changed = true;
   86|    159|                }
   87|       |            }
   88|       |
   89|       |            // Update distances for next round
   90|     57|            distances = new_distances;
   91|       |
   92|       |            // Check for convergence (Line 9-10)
   93|     57|            if !changed {
   94|       |                // No changes, converged - build result
   95|     19|                let mut result = SSSPResultStEphInt::new(n, source);
   96|     71|                for v in 0..n {
                                          ^19
   97|     71|                    let dist = *distances.get(&v).unwrap_or(&i64::MAX);
   98|     71|                    result.set_distance(v, dist);
   99|     71|                }
  100|       |
  101|       |                // Reconstruct predecessors
  102|     19|                reconstruct_predecessors(graph, &distances, &mut result, source);
  103|       |
  104|     19|                return Ok(result);
  105|     38|            }
  106|       |
  107|       |            // Check if we've reached |V| rounds without convergence (Line 8)
  108|     38|            if round == n - 1 {
  109|      1|                return Err("Negative-weight cycle detected".to_string());
  110|     37|            }
  111|       |        }
  112|       |
  113|       |        // Should not reach here, but handle it
  114|      0|        Err("Algorithm error: max rounds exceeded".to_string())
  115|     20|    }
  116|       |
  117|       |    /// Reconstruct predecessor tree from final distances
  118|       |    /// For each vertex v, find the in-neighbor u that achieves the shortest path
  119|     19|    fn reconstruct_predecessors(
  120|     19|        graph: &WeightedDirGraphStEphInt<usize>,
  121|     19|        distances: &HashMap<usize, i64>,
  122|     19|        result: &mut SSSPResultStEphInt,
  123|     19|        source: usize,
  124|     19|    ) {
  125|     19|        let n = graph.vertices().size();
  126|     71|        for v in 0..n {
                                  ^19
  127|     71|            if v == source {
  128|     19|                continue;
  129|     52|            }
  130|       |
  131|     52|            let v_dist = *distances.get(&v).unwrap_or(&i64::MAX);
  132|     52|            if v_dist == i64::MAX {
  133|      1|                continue; // Unreachable
  134|     51|            }
  135|       |
  136|       |            // Find which in-neighbor u gave us the shortest path
  137|     51|            let in_neighbors = graph.in_neighbors_weighted(&v);
  138|     68|            for (u, weight) in in_neighbors.iter() {
                                             ^51          ^51
  139|     68|                let u_dist = *distances.get(u).unwrap_or(&i64::MAX);
  140|     68|                if u_dist != i64::MAX {
  141|     68|                    let path_dist = u_dist.saturating_add(*weight as i64);
  142|     68|                    if path_dist == v_dist {
  143|     51|                        result.set_predecessor(v, *u);
  144|     51|                        break; // Found the predecessor
  145|     17|                    }
  146|      0|                }
  147|       |            }
  148|       |        }
  149|     19|    }
  150|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap59/JohnsonMtEphFloat.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 59: Johnson's Algorithm - Multi-threaded Ephemeral Float Weights
    3|       |//!
    4|       |//! Implements Algorithm 59.1 from the textbook with parallelism in Phase 3.
    5|       |//! All-Pairs Shortest Paths for graphs with negative weights (but no negative cycles).
    6|       |//!
    7|       |//! **Algorithmic Analysis:**
    8|       |//! - Johnson APSP: Work O(mn log n), Span O(m log n), Parallelism (n) where n = |V|, m = |E|
    9|       |//! - Phase 1 (Bellman-Ford): Work O(nm), Span O(nm) - sequential
   10|       |//! - Phase 2 (Reweighting): Work O(m), Span O(m) - sequential
   11|       |//! - Phase 3 (n Dijkstras in parallel): Work O(n * m log n) = O(mn log n), Span O(m log n)
   12|       |//! - Parallelism in Phase 3: (n) - n independent Dijkstra runs
   13|       |
   14|       |pub mod JohnsonMtEphFloat {
   15|       |
   16|       |    use std::thread;
   17|       |
   18|       |    use crate::Chap05::SetStEph::SetStEph::*;
   19|       |    use crate::Chap06::LabDirGraphMtEph::LabDirGraphMtEph::LabDirGraphMtEphTrait;
   20|       |    use crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::*;
   21|       |    use crate::Chap06::WeightedDirGraphMtEphFloat::WeightedDirGraphMtEphFloat::*;
   22|       |    use crate::Chap06::WeightedDirGraphStEphFloat::WeightedDirGraphStEphFloat::*;
   23|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   24|       |    use crate::Chap56::AllPairsResultStEphFloat::AllPairsResultStEphFloat::AllPairsResultStEphFloat;
   25|       |    use crate::Chap57::DijkstraStEphFloat::DijkstraStEphFloat::dijkstra;
   26|       |    use crate::Chap58::BellmanFordStEphFloat::BellmanFordStEphFloat::bellman_ford;
   27|       |    use crate::Types::Types::*;
   28|       |
   29|       |    pub trait JohnsonMtEphFloatTrait {
   30|       |        /// Parallel Johnson's all-pairs shortest path algorithm
   31|       |        /// APAS: Work O(mn log n), Span O(m log n) where n = |V|, m = |E|
   32|       |        fn johnson_apsp(graph: &WeightedDirGraphMtEphFloat<usize>) -> AllPairsResultStEphFloat;
   33|       |    }
   34|       |
   35|       |    /// Algorithm 59.1: Johnson's All-Pairs Shortest Paths (Parallel - Float version)
   36|       |    ///
   37|       |    /// Solves APSP problem with negative float weights using:
   38|       |    /// 1. Bellman-Ford to compute potentials (sequential)
   39|       |    /// 2. Reweight edges (sequential)
   40|       |    /// 3. Parallel Dijkstra from each vertex using ParaPair! divide-and-conquer
   41|       |    ///
   42|       |    /// **APAS Analysis:** Work O(mn log n), Span O(m log n), Parallelism (n)
   43|       |    /// **Claude Analysis:**
   44|       |    /// - Phase 1: Bellman-Ford: Work O(nm), Span O(nm) - sequential
   45|       |    /// - Phase 2: Reweighting: Work O(m), Span O(m) - sequential
   46|       |    /// - Phase 3: n Dijkstras via ParaPair! recursion:
   47|       |    ///   * Work O(n * m log n) = O(mn log n)
   48|       |    ///   * Span O(log n) recursion depth  O(m log n) per Dijkstra = O(m log n)
   49|       |    ///   * However, since all n Dijkstras can run in parallel, effective Span O(m log n)
   50|       |    ///   * Parallelism (n * m log n) / (m log n) = (n)
   51|       |    /// - Total: Work O(mn log n), Span O(m log n), Parallelism (n)
   52|       |    ///
   53|       |    /// # Arguments
   54|       |    /// * `graph` - Weighted directed graph with float weights (can be negative, no negative cycles)
   55|       |    ///
   56|       |    /// # Returns
   57|       |    /// `AllPairsResultStEphFloat` containing nn distance matrix and predecessor matrix
   58|     10|    pub fn johnson_apsp(graph: &WeightedDirGraphMtEphFloat<usize>) -> AllPairsResultStEphFloat {
   59|     10|        let n = graph.vertices().size();
   60|       |
   61|       |        // Phase 1: Add dummy source and run Bellman-Ford
   62|     10|        let (graph_with_dummy, dummy_idx) = add_dummy_source(graph, n);
   63|       |
   64|     10|        let bellman_ford_result = match bellman_ford(&graph_with_dummy, dummy_idx) {
   65|     10|            | Ok(res) => res,
   66|       |            | Err(_) => {
   67|       |                // Negative cycle detected - return infinity matrix
   68|      0|                return create_negative_cycle_result(n);
   69|       |            }
   70|       |        };
   71|       |
   72|       |        // Extract potentials
   73|     28|        let potentials = ArraySeqStEphS::tabulate(&|i| bellman_ford_result.get_distance(i), n);
                          ^10          ^10                                                                ^10
   74|       |
   75|       |        // Phase 2: Reweight edges to eliminate negative weights
   76|     10|        let reweighted_graph = reweight_graph(graph, &potentials, n);
   77|       |
   78|       |        // Phase 3: Run Dijkstra from each vertex IN PARALLEL and adjust distances
   79|       |        // Unconditionally parallel using recursive divide-and-conquer with ParaPair!
   80|     10|        let (all_distances, all_predecessors) = parallel_dijkstra_all(&reweighted_graph, &potentials, 0, n, n);
   81|       |
   82|     10|        AllPairsResultStEphFloat {
   83|     10|            distances: all_distances,
   84|     10|            predecessors: all_predecessors,
   85|     10|            n,
   86|     10|        }
   87|     10|    }
   88|       |
   89|       |    /// Parallel Dijkstra execution using recursive divide-and-conquer with ParaPair!
   90|       |    /// Returns sequences of distance and predecessor rows
   91|     46|    fn parallel_dijkstra_all(
   92|     46|        graph: &WeightedDirGraphStEphFloat<usize>,
   93|     46|        potentials: &ArraySeqStEphS<OrderedF64>,
   94|     46|        start: usize,
   95|     46|        end: usize,
   96|     46|        n: usize,
   97|     46|    ) -> (
   98|     46|        ArraySeqStEphS<ArraySeqStEphS<OrderedF64>>,
   99|     46|        ArraySeqStEphS<ArraySeqStEphS<usize>>,
  100|     46|    ) {
  101|     46|        let range_size = end - start;
  102|       |
  103|       |        // Base case: empty range
  104|     46|        if range_size == 0 {
  105|      0|            return (ArraySeqStEphS::empty(), ArraySeqStEphS::empty());
  106|     46|        }
  107|       |
  108|       |        // Base case: single vertex
  109|     46|        if range_size == 1 {
  110|     28|            let u = start;
  111|     28|            let dijkstra_result = dijkstra(graph, u);
  112|       |
  113|       |            // Adjust distances: G(u,v) = G'(u,v) - p(u) + p(v)
  114|     28|            let p_u = *potentials.nth(u);
  115|     28|            let adjusted_row = ArraySeqStEphS::tabulate(
  116|     86|                &|v| {
  117|     86|                    let d_prime = dijkstra_result.get_distance(v);
  118|     86|                    if d_prime == OrderedF64::from(f64::INFINITY) {
  119|     29|                        OrderedF64::from(f64::INFINITY)
  120|       |                    } else {
  121|     57|                        let p_v = *potentials.nth(v);
  122|     57|                        OrderedF64::from(d_prime.0 - p_u.0 + p_v.0)
  123|       |                    }
  124|     86|                },
  125|     28|                n,
  126|       |            );
  127|       |
  128|     28|            let dist_seq = ArraySeqStEphS::singleton(adjusted_row);
  129|     28|            let pred_seq = ArraySeqStEphS::singleton(dijkstra_result.predecessors.clone());
  130|     28|            return (dist_seq, pred_seq);
  131|     18|        }
  132|       |
  133|       |        // Recursive case: split in half and use ParaPair! for unconditional parallelism
  134|     18|        let mid = start + range_size / 2;
  135|     18|        let graph_left = graph.clone();
  136|     18|        let graph_right = graph.clone();
  137|     18|        let potentials_left = potentials.clone();
  138|     18|        let potentials_right = potentials.clone();
  139|       |
  140|     18|        let Pair((left_dist, left_pred), (right_dist, right_pred)) = crate::ParaPair!(
  141|     18|            move || parallel_dijkstra_all(&graph_left, &potentials_left, start, mid, n),
  142|     18|            move || parallel_dijkstra_all(&graph_right, &potentials_right, mid, end, n)
  143|       |        );
  144|       |
  145|       |        // Combine results
  146|     18|        let combined_dist = ArraySeqStEphS::append(&left_dist, &right_dist);
  147|     18|        let combined_pred = ArraySeqStEphS::append(&left_pred, &right_pred);
  148|       |
  149|     18|        (combined_dist, combined_pred)
  150|     46|    }
  151|       |
  152|       |    /// Add dummy source with zero-weight edges to all vertices
  153|     10|    fn add_dummy_source(
  154|     10|        graph: &WeightedDirGraphMtEphFloat<usize>,
  155|     10|        n: usize,
  156|     10|    ) -> (WeightedDirGraphStEphFloat<usize>, usize) {
  157|       |        // Convert MtEph graph to StEph for Bellman-Ford
  158|     10|        let mut vertices = Set::empty();
  159|     28|        for i in 0..n {
                                  ^10
  160|     28|            vertices.insert(i);
  161|     28|        }
  162|       |
  163|       |        // Add dummy vertex
  164|     10|        vertices.insert(n);
  165|       |
  166|     10|        let mut edges = Set::empty();
  167|       |
  168|       |        // Copy all original edges
  169|     28|        for u in 0..n {
                                  ^10
  170|     28|            for v_w in graph.out_neighbors_weighted(&u).iter() {
                              ^24
  171|     24|                let (v, w) = v_w;
  172|     24|                edges.insert((u, *v, *w));
  173|     24|            }
  174|       |        }
  175|       |
  176|       |        // Add edges from dummy source to all original vertices
  177|     28|        for v in 0..n {
                                  ^10
  178|     28|            edges.insert((n, v, OrderedF64::from(0.0)));
  179|     28|        }
  180|       |
  181|     10|        (WeightedDirGraphStEphFloat::from_weighted_edges(vertices, edges), n)
  182|     10|    }
  183|       |
  184|       |    /// Reweight edges: w'(u,v) = w(u,v) + p(u) - p(v)
  185|     10|    fn reweight_graph(
  186|     10|        graph: &WeightedDirGraphMtEphFloat<usize>,
  187|     10|        potentials: &ArraySeqStEphS<OrderedF64>,
  188|     10|        n: usize,
  189|     10|    ) -> WeightedDirGraphStEphFloat<usize> {
  190|     10|        let mut vertices = Set::empty();
  191|     28|        for i in 0..n {
                                  ^10
  192|     28|            vertices.insert(i);
  193|     28|        }
  194|       |
  195|     10|        let mut reweighted_edges = Set::empty();
  196|     28|        for u in 0..n {
                                  ^10
  197|     28|            let p_u = *potentials.nth(u);
  198|     28|            for v_w in graph.out_neighbors_weighted(&u).iter() {
                              ^24
  199|     24|                let (v, w) = v_w;
  200|     24|                let p_v = *potentials.nth(*v);
  201|     24|                let w_prime = OrderedF64::from(w.0 + p_u.0 - p_v.0);
  202|     24|                reweighted_edges.insert((u, *v, w_prime));
  203|     24|            }
  204|       |        }
  205|       |
  206|     10|        WeightedDirGraphStEphFloat::from_weighted_edges(vertices, reweighted_edges)
  207|     10|    }
  208|       |
  209|       |    /// Create result for negative cycle case
  210|      0|    fn create_negative_cycle_result(n: usize) -> AllPairsResultStEphFloat {
  211|      0|        let distances = ArraySeqStEphS::tabulate(
  212|      0|            &|_| ArraySeqStEphS::tabulate(&|_| OrderedF64::from(f64::INFINITY), n),
  213|      0|            n,
  214|       |        );
  215|      0|        let predecessors = ArraySeqStEphS::tabulate(&|_| ArraySeqStEphS::tabulate(&|_| 0, n), n);
  216|      0|        AllPairsResultStEphFloat {
  217|      0|            distances,
  218|      0|            predecessors,
  219|      0|            n,
  220|      0|        }
  221|      0|    }
  222|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap59/JohnsonMtEphInt.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 59: Johnson's Algorithm - Multi-threaded Ephemeral Integer Weights
    3|       |//!
    4|       |//! Implements Algorithm 59.1 from the textbook with parallelism in Phase 3.
    5|       |//! All-Pairs Shortest Paths for graphs with negative weights (but no negative cycles).
    6|       |//!
    7|       |//! **Algorithmic Analysis:**
    8|       |//! - Johnson APSP: Work O(mn log n), Span O(m log n), Parallelism (n) where n = |V|, m = |E|
    9|       |//! - Phase 1 (Bellman-Ford): Work O(nm), Span O(nm) - sequential
   10|       |//! - Phase 2 (Reweighting): Work O(m), Span O(m) - sequential
   11|       |//! - Phase 3 (n Dijkstras in parallel): Work O(n * m log n) = O(mn log n), Span O(m log n)
   12|       |//! - Parallelism in Phase 3: (n) - n independent Dijkstra runs
   13|       |
   14|       |pub mod JohnsonMtEphInt {
   15|       |
   16|       |    use std::thread;
   17|       |
   18|       |    use crate::Chap05::SetStEph::SetStEph::*;
   19|       |    use crate::Chap06::LabDirGraphMtEph::LabDirGraphMtEph::LabDirGraphMtEphTrait;
   20|       |    use crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::*;
   21|       |    use crate::Chap06::WeightedDirGraphMtEphInt::WeightedDirGraphMtEphInt::*;
   22|       |    use crate::Chap06::WeightedDirGraphStEphInt::WeightedDirGraphStEphInt::*;
   23|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   24|       |    use crate::Chap56::AllPairsResultStEphInt::AllPairsResultStEphInt::AllPairsResultStEphInt;
   25|       |    use crate::Chap57::DijkstraStEphInt::DijkstraStEphInt::dijkstra;
   26|       |    use crate::Chap58::BellmanFordStEphInt::BellmanFordStEphInt::bellman_ford;
   27|       |    use crate::Types::Types::*;
   28|       |
   29|       |    pub trait JohnsonMtEphIntTrait {
   30|       |        /// Parallel Johnson's all-pairs shortest path algorithm
   31|       |        /// APAS: Work O(mn log n), Span O(m log n) where n = |V|, m = |E|
   32|       |        fn johnson_apsp(graph: &WeightedDirGraphMtEphInt<usize>) -> AllPairsResultStEphInt;
   33|       |    }
   34|       |
   35|       |    /// Algorithm 59.1: Johnson's All-Pairs Shortest Paths (Parallel)
   36|       |    ///
   37|       |    /// Solves APSP problem with negative weights using:
   38|       |    /// 1. Bellman-Ford to compute potentials (sequential)
   39|       |    /// 2. Reweight edges (sequential)
   40|       |    /// 3. Parallel Dijkstra from each vertex using ParaPair! divide-and-conquer
   41|       |    ///
   42|       |    /// **APAS Analysis:** Work O(mn log n), Span O(m log n), Parallelism (n)
   43|       |    /// **Claude Analysis:**
   44|       |    /// - Phase 1: Bellman-Ford: Work O(nm), Span O(nm) - sequential
   45|       |    /// - Phase 2: Reweighting: Work O(m), Span O(m) - sequential
   46|       |    /// - Phase 3: n Dijkstras via ParaPair! recursion:
   47|       |    ///   * Work O(n * m log n) = O(mn log n)
   48|       |    ///   * Span O(log n) recursion depth  O(m log n) per Dijkstra = O(m log n)
   49|       |    ///   * However, since all n Dijkstras can run in parallel, effective Span O(m log n)
   50|       |    ///   * Parallelism (n * m log n) / (m log n) = (n)
   51|       |    /// - Total: Work O(mn log n), Span O(m log n), Parallelism (n)
   52|       |    ///
   53|       |    /// # Arguments
   54|       |    /// * `graph` - Weighted directed graph with integer weights (can be negative, no negative cycles)
   55|       |    ///
   56|       |    /// # Returns
   57|       |    /// `AllPairsResultStEphInt` containing nn distance matrix and predecessor matrix
   58|      5|    pub fn johnson_apsp(graph: &WeightedDirGraphMtEphInt<usize>) -> AllPairsResultStEphInt {
   59|      5|        let n = graph.vertices().size();
   60|       |
   61|       |        // Phase 1: Add dummy source and run Bellman-Ford
   62|      5|        let (graph_with_dummy, dummy_idx) = add_dummy_source(graph, n);
   63|       |
   64|      5|        let bellman_ford_result = match bellman_ford(&graph_with_dummy, dummy_idx) {
   65|      5|            | Ok(res) => res,
   66|       |            | Err(_) => {
   67|       |                // Negative cycle detected - return infinity matrix
   68|      0|                return create_negative_cycle_result(n);
   69|       |            }
   70|       |        };
   71|       |
   72|       |        // Extract potentials
   73|     15|        let potentials = ArraySeqStEphS::tabulate(&|i| bellman_ford_result.get_distance(i), n);
                          ^5           ^5                                                                 ^5
   74|       |
   75|       |        // Phase 2: Reweight edges to eliminate negative weights
   76|      5|        let reweighted_graph = reweight_graph(graph, &potentials, n);
   77|       |
   78|       |        // Phase 3: Run Dijkstra from each vertex IN PARALLEL and adjust distances
   79|       |        // Unconditionally parallel using recursive divide-and-conquer with ParaPair!
   80|      5|        let (all_distances, all_predecessors) = parallel_dijkstra_all(&reweighted_graph, &potentials, 0, n, n);
   81|       |
   82|      5|        AllPairsResultStEphInt {
   83|      5|            distances: all_distances,
   84|      5|            predecessors: all_predecessors,
   85|      5|            n,
   86|      5|        }
   87|      5|    }
   88|       |
   89|       |    /// Parallel Dijkstra execution using recursive divide-and-conquer with ParaPair!
   90|       |    /// Returns sequences of distance and predecessor rows
   91|     25|    fn parallel_dijkstra_all(
   92|     25|        graph: &WeightedDirGraphStEphInt<usize>,
   93|     25|        potentials: &ArraySeqStEphS<i64>,
   94|     25|        start: usize,
   95|     25|        end: usize,
   96|     25|        n: usize,
   97|     25|    ) -> (
   98|     25|        ArraySeqStEphS<ArraySeqStEphS<i64>>,
   99|     25|        ArraySeqStEphS<ArraySeqStEphS<usize>>,
  100|     25|    ) {
  101|     25|        let range_size = end - start;
  102|       |
  103|       |        // Base case: empty range
  104|     25|        if range_size == 0 {
  105|      0|            return (ArraySeqStEphS::empty(), ArraySeqStEphS::empty());
  106|     25|        }
  107|       |
  108|       |        // Base case: single vertex
  109|     25|        if range_size == 1 {
  110|     15|            let u = start;
  111|     15|            let dijkstra_result = dijkstra(graph, u);
  112|       |
  113|       |            // Adjust distances: G(u,v) = G'(u,v) - p(u) + p(v)
  114|     15|            let p_u = *potentials.nth(u);
  115|     15|            let adjusted_row = ArraySeqStEphS::tabulate(
  116|     51|                &|v| {
  117|     51|                    let d_prime = dijkstra_result.get_distance(v);
  118|     51|                    if d_prime == i64::MAX {
  119|     16|                        i64::MAX
  120|       |                    } else {
  121|     35|                        let p_v = *potentials.nth(v);
  122|     35|                        d_prime - p_u + p_v
  123|       |                    }
  124|     51|                },
  125|     15|                n,
  126|       |            );
  127|       |
  128|     15|            let dist_seq = ArraySeqStEphS::singleton(adjusted_row);
  129|     15|            let pred_seq = ArraySeqStEphS::singleton(dijkstra_result.predecessors.clone());
  130|     15|            return (dist_seq, pred_seq);
  131|     10|        }
  132|       |
  133|       |        // Recursive case: split in half and use ParaPair! for unconditional parallelism
  134|     10|        let mid = start + range_size / 2;
  135|     10|        let graph_left = graph.clone();
  136|     10|        let graph_right = graph.clone();
  137|     10|        let potentials_left = potentials.clone();
  138|     10|        let potentials_right = potentials.clone();
  139|       |
  140|     10|        let Pair((left_dist, left_pred), (right_dist, right_pred)) = crate::ParaPair!(
  141|     10|            move || parallel_dijkstra_all(&graph_left, &potentials_left, start, mid, n),
  142|     10|            move || parallel_dijkstra_all(&graph_right, &potentials_right, mid, end, n)
  143|       |        );
  144|       |
  145|       |        // Combine results
  146|     10|        let combined_dist = ArraySeqStEphS::append(&left_dist, &right_dist);
  147|     10|        let combined_pred = ArraySeqStEphS::append(&left_pred, &right_pred);
  148|       |
  149|     10|        (combined_dist, combined_pred)
  150|     25|    }
  151|       |
  152|       |    /// Add dummy source with zero-weight edges to all vertices
  153|      5|    fn add_dummy_source(graph: &WeightedDirGraphMtEphInt<usize>, n: usize) -> (WeightedDirGraphStEphInt<usize>, usize) {
  154|       |        // Convert MtEph graph to StEph for Bellman-Ford
  155|      5|        let mut vertices = Set::empty();
  156|     15|        for i in 0..n {
                                  ^5
  157|     15|            vertices.insert(i);
  158|     15|        }
  159|       |
  160|       |        // Add dummy vertex
  161|      5|        vertices.insert(n);
  162|       |
  163|      5|        let mut edges = Set::empty();
  164|       |
  165|       |        // Copy all original edges
  166|     15|        for u in 0..n {
                                  ^5
  167|     15|            for v_w in graph.out_neighbors_weighted(&u).iter() {
  168|     15|                let (v, w) = v_w;
  169|     15|                edges.insert((u, *v, *w));
  170|     15|            }
  171|       |        }
  172|       |
  173|       |        // Add edges from dummy source to all original vertices
  174|     15|        for v in 0..n {
                                  ^5
  175|     15|            edges.insert((n, v, 0));
  176|     15|        }
  177|       |
  178|      5|        (WeightedDirGraphStEphInt::from_weighted_edges(vertices, edges), n)
  179|      5|    }
  180|       |
  181|       |    /// Reweight edges: w'(u,v) = w(u,v) + p(u) - p(v)
  182|      5|    fn reweight_graph(
  183|      5|        graph: &WeightedDirGraphMtEphInt<usize>,
  184|      5|        potentials: &ArraySeqStEphS<i64>,
  185|      5|        n: usize,
  186|      5|    ) -> WeightedDirGraphStEphInt<usize> {
  187|      5|        let mut vertices = Set::empty();
  188|     15|        for i in 0..n {
                                  ^5
  189|     15|            vertices.insert(i);
  190|     15|        }
  191|       |
  192|      5|        let mut reweighted_edges = Set::empty();
  193|     15|        for u in 0..n {
                                  ^5
  194|     15|            let p_u = *potentials.nth(u);
  195|     15|            for v_w in graph.out_neighbors_weighted(&u).iter() {
  196|     15|                let (v, w) = v_w;
  197|     15|                let p_v = *potentials.nth(*v);
  198|     15|                let w_prime = (*w as i64) + p_u - p_v;
  199|     15|                reweighted_edges.insert((u, *v, w_prime as i32));
  200|     15|            }
  201|       |        }
  202|       |
  203|      5|        WeightedDirGraphStEphInt::from_weighted_edges(vertices, reweighted_edges)
  204|      5|    }
  205|       |
  206|       |    /// Create result for negative cycle case
  207|      0|    fn create_negative_cycle_result(n: usize) -> AllPairsResultStEphInt {
  208|      0|        let distances = ArraySeqStEphS::tabulate(&|_| ArraySeqStEphS::tabulate(&|_| i64::MAX, n), n);
  209|      0|        let predecessors = ArraySeqStEphS::tabulate(&|_| ArraySeqStEphS::tabulate(&|_| 0, n), n);
  210|      0|        AllPairsResultStEphInt {
  211|      0|            distances,
  212|      0|            predecessors,
  213|      0|            n,
  214|      0|        }
  215|      0|    }
  216|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap59/JohnsonStEphFloat.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 59: Johnson's Algorithm - Single-threaded Ephemeral Float Weights
    3|       |//!
    4|       |//! Implements Algorithm 59.1 from the textbook.
    5|       |//! All-Pairs Shortest Paths for graphs with negative weights (but no negative cycles).
    6|       |//!
    7|       |//! **Algorithmic Analysis:**
    8|       |//! - Johnson APSP: Work O(mn log n), Span O(mn log n) where n = |V|, m = |E|
    9|       |//! - Phase 1 (Bellman-Ford): Work O(nm), Span O(nm)
   10|       |//! - Phase 2 (Reweighting): Work O(m), Span O(m)
   11|       |//! - Phase 3 (n Dijkstras): Work O(n * m log n) = O(mn log n), Span O(mn log n) sequential
   12|       |
   13|       |pub mod JohnsonStEphFloat {
   14|       |
   15|       |    use crate::Chap05::SetStEph::SetStEph::*;
   16|       |    use crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::*;
   17|       |    use crate::Chap06::WeightedDirGraphStEphFloat::WeightedDirGraphStEphFloat::*;
   18|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   19|       |    use crate::Chap56::AllPairsResultStEphFloat::AllPairsResultStEphFloat::AllPairsResultStEphFloat;
   20|       |    use crate::Chap57::DijkstraStEphFloat::DijkstraStEphFloat::dijkstra;
   21|       |    use crate::Chap58::BellmanFordStEphFloat::BellmanFordStEphFloat::bellman_ford;
   22|       |    use crate::Types::Types::*;
   23|       |    use ordered_float::OrderedFloat;
   24|       |
   25|       |    pub trait JohnsonStEphFloatTrait {
   26|       |        /// Johnson's all-pairs shortest path algorithm
   27|       |        /// APAS: Work O(mn log n), Span O(mn log n) where n = |V|, m = |E|
   28|       |        fn johnson_apsp(graph: &WeightedDirGraphStEphFloat<usize>) -> AllPairsResultStEphFloat;
   29|       |    }
   30|       |
   31|       |    /// Algorithm 59.1: Johnson's All-Pairs Shortest Paths (Float version)
   32|       |    ///
   33|       |    /// Solves APSP problem with negative float weights allowed using:
   34|       |    /// 1. Bellman-Ford to compute potentials and eliminate negative weights
   35|       |    /// 2. Dijkstra from each vertex on reweighted graph
   36|       |    ///
   37|       |    /// **APAS Analysis:** Work O(mn log n), Span O(m log n)
   38|       |    /// **Claude Analysis:**
   39|       |    /// - Phase 1: Bellman-Ford on G' (n+1 vertices, m+n edges): Work O((n+1)(m+n)) = O(nm), Span O(nm)
   40|       |    /// - Phase 2: Reweight m edges: Work O(m), Span O(m)
   41|       |    /// - Phase 3: n sequential Dijkstra runs: Work O(n * m log n) = O(mn log n), Span O(mn log n)
   42|       |    /// - Total: Work O(mn log n), Span O(mn log n)
   43|       |    ///
   44|       |    /// # Arguments
   45|       |    /// * `graph` - Weighted directed graph with float weights (can be negative, no negative cycles)
   46|       |    ///
   47|       |    /// # Returns
   48|       |    /// `AllPairsResultStEphFloat` containing nn distance matrix and predecessor matrix
   49|      5|    pub fn johnson_apsp(graph: &WeightedDirGraphStEphFloat<usize>) -> AllPairsResultStEphFloat {
   50|      5|        let n = graph.vertices().size();
   51|      5|        let (graph_with_dummy, dummy_idx) = add_dummy_source(graph, n);
   52|       |
   53|      5|        let bellman_ford_result = match bellman_ford(&graph_with_dummy, dummy_idx) {
   54|      5|            | Ok(result) => result,
   55|      0|            | Err(_) => return create_negative_cycle_result(n),
   56|       |        };
   57|       |
   58|     15|        let potentials = ArraySeqStEphS::tabulate(&|i| bellman_ford_result.get_distance(i), n);
                          ^5           ^5                                                                 ^5
   59|      5|        let reweighted_graph = reweight_graph(graph, &potentials, n);
   60|       |
   61|      5|        let mut all_distances = ArraySeqStEphS::empty();
   62|      5|        let mut all_predecessors = ArraySeqStEphS::empty();
   63|       |
   64|     15|        for u in 0..n {
                                  ^5
   65|     15|            let dijkstra_result = dijkstra(&reweighted_graph, u);
   66|     15|            let p_u = *potentials.nth(u);
   67|       |
   68|     15|            let adjusted_row = ArraySeqStEphS::tabulate(
   69|     51|                &|v| {
   70|     51|                    let d_prime = dijkstra_result.get_distance(v);
   71|     51|                    if d_prime.0.is_infinite() {
   72|     22|                        OrderedFloat(f64::INFINITY)
   73|       |                    } else {
   74|     29|                        let p_v = *potentials.nth(v);
   75|     29|                        OrderedFloat(d_prime.0 - p_u.0 + p_v.0)
   76|       |                    }
   77|     51|                },
   78|     15|                n,
   79|       |            );
   80|       |
   81|     15|            all_distances = ArraySeqStEphS::append(&all_distances, &ArraySeqStEphS::singleton(adjusted_row));
   82|     15|            all_predecessors = ArraySeqStEphS::append(
   83|     15|                &all_predecessors,
   84|     15|                &ArraySeqStEphS::singleton(dijkstra_result.predecessors.clone()),
   85|       |            );
   86|       |        }
   87|       |
   88|      5|        AllPairsResultStEphFloat {
   89|      5|            distances: all_distances,
   90|      5|            predecessors: all_predecessors,
   91|      5|            n,
   92|      5|        }
   93|      5|    }
   94|       |
   95|      5|    fn add_dummy_source(
   96|      5|        graph: &WeightedDirGraphStEphFloat<usize>,
   97|      5|        n: usize,
   98|      5|    ) -> (WeightedDirGraphStEphFloat<usize>, usize) {
   99|      5|        let dummy_idx = n;
  100|      5|        let mut vertices = Set::empty();
  101|     20|        for i in 0..=n {
                                   ^5
  102|     20|            vertices.insert(i);
  103|     20|        }
  104|      5|        let mut edges = Set::empty();
  105|     13|        for LabEdge(from, to, weight) in graph.labeled_arcs().iter() {
                                                       ^5                   ^5
  106|     13|            edges.insert((*from, *to, *weight));
  107|     13|        }
  108|     15|        for i in 0..n {
                                  ^5
  109|     15|            edges.insert((dummy_idx, i, OrderedFloat(0.0)));
  110|     15|        }
  111|      5|        (
  112|      5|            WeightedDirGraphStEphFloat::from_weighted_edges(vertices, edges),
  113|      5|            dummy_idx,
  114|      5|        )
  115|      5|    }
  116|       |
  117|      5|    fn reweight_graph(
  118|      5|        graph: &WeightedDirGraphStEphFloat<usize>,
  119|      5|        potentials: &ArraySeqStEphS<OrderedF64>,
  120|      5|        n: usize,
  121|      5|    ) -> WeightedDirGraphStEphFloat<usize> {
  122|      5|        let mut vertices = Set::empty();
  123|     15|        for i in 0..n {
                                  ^5
  124|     15|            vertices.insert(i);
  125|     15|        }
  126|      5|        let mut edges = Set::empty();
  127|     13|        for LabEdge(from, to, weight) in graph.labeled_arcs().iter() {
                                                       ^5                   ^5
  128|     13|            let p_from = *potentials.nth(*from);
  129|     13|            let p_to = *potentials.nth(*to);
  130|     13|            let new_weight = OrderedFloat(weight.0 + p_from.0 - p_to.0);
  131|     13|            edges.insert((*from, *to, new_weight));
  132|     13|        }
  133|      5|        WeightedDirGraphStEphFloat::from_weighted_edges(vertices, edges)
  134|      5|    }
  135|       |
  136|      0|    fn create_negative_cycle_result(n: usize) -> AllPairsResultStEphFloat {
  137|      0|        let distances = ArraySeqStEphS::tabulate(&|_| ArraySeqStEphS::tabulate(&|_| OrderedFloat(f64::INFINITY), n), n);
  138|      0|        let predecessors = ArraySeqStEphS::tabulate(&|_| ArraySeqStEphS::tabulate(&|_| 0, n), n);
  139|      0|        AllPairsResultStEphFloat {
  140|      0|            distances,
  141|      0|            predecessors,
  142|      0|            n,
  143|      0|        }
  144|      0|    }
  145|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap59/JohnsonStEphInt.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 59: Johnson's Algorithm - Single-threaded Ephemeral Integer Weights
    3|       |//!
    4|       |//! Implements Algorithm 59.1 from the textbook.
    5|       |//! All-Pairs Shortest Paths for graphs with negative weights (but no negative cycles).
    6|       |//!
    7|       |//! **Algorithmic Analysis:**
    8|       |//! - Johnson APSP: Work O(mn log n), Span O(mn log n) where n = |V|, m = |E|
    9|       |//! - Phase 1 (Bellman-Ford): Work O(nm), Span O(nm)
   10|       |//! - Phase 2 (Reweighting): Work O(m), Span O(m)
   11|       |//! - Phase 3 (n Dijkstras): Work O(n * m log n) = O(mn log n), Span O(mn log n) sequential
   12|       |
   13|       |pub mod JohnsonStEphInt {
   14|       |
   15|       |    use crate::Chap05::SetStEph::SetStEph::*;
   16|       |    use crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::*;
   17|       |    use crate::Chap06::WeightedDirGraphStEphInt::WeightedDirGraphStEphInt::*;
   18|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   19|       |    use crate::Chap56::AllPairsResultStEphInt::AllPairsResultStEphInt::AllPairsResultStEphInt;
   20|       |    use crate::Chap57::DijkstraStEphInt::DijkstraStEphInt::dijkstra;
   21|       |    use crate::Chap58::BellmanFordStEphInt::BellmanFordStEphInt::bellman_ford;
   22|       |    use crate::Types::Types::*;
   23|       |
   24|       |    pub trait JohnsonStEphIntTrait {
   25|       |        /// Johnson's all-pairs shortest path algorithm
   26|       |        /// APAS: Work O(mn log n), Span O(mn log n) where n = |V|, m = |E|
   27|       |        fn johnson_apsp(graph: &WeightedDirGraphStEphInt<usize>) -> AllPairsResultStEphInt;
   28|       |    }
   29|       |
   30|       |    /// Algorithm 59.1: Johnson's All-Pairs Shortest Paths
   31|       |    ///
   32|       |    /// Solves APSP problem with negative weights allowed using:
   33|       |    /// 1. Bellman-Ford to compute potentials and eliminate negative weights
   34|       |    /// 2. Dijkstra from each vertex on reweighted graph
   35|       |    ///
   36|       |    /// **APAS Analysis:** Work O(mn log n), Span O(m log n)
   37|       |    /// **Claude Analysis:**
   38|       |    /// - Phase 1: Bellman-Ford on G' (n+1 vertices, m+n edges): Work O((n+1)(m+n)) = O(nm), Span O(nm)
   39|       |    /// - Phase 2: Reweight m edges: Work O(m), Span O(m)
   40|       |    /// - Phase 3: n sequential Dijkstra runs: Work O(n * m log n) = O(mn log n), Span O(mn log n)
   41|       |    /// - Total: Work O(mn log n), Span O(mn log n)
   42|       |    ///
   43|       |    /// # Arguments
   44|       |    /// * `graph` - Weighted directed graph with integer weights (can be negative, no negative cycles)
   45|       |    ///
   46|       |    /// # Returns
   47|       |    /// `AllPairsResultStEphInt` containing nn distance matrix and predecessor matrix
   48|      5|    pub fn johnson_apsp(graph: &WeightedDirGraphStEphInt<usize>) -> AllPairsResultStEphInt {
   49|      5|        let n = graph.vertices().size();
   50|       |
   51|       |        // Phase 1: Add dummy source and run Bellman-Ford
   52|      5|        let (graph_with_dummy, dummy_idx) = add_dummy_source(graph, n);
   53|       |
   54|      5|        let bellman_ford_result = match bellman_ford(&graph_with_dummy, dummy_idx) {
   55|      5|            | Ok(result) => result,
   56|       |            | Err(_) => {
   57|       |                // Negative cycle detected - return infinity matrix
   58|      0|                return create_negative_cycle_result(n);
   59|       |            }
   60|       |        };
   61|       |
   62|       |        // Extract potentials
   63|     15|        let potentials = ArraySeqStEphS::tabulate(&|i| bellman_ford_result.get_distance(i), n);
                          ^5           ^5                                                                 ^5
   64|       |
   65|       |        // Phase 2: Reweight edges
   66|      5|        let reweighted_graph = reweight_graph(graph, &potentials, n);
   67|       |
   68|       |        // Phase 3: Run Dijkstra from each vertex and adjust distances
   69|      5|        let mut all_distances = ArraySeqStEphS::empty();
   70|      5|        let mut all_predecessors = ArraySeqStEphS::empty();
   71|       |
   72|     15|        for u in 0..n {
                                  ^5
   73|     15|            let dijkstra_result = dijkstra(&reweighted_graph, u);
   74|       |
   75|       |            // Adjust distances: G(u,v) = G'(u,v) - p(u) + p(v)
   76|     15|            let p_u = *potentials.nth(u);
   77|     15|            let adjusted_row = ArraySeqStEphS::tabulate(
   78|     51|                &|v| {
   79|     51|                    let d_prime = dijkstra_result.get_distance(v);
   80|     51|                    if d_prime == i64::MAX {
   81|     16|                        i64::MAX
   82|       |                    } else {
   83|     35|                        let p_v = *potentials.nth(v);
   84|     35|                        d_prime - p_u + p_v
   85|       |                    }
   86|     51|                },
   87|     15|                n,
   88|       |            );
   89|       |
   90|     15|            let singleton_dist = ArraySeqStEphS::singleton(adjusted_row);
   91|     15|            let singleton_pred = ArraySeqStEphS::singleton(dijkstra_result.predecessors.clone());
   92|       |
   93|     15|            all_distances = ArraySeqStEphS::append(&all_distances, &singleton_dist);
   94|     15|            all_predecessors = ArraySeqStEphS::append(&all_predecessors, &singleton_pred);
   95|       |        }
   96|       |
   97|      5|        AllPairsResultStEphInt {
   98|      5|            distances: all_distances,
   99|      5|            predecessors: all_predecessors,
  100|      5|            n,
  101|      5|        }
  102|      5|    }
  103|       |
  104|       |    /// Add dummy source with zero-weight edges to all vertices
  105|      5|    fn add_dummy_source(graph: &WeightedDirGraphStEphInt<usize>, n: usize) -> (WeightedDirGraphStEphInt<usize>, usize) {
  106|      5|        let dummy_idx = n;
  107|       |
  108|       |        // Create vertices including dummy
  109|      5|        let mut vertices = Set::empty();
  110|     20|        for i in 0..=n {
                                   ^5
  111|     20|            vertices.insert(i);
  112|     20|        }
  113|       |
  114|       |        // Copy all original edges
  115|      5|        let mut edges = Set::empty();
  116|     15|        for LabEdge(from, to, weight) in graph.labeled_arcs().iter() {
                                                       ^5                   ^5
  117|     15|            edges.insert((*from, *to, *weight));
  118|     15|        }
  119|       |
  120|       |        // Add zero-weight edges from dummy to all original vertices
  121|     15|        for i in 0..n {
                                  ^5
  122|     15|            edges.insert((dummy_idx, i, 0));
  123|     15|        }
  124|       |
  125|      5|        (
  126|      5|            WeightedDirGraphStEphInt::from_weighted_edges(vertices, edges),
  127|      5|            dummy_idx,
  128|      5|        )
  129|      5|    }
  130|       |
  131|       |    /// Reweight edges: w'(u,v) = w(u,v) + p(u) - p(v)
  132|      5|    fn reweight_graph(
  133|      5|        graph: &WeightedDirGraphStEphInt<usize>,
  134|      5|        potentials: &ArraySeqStEphS<i64>,
  135|      5|        n: usize,
  136|      5|    ) -> WeightedDirGraphStEphInt<usize> {
  137|      5|        let mut vertices = Set::empty();
  138|     15|        for i in 0..n {
                                  ^5
  139|     15|            vertices.insert(i);
  140|     15|        }
  141|       |
  142|      5|        let mut edges = Set::empty();
  143|     15|        for LabEdge(from, to, weight) in graph.labeled_arcs().iter() {
                                                       ^5                   ^5
  144|     15|            let p_from = *potentials.nth(*from);
  145|     15|            let p_to = *potentials.nth(*to);
  146|     15|            let new_weight = (*weight as i64 + p_from - p_to) as i32;
  147|     15|            edges.insert((*from, *to, new_weight));
  148|     15|        }
  149|       |
  150|      5|        WeightedDirGraphStEphInt::from_weighted_edges(vertices, edges)
  151|      5|    }
  152|       |
  153|       |    /// Create result for negative cycle case
  154|      0|    fn create_negative_cycle_result(n: usize) -> AllPairsResultStEphInt {
  155|      0|        let distances = ArraySeqStEphS::tabulate(&|_| ArraySeqStEphS::tabulate(&|_| i64::MAX, n), n);
  156|      0|        let predecessors = ArraySeqStEphS::tabulate(&|_| ArraySeqStEphS::tabulate(&|_| 0, n), n);
  157|      0|        AllPairsResultStEphInt {
  158|      0|            distances,
  159|      0|            predecessors,
  160|      0|            n,
  161|      0|        }
  162|      0|    }
  163|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap61/EdgeContractionMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 61: Edge Contraction - Multi-threaded Ephemeral Implementation
    3|       |//!
    4|       |//! Implements:
    5|       |//! - Algorithm 61.6: Parallel Edge Contraction (with fork/join parallelism)
    6|       |
    7|       |pub mod EdgeContractionMtEph {
    8|       |
    9|       |    use std::hash::Hash;
   10|       |    use std::sync::Arc;
   11|       |
   12|       |    use crate::Chap05::SetStEph::SetStEph::*;
   13|       |    use crate::Chap06::UnDirGraphMtEph::UnDirGraphMtEph::*;
   14|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   15|       |    use crate::Chap61::VertexMatchingMtEph::VertexMatchingMtEph::parallel_matching_mt;
   16|       |    use crate::ParaPair;
   17|       |    use crate::SetLit;
   18|       |    use crate::Types::Types::*;
   19|       |
   20|       |    pub trait EdgeContractionMtEphTrait {
   21|       |        /// Parallel edge contraction algorithm
   22|       |        /// APAS: Work O(|E|), Span O(lg |V|)
   23|       |        fn edge_contract_mt<V: StT + MtT + Hash + Ord + 'static>(
   24|       |            graph: &UnDirGraphMtEph<V>,
   25|       |            matching: &Set<Edge<V>>,
   26|       |        ) -> UnDirGraphMtEph<V>;
   27|       |
   28|       |        /// Single round of parallel edge contraction
   29|       |        /// APAS: Work O(|V| + |E|), Span O(lg |V|)
   30|       |        fn contract_round_mt<V: StT + MtT + Hash + Ord + 'static>(
   31|       |            graph: &UnDirGraphMtEph<V>,
   32|       |            seed: u64,
   33|       |        ) -> UnDirGraphMtEph<V>;
   34|       |    }
   35|       |
   36|       |    /// Algorithm 61.6: Parallel Edge Contraction
   37|       |    ///
   38|       |    /// Contracts edges in a matching by merging their endpoints in parallel.
   39|       |    /// Each edge in the matching forms a block of two vertices.
   40|       |    /// Unmatched vertices form singleton blocks.
   41|       |    ///
   42|       |    /// APAS: Work (|V| + |E|), Span (log |V| + log |E|)
   43|       |    /// Claude: Work (|V| + |E|), Span (log |V| + log |E|),
   44|       |    ///         Parallelism (|V| + |E|) / log(|V| + |E|)
   45|       |    ///
   46|       |    /// Phase 1: Build vertex-to-block mapping - (|V|) parallelism
   47|       |    /// Phase 2: Build new vertex set - (|V|) parallelism
   48|       |    /// Phase 3: Build new edge set - (|E|) parallelism
   49|       |    ///
   50|       |    /// Arguments:
   51|       |    /// - graph: The undirected graph
   52|       |    /// - matching: A vertex matching (set of edges where no two share an endpoint)
   53|       |    ///
   54|       |    /// Returns:
   55|       |    /// - Contracted graph where matched edges are merged into single vertices
   56|      3|    pub fn edge_contract_mt<V: StT + MtT + Hash + Ord + 'static>(
   57|      3|        graph: &UnDirGraphMtEph<V>,
   58|      3|        matching: &Set<Edge<V>>,
   59|      3|    ) -> UnDirGraphMtEph<V> {
   60|       |        use std::sync::{Arc, Mutex};
   61|       |
   62|       |        // Create a mapping from original vertices to their block representatives
   63|      3|        let vertex_to_block = Arc::new(Mutex::new(std::collections::HashMap::new()));
   64|       |
   65|       |        // Phase 1: Assign block representatives for matched edges (sequential for now)
   66|       |        {
   67|      3|            let mut map = vertex_to_block.lock().unwrap();
   68|      7|            for edge in matching.iter() {
                                      ^3       ^3
   69|      7|                let Edge(u, v) = edge;
   70|      7|                map.insert(u.clone(), u.clone());
   71|      7|                map.insert(v.clone(), u.clone());
   72|      7|            }
   73|       |
   74|       |            // For unmatched vertices, they are their own representatives
   75|     24|            for vertex in graph.vertices().iter() {
                                        ^3               ^3
   76|     24|                if !map.contains_key(vertex) {
   77|     10|                    map.insert(vertex.clone(), vertex.clone());
   78|     14|                }
   79|       |            }
   80|       |        }
   81|       |
   82|      3|        let vertex_to_block = Arc::try_unwrap(vertex_to_block).unwrap().into_inner().unwrap();
   83|       |
   84|       |        // Phase 2: Build new vertex set (representatives)
   85|      3|        let mut new_vertices: Set<V> = SetLit![];
   86|     24|        for representative in vertex_to_block.values() {
                                            ^3              ^3
   87|     24|            let _ = new_vertices.insert(representative.clone());
   88|     24|        }
   89|       |
   90|       |        // Phase 3: Build new edge set in parallel
   91|      3|        let edges_vec: std::vec::Vec<Edge<V>> = graph.edges().iter().cloned().collect();
   92|      3|        let edges_seq = ArraySeqStEphS::from_vec(edges_vec);
   93|      3|        let n_edges = edges_seq.length();
   94|      3|        let edges_arc = Arc::new(edges_seq);
   95|      3|        let vertex_map_arc = Arc::new(vertex_to_block);
   96|       |
   97|      3|        let new_edges_set = build_edges_parallel(edges_arc, vertex_map_arc, 0, n_edges);
   98|       |
   99|      3|        <UnDirGraphMtEph<V> as UnDirGraphMtEphTrait<V>>::FromSets(new_vertices, new_edges_set)
  100|      3|    }
  101|       |
  102|       |    /// Build new edge set in parallel using divide-and-conquer
  103|       |    ///
  104|       |    /// Work (|E|), Span (log |E|), Parallelism (|E| / log |E|)
  105|     43|    fn build_edges_parallel<V: StT + MtT + Hash + Ord + 'static>(
  106|     43|        edges: Arc<ArraySeqStEphS<Edge<V>>>,
  107|     43|        vertex_map: Arc<std::collections::HashMap<V, V>>,
  108|     43|        start: usize,
  109|     43|        end: usize,
  110|     43|    ) -> Set<Edge<V>> {
  111|     43|        let size = end - start;
  112|       |
  113|     43|        if size == 0 {
  114|      0|            return SetLit![];
  115|     43|        }
  116|       |
  117|     43|        if size == 1 {
  118|       |            // Base case: process single edge
  119|     23|            let edge = edges.nth(start as N);
  120|     23|            let Edge(u, v) = edge;
  121|     23|            let block_u = vertex_map.get(u).unwrap().clone();
  122|     23|            let block_v = vertex_map.get(v).unwrap().clone();
  123|       |
  124|     23|            if block_u != block_v {
  125|     16|                let new_edge = if block_u < block_v {
  126|     16|                    Edge(block_u, block_v)
  127|       |                } else {
  128|      0|                    Edge(block_v, block_u)
  129|       |                };
  130|     16|                let mut result: Set<Edge<V>> = SetLit![];
  131|     16|                let _ = result.insert(new_edge);
  132|     16|                return result;
  133|       |            } else {
  134|      7|                return SetLit![];
  135|       |            }
  136|     20|        }
  137|       |
  138|       |        // Recursive case: divide and conquer
  139|     20|        let mid = start + size / 2;
  140|       |
  141|     20|        let edges1 = edges.clone();
  142|     20|        let map1 = vertex_map.clone();
  143|     20|        let edges2 = edges;
  144|     20|        let map2 = vertex_map;
  145|       |
  146|     20|        let pair = ParaPair!(move || build_edges_parallel(edges1, map1, start, mid), move || {
  147|     20|            build_edges_parallel(edges2, map2, mid, end)
  148|     20|        });
  149|       |
  150|       |        // Combine results (union of sets)
  151|     20|        let mut result = pair.0;
  152|     30|        for edge in pair.1.iter() {
                                  ^20    ^20
  153|     30|            let _ = result.insert(edge.clone());
  154|     30|        }
  155|     20|        result
  156|     43|    }
  157|       |
  158|       |    /// One round of parallel edge contraction
  159|       |    ///
  160|       |    /// Computes a parallel matching and contracts it.
  161|       |    ///
  162|       |    /// Work (|V| + |E|  avg_degree), Span (log |V| + log |E| + avg_degree)
  163|       |    ///
  164|       |    /// Arguments:
  165|       |    /// - graph: The undirected graph
  166|       |    /// - seed: Random seed for matching
  167|       |    ///
  168|       |    /// Returns:
  169|       |    /// - Contracted graph
  170|      1|    pub fn contract_round_mt<V: StT + MtT + Hash + Ord + 'static>(
  171|      1|        graph: &UnDirGraphMtEph<V>,
  172|      1|        seed: u64,
  173|      1|    ) -> UnDirGraphMtEph<V> {
  174|      1|        let matching = parallel_matching_mt(graph, seed);
  175|      1|        edge_contract_mt(graph, &matching)
  176|      1|    }
  177|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap61/EdgeContractionStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 61: Edge Contraction - Sequential Ephemeral Implementation
    3|       |//!
    4|       |//! Implements:
    5|       |//! - Algorithm 61.6: Parallel Edge Contraction (Sequential version)
    6|       |//! - One round of contraction using greedy matching
    7|       |
    8|       |pub mod EdgeContractionStEph {
    9|       |
   10|       |    use std::hash::Hash;
   11|       |
   12|       |    use crate::Chap05::SetStEph::SetStEph::*;
   13|       |    use crate::Chap06::UnDirGraphStEph::UnDirGraphStEph::*;
   14|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   15|       |    use crate::Chap61::VertexMatchingStEph::VertexMatchingStEph::greedy_matching;
   16|       |    use crate::SetLit;
   17|       |    use crate::Types::Types::*;
   18|       |
   19|       |    pub trait EdgeContractionStEphTrait {
   20|       |        /// Sequential edge contraction algorithm
   21|       |        /// APAS: Work O(|E|), Span O(|E|)
   22|       |        fn edge_contract<V: StT + Hash + Ord>(
   23|       |            graph: &UnDirGraphStEph<V>,
   24|       |            matching: &Set<Edge<V>>,
   25|       |        ) -> UnDirGraphStEph<Set<V>>;
   26|       |
   27|       |        /// Single round of sequential edge contraction
   28|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   29|       |        fn contract_round<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> UnDirGraphStEph<V>;
   30|       |    }
   31|       |
   32|       |    /// Algorithm 61.6: Sequential Edge Contraction
   33|       |    ///
   34|       |    /// Contracts edges in a matching by merging their endpoints.
   35|       |    /// Each edge in the matching forms a block of two vertices.
   36|       |    /// Unmatched vertices form singleton blocks.
   37|       |    ///
   38|       |    /// APAS: Work (|V| + |E|), Span (|V| + |E|)
   39|       |    /// Claude: Work (|V| + |E|), Span (|V| + |E|), Parallelism (1) - sequential
   40|       |    ///
   41|       |    /// Arguments:
   42|       |    /// - graph: The undirected graph
   43|       |    /// - matching: A vertex matching (set of edges where no two share an endpoint)
   44|       |    ///
   45|       |    /// Returns:
   46|       |    /// - Contracted graph where matched edges are merged into single vertices
   47|      3|    pub fn edge_contract<V: StT + Hash + Ord>(
   48|      3|        graph: &UnDirGraphStEph<V>,
   49|      3|        matching: &Set<Edge<V>>,
   50|      3|    ) -> UnDirGraphStEph<V> {
   51|       |        // Create a mapping from original vertices to their block representatives
   52|      3|        let mut vertex_to_block: std::collections::HashMap<V, V> = std::collections::HashMap::new();
   53|       |
   54|       |        // For each edge in the matching, assign both endpoints to the same representative
   55|      7|        for edge in matching.iter() {
                                  ^3       ^3
   56|      7|            let Edge(u, v) = edge;
   57|      7|            // Use the first vertex as the representative
   58|      7|            vertex_to_block.insert(u.clone(), u.clone());
   59|      7|            vertex_to_block.insert(v.clone(), u.clone());
   60|      7|        }
   61|       |
   62|       |        // For unmatched vertices, they are their own representatives
   63|     19|        for vertex in graph.vertices().iter() {
                                    ^3               ^3
   64|     19|            if !vertex_to_block.contains_key(vertex) {
   65|      5|                vertex_to_block.insert(vertex.clone(), vertex.clone());
   66|     14|            }
   67|       |        }
   68|       |
   69|       |        // Build the new contracted graph
   70|      3|        let mut new_vertices: Set<V> = SetLit![];
   71|      3|        let mut new_edges: Set<Edge<V>> = SetLit![];
   72|       |
   73|       |        // Add all block representatives as vertices
   74|     19|        for representative in vertex_to_block.values() {
                                            ^3              ^3
   75|     19|            let _ = new_vertices.insert(representative.clone());
   76|     19|        }
   77|       |
   78|       |        // For each edge in the original graph, add a new edge between block representatives
   79|       |        // (unless both endpoints are in the same block)
   80|     18|        for edge in graph.edges().iter() {
                                  ^3            ^3
   81|     18|            let Edge(u, v) = edge;
   82|     18|            let block_u = vertex_to_block.get(u).unwrap().clone();
   83|     18|            let block_v = vertex_to_block.get(v).unwrap().clone();
   84|       |
   85|       |            // Only add edge if endpoints are in different blocks (no self-loops)
   86|     18|            if block_u != block_v {
   87|     11|                let new_edge = if block_u < block_v {
   88|     11|                    Edge(block_u, block_v)
   89|       |                } else {
   90|      0|                    Edge(block_v, block_u)
   91|       |                };
   92|     11|                let _ = new_edges.insert(new_edge);
   93|      7|            }
   94|       |        }
   95|       |
   96|      3|        <UnDirGraphStEph<V> as UnDirGraphStEphTrait<V>>::FromSets(new_vertices, new_edges)
   97|      3|    }
   98|       |
   99|       |    /// One round of sequential edge contraction
  100|       |    ///
  101|       |    /// Computes a greedy matching and contracts it.
  102|       |    ///
  103|       |    /// Work (|V| + |E|), Span (|V| + |E|), Parallelism (1)
  104|       |    ///
  105|       |    /// Arguments:
  106|       |    /// - graph: The undirected graph
  107|       |    ///
  108|       |    /// Returns:
  109|       |    /// - Contracted graph
  110|      1|    pub fn contract_round<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> UnDirGraphStEph<V> {
  111|      1|        let matching = greedy_matching(graph);
  112|      1|        edge_contract(graph, &matching)
  113|      1|    }
  114|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap61/VertexMatchingMtEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 61: Vertex Matching - Multi-threaded Ephemeral Implementation
    3|       |//!
    4|       |//! Implements:
    5|       |//! - Algorithm 61.4: Parallel Vertex Matching (randomized with fork/join)
    6|       |
    7|       |pub mod VertexMatchingMtEph {
    8|       |
    9|       |    use std::hash::Hash;
   10|       |
   11|       |    use crate::Chap05::SetStEph::SetStEph::*;
   12|       |    use crate::Chap06::UnDirGraphMtEph::UnDirGraphMtEph::*;
   13|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   14|       |    use crate::ParaPair;
   15|       |    use crate::SetLit;
   16|       |    use crate::Types::Types::*;
   17|       |
   18|       |    pub trait VertexMatchingMtEphTrait {
   19|       |        /// Parallel vertex matching using randomized symmetry breaking
   20|       |        /// APAS: Work O(|E|), Span O(lg |V|)
   21|       |        fn parallel_matching_mt<V: StT + MtT + Hash + 'static>(graph: &UnDirGraphMtEph<V>) -> Set<Edge<V>>;
   22|       |    }
   23|       |
   24|       |    /// Algorithm 61.4: Parallel Vertex Matching
   25|       |    ///
   26|       |    /// Computes a vertex matching using randomized symmetry breaking.
   27|       |    /// For each edge, flips a coin in parallel. Selects an edge if:
   28|       |    /// - Its coin is heads (true)
   29|       |    /// - All edges incident on its endpoints flipped tails (false)
   30|       |    ///
   31|       |    /// APAS: Work (|E|  avg_degree), Span (log |E| + avg_degree)
   32|       |    /// Claude: Work (|E|  avg_degree), Span (log |E| + avg_degree),
   33|       |    ///         Parallelism (|E|) in coin flipping phase
   34|       |    ///
   35|       |    /// Phase 1: Flip coins for all edges in parallel - (|E|) parallelism
   36|       |    /// Phase 2: Select edges based on local maxima - (|E|) parallelism with degree-dependent checks
   37|       |    ///
   38|       |    /// Arguments:
   39|       |    /// - graph: The undirected graph
   40|       |    /// - seed: Random seed for reproducibility
   41|       |    ///
   42|       |    /// Returns:
   43|       |    /// - A set of edges forming a vertex matching
   44|      4|    pub fn parallel_matching_mt<V: StT + MtT + Hash + 'static>(graph: &UnDirGraphMtEph<V>, seed: u64) -> Set<Edge<V>> {
   45|       |        use rand::rngs::StdRng;
   46|       |        use rand::{Rng, SeedableRng};
   47|       |        use std::sync::{Arc, Mutex};
   48|       |
   49|      4|        let mut rng = StdRng::seed_from_u64(seed);
   50|       |
   51|       |        // Convert edges to a sequence for parallel processing
   52|      4|        let edges_vec: std::vec::Vec<Edge<V>> = graph.edges().iter().cloned().collect();
   53|      4|        let edges_seq: ArraySeqStEphS<Edge<V>> = ArraySeqStEphS::from_vec(edges_vec);
   54|      4|        let n_edges = edges_seq.length();
   55|       |
   56|      4|        if n_edges == 0 {
   57|      0|            return SetLit![];
   58|      4|        }
   59|       |
   60|       |        // Phase 1: Flip coins for all edges in parallel
   61|      4|        let coins = flip_coins_parallel(&edges_seq, &mut rng);
   62|       |
   63|       |        // Phase 2: Select edges where coin is heads and all adjacent edges are tails
   64|      4|        let matching = select_edges_parallel(graph, &edges_seq, &coins);
   65|       |
   66|      4|        matching
   67|      4|    }
   68|       |
   69|       |    /// Phase 1: Flip coins for all edges in parallel
   70|       |    ///
   71|       |    /// Work (|E|), Span (log |E|), Parallelism (|E|/log |E|)
   72|      4|    fn flip_coins_parallel<V: StT + MtT + 'static>(
   73|      4|        edges: &ArraySeqStEphS<Edge<V>>,
   74|      4|        rng: &mut rand::rngs::StdRng,
   75|      4|    ) -> ArraySeqStEphS<B> {
   76|       |        use rand::Rng;
   77|       |
   78|      4|        let n = edges.length();
   79|      4|        if n == 0 {
   80|      0|            return ArraySeqStEphS::empty();
   81|      4|        }
   82|       |
   83|       |        // Generate all random values sequentially (RNG must be sequential)
   84|      4|        let mut coins_vec = std::vec::Vec::with_capacity(n);
   85|     38|        for _ in 0..n {
                                  ^4
   86|     38|            coins_vec.push(rng.random::<bool>());
   87|     38|        }
   88|       |
   89|       |        // Convert to sequence
   90|      4|        ArraySeqStEphS::from_vec(coins_vec)
   91|      4|    }
   92|       |
   93|       |    /// Phase 2: Select edges in parallel where coin is heads and adjacent edges are tails
   94|       |    ///
   95|       |    /// Work (|E|  avg_degree), Span (log |E| + avg_degree), Parallelism (|E|/log |E|)
   96|      4|    fn select_edges_parallel<V: StT + MtT + Hash + 'static>(
   97|      4|        graph: &UnDirGraphMtEph<V>,
   98|      4|        edges: &ArraySeqStEphS<Edge<V>>,
   99|      4|        coins: &ArraySeqStEphS<B>,
  100|      4|    ) -> Set<Edge<V>> {
  101|       |        use std::sync::Arc;
  102|       |
  103|      4|        let n = edges.length();
  104|      4|        if n == 0 {
  105|      0|            return SetLit![];
  106|      4|        }
  107|       |
  108|       |        // Build edge index for O(1) coin lookups
  109|      4|        let edge_coin_map: std::collections::HashMap<Edge<V>, bool> =
  110|     38|            edges.iter().zip(coins.iter()).map(|(e, c)| (e.clone(), *c)).collect();
                          ^4    ^4     ^4  ^4    ^4      ^4                            ^4
  111|       |
  112|       |        // Wrap in Arc for thread-safe sharing
  113|      4|        let graph_arc = Arc::new(graph.clone());
  114|      4|        let edges_arc = Arc::new(edges.clone());
  115|      4|        let map_arc = Arc::new(edge_coin_map);
  116|       |
  117|       |        // Parallel edge selection using divide-and-conquer
  118|      4|        let selected = select_edges_recursive(graph_arc, edges_arc, map_arc, 0, n);
  119|       |
  120|       |        // Convert sequence to set
  121|      4|        let mut result: Set<Edge<V>> = SetLit![];
  122|      9|        for edge in selected.iter() {
                                  ^4       ^4
  123|      9|            let _ = result.insert(edge.clone());
  124|      9|        }
  125|      4|        result
  126|      4|    }
  127|       |
  128|       |    /// Recursive helper for parallel edge selection
  129|       |    ///
  130|       |    /// Work (k  avg_degree) where k = end - start
  131|       |    /// Span (log k + avg_degree), Parallelism (k/log k)
  132|     72|    fn select_edges_recursive<V: StT + MtT + Hash + 'static>(
  133|     72|        graph: std::sync::Arc<UnDirGraphMtEph<V>>,
  134|     72|        edges: std::sync::Arc<ArraySeqStEphS<Edge<V>>>,
  135|     72|        edge_coins: std::sync::Arc<std::collections::HashMap<Edge<V>, bool>>,
  136|     72|        start: usize,
  137|     72|        end: usize,
  138|     72|    ) -> ArraySeqStEphS<Edge<V>> {
  139|     72|        let size = end - start;
  140|       |
  141|     72|        if size == 0 {
  142|      0|            return ArraySeqStEphS::empty();
  143|     72|        }
  144|       |
  145|     72|        if size == 1 {
  146|       |            // Base case: check single edge
  147|     38|            let edge = edges.nth(start as N);
  148|     38|            if should_select_edge(&graph, edge, &edge_coins) {
  149|      9|                return ArraySeqStEphS::from_vec(std::vec![edge.clone()]);
  150|       |            } else {
  151|     29|                return ArraySeqStEphS::empty();
  152|       |            }
  153|     34|        }
  154|       |
  155|       |        // Recursive case: divide and conquer
  156|     34|        let mid = start + size / 2;
  157|       |
  158|     34|        let graph1 = graph.clone();
  159|     34|        let edges1 = edges.clone();
  160|     34|        let coins1 = edge_coins.clone();
  161|     34|        let graph2 = graph;
  162|     34|        let edges2 = edges;
  163|     34|        let coins2 = edge_coins;
  164|       |
  165|     34|        let pair = ParaPair!(
  166|     34|            move || select_edges_recursive(graph1, edges1, coins1, start, mid),
  167|     34|            move || select_edges_recursive(graph2, edges2, coins2, mid, end)
  168|       |        );
  169|       |
  170|       |        // Combine results
  171|     34|        let mut left_vec: std::vec::Vec<Edge<V>> = pair.0.iter().cloned().collect();
  172|     34|        let right_vec: std::vec::Vec<Edge<V>> = pair.1.iter().cloned().collect();
  173|     34|        left_vec.extend(right_vec);
  174|     34|        ArraySeqStEphS::from_vec(left_vec)
  175|     72|    }
  176|       |
  177|       |    /// Check if an edge should be selected
  178|       |    ///
  179|       |    /// Edge is selected if its coin is heads and all adjacent edges have tails
  180|     38|    fn should_select_edge<V: StT + MtT + Hash + 'static>(
  181|     38|        graph: &UnDirGraphMtEph<V>,
  182|     38|        edge: &Edge<V>,
  183|     38|        edge_coins: &std::collections::HashMap<Edge<V>, bool>,
  184|     38|    ) -> bool {
  185|     38|        let Edge(u, v) = edge;
  186|       |
  187|       |        // Check if this edge flipped heads
  188|     38|        if !edge_coins.get(edge).copied().unwrap_or(false) {
  189|     21|            return false;
  190|     17|        }
  191|       |
  192|       |        // Check if all edges incident on u and v flipped tails (except this one)
  193|    144|        for adj_edge in graph.edges().iter() {
                                      ^17           ^17
  194|    144|            if adj_edge == edge {
  195|     12|                continue; // Skip the current edge
  196|    132|            }
  197|       |
  198|       |            // Check if adjacent edge is incident on u or v
  199|    132|            if graph.Incident(adj_edge, u) || graph.Incident(adj_edge, v) {
                                                            ^112  ^112     ^112      ^112
  200|     33|                if edge_coins.get(adj_edge).copied().unwrap_or(false) {
  201|      8|                    return false; // Adjacent edge flipped heads
  202|     25|                }
  203|     99|            }
  204|       |        }
  205|       |
  206|      9|        true
  207|     38|    }
  208|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap61/VertexMatchingStEph.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 61: Vertex Matching - Sequential Ephemeral Implementation
    3|       |//!
    4|       |//! Implements:
    5|       |//! - Algorithm 61.3: Greedy Vertex Matching (sequential)
    6|       |//! - Baseline sequential version of parallel matching algorithm
    7|       |
    8|       |pub mod VertexMatchingStEph {
    9|       |
   10|       |    use std::hash::Hash;
   11|       |
   12|       |    use crate::Chap05::SetStEph::SetStEph::*;
   13|       |    use crate::Chap06::UnDirGraphStEph::UnDirGraphStEph::*;
   14|       |    use crate::SetLit;
   15|       |    use crate::Types::Types::*;
   16|       |
   17|       |    pub trait VertexMatchingStEphTrait {
   18|       |        /// Greedy vertex matching algorithm
   19|       |        /// APAS: Work (|E|), Span (|E|)
   20|       |        fn greedy_matching<V: StT + Hash>(graph: &UnDirGraphStEph<V>) -> Set<Edge<V>>;
   21|       |
   22|       |        /// Sequential version of parallel matching
   23|       |        /// APAS: Work (|E|), Span (|E|)
   24|       |        fn parallel_matching_st<V: StT + Hash>(graph: &UnDirGraphStEph<V>) -> Set<Edge<V>>;
   25|       |    }
   26|       |
   27|       |    /// Algorithm 61.3: Greedy Vertex Matching
   28|       |    ///
   29|       |    /// Iterates over edges sequentially, adding each edge to the matching
   30|       |    /// if neither endpoint is already matched.
   31|       |    ///
   32|       |    /// APAS: Work (|E|), Span (|E|)
   33|       |    /// Claude: Work (|E|), Span (|E|), Parallelism (1) - inherently sequential
   34|       |    ///
   35|       |    /// Arguments:
   36|       |    /// - graph: The undirected graph
   37|       |    ///
   38|       |    /// Returns:
   39|       |    /// - A set of edges forming a vertex matching (no two edges share an endpoint)
   40|      4|    pub fn greedy_matching<V: StT + Hash>(graph: &UnDirGraphStEph<V>) -> Set<Edge<V>> {
   41|      4|        let mut matching: Set<Edge<V>> = SetLit![];
   42|      4|        let mut matched_vertices: Set<V> = SetLit![];
   43|       |
   44|       |        // Iterate over all edges
   45|     29|        for edge in graph.edges().iter() {
                                  ^4            ^4
   46|     29|            let Edge(u, v) = edge;
   47|       |
   48|       |            // Add edge if neither endpoint is already matched
   49|     29|            if !matched_vertices.mem(u) && !matched_vertices.mem(v) {
                                                         ^16^16
   50|     13|                let _ = matching.insert(edge.clone());
   51|     13|                let _ = matched_vertices.insert(u.clone());
   52|     13|                let _ = matched_vertices.insert(v.clone());
   53|     16|            }
   54|       |        }
   55|       |
   56|      4|        matching
   57|      4|    }
   58|       |
   59|       |    /// Baseline Sequential Version of Parallel Matching
   60|       |    ///
   61|       |    /// Simulates the parallel matching algorithm (Algorithm 61.4) sequentially
   62|       |    /// by flipping a coin for each edge and selecting edges where:
   63|       |    /// - The coin is heads (probability 1/2)
   64|       |    /// - All adjacent edges are tails
   65|       |    ///
   66|       |    /// APAS: Work (|E|  avg_degree), Span (|E|  avg_degree)
   67|       |    /// Claude: Work (|E|  avg_degree), Span (|E|  avg_degree), Parallelism (1) - sequential baseline
   68|       |    ///
   69|       |    /// Arguments:
   70|       |    /// - graph: The undirected graph
   71|       |    /// - seed: Random seed for reproducibility
   72|       |    ///
   73|       |    /// Returns:
   74|       |    /// - A set of edges forming a vertex matching
   75|      2|    pub fn parallel_matching_st<V: StT + Hash>(graph: &UnDirGraphStEph<V>, seed: u64) -> Set<Edge<V>> {
   76|       |        use rand::rngs::StdRng;
   77|       |        use rand::{Rng, SeedableRng};
   78|       |
   79|      2|        let mut rng = StdRng::seed_from_u64(seed);
   80|      2|        let mut matching: Set<Edge<V>> = SetLit![];
   81|       |
   82|       |        // Create a map from edges to their coin flips (heads = true, tails = false)
   83|      2|        let mut edge_coins: std::collections::HashMap<Edge<V>, bool> = std::collections::HashMap::new();
   84|       |
   85|     12|        for edge in graph.edges().iter() {
                                  ^2            ^2
   86|     12|            edge_coins.insert(edge.clone(), rng.random::<bool>());
   87|     12|        }
   88|       |
   89|       |        // Select edges where coin is heads and all adjacent edges are tails
   90|     12|        for edge in graph.edges().iter() {
                                  ^2            ^2
   91|     12|            let Edge(u, v) = edge;
   92|       |
   93|       |            // Check if this edge flipped heads
   94|     12|            if !edge_coins.get(edge).copied().unwrap_or(false) {
   95|      5|                continue;
   96|      7|            }
   97|       |
   98|       |            // Check if all edges incident on u and v flipped tails (except this one)
   99|      7|            let mut all_adjacent_tails = true;
  100|       |
  101|     27|            for adj_edge in graph.edges().iter() {
                                          ^7            ^7
  102|     27|                if adj_edge == edge {
  103|      4|                    continue; // Skip the current edge
  104|     23|                }
  105|       |
  106|       |                // Check if adjacent edge is incident on u or v
  107|     23|                if graph.Incident(adj_edge, u) || graph.Incident(adj_edge, v) {
                                                                ^15   ^15      ^15       ^15
  108|     10|                    if edge_coins.get(adj_edge).copied().unwrap_or(false) {
  109|      6|                        all_adjacent_tails = false;
  110|      6|                        break;
  111|      4|                    }
  112|     13|                }
  113|       |            }
  114|       |
  115|      7|            if all_adjacent_tails {
  116|      1|                let _ = matching.insert(edge.clone());
  117|      6|            }
  118|       |        }
  119|       |
  120|      2|        matching
  121|      2|    }
  122|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap62/StarContractionMtEph.rs:
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 62: Star Contraction - Multi-threaded Ephemeral Implementation
    3|       |//!
    4|       |//! Implements Algorithm 62.5: Star Contraction (parallel version)
    5|       |//! Uses parallel star partition and parallel edge routing for quotient graph construction.
    6|       |
    7|       |pub mod StarContractionMtEph {
    8|       |
    9|       |    use std::collections::HashMap;
   10|       |    use std::hash::Hash;
   11|       |    use std::sync::{Arc, Mutex};
   12|       |
   13|       |    use crate::Chap05::SetStEph::SetStEph::*;
   14|       |    use crate::Chap06::UnDirGraphMtEph::UnDirGraphMtEph::*;
   15|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   16|       |    use crate::Chap62::StarPartitionMtEph::StarPartitionMtEph::parallel_star_partition;
   17|       |    use crate::ParaPair;
   18|       |    use crate::SetLit;
   19|       |    use crate::Types::Types::*;
   20|       |
   21|       |    pub trait StarContractionMtEphTrait {
   22|       |        /// Parallel star contraction higher-order function
   23|       |        /// APAS: Work O((n + m) lg n), Span O(lg n)
   24|       |        fn star_contract_mt<V, R, F, G>(graph: &UnDirGraphMtEph<V>, base: F, expand: G) -> R
   25|       |        where
   26|       |            V: StT + MtT + Hash + Ord + 'static,
   27|       |            R: StT + MtT + 'static,
   28|       |            F: Fn(&Set<V>) -> R + Send + Sync + 'static,
   29|       |            G: Fn(&Set<V>, &R) -> R + Send + Sync + 'static;
   30|       |
   31|       |        /// Contract graph to just vertices (no edges)
   32|       |        /// APAS: Work O((n + m) lg n), Span O(lg n)
   33|       |        fn contract_to_vertices_mt<V: StT + MtT + Hash + Ord + 'static>(graph: &UnDirGraphMtEph<V>) -> Set<V>;
   34|       |    }
   35|       |
   36|       |    /// Algorithm 62.5: Star Contraction (Parallel)
   37|       |    ///
   38|       |    /// Higher-order recursive star contraction with parallelism:
   39|       |    /// - Base case: No edges, call base function on vertices
   40|       |    /// - Recursive case: Parallel partition, parallel quotient construction, recur, then expand
   41|       |    ///
   42|       |    /// APAS: Work O((n + m) lg n), Span O(lg n)
   43|       |    /// claude-4-sonet: Work O((n + m) lg n), Span O(lg n), Parallelism ((n+m)/lg n)
   44|       |    ///
   45|       |    /// Arguments:
   46|       |    /// - graph: The undirected graph to contract
   47|       |    /// - seed: Random seed for partition
   48|       |    /// - base: Function to call on the base case (isolated vertices)
   49|       |    /// - expand: Function to expand result from quotient graph to original graph
   50|       |    ///
   51|       |    /// Returns:
   52|       |    /// - Result of type R as computed by base and expand functions
   53|     31|    pub fn star_contract_mt<V, R, F, G>(graph: &UnDirGraphMtEph<V>, seed: u64, base: &F, expand: &G) -> R
   54|     31|    where
   55|     31|        V: StT + MtT + Hash + Ord + 'static,
   56|     31|        F: Fn(&Set<V>) -> R,
   57|     31|        G: Fn(&Set<V>, &Set<Edge<V>>, &Set<V>, &HashMap<V, V>, R) -> R,
   58|       |    {
   59|       |        // Base case: no edges
   60|     31|        if graph.sizeE() == 0 {
   61|      7|            return base(graph.vertices());
   62|     24|        }
   63|       |
   64|       |        // Recursive case:
   65|       |        // 1. Compute parallel star partition
   66|     24|        let (centers, partition_map) = parallel_star_partition(graph, seed);
   67|       |
   68|       |        // 2. Build quotient graph in parallel
   69|     24|        let quotient_graph = build_quotient_graph_parallel(graph, &centers, &partition_map);
   70|       |
   71|       |        // 3. Recursively contract quotient graph
   72|     24|        let r = star_contract_mt(&quotient_graph, seed + 1, base, expand);
   73|       |
   74|       |        // 4. Expand result back to original graph
   75|     24|        expand(graph.vertices(), graph.edges(), &centers, &partition_map, r)
   76|     31|    }
   77|       |
   78|       |    /// Build quotient graph from partition (parallel version)
   79|       |    ///
   80|       |    /// Routes edges through partition map using divide-and-conquer parallelism.
   81|       |    ///
   82|       |    /// APAS: Work O(m), Span O(lg m)
   83|       |    /// claude-4-sonet: Work O(m), Span O(lg m), Parallelism (m/lg m)
   84|     24|    fn build_quotient_graph_parallel<V: StT + MtT + Hash + Ord + 'static>(
   85|     24|        graph: &UnDirGraphMtEph<V>,
   86|     24|        centers: &Set<V>,
   87|     24|        partition_map: &HashMap<V, V>,
   88|     24|    ) -> UnDirGraphMtEph<V> {
   89|       |        // Convert edges to sequence for parallel processing
   90|     24|        let edges_vec: std::vec::Vec<Edge<V>> = graph.edges().iter().cloned().collect();
   91|     24|        let edges_seq = ArraySeqStEphS::from_vec(edges_vec);
   92|     24|        let n_edges = edges_seq.length();
   93|       |
   94|       |        // Build partition map Arc for sharing across threads
   95|     24|        let part_map_arc = Arc::new(partition_map.clone());
   96|       |
   97|       |        // Process edges in parallel
   98|     24|        let quotient_edges = route_edges_parallel(&edges_seq, part_map_arc, 0, n_edges);
   99|       |
  100|     24|        <UnDirGraphMtEph<V> as UnDirGraphMtEphTrait<V>>::FromSets(centers.clone(), quotient_edges)
  101|     24|    }
  102|       |
  103|       |    /// Parallel edge routing using divide-and-conquer
  104|       |    ///
  105|       |    /// Work O(k), Span O(lg k), where k = end - start
  106|    118|    fn route_edges_parallel<V: StT + MtT + Hash + Ord + 'static>(
  107|    118|        edges: &ArraySeqStEphS<Edge<V>>,
  108|    118|        partition_map: Arc<HashMap<V, V>>,
  109|    118|        start: usize,
  110|    118|        end: usize,
  111|    118|    ) -> Set<Edge<V>> {
  112|    118|        let size = end - start;
  113|       |
  114|    118|        if size == 0 {
  115|      0|            return SetLit![];
  116|    118|        }
  117|       |
  118|    118|        if size == 1 {
  119|       |            // Base case: process single edge
  120|     71|            let edge = edges.nth(start as N);
  121|     71|            let Edge(u, v) = edge;
  122|     71|            let u_center = partition_map.get(u).unwrap_or(u);
  123|     71|            let v_center = partition_map.get(v).unwrap_or(v);
  124|       |
  125|       |            // Add edge if centers are different
  126|     71|            if u_center != v_center {
  127|     44|                let new_edge = if u_center < v_center {
  128|     38|                    Edge(u_center.clone(), v_center.clone())
  129|       |                } else {
  130|      6|                    Edge(v_center.clone(), u_center.clone())
  131|       |                };
  132|     44|                return SetLit![new_edge];
  133|     27|            }
  134|     27|            return SetLit![];
  135|     47|        }
  136|       |
  137|       |        // Recursive case: divide and conquer
  138|     47|        let mid = start + size / 2;
  139|       |
  140|     47|        let edges1 = edges.clone();
  141|     47|        let map1 = partition_map.clone();
  142|     47|        let edges2 = edges.clone();
  143|     47|        let map2 = partition_map;
  144|       |
  145|     47|        let pair = ParaPair!(move || route_edges_parallel(&edges1, map1, start, mid), move || {
  146|     47|            route_edges_parallel(&edges2, map2, mid, end)
  147|     47|        });
  148|       |
  149|       |        // Union the two sets
  150|     47|        let mut result = pair.0;
  151|     47|        for edge in pair.1.iter() {
                          ^37
  152|     37|            let _ = result.insert(edge.clone());
  153|     37|        }
  154|     47|        result
  155|    118|    }
  156|       |
  157|       |    /// One round of parallel star contraction
  158|       |    ///
  159|       |    /// Convenience wrapper that performs contraction with identity base/expand.
  160|       |    ///
  161|       |    /// APAS: Work O((n + m) lg n), Span O(lg n)
  162|       |    /// claude-4-sonet: Work O((n + m) lg n), Span O(lg n), Parallelism ((n+m)/lg n)
  163|      4|    pub fn contract_to_vertices_mt<V: StT + MtT + Hash + Ord + 'static>(
  164|      4|        graph: &UnDirGraphMtEph<V>,
  165|      4|        seed: u64,
  166|      4|    ) -> Set<V> {
  167|      4|        star_contract_mt(
  168|      4|            graph,
  169|      4|            seed,
  170|      4|            &|vertices| vertices.clone(),
  171|       |            &|_v, _e, _centers, _part, result| result,
  172|       |        )
  173|      4|    }
  174|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap62/StarContractionStEph.rs:
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 62: Star Contraction - Sequential Ephemeral Implementation
    3|       |//!
    4|       |//! Implements Algorithm 62.5: Star Contraction (sequential version)
    5|       |//! A higher-order function that recursively contracts a graph using star partitions.
    6|       |
    7|       |pub mod StarContractionStEph {
    8|       |
    9|       |    use std::collections::HashMap;
   10|       |    use std::hash::Hash;
   11|       |
   12|       |    use crate::Chap05::SetStEph::SetStEph::*;
   13|       |    use crate::Chap06::UnDirGraphStEph::UnDirGraphStEph::*;
   14|       |    use crate::Chap62::StarPartitionStEph::StarPartitionStEph::sequential_star_partition;
   15|       |    use crate::SetLit;
   16|       |    use crate::Types::Types::*;
   17|       |
   18|       |    pub trait StarContractionStEphTrait {
   19|       |        /// Sequential star contraction higher-order function
   20|       |        /// APAS: Work O((n + m) lg n), Span O((n + m) lg n)
   21|       |        fn star_contract<V, R, F, G>(graph: &UnDirGraphStEph<V>, base: F, expand: G) -> R
   22|       |        where
   23|       |            V: StT + Hash + Ord,
   24|       |            F: Fn(&Set<V>) -> R,
   25|       |            G: Fn(&Set<V>, &R) -> R;
   26|       |
   27|       |        /// Contract graph to just vertices (no edges)
   28|       |        /// APAS: Work O((n + m) lg n), Span O((n + m) lg n)
   29|       |        fn contract_to_vertices<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> Set<V>;
   30|       |    }
   31|       |
   32|       |    /// Algorithm 62.5: Star Contraction (Sequential)
   33|       |    ///
   34|       |    /// Higher-order recursive star contraction:
   35|       |    /// - Base case: No edges, call base function on vertices
   36|       |    /// - Recursive case: Partition graph, build quotient graph, recur, then expand
   37|       |    ///
   38|       |    /// APAS: Work O((n + m) lg n), Span O((n + m) lg n)
   39|       |    /// claude-4-sonet: Work O((n + m) lg n), Span O((n + m) lg n)
   40|       |    ///
   41|       |    /// Arguments:
   42|       |    /// - graph: The undirected graph to contract
   43|       |    /// - base: Function to call on the base case (isolated vertices)
   44|       |    /// - expand: Function to expand result from quotient graph to original graph
   45|       |    ///
   46|       |    /// Returns:
   47|       |    /// - Result of type R as computed by base and expand functions
   48|     26|    pub fn star_contract<V, R, F, G>(graph: &UnDirGraphStEph<V>, base: &F, expand: &G) -> R
   49|     26|    where
   50|     26|        V: StT + Hash + Ord,
   51|     26|        F: Fn(&Set<V>) -> R,
   52|     26|        G: Fn(&Set<V>, &Set<Edge<V>>, &Set<V>, &HashMap<V, V>, R) -> R,
   53|       |    {
   54|       |        // Base case: no edges
   55|     26|        if graph.sizeE() == 0 {
   56|     11|            return base(graph.vertices());
   57|     15|        }
   58|       |
   59|       |        // Recursive case:
   60|       |        // 1. Compute star partition
   61|     15|        let (centers, partition_map) = sequential_star_partition(graph);
   62|       |
   63|       |        // 2. Build quotient graph
   64|     15|        let quotient_graph = build_quotient_graph(graph, &centers, &partition_map);
   65|       |
   66|       |        // 3. Recursively contract quotient graph
   67|     15|        let r = star_contract(&quotient_graph, base, expand);
   68|       |
   69|       |        // 4. Expand result back to original graph
   70|     15|        expand(graph.vertices(), graph.edges(), &centers, &partition_map, r)
   71|     26|    }
   72|       |
   73|       |    /// Build quotient graph from partition
   74|       |    ///
   75|       |    /// Routes edges through partition map, removing self-loops.
   76|       |    ///
   77|       |    /// APAS: Work O(m), Span O(m)
   78|       |    /// claude-4-sonet: Work O(m), Span O(m)
   79|     15|    fn build_quotient_graph<V: StT + Hash + Ord>(
   80|     15|        graph: &UnDirGraphStEph<V>,
   81|     15|        centers: &Set<V>,
   82|     15|        partition_map: &HashMap<V, V>,
   83|     15|    ) -> UnDirGraphStEph<V> {
   84|     15|        let mut quotient_edges: Set<Edge<V>> = SetLit![];
   85|       |
   86|     51|        for edge in graph.edges().iter() {
                                  ^15           ^15
   87|     51|            let Edge(u, v) = edge;
   88|       |
   89|       |            // Map endpoints to their centers
   90|     51|            let u_center = partition_map.get(u).unwrap_or(u);
   91|     51|            let v_center = partition_map.get(v).unwrap_or(v);
   92|       |
   93|       |            // Add edge if centers are different (no self-loops)
   94|     51|            if u_center != v_center {
   95|       |                // Normalize edge order for undirected graph
   96|     16|                let new_edge = if u_center < v_center {
   97|     11|                    Edge(u_center.clone(), v_center.clone())
   98|       |                } else {
   99|      5|                    Edge(v_center.clone(), u_center.clone())
  100|       |                };
  101|     16|                let _ = quotient_edges.insert(new_edge);
  102|     35|            }
  103|       |        }
  104|       |
  105|     15|        <UnDirGraphStEph<V> as UnDirGraphStEphTrait<V>>::FromSets(centers.clone(), quotient_edges)
  106|     15|    }
  107|       |
  108|       |    /// One round of sequential star contraction
  109|       |    ///
  110|       |    /// Convenience wrapper that performs contraction with identity base/expand.
  111|       |    ///
  112|       |    /// APAS: Work O((n + m) lg n), Span O((n + m) lg n)
  113|       |    /// claude-4-sonet: Work O((n + m) lg n), Span O((n + m) lg n)
  114|      3|    pub fn contract_to_vertices<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> Set<V> {
  115|      3|        star_contract(
  116|      3|            graph,
  117|      3|            &|vertices| vertices.clone(),
  118|       |            &|_v, _e, _centers, _part, result| result,
  119|       |        )
  120|      3|    }
  121|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap62/StarPartitionMtEph.rs:
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 62: Star Partition - Multi-threaded Ephemeral Implementation
    3|       |//!
    4|       |//! Implements Algorithm 62.3: Parallel Star Partition using randomized coin flips.
    5|       |//! Uses Seq.inject for efficient parallel updates.
    6|       |
    7|       |pub mod StarPartitionMtEph {
    8|       |
    9|       |    use std::collections::HashMap;
   10|       |    use std::hash::Hash;
   11|       |
   12|       |    use crate::Chap05::SetStEph::SetStEph::*;
   13|       |    use crate::Chap06::UnDirGraphMtEph::UnDirGraphMtEph::*;
   14|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   15|       |    use crate::SetLit;
   16|       |    use crate::Types::Types::*;
   17|       |    use rand::*;
   18|       |    use rand::rngs::StdRng;
   19|       |
   20|       |    pub trait StarPartitionMtEphTrait {
   21|       |        /// Parallel star partition using randomized coin flips
   22|       |        /// APAS: Work O(|V| + |E|), Span O(lg |V|)
   23|       |        fn parallel_star_partition<V: StT + MtT + Hash + Ord + 'static>(graph: &UnDirGraphMtEph<V>) -> Set<Set<V>>;
   24|       |    }
   25|       |
   26|       |    /// Algorithm 62.3: Parallel Star Partition
   27|       |    ///
   28|       |    /// Computes a star partition using randomized coin flips:
   29|       |    /// 1. Flip a coin for each vertex
   30|       |    /// 2. Find edges from tails (non-centers) to heads (centers)
   31|       |    /// 3. Use Seq.inject to map satellites to centers
   32|       |    /// 4. Remaining vertices become singleton centers
   33|       |    ///
   34|       |    /// APAS: Work O(n + m), Span O(lg n)
   35|       |    /// claude-4-sonet: Work O(n + m), Span O(lg n), Parallelism ((n+m)/lg n)
   36|       |    ///
   37|       |    /// Arguments:
   38|       |    /// - graph: The undirected graph to partition
   39|       |    /// - seed: Random seed for coin flips
   40|       |    ///
   41|       |    /// Returns:
   42|       |    /// - (centers, partition_map): Set of center vertices and mapping from each vertex to its center
   43|     55|    pub fn parallel_star_partition<V: StT + MtT + Hash + Ord + 'static>(
   44|     55|        graph: &UnDirGraphMtEph<V>,
   45|     55|        seed: u64,
   46|     55|    ) -> (Set<V>, HashMap<V, V>) {
   47|     55|        let mut rng = StdRng::seed_from_u64(seed);
   48|       |
   49|       |        // Create vertex to index mapping for inject operation
   50|     55|        let vertices_vec: std::vec::Vec<V> = graph.vertices().iter().cloned().collect();
   51|     55|        let n = vertices_vec.len() as N;
   52|       |
   53|     55|        let mut vertex_to_index: HashMap<V, N> = HashMap::new();
   54|    240|        for (i, v) in vertices_vec.iter().enumerate() {
                                    ^55                 ^55
   55|    240|            let _ = vertex_to_index.insert(v.clone(), i as N);
   56|    240|        }
   57|       |
   58|       |        // Phase 1: Flip coins for each vertex (heads = true, tails = false)
   59|     55|        let mut coin_flips: HashMap<V, bool> = HashMap::new();
   60|    240|        for vertex in vertices_vec.iter() {
                                    ^55          ^55
   61|    240|            let _ = coin_flips.insert(vertex.clone(), rng.random::<bool>());
   62|    240|        }
   63|       |
   64|       |        // Phase 2: Find edges from tails to heads (TH)
   65|     55|        let mut th_edges: std::vec::Vec<(N, V)> = std::vec::Vec::new();
   66|    165|        for edge in graph.edges().iter() {
                                  ^55           ^55
   67|    165|            let Edge(u, v) = edge;
   68|    165|            let u_heads = coin_flips.get(u).copied().unwrap_or(false);
   69|    165|            let v_heads = coin_flips.get(v).copied().unwrap_or(false);
   70|       |
   71|       |            // Add edge if u is tails and v is heads
   72|    165|            if !u_heads && v_heads {
                                         ^92
   73|     47|                if let Some(&u_idx) = vertex_to_index.get(u) {
   74|     47|                    th_edges.push((u_idx, v.clone()));
   75|     47|                }
                              ^0
   76|    118|            }
   77|       |            // Add edge if v is tails and u is heads
   78|    165|            if !v_heads && u_heads {
                                         ^83
   79|     38|                if let Some(&v_idx) = vertex_to_index.get(v) {
   80|     38|                    th_edges.push((v_idx, u.clone()));
   81|     38|                }
                              ^0
   82|    127|            }
   83|       |        }
   84|       |
   85|       |        // Phase 3: Build base sequence V' where each index maps to itself
   86|    240|        let mut base_seq = <ArraySeqStEphS<V> as ArraySeqStEphTrait<V>>::tabulate(&|i| vertices_vec[i as usize].clone(), n);
                          ^55            ^55                                                                                           ^55
   87|       |
   88|       |        // Phase 4: Convert th_edges to ArraySeqStEphS<Pair<usize, V>>
   89|     55|        let updates_seq = ArraySeqStEphS::from_vec(
   90|     85|            th_edges.into_iter().map(|(idx, vertex)| Pair(idx, vertex)).collect()
                          ^55      ^55         ^55                                    ^55
   91|       |        );
   92|       |
   93|       |        // Phase 5: Apply inject to get partition map P
   94|     55|        let p_seq = base_seq.inject(&updates_seq);
   95|       |
   96|       |        // Phase 6: Extract centers (vertices where P[v] = v)
   97|     55|        let mut centers: Set<V> = SetLit![];
   98|     55|        let mut partition_map: HashMap<V, V> = HashMap::new();
   99|       |
  100|    240|        for (i, vertex) in vertices_vec.iter().enumerate() {
                                         ^55                 ^55
  101|    240|            let center = p_seq.nth(i as N).clone();
  102|    240|            let _ = partition_map.insert(vertex.clone(), center.clone());
  103|       |
  104|       |            // A vertex is a center if it maps to itself
  105|    240|            if *vertex == center {
  106|    172|                let _ = centers.insert(vertex.clone());
  107|    172|            }
                          ^68
  108|       |        }
  109|       |
  110|     55|        (centers, partition_map)
  111|     55|    }
  112|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap62/StarPartitionStEph.rs:
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 62: Star Partition - Sequential Ephemeral Implementation
    3|       |//!
    4|       |//! Implements sequential star partition using greedy vertex selection.
    5|       |//! A star partition divides a graph into blocks where each block is a
    6|       |//! vertex-induced subgraph with respect to a star graph.
    7|       |
    8|       |pub mod StarPartitionStEph {
    9|       |
   10|       |    use std::collections::HashMap;
   11|       |    use std::hash::Hash;
   12|       |
   13|       |    use crate::Chap05::SetStEph::SetStEph::*;
   14|       |    use crate::Chap06::UnDirGraphStEph::UnDirGraphStEph::*;
   15|       |    use crate::SetLit;
   16|       |    use crate::Types::Types::*;
   17|       |
   18|       |    pub trait StarPartitionStEphTrait {
   19|       |        /// Sequential star partition using greedy selection
   20|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   21|       |        fn sequential_star_partition<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> Set<Set<V>>;
   22|       |    }
   23|       |
   24|       |    /// Sequential Star Partition using greedy selection
   25|       |    ///
   26|       |    /// Constructs a star partition by iteratively selecting vertices:
   27|       |    /// 1. Pick an arbitrary unprocessed vertex v as a star center
   28|       |    /// 2. Add all neighbors of v as satellites
   29|       |    /// 3. Remove v and its satellites from consideration
   30|       |    /// 4. Repeat until all vertices are processed
   31|       |    ///
   32|       |    /// APAS: Work (n + m), Span (n + m)
   33|       |    /// claude-4-sonet: Work (n + m), Span (n + m)
   34|       |    ///
   35|       |    /// Arguments:
   36|       |    /// - graph: The undirected graph to partition
   37|       |    ///
   38|       |    /// Returns:
   39|       |    /// - (centers, partition_map): Set of center vertices and mapping from each vertex to its center
   40|     32|    pub fn sequential_star_partition<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> (Set<V>, HashMap<V, V>) {
   41|     32|        let mut partition_map: HashMap<V, V> = HashMap::new();
   42|     32|        let mut centers: Set<V> = SetLit![];
   43|     32|        let mut processed: Set<V> = SetLit![];
   44|       |
   45|       |        // Iterate through all vertices
   46|    152|        for vertex in graph.vertices().iter() {
                                    ^32              ^32
   47|       |            // Skip if already processed as a satellite
   48|    152|            if processed.mem(vertex) {
   49|     72|                continue;
   50|     80|            }
   51|       |
   52|       |            // Make this vertex a center
   53|     80|            let _ = centers.insert(vertex.clone());
   54|     80|            let _ = partition_map.insert(vertex.clone(), vertex.clone());
   55|     80|            let _ = processed.insert(vertex.clone());
   56|       |
   57|       |            // Add all neighbors as satellites of this center
   58|     80|            let neighbors = graph.NG(vertex);
   59|     98|            for neighbor in neighbors.iter() {
                                          ^80       ^80
   60|     98|                if !processed.mem(neighbor) {
   61|     72|                    let _ = partition_map.insert(neighbor.clone(), vertex.clone());
   62|     72|                    let _ = processed.insert(neighbor.clone());
   63|     72|                }
                              ^26
   64|       |            }
   65|       |        }
   66|       |
   67|     32|        (centers, partition_map)
   68|     32|    }
   69|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap63/ConnectivityMtEph.rs:
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 63: Graph Connectivity - Multi-threaded Ephemeral Implementation
    3|       |//!
    4|       |//! Implements parallel graph connectivity algorithms using star contraction.
    5|       |//! - Algorithm 63.2: count_components (parallel)
    6|       |//! - Algorithm 63.3: connected_components (parallel)
    7|       |//! - Exercise 63.1: count_components using star_contract
    8|       |//! - Exercise 63.2: connected_components using star_contract
    9|       |
   10|       |pub mod ConnectivityMtEph {
   11|       |
   12|       |    use std::collections::HashMap;
   13|       |    use std::hash::Hash;
   14|       |    use std::sync::Arc;
   15|       |
   16|       |    use crate::Chap05::SetStEph::SetStEph::*;
   17|       |    use crate::Chap06::UnDirGraphMtEph::UnDirGraphMtEph::*;
   18|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   19|       |    use crate::Chap62::StarContractionMtEph::StarContractionMtEph::star_contract_mt;
   20|       |    use crate::Chap62::StarPartitionMtEph::StarPartitionMtEph::parallel_star_partition;
   21|       |    use crate::ParaPair;
   22|       |    use crate::SetLit;
   23|       |    use crate::Types::Types::*;
   24|       |
   25|       |    pub trait ConnectivityMtEphTrait {
   26|       |        /// Count connected components using parallel star contraction
   27|       |        /// APAS: Work O(|V| + |E|), Span O(lg |V|)
   28|       |        fn count_components_mt<V: StT + MtT + Hash + Ord + 'static>(graph: &UnDirGraphMtEph<V>) -> N;
   29|       |
   30|       |        /// Find connected components using parallel star contraction
   31|       |        /// APAS: Work O(|V| + |E|), Span O(lg |V|)
   32|       |        fn connected_components_mt<V: StT + MtT + Hash + Ord + 'static>(graph: &UnDirGraphMtEph<V>) -> Set<Set<V>>;
   33|       |
   34|       |        /// Count components using higher-order function approach
   35|       |        /// APAS: Work O(|V| + |E|), Span O(lg |V|)
   36|       |        fn count_components_hof<V: StT + MtT + Hash + Ord + 'static>(graph: &UnDirGraphMtEph<V>) -> N;
   37|       |
   38|       |        /// Find components using higher-order function approach
   39|       |        /// APAS: Work O(|V| + |E|), Span O(lg |V|)
   40|       |        fn connected_components_hof<V: StT + MtT + Hash + Ord + 'static>(graph: &UnDirGraphMtEph<V>) -> Set<Set<V>>;
   41|       |    }
   42|       |
   43|       |    /// Algorithm 63.2: Count Connected Components (Parallel)
   44|       |    ///
   45|       |    /// Uses recursive parallel star contraction to count connected components.
   46|       |    ///
   47|       |    /// APAS: Work O((n+m) lg n), Span O(lg n)
   48|       |    /// claude-4-sonet: Work O((n+m) lg n), Span O(lg n), Parallelism ((n+m)/lg n)
   49|       |    ///
   50|       |    /// Arguments:
   51|       |    /// - graph: The undirected graph
   52|       |    /// - seed: Random seed for star partition
   53|       |    ///
   54|       |    /// Returns:
   55|       |    /// - The number of connected components
   56|     21|    pub fn count_components_mt<V: StT + MtT + Hash + Ord + 'static>(graph: &UnDirGraphMtEph<V>, seed: u64) -> N {
   57|       |        // Base case: no edges, each vertex is own component
   58|     21|        if graph.sizeE() == 0 {
   59|      3|            return graph.sizeV();
   60|     18|        }
   61|       |
   62|       |        // Partition the graph in parallel
   63|     18|        let (centers, partition_map) = parallel_star_partition(graph, seed);
   64|       |
   65|       |        // Build quotient graph in parallel
   66|     18|        let quotient_edges = build_quotient_edges_parallel(graph, &partition_map);
   67|     18|        let quotient_graph = <UnDirGraphMtEph<V> as UnDirGraphMtEphTrait<V>>::FromSets(centers, quotient_edges);
   68|       |
   69|       |        // Recursively count components in quotient graph
   70|     18|        count_components_mt(&quotient_graph, seed + 1)
   71|     21|    }
   72|       |
   73|       |    /// Algorithm 63.3: Connected Components (Parallel)
   74|       |    ///
   75|       |    /// Computes all connected components in parallel.
   76|       |    ///
   77|       |    /// APAS: Work O((n+m) lg n), Span O(lg n)
   78|       |    /// claude-4-sonet: Work O((n+m) lg n), Span O(lg n), Parallelism ((n+m)/lg n)
   79|       |    ///
   80|       |    /// Arguments:
   81|       |    /// - graph: The undirected graph
   82|       |    /// - seed: Random seed for star partition
   83|       |    ///
   84|       |    /// Returns:
   85|       |    /// - (representatives, component_map): Set of component representatives and
   86|       |    ///   mapping from each vertex to its component representative
   87|     10|    pub fn connected_components_mt<V: StT + MtT + Hash + Ord + 'static>(
   88|     10|        graph: &UnDirGraphMtEph<V>,
   89|     10|        seed: u64,
   90|     10|    ) -> (Set<V>, HashMap<V, V>) {
   91|       |        // Base case: no edges, each vertex maps to itself
   92|     10|        if graph.sizeE() == 0 {
   93|      2|            let mut component_map = HashMap::new();
   94|      4|            for vertex in graph.vertices().iter() {
                                        ^2               ^2
   95|      4|                let _ = component_map.insert(vertex.clone(), vertex.clone());
   96|      4|            }
   97|      2|            return (graph.vertices().clone(), component_map);
   98|      8|        }
   99|       |
  100|       |        // Partition the graph in parallel
  101|      8|        let (centers, partition_map) = parallel_star_partition(graph, seed);
  102|       |
  103|       |        // Build quotient graph in parallel
  104|      8|        let quotient_edges = build_quotient_edges_parallel(graph, &partition_map);
  105|      8|        let quotient_graph = <UnDirGraphMtEph<V> as UnDirGraphMtEphTrait<V>>::FromSets(centers, quotient_edges);
  106|       |
  107|       |        // Recursively compute components in quotient graph
  108|      8|        let (representatives, component_map_quotient) = connected_components_mt(&quotient_graph, seed + 1);
  109|       |
  110|       |        // Compose maps in parallel
  111|      8|        let component_map = compose_maps_parallel(&partition_map, &component_map_quotient);
  112|       |
  113|      8|        (representatives, component_map)
  114|     10|    }
  115|       |
  116|       |    /// Helper: Build quotient graph edges in parallel
  117|       |    ///
  118|       |    /// Work O(m), Span O(lg m), Parallelism (m/lg m)
  119|     26|    fn build_quotient_edges_parallel<V: StT + MtT + Hash + Ord + 'static>(
  120|     26|        graph: &UnDirGraphMtEph<V>,
  121|     26|        partition_map: &HashMap<V, V>,
  122|     26|    ) -> Set<Edge<V>> {
  123|     26|        let edges_vec: std::vec::Vec<Edge<V>> = graph.edges().iter().cloned().collect();
  124|     26|        let edges_seq = ArraySeqStEphS::from_vec(edges_vec);
  125|     26|        let n_edges = edges_seq.length();
  126|       |
  127|     26|        let part_map_arc = Arc::new(partition_map.clone());
  128|       |
  129|     26|        route_edges_parallel(&edges_seq, part_map_arc, 0, n_edges)
  130|     26|    }
  131|       |
  132|       |    /// Parallel edge routing using divide-and-conquer
  133|       |    ///
  134|       |    /// Work O(k), Span O(lg k), where k = end - start
  135|     94|    fn route_edges_parallel<V: StT + MtT + Hash + Ord + 'static>(
  136|     94|        edges: &ArraySeqStEphS<Edge<V>>,
  137|     94|        partition_map: Arc<HashMap<V, V>>,
  138|     94|        start: usize,
  139|     94|        end: usize,
  140|     94|    ) -> Set<Edge<V>> {
  141|     94|        let size = end - start;
  142|       |
  143|     94|        if size == 0 {
  144|      0|            return SetLit![];
  145|     94|        }
  146|       |
  147|     94|        if size == 1 {
  148|       |            // Base case: process single edge
  149|     60|            let edge = edges.nth(start as N);
  150|     60|            let Edge(u, v) = edge;
  151|     60|            let u_center = partition_map.get(u).unwrap_or(u);
  152|     60|            let v_center = partition_map.get(v).unwrap_or(v);
  153|       |
  154|       |            // Only add if centers are different
  155|     60|            if u_center != v_center {
  156|     35|                let new_edge = if u_center < v_center {
  157|     33|                    Edge(u_center.clone(), v_center.clone())
  158|       |                } else {
  159|      2|                    Edge(v_center.clone(), u_center.clone())
  160|       |                };
  161|     35|                return SetLit![new_edge];
  162|     25|            }
  163|     25|            return SetLit![];
  164|     34|        }
  165|       |
  166|       |        // Recursive case: divide and conquer
  167|     34|        let mid = start + size / 2;
  168|       |
  169|     34|        let edges1 = edges.clone();
  170|     34|        let map1 = partition_map.clone();
  171|     34|        let edges2 = edges.clone();
  172|     34|        let map2 = partition_map;
  173|       |
  174|     34|        let pair = ParaPair!(move || route_edges_parallel(&edges1, map1, start, mid), move || {
  175|     34|            route_edges_parallel(&edges2, map2, mid, end)
  176|     34|        });
  177|       |
  178|       |        // Union the two sets
  179|     34|        let mut result = pair.0;
  180|     34|        for edge in pair.1.iter() {
                          ^30
  181|     30|            let _ = result.insert(edge.clone());
  182|     30|        }
  183|     34|        result
  184|     94|    }
  185|       |
  186|       |    /// Helper: Compose maps in parallel (P  C)
  187|       |    ///
  188|       |    /// For each (u  v) in P, output (u  C[v])
  189|       |    ///
  190|       |    /// Work O(|P|), Span O(lg |P|), Parallelism (|P|/lg |P|)
  191|      8|    fn compose_maps_parallel<V: StT + MtT + Hash + Ord + 'static>(
  192|      8|        partition_map: &HashMap<V, V>,
  193|      8|        component_map: &HashMap<V, V>,
  194|      8|    ) -> HashMap<V, V> {
  195|       |        // For now, compose sequentially since tuples don't implement Display
  196|       |        // Future optimization: use custom parallel map composition
  197|      8|        let mut result = HashMap::new();
  198|     31|        for (u, v) in partition_map.iter() {
                                    ^8            ^8
  199|     31|            let component = component_map.get(v).unwrap_or(v);
  200|     31|            let _ = result.insert(u.clone(), component.clone());
  201|     31|        }
  202|      8|        result
  203|      8|    }
  204|       |
  205|       |    /// Exercise 63.1: Count Components using star_contract_mt higher-order function
  206|       |    ///
  207|       |    /// APAS: Work O((n+m) lg n), Span O(lg n)
  208|       |    /// claude-4-sonet: Work O((n+m) lg n), Span O(lg n), Parallelism ((n+m)/lg n)
  209|      1|    pub fn count_components_hof<V: StT + MtT + Hash + Ord + 'static>(graph: &UnDirGraphMtEph<V>, seed: u64) -> N {
  210|       |        // Base: when no edges, return number of vertices
  211|      1|        let base = |vertices: &Set<V>| vertices.size();
  212|       |
  213|       |        // Expand: just return the recursive result
  214|      1|        let expand = |_v: &Set<V>, _e: &Set<Edge<V>>, _centers: &Set<V>, _part: &HashMap<V, V>, r: N| r;
  215|       |
  216|      1|        star_contract_mt(graph, seed, &base, &expand)
  217|      1|    }
  218|       |
  219|       |    /// Exercise 63.2: Connected Components using star_contract_mt higher-order function
  220|       |    ///
  221|       |    /// APAS: Work O((n+m) lg n), Span O(lg n)
  222|       |    /// claude-4-sonet: Work O((n+m) lg n), Span O(lg n), Parallelism ((n+m)/lg n)
  223|      0|    pub fn connected_components_hof<V: StT + MtT + Hash + Ord + 'static>(
  224|      0|        graph: &UnDirGraphMtEph<V>,
  225|      0|        seed: u64,
  226|      0|    ) -> (Set<V>, HashMap<V, V>) {
  227|       |        // Base: when no edges, each vertex maps to itself
  228|      0|        let base = |vertices: &Set<V>| {
  229|      0|            let mut map = HashMap::new();
  230|      0|            for v in vertices.iter() {
  231|      0|                let _ = map.insert(v.clone(), v.clone());
  232|      0|            }
  233|      0|            (vertices.clone(), map)
  234|      0|        };
  235|       |
  236|       |        // Expand: compose partition map P with component map C
  237|      0|        let expand = |_v: &Set<V>,
  238|       |                      _e: &Set<Edge<V>>,
  239|       |                      _centers: &Set<V>,
  240|       |                      partition_map: &HashMap<V, V>,
  241|      0|                      (reps, component_map): (Set<V>, HashMap<V, V>)| {
  242|      0|            let mut result_map = HashMap::new();
  243|      0|            for (u, v) in partition_map.iter() {
  244|      0|                let component = component_map.get(v).unwrap_or(v);
  245|      0|                let _ = result_map.insert(u.clone(), component.clone());
  246|      0|            }
  247|      0|            (reps, result_map)
  248|      0|        };
  249|       |
  250|      0|        star_contract_mt(graph, seed, &base, &expand)
  251|      0|    }
  252|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap63/ConnectivityStEph.rs:
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 63: Graph Connectivity - Sequential Ephemeral Implementation
    3|       |//!
    4|       |//! Implements graph connectivity algorithms using star contraction.
    5|       |//! - Algorithm 63.2: count_components
    6|       |//! - Algorithm 63.3: connected_components
    7|       |//! - Exercise 63.1: count_components using star_contract
    8|       |//! - Exercise 63.2: connected_components using star_contract
    9|       |
   10|       |pub mod ConnectivityStEph {
   11|       |
   12|       |    use std::collections::HashMap;
   13|       |    use std::hash::Hash;
   14|       |
   15|       |    use crate::Chap05::SetStEph::SetStEph::*;
   16|       |    use crate::Chap06::UnDirGraphStEph::UnDirGraphStEph::*;
   17|       |    use crate::Chap62::StarContractionStEph::StarContractionStEph::star_contract;
   18|       |    use crate::Chap62::StarPartitionStEph::StarPartitionStEph::sequential_star_partition;
   19|       |    use crate::SetLit;
   20|       |    use crate::Types::Types::*;
   21|       |
   22|       |    pub trait ConnectivityStEphTrait {
   23|       |        /// Count connected components using star contraction
   24|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   25|       |        fn count_components<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> N;
   26|       |
   27|       |        /// Find connected components using star contraction
   28|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   29|       |        fn connected_components<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> Set<Set<V>>;
   30|       |
   31|       |        /// Count components using higher-order function approach
   32|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   33|       |        fn count_components_hof<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> N;
   34|       |
   35|       |        /// Find components using higher-order function approach
   36|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   37|       |        fn connected_components_hof<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> Set<Set<V>>;
   38|       |    }
   39|       |
   40|       |    /// Algorithm 63.2: Count Connected Components
   41|       |    ///
   42|       |    /// Uses recursive star contraction to count the number of connected components.
   43|       |    /// Base case: No edges means each vertex is its own component.
   44|       |    /// Inductive case: Partition, build quotient graph, recurse.
   45|       |    ///
   46|       |    /// APAS: Work O((n+m) lg n), Span O((n+m) lg n)
   47|       |    /// claude-4-sonet: Work O((n+m) lg n), Span O((n+m) lg n)
   48|       |    ///
   49|       |    /// Arguments:
   50|       |    /// - graph: The undirected graph
   51|       |    ///
   52|       |    /// Returns:
   53|       |    /// - The number of connected components
   54|     10|    pub fn count_components<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> N {
   55|       |        // Base case: no edges, each vertex is own component
   56|     10|        if graph.sizeE() == 0 {
   57|      4|            return graph.sizeV();
   58|      6|        }
   59|       |
   60|       |        // Partition the graph
   61|      6|        let (centers, partition_map) = sequential_star_partition(graph);
   62|       |
   63|       |        // Build quotient graph by routing edges through partition map
   64|      6|        let quotient_edges = build_quotient_edges(graph, &partition_map);
   65|      6|        let quotient_graph = <UnDirGraphStEph<V> as UnDirGraphStEphTrait<V>>::FromSets(centers, quotient_edges);
   66|       |
   67|       |        // Recursively count components in quotient graph
   68|      6|        count_components(&quotient_graph)
   69|     10|    }
   70|       |
   71|       |    /// Algorithm 63.3: Connected Components
   72|       |    ///
   73|       |    /// Computes all connected components and returns a mapping from each vertex
   74|       |    /// to a representative of its component.
   75|       |    ///
   76|       |    /// APAS: Work O((n+m) lg n), Span O((n+m) lg n)
   77|       |    /// claude-4-sonet: Work O((n+m) lg n), Span O((n+m) lg n)
   78|       |    ///
   79|       |    /// Arguments:
   80|       |    /// - graph: The undirected graph
   81|       |    ///
   82|       |    /// Returns:
   83|       |    /// - (representatives, component_map): Set of component representatives and
   84|       |    ///   mapping from each vertex to its component representative
   85|      9|    pub fn connected_components<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> (Set<V>, HashMap<V, V>) {
   86|       |        // Base case: no edges, each vertex maps to itself
   87|      9|        if graph.sizeE() == 0 {
   88|      3|            let mut component_map = HashMap::new();
   89|      7|            for vertex in graph.vertices().iter() {
                                        ^3               ^3
   90|      7|                let _ = component_map.insert(vertex.clone(), vertex.clone());
   91|      7|            }
   92|      3|            return (graph.vertices().clone(), component_map);
   93|      6|        }
   94|       |
   95|       |        // Partition the graph
   96|      6|        let (centers, partition_map) = sequential_star_partition(graph);
   97|       |
   98|       |        // Build quotient graph
   99|      6|        let quotient_edges = build_quotient_edges(graph, &partition_map);
  100|      6|        let quotient_graph = <UnDirGraphStEph<V> as UnDirGraphStEphTrait<V>>::FromSets(centers, quotient_edges);
  101|       |
  102|       |        // Recursively compute components in quotient graph
  103|      6|        let (representatives, component_map_quotient) = connected_components(&quotient_graph);
  104|       |
  105|       |        // Compose maps: for each vertex u, map it to C[P[u]]
  106|      6|        let mut component_map = HashMap::new();
  107|     33|        for (u, v) in partition_map.iter() {
                                    ^6            ^6
  108|     33|            let component = component_map_quotient.get(v).unwrap_or(v);
  109|     33|            let _ = component_map.insert(u.clone(), component.clone());
  110|     33|        }
  111|       |
  112|      6|        (representatives, component_map)
  113|      9|    }
  114|       |
  115|       |    /// Helper: Build quotient graph edges by routing through partition map
  116|       |    ///
  117|       |    /// Filters out self-edges (where both endpoints map to same super-vertex).
  118|       |    ///
  119|       |    /// Work O(m), Span O(m)
  120|     12|    fn build_quotient_edges<V: StT + Hash + Ord>(
  121|     12|        graph: &UnDirGraphStEph<V>,
  122|     12|        partition_map: &HashMap<V, V>,
  123|     12|    ) -> Set<Edge<V>> {
  124|     12|        let mut quotient_edges: Set<Edge<V>> = SetLit![];
  125|       |
  126|     40|        for edge in graph.edges().iter() {
                                  ^12           ^12
  127|     40|            let Edge(u, v) = edge;
  128|     40|            let u_center = partition_map.get(u).unwrap_or(u);
  129|     40|            let v_center = partition_map.get(v).unwrap_or(v);
  130|       |
  131|       |            // Only add if centers are different (no self-loops)
  132|     40|            if u_center != v_center {
  133|     10|                let new_edge = if u_center < v_center {
  134|      8|                    Edge(u_center.clone(), v_center.clone())
  135|       |                } else {
  136|      2|                    Edge(v_center.clone(), u_center.clone())
  137|       |                };
  138|     10|                let _ = quotient_edges.insert(new_edge);
  139|     30|            }
  140|       |        }
  141|       |
  142|     12|        quotient_edges
  143|     12|    }
  144|       |
  145|       |    /// Exercise 63.1: Count Components using star_contract higher-order function
  146|       |    ///
  147|       |    /// Expresses countComponents in terms of starContract (Algorithm 62.5).
  148|       |    ///
  149|       |    /// APAS: Work O((n+m) lg n), Span O((n+m) lg n)
  150|       |    /// claude-4-sonet: Work O((n+m) lg n), Span O((n+m) lg n)
  151|      1|    pub fn count_components_hof<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> N {
  152|       |        // Base: when no edges, return number of vertices
  153|      1|        let base = |vertices: &Set<V>| vertices.size();
  154|       |
  155|       |        // Expand: just return the recursive result (no expansion needed for counting)
  156|      1|        let expand = |_v: &Set<V>, _e: &Set<Edge<V>>, _centers: &Set<V>, _part: &HashMap<V, V>, r: N| r;
  157|       |
  158|      1|        star_contract(graph, &base, &expand)
  159|      1|    }
  160|       |
  161|       |    /// Exercise 63.2: Connected Components using star_contract higher-order function
  162|       |    ///
  163|       |    /// Expresses connectedComponents in terms of starContract (Algorithm 62.5).
  164|       |    ///
  165|       |    /// APAS: Work O((n+m) lg n), Span O((n+m) lg n)
  166|       |    /// claude-4-sonet: Work O((n+m) lg n), Span O((n+m) lg n)
  167|      1|    pub fn connected_components_hof<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> (Set<V>, HashMap<V, V>) {
  168|       |        // Base: when no edges, each vertex maps to itself
  169|      1|        let base = |vertices: &Set<V>| {
  170|      1|            let mut map = HashMap::new();
  171|      3|            for v in vertices.iter() {
                                   ^1       ^1
  172|      3|                let _ = map.insert(v.clone(), v.clone());
  173|      3|            }
  174|      1|            (vertices.clone(), map)
  175|      1|        };
  176|       |
  177|       |        // Expand: compose partition map P with component map C
  178|      1|        let expand = |_v: &Set<V>,
  179|       |                      _e: &Set<Edge<V>>,
  180|       |                      _centers: &Set<V>,
  181|       |                      partition_map: &HashMap<V, V>,
  182|      2|                      (reps, component_map): (Set<V>, HashMap<V, V>)| {
  183|      2|            let mut result_map = HashMap::new();
  184|     13|            for (u, v) in partition_map.iter() {
                                        ^2            ^2
  185|     13|                let component = component_map.get(v).unwrap_or(v);
  186|     13|                let _ = result_map.insert(u.clone(), component.clone());
  187|     13|            }
  188|      2|            (reps, result_map)
  189|      2|        };
  190|       |
  191|      1|        star_contract(graph, &base, &expand)
  192|      1|    }
  193|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap64/SpanTreeMtEph.rs:
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 64: Minimum Spanning Trees - Spanning Tree via Star Contraction (Parallel)
    3|       |//!
    4|       |//! Implements Exercise 64.2: Compute spanning tree using parallel star contraction.
    5|       |
    6|       |pub mod SpanTreeMtEph {
    7|       |
    8|       |    use std::collections::HashMap;
    9|       |    use std::hash::Hash;
   10|       |
   11|       |    use crate::Chap05::SetStEph::SetStEph::*;
   12|       |    use crate::Chap06::UnDirGraphMtEph::UnDirGraphMtEph::*;
   13|       |    use crate::Chap62::StarContractionMtEph::StarContractionMtEph::star_contract_mt;
   14|       |    use crate::SetLit;
   15|       |    use crate::Types::Types::*;
   16|       |
   17|       |    pub trait SpanTreeMtEphTrait {
   18|       |        /// Parallel spanning tree via star contraction
   19|       |        /// APAS: Work O(|V| + |E|), Span O(lg |V|)
   20|       |        fn spanning_tree_star_contraction_mt<V: StT + MtT + Hash + Ord + 'static>(
   21|       |            graph: &UnDirGraphMtEph<V>,
   22|       |        ) -> Set<Edge<V>>;
   23|       |
   24|       |        /// Verify spanning tree properties
   25|       |        /// APAS: Work O(|V| + |E|), Span O(lg |V|)
   26|       |        fn verify_spanning_tree<V: StT + MtT + Hash + Ord>(graph: &UnDirGraphMtEph<V>, tree: &Set<Edge<V>>) -> B;
   27|       |    }
   28|       |
   29|       |    /// Exercise 64.2: Spanning Tree via Star Contraction (Parallel)
   30|       |    ///
   31|       |    /// Computes a spanning tree using parallel star contraction.
   32|       |    ///
   33|       |    /// APAS: Work O((n+m) lg n), Span O(lg n)
   34|       |    /// claude-4-sonet: Work O((n+m) lg n), Span O(lg n), Parallelism ((n+m)/lg n)
   35|       |    ///
   36|       |    /// Arguments:
   37|       |    /// - graph: The undirected graph
   38|       |    /// - seed: Random seed for star partition
   39|       |    ///
   40|       |    /// Returns:
   41|       |    /// - Set of edges forming a spanning tree
   42|      1|    pub fn spanning_tree_star_contraction_mt<V: StT + MtT + Hash + Ord + 'static>(
   43|      1|        graph: &UnDirGraphMtEph<V>,
   44|      1|        seed: u64,
   45|      1|    ) -> Set<Edge<V>> {
   46|       |        // Base: no edges means no spanning tree edges
   47|      1|        let base = |_vertices: &Set<V>| SetLit![];
   48|       |
   49|       |        // Expand: add star partition edges to recursive result
   50|      1|        let expand = |_v: &Set<V>,
   51|       |                      _e: &Set<Edge<V>>,
   52|       |                      _centers: &Set<V>,
   53|       |                      partition_map: &HashMap<V, V>,
   54|      0|                      quotient_edges: Set<Edge<V>>| {
   55|      0|            let mut spanning_edges = SetLit![];
   56|       |
   57|      0|            for (vertex, center) in partition_map.iter() {
   58|      0|                if vertex != center {
   59|      0|                    let edge = if vertex < center {
   60|      0|                        Edge(vertex.clone(), center.clone())
   61|       |                    } else {
   62|      0|                        Edge(center.clone(), vertex.clone())
   63|       |                    };
   64|      0|                    let _ = spanning_edges.insert(edge);
   65|      0|                }
   66|       |            }
   67|       |
   68|      0|            for edge in quotient_edges.iter() {
   69|      0|                let _ = spanning_edges.insert(edge.clone());
   70|      0|            }
   71|       |
   72|      0|            spanning_edges
   73|      0|        };
   74|       |
   75|      1|        star_contract_mt(graph, seed, &base, &expand)
   76|      1|    }
   77|       |
   78|       |    /// Verify that result is a valid spanning tree
   79|      0|    pub fn verify_spanning_tree<V: StT + MtT + Hash + Ord>(graph: &UnDirGraphMtEph<V>, tree_edges: &Set<Edge<V>>) -> B {
   80|      0|        let n = graph.sizeV();
   81|      0|        let expected_edges = if n > 0 { n - 1 } else { 0 };
   82|       |
   83|      0|        if tree_edges.size() != expected_edges {
   84|      0|            return false;
   85|      0|        }
   86|       |
   87|      0|        for edge in tree_edges.iter() {
   88|       |            // For undirected graphs, check both edge orientations
   89|      0|            let Edge(u, v) = edge;
   90|      0|            if !graph.edges().mem(edge) && !graph.edges().mem(&Edge(v.clone(), u.clone())) {
   91|      0|                return false;
   92|      0|            }
   93|       |        }
   94|       |
   95|      0|        true
   96|      0|    }
   97|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap64/SpanTreeStEph.rs:
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 64: Minimum Spanning Trees - Spanning Tree via Star Contraction (Sequential)
    3|       |//!
    4|       |//! Implements Exercise 64.2: Compute spanning tree using star contraction.
    5|       |
    6|       |pub mod SpanTreeStEph {
    7|       |
    8|       |    use std::collections::HashMap;
    9|       |    use std::hash::Hash;
   10|       |
   11|       |    use crate::Chap05::SetStEph::SetStEph::*;
   12|       |    use crate::Chap06::UnDirGraphStEph::UnDirGraphStEph::*;
   13|       |    use crate::Chap62::StarContractionStEph::StarContractionStEph::star_contract;
   14|       |    use crate::SetLit;
   15|       |    use crate::Types::Types::*;
   16|       |
   17|       |    pub trait SpanTreeStEphTrait {
   18|       |        /// Sequential spanning tree via star contraction
   19|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   20|       |        fn spanning_tree_star_contraction<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> Set<Edge<V>>;
   21|       |
   22|       |        /// Verify spanning tree properties
   23|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   24|       |        fn verify_spanning_tree<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>, tree: &Set<Edge<V>>) -> B;
   25|       |    }
   26|       |
   27|       |    /// Exercise 64.2: Spanning Tree via Star Contraction
   28|       |    ///
   29|       |    /// Computes a spanning tree by recursively applying star contraction and
   30|       |    /// collecting all edges from star partitions.
   31|       |    ///
   32|       |    /// Algorithm:
   33|       |    /// 1. Base case: If no edges, return empty edge set
   34|       |    /// 2. Compute star partition (centers and partition map)
   35|       |    /// 3. Add all edges from partition map to spanning tree
   36|       |    /// 4. Build quotient graph
   37|       |    /// 5. Recursively compute spanning tree of quotient
   38|       |    /// 6. Map quotient tree edges back to original edges
   39|       |    ///
   40|       |    /// APAS: Work O((n+m) lg n), Span O((n+m) lg n)
   41|       |    /// claude-4-sonet: Work O((n+m) lg n), Span O((n+m) lg n)
   42|       |    ///
   43|       |    /// Arguments:
   44|       |    /// - graph: The undirected graph
   45|       |    ///
   46|       |    /// Returns:
   47|       |    /// - Set of edges forming a spanning tree
   48|      5|    pub fn spanning_tree_star_contraction<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> Set<Edge<V>> {
   49|       |        // Base: no edges means no spanning tree edges (isolated vertices)
   50|      5|        let base = |_vertices: &Set<V>| SetLit![];
   51|       |
   52|       |        // Expand: add star partition edges and map quotient tree edges back
   53|      5|        let expand = |_v: &Set<V>,
   54|       |                      original_edges: &Set<Edge<V>>,
   55|       |                      _centers: &Set<V>,
   56|       |                      partition_map: &HashMap<V, V>,
   57|      6|                      quotient_tree: Set<Edge<V>>| {
   58|       |            // Collect edges from partition map (vertex  center edges)
   59|      6|            let mut spanning_edges = SetLit![];
   60|       |
   61|     25|            for (vertex, center) in partition_map.iter() {
                                                  ^6            ^6
   62|       |                // Add edge if vertex is not its own center (avoid self-loops)
   63|     25|                if vertex != center {
   64|       |                    // Normalize edge order
   65|     14|                    let edge = if vertex < center {
   66|      7|                        Edge(vertex.clone(), center.clone())
   67|       |                    } else {
   68|      7|                        Edge(center.clone(), vertex.clone())
   69|       |                    };
   70|     14|                    let _ = spanning_edges.insert(edge);
   71|     11|                }
   72|       |            }
   73|       |
   74|       |            // Map quotient tree edges back to original edges
   75|       |            // For each edge between centers in quotient tree, find original edge that maps to it
   76|      6|            for quotient_edge in quotient_tree.iter() {
                              ^5
   77|      5|                let Edge(c1, c2) = quotient_edge;
   78|       |
   79|       |                // Find an original edge that connects the two stars (centers c1 and c2)
   80|     16|                for original_edge in original_edges.iter() {
                                                   ^5             ^5
   81|     16|                    let Edge(u, v) = original_edge;
   82|     16|                    let u_center = partition_map.get(u).unwrap_or(u);
   83|     16|                    let v_center = partition_map.get(v).unwrap_or(v);
   84|       |
   85|       |                    // Check if this original edge connects the two centers (in either direction)
   86|     16|                    if (u_center == c1 && v_center == c2) || (u_center == c2 && v_center == c1) {
                                                        ^8                  ^12               ^4
   87|      5|                        let _ = spanning_edges.insert(original_edge.clone());
   88|      5|                        break; // Only need one edge between the two stars
   89|     11|                    }
   90|       |                }
   91|       |            }
   92|       |
   93|      6|            spanning_edges
   94|      6|        };
   95|       |
   96|      5|        star_contract(graph, &base, &expand)
   97|      5|    }
   98|       |
   99|       |    /// Verify that result is a valid spanning tree
  100|       |    ///
  101|       |    /// Checks:
  102|       |    /// 1. All vertices are included
  103|       |    /// 2. Exactly |V| - 1 edges
  104|       |    /// 3. All edges are from original graph
  105|       |    ///
  106|       |    /// Returns true if valid spanning tree
  107|      5|    pub fn verify_spanning_tree<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>, tree_edges: &Set<Edge<V>>) -> B {
  108|      5|        let n = graph.sizeV();
  109|      5|        let expected_edges = if n > 0 { n - 1 } else { 0 };
                                                                     ^0
  110|       |
  111|       |        // Check edge count
  112|      5|        if tree_edges.size() != expected_edges {
  113|      1|            return false;
  114|      4|        }
  115|       |
  116|       |        // Check all edges are from original graph
  117|     14|        for edge in tree_edges.iter() {
                                  ^4         ^4
  118|     14|            let Edge(u, v) = edge;
  119|       |            // For undirected graphs, Neighbor checks if u and v are connected
  120|     14|            if !graph.Neighbor(u, v) {
  121|      0|                return false;
  122|     14|            }
  123|       |        }
  124|       |
  125|      4|        true
  126|      5|    }
  127|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap64/TSPApproxMtEph.rs:
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 64: TSP 2-Approximation via MST (Parallel)
    3|       |//!
    4|       |//! Implements Section 4: Approximating Metric TSP via MST (parallel version)
    5|       |//! Note: Euler tour remains sequential (DFS-based), but included for API completeness
    6|       |
    7|       |pub mod TSPApproxMtEph {
    8|       |
    9|       |    use std::collections::{HashMap, HashSet};
   10|       |    use std::hash::Hash;
   11|       |
   12|       |    use crate::Chap05::SetStEph::SetStEph::*;
   13|       |    use crate::Chap06::LabUnDirGraphMtEph::LabUnDirGraphMtEph::*;
   14|       |    use crate::SetLit;
   15|       |    use crate::Types::Types::*;
   16|       |    use ordered_float::OrderedFloat;
   17|       |
   18|       |    pub trait TSPApproxMtEphTrait {
   19|       |        /// Parallel Euler tour of a tree
   20|       |        /// APAS: Work O(|V|), Span O(|V|)
   21|       |        fn euler_tour_mt<V: StT + MtT + Hash + Ord + 'static>(
   22|       |            tree: &LabUnDirGraphMtEph<V, OrderedFloat<f64>>,
   23|       |            start: V,
   24|       |        ) -> std::vec::Vec<V>;
   25|       |
   26|       |        /// Parallel shortcut Euler tour
   27|       |        /// APAS: Work O(|V|), Span O(lg |V|)
   28|       |        fn shortcut_tour_mt<V: StT + MtT + Hash + Ord>(euler_tour: &[V]) -> std::vec::Vec<V>;
   29|       |
   30|       |        /// Parallel tour weight computation
   31|       |        /// APAS: Work O(|V|), Span O(lg |V|)
   32|       |        fn tour_weight_mt<V: StT + MtT + Hash + Ord>(
   33|       |            tour: &[V],
   34|       |            distances: &HashMap<(V, V), OrderedFloat<f64>>,
   35|       |        ) -> OrderedFloat<f64>;
   36|       |
   37|       |        /// Parallel 2-approximation algorithm for metric TSP
   38|       |        /// APAS: Work O(|V| log |V|), Span O(|V| log |V|)
   39|       |        fn approx_metric_tsp_mt<V: StT + MtT + Hash + Ord + 'static>(
   40|       |            distances: &HashMap<(V, V), OrderedFloat<f64>>,
   41|       |            vertices: &Set<V>,
   42|       |        ) -> std::vec::Vec<V>;
   43|       |    }
   44|       |
   45|       |    /// Euler Tour of a Tree (Parallel version, but DFS remains sequential)
   46|       |    ///
   47|       |    /// APAS: Work O(n), Span O(n)
   48|       |    /// claude-4-sonet: Work O(n), Span O(n) [DFS is inherently sequential]
   49|       |    ///
   50|       |    /// Arguments:
   51|       |    /// - graph: Undirected graph (should be a tree)
   52|       |    /// - start: Starting vertex
   53|       |    /// - tree_edges: Set of edges forming the tree
   54|       |    ///
   55|       |    /// Returns:
   56|       |    /// - Vector of vertices in Euler tour order
   57|      2|    pub fn euler_tour_mt<V: StT + MtT + Hash + Ord + 'static>(
   58|      2|        graph: &LabUnDirGraphMtEph<V, OrderedFloat<f64>>,
   59|      2|        start: &V,
   60|      2|        tree_edges: &Set<LabEdge<V, OrderedFloat<f64>>>,
   61|      2|    ) -> std::vec::Vec<V> {
   62|      2|        let mut tour = std::vec::Vec::new();
   63|      2|        let mut visited_edges: HashSet<(V, V)> = HashSet::new();
   64|       |
   65|      2|        euler_tour_dfs(graph, start, None, tree_edges, &mut tour, &mut visited_edges);
   66|       |
   67|      2|        tour
   68|      2|    }
   69|       |
   70|       |    /// DFS helper for Euler tour
   71|      6|    fn euler_tour_dfs<V: StT + MtT + Hash + Ord>(
   72|      6|        graph: &LabUnDirGraphMtEph<V, OrderedFloat<f64>>,
   73|      6|        current: &V,
   74|      6|        parent: Option<&V>,
   75|      6|        tree_edges: &Set<LabEdge<V, OrderedFloat<f64>>>,
   76|      6|        tour: &mut std::vec::Vec<V>,
   77|      6|        visited_edges: &mut HashSet<(V, V)>,
   78|      6|    ) {
   79|      6|        tour.push(current.clone());
   80|       |
   81|      6|        let neighbors = get_neighbors(graph, current);
   82|     12|        for neighbor in neighbors.iter() {
                                      ^6        ^6
   83|     12|            if let Some(p) = parent {
                                      ^8
   84|      8|                if neighbor == p {
   85|      4|                    continue;
   86|      4|                }
   87|      4|            }
   88|       |
   89|      8|            let edge_key = if current < neighbor {
   90|      6|                (current.clone(), neighbor.clone())
   91|       |            } else {
   92|      2|                (neighbor.clone(), current.clone())
   93|       |            };
   94|       |
   95|      8|            if visited_edges.contains(&edge_key) {
   96|      0|                continue;
   97|      8|            }
   98|       |
   99|      8|            let mut edge_found = false;
  100|     14|            for edge in tree_edges.iter() {
                                      ^8         ^8
  101|     14|                let LabEdge(u, v, _) = edge;
  102|     14|                if (u == current && v == neighbor) || (u == neighbor && v == current) {
                                                  ^6                 ^10              ^3
  103|      4|                    edge_found = true;
  104|      4|                    break;
  105|     10|                }
  106|       |            }
  107|       |
  108|      8|            if edge_found {
  109|      4|                visited_edges.insert(edge_key);
  110|      4|                euler_tour_dfs(graph, neighbor, Some(current), tree_edges, tour, visited_edges);
  111|      4|                tour.push(current.clone());
  112|      4|            }
  113|       |        }
  114|      6|    }
  115|       |
  116|       |    /// Shortcut Tour (Parallel version)
  117|       |    ///
  118|       |    /// APAS: Work O(n), Span O(n)
  119|       |    /// claude-4-sonet: Work O(n), Span O(n)
  120|       |    ///
  121|       |    /// Note: Could be parallelized with filter operation, but overhead likely not worth it
  122|      2|    pub fn shortcut_tour_mt<V: StT + MtT + Hash + Ord>(euler_tour: &[V]) -> std::vec::Vec<V> {
  123|      2|        if euler_tour.is_empty() {
  124|      0|            return std::vec::Vec::new();
  125|      2|        }
  126|       |
  127|      2|        let mut shortcut = std::vec::Vec::new();
  128|      2|        let mut visited: HashSet<V> = HashSet::new();
  129|       |
  130|     10|        for vertex in euler_tour.iter() {
                                    ^2         ^2
  131|     10|            if !visited.contains(vertex) {
  132|      6|                shortcut.push(vertex.clone());
  133|      6|                let _ = visited.insert(vertex.clone());
  134|      6|            }
                          ^4
  135|       |        }
  136|       |
  137|      2|        if let Some(start) = shortcut.first() {
  138|      2|            shortcut.push(start.clone());
  139|      2|        }
                      ^0
  140|       |
  141|      2|        shortcut
  142|      2|    }
  143|       |
  144|       |    /// Compute tour weight
  145|       |    ///
  146|       |    /// APAS: Work O(n), Span O(n)
  147|       |    /// claude-4-sonet: Work O(n), Span O(n)
  148|      1|    pub fn tour_weight_mt<V: StT + MtT + Hash + Ord>(
  149|      1|        graph: &LabUnDirGraphMtEph<V, OrderedFloat<f64>>,
  150|      1|        tour: &[V],
  151|      1|    ) -> OrderedFloat<f64> {
  152|      1|        let mut total = OrderedFloat(0.0);
  153|       |
  154|      3|        for i in 0..tour.len() - 1 {
                                  ^1
  155|      3|            let u = &tour[i];
  156|      3|            let v = &tour[i + 1];
  157|       |
  158|      3|            if let Some(weight) = get_edge_weight(graph, u, v) {
  159|      3|                total += weight;
  160|      3|            }
                          ^0
  161|       |        }
  162|       |
  163|      1|        total
  164|      1|    }
  165|       |
  166|       |    /// Helper to get neighbors of a vertex
  167|      6|    fn get_neighbors<V: StT + MtT + Hash + Ord>(graph: &LabUnDirGraphMtEph<V, OrderedFloat<f64>>, v: &V) -> Set<V> {
  168|      6|        let mut neighbors = SetLit![];
  169|     18|        for edge in graph.labeled_edges().iter() {
                                  ^6                    ^6
  170|     18|            let LabEdge(a, b, _) = edge;
  171|     18|            if a == v {
  172|      6|                let _ = neighbors.insert(b.clone());
  173|     12|            } else if b == v {
  174|      6|                let _ = neighbors.insert(a.clone());
  175|      6|            }
  176|       |        }
  177|      6|        neighbors
  178|      6|    }
  179|       |
  180|       |    /// Helper to get edge weight
  181|      3|    fn get_edge_weight<V: StT + MtT + Hash + Ord>(
  182|      3|        graph: &LabUnDirGraphMtEph<V, OrderedFloat<f64>>,
  183|      3|        u: &V,
  184|      3|        v: &V,
  185|      3|    ) -> Option<OrderedFloat<f64>> {
  186|      6|        for edge in graph.labeled_edges().iter() {
                                  ^3                    ^3
  187|      6|            let LabEdge(a, b, w) = edge;
  188|      6|            if (a == u && b == v) || (a == v && b == u) {
                                        ^3          ^3        ^2
  189|      3|                return Some(*w);
  190|      3|            }
  191|       |        }
  192|      0|        None
  193|      3|    }
  194|       |
  195|       |    /// Approximate Metric TSP (Parallel version)
  196|       |    ///
  197|       |    /// APAS: Work O(n+m), Span O(n+m)
  198|       |    /// claude-4-sonet: Work O(n+m), Span O(n+m) [Limited parallelism due to DFS]
  199|       |    ///
  200|       |    /// Arguments:
  201|       |    /// - graph: Complete weighted undirected graph (metric)
  202|       |    /// - spanning_tree: Spanning tree edges (ideally MST)
  203|       |    /// - start: Starting vertex
  204|       |    ///
  205|       |    /// Returns:
  206|       |    /// - (tour, weight): Hamiltonian cycle and its total weight
  207|      1|    pub fn approx_metric_tsp_mt<V: StT + MtT + Hash + Ord + 'static>(
  208|      1|        graph: &LabUnDirGraphMtEph<V, OrderedFloat<f64>>,
  209|      1|        spanning_tree: &Set<LabEdge<V, OrderedFloat<f64>>>,
  210|      1|        start: &V,
  211|      1|    ) -> (std::vec::Vec<V>, OrderedFloat<f64>) {
  212|      1|        let euler = euler_tour_mt(graph, start, spanning_tree);
  213|      1|        let tour = shortcut_tour_mt(&euler);
  214|      1|        let weight = tour_weight_mt(graph, &tour);
  215|       |
  216|      1|        (tour, weight)
  217|      1|    }
  218|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap64/TSPApproxStEph.rs:
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 64: TSP 2-Approximation via MST (Sequential)
    3|       |//!
    4|       |//! Implements Section 4: Approximating Metric TSP via MST
    5|       |//! - Euler tour of spanning tree
    6|       |//! - Shortcut to avoid revisiting vertices
    7|       |//! - 2-approximation guarantee
    8|       |
    9|       |pub mod TSPApproxStEph {
   10|       |
   11|       |    use std::collections::{HashMap, HashSet};
   12|       |    use std::hash::Hash;
   13|       |
   14|       |    use crate::Chap05::SetStEph::SetStEph::*;
   15|       |    use crate::Chap06::LabUnDirGraphStEph::LabUnDirGraphStEph::*;
   16|       |    use crate::SetLit;
   17|       |    use crate::Types::Types::*;
   18|       |    use ordered_float::OrderedFloat;
   19|       |
   20|       |    pub trait TSPApproxStEphTrait {
   21|       |        /// Compute Euler tour of a tree
   22|       |        /// APAS: Work O(|V|), Span O(|V|)
   23|       |        fn euler_tour<V: StT + Hash + Ord>(
   24|       |            tree: &LabUnDirGraphStEph<V, OrderedFloat<f64>>,
   25|       |            start: V,
   26|       |        ) -> std::vec::Vec<V>;
   27|       |
   28|       |        /// Shortcut Euler tour to avoid revisiting vertices
   29|       |        /// APAS: Work O(|V|), Span O(|V|)
   30|       |        fn shortcut_tour<V: StT + Hash + Ord>(euler_tour: &[V]) -> std::vec::Vec<V>;
   31|       |
   32|       |        /// Compute total weight of a tour
   33|       |        /// APAS: Work O(|V|), Span O(|V|)
   34|       |        fn tour_weight<V: StT + Hash + Ord>(
   35|       |            tour: &[V],
   36|       |            distances: &HashMap<(V, V), OrderedFloat<f64>>,
   37|       |        ) -> OrderedFloat<f64>;
   38|       |
   39|       |        /// 2-approximation algorithm for metric TSP
   40|       |        /// APAS: Work O(|V| log |V|), Span O(|V| log |V|)
   41|       |        fn approx_metric_tsp<V: StT + Hash + Ord>(
   42|       |            distances: &HashMap<(V, V), OrderedFloat<f64>>,
   43|       |            vertices: &Set<V>,
   44|       |        ) -> std::vec::Vec<V>;
   45|       |    }
   46|       |
   47|       |    /// Euler Tour of a Tree
   48|       |    ///
   49|       |    /// Performs DFS traversal that visits each edge twice (once in each direction).
   50|       |    /// Returns a sequence of vertices visited.
   51|       |    ///
   52|       |    /// APAS: Work O(n), Span O(n)
   53|       |    /// claude-4-sonet: Work O(n), Span O(n) [DFS is inherently sequential]
   54|       |    ///
   55|       |    /// Arguments:
   56|       |    /// - graph: Undirected graph (should be a tree)
   57|       |    /// - start: Starting vertex
   58|       |    /// - tree_edges: Set of edges forming the tree
   59|       |    ///
   60|       |    /// Returns:
   61|       |    /// - Vector of vertices in Euler tour order
   62|      2|    pub fn euler_tour<V: StT + Hash + Ord>(
   63|      2|        graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>,
   64|      2|        start: &V,
   65|      2|        tree_edges: &Set<LabEdge<V, OrderedFloat<f64>>>,
   66|      2|    ) -> std::vec::Vec<V> {
   67|      2|        let mut tour = std::vec::Vec::new();
   68|      2|        let mut visited_edges: HashSet<(V, V)> = HashSet::new();
   69|       |
   70|      2|        euler_tour_dfs(graph, start, None, tree_edges, &mut tour, &mut visited_edges);
   71|       |
   72|      2|        tour
   73|      2|    }
   74|       |
   75|       |    /// DFS helper for Euler tour
   76|      6|    fn euler_tour_dfs<V: StT + Hash + Ord>(
   77|      6|        graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>,
   78|      6|        current: &V,
   79|      6|        parent: Option<&V>,
   80|      6|        tree_edges: &Set<LabEdge<V, OrderedFloat<f64>>>,
   81|      6|        tour: &mut std::vec::Vec<V>,
   82|      6|        visited_edges: &mut HashSet<(V, V)>,
   83|      6|    ) {
   84|      6|        tour.push(current.clone());
   85|       |
   86|       |        // Visit all neighbors connected by tree edges
   87|      6|        let neighbors = get_neighbors(graph, current);
   88|     12|        for neighbor in neighbors.iter() {
                                      ^6        ^6
   89|       |            // Skip parent to avoid immediate backtrack
   90|     12|            if let Some(p) = parent {
                                      ^8
   91|      8|                if neighbor == p {
   92|      4|                    continue;
   93|      4|                }
   94|      4|            }
   95|       |
   96|       |            // Check if edge is in tree and not yet traversed
   97|      8|            let edge_key = if current < neighbor {
   98|      6|                (current.clone(), neighbor.clone())
   99|       |            } else {
  100|      2|                (neighbor.clone(), current.clone())
  101|       |            };
  102|       |
  103|      8|            if visited_edges.contains(&edge_key) {
  104|      0|                continue;
  105|      8|            }
  106|       |
  107|       |            // Check if edge exists in tree_edges
  108|      8|            let mut edge_found = false;
  109|     14|            for edge in tree_edges.iter() {
                                      ^8         ^8
  110|     14|                let LabEdge(u, v, _) = edge;
  111|     14|                if (u == current && v == neighbor) || (u == neighbor && v == current) {
                                                  ^6                 ^10              ^3
  112|      4|                    edge_found = true;
  113|      4|                    break;
  114|     10|                }
  115|       |            }
  116|       |
  117|      8|            if edge_found {
  118|      4|                visited_edges.insert(edge_key);
  119|      4|                euler_tour_dfs(graph, neighbor, Some(current), tree_edges, tour, visited_edges);
  120|      4|                tour.push(current.clone());
  121|      4|            }
  122|       |        }
  123|      6|    }
  124|       |
  125|       |    /// Shortcut Tour
  126|       |    ///
  127|       |    /// Removes duplicate vertex visits from Euler tour using triangle inequality.
  128|       |    /// Result is a Hamiltonian cycle (visits each vertex exactly once).
  129|       |    ///
  130|       |    /// APAS: Work O(n), Span O(n)
  131|       |    /// claude-4-sonet: Work O(n), Span O(n)
  132|       |    ///
  133|       |    /// Arguments:
  134|       |    /// - euler_tour: Euler tour with possible duplicate visits
  135|       |    ///
  136|       |    /// Returns:
  137|       |    /// - Vector of vertices with each vertex appearing exactly once (except start/end)
  138|      2|    pub fn shortcut_tour<V: StT + Hash + Ord>(euler_tour: &[V]) -> std::vec::Vec<V> {
  139|      2|        if euler_tour.is_empty() {
  140|      0|            return std::vec::Vec::new();
  141|      2|        }
  142|       |
  143|      2|        let mut shortcut = std::vec::Vec::new();
  144|      2|        let mut visited: HashSet<V> = HashSet::new();
  145|       |
  146|     11|        for vertex in euler_tour.iter() {
                                    ^2         ^2
  147|     11|            if !visited.contains(vertex) {
  148|      6|                shortcut.push(vertex.clone());
  149|      6|                let _ = visited.insert(vertex.clone());
  150|      6|            }
                          ^5
  151|       |        }
  152|       |
  153|       |        // Add starting vertex at end to complete cycle
  154|      2|        if let Some(start) = shortcut.first() {
  155|      2|            shortcut.push(start.clone());
  156|      2|        }
                      ^0
  157|       |
  158|      2|        shortcut
  159|      2|    }
  160|       |
  161|       |    /// Compute tour weight
  162|       |    ///
  163|       |    /// Sums the weights of edges in the tour.
  164|       |    ///
  165|       |    /// APAS: Work O(n), Span O(n)
  166|       |    /// claude-4-sonet: Work O(n), Span O(n)
  167|      2|    pub fn tour_weight<V: StT + Hash + Ord>(
  168|      2|        graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>,
  169|      2|        tour: &[V],
  170|      2|    ) -> OrderedFloat<f64> {
  171|      2|        let mut total = OrderedFloat(0.0);
  172|       |
  173|      6|        for i in 0..tour.len() - 1 {
                                  ^2
  174|      6|            let u = &tour[i];
  175|      6|            let v = &tour[i + 1];
  176|       |
  177|       |            // Find edge weight
  178|      6|            if let Some(weight) = get_edge_weight(graph, u, v) {
  179|      6|                total += weight;
  180|      6|            }
                          ^0
  181|       |        }
  182|       |
  183|      2|        total
  184|      2|    }
  185|       |
  186|       |    /// Helper to get neighbors of a vertex
  187|      6|    fn get_neighbors<V: StT + Hash + Ord>(graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>, v: &V) -> Set<V> {
  188|      6|        let mut neighbors = SetLit![];
  189|     18|        for edge in graph.labeled_edges().iter() {
                                  ^6                    ^6
  190|     18|            let LabEdge(a, b, _) = edge;
  191|     18|            if a == v {
  192|      6|                let _ = neighbors.insert(b.clone());
  193|     12|            } else if b == v {
  194|      6|                let _ = neighbors.insert(a.clone());
  195|      6|            }
  196|       |        }
  197|      6|        neighbors
  198|      6|    }
  199|       |
  200|       |    /// Helper to get edge weight between two vertices
  201|      6|    fn get_edge_weight<V: StT + Hash + Ord>(
  202|      6|        graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>,
  203|      6|        u: &V,
  204|      6|        v: &V,
  205|      6|    ) -> Option<OrderedFloat<f64>> {
  206|     12|        for edge in graph.labeled_edges().iter() {
                                  ^6                    ^6
  207|     12|            let LabEdge(a, b, w) = edge;
  208|     12|            if (a == u && b == v) || (a == v && b == u) {
                                        ^6          ^6        ^2
  209|      6|                return Some(*w);
  210|      6|            }
  211|       |        }
  212|      0|        None
  213|      6|    }
  214|       |
  215|       |    /// Approximate Metric TSP
  216|       |    ///
  217|       |    /// 2-approximation algorithm for metric TSP:
  218|       |    /// 1. Given spanning tree T (should be MST for best results)
  219|       |    /// 2. Compute Euler tour (visits each edge twice)
  220|       |    /// 3. Apply shortcuts using triangle inequality
  221|       |    /// 4. Result has weight  2  w(T)
  222|       |    ///
  223|       |    /// APAS: Work O(n+m), Span O(n+m)
  224|       |    /// claude-4-sonet: Work O(n+m), Span O(n+m)
  225|       |    ///
  226|       |    /// Arguments:
  227|       |    /// - graph: Complete weighted undirected graph (metric: satisfies triangle inequality)
  228|       |    /// - spanning_tree: Spanning tree edges (ideally MST)
  229|       |    /// - start: Starting vertex for tour
  230|       |    ///
  231|       |    /// Returns:
  232|       |    /// - (tour, weight): Hamiltonian cycle and its total weight
  233|      1|    pub fn approx_metric_tsp<V: StT + Hash + Ord>(
  234|      1|        graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>,
  235|      1|        spanning_tree: &Set<LabEdge<V, OrderedFloat<f64>>>,
  236|      1|        start: &V,
  237|      1|    ) -> (std::vec::Vec<V>, OrderedFloat<f64>) {
  238|       |        // Step 1: Compute Euler tour
  239|      1|        let euler = euler_tour(graph, start, spanning_tree);
  240|       |
  241|       |        // Step 2: Apply shortcuts
  242|      1|        let tour = shortcut_tour(&euler);
  243|       |
  244|       |        // Step 3: Compute tour weight
  245|      1|        let weight = tour_weight(graph, &tour);
  246|       |
  247|      1|        (tour, weight)
  248|      1|    }
  249|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap65/KruskalStEph.rs:
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 65: Kruskal's MST Algorithm (Sequential Ephemeral)
    3|       |//!
    4|       |//! Implements Algorithm 65.2: Kruskal's algorithm for computing Minimum Spanning Trees.
    5|       |//! Uses Union-Find data structure for efficient cycle detection.
    6|       |
    7|       |pub mod KruskalStEph {
    8|       |
    9|       |    use std::hash::Hash;
   10|       |
   11|       |    use crate::Chap05::SetStEph::SetStEph::*;
   12|       |    use crate::Chap06::LabUnDirGraphStEph::LabUnDirGraphStEph::*;
   13|       |    use crate::Chap65::UnionFindStEph::UnionFindStEph::UnionFind;
   14|       |    use crate::SetLit;
   15|       |    use crate::Types::Types::*;
   16|       |    use ordered_float::OrderedFloat;
   17|       |
   18|       |    pub trait KruskalStEphTrait {
   19|       |        /// Kruskal's MST algorithm
   20|       |        /// APAS: Work O(m log m), Span O(m log m) where m = |E|
   21|       |        fn kruskal_mst<V: StT + Hash + Ord>(
   22|       |            graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>,
   23|       |        ) -> Set<LabEdge<V, OrderedFloat<f64>>>;
   24|       |
   25|       |        /// Compute total weight of MST
   26|       |        /// APAS: Work O(m), Span O(1)
   27|       |        fn mst_weight<V: StT + Hash>(mst: &Set<LabEdge<V, OrderedFloat<f64>>>) -> OrderedFloat<f64>;
   28|       |
   29|       |        /// Verify MST has correct size
   30|       |        /// APAS: Work O(1), Span O(1)
   31|       |        fn verify_mst_size<V: StT + Hash + Ord>(
   32|       |            graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>,
   33|       |            mst: &Set<LabEdge<V, OrderedFloat<f64>>>,
   34|       |        ) -> B;
   35|       |    }
   36|       |
   37|       |    /// Algorithm 65.2: Kruskal's MST Algorithm
   38|       |    ///
   39|       |    /// Computes the Minimum Spanning Tree by sorting edges and greedily adding them.
   40|       |    /// Uses Union-Find to detect cycles efficiently.
   41|       |    ///
   42|       |    /// Algorithm:
   43|       |    /// 1. Sort edges by weight
   44|       |    /// 2. For each edge (u,v) in sorted order:
   45|       |    ///    - If find(u)  find(v): add edge to MST, union(u,v)
   46|       |    ///    - Else: skip (would create cycle)
   47|       |    ///
   48|       |    /// APAS: Work O(m lg n), Span O(m lg n)
   49|       |    /// claude-4-sonet: Work O(m lg n), Span O(m lg n) [sequential]
   50|       |    ///
   51|       |    /// Arguments:
   52|       |    /// - graph: Weighted undirected graph
   53|       |    ///
   54|       |    /// Returns:
   55|       |    /// - Set of edges forming the MST
   56|      7|    pub fn kruskal_mst<V: StT + Hash + Ord>(
   57|      7|        graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>,
   58|      7|    ) -> Set<LabEdge<V, OrderedFloat<f64>>> {
   59|      7|        let mut mst_edges = SetLit![];
   60|       |
   61|       |        // Initialize Union-Find with all vertices
   62|      7|        let mut uf = UnionFind::new();
   63|     23|        for vertex in graph.vertices().iter() {
                                    ^7               ^7
   64|     23|            uf.insert(vertex.clone());
   65|     23|        }
   66|       |
   67|       |        // Sort edges by weight
   68|      7|        let mut edges_vec: Vec<LabEdge<V, OrderedFloat<f64>>> = graph.labeled_edges().iter().cloned().collect();
   69|     25|        edges_vec.sort_by(|e1, e2| {
                      ^7        ^7
   70|     25|            let LabEdge(_u1, _v1, w1) = e1;
   71|     25|            let LabEdge(_u2, _v2, w2) = e2;
   72|     25|            w1.cmp(w2)
   73|     25|        });
   74|       |
   75|       |        // Greedily add edges that don't form cycles
   76|     24|        for edge in edges_vec.iter() {
                                  ^7        ^7
   77|     24|            let LabEdge(u, v, _w) = edge;
   78|       |
   79|       |            // Check if u and v are in different components
   80|     24|            if !uf.equals(u, v) {
   81|     16|                // Add edge to MST
   82|     16|                let _ = mst_edges.insert(edge.clone());
   83|     16|                // Union the components
   84|     16|                uf.union(u, v);
   85|     16|            }
                          ^8
   86|       |            // Else: skip edge (would form cycle)
   87|       |        }
   88|       |
   89|      7|        mst_edges
   90|      7|    }
   91|       |
   92|       |    /// Compute total MST weight
   93|       |    ///
   94|       |    /// APAS: Work O(|MST|), Span O(|MST|)
   95|       |    /// claude-4-sonet: Work O(|MST|), Span O(|MST|)
   96|      6|    pub fn mst_weight<V: StT + Hash>(mst_edges: &Set<LabEdge<V, OrderedFloat<f64>>>) -> OrderedFloat<f64> {
   97|      6|        let mut total = OrderedFloat(0.0);
   98|     14|        for edge in mst_edges.iter() {
                                  ^6        ^6
   99|     14|            let LabEdge(_u, _v, w) = edge;
  100|     14|            total += *w;
  101|     14|        }
  102|      6|        total
  103|      6|    }
  104|       |
  105|       |    /// Verify MST has correct number of edges
  106|       |    ///
  107|       |    /// A valid MST of n vertices should have n-1 edges.
  108|      4|    pub fn verify_mst_size<V: StT + Hash + Ord>(n_vertices: N, mst_edges: &Set<LabEdge<V, OrderedFloat<f64>>>) -> B {
  109|      4|        let expected_edges = if n_vertices > 0 { n_vertices - 1 } else { 0 };
                                                                                       ^0
  110|      4|        mst_edges.size() == expected_edges
  111|      4|    }
  112|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap65/PrimStEph.rs:
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 65: Prim's MST Algorithm (Sequential Ephemeral)
    3|       |//!
    4|       |//! Implements Algorithm 65.1: Prim's algorithm for computing Minimum Spanning Trees.
    5|       |//! Uses priority-first search similar to Dijkstra's algorithm.
    6|       |
    7|       |pub mod PrimStEph {
    8|       |
    9|       |    use std::cmp::Ordering;
   10|       |    use std::collections::HashMap;
   11|       |    use std::fmt::{Display, Formatter, Result as FmtResult};
   12|       |    use std::hash::Hash;
   13|       |
   14|       |    use crate::Chap05::SetStEph::SetStEph::*;
   15|       |    use crate::Chap06::LabUnDirGraphStEph::LabUnDirGraphStEph::*;
   16|       |    use crate::Chap45::BinaryHeapPQ::BinaryHeapPQ::*;
   17|       |    use crate::SetLit;
   18|       |    use crate::Types::Types::*;
   19|       |    use ordered_float::OrderedFloat;
   20|       |
   21|       |    pub trait PrimStEphTrait {
   22|       |        /// Prim's MST algorithm
   23|       |        /// APAS: Work O(m log n), Span O(m log n) where m = |E|, n = |V|
   24|       |        fn prim_mst<V: StT + Hash + Ord + Display>(
   25|       |            graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>,
   26|       |            start: V,
   27|       |        ) -> Set<LabEdge<V, OrderedFloat<f64>>>;
   28|       |
   29|       |        /// Compute total weight of MST
   30|       |        /// APAS: Work O(m), Span O(1)
   31|       |        fn mst_weight<V: StT + Hash>(mst: &Set<LabEdge<V, OrderedFloat<f64>>>) -> OrderedFloat<f64>;
   32|       |    }
   33|       |
   34|       |    /// Priority queue entry for Prim's algorithm
   35|       |    #[derive(Clone, Eq, PartialEq, Debug)]
   36|       |    struct PQEntry<V: StT + Hash + Ord> {
   37|       |        priority: OrderedFloat<f64>,
   38|       |        vertex: V,
   39|       |        parent: Option<V>,
   40|       |    }
   41|       |
   42|       |    impl<V: StT + Hash + Ord> PQEntry<V> {
   43|     34|        fn new(priority: OrderedFloat<f64>, vertex: V, parent: Option<V>) -> Self {
   44|     34|            PQEntry {
   45|     34|                priority,
   46|     34|                vertex,
   47|     34|                parent,
   48|     34|            }
   49|     34|        }
   50|       |    }
   51|       |
   52|       |    impl<V: StT + Hash + Ord> Ord for PQEntry<V> {
   53|     29|        fn cmp(&self, other: &Self) -> Ordering { self.priority.cmp(&other.priority) }
   54|       |    }
   55|       |
   56|       |    impl<V: StT + Hash + Ord> PartialOrd for PQEntry<V> {
   57|     29|        fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(self.cmp(other)) }
   58|       |    }
   59|       |
   60|       |    impl<V: StT + Hash + Ord + Display> Display for PQEntry<V> {
   61|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult { write!(f, "({}, {})", self.priority, self.vertex) }
   62|       |    }
   63|       |
   64|       |    /// Algorithm 65.1: Prim's MST Algorithm
   65|       |    ///
   66|       |    /// Computes the Minimum Spanning Tree using priority-first search.
   67|       |    /// Similar to Dijkstra's, but priority is minimum edge weight to visited set X.
   68|       |    ///
   69|       |    /// Priority: p(v) = min_{xX} w(x,v)
   70|       |    ///
   71|       |    /// APAS: Work O(m lg n), Span O(m lg n)
   72|       |    /// claude-4-sonet: Work O(m lg n), Span O(m lg n) [sequential]
   73|       |    ///
   74|       |    /// Arguments:
   75|       |    /// - graph: Weighted undirected graph
   76|       |    /// - start: Starting vertex (arbitrary choice)
   77|       |    ///
   78|       |    /// Returns:
   79|       |    /// - Set of edges forming the MST
   80|      8|    pub fn prim_mst<V: StT + Hash + Ord + Display>(
   81|      8|        graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>,
   82|      8|        start: &V,
   83|      8|    ) -> Set<LabEdge<V, OrderedFloat<f64>>> {
   84|      8|        let mut mst_edges = SetLit![];
   85|      8|        let mut visited: std::collections::HashSet<V> = std::collections::HashSet::new();
   86|       |
   87|       |        // Priority queue
   88|      8|        let mut pq = BinaryHeapPQ::<PQEntry<V>>::singleton(PQEntry::new(OrderedFloat(0.0), start.clone(), None));
   89|       |
   90|     42|        while !pq.is_empty() {
   91|       |            // Extract minimum priority vertex
   92|     34|            let (new_pq, entry_opt) = pq.delete_min();
   93|     34|            pq = new_pq;
   94|       |
   95|     34|            let entry = match entry_opt {
   96|     34|                | Some(e) => e,
   97|      0|                | None => break,
   98|       |            };
   99|       |
  100|     34|            let u = entry.vertex;
  101|     34|            let parent_u = entry.parent;
  102|       |
  103|     34|            if visited.contains(&u) {
  104|      9|                continue;
  105|     25|            }
  106|       |
  107|     25|            let _ = visited.insert(u.clone());
  108|       |
  109|       |            // Add edge to MST (except for start vertex)
  110|     25|            if let Some(parent_v) = parent_u {
                                      ^17
  111|     17|                if let Some(weight) = get_edge_weight(graph, &parent_v, &u) {
  112|     17|                    let edge = if parent_v < u {
  113|     14|                        LabEdge(parent_v, u.clone(), weight)
  114|       |                    } else {
  115|      3|                        LabEdge(u.clone(), parent_v, weight)
  116|       |                    };
  117|     17|                    let _ = mst_edges.insert(edge);
  118|      0|                }
  119|      8|            }
  120|       |
  121|       |            // Update priorities of neighbors
  122|     25|            let neighbors = get_neighbors(graph, &u);
  123|     52|            for v in neighbors.iter() {
                                   ^25       ^25
  124|     52|                if !visited.contains(v) {
  125|     26|                    if let Some(weight) = get_edge_weight(graph, &u, v) {
  126|     26|                        pq = pq.insert(PQEntry::new(weight, v.clone(), Some(u.clone())));
  127|     26|                    }
                                  ^0
  128|     26|                }
  129|       |            }
  130|       |        }
  131|       |
  132|      8|        mst_edges
  133|      8|    }
  134|       |
  135|       |    /// Helper: Get neighbors of a vertex
  136|     25|    fn get_neighbors<V: StT + Hash + Ord>(graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>, v: &V) -> Set<V> {
  137|     25|        let mut neighbors = SetLit![];
  138|     92|        for edge in graph.labeled_edges().iter() {
                                  ^25                   ^25
  139|     92|            let LabEdge(a, b, _) = edge;
  140|     92|            if a == v {
  141|     26|                let _ = neighbors.insert(b.clone());
  142|     66|            } else if b == v {
  143|     26|                let _ = neighbors.insert(a.clone());
  144|     40|            }
  145|       |        }
  146|     25|        neighbors
  147|     25|    }
  148|       |
  149|       |    /// Helper: Get edge weight between two vertices
  150|     43|    fn get_edge_weight<V: StT + Hash + Ord>(
  151|     43|        graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>,
  152|     43|        u: &V,
  153|     43|        v: &V,
  154|     43|    ) -> Option<OrderedFloat<f64>> {
  155|    109|        for edge in graph.labeled_edges().iter() {
                                  ^43                   ^43
  156|    109|            let LabEdge(a, b, w) = edge;
  157|    109|            if (a == u && b == v) || (a == v && b == u) {
                                        ^57         ^73       ^18
  158|     43|                return Some(*w);
  159|     66|            }
  160|       |        }
  161|      0|        None
  162|     43|    }
  163|       |
  164|       |    /// Compute total MST weight
  165|       |    ///
  166|       |    /// APAS: Work O(|MST|), Span O(|MST|)
  167|       |    /// claude-4-sonet: Work O(|MST|), Span O(|MST|)
  168|      9|    pub fn mst_weight<V: StT + Hash>(mst_edges: &Set<LabEdge<V, OrderedFloat<f64>>>) -> OrderedFloat<f64> {
  169|      9|        let mut total = OrderedFloat(0.0);
  170|     19|        for edge in mst_edges.iter() {
                                  ^9        ^9
  171|     19|            let LabEdge(_u, _v, w) = edge;
  172|     19|            total += *w;
  173|     19|        }
  174|      9|        total
  175|      9|    }
  176|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap65/UnionFindStEph.rs:
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 65: Union-Find Data Structure (Sequential Ephemeral)
    3|       |//!
    4|       |//! Implements Union-Find (Disjoint Set Union) with path compression and union by rank.
    5|       |//! Used in Kruskal's MST algorithm for efficient cycle detection.
    6|       |
    7|       |pub mod UnionFindStEph {
    8|       |
    9|       |    use std::collections::HashMap;
   10|       |    use std::hash::Hash;
   11|       |
   12|       |    use crate::Types::Types::*;
   13|       |
   14|       |    pub trait UnionFindStEphTrait<V: StT + Hash> {
   15|       |        /// Create a new empty Union-Find structure
   16|       |        /// APAS: Work (1), Span (1)
   17|       |        fn new() -> Self;
   18|       |
   19|       |        /// Insert a new element into the Union-Find structure
   20|       |        /// APAS: Work (1), Span (1)
   21|       |        fn insert(&mut self, v: V);
   22|       |
   23|       |        /// Find the representative (root) of the set containing v with path compression
   24|       |        /// APAS: Work O((n)), Span O((n)) amortized (inverse Ackermann)
   25|       |        fn find(&mut self, v: &V) -> V;
   26|       |
   27|       |        /// Union two sets containing u and v using union by rank
   28|       |        /// APAS: Work O((n)), Span O((n)) amortized
   29|       |        fn union(&mut self, u: &V, v: &V);
   30|       |
   31|       |        /// Check if two elements are in the same set
   32|       |        /// APAS: Work O((n)), Span O((n)) amortized
   33|       |        fn equals(&mut self, u: &V, v: &V) -> B;
   34|       |
   35|       |        /// Get the number of distinct sets
   36|       |        /// APAS: Work O(n (n)), Span O(n (n))
   37|       |        fn num_sets(&mut self) -> usize;
   38|       |    }
   39|       |
   40|       |    pub struct UnionFind<V: StT + Hash> {
   41|       |        parent: HashMap<V, V>,
   42|       |        rank: HashMap<V, usize>,
   43|       |    }
   44|       |
   45|       |    impl<V: StT + Hash> UnionFind<V> {
   46|       |        /// Create a new empty Union-Find structure
   47|       |        ///
   48|       |        /// APAS: Work (1), Span (1)
   49|       |        /// claude-4-sonet: Work (1), Span (1)
   50|     21|        pub fn new() -> Self {
   51|     21|            UnionFind {
   52|     21|                parent: HashMap::new(),
   53|     21|                rank: HashMap::new(),
   54|     21|            }
   55|     21|        }
   56|       |
   57|       |        /// Insert a new element into the Union-Find structure
   58|       |        ///
   59|       |        /// Initially, each element is in its own set (parent is itself).
   60|       |        ///
   61|       |        /// APAS: Work (1), Span (1)
   62|       |        /// claude-4-sonet: Work (1), Span (1)
   63|       |        ///
   64|       |        /// Arguments:
   65|       |        /// - v: The element to insert
   66|    169|        pub fn insert(&mut self, v: V) {
   67|    169|            if !self.parent.contains_key(&v) {
   68|    168|                let _ = self.parent.insert(v.clone(), v.clone());
   69|    168|                let _ = self.rank.insert(v, 0);
   70|    168|            }
                          ^1
   71|    169|        }
   72|       |
   73|       |        /// Find the representative (root) of the set containing v
   74|       |        ///
   75|       |        /// Uses path compression: makes all nodes on path point directly to root.
   76|       |        ///
   77|       |        /// APAS: Work O((n)), Span O((n)) amortized (inverse Ackermann)
   78|       |        /// claude-4-sonet: Work O((n)), Span O((n)) amortized
   79|       |        ///
   80|       |        /// Arguments:
   81|       |        /// - v: The element to find
   82|       |        ///
   83|       |        /// Returns:
   84|       |        /// - The representative of v's set
   85|  1.17k|        pub fn find(&mut self, v: &V) -> V {
   86|  1.17k|            let parent_v = self.parent.get(v).unwrap().clone();
   87|       |
   88|  1.17k|            if parent_v == *v {
   89|       |                // v is the root
   90|    823|                v.clone()
   91|       |            } else {
   92|       |                // Recursively find root and compress path
   93|    348|                let root = self.find(&parent_v);
   94|    348|                let _ = self.parent.insert(v.clone(), root.clone());
   95|    348|                root
   96|       |            }
   97|  1.17k|        }
   98|       |
   99|       |        /// Union two sets containing u and v
  100|       |        ///
  101|       |        /// Uses union by rank: attaches smaller tree under larger tree.
  102|       |        /// Only updates rank if trees have same rank.
  103|       |        ///
  104|       |        /// APAS: Work O((n)), Span O((n)) amortized
  105|       |        /// claude-4-sonet: Work O((n)), Span O((n)) amortized
  106|       |        ///
  107|       |        /// Arguments:
  108|       |        /// - u: Element in first set
  109|       |        /// - v: Element in second set
  110|    144|        pub fn union(&mut self, u: &V, v: &V) {
  111|    144|            let root_u = self.find(u);
  112|    144|            let root_v = self.find(v);
  113|       |
  114|    144|            if root_u == root_v {
  115|      1|                return; // Already in same set
  116|    143|            }
  117|       |
  118|    143|            let rank_u = *self.rank.get(&root_u).unwrap_or(&0);
  119|    143|            let rank_v = *self.rank.get(&root_v).unwrap_or(&0);
  120|       |
  121|    143|            if rank_u < rank_v {
  122|      0|                // Attach u's tree under v's tree
  123|      0|                let _ = self.parent.insert(root_u, root_v);
  124|    143|            } else if rank_u > rank_v {
  125|    121|                // Attach v's tree under u's tree
  126|    121|                let _ = self.parent.insert(root_v, root_u);
  127|    121|            } else {
  128|     22|                // Same rank: attach v under u and increase u's rank
  129|     22|                let _ = self.parent.insert(root_v, root_u.clone());
  130|     22|                let _ = self.rank.insert(root_u, rank_u + 1);
  131|     22|            }
  132|    144|        }
  133|       |
  134|       |        /// Check if two elements are in the same set
  135|       |        ///
  136|       |        /// APAS: Work O((n)), Span O((n)) amortized
  137|       |        /// claude-4-sonet: Work O((n)), Span O((n)) amortized
  138|       |        ///
  139|       |        /// Arguments:
  140|       |        /// - u: First element
  141|       |        /// - v: Second element
  142|       |        ///
  143|       |        /// Returns:
  144|       |        /// - true if u and v are in the same set
  145|    138|        pub fn equals(&mut self, u: &V, v: &V) -> B { self.find(u) == self.find(v) }
  146|       |
  147|       |        /// Get the number of distinct sets
  148|       |        ///
  149|       |        /// APAS: Work O(n (n)), Span O(n (n))
  150|       |        /// claude-4-sonet: Work O(n (n)), Span O(n (n))
  151|       |        ///
  152|       |        /// Returns:
  153|       |        /// - Number of distinct sets
  154|     17|        pub fn num_sets(&mut self) -> usize {
  155|     17|            let mut roots = std::collections::HashSet::new();
  156|     17|            let keys: Vec<V> = self.parent.keys().cloned().collect();
  157|    255|            for v in keys.iter() {
                                   ^17  ^17
  158|    255|                let root = self.find(v);
  159|    255|                let _ = roots.insert(root);
  160|    255|            }
  161|     17|            roots.len()
  162|     17|        }
  163|       |    }
  164|       |
  165|       |    impl<V: StT + Hash> UnionFindStEphTrait<V> for UnionFind<V> {
  166|      0|        fn new() -> Self {
  167|      0|            UnionFind {
  168|      0|                parent: HashMap::new(),
  169|      0|                rank: HashMap::new(),
  170|      0|            }
  171|      0|        }
  172|       |
  173|      0|        fn insert(&mut self, v: V) {
  174|      0|            if !self.parent.contains_key(&v) {
  175|      0|                let _ = self.parent.insert(v.clone(), v.clone());
  176|      0|                let _ = self.rank.insert(v, 0);
  177|      0|            }
  178|      0|        }
  179|       |
  180|      0|        fn find(&mut self, v: &V) -> V {
  181|      0|            let parent_v = self.parent.get(v).unwrap().clone();
  182|       |
  183|      0|            if parent_v == *v {
  184|      0|                v.clone()
  185|       |            } else {
  186|      0|                let root = self.find(&parent_v);
  187|      0|                let _ = self.parent.insert(v.clone(), root.clone());
  188|      0|                root
  189|       |            }
  190|      0|        }
  191|       |
  192|      0|        fn union(&mut self, u: &V, v: &V) {
  193|      0|            let root_u = self.find(u);
  194|      0|            let root_v = self.find(v);
  195|       |
  196|      0|            if root_u == root_v {
  197|      0|                return;
  198|      0|            }
  199|       |
  200|      0|            let rank_u = *self.rank.get(&root_u).unwrap_or(&0);
  201|      0|            let rank_v = *self.rank.get(&root_v).unwrap_or(&0);
  202|       |
  203|      0|            if rank_u < rank_v {
  204|      0|                let _ = self.parent.insert(root_u, root_v);
  205|      0|            } else if rank_u > rank_v {
  206|      0|                let _ = self.parent.insert(root_v, root_u);
  207|      0|            } else {
  208|      0|                let _ = self.parent.insert(root_v, root_u.clone());
  209|      0|                let _ = self.rank.insert(root_u, rank_u + 1);
  210|      0|            }
  211|      0|        }
  212|       |
  213|      0|        fn equals(&mut self, u: &V, v: &V) -> B { self.find(u) == self.find(v) }
  214|       |
  215|      0|        fn num_sets(&mut self) -> usize {
  216|      0|            let mut roots = std::collections::HashSet::new();
  217|      0|            let keys: Vec<V> = self.parent.keys().cloned().collect();
  218|      0|            for v in keys.iter() {
  219|      0|                let root = self.find(v);
  220|      0|                let _ = roots.insert(root);
  221|      0|            }
  222|      0|            roots.len()
  223|      0|        }
  224|       |    }
  225|       |
  226|       |    impl<V: StT + Hash> Default for UnionFind<V> {
  227|      0|        fn default() -> Self { Self::new() }
  228|       |    }
  229|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap66/BoruvkaMtEph.rs:
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 66: Borvka's MST Algorithm (Parallel Ephemeral)
    3|       |//!
    4|       |//! Implements parallel versions of Algorithm 66.2 and 66.3 using ParaPair! macro.
    5|       |//! Achieves Work O(m log n), Span O(log n).
    6|       |
    7|       |pub mod BoruvkaMtEph {
    8|       |
    9|       |    use std::collections::HashMap;
   10|       |    use std::hash::Hash;
   11|       |    use std::sync::Arc;
   12|       |
   13|       |    use crate::Chap05::SetStEph::SetStEph::*;
   14|       |    use crate::ParaPair;
   15|       |    use crate::SetLit;
   16|       |    use crate::Types::Types::*;
   17|       |    use ordered_float::OrderedFloat;
   18|       |    use rand::rngs::StdRng;
   19|       |    use rand::*;
   20|       |
   21|       |    pub trait BoruvkaMtEphTrait {
   22|       |        /// Find vertex bridges for parallel Borvka's algorithm
   23|       |        /// APAS: Work O(|E|), Span O(lg |E|)
   24|       |        fn vertex_bridges_mt<V: StT + Hash + Ord + Send + Sync + 'static>(
   25|       |            edges: &Set<LabeledEdge<V>>,
   26|       |        ) -> Set<(V, LabeledEdge<V>)>;
   27|       |
   28|       |        /// Parallel bridge-based star partition
   29|       |        /// APAS: Work O(|V| + |E|), Span O(lg |V|)
   30|       |        fn bridge_star_partition_mt<V: StT + Hash + Ord + Send + Sync + 'static>(
   31|       |            vertices: &Set<V>,
   32|       |            bridges: &Set<(V, LabeledEdge<V>)>,
   33|       |        ) -> Set<Set<V>>;
   34|       |
   35|       |        /// Parallel Borvka's MST algorithm
   36|       |        /// APAS: Work O(m log n), Span O(log n)
   37|       |        fn boruvka_mst_mt<V: StT + Hash + Ord + Send + Sync + 'static>(
   38|       |            edges: &Set<LabeledEdge<V>>,
   39|       |        ) -> Set<LabeledEdge<V>>;
   40|       |
   41|       |        /// Parallel Borvka's MST with random seed
   42|       |        /// APAS: Work O(m log n), Span O(log n)
   43|       |        fn boruvka_mst_mt_with_seed<V: StT + Hash + Ord + Send + Sync + 'static>(
   44|       |            edges: &Set<LabeledEdge<V>>,
   45|       |            seed: u64,
   46|       |        ) -> Set<LabeledEdge<V>>;
   47|       |
   48|       |        /// Compute total weight of MST
   49|       |        /// APAS: Work O(m), Span O(1)
   50|       |        fn mst_weight<V: StT + Hash>(mst: &Set<LabeledEdge<V>>) -> OrderedFloat<f64>;
   51|       |    }
   52|       |
   53|       |    /// Edge with label: (u, v, weight, label)
   54|       |    pub type LabeledEdge<V> = (V, V, OrderedFloat<f64>, usize);
   55|       |
   56|       |    /// Parallel vertex bridges using divide-and-conquer reduce
   57|       |    ///
   58|       |    /// For each vertex, find the minimum weight edge incident on it.
   59|       |    /// Uses parallel reduce over edges.
   60|       |    ///
   61|       |    /// APAS: Work O(m), Span O(log m)
   62|       |    /// claude-4-sonet: Work O(m), Span O(log m) [parallel reduce with ParaPair!]
   63|       |    ///
   64|       |    /// Arguments:
   65|       |    /// - edges: Arc-wrapped vector of labeled edges
   66|       |    /// - start: Start index in edges
   67|       |    /// - end: End index in edges
   68|       |    ///
   69|       |    /// Returns:
   70|       |    /// - HashMap mapping vertex  (neighbor, weight, label) for minimum edge
   71|    165|    pub fn vertex_bridges_mt<V: StT + Hash + Ord + Send + Sync + 'static>(
   72|    165|        edges: Arc<Vec<LabeledEdge<V>>>,
   73|    165|        start: usize,
   74|    165|        end: usize,
   75|    165|    ) -> HashMap<V, (V, OrderedFloat<f64>, usize)> {
   76|    165|        let size = end - start;
   77|    165|        if size == 0 {
   78|      0|            return HashMap::new();
   79|    165|        }
   80|       |
   81|    165|        if size == 1 {
   82|       |            // Base case: single edge contributes bridges for both endpoints
   83|     96|            let (u, v, w, label) = edges[start].clone();
   84|     96|            let mut result = HashMap::new();
   85|     96|            let _ = result.insert(u.clone(), (v.clone(), w, label));
   86|     96|            let _ = result.insert(v.clone(), (u.clone(), w, label));
   87|     96|            return result;
   88|     69|        }
   89|       |
   90|       |        // Divide and conquer
   91|     69|        let mid = start + size / 2;
   92|     69|        let edges1 = edges.clone();
   93|     69|        let edges2 = edges;
   94|       |
   95|     69|        let pair = ParaPair!(
   96|     69|            move || vertex_bridges_mt(edges1, start, mid),
   97|     69|            move || vertex_bridges_mt(edges2, mid, end)
   98|       |        );
   99|       |
  100|       |        // Merge: for each vertex, keep the minimum weight edge
  101|     69|        let mut merged = pair.0;
  102|     69|        let right_bridges = pair.1;
  103|    258|        for (v, (neighbor, w, label)) in right_bridges {
                           ^189^189      ^189^189
  104|    189|            match merged.get(&v) {
  105|     88|                | None => {
  106|     88|                    let _ = merged.insert(v, (neighbor, w, label));
  107|     88|                }
  108|    101|                | Some((_, existing_w, _)) => {
  109|    101|                    if w < *existing_w {
  110|     62|                        let _ = merged.insert(v, (neighbor, w, label));
  111|     62|                    }
                                  ^39
  112|       |                }
  113|       |            }
  114|       |        }
  115|       |
  116|     69|        merged
  117|    165|    }
  118|       |
  119|       |    /// Parallel bridge star partition
  120|       |    ///
  121|       |    /// Performs star contraction along vertex bridges using randomized coin flips.
  122|       |    /// Parallelizes coin flips and edge filtering.
  123|       |    ///
  124|       |    /// APAS: Work O(n + m), Span O(log n)
  125|       |    /// claude-4-sonet: Work O(n + m), Span O(log n) [parallel iteration with ParaPair!]
  126|       |    ///
  127|       |    /// Arguments:
  128|       |    /// - vertices_vec: Vector of vertices (for parallel iteration)
  129|       |    /// - bridges: Vertex bridges (from vertex_bridges_mt)
  130|       |    /// - rng: Random number generator for coin flips
  131|       |    ///
  132|       |    /// Returns:
  133|       |    /// - (remaining_vertices, partition_map) where partition_map: tail  (head, weight, label)
  134|     27|    pub fn bridge_star_partition_mt<V: StT + Hash + Ord + Send + Sync + 'static>(
  135|     27|        vertices_vec: Vec<V>,
  136|     27|        bridges: HashMap<V, (V, OrderedFloat<f64>, usize)>,
  137|     27|        rng: &mut StdRng,
  138|     27|    ) -> (Set<V>, HashMap<V, (V, OrderedFloat<f64>, usize)>) {
  139|       |        // Coin flips (sequential for consistent seed)
  140|     27|        let mut coin_flips: HashMap<V, bool> = HashMap::new();
  141|     91|        for vertex in vertices_vec.iter() {
                                    ^27          ^27
  142|     91|            let _ = coin_flips.insert(vertex.clone(), rng.random::<bool>());
  143|     91|        }
  144|       |
  145|       |        // Parallel edge filtering: select edges from TailHead
  146|     27|        let vertices_len = vertices_vec.len();
  147|     27|        let vertices_arc = Arc::new(vertices_vec);
  148|     27|        let bridges_arc = Arc::new(bridges);
  149|     27|        let flips_arc = Arc::new(coin_flips);
  150|     27|        let partition = filter_tail_to_head_mt(vertices_arc.clone(), bridges_arc, flips_arc, 0, vertices_len);
  151|       |
  152|       |        // Compute remaining vertices (not contracted)
  153|     27|        let mut remaining = SetLit![];
  154|     91|        for v in vertices_arc.iter() {
                               ^27          ^27
  155|     91|            if !partition.contains_key(v) {
  156|     63|                let _ = remaining.insert(v.clone());
  157|     63|            }
                          ^28
  158|       |        }
  159|       |
  160|     27|        (remaining, partition)
  161|     27|    }
  162|       |
  163|       |    /// Parallel filter: find edges from TailHead
  164|    155|    fn filter_tail_to_head_mt<V: StT + Hash + Ord + Send + Sync + 'static>(
  165|    155|        vertices: Arc<Vec<V>>,
  166|    155|        bridges: Arc<HashMap<V, (V, OrderedFloat<f64>, usize)>>,
  167|    155|        coin_flips: Arc<HashMap<V, bool>>,
  168|    155|        start: usize,
  169|    155|        end: usize,
  170|    155|    ) -> HashMap<V, (V, OrderedFloat<f64>, usize)> {
  171|    155|        let size = end - start;
  172|    155|        if size == 0 {
  173|      0|            return HashMap::new();
  174|    155|        }
  175|       |
  176|    155|        if size == 1 {
  177|       |            // Base case: check single vertex
  178|     91|            let u = &vertices[start];
  179|     91|            if let Some((v, w, label)) = bridges.get(u) {
  180|     91|                let u_heads = coin_flips.get(u).copied().unwrap_or(false);
  181|     91|                let v_heads = coin_flips.get(v).copied().unwrap_or(false);
  182|       |
  183|     91|                if !u_heads && v_heads {
                                             ^39
  184|     28|                    let mut result = HashMap::new();
  185|     28|                    let _ = result.insert(u.clone(), (v.clone(), *w, *label));
  186|     28|                    return result;
  187|     63|                }
  188|      0|            }
  189|     63|            return HashMap::new();
  190|     64|        }
  191|       |
  192|       |        // Divide and conquer
  193|     64|        let mid = start + size / 2;
  194|     64|        let verts1 = vertices.clone();
  195|     64|        let bridges1 = bridges.clone();
  196|     64|        let flips1 = coin_flips.clone();
  197|     64|        let verts2 = vertices;
  198|     64|        let bridges2 = bridges;
  199|     64|        let flips2 = coin_flips;
  200|       |
  201|     64|        let pair = ParaPair!(
  202|     64|            move || filter_tail_to_head_mt(verts1, bridges1, flips1, start, mid),
  203|     64|            move || filter_tail_to_head_mt(verts2, bridges2, flips2, mid, end)
  204|       |        );
  205|       |
  206|       |        // Merge
  207|     64|        let mut merged = pair.0;
  208|     64|        merged.extend(pair.1);
  209|     64|        merged
  210|    155|    }
  211|       |
  212|       |    /// Parallel Borvka's MST
  213|       |    ///
  214|       |    /// Computes the Minimum Spanning Tree using recursive bridge-based contraction.
  215|       |    /// Parallelizes vertex bridge computation and edge routing.
  216|       |    ///
  217|       |    /// APAS: Work O(m log n), Span O(log n)
  218|       |    /// claude-4-sonet: Work O(m log n), Span O(log n) [O(log n) rounds  O(log n) span per round]
  219|       |    ///
  220|       |    /// Arguments:
  221|       |    /// - vertices_vec: Vector of vertices
  222|       |    /// - edges_vec: Vector of labeled edges
  223|       |    /// - mst_labels: Accumulated MST edge labels
  224|       |    /// - rng: Random number generator
  225|       |    ///
  226|       |    /// Returns:
  227|       |    /// - Set of edge labels in the MST
  228|     36|    pub fn boruvka_mst_mt<V: StT + Hash + Ord + Send + Sync + 'static>(
  229|     36|        vertices_vec: Vec<V>,
  230|     36|        edges_vec: Vec<LabeledEdge<V>>,
  231|     36|        mst_labels: Set<usize>,
  232|     36|        rng: &mut StdRng,
  233|     36|    ) -> Set<usize> {
  234|       |        // Base case: no edges remaining
  235|     36|        if edges_vec.is_empty() {
  236|      9|            return mst_labels;
  237|     27|        }
  238|       |
  239|       |        // Find vertex bridges (parallel)
  240|     27|        let edges_len = edges_vec.len();
  241|     27|        let edges_arc = Arc::new(edges_vec);
  242|     27|        let bridges = vertex_bridges_mt(edges_arc.clone(), 0, edges_len);
  243|       |
  244|       |        // Perform bridge star partition
  245|     27|        let (remaining_vertices, partition) = bridge_star_partition_mt(vertices_vec, bridges, rng);
  246|       |
  247|       |        // Collect new MST labels from partition
  248|     27|        let mut new_mst_labels = mst_labels.clone();
  249|     28|        for (_, (_, _, label)) in partition.iter() {
                                                ^27       ^27
  250|     28|            let _ = new_mst_labels.insert(*label);
  251|     28|        }
  252|       |
  253|       |        // Build full partition map (including identity for non-contracted vertices)
  254|     27|        let mut full_partition: HashMap<V, V> = HashMap::new();
  255|     28|        for (tail, (head, _, _)) in partition.iter() {
                                                  ^27       ^27
  256|     28|            let _ = full_partition.insert(tail.clone(), head.clone());
  257|     28|        }
  258|     63|        for v in remaining_vertices.iter() {
                               ^27                ^27
  259|     63|            let _ = full_partition.insert(v.clone(), v.clone());
  260|     63|        }
  261|       |
  262|       |        // Parallel edge re-routing
  263|     27|        let part_arc = Arc::new(full_partition);
  264|     27|        let new_edges = reroute_edges_mt(edges_arc, part_arc, 0, edges_len);
  265|       |
  266|       |        // Recurse
  267|     27|        let remaining_vec: Vec<V> = remaining_vertices.iter().cloned().collect();
  268|     27|        boruvka_mst_mt(remaining_vec, new_edges, new_mst_labels, rng)
  269|     36|    }
  270|       |
  271|       |    /// Parallel edge re-routing: map edges to new endpoints and remove self-edges
  272|    165|    fn reroute_edges_mt<V: StT + Hash + Ord + Send + Sync + 'static>(
  273|    165|        edges: Arc<Vec<LabeledEdge<V>>>,
  274|    165|        partition: Arc<HashMap<V, V>>,
  275|    165|        start: usize,
  276|    165|        end: usize,
  277|    165|    ) -> Vec<LabeledEdge<V>> {
  278|    165|        let size = end - start;
  279|    165|        if size == 0 {
  280|      0|            return Vec::new();
  281|    165|        }
  282|       |
  283|    165|        if size == 1 {
  284|     96|            let (u, v, w, label) = &edges[start];
  285|     96|            let new_u = partition.get(u).cloned().unwrap_or_else(|| u.clone());
                                                                                  ^0^0
  286|     96|            let new_v = partition.get(v).cloned().unwrap_or_else(|| v.clone());
                                                                                  ^0^0
  287|       |
  288|     96|            if new_u != new_v {
  289|     59|                return vec![(new_u, new_v, *w, *label)];
  290|     37|            }
  291|     37|            return Vec::new();
  292|     69|        }
  293|       |
  294|       |        // Divide and conquer
  295|     69|        let mid = start + size / 2;
  296|     69|        let edges1 = edges.clone();
  297|     69|        let part1 = partition.clone();
  298|     69|        let edges2 = edges;
  299|     69|        let part2 = partition;
  300|       |
  301|     69|        let pair = ParaPair!(move || reroute_edges_mt(edges1, part1, start, mid), move || {
  302|     69|            reroute_edges_mt(edges2, part2, mid, end)
  303|     69|        });
  304|       |
  305|       |        // Merge
  306|     69|        let mut left_result = pair.0;
  307|     69|        let mut right_result = pair.1;
  308|     69|        left_result.append(&mut right_result);
  309|     69|        left_result
  310|    165|    }
  311|       |
  312|       |    /// Helper: Create Borvka MST with a specific seed
  313|       |    ///
  314|       |    /// APAS: Work O(m log n), Span O(log n)
  315|       |    /// claude-4-sonet: Work O(m log n), Span O(log n)
  316|       |    ///
  317|       |    /// Arguments:
  318|       |    /// - vertices: Set of vertices
  319|       |    /// - edges: Set of labeled edges
  320|       |    /// - seed: Random seed for reproducibility
  321|       |    ///
  322|       |    /// Returns:
  323|       |    /// - Set of edge labels in the MST
  324|      9|    pub fn boruvka_mst_mt_with_seed<V: StT + Hash + Ord + Send + Sync + 'static>(
  325|      9|        vertices: &Set<V>,
  326|      9|        edges: &Set<LabeledEdge<V>>,
  327|      9|        seed: u64,
  328|      9|    ) -> Set<usize> {
  329|      9|        let mut rng = StdRng::seed_from_u64(seed);
  330|      9|        let vertices_vec: Vec<V> = vertices.iter().cloned().collect();
  331|      9|        let edges_vec: Vec<LabeledEdge<V>> = edges.iter().cloned().collect();
  332|      9|        boruvka_mst_mt(vertices_vec, edges_vec, SetLit![], &mut rng)
  333|      9|    }
  334|       |
  335|       |    /// Compute MST weight from edge labels
  336|       |    ///
  337|       |    /// APAS: Work O(m), Span O(m)
  338|       |    /// claude-4-sonet: Work O(m), Span O(m)
  339|      8|    pub fn mst_weight<V: StT + Hash>(edges: &Set<LabeledEdge<V>>, mst_labels: &Set<usize>) -> OrderedFloat<f64> {
  340|      8|        let mut total = OrderedFloat(0.0);
  341|     37|        for (_, _, w, label) in edges.iter() {
                                              ^8    ^8
  342|     37|            if mst_labels.mem(label) {
  343|     28|                total += *w;
  344|     28|            }
                          ^9
  345|       |        }
  346|      8|        total
  347|      8|    }
  348|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Chap66/BoruvkaStEph.rs:
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Chapter 66: Borvka's MST Algorithm (Sequential Ephemeral)
    3|       |//!
    4|       |//! Implements Algorithm 66.2 and 66.3: Borvka's algorithm for computing Minimum Spanning Trees
    5|       |//! using vertex bridges and graph contraction with randomized star contraction.
    6|       |
    7|       |pub mod BoruvkaStEph {
    8|       |
    9|       |    use std::collections::HashMap;
   10|       |    use std::hash::Hash;
   11|       |
   12|       |    use crate::Chap05::SetStEph::SetStEph::*;
   13|       |    use crate::SetLit;
   14|       |    use crate::Types::Types::*;
   15|       |    use ordered_float::OrderedFloat;
   16|       |    use rand::rngs::StdRng;
   17|       |    use rand::*;
   18|       |
   19|       |    pub trait BoruvkaStEphTrait {
   20|       |        /// Find vertex bridges for Borvka's algorithm
   21|       |        /// APAS: Work O(|E|), Span O(|E|)
   22|       |        fn vertex_bridges<V: StT + Hash + Ord>(edges: &Set<LabeledEdge<V>>) -> Set<(V, LabeledEdge<V>)>;
   23|       |
   24|       |        /// Bridge-based star partition
   25|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   26|       |        fn bridge_star_partition<V: StT + Hash + Ord>(
   27|       |            vertices: &Set<V>,
   28|       |            bridges: &Set<(V, LabeledEdge<V>)>,
   29|       |        ) -> Set<Set<V>>;
   30|       |
   31|       |        /// Borvka's MST algorithm
   32|       |        /// APAS: Work O(m log n), Span O(m log n)
   33|       |        fn boruvka_mst<V: StT + Hash + Ord>(edges: &Set<LabeledEdge<V>>) -> Set<LabeledEdge<V>>;
   34|       |
   35|       |        /// Borvka's MST with random seed
   36|       |        /// APAS: Work O(m log n), Span O(m log n)
   37|       |        fn boruvka_mst_with_seed<V: StT + Hash + Ord>(edges: &Set<LabeledEdge<V>>, seed: u64) -> Set<LabeledEdge<V>>;
   38|       |
   39|       |        /// Compute total weight of MST
   40|       |        /// APAS: Work O(m), Span O(1)
   41|       |        fn mst_weight<V: StT + Hash>(mst: &Set<LabeledEdge<V>>) -> OrderedFloat<f64>;
   42|       |    }
   43|       |
   44|       |    /// Edge with label: (u, v, weight, label)
   45|       |    /// Vertices u,v change during contraction, but weight and label are immutable
   46|       |    pub type LabeledEdge<V> = (V, V, OrderedFloat<f64>, usize);
   47|       |
   48|       |    /// Algorithm 66.3: Find vertex bridges
   49|       |    ///
   50|       |    /// For each vertex, find the minimum weight edge incident on it.
   51|       |    /// Returns a table mapping each vertex to (neighbor, weight, label).
   52|       |    ///
   53|       |    /// APAS: Work O(m), Span O(m)
   54|       |    /// claude-4-sonet: Work O(m), Span O(m) [sequential iteration]
   55|       |    ///
   56|       |    /// Arguments:
   57|       |    /// - edges: Set of labeled edges
   58|       |    ///
   59|       |    /// Returns:
   60|       |    /// - HashMap mapping vertex  (neighbor, weight, label) for minimum edge
   61|     24|    pub fn vertex_bridges<V: StT + Hash + Ord>(
   62|     24|        edges: &Set<LabeledEdge<V>>,
   63|     24|    ) -> HashMap<V, (V, OrderedFloat<f64>, usize)> {
   64|     24|        let mut bridges: HashMap<V, (V, OrderedFloat<f64>, usize)> = HashMap::new();
   65|       |
   66|     77|        for edge in edges.iter() {
                                  ^24   ^24
   67|     77|            let (u, v, w, label) = edge.clone();
   68|       |
   69|       |            // Update bridge for u
   70|     77|            match bridges.get(&u) {
   71|     33|                | None => {
   72|     33|                    let _ = bridges.insert(u.clone(), (v.clone(), w, label));
   73|     33|                }
   74|     44|                | Some((_, existing_w, _)) => {
   75|     44|                    if w < *existing_w {
   76|      9|                        let _ = bridges.insert(u.clone(), (v.clone(), w, label));
   77|     35|                    }
   78|       |                }
   79|       |            }
   80|       |
   81|       |            // Update bridge for v
   82|     77|            match bridges.get(&v) {
   83|     43|                | None => {
   84|     43|                    let _ = bridges.insert(v.clone(), (u.clone(), w, label));
   85|     43|                }
   86|     34|                | Some((_, existing_w, _)) => {
   87|     34|                    if w < *existing_w {
   88|     20|                        let _ = bridges.insert(v.clone(), (u.clone(), w, label));
   89|     20|                    }
                                  ^14
   90|       |                }
   91|       |            }
   92|       |        }
   93|       |
   94|     24|        bridges
   95|     24|    }
   96|       |
   97|       |    /// Algorithm 66.2: Bridge star partition
   98|       |    ///
   99|       |    /// Performs star contraction along vertex bridges using randomized coin flips.
  100|       |    /// Each vertex flips a coin (Heads/Tails). Edges from TailHead are contracted.
  101|       |    ///
  102|       |    /// APAS: Work O(n), Span O(n)
  103|       |    /// claude-4-sonet: Work O(n), Span O(n) [sequential]
  104|       |    ///
  105|       |    /// Arguments:
  106|       |    /// - vertices: Set of vertices
  107|       |    /// - bridges: Vertex bridges (from vertex_bridges)
  108|       |    /// - rng: Random number generator for coin flips
  109|       |    ///
  110|       |    /// Returns:
  111|       |    /// - (remaining_vertices, partition_map) where partition_map: tail  (head, weight, label)
  112|     24|    pub fn bridge_star_partition<V: StT + Hash + Ord>(
  113|     24|        vertices: &Set<V>,
  114|     24|        bridges: &HashMap<V, (V, OrderedFloat<f64>, usize)>,
  115|     24|        rng: &mut StdRng,
  116|     24|    ) -> (Set<V>, HashMap<V, (V, OrderedFloat<f64>, usize)>) {
  117|       |        // Coin flips for all vertices
  118|     24|        let mut flips: HashMap<V, bool> = HashMap::new();
  119|     76|        for v in vertices.iter() {
                               ^24      ^24
  120|     76|            let is_heads = rng.random::<bool>();
  121|     76|            let _ = flips.insert(v.clone(), is_heads);
  122|     76|        }
  123|       |
  124|       |        // Select edges from TailHead (Tail=false, Head=true)
  125|     24|        let mut partition: HashMap<V, (V, OrderedFloat<f64>, usize)> = HashMap::new();
  126|     76|        for (u, (v, w, label)) in bridges.iter() {
                                                ^24     ^24
  127|     76|            let u_heads = flips.get(u).copied().unwrap_or(false);
  128|     76|            let v_heads = flips.get(v).copied().unwrap_or(false);
  129|       |
  130|       |            // Contract if u is Tail and v is Head
  131|     76|            if !u_heads && v_heads {
                                         ^33
  132|     21|                let _ = partition.insert(u.clone(), (v.clone(), *w, *label));
  133|     55|            }
  134|       |        }
  135|       |
  136|       |        // Remaining vertices = all vertices minus contracted tails
  137|     24|        let mut remaining = SetLit![];
  138|     76|        for v in vertices.iter() {
                               ^24      ^24
  139|     76|            if !partition.contains_key(v) {
  140|     55|                let _ = remaining.insert(v.clone());
  141|     55|            }
                          ^21
  142|       |        }
  143|       |
  144|     24|        (remaining, partition)
  145|     24|    }
  146|       |
  147|       |    /// Algorithm 66.3: Borvka's MST
  148|       |    ///
  149|       |    /// Computes the Minimum Spanning Tree using recursive bridge-based contraction.
  150|       |    /// Returns the set of edge labels in the MST.
  151|       |    ///
  152|       |    /// APAS: Work O(m log n), Span O(m log n)
  153|       |    /// claude-4-sonet: Work O(m log n), Span O(m log n) [sequential, expected O(log n) rounds]
  154|       |    ///
  155|       |    /// Arguments:
  156|       |    /// - vertices: Set of vertices
  157|       |    /// - edges: Set of labeled edges
  158|       |    /// - mst_labels: Accumulated MST edge labels
  159|       |    /// - rng: Random number generator
  160|       |    ///
  161|       |    /// Returns:
  162|       |    /// - Set of edge labels in the MST
  163|     32|    pub fn boruvka_mst<V: StT + Hash + Ord>(
  164|     32|        vertices: &Set<V>,
  165|     32|        edges: &Set<LabeledEdge<V>>,
  166|     32|        mst_labels: Set<usize>,
  167|     32|        rng: &mut StdRng,
  168|     32|    ) -> Set<usize> {
  169|       |        // Base case: no edges remaining
  170|     32|        if edges.size() == 0 {
  171|      8|            return mst_labels;
  172|     24|        }
  173|       |
  174|       |        // Find vertex bridges
  175|     24|        let bridges = vertex_bridges(edges);
  176|       |
  177|       |        // Perform bridge star partition
  178|     24|        let (remaining_vertices, partition) = bridge_star_partition(vertices, &bridges, rng);
  179|       |
  180|       |        // Collect new MST labels from partition
  181|     24|        let mut new_mst_labels = mst_labels.clone();
  182|     24|        for (_, (_, _, label)) in partition.iter() {
                                     ^21
  183|     21|            let _ = new_mst_labels.insert(*label);
  184|     21|        }
  185|       |
  186|       |        // Build full partition map (including identity for non-contracted vertices)
  187|     24|        let mut full_partition: HashMap<V, V> = HashMap::new();
  188|     24|        for (tail, (head, _, _)) in partition.iter() {
                           ^21    ^21
  189|     21|            let _ = full_partition.insert(tail.clone(), head.clone());
  190|     21|        }
  191|     55|        for v in remaining_vertices.iter() {
                               ^24                ^24
  192|     55|            let _ = full_partition.insert(v.clone(), v.clone());
  193|     55|        }
  194|       |
  195|       |        // Re-route edges to new endpoints, removing self-edges
  196|     24|        let mut new_edges = SetLit![];
  197|     77|        for (u, v, w, label) in edges.iter() {
                                              ^24   ^24
  198|     77|            let new_u = full_partition.get(u).cloned().unwrap_or_else(|| u.clone());
                                                                                       ^0^0
  199|     77|            let new_v = full_partition.get(v).cloned().unwrap_or_else(|| v.clone());
                                                                                       ^0^0
  200|       |
  201|       |            // Skip self-edges
  202|     77|            if new_u != new_v {
  203|     50|                let _ = new_edges.insert((new_u, new_v, *w, *label));
  204|     50|            }
                          ^27
  205|       |        }
  206|       |
  207|       |        // Recurse
  208|     24|        boruvka_mst(&remaining_vertices, &new_edges, new_mst_labels, rng)
  209|     32|    }
  210|       |
  211|       |    /// Helper: Create Borvka MST with a specific seed
  212|       |    ///
  213|       |    /// APAS: Work O(m log n), Span O(m log n)
  214|       |    /// claude-4-sonet: Work O(m log n), Span O(m log n)
  215|       |    ///
  216|       |    /// Arguments:
  217|       |    /// - vertices: Set of vertices
  218|       |    /// - edges: Set of labeled edges
  219|       |    /// - seed: Random seed for reproducibility
  220|       |    ///
  221|       |    /// Returns:
  222|       |    /// - Set of edge labels in the MST
  223|      8|    pub fn boruvka_mst_with_seed<V: StT + Hash + Ord>(
  224|      8|        vertices: &Set<V>,
  225|      8|        edges: &Set<LabeledEdge<V>>,
  226|      8|        seed: u64,
  227|      8|    ) -> Set<usize> {
  228|      8|        let mut rng = StdRng::seed_from_u64(seed);
  229|      8|        boruvka_mst(vertices, edges, SetLit![], &mut rng)
  230|      8|    }
  231|       |
  232|       |    /// Compute MST weight from edge labels
  233|       |    ///
  234|       |    /// APAS: Work O(m), Span O(m)
  235|       |    /// claude-4-sonet: Work O(m), Span O(m)
  236|      7|    pub fn mst_weight<V: StT + Hash>(edges: &Set<LabeledEdge<V>>, mst_labels: &Set<usize>) -> OrderedFloat<f64> {
  237|      7|        let mut total = OrderedFloat(0.0);
  238|     27|        for (_, _, w, label) in edges.iter() {
                                              ^7    ^7
  239|     27|            if mst_labels.mem(label) {
  240|     21|                total += *w;
  241|     21|            }
                          ^6
  242|       |        }
  243|      7|        total
  244|      7|    }
  245|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/Types.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Common types used across the crate.
    3|       |//!
    4|       |
    5|       |pub mod Types {
    6|       |
    7|       |use std::fmt::{Debug, Display};
    8|       |use std::hash::Hash;
    9|       |
   10|       |    pub type N = usize;
   11|       |
   12|       |    /// Data Type 18.1 (Boolean) type used by APAS.
   13|       |    /// Using Rust's built-in bool with normal true/false literals
   14|       |    pub type B = bool;
   15|       |
   16|       |    /// Data Type 18.1 (Ordering) relationships used by APAS, using Rust's as it matches.
   17|       |    /// Enumerated values in `std::cmp::Ordering` are named: Less, Equal, Greater.
   18|       |    pub use std::cmp::Ordering as O;
   19|       |
   20|       |    // Note: bool already implements Display, Debug, Not, etc.
   21|       |    // No custom implementations needed when B = bool
   22|       |
   23|       |    // Newtype wrapper for key-value pairs that implements Display
   24|       |    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
   25|       |    pub struct Pair<K, V>(pub K, pub V);
   26|       |
   27|       |    impl<K: Display, V: Display> Display for Pair<K, V> {
   28|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, "({} -> {})", self.0, self.1) }
   29|       |    }
   30|       |
   31|       |    // Triple wrapper for three-element tuples
   32|       |    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
   33|       |    pub struct Triple<A, B, C>(pub A, pub B, pub C);
   34|       |
   35|       |    impl<A: Display, B: Display, C: Display> Display for Triple<A, B, C> {
   36|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   37|      1|            write!(f, "({}, {}, {})", self.0, self.1, self.2)
   38|      1|        }
   39|       |    }
   40|       |
   41|       |    // Key-value struct with named fields
   42|       |    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
   43|       |    pub struct KeyVal<K, V> {
   44|       |        pub key: K,
   45|       |        pub val: V,
   46|       |    }
   47|       |
   48|       |    impl<K: Display, V: Display> Display for KeyVal<K, V> {
   49|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   50|      1|            write!(f, "{{key: {}, val: {}}}", self.key, self.val)
   51|      1|        }
   52|       |    }
   53|       |
   54|       |    // Type bounds shorthands
   55|       |    // StT: single-threaded friendly elements: Eq + Clone + Display + Debug + Sized
   56|       |    pub trait StT: Eq + Clone + Display + Debug + Sized {}
   57|       |    impl<T> StT for T where T: Eq + Clone + Display + Debug + Sized {}
   58|       |
   59|       |    // StTInMtT: St-friendly elements that can be shared across threads (StT + Send + Sync)
   60|       |    pub trait StTInMtT: StT + Send + Sync {}
   61|       |    impl<T> StTInMtT for T where T: StT + Send + Sync {}
   62|       |
   63|       |    // MtT: multi-threaded friendly elements; minimal so it can include Mutex<..>
   64|       |    // Keep only thread-safety and size requirements.
   65|       |    pub trait MtT: Sized + Send + Sync {
   66|       |        type Inner: StT;
   67|       |        fn clone_mt(&self) -> Self;
   68|       |        fn new_mt(inner: Self::Inner) -> Self;
   69|       |    }
   70|       |
   71|       |    // HashFunClone: Combines HashFunction and Clone for Chapter 47 hash tables
   72|       |    // Reduces where clause complexity by bundling common requirements
   73|       |    pub trait HashFunClone<K>: crate::Chap47::HashFunctionTraits::HashFunctionTraits::HashFunction<K> + Clone {}
   74|       |    impl<K, T> HashFunClone<K> for T where T: crate::Chap47::HashFunctionTraits::HashFunctionTraits::HashFunction<K> + Clone {}
   75|       |
   76|       |    // MtKey: Multi-threaded key type with ordering and static lifetime
   77|       |    // Common pattern: StTInMtT + Ord + 'static (appears 15+ times)
   78|       |    pub trait MtKey: StTInMtT + Ord + 'static {}
   79|       |    impl<T> MtKey for T where T: StTInMtT + Ord + 'static {}
   80|       |
   81|       |    // MtVal: Multi-threaded value type with static lifetime
   82|       |    // Common pattern: StTInMtT + 'static (appears 15+ times)
   83|       |    pub trait MtVal: StTInMtT + 'static {}
   84|       |    impl<T> MtVal for T where T: StTInMtT + 'static {}
   85|       |
   86|       |    // MtFn: Multi-threaded function type with common bounds
   87|       |    // Common pattern: Fn(...) + Send + Sync + 'static (appears 30+ times)
   88|       |    pub trait MtFn<Args, Output>: Fn(Args) -> Output + Send + Sync + 'static {}
   89|       |    impl<T, Args, Output> MtFn<Args, Output> for T where T: Fn(Args) -> Output + Send + Sync + 'static {}
   90|       |
   91|       |    // MtFnClone: Multi-threaded function type with Clone
   92|       |    // Common pattern: Fn(...) + Send + Sync + Clone + 'static (appears 20+ times)
   93|       |    pub trait MtFnClone<Args, Output>: Fn(Args) -> Output + Send + Sync + Clone + 'static {}
   94|       |    impl<T, Args, Output> MtFnClone<Args, Output> for T where T: Fn(Args) -> Output + Send + Sync + Clone + 'static {}
   95|       |
   96|       |    // MtReduceFn: Multi-threaded reducer function type
   97|       |    // Common pattern: Fn(&V, &V) -> V + Clone + Send + Sync + 'static (appears 8+ times)
   98|       |    pub trait MtReduceFn<V>: Fn(&V, &V) -> V + Clone + Send + Sync + 'static {}
   99|       |    impl<T, V> MtReduceFn<V> for T where T: Fn(&V, &V) -> V + Clone + Send + Sync + 'static {}
  100|       |
  101|       |    // Pred: Multi-threaded predicate function (boolean function)
  102|       |    // Common pattern: Fn(&T) -> B + Send + Sync + 'static (appears 10+ times)
  103|       |    pub trait Pred<T>: Fn(&T) -> B + Send + Sync + 'static {}
  104|       |    impl<F, T> Pred<T> for F where F: Fn(&T) -> B + Send + Sync + 'static {}
  105|       |
  106|       |    // PredVal: Multi-threaded predicate function taking values by value
  107|       |    // Common pattern: Fn(T) -> B + Send + Sync + 'static (for Copy types like N)
  108|       |    pub trait PredVal<T>: Fn(T) -> B + Send + Sync + 'static {}
  109|       |    impl<F, T> PredVal<T> for F where F: Fn(T) -> B + Send + Sync + 'static {}
  110|       |
  111|       |    // Note: StT + Send + Sync is already covered by existing StTInMtT trait
  112|       |    // StTInMtT + 'static pattern can be expressed as StTInMtT + 'static inline
  113|       |
  114|       |    // HashOrd: Type that can be hashed and ordered (for graph vertices)
  115|       |    // Common pattern: StT + MtT + Hash + Ord (appears in graph modules)
  116|       |    pub trait HashOrd: StT + Hash + Ord {}
  117|       |    impl<T> HashOrd for T where T: StT + Hash + Ord {}
  118|       |
  119|       |    // ArithmeticT: Type supporting arithmetic operations (for reductions)
  120|       |    // Common pattern: StT + std::ops::Add<Output = T> + Default + Copy
  121|       |    pub trait ArithmeticT: StT + std::ops::Add<Output = Self> + Default + Copy {}
  122|       |    impl<T> ArithmeticT for T where T: StT + std::ops::Add<Output = T> + Default + Copy {}
  123|       |
  124|       |    impl<T: StT + Send> MtT for std::sync::Mutex<T> {
  125|       |        type Inner = T;
  126|      1|        fn clone_mt(&self) -> Self {
  127|      1|            let inner = self.lock().unwrap().clone();
  128|      1|            std::sync::Mutex::new(inner)
  129|      1|        }
  130|      1|        fn new_mt(inner: Self::Inner) -> Self { std::sync::Mutex::new(inner) }
  131|       |    }
  132|       |
  133|       |    impl<A: StT + Send + Sync, B: StT + Send + Sync> MtT for Pair<A, B> {
  134|       |        type Inner = Pair<A, B>;
  135|      1|        fn clone_mt(&self) -> Self { self.clone() }
  136|      1|        fn new_mt(inner: Self::Inner) -> Self { inner }
  137|       |    }
  138|       |
  139|       |    // Ad-hoc implementations for specific primitive types to avoid conflicts
  140|       |    impl MtT for usize {
  141|       |        type Inner = usize;
  142|  1.29k|        fn clone_mt(&self) -> Self { *self }
  143|      1|        fn new_mt(inner: Self::Inner) -> Self { inner }
  144|       |    }
  145|       |
  146|       |    impl MtT for isize {
  147|       |        type Inner = isize;
  148|      1|        fn clone_mt(&self) -> Self { *self }
  149|      1|        fn new_mt(inner: Self::Inner) -> Self { inner }
  150|       |    }
  151|       |
  152|       |    impl MtT for i32 {
  153|       |        type Inner = i32;
  154|  83.1k|        fn clone_mt(&self) -> Self { *self }
  155|      1|        fn new_mt(inner: Self::Inner) -> Self { inner }
  156|       |    }
  157|       |
  158|       |    impl MtT for u32 {
  159|       |        type Inner = u32;
  160|      1|        fn clone_mt(&self) -> Self { *self }
  161|      1|        fn new_mt(inner: Self::Inner) -> Self { inner }
  162|       |    }
  163|       |
  164|       |    impl MtT for i64 {
  165|       |        type Inner = i64;
  166|      1|        fn clone_mt(&self) -> Self { *self }
  167|      1|        fn new_mt(inner: Self::Inner) -> Self { inner }
  168|       |    }
  169|       |
  170|       |    impl MtT for u64 {
  171|       |        type Inner = u64;
  172|      1|        fn clone_mt(&self) -> Self { *self }
  173|      1|        fn new_mt(inner: Self::Inner) -> Self { inner }
  174|       |    }
  175|       |
  176|       |    impl MtT for bool {
  177|       |        type Inner = bool;
  178|      1|        fn clone_mt(&self) -> Self { *self }
  179|      1|        fn new_mt(inner: Self::Inner) -> Self { inner }
  180|       |    }
  181|       |
  182|       |    impl MtT for char {
  183|       |        type Inner = char;
  184|      1|        fn clone_mt(&self) -> Self { *self }
  185|      1|        fn new_mt(inner: Self::Inner) -> Self { inner }
  186|       |    }
  187|       |
  188|       |    // Special case: ad-hoc implementation for String
  189|       |    impl MtT for String {
  190|       |        type Inner = String;
  191|      1|        fn clone_mt(&self) -> Self { self.clone() }
  192|      1|        fn new_mt(inner: Self::Inner) -> Self { inner }
  193|       |    }
  194|       |
  195|       |    // String slice implementation
  196|       |    impl<'a> MtT for &'a str {
  197|       |        type Inner = &'a str;
  198|      1|        fn clone_mt(&self) -> Self { *self }
  199|      1|        fn new_mt(inner: Self::Inner) -> Self { inner }
  200|       |    }
  201|       |
  202|       |    // Note: bool already has MtT implementation above (line ~112)
  203|       |    // No custom implementation needed when B = bool
  204|       |
  205|       |    /// Edge wrapper to enable Display/Debug for pairs (V,V) under baseline bounds.
  206|       |    #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
  207|       |    pub struct Edge<V: StT>(pub V, pub V);
  208|       |
  209|       |    impl<V: StT> std::fmt::Display for Edge<V> {
  210|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, "({}, {})", self.0, self.1) }
  211|       |    }
  212|       |
  213|       |    impl<V: StT> From<(V, V)> for Edge<V> {
  214|      1|        fn from(t: (V, V)) -> Self { Edge(t.0, t.1) }
  215|       |    }
  216|       |
  217|       |    impl<V: StT> From<Edge<V>> for (V, V) {
  218|      1|        fn from(e: Edge<V>) -> (V, V) { (e.0, e.1) }
  219|       |    }
  220|       |
  221|       |    /// Labeled Edge wrapper to enable edges with labels.
  222|       |    #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
  223|       |    pub struct LabEdge<V: StT, L: StT + Hash>(pub V, pub V, pub L);
  224|       |
  225|       |    impl<V: StT, L: StT + Hash> std::fmt::Display for LabEdge<V, L> {
  226|      6|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  227|      6|            write!(f, "({}, {}, {})", self.0, self.1, self.2)
  228|      6|        }
  229|       |    }
  230|       |
  231|       |    impl<V: StT, L: StT + Hash> From<(V, V, L)> for LabEdge<V, L> {
  232|      1|        fn from(t: (V, V, L)) -> Self { LabEdge(t.0, t.1, t.2) }
  233|       |    }
  234|       |
  235|       |    impl<V: StT, L: StT + Hash> From<LabEdge<V, L>> for (V, V, L) {
  236|      1|        fn from(e: LabEdge<V, L>) -> (V, V, L) { (e.0, e.1, e.2) }
  237|       |    }
  238|       |
  239|       |    // Import OrderedFloat from the ordered-float crate
  240|       |    pub use ordered_float::OrderedFloat;
  241|       |
  242|       |    // Convenience type aliases for common float types
  243|       |    pub type OrderedF32 = OrderedFloat<f32>;
  244|       |    pub type OrderedF64 = OrderedFloat<f64>;
  245|       |
  246|       |    impl<A, B> From<(A, B)> for Pair<A, B> {
  247|      1|        fn from(t: (A, B)) -> Self { Pair(t.0, t.1) }
  248|       |    }
  249|       |
  250|       |    impl<A, B> From<Pair<A, B>> for (A, B) {
  251|      1|        fn from(p: Pair<A, B>) -> Self { (p.0, p.1) }
  252|       |    }
  253|       |
  254|       |    #[macro_export]
  255|       |    macro_rules! ParaPair {
  256|       |        ( $left:expr, $right:expr ) => {{
  257|       |            let left_handle = std::thread::Builder::new()
  258|       |                .stack_size(32 * 1024 * 1024) // 32MB stack for unconditional parallelism
  259|       |                .spawn($left)
  260|       |                .expect("failed to spawn left thread");
  261|       |            let right_handle = std::thread::Builder::new()
  262|       |                .stack_size(32 * 1024 * 1024) // 32MB stack for unconditional parallelism
  263|       |                .spawn($right)
  264|       |                .expect("failed to spawn right thread");
  265|       |            let left_result = left_handle.join().expect("left ParaPair task panicked");
  266|       |            let right_result = right_handle.join().expect("right ParaPair task panicked");
  267|       |            $crate::Types::Types::Pair(left_result, right_result)
  268|       |        }};
  269|       |    }
  270|       |
  271|       |    #[allow(dead_code)]
  272|      0|    fn _ParaPair_type_checks() {
  273|      0|        let Pair(left, right) = ParaPair!(|| { 1usize }, || { 2usize });
  274|      0|        let _: usize = left;
  275|      0|        let _: usize = right;
  276|      0|    }
  277|       |
  278|       |    /// Set equivalence comparison for sequences (order-independent, useful for MT tests)
  279|       |    /// APAS: Work (n), Span (1) - simple membership test both ways
  280|       |    /// claude-4-sonet: Work (n), Span (1) - simple membership test both ways
  281|      4|    pub fn ArraySeqSetEq<T: PartialEq>(a_len: N, a_nth: fn(N) -> T, b_len: N, b_nth: fn(N) -> T) -> bool {
  282|      4|        if a_len != b_len {
  283|      1|            return false;
  284|      3|        }
  285|       |
  286|       |        // For each element in sequence A, check if it exists in sequence B
  287|      9|        for i in 0..a_len {
                                  ^3
  288|      9|            let a_elem = a_nth(i);
  289|      9|            let mut found = false;
  290|     18|            for j in 0..b_len {
                                      ^9
  291|     18|                if a_elem == b_nth(j) {
  292|      8|                    found = true;
  293|      8|                    break;
  294|     10|                }
  295|       |            }
  296|      9|            if !found {
  297|      1|                return false;
  298|      8|            }
  299|       |        }
  300|       |
  301|       |        // For each element in sequence B, check if it exists in sequence A
  302|      6|        for j in 0..b_len {
                                  ^2
  303|      6|            let b_elem = b_nth(j);
  304|      6|            let mut found = false;
  305|     12|            for i in 0..a_len {
                                      ^6
  306|     12|                if b_elem == a_nth(i) {
  307|      6|                    found = true;
  308|      6|                    break;
  309|      6|                }
  310|       |            }
  311|      6|            if !found {
  312|      0|                return false;
  313|      6|            }
  314|       |        }
  315|       |
  316|      2|        true
  317|      4|    }
  318|       |
  319|       |    #[macro_export]
  320|       |    macro_rules! EdgeLit {
  321|       |        ($a:expr, $b:expr) => {
  322|       |            $crate::Types::Types::Edge($a, $b)
  323|       |        };
  324|       |    }
  325|       |
  326|       |    #[macro_export]
  327|       |    macro_rules! PairLit {
  328|       |        ($a:expr, $b:expr) => {
  329|       |            $crate::Types::Types::Pair($a, $b)
  330|       |        };
  331|       |    }
  332|       |
  333|       |    #[macro_export]
  334|       |    macro_rules! EdgeList {
  335|       |        () => {
  336|       |            Vec::new()
  337|       |        };
  338|       |        ( $( ($a:expr, $b:expr) ),* $(,)? ) => {
  339|       |            vec![ $( $crate::EdgeLit!($a, $b) ),* ]
  340|       |        };
  341|       |    }
  342|       |
  343|       |    #[macro_export]
  344|       |    macro_rules! PairList {
  345|       |        () => {
  346|       |            Vec::new()
  347|       |        };
  348|       |        ( $( ($a:expr, $b:expr) ),* $(,)? ) => {
  349|       |            vec![ $( $crate::PairLit!($a, $b) ),* ]
  350|       |        };
  351|       |    }
  352|       |
  353|       |}

/home/milnes/APASVERUS/APAS-AI/apas-ai/src/main.rs:
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    2|       |//! Binary entry point for `apas-ai` (not used by library tests/benches).
    3|       |//!
    4|       |//! Abstract:
    5|       |//! - Minimal placeholder main to satisfy Cargo bin target.
    6|       |//! - All functionality lives in the library; benches/tests import the crate APIs.
    7|       |
    8|      0|fn main() {
    9|      0|    println!("No functionality here yet.");
   10|      0|}

