Chap21

2. EPHEMERAL SEQUENCES 151
of the data structure: because an instance is never consumed more than once, it is safe to
destruct or reuse it when making a new instance. We refer to an implementation of a data
structure that destroys existing instances as ephemeral.
Disadvantages of Ephemeral Implementations. Even though they can be efficient, ephemeral
implementations have one important disadvantage: they are generally not safe for paral-
lelism. As an example, consider the following three sequences:
a = 〈 0, 1, . . . , n − 1 〉
b = 〈 (0, 0), (1, 2), (2, 4), . . . , (n − 1, 2n − 2) 〉
c = 〈 (0, 1), (1, 3), (2, 5), . . . , (n − 1, 2n − 1) 〉
Using ephemeral sequences, the result of the following piece of code, which injects the
sequence b and c into another sequence a is non-deterministic:
inject a b || inject a c.
This piece of code has as many as 2n distinct outcomes: the element at position i is either
the ith even number of ith odd number.
Ephemeral implementations can therefore make reasoning about the correctness parallel
algorithms challenging, because we have to consider an exponential number of possibili-
ties. An earlier chapter covers this topic in more detail. This does not mean, however,
that emphemeral data structures should be avoided at all cost. They are usually acceptable
in sequential algorithms. Even in parallel algorithms, it is sometimes possible to use them
in a structured fashion and establish that they don’t harm correctness.
2 Ephemeral Sequences
Constant Work Updates. We can create an ephemeral version of array sequences by
changing the update, inject, and ninject primitives to update the input array destructively.
For an update sequence of length m, the resulting implementation has the following im-
proved bounds:
• O(1) work and span for update,
• O(m) work and O(lg d) span for inject, where d is the degree of the of the update
sequence,
• O(m) work and O(1) span for ninject

Cost Specification 22.2 (Single Threaded Array Sequence).
Work Span
fromSeq a O (|a|) O (1)
toSeq a O (|a|) O (1)
nth a i O (1) O (1)
update a (i, v) O (1) O (1)
inject a b O(|b|) O (lg(degree(d)))

