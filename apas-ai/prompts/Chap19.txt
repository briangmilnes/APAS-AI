
 The idea of Chap19 is to use Chap18 but redefine things in terms of this set of
 primitives:

 I think our primitives are good.

  But we want Chap19/<X> to import and stub out any missing functions in Chap18/<X>
 and reimplement all of the ones below in terms of the 7 primitives.

  Review the Chap19 functions and notice they all have the same trait/impl
 names so an as in importing the Chap18 version <X> files is going to be
 needed.

 Explore Chap18 and Chap19 files.

 Then make a detailed to-do list and let me review it. 

 Then give me an estimate of the time.

 Then execute when I tell you.

 

From APAS:

1 A Parametric Implementation

The sequence ADT, as we described in ADT Chapter , includes more than a dozen func-
tions. Although it is possible to present an implementation by considering each function
independently, it usually suffices to implement directly a smaller subset of the functions,
which we can think of the primitive functions, and implement the rest of the functions in
terms of the primitive ones.
In this section, we briefly describe how such an implementation could proceed based on
the following primitive functions:
• nth,
• length,
• subseq,
• tabulate,
• flatten, and
• inject and ninject.
First, we present an implementation of the rest of the interface based on the primitive
functions. We then describe in Section 1 how the implement the primitive functions.

1. A PARAMETRIC IMPLEMENTATION 127
Algorithm 19.1 (Function empty). We can implement the empty sequence empty directly
in terms of tabulate:
empty = tabulate (lambda i.i) 0.
Algorithm 19.2 (Function singleton). We can implement the function singleton directly in
terms of tabulate:
singleton x = tabulate (lambda i.x) 1.
Algorithm 19.3 (Function map). The function map is relatively easy to implement in terms
of tabulate:
map f a = tabulate (lambda i.f (a[i])) |a|.
Algorithm 19.4 (Function append ). We can implement append directly in terms of flatten:
append a b = flatten 〈 a, b 〉 .
We can also implement append by using tabulate. To this end, we first define a helper
function:
select (a, b) i =lambda i. (19.1)
if i < |a| then a[i] (19.2)
else b[i − |a|]. (19.3)
We can now state append as
append a b = tabulate (select (a, b)) (|a| + |b|).
Algorithm 19.5 (Function filter ). We can implement filter by a using a combination of map
and flatten. The basic idea is to map the elements of the sequence for which the condition
holds to singletons and map the other elements to empty sequences and then flatten.
We first define a function that “deflates” the elements for which the condition f does not
hold:
deflate f x =
if (f x) then 〈 x 〉
else 〈 〉 .
We can now write filter as a relatively simple application of flatten, map, and deflate.
filter f a =
let b = map (deflate f ) a
in flatten b end
128 CHAPTER 19. ARRAY SEQUENCES
Algorithm 19.6 (Function update). We can implement the function update in terms of tabulate

update a (i, x) =
tabulate (lambda j. if i = j then x else a[i])
|a|
Algorithm 19.7 (Functions isEmpty and isSingleton). Emptiness and singleton checks are
simple by using the length function:
isEmpty a =
|a| = 0
isSingleton a =
|a| = 1
Algorithm 19.8 (Functions iterate). We can implement iteration by simply iterating over
the sequence from left to right.
iterate f x a =
if |a| = 0 then
x
else if |a| = 1 then
f (x, a[0])
else
iterate f (f (x, a[0])) a[1 . . . |a| − 1]
Algorithm 19.9 (Functions reduce). We can implement reduce by using a divide-and-conquer
strategy.
reduce f id a =
if |a| = 0 then
id
else if |a| = 1 then
a[0]
else
let
mid = f loor(|a|/2)
(b, c) = (a[0 . . . mid − 1], a[mid . . . |a| − 1])
(rb, rc) = (reduce f id b) || (reduce f id c)
in
f (rb, rc)
end

Algorithm 19.10 (Scan Using Contraction). We will cover scan in more detail in Section 3.
But for completeness, we present an implementation below. For simplicity, we assume that
the length of the sequence is a power of two, though this is not difficult to eliminate
(* Assumption: |a| is a power of two. *)
scan f id a =
case |a|
| 0 ⇒ (〈 〉 , id)
| 1 ⇒ (〈 id 〉 , a[0])
| n ⇒
let
a′ = 〈 f (a[2i], a[2i + 1]) : 0 ≤ i < n/2 〉
(r, t) = scan f id a′
in
(〈 pi : 0 ≤ i < n 〉 , t), where pi =
{
r[i/2] even(i)
f (r[i/2], a[i − 1]) otherwise
end


Algorithm 19.10 (Scan Using Contraction). We will cover scan in more detail in Section 3.
But for completeness, we present an implementation below. For simplicity, we assume that
the length of the sequence is a power of two, though this is not difficult to eliminate.


(* Assumption: |a| is a power of two. *)
scan f id a =
case |a|
| 0 ⇒ (〈 〉 , id)
| 1 ⇒ (〈 id 〉 , a[0])
| n ⇒
let
a′ = 〈 f (a[2i], a[2i + 1]) : 0 ≤ i < n/2 〉
(r, t) = scan f id a′
in
(〈 pi : 0 ≤ i < n 〉 , t), where pi =
{
r[i/2] even(i)
f (r[i/2], a[i − 1]) otherwise
end


2. IMPLEMENTING THE PRIMITIVE FUNCTIONS 129
(* Assumption: |a| is a power of two. *)
scan f id a =
case |a|
| 0 ⇒ (〈 〉 , id)
| 1 ⇒ (〈 id 〉 , a[0])
| n ⇒
let
a′ = 〈 f (a[2i], a[2i + 1]) : 0 ≤ i < n/2 〉
(r, t) = scan f id a′
in
(〈 pi : 0 ≤ i < n 〉 , t), where pi =
{
r[i/2] even(i)
f (r[i/2], a[i − 1]) otherwise
end
2 Implementing the Primitive Functions
To support the primitive operations efficiently we represent a sequence as an array segment
(a.k.a., slice) contained within a possibly larger array along with a few additional pieces of
information. More precisely, a sequence is represented as:
• an array of elements contains the elements in the sequence (but possibly more)
• a “left” and a “right” position indicates the boundaries of the slice in terms of the be-
ginning and the ending of a contiguous section of the array that contains the elements
in the sequence (in order),
Algorithm 19.11 (Function nth). Using arrays, indexing into any location requires a simple
array access and can be achieved in constant work and span.
Algorithm 19.12 (Function length). Because we know the boundary positions of the array
slice that corresponds to the sequence, we can calculate length by using simple arithmetic
in constant work and span.
Algorithm 19.13 (Function subseq). Taking a subsequence of a sequence requires deter-
mining the boundaries for the new slice. We do not need to copy the elements of the array
within the boundary. This operation therefore requires basic arithmetic and thus can be
done in constant work and span.
Algorithm 19.14 (Function tabulate). Consider a call to tabulate of the form:
tabulate f n.
To construct the sequence of length n, we allocate a fresh array of n elements, evaluate f at
each position i and write the result into position i of the array.

Because the function f can be evaluated at each element independently in parallel, this
operation has the same span and that of the function f itself (maximized over all positions)
and the total work is the sum of the work required to evaluate f at each position.
Algorithm 19.15 (Function flatten). Consider a call to flatten of the form:
flatten a,
where a is a sequences of sequences.
To compute the resulting sequence, we first map each element of a to its length; let ` be the
resulting sequence. We then perform the scan scan + 0 `. This computation returns for
each element of a its position in the result sequence of flatten. Finally, we allocate an array
that can hold all of the elements of the sequences in a and write each element of a into its
corresponding segment in parallel.
This cost of scan is O(|a|) work and O(lg |a|) span. The cost of the final write of each
element requires O(||a||) work, where ||a|| = ∑|a|−1
i=0 |a[i]| and constant span. Thus the total
work is O(|a| + ||a||) and span is O(lg |a|).

Algorithm 19.16 (Function inject). Consider a call to inject of the form:
inject a b,
where a is a sequence of length n and b is a sequence of m updates.
To inject the updates into the sequence, we create a new array aa from a, where for all
0 ≤ i < |a|, aa[i] = (a[i], |a|). We then “inject” all updates in b into aa in parallel. To handle
each update of the form (j, v) at position k, we perform an atomic update operation that
proceeds as follows.
atomicW rite aa b k =
atomically do:
(j, v) ← b[k]
(w, i) ← aa[j]
if k < i then
aa[j] ← (v, k)
This update operation guarantees that of the possibly many conflicting operations the first
(leftmost) one in the update sequence wins and is transferred to the result; the other up-
dates either don’t take place or are overwritten. After all updates complete, we take aa and
create another array consisting of only the value component of each element.
Under the assumption that all updates occur uniformly randomly, it is possible to prove
that the number of updates to a position that is targeted by d updates is O(lg d) in expecta-
tion and the total work is O(n + m). Note that d ≤ m and therefore O(lg m) span is also a
decent upper bound but as we will see in many cases d, which is the degree, is constant.
Algorithm 19.17 (Function ninject). Consider a call to ninject of the form:
ninject a b,

2. IMPLEMENTING THE PRIMITIVE FUNCTIONS 131
where a is a sequence to be injected into and b is the updates.
To inject the updates into the sequence, we make a copy of the array a and then use an
atomic write operation to write or “inject” each update independently in parallel. Each
instance of the atomic write operation updates the relevant element of the copied array
atomically. Assuming that each atomic write operation requires constant-work, this imple-
mentation requires linear work in the number of updates and constant span.
Remark (Benign Effects). We made careful use of side effects (memory updates) in imple-
menting the primitive functions. Because these side effects are not visible to the program-
mer, the ADT remains to be purely functional and thus is safe for parallelism. Effects such
as these that have no impact on purity are sometimes called benign effects.

