//! Edge Set Graph Representation - Ephemeral Multi-Threaded Implementation
//!
//! This module implements the ephemeral edge-set representation with parallel
//! map operations and in-place mutations protected by synchronization.

pub mod EdgeSetGraphMtEph {

use crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::*;
use crate::Chap43Claude::OrderedTableStEph::OrderedTableStEph::*;
use crate::Types::Types::*;
use std::fmt::{Debug, Display};
use std::sync::{Arc, Mutex};
use std::thread;

/// Ephemeral multi-threaded edge-set graph (struct product record type)

pub struct EdgeSetGraphMtEphS<V: MtT + Ord + Clone + Debug + Display> {
    /// Set of vertices
    vertices: AVLTreeSetStEph<V>,
    /// Set of directed edges (u, v)
    edges: AVLTreeSetStEph<Pair<V, V>>,
}

impl<V: MtT + Ord + Clone + Debug + Display> EdgeSetGraphMtEphS<V> {
    /// Claude Work: O(1) - constant time initialization
    /// Claude Span: O(1) - constant time initialization
    pub fn new() -> Self {
        EdgeSetGraphMtEphS {
            vertices: AVLTreeSetStEph::empty(),
            edges: AVLTreeSetStEph::empty(),
        }
    }

    /// Insert an isolated vertex (ephemeral mutation)
    /// Claude Work: O(lg n) - tree-based set insert
    /// Claude Span: O(lg n) - tree-based set insert
    pub fn insert_vertex(&mut self, v: V) {
        self.vertices.insert(v);
    }

    /// Delete an isolated vertex (ephemeral mutation)
    /// Claude Work: O(lg n) - tree-based set delete
    /// Claude Span: O(lg n) - tree-based set delete
    pub fn delete_vertex(&mut self, v: &V) {
        self.vertices.delete(v);
    }

    /// Insert a directed edge (ephemeral mutation)
    /// Claude Work: O(lg n) - tree-based set insert
    /// Claude Span: O(lg n) - tree-based set insert
    pub fn insert_edge(&mut self, u: V, v: V) {
        self.edges.insert(Pair(u, v));
    }

    /// Delete a directed edge (ephemeral mutation)
    /// Claude Work: O(lg n) - tree-based set delete
    /// Claude Span: O(lg n) - tree-based set delete
    pub fn delete_edge(&mut self, u: &V, v: &V) {
        self.edges.delete(&(*u, *v));
    }

    /// Check if edge (u, v) exists
    /// Claude Work: O(lg n) - tree-based set find
    /// Claude Span: O(lg n) - tree-based set find
    pub fn has_edge(&self, u: &V, v: &V) -> bool {
        self.edges.find(&*u, *v)
    }

    /// Get number of vertices
    /// Claude Work: O(1) - constant time
    /// Claude Span: O(1) - constant time
    pub fn vertex_count(&self) -> usize {
        self.vertices.size()
    }

    /// Get number of edges
    /// Claude Work: O(1) - constant time
    /// Claude Span: O(1) - constant time
    pub fn edge_count(&self) -> usize {
        self.edges.size()
    }

    /// Get out-degree of a vertex (parallel)
    /// Claude Work: O(m) - scan all edges
    /// Claude Span: O(lg m) - parallel reduction
//     pub fn out_degree(&self, v: &V) -> usize {
//         let edges_vec: Vec<Pair<V, V>> = self.edges.iter().cloned().collect();
//         let chunk_size = (edges_vec.len() / 4).max(1);
//         let v_clone = v.clone();
//         
//         let handles: Vec<_> = edges_vec
//             .chunks(chunk_size)
//             .map(|chunk| {
//                 let chunk = chunk.to_vec();
//                 let v_clone = v_clone.clone();
//                 thread::spawn(move || {
//                     chunk.iter().filter(|(u, _)| u == &v_clone).count()
//                 })
//             })
//             .collect();
//         
//         handles.into_iter().map(|h| h.join().unwrap()).sum()
//     }

    /// Map a function over all vertices (parallel)
    /// Claude Work: O(n) - assuming f is O(1)
    /// Claude Span: O(lg n) - parallel tree traversal
//     pub fn map_vertices_parallel<F, R>(&self, f: F) -> Vec<R>
//     where
//         F: Fn(&V) -> R + Send + Sync,
//         R: Send,
//     {
//         let vertices_vec: Vec<V> = self.vertices.iter().cloned().collect();
//         let chunk_size = (vertices_vec.len() / 4).max(1);
//         let f = Arc::new(f);
//         
//         let handles: Vec<_> = vertices_vec
//             .chunks(chunk_size)
//             .map(|chunk| {
//                 let chunk = chunk.to_vec();
//                 let f = Arc::clone(&f);
//                 thread::spawn(move || {
//                     chunk.iter().map(|v| f(v)).collect::<Vec<_>>()
//                 })
//             })
//             .collect();
//         
//         handles
//             .into_iter()
//             .flat_map(|h| h.join().unwrap())
//             .collect()
//     }

    /// Map a function over all edges (parallel)
    /// Claude Work: O(m) - assuming f is O(1)
    /// Claude Span: O(lg m) - parallel tree traversal
//     pub fn map_edges_parallel<F, R>(&self, f: F) -> Vec<R>
//     where
//         F: Fn(&(V, V)) -> R + Send + Sync,
//         R: Send,
//     {
//         let edges_vec: Vec<Pair<V, V>> = self.edges.iter().cloned().collect();
//         let chunk_size = (edges_vec.len() / 4).max(1);
//         let f = Arc::new(f);
//         
//         let handles: Vec<_> = edges_vec
//             .chunks(chunk_size)
//             .map(|chunk| {
//                 let chunk = chunk.to_vec();
//                 let f = Arc::clone(&f);
//                 thread::spawn(move || {
//                     chunk.iter().map(|e| f(e)).collect::<Vec<_>>()
//                 })
//             })
//             .collect();
//         
//         handles
//             .into_iter()
//             .flat_map(|h| h.join().unwrap())
//             .collect()
//     }

    /// Check if graph is empty
    /// Claude Work: O(1) - constant time check
    /// Claude Span: O(1) - constant time check
    pub fn is_empty(&self) -> bool {
        self.vertices.size() == 0
    }

    /// Get reference to vertex set
    pub fn vertices(&self) -> &AVLTreeSetStEph<V> {
        &self.vertices
    }

    /// Get reference to edge set
    pub fn edges(&self) -> &AVLTreeSetStEph<Pair<V, V>> {
        &self.edges
    }
}

impl<V: MtT + Ord + Clone + Debug + Display> Default for EdgeSetGraphMtEphS<V> {
    fn default() -> Self {
        Self::new()
    }
}

impl<V: MtT + Display> Display for EdgeSetGraphMtEphS<V> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EdgeSetGraphMtEph(vertices={}, edges={})",
            self.vertex_count(),
            self.edge_count()
        )
    }
}

// /// Weighted edge-set graph with separate weight table (parallel ephemeral)

// pub struct WeightedEdgeSetGraphMtEphS<V: MtT + Ord + Clone + Debug + Display> {
//     /// Base graph structure
//     graph: EdgeSetGraphMtEphS<V>,
//     /// Weight table mapping edges to weights (protected by mutex)
//     weights: Arc<Mutex<OrderedTableStEph<Pair<V, V>, f64>>>,
// }

// impl<V: MtT + Ord + Clone + Debug + Display> WeightedEdgeSetGraphMtEphS<V> {
//     /// Create new weighted graph
//     /// Claude Work: O(1) - constant time initialization
//     /// Claude Span: O(1) - constant time initialization
//     pub fn new() -> Self {
//         WeightedEdgeSetGraphMtEphS {
//             graph: EdgeSetGraphMtEphS::new(),
//             weights: Arc::new(Mutex::new(OrderedTableStEph::empty())),
//         }
//     }
// 
//     /// Insert weighted edge (ephemeral mutation)
//     /// Claude Work: O(lg n) - insert edge + insert weight
//     /// Claude Span: O(lg n) - sequential operations
//     pub fn insert_weighted_edge(&mut self, u: V, v: V, weight: f64) {
//         self.graph.insert_edge(u, v);
//         let mut weights_guard = self.weights.lock().unwrap();
//         weights_guard.insert((u, v), weight);
//     }
// 
//     /// Get edge weight
//     /// Claude Work: O(lg n) - table lookup
//     /// Claude Span: O(lg n) - table lookup
//     pub fn get_weight(&self, u: &V, v: &V) -> Option<f64> {
//         let weights_guard = self.weights.lock().unwrap();
//         weights_guard.find(&Pair(u.clone(), v.clone())).copied()
//     }
// 
//     /// Update edge weight (ephemeral mutation)
//     /// Claude Work: O(lg n) - table update
//     /// Claude Span: O(lg n) - table update
//     pub fn set_weight(&mut self, u: &V, v: &V, weight: f64) {
//         let mut weights_guard = self.weights.lock().unwrap();
//         weights_guard.insert((*u, *v), weight);
//     }
// 
//     /// Access underlying graph
//     pub fn graph(&self) -> &EdgeSetGraphMtEphS<V> {
//         &self.graph
//     }
// 
//     /// Mutable access to underlying graph
//     pub fn graph_mut(&mut self) -> &mut EdgeSetGraphMtEphS<V> {
//         &mut self.graph
//     }
// }

// impl<V: MtT + Ord + Clone + Debug + Display> Default for WeightedEdgeSetGraphMtEphS<V> {
//     fn default() -> Self {
//         Self::new()
//     }
// }

} // end mod EdgeSetGraphMtEph
