- Definitions:
  - crate: compilation unit; roots at src/lib.rs or src/main.rs; absolute paths 
begin crate::
  - module: namespace; declared with mod name; or inline mod name { ... }; 
controls visibility and paths
  - item: any top-level definition (mod, use, struct, enum, union, trait, impl, 
fn, const, static, type, macro)
  - function: free function at module scope; callable by path; signature 
defines type
  - method: function in an impl with a receiver; call as v.m(x)
  - associated function: function in an impl without a receiver; call as 
Type::f(args)
  - associated type: type member of a trait; specified in impls; may have a 
default
  - associated const: const member of a trait or impl; compile-time value bound 
to the item
  - path: hierarchical name using ::; absolute crate::; relative self:: and 
super::
  - visibility: pub, pub(crate), pub(super), pub(in path); governs reachability
  - use / pub use: import or re-export names into scope; no new definitions
  - macro (macro_rules!): declarative macro; export with #[macro_export]; 
invoked as Name!(...)
  - type alias: type Name = Existing; new name, same type
  - newtype: struct Name(Existing); distinct type with same representation
  - attributes: inner #![..] at crate/module roots, outer #[..] on items

- Trait:
  - can put in:
    - method signatures: fn m(&self, x: T) -> U
    - default method bodies: fn m(&self) -> U { ... }
    - associated types: type Item;
    - associated types with default: type Item = U;
    - associated constants: const N: usize;
  - can't put in:
    - fields or data members
    - struct/enum/union definitions
    - modules: mod m;
    - imports: use path::Item;
    - free consts/statics: const X: T = ...; static X: T = ...;
    - free type aliases: type Alias = T;
    - impl blocks

- Impl:
  - impl Trait for Type:
    - can put in:
      - method implementations: fn m(&self) -> U { ... }
      - associated type bindings: type Item = RealType;
      - associated const values: const N: usize = 8;
    - can't put in:
      - new items not declared in the trait (no extra methods here)
      - struct/enum/union definitions
      - modules/imports/macros: mod/use/macro_rules!
      - free type aliases: type Alias = T;
  - impl Type (inherent):
    - can put in:
      - associated functions: fn new(args) -> Self
      - methods: fn m(&self) -> U
      - associated consts: const NAME: Type = VALUE;
    - can't put in:
      - associated types (only allowed in trait impls)
      - struct/enum/union definitions
      - modules/imports/macros: mod/use/macro_rules!
      - free type aliases: type Alias = T;

- File top level (module file):
  - can put in:
    - module declarations: mod m; or inline: mod m { ... }
    - imports and re-exports: use path::Item; pub use path::Item;
    - type definitions: struct S { .. } enum E { .. } union U { .. }
    - trait definitions: trait T { .. }
    - impl blocks: impl T for S { .. } impl S { .. }
    - type aliases: type N = usize;
    - constants/statics: const N: usize = 0; static S: i32 = 1;
    - free functions: pub fn f() {}
    - macro definitions: macro_rules! Name { ( $($t:tt)* ) => { /* ... */ } }
    - attributes: crate-level #![deny(warnings)] and item-level #[cfg(test)]
    - extern crate name; (rarely needed in 2018+)
  - can't put in:
    - statements or expressions outside items: let x = 1; x + 1;
    - control flow outside functions: return; break; continue;

- UFCS (Uniform Function Call Syntax):
  - Purpose: fully qualify the trait implementation that provides an item: 
<Type as Trait>::item.
  - Why: disambiguate when multiple traits/inherent impls provide same names, 
and to call trait-associated items with no receiver (cannot infer Self).
  - Forms:
    - Method: <Type as Trait>::method(&value, args)
    - Associated function: <Type as Trait>::assoc_fn(args)
    - Associated const/type: <Type as Trait>::CONST, <Type as Trait>::AssocType
  - Must use when:
    - There is a name collision between traits or between trait and inherent 
impl.
    - Associated function returns Self and there is no expected type at the 
call site to pick the implementor.
    - Ambiguity cannot be resolved by imports/inference.
  - Avoiding UFCS:
    - Prefer method-call syntax when you have a receiver and the trait is in 
scope: value.method(args)
    - Provide an expected type then call: Trait::<Params>::assoc_fn(args)
    - Offer inherent wrappers (impl Type { fn new(...) -> Self { ... } }) and 
call Type::new(...)

- Core Rust Types:
  - Ownership/smart pointers
    - Box<T>: heap allocation, unique ownership
    - Rc<T>: single-thread ref-counted shared ownership
    - Arc<T>: atomic (thread-safe) ref-counted shared ownership
    - Weak<T>: non-owning weak ref to Rc/Arc
    - Pin<P>: prevents moving the pointee
  - Interior mutability
    - Cell<T>: copy in/out interior mutation
    - RefCell<T>: dynamic borrow-checked interior mutation
    - UnsafeCell<T>: primitive for interior mutability (unsafe code base)
  - References and raw pointers
    - &T, &mut T: shared/exclusive borrows
    - *const T, *mut T: raw pointers
    - NonNull<T>: non-null raw pointer
  - Option/Result/markers
    - Option<T>, Result<T, E>, Infallible (!), Never type (!)
    - PhantomData<T>, PhantomPinned
  - Uninitialized/ownership control
    - MaybeUninit<T>: uninitialized memory handling
    - ManuallyDrop<T>: suppress automatic Drop
  - Borrowed/owned switch
    - Cow<'a, T>: clone-on-write
  - Collections and strings
    - Vec<T>, VecDeque<T>, LinkedList<T>, BinaryHeap<T>
    - String, &str
    - HashMap<K, V>, BTreeMap<K, V>, HashSet<T>, BTreeSet<T>
    - OsString/OsStr, PathBuf/Path
  - Slices, arrays, ranges
    - [T; N] (array), &[T], &mut [T] (slices)
    - Range<T>, RangeInclusive<T>, RangeFrom<T>, RangeTo<T>, RangeFull
  - Concurrency primitives
    - Mutex<T>, RwLock<T>, Condvar, Barrier
    - Once, OnceLock<T>
    - std::sync::mpsc::{Sender<T>, Receiver<T>, SyncSender<T>}
  - Atomics
    - AtomicBool, AtomicIsize, AtomicUsize, AtomicI8/16/32/64/128, 
AtomicU8/16/32/64/128, AtomicPtr<T>
  - Threads/time
    - JoinHandle<T>, std::thread::Thread, std::thread::LocalKey<T>
    - Duration, Instant, SystemTime
  - FFI helpers
    - CString, CStr
  - Trait objects (type form)
    - Box<dyn Trait>, &dyn Trait, &mut dyn Trait

- Looping Syntax:
  - loop: loop { work(); if done { break; } }; with value: let r = loop { break 
42; };
  - while: while cond() { step(); }; while let Some(x) = it.next() { use_x(x); 
};
  - for over ranges: for i in 0..n { use_i(i); }; for i in 0..=n { use_i(i); }; 
for i in (0..n).rev() { use_i(i); };
  - for over iterators: for x in iter { f(x); }; for (i, x) in iter.enumerate() 
{ g(i, x); };
  - borrowing in for: for x in &v { read(x); }; for x in &mut v { *x += 1; };
  - labels: 'outer: for i in 0..n { for j in 0..m { break 'outer; } };
  - continue (with label): for i in 0..n { if skip(i) { continue; } do_i(i); }; 
'scan: loop { if skip() { continue 'scan; } break; };
  - break with value requires loop (not for/while): 'L: loop { break 'L 7; };
  - iterator-style looping (expression form): iter.for_each(|x| h(x));

- Importing a Macro:
  - Macros are invoked with '!' but imported without it. You cannot list a
    macro with '!' inside a brace import.
  - In a test file (e.g., tests/05_Test...rs) using LinkedListPer!:
    - Bring types/traits into scope:
      use apas_ai::LinkedListPer::{LinkedListPerS, LinkedListPerTrait};
    - Bring the macro name into scope separately (no '!'):
      use apas_ai::LinkedListPer;
    - Invoke the macro:
      LinkedListPer!(1, 2, 3);
  - Invalid (do not do):
      use apas_ai::LinkedListPer::{LinkedListPerS, LinkedListPerTrait,
      LinkedListPer!};
  - Alternative path invocation (when the macro is exported):
      apas_ai::LinkedListPer!(1, 2, 3);
  - If the macro is not #[macro_export], re-export it in src/lib.rs:
      pub use crate::LinkedListPer::LinkedListPer;
