//! Adjacency Table Graph Representation - Persistent Single-Threaded Implementation
//!
//! This module implements G = (V × (V set)) table representation where each vertex
//! maps to the set of its out-neighbors. Cost Specification 52.3.

pub mod AdjTableGraphStPer {

use crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::*;
use crate::Chap43Claude::OrderedTableStPer::OrderedTableStPer::*;
use crate::Types::Types::*;
use std::fmt::{Debug, Display};

/// Persistent single-threaded adjacency-table graph (struct product record type)
pub struct AdjTableGraphStPerS<V: StT + Ord + Clone + Debug + Display> {
    /// Adjacency table mapping each vertex to set of out-neighbors
    adj_table: OrderedTableStPer<V, AVLTreeSetStPer<V>>,
}

impl<V: StT + Ord + Clone + Debug + Display> AdjTableGraphStPerS<V> {
    /// Claude Work: O(1) - constant time initialization
    /// Claude Span: O(1) - constant time initialization
    pub fn new() -> Self {
        AdjTableGraphStPerS {
            adj_table: OrderedTableStPer::empty(),
        }
    }

    /// Insert an isolated vertex
    /// Claude Work: O(lg n) - table insert with empty set
    /// Claude Span: O(lg n) - table insert
    pub fn insert_vertex(self, v: V) -> Self {
        AdjTableGraphStPerS {
            adj_table: self.adj_table.insert(v, AVLTreeSetStPer::empty()),
        }
    }

    /// Delete an isolated vertex
    /// Claude Work: O(lg n) - table delete
    /// Claude Span: O(lg n) - table delete
    pub fn delete_vertex(self, v: V) -> Self {
        AdjTableGraphStPerS {
            adj_table: self.adj_table.delete(v),
        }
    }

    /// Insert a directed edge (u, v)
    /// Claude Work: O(lg n) - table lookup + set insert + table update
    /// Claude Span: O(lg n) - sequential operations
    pub fn insert_edge(self, u: V, v: V) -> Self {
        let neighbors = self.adj_table
            .find(&u)
            .map(|s| s.clone())
            .unwrap_or_else(|| AVLTreeSetStPer::empty())
            .insert(v);
        
        AdjTableGraphStPerS {
            adj_table: self.adj_table.insert(u, neighbors),
        }
    }

    /// Delete a directed edge (u, v)
    /// Claude Work: O(lg n) - table lookup + set delete + table update
    /// Claude Span: O(lg n) - sequential operations
    pub fn delete_edge(self, u: V, v: V) -> Self {
        if let Some(neighbors) = self.adj_table.find(&u) {
            let new_neighbors = neighbors.clone().delete(v);
            AdjTableGraphStPerS {
                adj_table: self.adj_table.insert(u, new_neighbors),
            }
        } else {
            self
        }
    }

    /// Check if edge (u, v) exists
    /// Claude Work: O(lg n) - table lookup + set contains
    /// Claude Span: O(lg n) - sequential operations
    pub fn has_edge(&self, u: &V, v: &V) -> bool {
        self.adj_table
            .find(u)
            .map(|neighbors| neighbors.find(v))
            .unwrap_or(false)
    }

    /// Get out-degree of a vertex
    /// Claude Work: O(lg n) - table lookup + set size
    /// Claude Span: O(lg n) - table lookup
//     pub fn out_degree(&self, v: &V) -> usize {
//         self.adj_table
//             .find(v)
//             .map(|neighbors| neighbors.size())
//             .unwrap_or(0)
//     }

    /// Get number of vertices
    /// Claude Work: O(1) - constant time
    /// Claude Span: O(1) - constant time
    pub fn vertex_count(&self) -> usize {
        self.adj_table.size()
    }

    /// Get number of edges
    /// Claude Work: O(n) - sum all neighbor set sizes
    /// Claude Span: O(lg n) - parallel reduction
    pub fn edge_count(&self) -> usize {
        self.adj_table
            .iter()
            .map(|(_, neighbors)| neighbors.size())
            .sum()
    }

    /// Map a function over all vertices
    /// Claude Work: O(n) - assuming f is O(1)
    /// Claude Span: O(lg n) - tree traversal
//     pub fn map_vertices<F, R>(&self, f: F) -> AVLTreeSetStPer<R>
//     where
//         F: Fn(&V) -> R,
//         R: StT,
//     {
//         let vertices: Vec<V> = self.adj_table.iter().map(|(v, _)| v).cloned().collect();
//         let mut result = AVLTreeSetStPer::empty();
//         for v in vertices {
//             result = result.insert(f(&v));
//         }
//         result
//     }

    /// Map a function over all edges
    /// Claude Work: O(m) - assuming f is O(1)
    /// Claude Span: O(lg n) - tree traversal
//     pub fn map_edges<F, R>(&self, f: F) -> AVLTreeSetStPer<R>
//     where
//         F: Fn(&V, &V) -> R,
//         R: StT,
//     {
//         let mut result = AVLTreeSetStPer::empty();
//         for (u, neighbors) in self.adj_table.iter() {
//             for v in neighbors.iter() {
//                 result = result.insert(f(u, v));
//             }
//         }
//         result
//     }

    /// Get out-neighbors of a vertex
    /// Claude Work: O(lg n + dg(v)) - table lookup
    /// Claude Span: O(lg n) - table lookup
//     pub fn out_neighbors(&self, v: &V) -> Option<AVLTreeSetStPer<V>> {
//         self.adj_table.find(v).map(|s| s.clone())
//     }

    /// Check if graph is empty
    /// Claude Work: O(1) - constant time check
    /// Claude Span: O(1) - constant time check
    pub fn is_empty(&self) -> bool {
        self.adj_table.size() == 0
    }

    /// Get reference to adjacency table
    pub fn adj_table(&self) -> &OrderedTableStPer<V, AVLTreeSetStPer<V>> {
        &self.adj_table
    }
}

impl<V: StT + Ord + Clone + Debug + Display> Default for AdjTableGraphStPerS<V> {
    fn default() -> Self {
        Self::new()
    }
}

impl<V: StT + Display> Display for AdjTableGraphStPerS<V> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "AdjTableGraphStPer(vertices={}, edges={})",
            self.vertex_count(),
            self.edge_count()
        )
    }
}

// /// Weighted adjacency-table graph with inline weights
// pub struct WeightedAdjTableGraphStPerS<V: StT + Ord + Clone + Debug + Display> {
//     /// Adjacency table mapping vertex to (neighbor → weight) table
//     adj_table: OrderedTableStPer<V, OrderedTableStPer<V, f64>>,
// }

// impl<V: StT + Ord + Clone + Debug + Display> WeightedAdjTableGraphStPerS<V> {
//     /// Create new weighted graph
//     /// Claude Work: O(1) - constant time initialization
//     /// Claude Span: O(1) - constant time initialization
//     pub fn new() -> Self {
//         WeightedAdjTableGraphStPerS {
//             adj_table: OrderedTableStPer::empty(),
//         }
//     }
// 
//     /// Insert weighted edge
//     /// Claude Work: O(lg n) - table operations
//     /// Claude Span: O(lg n) - sequential operations
//     pub fn insert_weighted_edge(self, u: V, v: V, weight: f64) -> Self {
//         let neighbors = self.adj_table
//             .find(&u)
//             .map(|t| t.clone())
//             .unwrap_or_else(|| OrderedTableStPer::empty())
//             .insert(v, weight);
//         
//         WeightedAdjTableGraphStPerS {
//             adj_table: self.adj_table.insert(u, neighbors),
//         }
//     }
// 
//     /// Get edge weight
//     /// Claude Work: O(lg n) - table lookups
//     /// Claude Span: O(lg n) - sequential lookups
//     pub fn get_weight(&self, u: &V, v: &V) -> Option<f64> {
//         self.adj_table
//             .find(u)
//             .and_then(|neighbors| neighbors.find(v).copied())
//     }
// 
//     /// Get number of vertices
//     pub fn vertex_count(&self) -> usize {
//         self.adj_table.size()
//     }
// 
//     /// Get adjacency table
//     pub fn adj_table(&self) -> &OrderedTableStPer<V, OrderedTableStPer<V, f64>> {
//         &self.adj_table
//     }
// }

// impl<V: StT + Ord + Clone + Debug + Display> Default for WeightedAdjTableGraphStPerS<V> {
//     fn default() -> Self {
//         Self::new()
//     }
// }

} // end mod AdjTableGraphStPer
