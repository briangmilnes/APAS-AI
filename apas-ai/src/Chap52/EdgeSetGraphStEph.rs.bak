//! Edge Set Graph Representation - Ephemeral Single-Threaded Implementation
//!
//! This module implements the ephemeral edge-set representation where updates
//! are performed in-place for better efficiency in sequential algorithms.

pub mod EdgeSetGraphStEph {

use crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::*;
use crate::Chap43Claude::OrderedTableStEph::OrderedTableStEph::*;
use crate::Types::Types::*;
use std::fmt::{Debug, Display};

/// Ephemeral single-threaded edge-set graph (struct product record type)

pub struct EdgeSetGraphStEphS<V: StT + Ord + Clone + Debug + Display> {
    /// Set of vertices
    vertices: AVLTreeSetStEph<V>,
    /// Set of directed edges (u, v)
    edges: AVLTreeSetStEph<Pair<V, V>>,
}

impl<V: StT + Ord + Clone + Debug + Display> EdgeSetGraphStEphS<V> {
    /// Claude Work: O(1) - constant time initialization
    /// Claude Span: O(1) - constant time initialization
    pub fn new() -> Self {
        EdgeSetGraphStEphS {
            vertices: AVLTreeSetStEph::empty(),
            edges: AVLTreeSetStEph::empty(),
        }
    }

    /// Insert an isolated vertex (ephemeral mutation)
    /// Claude Work: O(lg n) - tree-based set insert
    /// Claude Span: O(lg n) - tree-based set insert
    pub fn insert_vertex(&mut self, v: V) {
        self.vertices.insert(v);
    }

    /// Delete an isolated vertex (ephemeral mutation)
    /// Claude Work: O(lg n) - tree-based set delete
    /// Claude Span: O(lg n) - tree-based set delete
    pub fn delete_vertex(&mut self, v: &V) {
        self.vertices.delete(v);
    }

    /// Insert a directed edge (ephemeral mutation)
    /// Claude Work: O(lg n) - tree-based set insert
    /// Claude Span: O(lg n) - tree-based set insert
    pub fn insert_edge(&mut self, u: V, v: V) {
        self.edges.insert(Pair(u, v));
    }

    /// Delete a directed edge (ephemeral mutation)
    /// Claude Work: O(lg n) - tree-based set delete
    /// Claude Span: O(lg n) - tree-based set delete
    pub fn delete_edge(&mut self, u: &V, v: &V) {
        self.edges.delete(&(*u, *v));
    }

    /// Check if edge (u, v) exists
    /// Claude Work: O(lg n) - tree-based set find
    /// Claude Span: O(lg n) - tree-based set find
    pub fn has_edge(&self, u: &V, v: &V) -> bool {
        self.edges.find(&*u, *v)
    }

    /// Get number of vertices
    /// Claude Work: O(1) - constant time
    /// Claude Span: O(1) - constant time
    pub fn vertex_count(&self) -> usize {
        self.vertices.size()
    }

    /// Get number of edges
    /// Claude Work: O(1) - constant time
    /// Claude Span: O(1) - constant time
    pub fn edge_count(&self) -> usize {
        self.edges.size()
    }

    /// Get out-degree of a vertex
    /// Claude Work: O(m) - must scan all edges
    /// Claude Span: O(lg n) - sequential scan
//     pub fn out_degree(&self, v: &V) -> usize {
//         self.edges
//             .iter()
//             .filter(|(u, _)| u == v)
//             .count()
//     }

    /// Get in-degree of a vertex
    /// Claude Work: O(m) - must scan all edges
    /// Claude Span: O(lg n) - sequential scan
//     pub fn in_degree(&self, v: &V) -> usize {
//         self.edges
//             .iter()
//             .filter(|(_, w)| w == v)
//             .count()
//     }

    /// Map a function over all vertices
    /// Claude Work: O(n) - assuming f is O(1)
    /// Claude Span: O(lg n) - tree traversal
//     pub fn map_vertices<F, R>(&self, f: F) -> AVLTreeSetStEph<R>
//     where
//         F: Fn(&V) -> R,
//         R: StT,
//     {
//         self.vertices.map(f)
//     }

    /// Map a function over all edges
    /// Claude Work: O(m) - assuming f is O(1)
    /// Claude Span: O(lg n) - tree traversal
//     pub fn map_edges<F, R>(&self, f: F) -> AVLTreeSetStEph<R>
//     where
//         F: Fn(&(V, V)) -> R,
//         R: StT,
//     {
//         self.edges.map(f)
//     }

    /// Check if graph is empty
    /// Claude Work: O(1) - constant time check
    /// Claude Span: O(1) - constant time check
    pub fn is_empty(&self) -> bool {
        self.vertices.size() == 0
    }

    /// Get reference to vertex set
    pub fn vertices(&self) -> &AVLTreeSetStEph<V> {
        &self.vertices
    }

    /// Get reference to edge set
    pub fn edges(&self) -> &AVLTreeSetStEph<Pair<V, V>> {
        &self.edges
    }
}

impl<V: StT + Ord + Clone + Debug + Display> Default for EdgeSetGraphStEphS<V> {
    fn default() -> Self {
        Self::new()
    }
}

impl<V: StT + Display> Display for EdgeSetGraphStEphS<V> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EdgeSetGraphStEph(vertices={}, edges={})",
            self.vertex_count(),
            self.edge_count()
        )
    }
}

// /// Weighted edge-set graph with separate weight table (ephemeral)

// pub struct WeightedEdgeSetGraphStEphS<V: StT + Ord + Clone + Debug + Display> {
//     /// Base graph structure
//     graph: EdgeSetGraphStEphS<V>,
//     /// Weight table mapping edges to weights
//     weights: OrderedTableStEph<Pair<V, V>, f64>,
// }

// impl<V: StT + Ord + Clone + Debug + Display> WeightedEdgeSetGraphStEphS<V> {
//     /// Create new weighted graph
//     /// Claude Work: O(1) - constant time initialization
//     /// Claude Span: O(1) - constant time initialization
//     pub fn new() -> Self {
//         WeightedEdgeSetGraphStEphS {
//             graph: EdgeSetGraphStEphS::new(),
//             weights: OrderedTableStEph::empty(),
//         }
//     }
// 
//     /// Insert weighted edge (ephemeral mutation)
//     /// Claude Work: O(lg n) - insert edge + insert weight
//     /// Claude Span: O(lg n) - sequential operations
//     pub fn insert_weighted_edge(&mut self, u: V, v: V, weight: f64) {
//         self.graph.insert_edge(u, v);
//         self.weights.insert((u, v), weight);
//     }
// 
//     /// Get edge weight
//     /// Claude Work: O(lg n) - table lookup
//     /// Claude Span: O(lg n) - table lookup
//     pub fn get_weight(&self, u: &V, v: &V) -> Option<f64> {
//         self.weights.find(&Pair(u.clone(), v.clone())).copied()
//     }
// 
//     /// Update edge weight (ephemeral mutation)
//     /// Claude Work: O(lg n) - table update
//     /// Claude Span: O(lg n) - table update
//     pub fn set_weight(&mut self, u: &V, v: &V, weight: f64) {
//         self.weights.insert((*u, *v), weight);
//     }
// 
//     /// Access underlying graph
//     pub fn graph(&self) -> &EdgeSetGraphStEphS<V> {
//         &self.graph
//     }
// 
//     /// Mutable access to underlying graph
//     pub fn graph_mut(&mut self) -> &mut EdgeSetGraphStEphS<V> {
//         &mut self.graph
//     }
// }

// impl<V: StT + Ord + Clone + Debug + Display> Default for WeightedEdgeSetGraphStEphS<V> {
//     fn default() -> Self {
//         Self::new()
//     }
// }

} // end mod EdgeSetGraphStEph
