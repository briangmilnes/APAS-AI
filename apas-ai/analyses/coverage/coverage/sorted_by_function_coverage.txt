  107|      8|                Self::gcd(b, a % b)
  127|     48|            let hash_value = ((self.a * x + self.b) % self.p) as N;
  128|     48|            hash_value % table_size
  166|    270|                current_pos = (current_pos + h2_value) % table_size;
  172|     14|            let a = (seed * 1103515245 + 12345) % (self.p - 1) + 1; // Ensure a != 0
  173|     14|            let b = (a * 1103515245 + 12345) % self.p;
  182|  1.20k|                if sequence[i] == (sequence[i - 1] + 1) % sequence.len() {
  196|  3.28k|                    let pos = (i + self.c1 * probe_idx + self.c2 * probe_idx * probe_idx) % size;
  202|      3|            (h1 + probe_index * h2) % table_size
   20|     31|    pub fn is_divisible(n: N, i: N) -> B { if n % i == 0 { true } else { false } }
  211|    417|            (base_hash + probe_index) % table_size
  239|    230|            x = (x * 1103515245 + 12345) % (1i64 << 31); // Linear congruential generator
  240|    230|            result.push((x % 1000) as i32);
   24|      5|    pub fn is_even(x: &N) -> B { if *x % 2 == 0 { true } else { false } }
  248|       |        // Create a table with 50% load factor (Î± = 1/2)
  259|    560|                current_pos = (current_pos + h2_value) % table_size;
  274|     82|            (h1_value + probe_index * h2_value) % table_size
   28|    875|            (base_hash + probe_index) % table_size
  301|    450|            (base_hash + quadratic_offset) % table_size
  309|      4|            let mut candidate = if n % 2 == 0 { n + 1 } else { n };
  323|       |        // Estimate probe counts for 50% load factor
  325|      9|            if n % 2 == 0 {
  331|      6|                if n % i == 0 {
  350|       |        // Estimate probe counts for 50% load factor
   35|    390|            (h1 + probe_index * h2_safe) % table_size
  366|     60|                    hash_value % table_size
   36|    966|            (base_hash + quadratic_offset) % table_size
   42|       |        Minimal,  // < 10% performance degradation
   43|    228|                    if i % 2 == 0 {
   43|       |        Moderate, // 10-30% performance degradation
   44|     22|            if n % 2 == 1 { f(&result, a.nth(n - 1)) } else { result }
   44|       |        Severe,   // 30-50% performance degradation
   45|    332|                Self::gcd(b, a % b)
   45|       |        Critical, // > 50% performance degradation
   48|  1.38k|            (hasher.finish() as N) % table_size
   49|     68|            if n % 2 == 0 {
   51|     15|                if n % 2 == 0 { n } else { n - 1 },
   55|     15|            if n % 2 == 1 {
   55|     43|                if n % i == 0 {
   59|     22|            if n % 2 == 1 {
   70|    228|                    if i % 2 == 0 {
   72|  2.40k|            sum % table_size
   80|     15|                if n % 2 == 0 { n } else { n - 1 },
   84|     15|            if n % 2 == 1 {
   96|  1.81k|                hash_value = (hash_value + (ch as N) * power) % table_size;
   97|  1.81k|                power = (power * self.base) % table_size;
