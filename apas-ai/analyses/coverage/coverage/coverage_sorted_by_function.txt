   31|      1|            ArraySeqStEphS::from_vec(vec![i64::MAX, -4, 0]),
   62|      1|            ArraySeqStEphS::from_vec(vec![i64::MAX, -3, 0, i64::MAX]),
  170|       |    (keys: [$($k:expr),* $(,)?], probs: [$($p:expr),* $(,)?]) => {
  208|       |    (keys: [$($k:expr),* $(,)?], probs: [$($p:expr),* $(,)?]) => {
  239|       |    (keys: [$($k:expr),* $(,)?], probs: [$($p:expr),* $(,)?]) => {
  309|       |        (keys: [$($k:expr),* $(,)?], probs: [$($p:expr),* $(,)?]) => {
  347|       |        ($size:expr, $(($key:expr, $value:expr)),* $(,)?) => {{
  172|       |    (dims: [$(($r:expr, $c:expr)),* $(,)?]) => {
  209|       |        (dims: [$(($r:expr, $c:expr)),* $(,)?]) => {
  230|       |        (dims: [$(($r:expr, $c:expr)),* $(,)?]) => {
  300|       |        (dims: [$(($r:expr, $c:expr)),* $(,)?]) => {
  171|       |    (source: [$($s:expr),* $(,)?], target: [$($t:expr),* $(,)?]) => {
  172|       |    (source: [$($s:expr),* $(,)?], target: [$($t:expr),* $(,)?]) => {
  211|       |    (source: [$($s:expr),* $(,)?], target: [$($t:expr),* $(,)?]) => {
  222|       |    (source: [$($s:expr),* $(,)?], target: [$($t:expr),* $(,)?]) => {
  112|       |        ( $( ($a:expr, $b:expr) ),* $(,)? ) => {{
  122|       |        ( $( ($a:expr, $b:expr) ),* $(,)? ) => {{
  144|       |    ($($x:expr),* $(,)?) => {
  147|       |        ($($x:expr),+ $(,)?) => {{
  154|       |        ( $( $x:expr ),* $(,)? ) => {{
  164|       |    ($($x:expr),* $(,)?) => {
  169|       |    ($($x:expr),* $(,)?) => {
  188|       |    ($($x:expr),* $(,)?) => {
  193|       |        ( $( $x:expr ),* $(,)? ) => {{
  201|       |        ($($x:expr),* $(,)?) => {{
  204|       |        ( $( $x:expr ),* $(,)? ) => {{
  215|       |        ( $( $x:expr ),* $(,)? ) => {{
  217|       |        ( $( $x:expr ),* $(,)? ) => {{
  220|       |        ( $( $x:expr ),* $(,)? ) => {{
  220|       |        ($($x:expr),+ $(,)?) => {{
  228|       |        ( $( $x:expr ),* $(,)? ) => {{
  231|       |        ( $( ($k:expr, $v:expr) ),* $(,)? ) => {{
  236|       |        ($($x:expr),* $(,)?) => { $crate::Chap19::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS::from_vec(vec![$($x),*]) };
  250|       |        ( $( $x:expr ),* $(,)? ) => {{
  250|       |        ( $( $x:expr ),* $(,)? ) => {{
  250|       |        ($($x:expr),* $(,)?) => {
  256|       |        ($($x:expr),* $(,)?) => { $crate::Chap19::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS::from_vec(vec![$($x),*]) };
  257|       |        ( $( $x:expr ),* $(,)? ) => {{
  266|       |        ( $( $x:expr ),* $(,)? ) => {{
  267|       |        ($($x:expr),* $(,)?) => {{
  268|       |        ($($x:expr),* $(,)?) => {
  271|       |        ($($x:expr),* $(,)?) => {{
  272|       |        ( $( $x:expr ),* $(,)? ) => {{
  272|       |        ( $( $x:expr ),* $(,)? ) => {{
  272|       |        ( $( $x:expr ),* $(,)? ) => {{
  272|       |        ( $( $x:expr ),* $(,)? ) => {{
  272|       |        ( $( $x:expr ),* $(,)? ) => {{
  272|       |        ( $( $x:expr ),* $(,)? ) => {{
  274|       |        ( $( $x:expr ),* $(,)? ) => {{
  292|       |    ($($x:expr),* $(,)?) => {{
  294|       |        ( $( $x:expr ),* $(,)? ) => {{
  298|       |        ( $( $x:expr ),* $(,)? ) => {{
  298|       |        ($($x:expr),* $(,)?) => {{
  300|       |        ($($elem:expr),+ $(,)?) => {
  302|       |        ($($x:expr),* $(,)?) => { $crate::Chap18::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS::from_vec(vec![$($x),*]) };
  310|       |        ( $( $x:expr ),* $(,)? ) => {{
  310|       |        ($($x:expr),* $(,)?) => { $crate::Chap18::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS::from_vec(vec![$($x),*]) };
  311|       |        ( $( $x:expr ),* $(,)? ) => {{
  322|       |        ($($elem:expr),+ $(,)?) => {
  323|       |        ($($x:expr),* $(,)?) => { $crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::ArraySeqMtPerS::from_vec(vec![$($x),*]) };
  330|       |        ($($x:expr),* $(,)?) => { $crate::Chap19::ArraySeqMtPer::ArraySeqMtPer::ArraySeqMtPerS::from_vec(vec![$($x),*]) };
  332|       |        ($($x:expr),* $(,)?) => {{
  338|       |        ( $( ($a:expr, $b:expr) ),* $(,)? ) => {
  339|       |            vec![ $( $crate::EdgeLit!($a, $b) ),* ]
  342|       |        ( $( ($k:expr, $v:expr) ),* $(,)? ) => {{
  348|       |        ( $( ($a:expr, $b:expr) ),* $(,)? ) => {
  349|       |            vec![ $( $crate::PairLit!($a, $b) ),* ]
  354|       |        ($($x:expr),* $(,)?) => {{
  355|       |        ( $( $x:expr ),* $(,)? ) => {{
  379|       |        ($($elem:expr),+ $(,)?) => {
  381|       |        ($($x:expr),* $(,)?) => { $crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::ArraySeqMtEphS::from_vec(vec![$($x),*]) };
  395|       |        ($($x:expr),* $(,)?) => {{
  421|       |        ($($x:expr),* $(,)?) => { $crate::Chap18::LinkedListStPer::LinkedListStPer::LinkedListStPerS::from_vec(vec![$($x),*]) };
  430|       |        ($($x:expr),* $(,)?) => { $crate::Chap19::ArraySeqMtEphSlice::ArraySeqMtEphSlice::ArraySeqMtEphSliceS::from_vec(vec![$($x),*]) };
  431|       |        ($($x:expr),* $(,)?) => { $crate::Chap18::LinkedListStEph::LinkedListStEph::LinkedListStEphS::from_vec(vec![$($x),*]) };
  445|       |        ( $( $x:expr ),* $(,)? ) => {{
  322|       |            $crate::Types::Types::Edge($a, $b)
  329|       |            $crate::Types::Types::Pair($a, $b)
  321|       |        ($a:expr, $b:expr) => {
  328|       |        ($a:expr, $b:expr) => {
  174|       |            vec![$($crate::Types::Types::Pair($r, $c)),*]
  211|       |                vec![$($crate::Types::Types::Pair($r, $c)),*]
  232|       |                vec![$($crate::Types::Types::Pair($r, $c)),*]
  302|       |                vec![$($crate::Types::Types::Pair($r, $c)),*]
  110|       |            < $crate::Chap05::MappingStEph::MappingStEph::Mapping<_, _> as $crate::Chap05::MappingStEph::MappingStEph::MappingStEphTrait<_, _> >::FromRelation(& $crate::RelationLit![])
  122|       |            < $crate::Chap05::MappingStEph::MappingStEph::Mapping<_, _> as $crate::Chap05::MappingStEph::MappingStEph::MappingStEphTrait<_, _> >::FromVec(__pairs)
  120|       |            < $crate::Chap05::RelationStEph::RelationStEph::Relation<_, _> as $crate::Chap05::RelationStEph::RelationStEph::RelationStEphTrait<_, _> >::FromSet(__pairs)
  128|       |            < $crate::Chap05::RelationStEph::RelationStEph::Relation<_, _> as $crate::Chap05::RelationStEph::RelationStEph::RelationStEphTrait<_, _> >::FromSet(__pairs)
  269|       |            < $crate::Chap05::SetStEph::SetStEph::Set<_> >::empty()
  365|       |            < $crate::Chap06::DirGraphMtEph::DirGraphMtEph::DirGraphMtEph<_> as $crate::Chap06::DirGraphMtEph::DirGraphMtEph::DirGraphMtEphTrait<_> >::FromSets(__V, __A)
  374|       |            < $crate::Chap06::DirGraphMtEph::DirGraphMtEph::DirGraphMtEph<_> as $crate::Chap06::DirGraphMtEph::DirGraphMtEph::DirGraphMtEphTrait<_> >::FromSets(__V, __A)
  174|       |            < $crate::Chap06::DirGraphStEph::DirGraphStEph::DirGraphStEph<_> as $crate::Chap06::DirGraphStEph::DirGraphStEph::DirGraphStEphTrait<_> >::FromSets(__V, __A)
  183|       |            < $crate::Chap06::DirGraphStEph::DirGraphStEph::DirGraphStEph<_> as $crate::Chap06::DirGraphStEph::DirGraphStEph::DirGraphStEphTrait<_> >::FromSets(__V, __A)
  235|       |            < $crate::Chap06::LabDirGraphMtEph::LabDirGraphMtEph::LabDirGraphMtEph<_, _> as $crate::Chap06::LabDirGraphMtEph::LabDirGraphMtEph::LabDirGraphMtEphTrait<_, _> >::empty()
  240|       |            < $crate::Chap06::LabDirGraphMtEph::LabDirGraphMtEph::LabDirGraphMtEph<_, _> as $crate::Chap06::LabDirGraphMtEph::LabDirGraphMtEph::LabDirGraphMtEphTrait<_, _> >::from_vertices_and_labeled_arcs(vertices, labeled_arcs)
  145|       |            < $crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::LabDirGraphStEph<_, _> as $crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::LabDirGraphStEphTrait<_, _> >::empty()
  150|       |            < $crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::LabDirGraphStEph<_, _> as $crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::LabDirGraphStEphTrait<_, _> >::from_vertices_and_labeled_arcs(vertices, labeled_arcs)
  227|       |            < $crate::Chap06::LabUnDirGraphMtEph::LabUnDirGraphMtEph::LabUnDirGraphMtEph<_, _> as $crate::Chap06::LabUnDirGraphMtEph::LabUnDirGraphMtEph::LabUnDirGraphMtEphTrait<_, _> >::empty()
  243|       |            < $crate::Chap06::LabUnDirGraphMtEph::LabUnDirGraphMtEph::LabUnDirGraphMtEph<_, _> as $crate::Chap06::LabUnDirGraphMtEph::LabUnDirGraphMtEph::LabUnDirGraphMtEphTrait<_, _> >::from_vertices_and_labeled_edges(vertices, labeled_edges)
  177|       |            < $crate::Chap06::LabUnDirGraphStEph::LabUnDirGraphStEph::LabUnDirGraphStEph<_, _> as $crate::Chap06::LabUnDirGraphStEph::LabUnDirGraphStEph::LabUnDirGraphStEphTrait<_, _> >::empty()
  193|       |            < $crate::Chap06::LabUnDirGraphStEph::LabUnDirGraphStEph::LabUnDirGraphStEph<_, _> as $crate::Chap06::LabUnDirGraphStEph::LabUnDirGraphStEph::LabUnDirGraphStEphTrait<_, _> >::from_vertices_and_labeled_edges(vertices, labeled_edges)
  238|       |            < $crate::Chap06::UnDirGraphMtEph::UnDirGraphMtEph::UnDirGraphMtEph<_> as $crate::Chap06::UnDirGraphMtEph::UnDirGraphMtEph::UnDirGraphMtEphTrait<_> >::FromSets(__V, __E)
  247|       |            < $crate::Chap06::UnDirGraphMtEph::UnDirGraphMtEph::UnDirGraphMtEph<_> as $crate::Chap06::UnDirGraphMtEph::UnDirGraphMtEph::UnDirGraphMtEphTrait<_> >::FromSets(__V, __E)
  153|       |            < $crate::Chap06::UnDirGraphStEph::UnDirGraphStEph::UnDirGraphStEph<_> as $crate::Chap06::UnDirGraphStEph::UnDirGraphStEph::UnDirGraphStEphTrait<_> >::FromSets(__V, __E)
  162|       |            < $crate::Chap06::UnDirGraphStEph::UnDirGraphStEph::UnDirGraphStEph<_> as $crate::Chap06::UnDirGraphStEph::UnDirGraphStEph::UnDirGraphStEphTrait<_> >::FromSets(__V, __E)
  289|       |        < $crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::AVLTreeSeqStPerS<_> as
  294|       |        < $crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::AVLTreeSeqStPerS<_> as
  264|       |            < $crate::Chap37::BSTAVLMtEph::BSTAVLMtEph::BSTAVLMtEph<_> as $crate::Chap37::BSTAVLMtEph::BSTAVLMtEph::BSTAVLMtEphTrait<_> >::new()
  248|       |            < $crate::Chap37::BSTAVLStEph::BSTAVLStEph::BSTAVLStEph<_> as $crate::Chap37::BSTAVLStEph::BSTAVLStEph::BSTAVLStEphTrait<_> >::new()
  255|       |            < $crate::Chap37::BSTBBAlphaMtEph::BSTBBAlphaMtEph::BSTBBAlphaMtEph<_> as $crate::Chap37::BSTBBAlphaMtEph::BSTBBAlphaMtEph::BSTBBAlphaMtEphTrait<_> >::new()
  270|       |            < $crate::Chap37::BSTBBAlphaStEph::BSTBBAlphaStEph::BSTBBAlphaStEph<_> as $crate::Chap37::BSTBBAlphaStEph::BSTBBAlphaStEph::BSTBBAlphaStEphTrait<_> >::new()
  309|       |            < $crate::Chap37::BSTRBMtEph::BSTRBMtEph::BSTRBMtEph<_> as $crate::Chap37::BSTRBMtEph::BSTRBMtEph::BSTRBMtEphTrait<_> >::new()
  272|       |            < $crate::Chap37::BSTRBStEph::BSTRBStEph::BSTRBStEph<_> as $crate::Chap37::BSTRBStEph::BSTRBStEph::BSTRBStEphTrait<_> >::new()
  270|       |            < $crate::Chap37::BSTSetAVLMtEph::BSTSetAVLMtEph::BSTSetAVLMtEph<_> as $crate::Chap37::BSTSetAVLMtEph::BSTSetAVLMtEph::BSTSetAVLMtEphTrait<_> >::empty()
  270|       |            < $crate::Chap37::BSTSetBBAlphaMtEph::BSTSetBBAlphaMtEph::BSTSetBBAlphaMtEph<_> as $crate::Chap37::BSTSetBBAlphaMtEph::BSTSetBBAlphaMtEph::BSTSetBBAlphaMtEphTrait<_> >::empty()
  353|       |            < $crate::Chap37::BSTSetPlainMtEph::BSTSetPlainMtEph::BSTSetPlainMtEph<_> as $crate::Chap37::BSTSetPlainMtEph::BSTSetPlainMtEph::BSTSetPlainMtEphTrait<_> >::empty()
  270|       |            < $crate::Chap37::BSTSetRBMtEph::BSTSetRBMtEph::BSTSetRBMtEph<_> as $crate::Chap37::BSTSetRBMtEph::BSTSetRBMtEph::BSTSetRBMtEphTrait<_> >::empty()
  270|       |            < $crate::Chap37::BSTSetSplayMtEph::BSTSetSplayMtEph::BSTSetSplayMtEph<_> as $crate::Chap37::BSTSetSplayMtEph::BSTSetSplayMtEph::BSTSetSplayMtEphTrait<_> >::empty()
  215|       |            < $crate::Chap37::BSTSplayMtEph::BSTSplayMtEph::BSTSplayMtEph<_> as $crate::Chap37::BSTSplayMtEph::BSTSplayMtEph::BSTSplayMtEphTrait<_> >::new()
  191|       |            < $crate::Chap37::BSTSplayStEph::BSTSplayStEph::BSTSplayStEph<_> as $crate::Chap37::BSTSplayStEph::BSTSplayStEph::BSTSplayStEphTrait<_> >::new()
  202|       |            < $crate::Chap38::BSTParaStEph::BSTParaStEph::ParamBST<_> as $crate::Chap38::BSTParaStEph::BSTParaStEph::ParamBSTTrait<_> >::new()
  443|       |            < $crate::Chap39::BSTParaTreapMtEph::BSTParaTreapMtEph::ParamTreap<_> as $crate::Chap39::BSTParaTreapMtEph::BSTParaTreapMtEph::ParamTreapTrait<_> >::new()
  270|       |            < $crate::Chap39::BSTSetTreapMtEph::BSTSetTreapMtEph::BSTSetTreapMtEph<_> as $crate::Chap39::BSTSetTreapMtEph::BSTSetTreapMtEph::BSTSetTreapMtEphTrait<_> >::empty()
  248|       |            < $crate::Chap39::BSTTreapMtEph::BSTTreapMtEph::BSTTreapMtEph<_> as $crate::Chap39::BSTTreapMtEph::BSTTreapMtEph::BSTTreapMtEphTrait<_> >::new()
  226|       |            < $crate::Chap39::BSTTreapStEph::BSTTreapStEph::BSTTreapStEph<_> as $crate::Chap39::BSTTreapStEph::BSTTreapStEph::BSTTreapStEphTrait<_> >::new()
  229|       |            < $crate::Chap40::BSTKeyValueStEph::BSTKeyValueStEph::BSTKeyValueStEph<_, _> as $crate::Chap40::BSTKeyValueStEph::BSTKeyValueStEph::BSTKeyValueStEphTrait<_, _> >::new()
  340|       |            < $crate::Chap40::BSTReducedStEph::BSTReducedStEph::BSTReducedStEph<_, _, _, _> as $crate::Chap40::BSTReducedStEph::BSTReducedStEph::BSTReducedStEphTrait<_, _, _, _> >::new()
  296|       |            < $crate::Chap40::BSTSizeStEph::BSTSizeStEph::BSTSizeStEph<_> as $crate::Chap40::BSTSizeStEph::BSTSizeStEph::BSTSizeStEphTrait<_> >::new()
  173|       |            < $crate::Chap41::ArraySetEnumMtEph::ArraySetEnumMtEph::ArraySetEnumMtEph as $crate::Chap41::ArraySetEnumMtEph::ArraySetEnumMtEph::ArraySetEnumMtEphTrait >::empty($u)
  152|       |            < $crate::Chap41::ArraySetStEph::ArraySetStEph::ArraySetStEph<_> as $crate::Chap41::ArraySetStEph::ArraySetStEph::ArraySetStEphTrait<_> >::empty()
  292|       |            < $crate::Chap41::AVLTreeSetMtEph::AVLTreeSetMtEph::AVLTreeSetMtEph<_> as $crate::Chap41::AVLTreeSetMtEph::AVLTreeSetMtEph::AVLTreeSetMtEphTrait<_> >::empty()
  308|       |            < $crate::Chap41::AVLTreeSetMtPer::AVLTreeSetMtPer::AVLTreeSetMtPer<_> as $crate::Chap41::AVLTreeSetMtPer::AVLTreeSetMtPer::AVLTreeSetMtPerTrait<_> >::empty()
  218|       |            < $crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::AVLTreeSetStEph<_> as $crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::AVLTreeSetStEphTrait<_> >::empty()
  213|       |            < $crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::AVLTreeSetStPer<_> as $crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::AVLTreeSetStPerTrait<_> >::empty()
  394|       |            $crate::Chap43::AugOrderedTableStEph::AugOrderedTableStEph::AugOrderedTableStEphTrait::empty($reducer, $identity)
  427|       |            $crate::Chap43::AugOrderedTableMtEph::AugOrderedTableMtEph::AugOrderedTableMtEphTrait::empty($reducer, $identity)
  429|       |            $crate::Chap43::AugOrderedTableStPer::AugOrderedTableStPer::AugOrderedTableStPerTrait::empty($reducer, $identity)
  359|       |        ($name:ident, $key_type:ty, $hash_expr:expr, $desc:expr) => {
  256|       |        ( $left:expr, $right:expr ) => {{
  377|       |            $crate::Chap18::ArraySeq::ArraySeq::ArraySeqS::from_vec(vec![$elem; $len])
  376|       |        ($elem:expr; $len:expr) => {
  142|       |        ($x:expr; $n:expr) => {{
  215|       |        ($x:expr; $n:expr) => {{
  235|       |        ($x:expr; $n:expr) => { $crate::Chap19::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS::from_vec(vec![$x; $n]) };
  247|       |        ($x:expr; $n:expr) => {
  255|       |        ($x:expr; $n:expr) => { $crate::Chap19::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS::from_vec(vec![$x; $n]) };
  287|       |    ($x:expr; $n:expr) => {{
  301|       |        ($x:expr; $n:expr) => { $crate::Chap18::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS::from_vec(vec![$x; $n]) };
  309|       |        ($x:expr; $n:expr) => { $crate::Chap18::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS::from_vec(vec![$x; $n]) };
  322|       |        ($x:expr; $n:expr) => { $crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::ArraySeqMtPerS::from_vec(vec![$x; $n]) };
  327|       |        ($x:expr; $n:expr) => {{
  329|       |        ($x:expr; $n:expr) => { $crate::Chap19::ArraySeqMtPer::ArraySeqMtPer::ArraySeqMtPerS::from_vec(vec![$x; $n]) };
  380|       |        ($x:expr; $n:expr) => { $crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::ArraySeqMtEphS::from_vec(vec![$x; $n]) };
  420|       |        ($x:expr; $n:expr) => { $crate::Chap18::LinkedListStPer::LinkedListStPer::LinkedListStPerS::from_vec(vec![$x; $n]) };
  429|       |        ($x:expr; $n:expr) => { $crate::Chap19::ArraySeqMtEphSlice::ArraySeqMtEphSlice::ArraySeqMtEphSliceS::from_vec(vec![$x; $n]) };
  430|       |        ($x:expr; $n:expr) => { $crate::Chap18::LinkedListStEph::LinkedListStEph::LinkedListStEphS::from_vec(vec![$x; $n]) };
  386|       |        (reducer: $reducer:expr, identity: $identity:expr, $($k:expr => $v:expr),* $(,)?) => {{
  393|       |        (reducer: $reducer:expr, identity: $identity:expr) => {{
  419|       |        (reducer: $reducer:expr, identity: $identity:expr, $($k:expr => $v:expr),* $(,)?) => {{
  421|       |        (reducer: $reducer:expr, identity: $identity:expr, $($k:expr => $v:expr),* $(,)?) => {{
  426|       |        (reducer: $reducer:expr, identity: $identity:expr) => {{
  428|       |        (reducer: $reducer:expr, identity: $identity:expr) => {{
  172|       |        ( $u:expr ; ) => {{
  175|       |        ( $u:expr ; $( $x:expr ),* $(,)? ) => {{
  187|       |                        $crate::Types::Types::LabEdge($v2, $v1, $label)
  237|       |                        $crate::Types::Types::LabEdge($v2, $v1, $label)
  185|       |                        $crate::Types::Types::LabEdge($v1, $v2, $label)
  235|       |                        $crate::Types::Types::LabEdge($v1, $v2, $label)
  128|       |            $crate::Chap23::BalBinTreeStEph::BalBinTreeStEph::BalBinNode::new($left, $value, $right)
  248|       |            $crate::Chap17::MathSeq::MathSeq::MathSeqS::with_len($n, $x)
  130|     17|                    avg_cluster_size: 0.0,
  131|     17|                    clustering_coefficient: 0.0,
  132|     17|                    probe_variance: 0.0,
  140|      0|                    hash_function_independence: 0.0,
  142|      0|                    collision_avoidance_score: 0.0,
  166|      1|                    avg_chain_length: 0.0,
  167|      1|                    secondary_clustering_coefficient: 0.0,
  168|      1|                    probe_sequence_diversity: 0.0,
  178|      0|                    avg_chain_length: 0.0,
  179|      0|                    secondary_clustering_coefficient: 0.0,
  180|      0|                    probe_sequence_diversity: 0.0,
  273|     16|                avg_chain_length: 0.0,
  368|      1|                overall_clustering_score: 0.0,
   61|      1|                    avg_cluster_size: 0.0,
   62|      1|                    clustering_coefficient: 0.0,
   63|      1|                    probe_variance: 0.0,
   72|      0|                    avg_cluster_size: 0.0,
   73|      0|                    clustering_coefficient: 0.0,
   74|      0|                    probe_variance: 0.0,
  121|      4|                return 0;
  123|      4|                | (0, j) => j, // Insert all remaining characters from T
  124|    554|                                rank: 0, // rank will be recalculated
  125|      4|                | (0, j) => j, // Insert all remaining characters from T
  128|     17|                    total_clusters: 0,
  129|     17|                    max_cluster_size: 0,
  132|      4|            sort(self, 0, n);
  133|      2|                return 0;
  136|    170|                                rank: 0, // rank will be recalculated
  137|      0|                    probe_sequence_length: 0,
  138|      0|                    unique_probe_positions: 0,
  139|      0|                    probe_sequence_period: 0,
  140|      0|                | 0 => PrimTreeSeqStTree::Zero,
  160|      2|                return 0;
  164|      1|                    collision_chains: 0,
  165|      1|                    max_chain_length: 0,
  169|      2|            sort(self, 0, n);
  175|      2|                return 0;
  176|      0|                    collision_chains: 0,
  177|      0|                    max_chain_length: 0,
  247|      1|                index: 0,
  271|     16|                num_collisions: 0,
  272|     16|                max_chain_length: 0,
   29|  20.5M|                left_size: 0,
   30|      1|            ArraySeqStEphS::from_vec(vec![i64::MAX, 0, 2]),
   30|  20.5M|                right_size: 0,
   33|      1|            ArraySeqStEphS::from_vec(vec![i64::MAX, 0, 3, i64::MAX]),
   33|      2|                num_elements: 0,
   34|     39|                left_size: 0,
   35|     39|                right_size: 0,
   48|     24|                num_elements: 0,
   53|     29|                num_elements: 0,
   56|     28|                | (0, j) => j, // Base case: need j insertions
   57|     50|                | (0, _) => false, // Base case: no elements left, target > 0
   59|      1|                    total_clusters: 0,
   60|      1|                    max_cluster_size: 0,
   61|      1|            ArraySeqStEphS::from_vec(vec![i64::MAX, 0, 1, 1]),
   61|     55|                | (0, _) => false, // Base case: no elements left, target > 0
   63|    126|                num_elements: 0,
   64|    126|                num_deleted: 0,
   65|      4|                | (0, j) => j, // Insert all remaining characters from T
   65|      8|                | (0, j) => j, // Base case: need j insertions
   66|      0|                return 0;
   66|     31|                | (0, _) => false, // Base case: no elements left, target > 0
   68|      4|                | (0, j) => j, // Insert all remaining characters from T
   69|   578k|                next_key: 0,
   70|      0|                    total_clusters: 0,
   70|      3|                | (0, j) => j, // Insert all remaining characters from T
   70|      3|                | (0, j) => j, // Insert all remaining characters from T
   71|      0|                    max_cluster_size: 0,
   71|     48|                | (0, _) => false, // Base case: no elements left, target > 0
   71|     65|                | (0, j) => j, // Base case: need j insertions
   76|      0|                return 0;
   81|     22|                | (0, j) => j, // Base case: need j insertions
   84|      4|            sort(self, 0, n);
   85|      0|                return 0;
   85|      1|            ArraySeqStEphS::from_vec(vec![i64::MAX, 0, -5]),
   90|     46|                next_key: 0,
   92|      0|                return 0;
   98|      1|                | 0 => PrimTreeSeqStTree::Zero,
   99|      0|                return 0;
   81|    107|                range: 0..len,
  100|       |                | _ => {
  100|      0|            write!(f, "[")?;
  100|     10|                candidate += 1;
  100|     14|            total += *w;
  100|      1|            Self {
  100|      1|        table = table.insert("B".to_string(), "B_value".to_string());
  100|     25|    ) {
  250|      1|            ("Large (100 elements)".to_string(), large_example(100)),
  100|     46|    ) {
  100|    463|                    h.left = x.right.take();
  100|      4|    ) -> Set<Edge<V>> {
  100|      5|            AllPairsResultStPerInt {
  100|      5|                let _ = row.set(v, pred);
  100|    907|            left > ALPHA * total || right > ALPHA * total
  101|       |                | (
  101|      0|    ) -> (AVLTreeSetStPer<N>, Vec<N>) {
  101|      0|                    ParaPair!(move || parallel_out(left_arcs, v_left), move || parallel_out(
  101|    104|            pq = pq.insert(element.clone());
  101|    110|                    y.left = Some(x);
  101|  1.32k|                    y.left = Some(x);
  101|     13|                let _ = quotient_edges.insert(new_edge);
  101|      1|            EdgeSetGraphStPer {
  101|      1|        table = table.insert("D".to_string(), "D_value".to_string());
  101|    251|                current = node.next.as_deref();
  101|     30|    ) {
  101|      3|            OrderedTableMtEph {
  101|      4|                            insertion_pos = Some(hash_pos);
  101|      4|            Self {
  101|      5|                let _ = self.predecessors.set(u, row);
  101|      7|                result = result.union(&ng_u);
  101|     96|                        1 + std::cmp::min(delete_cost, insert_cost)
  102|    110|                    *link = Some(y);
  102|  1.32k|                    *link = Some(y);
  102|     18|            Self {
  102|      1|                    FlatEntry::Empty => return false,
  102|      1|        table = table.insert("E".to_string(), "E_value".to_string());
  102|      1|                u != &v_clone2 && w != &v_clone2
  102|    216|            vals = parallel_sort(vals);
  102|    222|            let _ = partition_map.insert(vertex.clone(), center.clone());
  102|    251|                i += 1;
  102|    307|            new_elements = ArraySeqStPerS::append(&new_elements, &new_elem_seq);
  102|     30|    ) -> (AVLTreeSetStPer<N>, AVLTreeSetStPer<N>) {
  102|     31|                0 // Base case: single matrix, no multiplication needed
  102|    463|                    x.color = h.color;
  102|      5|            AllPairsResultStPerFloat {
  102|      5|                let _ = row.set(v, pred);
  102|      8|            AdjTableGraphStPer { adj: new_adj }
  102|       |                    LeftistHeapNode::Node {
  103|      0|                    write!(f, ", ")?;
  103|     11|                    let _ = self.adj.set(u, ArraySeqStEphS::from_vec(new_neighbors_vec));
  103|     19|            solver.memo.clear(); // Fresh memo for each query
  103|      1|    ) -> bool {
  103|      1|                    FlatEntry::Deleted | FlatEntry::Occupied(_, _) => {
  103|      1|        table = table.insert("A".to_string(), "A_value".to_string());
  103|      2|            Self {
  103|      2|                    write!(f, ", ")?;
  103|    463|                    h.color = Color::Red;
  103|      4|                    edge_found = true;
  103|      5|                    continue; // Skip the current edge
  103|      5|                let _ = self.predecessors.set(u, row);
  103|      8|            visited.size() == self.vertices().size()
  104|      0|                    *link = Some(x);
  104|      0|                    *link = Some(x);
  104|  1.00k|                &|i| {
  104|     11|                    h.left = x.right.take();
  104|      1|                        attempt += 1;
  104|      1|    ) -> bool {
  104|      1|            EdgeSetGraphMtPer {
  104|      1|        table = table.insert("F".to_string(), "F_value".to_string());
  104|    216|            AVLTreeSetMtPer {
  104|     21|                    thread::spawn(move || {
  104|     21|                    thread::spawn(move || {
  104|     26|            solver.memo.clear(); // Fresh memo for each query
  104|    463|                    x.right = Some(h);
  104|      7|                table[i - 1][j - 1]
  105|      0|                write!(f, "{}", item)?;
  105|      1|                    first = false;
  105|      1|            Self {
  105|     23|                    x.left = y.right.take();
  105|      2|                    count += 1;
  105|      2|            OrderedSetStPer {
  105|      2|            Self {
  105|      4|                    write!(f, ", ")?;
  105|    608|                        *guard = Some(Node::new(value));
  106|      0|                    ParaPair!(move || parallel_neighbors(left_edges, v_left), move || {
  106|     11|                    x.color = h.color;
  106|     14|                new_neighbors = new_neighbors.union(&neighbors);
  106|    158|                let _ = centers.insert(vertex.clone());
  106|      1|            self.base_set = result;
  106|     20|        let _ = visited.set(vertex, true);
  106|     21|                print!(", ");
  106|      2|        ) -> ArraySeqMtEphS<U> {
  106|    598|                probe_index += 1;
  106|      5|            Self {
  106|     67|                    let _ = merged.insert(v, (neighbor, w, label));
  106|     68|                    .map(|k| {
  106|      7|            hash_val % table.current_size
  106|     89|            self.root = node;
  106|      8|                table[i - 1][j - 1]
  106|       |    /// - graph: The undirected graph
  106|       |            OrderedTableStPer {
  106|       |    /// - vertices: Set of vertices
  107|      0|            write!(f, "]")
  107|     11|                    h.color = Color::Red;
  107|      1|                AdjTableGraphMtPer {
  107|     21|                    result = result.insert(elem.clone());
  107|     23|                t.root = insert_at_link(t.root.take(), i, v, &mut t.next_key);
  107|     25|            let _ = visited.insert(u.clone());
  107|      3|                write!(f, "{}", x)?;
  107|  5.12k|                    min_element = current;
  107|      6|                write!(f, "{}", item)?;
  107|      7|        SearchResult { visited, parent: None }
  107|      8|            let _ = s.insert(x);
  107|       |    /// - bridges: Vertex bridges (from vertex_bridges)
  108|      0|                    ParaPair!(move || parallel_out(left_arcs, v_left), move || parallel_out(
  108|    114|                    .map(|k| {
  108|     11|                    x.right = Some(h);
  108|     14|                &|i| {
  108|     23|                    y.right = Some(x);
  108|     30|            Self {
  108|     34|                Probability::zero() // Base case: empty subsequence
  108|     46|                    *link = Self::build_balanced(&values);
  108|  5.12k|                    min_index = i;
  108|  5.17k|                new_elements = ArraySeqStPerS::append(&new_elements, &single_seq);
  108|      8|            Set { data: s }
  108|      9|                result = result.resize(new_size);
  108|       |                    LeftistHeapNode::Node {
  108|       |    /// - rng: Random number generator for coin flips
  108|       |        /// - u: Element in first set
  109|       |        () => {{
  109|       |        () => {{
  109|    104|            pq = new_pq;
  109|     10|            debug_assert!(t.length() == length);
  109|  11.4k|                    result = result.union(&ng_u);
  109|     14|                1 + min(delete_cost, insert_cost)
  109|      1|            Self {
  109|      1|            write!(f, "]")
  109|     23|            let _ = row.set(v, exists);
  109|     23|                    *link = Some(y);
  109|      2|            Self {
  109|      2|            write!(f, "]")
  109|     33|            let _ = component_map.insert(u.clone(), component.clone());
  109|    463|                    *link = Some(x);
  109|      5|                        all_adjacent_tails = false;
  109|       |    /// - Contracted graph
  109|       |            loop {
  109|       |        /// - v: Element in second set
  110|     23|                        let _ = merged.insert(v, (neighbor, w, label));
  110|     23|            let _ = self.matrix.set(u, row);
  110|     28|                    let _ = out.insert(y.clone());
  110|     37|                            frontier_updated = frontier_updated.union(&AVLTreeSetStEph::singleton(neighbor_entry));
  110|     43|    ) -> Set<Edge<V>> {
  110|    446|                head = Some(Box::new(NodeP { value, next: head }));
  110|      4|        mst_edges.size() == expected_edges
  110|      4|            Self {
  110|     68|                        left_cost + right_cost + split_cost
  111|       |        () => {{
  111|      0|                    *link = Some(h);
  111|      0|                    *link = Some(x);
  111|    100|                .filter_map(|v| {
  111|     10|                .filter_map(|v| {
  111|     10|                .filter_map(|v| {
  111|     10|                .filter_map(|v| {
  111|     10|                .filter_map(|v| {
  111|    112|    ) -> Set<Edge<V>> {
  111|    114|                        left_cost + right_cost
  111|    118|            ArraySetStEph {
  111|     11|            EdgeSetGraphStPer {
  111|     11|                    *link = Some(x);
  111|     15|                1 + min(delete_cost, insert_cost)
  111|     17|                .filter_map(|v| {
  111|    307|            SortedListPQ { elements: new_elements }
  111|      3|            self.entries = mapped_entries;
  111|    446|                len += 1;
  111|     54|            AdvancedDoubleHashingStrategy {
  111|       |    /// - (remaining_vertices, partition_map) where partition_map: tail → (head, weight, label)
  112|  1.46k|                        doc_ids = ArraySeqStPerS::append(&doc_ids, &single_seq);
  112|      1|            ArraySetEnumMtEph {
  112|      1|            OrderedSetStPer {
  112|      1|            self.base_set = result;
  112|     26|                0 // Base case: single matrix, no multiplication needed
  112|     27|            (base + clamped_start)..(base + clamped_end)
  112|      4|                    edge_found = true;
  113|      0|                    *link = Some(h);
  113|      0|                    ParaPair!(move || parallel_neighbors(left_edges, v_left), move || {
  113|      0|            visited = new_visited;
  113|     10|            Self {
  113|     11|            AdjSeqGraphStPer {
  113|    167|            LinkedListStPerS { head, len }
  113|     64|                    pq = pq.insert(PQEntry::new(new_dist, u_idx));
  113|      6|            Self {
  113|     80|                    pq = pq.insert(PQEntry::new(new_dist, u_idx));
  113|      8|            OrderedTableStPer {
  114|       |                ) => {
  114|      0|            result = new_result;
  114|      1|                let _ = self.adj.set(u, ArraySeqStEphS::from_vec(new_neighbors_vec));
  114|     27|            Self {
  114|      4|                            let _ = a.set(lt, xi);
  114|      7|            EdgeSetGraphMtPer {
  115|     11|                current = pred;
  115|     18|            visited = new_visited;
  115|      1|                return; // Already in same set
  115|      4|                            let _ = a.set(i, xlt);
  116|    172|            Self {
  116|    187|                    smallest = left;
  116|     18|            component = component.union(&sub_component);
  116|    217|                    move || parallel_filter(left_vals, f_left),
  116|     25|    ) -> (Set<V>, HashMap<V, (V, OrderedFloat<f64>, usize)>) {
  116|      2|                let _ = matching.insert(edge.clone());
  116|      3|                    let (_, _, reduced_right) = ParamBST::split_inner(&right, &min_key);
  116|      4|            TableStPer { entries }
  116|     51|                &|v| {
  116|     63|                    .map(|k| {
  116|      7|        SearchResult { visited, parent: None }
  116|      7|            Self {
  116|     86|                &|v| {
  117|      0|                unsafe {
  117|     10|                        lt += 1;
  117|     17|                    let _ = mst_edges.insert(edge);
  117|     19|            ComprehensiveClusteringAnalysis {
  117|      1|                    node.value = value;
  117|      1|        table = table.insert("B".to_string(), "B_value".to_string());
  117|    217|                    move || parallel_filter(right_vals_final, f_right)
  117|     25|            AdvancedQuadraticProbingStrategy {
  117|     25|                current = node.next.as_deref_mut();
  117|     28|                    new_neighbors = new_neighbors.union(&neighbors);
  117|      2|                    result_adj = result_adj.insert(u.clone(), new_neighbors);
  117|      3|                current = pred;
  117|      3|            self.entries = filtered;
  118|       |        () => {{
  118|      0|            ) -> Set<V> {
  118|     10|                        i += 1;
  118|      1|                    false // No new insertion
  118|      1|        table = table.insert("E".to_string(), "E_value".to_string());
  118|     21|                table_guard[i][j] = new_value;
  118|     21|                table_guard[i][j] = new_value;
  118|  22.1k|                node.color = match node.color {
  118|     25|                i += 1;
  118|      2|            self.base_set = result;
  118|      2|                self.data[index] = item;
  118|     32|                    period = i;
  118|     43|                    result = result.insert(elem.clone());
  118|  5.50k|                    new_elements = ArraySeqStPerS::append(&new_elements, &single_seq);
  118|     60|                prob_sum + min_cost
  119|      0|                    current = node.next;
  119|     16|            UniversalIntegerHashFunction { a, b, p: LARGE_PRIME }
  119|      1|            OrderedSetStPer {
  119|      1|                "SubsetSumStPer(multiset: {}, memo_entries: {})",
  119|      1|        table = table.insert("A".to_string(), "A_value".to_string());
  119|     85|            pq = pq.insert(element.clone());
  120|    132|                node.color = match node.color {
  120|    179|                    .map(|k| {
  120|      1|            AdjTableGraphStPer { adj: result_adj }
  120|      1|            EdgeSetGraphStPer {
  120|      1|        table = table.insert("F".to_string(), "F_value".to_string());
  120|     25|                    let _ = inn.insert(x.clone());
  120|    308|            position < (load * size) / size
  120|     37|                            frontier_updated = frontier_updated.union(&AVLTreeSetMtPer::singleton(neighbor_entry));
  120|    554|                            LeftistHeapNode::Node {
  120|     63|                        left_cost + right_cost + split_cost
  120|     67|                    smallest = right;
  120|      6|                        gt -= 1;
  121|  1.02k|                &|i| {
  121|    117|                *link = Some(Box::new(Node::new(key, value, rng.random())));
  121|     18|                        lo = mid + 1;
  121|      1|            Self {
  121|    213|        ) -> ArraySeqMtPerS<W> {
  121|      2|            Self {
  121|     47|                        priorities = priorities.union(&AVLTreeSetStEph::singleton(Pair(v.clone(), p)));
  121|     56|            (hash1 + (attempt * step)) % table.current_size
  121|      5|    ) -> WeightedDirGraphStEphFloat<usize> {
  121|  74.1k|                let _ = out.data.insert(x.clone());
  121|     79|            let _ = flips.insert(v.clone(), is_heads);
  122|    117|                true // New insertion
  122|     11|            solver.memo.clear(); // Fresh memo for each query
  122|      1|            EdgeSetGraphMtPer {
  122|      1|                "MinEditDistStPer(source: {}, target: {}, memo_entries: {})",
  122|     23|    ) -> Set<Edge<V>> {
  122|     35|                        d_prime - p_u + p_v
  122|      3|                current = pred;
  122|     57|                        OrderedF64::from(d_prime.0 - p_u.0 + p_v.0)
  122|      6|                    found_index = Some(i);
  122|      6|                        let _ = a.set(i, xgt);
  122|  9.14k|                        lt += 1;
  122|       |        ) -> ArraySeqMtEphS<U>
  123|  1.10k|            node.size = 1 + Self::size_link(&node.left) + Self::size_link(&node.right);
  123|     11|    ) -> Set<Edge<V>> {
  123|    179|                        left_cost + right_cost
  123|      1|            AdvancedDoubleHashingStrategy {
  123|      1|        table = table.insert("D".to_string(), "D_value".to_string());
  123|  22.1k|                    left.color = match left.color {
  123|     25|                        hi = mid;
  123|     29|                self.cached_reduction = v;
  123|      2|                let _ = self.parent.insert(root_u, root_v);
  123|      2|            OrderedTableStPer {
  123|      3|            let _ = self.multiset.set(index, value);
  123|      6|                        let _ = a.set(gt, xi);
  123|  9.14k|                        i += 1;
  123|      9|            let _ = result.insert(edge.clone());
  124|      0|                period = probe_sequence.len();
  124|     16|                            frontier_updated = frontier_updated.union(&AVLTreeSetStPer::singleton(neighbor_entry));
  124|     18|                | _ => min_node(&inner.left),
  124|     19|    ) {
  124|      1|            ArraySetEnumMtEph {
  124|      1|            self.base_set = result;
  124|    231|                    break; // Heap property satisfied
  124|    326|                *link = Some(Box::new(Node::new(value, rng.random())));
  124|  37.8k|                            lt += 1;
  124|  4.94k|                new_table = ArraySeqStPerS::append(&new_table, &single_seq);
  125|  1.02k|                *link = Some(Box::new(Node::new(value, rng.random())));
  125|     10|            Self {
  125|    132|                    left.color = match left.color {
  125|    174|                self.cached_reduction = (self.reducer)(&self.cached_reduction, &v);
  125|  3.16k|                        gt -= 1;
  125|  37.8k|                            i += 1;
  125|      3|                current = pred;
  125|      8|                        i += 1;
  126|     10|            solver.memo.clear(); // Fresh memo for each query
  126|    119|                let _ = self.parent.insert(root_v, root_u);
  126|     26|                        pq = pq.insert(PQEntry::new(weight, v.clone(), Some(u.clone())));
  126|      2|                let _ = out.set(index, v.clone());
  126|      2|            write!(f, "[")?;
  126|    533|                final_table = final_table.insert(word.clone(), doc_set, |_old, new| new.clone());
  126|      9|            OrderedSetStPer {
  126|       |        ) -> ArraySeqStPerS<Pair<K, ArraySeqStPerS<V>>>;
  127|       |        () => {{
  127|    108|                    ParaPair!(move || parallel_ng(left_edges, v_left), move || parallel_ng(
  127|      1|            AdjMatrixGraphStEph {
  127|      2|                index += 1;
  127|   381k|                            gt -= 1;
  127|      3|            self.elements = filtered;
  127|    674|            node.left = Self::build_balanced(&values[..mid]);
  127|     85|            pq = new_pq;
  128|  1.01k|                        i += 1;
  128|     11|                .filter_map(|v| {
  128|     15|                .filter_map(|v| {
  128|    200|                result = self.swap_elements(&result, i, smallest);
  128|      3|                current = pred;
  128|      3|            OrderedTableStEph {
  128|     48|            hash_value % table_size
  128|  6.51k|                new_elements = ArraySeqStPerS::append(&new_elements, &single_seq);
  128|    674|            node.right = Self::build_balanced(&values[mid + 1..]);
  128|     88|                .filter_map(|v| {
  128|      8|                .filter_map(|v| {
  128|      8|                .filter_map(|v| {
  128|      8|                .filter_map(|v| {
  128|       |    /// - vertices_vec: Vector of vertices (for parallel iteration)
  129|     18|                    FlatEntry::Empty | FlatEntry::Deleted => return slot,
  129|    200|                i = smallest;
  129|  22.1k|                    right.color = match right.color {
  129|     22|                let _ = self.parent.insert(root_v, root_u.clone());
  129|     27|            Self {
  129|     30|                self.cached_reduction = v;
  129|  35.4k|                result = result.insert(elem.clone());
  129|     36|            DocumentIndex {
  129|      8|            TableStPer { entries }
  129|       |    /// - bridges: Vertex bridges (from vertex_bridges_mt)
  130|      0|            ) -> Set<V> {
  130|  1.10k|            node.reduced_value = Op::combine(left_reduced, Op::combine(node_reduced, right_reduced));
  130|      1|                    FlatEntry::Occupied(k, _) if k == key => return slot,
  130|     22|                let _ = self.rank.insert(root_u, rank_u + 1);
  130|    268|                self.num_elements + 1
  130|      2|                result = result.union(&plus_u);
  130|      2|            Self {
  130|     32|            ProbeSequenceVisualization {
  130|      3|                current = pred;
  130|      3|                current = pred;
  130|     42|            AdvancedQuadraticProbingStrategy {
  130|      4|            OrderedTableStPer {
  130|  5.81k|                            i += 1;
  130|     71|                prob_sum + min_cost
  130|      8|            UnsortedListPQ {
  130|      9|            SearchResult { visited, parent: None }
  130|       |    /// - rng: Random number generator for coin flips
  131|      0|                    _ => attempt += 1,
  131|      0|                        self.med_recursive_parallel(i - 1, j - 1)
  131|    132|                    right.color = match right.color {
  131|     17|                let _ = result.insert(new_edge);
  131|      1|    ) -> bool {
  131|     21|        ) -> usize {
  131|     21|        ) -> usize {
  131|  2.48k|                self.cached_reduction = (self.reducer)(&self.cached_reduction, &v);
  131|      2|            Self {
  131|      4|                    write!(f, ", ")?;
  132|    111|                let (_, right) = mid_and_right.split_at_mut(gt - lt);
  132|  15.0k|                let _ = out.insert(x.clone());
  132|    170|                            LeftistHeapNode::Node {
  132|      1|    ) -> bool {
  132|     21|                let _ = partition.insert(u.clone(), (v.clone(), *w, *label));
  132|    231|                    *link = Some(Box::new(Node::new(value)));
  132|      3|                current = pred;
   13|     23|            "jack" => "chess is fun",
  132|     47|                        priorities = priorities.union(&AVLTreeSetMtPer::singleton(Pair(v.clone(), p)));
  133|      0|                        self.med_recursive_parallel(i - 1, j - 1)
  133|     14|                initial_frontier = initial_frontier.union(&AVLTreeSetStEph::singleton(entry));
  133|     19|    ) {
  133|      1|                continue; // Unreachable
  133|      1|            OrderedSetStPer {
  133|      1|            Self {
  133|      2|                    first = false;
  133|     33|                        current = node.next.as_deref();
  133|      3|            self.cached_reduction = self.recalculate_reduction();
  133|      4|            Self {
  133|      6|                let _ = visited.insert(vertex.clone());
  133|       |    /// - (remaining_vertices, partition_map) where partition_map: tail → (head, weight, label)
  134|      0|                self.num_deleted - 1
  134|      0|            self.seq_s = s;
  134|    111|                thread::scope(|scope| {
  134|    116|                | _ => max_node(&inner.right),
  134|     11|            Set { data: out }
  134|     13|        HeapsortComparison {
  134|  1.85k|                result = result.insert(elem.clone());
  134|      1|            "Table1 ∩ Table2: size = {}, key 2 -> {:?}",
  134|     33|                        skipped += 1;
  134|      3|            let _ = self.source.set(index, value);
  134|      4|                &|i| {
  134|  5.81k|                    let (_, right) = mid_and_right.split_at_mut(gt - lt);
  134|      6|                *self = AVLTreeSeqStEphS::from_vec(out_vec);
  134|      7|            TableStPer { entries: filtered }
  134|       |    /// - euler_tour: Euler tour with possible duplicate visits
  135|      0|                    ParaPair!(move || parallel_ng_of_vertices(left_verts, graph_left), move || {
  135|      0|            self.clear_memo(); // Clear memo when sequences change
  135|     11|            AdjMatrixGraphStPer {
  135|     14|                print!(", ");
  135|     16|        ) -> ComprehensiveClusteringAnalysis
  135|      3|            OrderedTableMtEph {
  135|      6|                write!(f, "{}", node.value)?;
  136|      0|            node.left = left;
  136|     10|                    i += 1;
  136|     19|            AdjTableGraphStPer { adj: final_adj }
  136|      1|            ArraySetEnumMtEph {
  136|      1|                "LabDirGraph {{ vertices: {:?}, labeled_arcs: {:?} }}",
  136|     23|                        priorities = priorities.union(&AVLTreeSetStPer::singleton(Pair(v.clone(), p)));
  136|  5.81k|                    thread::scope(|scope| {
  136|      5|    ) -> WeightedDirGraphStEphInt<usize> {
  136|      6|                current = node.next.as_deref();
  136|      6|                        i += 1;
  137|      0|            node.right = right;
  137|      0|                "SubsetSumStEph(multiset: {}, memo_entries: {})",
  137|  1.05k|                *link = Some(Box::new(Node::new(value, rng.random())));
  137|      1|            Self {
  137|      3|            self.root = node;
  137|      4|            OrderedTableStPer {
  137|      6|                        j += 1;
  137|       |    /// - Vector of vertices with each vertex appearing exactly once (except start/end)
  138|      0|            OrderedSetMtEph { elements }
  138|     10|                let _ = quotient_edges.insert(new_edge);
  138|     13|            PQMinResult {
  138|     15|                    &|i| {
  138|      1|        println!("Table1 ∪ Table2: size = {}", union.size());
  138|      1|            TopDownDPStPerS {
  138|     20|    ) -> (Set<V>, HashMap<V, (V, OrderedFloat<f64>, usize)>) {
  138|      2|            write!(f, "]")
  138|     72|    ) -> ArraySeqStEphS<Edge<V>> {
  139|       |        () => {{
  139|      0|        AllPairsResultStEphFloat {
  139|      0|                    new_chain = ArraySeqStPerS::append(&new_chain, &single_seq);
  139|      0|                "OBSTStPer(keys: {}, memo_entries: {})",
  139|      1|                a.length() + b.length(),
  139|      1|        println!("Table1 - Table2: size = {}", difference.size());
  139|      2|                result = result.union(&minus_u);
  139|      5|            self.cached_reduction = self.recalculate_reduction();
  139|      6|                    j += 1;
  139|      7|                table_guard[i - 1][j - 1]
   13|       |        Node {
  140|      0|                ParaPair!(move || left_set.filter(f_left), move || right_set.filter(f_right));
  140|      0|            ) -> Set<(V, OrderedFloat<f64>)> {
  140|    271|                self.elements = ArraySeqStEphS::from_vec(temp_vec);
  140|      2|            Self {
  140|      3|            let _ = self.target.set(index, value);
  140|     58|                let _ = remaining.insert(v.clone());
  140|      7|                table_guard[i - 1][j - 1]
  140|      8|            visited.size() == self.vertices().size()
  140|     99|    ) -> Set<Edge<V>> {
  140|       |        /// - u: First element
  141|       |        () => { $crate::Chap37::BSTPlainStEph::BSTPlainStEph::BSTPlainStEph::new() };
  141|      0|            output.push_str(&format!("{}: {} elements\n", name, data.len()));
  141|      0|                    was_deleted = true;
  141|     10|            move || parallel_dijkstra_all(&graph_left, &potentials_left, start, mid, n),
  141|     18|            move || parallel_dijkstra_all(&graph_left, &potentials_left, start, mid, n),
  141|      1|            AdjSeqGraphStPer {
  141|     26|                let _ = neighbors.insert(b.clone());
  141|       |        /// - v: Second element
  142|       |                | _ => {
  142|      0|            self.seq_t = t;
  142|     10|            move || parallel_dijkstra_all(&graph_right, &potentials_right, mid, end, n)
  142|     11|                        count += 1;
  142|     18|            move || parallel_dijkstra_all(&graph_right, &potentials_right, mid, end, n)
  142|      1|                continue; // Unreachable
  142|     20|                guard[idx] = item;
  142|    231|            left > ALPHA * total || right > ALPHA * total
   14|     23|            "mary" => "I had fun in dance club today",
  142|      4|            self.entries = ArraySeqStEphS::from_vec(intersection_entries);
  142|      5|            *self = ArraySeqMtEphS::from_vec(data);
  142|     70|            let _ = coin_flips.insert(vertex.clone(), rng.random::<bool>());
  143|      0|                "MatrixChainStPer(matrices: {}, memo_entries: {})",
  143|      0|            self.clear_memo(); // Clear memo when sequences change
  143|      0|            ) -> Set<V> {
  143|     26|                let _ = neighbors.insert(a.clone());
  143|      4|            AdvancedQuadraticProbingStrategy {
  143|     53|            OrderedSetStPer {
  143|       |        ) -> ArraySeqMtPerS<W>
  143|       |macro_rules! SubsetSumStPerLit {
  144|       |        () => {{
  144|     14|                1 + min(delete_cost, insert_cost)
  144|     14|                initial_frontier = initial_frontier.union(&AVLTreeSetMtPer::singleton(entry));
  144|      1|                    new_chain = ArraySeqStPerS::append(&new_chain, &single_seq);
  144|      2|            OrderedTableStPer {
  144|      2|            write!(f, "[")?;
  144|     51|                        break; // Found the predecessor
  144|       |            for _ in 0..$n { __tree.insert($x.clone()); }
  144|       |        /// - true if u and v are in the same set
  145|       |        ($value:expr) => {
  145|     14|                1 + min(delete_cost, insert_cost)
  145|     14|                print!(", ");
  145|    158|                    x.right = y.left.take();
  145|     19|                result.set(a.length() + i, b.nth(i).clone()).unwrap();
  145|      1|            let _ = self.multiset.set(index, value);
  145|      1|            Self {
  145|      1|                self.keys[index] = key_prob;
  145|      2|                    AdjTableGraphStPer { adj: new_adj }
  145|      2|            Self {
  145|      7|            PQMinResult {
  145|     87|                        current = node.next.as_deref();
  146|     12|            Self {
  146|  1.76k|                    *link = Some(Box::new(Node::new(value)));
  146|      1|                    was_deleted = true;
  146|    204|                    *link = Some(Box::new(Node::new(value)));
  146|      4|                i += 1;
  146|     87|                        taken += 1;
  147|     13|                    result = result.union(&ng_u);
  147|      1|            Self {
  147|      1|            Self {
  147|      5|                result.set(a.length() + i, b.nth_cloned(i)).unwrap();
  148|    158|                    y.left = Some(x);
  148|     19|                &|i| {
  148|      1|            ArraySetEnumMtEph {
  148|      3|            result.base_table = TableMtEph::empty();
  148|      4|                avg_cluster_size / expected_avg_cluster_size
  148|     67|            ParamBST {
  148|      9|            OrderedSetStEph {
  149|       |    () => {
  149|      0|            output.push_str(&format!("{}: {} - {}\n", impl_name, complexity_str, notes));
  149|   116k|                        Self::is_red(&node.left) && Self::is_red(&left.left)
  149|  11.7k|                result = ArraySeqStPerS::append(&result, &single_seq);
  149|     13|            PQMinResult {
  149|    158|                    *link = Some(y);
  149|      2|                self.dimensions[index] = dim;
  149|      4|                    found = true;
  149|      4|                    found = true;
  149|      4|                    found = true;
  149|      4|                    write!(f, ", ")?;
  149|      5|                    found = true;
  149|      5|            self.with_exclusive(|data| {
  149|      6|                    found = true;
  149|      6|                    found = true;
  149|      6|                let _ = visited.insert(vertex.clone());
  149|      8|                initial_frontier = initial_frontier.union(&AVLTreeSetStPer::singleton(entry));
  150|       |        () => {{
  150|     11|                    *link = Self::build_balanced(&values);
  150|     28|                    let (_, _, reduced_right) = ParamBST::split_inner(&right, &min_key);
  150|     29|                    result = ArraySeqStPerS::append(&result, &single_seq);
  150|      4|                j += 1;
  151|       |        () => {
  151|      0|                    *link = Some(x);
  151|      0|                result = result.resize(new_size);
  151|      1|    ) -> OrderedFloat<f64> {
  151|     29|                    i += 1;
  151|      2|                    first = false;
  151|      4|            OrderedTableStPer {
  151|      5|                            let _ = a.set(lt, xi);
  152|      0|                "SubsetSumMtPer(multiset: {}, memo_entries: {})",
  152|     11|                        i += 1;
  152|    134|            BSTSplayMtEph {
  152|     17|            Self {
  152|      1|        ) -> Self {
  152|     38|            let _ = result.insert(edge.clone());
   15|     23|            "nick" => "food at the cafeteria sucks",
  152|      5|                            let _ = a.set(i, xlt);
  153|      0|                    ParaPair!(move || parallel_in(left_arcs, v_left), move || parallel_in(
  153|      0|                    ParaPair!(move || parallel_out(left_arcs, v_left), move || parallel_out(
  153|     11|                        j += 1;
  153|      1|            Self {
  153|     21|                    result = result.insert(elem.clone());
  153|     31|            let _ = result.insert(edge.clone());
  153|      3|                self.keys[index].prob = prob;
  153|     51|                        break; // Found the predecessor
  153|      5|            BalancedTreePQ {
  153|      6|                write!(f, "{}", node.value)?;
  153|       |        /// - Number of distinct sets
  154|      0|                "MinEditDistStEph(source: {}, target: {}, memo_entries: {})",
  154|      1|                a.length() + b.length(),
  154|  26.0k|                        let _ = out.insert(y.clone_mt());
  154|     27|                    result = ArraySeqStPerS::append(&result, &single_seq);
  154|      2|                        Some(self.elements[pos - 1].clone())
  154|     43|    ) -> Option<OrderedFloat<f64>> {
  154|      5|            Self { inner, range: 0..1 }
  154|      6|                current = node.next.as_deref();
  154|      7|                        lt += 1;
  154|      7|            PQMinResult {
  155|  1.00k|            table_per = table_per.insert(i, format!("value_{}", i), |_old, new| new.clone());
  155|     27|                    j += 1;
  155|      5|                result = result.insert(element.clone());
  155|      7|                        i += 1;
  156|      0|            ) -> Set<V> {
  156|     10|    ) -> (WeightedDirGraphStEphFloat<usize>, usize) {
  156|      1|                a.length() + b.length(),
  156|      1|            Self {
  156|      2|            write!(f, "]")
  156|     42|                let _ = remaining.insert(v.clone());
  156|       |    /// - vertices: Set of vertices
  157|      0|        AllPairsResultStEphInt {
  157|      0|                new_buckets = ArraySeqStPerS::append(&new_buckets, &single_seq);
  157|      0|                sum_squared_diff / (total_clusters - 1) as f64
  157|      1|            AdjMatrixGraphStPer {
  157|      2|            .union(&singleton3) // duplicate, should not change result
  157|      8|                        gt -= 1;
  157|       |    /// - edges: Set of labeled edges
  158|  10.9k|            t.root = insert_at_link(t.root.take(), 0, item, &mut t.next_key);
  158|     10|            TableStPer {
  158|      1|            Self {
  158|      1|                self.dimensions[index] = dim;
  158|     21|        ) -> SecondaryClusteringMetrics
  158|     22|            Self {
  158|      2|            OrderedTableStPer {
  158|      2|            .union(&singleton1) // duplicate, should not change result
  158|     35|                print!(", ");
  158|      7|                        i += 1;
  158|       |    /// - mst_labels: Accumulated MST edge labels
  159|      0|            MathSeqS {
  159|     13|            self.unsorted_list_result == *expected
  159|     16|            ComprehensiveClusteringAnalysis {
  159|    255|                let _ = roots.insert(root);
  159|     27|            ProbeSequenceVisualization {
  159|      3|                total += weight;
  159|     48|            self.elements = AVLTreeSeqStEphS::from_vec(vec_elements);
  159|      5|                    x.left = y.right.take();
  159|      8|                        let _ = a.set(i, xgt);
  159|       |    /// - rng: Random number generator
   15|       |        ) -> ArraySeqStPerS<Pair<N, &'static str>>;
  160|      0|                "MinEditDistMtPer(source: {}, target: {}, memo_entries: {})",
  160|      1|            Self {
  160|      2|            .union(&singleton2); // duplicate, should not change result
  160|      8|                        let _ = a.set(gt, xi);
  161|      2|            let _ = self.source.set(index, value);
  161|      3|                        Some(self.elements[pos - 1].clone())
  162|       |        () => {{
  162|      0|                        j += 1;
  162|     19|            Self {
  162|  20.0k|                    let _ = out.insert(Pair(a.clone(), b.clone()));
   16|     23|            "josefa" => "rock climbing was a blast",
  162|      4|            PrimaryClusteringMetrics {
  162|      5|                    y.right = Some(x);
  162|      6|                        crate::ParaPair!(move || ParamTreap::union_inner(&al, &bl), move || {
  162|      8|                        i += 1;
  162|      8|                new_buckets = ArraySeqStPerS::append(&new_buckets, &single_seq);
  162|       |    /// - Set of edge labels in the MST
  163|      0|                    ParaPair!(move || parallel_in(left_arcs, v_left), move || parallel_in(
  163|      1|                    found_index = Some(i);
  163|      2|                result = ArraySeqStPerS::append(&result, &single_seq);
  163|  4.27k|                        lt += 1;
  163|      5|                    *link = Some(y);
  163|      9|            UniversalIntegerHashFamily { p: LARGE_PRIME }
  163|       |macro_rules! SubsetSumMtPerLit {
  164|      0|                self.data[index] = item;
  164|    222|                current = node.next.as_deref();
  164|    254|                        move || ParamBST::union_inner(&al, &bl),
  164|      2|                i += 1;
  164|  4.27k|                        i += 1;
  164|      6|                result = result.insert(element.clone());
  164|    995|                            lt += 1;
  164|      9|                acc = f(&acc, a.nth(i));
  165|      0|                    *link = Some(x);
  165|      1|            Self {
  165|    222|                i += 1;
  165|    254|                        move || ParamBST::union_inner(&ar, &br)
  165|     25|            *self.root.borrow_mut() = new_state;
  165|    270|                probe_count += 1;
  165|      2|            OrderedTableStPer {
  165|      5|            Set { data: out }
  165|    995|                            i += 1;
  165|       |        ) -> ArraySeqStEphS<Pair<K, ArraySeqStEphS<V>>>;
  165|       |    /// - graph: The undirected graph
  166|    174|                *link = Some(Box::new(Node::new(value)));
  166|      1|            *self = Self::empty();
  166|    270|                current_pos = (current_pos + h2_value) % table_size;
  166|  3.49k|                        gt -= 1;
  166|     34|            move || select_edges_recursive(graph1, edges1, coins1, start, mid),
  166|      4|                self.data[index] = value;
  166|      4|    ) -> Set<V> {
166 |     assert!(med.memo_size() >= 0);
  166|       |    /// - seed: Random seed for matching
  167|      0|            UnionFind {
  167|     10|                Some(seq.nth(size - 1).clone())
  167|  1.12k|                    left.rank() >= right.rank() && left.is_leftist() && right.is_leftist()
  167|     17|                result = self.bubble_down(i, &result);
  167|     26|                AVLTreeSetStPer {
  167|     34|            move || select_edges_recursive(graph2, edges2, coins2, mid, end)
  167|      3|                        i += 1;
  167|    998|                            gt -= 1;
  167|       |        ) -> (ArraySeqMtPerS<A>, A);
  168|      0|            TopDownDPMtPerS {
  168|     15|                result = f(result, &pair.0, &pair.1);
  168|      1|                "LabUnDirGraph {{ vertices: {:?}, labeled_edges: {:?} }}",
  168|      1|            let _ = self.target.set(index, value);
  168|     33|    ) -> Set<usize> {
  168|      3|                        j += 1;
  168|     49|                array_seq = ArraySeqStPerS::append(&array_seq, &single_seq);
  168|       |macro_rules! SubsetSumStEphLit {
  169|       |    () => {
  169|      0|                    ParaPair!(move || parallel_neighbors(left_edges, v_left), move || {
  169|  1.16k|                        i += 1;
  169|      1|            Self {
  169|   212k|            let _ = self.data.insert(x);
  169|    263|            node.left = Self::build_balanced(&values[..mid]);
  169|     34|                    result = ArraySeqStPerS::append(&result, &single_seq);
  169|      5|            TableMtEph {
  169|       |    /// - Contracted graph
  169|       |macro_rules! OBSTStPerLit {
  170|      0|                "OBSTStEph(keys: {}, memo_entries: {})",
  170|    120|    ) -> HashMap<V, (V, OrderedFloat<f64>, usize)> {
  170|     17|            ArraySeqMtEphSliceS {
  170|    180|                            i += 1;
  170|    263|            node.right = Self::build_balanced(&values[mid + 1..]);
  170|      2|    ) -> OrderedFloat<f64> {
  170|       |macro_rules! MinEditDistStPerLit {
  171|       |        () => {{
  171|       |        () => {{
  171|      1|            Self {
  171|     34|                current_pq = new_pq;
  171|      5|                left = a.next.as_deref();
  171|      5|                result = ArraySeqStPerS::append(&result, &single_seq);
  171|       |macro_rules! MatrixChainStPerLit {
  171|       |macro_rules! MinEditDistMtPerLit {
  172|      0|                result = result.resize(new_size);
  172|     19|            total += *w;
  172|      2|            OrderedTableStPer {
  172|      2|            *self.root.borrow_mut() = new_state;
  172|      2|                    write!(f, ", ")?;
  172|      3|                let _ = map.insert(v.clone(), v.clone());
   17|     23|            "peter" => "I had fun at the party, food was great"
  172|      3|                Some(seq.nth(size - 1).clone())
  172|   555k|                self.elements = AVLTreeSeqStEphS::from_vec(vec_elements);
  172|      5|                j += 1;
  172|      5|                right = b.next.as_deref();
  172|      6|                let _ = neighbors.insert(b.clone());
  172|       |            Ok(AVLTreeSeqMtPerS {
  173|      0|                    ParaPair!(move || parallel_ng_of_vertices(left_verts, graph_left), move || {
  173|      1|            Self {
  173|      1|    ) -> UnDirGraphMtEph<V> {
  173|      1|            write!(f, "[")?;
  173|    208|                let (_, right) = mid_and_right.split_at_mut(gt - lt);
   17|     38|            LinearProbingStrategy {
  173|       |            Ok(AVLTreeSeqStPerS {
  174|       |    () => {
  174|      0|                    h1_value - h2_value
  174|    178|                    let (_, right) = mid_and_right.split_at_mut(gt - lt);
  174|     26|            ArraySeqS {
  174|      3|                        Some(self.elements[pos + 1].clone())
  174|      3|                write!(f, "{}", item)?;
  174|      6|                let _ = neighbors.insert(a.clone());
  175|      0|                let _ = self.parent.insert(v.clone(), v.clone());
  175|      0|                "MatrixChainStEph(matrices: {}, memo_entries: {})",
  175|    208|                thread::scope(|scope| {
  175|      5|            SortedListPQ { elements: result }
  176|       |        () => {{
  176|       |    () => {
  176|      0|                let _ = self.rank.insert(v, 0);
  176|      0|                "SubsetSumMtEph(multiset: {}, memo_entries: {})",
  176|    178|                    thread::scope(|scope| {
  176|      1|                i += 1;
  176|      1|                *self = AVLTreeS::from_vec(out_vec);
  176|      1|            write!(f, "]")
  176|      3|                    h2_value - h1_value
  177|       |    () => {
  177|       |    () => {
  177|    243|            BinaryHeapPQ {
  177|    274|            AVLTreeSeqMtPerS {
  178|       |    () => {
  178|      0|            DocumentIndex {
  178|      0|                print!(", ");
  178|    108|                    ParaPair!(move || parallel_intersect(left_self, other_left), move || {
  178|   171k|                let _ = s.insert(x);
  178|  1.85k|            AVLTreeSeqStPerS {
  178|      2|                    write!(f, ", ")?;
  178|  37.6k|                AVLTreeSetStPer {
  178|    598|                probe_index += 1;
  178|      6|                        crate::ParaPair!(move || ParamTreap::intersect_inner(&al, &bl), move || {
  179|      0|                result = result.resize(new_size);
  179|     12|                acc = f(&acc, a.nth(i));
  179|     16|        ) -> ComprehensiveClusteringAnalysis {
  179|     38|                    move || Self::merge_sort_parallel(&*l)
  179|      6|                total += weight;
  180|      0|                ParaPair!(move || left_set.intersection(&other_left), move || right_set
  180|    156|                        crate::ParaPair!(move || ParamBST::intersect_inner(&al, &bl), move || {
  180|     17|                0.0 // Same hash values indicate poor independence
  180|      1|                    first = false;
  180|     23|            Set { data: s }
  180|     25|            1.0 / (1.0 - load_factor)
  181|       |        () => {{
  181|     30|            let _ = result.insert(edge.clone());
   18|      1|                    *v = value;
  182|      0|            ) -> Set<V> {
  182|      1|            Self {
  182|     25|        for (_, (_, _, label)) in partition.iter() {
   18|     23|            DoubleHashingStrategy {
  182|      3|                write!(f, "{}", node.value)?;
  182|      7|                j += 1;
  183|      0|                    self.entries = ArraySeqMtEphS::singleton(Pair(pair.0, new_value));
  183|    144|            BSTTreapMtEph {
  183|     21|            let _ = new_mst_labels.insert(*label);
  183|    233|            AVLTreeSetStEph {
  183|  24.9k|                *link = Some(Box::new(Node::new(value)));
  183|    370|                    consecutive_count += 1;
  183|     38|                    move || Self::merge_sort_parallel(&*r)
  183|      3|                current = node.next.as_deref();
  183|      5|            *self = ArraySeqMtEphS::from_vec(data);
  184|     10|                result = result.insert(element.clone());
  184|     38|    ) -> bool {
  184|     96|            BinaryHeapPQ {
  185|      0|                    ParaPair!(move || parallel_nplus(left_arcs, v_left), move || parallel_nplus(
  185|      0|        println!("first() = {:?}", int_set.first());
  185|  1.12k|                    left_ok && right_ok && left.is_heap() && right.is_heap()
  185|      1|            self.cached_reduction = self.recalculate_reduction();
  185|      1|            write!(f, "]")
  185|     28|                    let _ = result.insert(u.clone(), (v.clone(), *w, *label));
  185|      3|    ) -> Option<OrderedFloat<f64>> {
  185|      6|            self.entries = ArraySeqStEphS::from_vec(union_entries);
  185|      9|                Some(self.elements.nth(self.elements.length() - 1))
  186|       |        () => {{
  186|      0|        println!("last() = {:?}", int_set.last());
  186|     12|                let _ = result_map.insert(u.clone(), component.clone());
  186|      1|            Self {
  186|     20|            DoubleHashingMetrics {
  186|      5|    ) -> WeightedDirGraphStEphInt<usize> {
  187|      0|                let _ = self.parent.insert(v.clone(), root.clone());
  187|      0|        println!("previous(7) = {:?}", int_set.previous(&7));
  187|    135|            BSTBBAlphaMtEph {
  187|      2|                    write!(f, ", ")?;
  187|       |macro_rules! SubsetSumMtEphLit {
  188|      0|        println!("next(7) = {:?}", int_set.next(&7));
  188|      3|                    node.value = value;
  188|    837|                    consecutive_count = 1;
  189|      0|            let _ = s.insert(x);
  189|      0|        println!("rank(7) = {}", int_set.rank(&7));
  189|     10|    ) -> WeightedDirGraphStEphFloat<usize> {
  189|    112|                result = f(result, &pair.0, &pair.1);
  189|     21|            let _ = full_partition.insert(tail.clone(), head.clone());
  189|      3|                write!(f, "{}", self.elements.nth(i))?;
  189|      6|            TableStPer {
  190|       |        () => {
  190|      0|        println!("select(3) = {:?}", int_set.select(3));
  190|      0|            Set { data: s }
  190|      1|            ProbeSequenceGenerator {
  190|      9|                acc = f(&acc, a.nth(i));
  191|      0|                    new_table = new_table.insert_without_resize(pair.0.clone(), pair.1.clone());
  191|      0|            write!(f, "{{")?;
  191|      1|            self.cached_reduction = self.recalculate_reduction();
  191|      1|            write!(f, "[")?;
  191|      1|            write!(f, "]")
  191|     30|                words = ArraySeqStPerS::append(&words, &single_seq);
  191|  5.80k|            AVLTreeSetStPer {
   19|     18|            QuadraticProbingStrategy {
   19|      1|                    *v = value;
  192|     42|                        left_size + 1
  192|     58|            let _ = full_partition.insert(v.clone(), v.clone());
  192|      6|                let _ = neighbors.insert(b.clone());
  192|      9|                (1.0 / load_factor) * (1.0 / (1.0 - load_factor)).ln()
  193|       |    () => {
  193|      1|            self.cached_reduction = self.recalculate_reduction();
  193|      5|                    kept_count += 1;
  194|      0|                    write!(f, ", ")?;
  194|     64|                        left_size + 1 + Self::rank_link(&node.right, key)
  194|      6|                let _ = neighbors.insert(a.clone());
  194|      8|    ) -> HashMap<V, V> {
  195|     12|                continue; // Skip the current edge
  195|    199|                *link = Some(Box::new(Node::new(key, value, rng.random(), node_reduced)));
  195|      1|                dimensions_guard[index] = dim;
  195|      1|            MathSeqS {
  196|      0|                write!(f, "{:?}", self.elements.nth(i))?;
  196|    129|                    new_table = new_table.insert_without_resize(pair.0.clone(), pair.1.clone());
  196|      2|                    write!(f, ", ")?;
  196|    528|                    &|i| {
  197|      0|                print!(", ");
  197|     16|            ComprehensiveClusteringAnalysis {
  197|      1|                "MatrixChainMtPer(matrices: {}, memo_entries: {})",
  197|      1|            self.cached_reduction = self.recalculate_reduction();
  197|      3|                | (_, Exposed::Leaf) => a.clone(),
  197|    648|            AVLTreeSeqMtPerS {
  198|       |        () => {
  198|      0|            write!(f, "}}")
  198|      1|                    first = false;
  198|      7|                        crate::ParaPair!(move || ParamTreap::difference_inner(&al, &bl), move || {
  198|      8|                acc = f(&acc, a.nth(i));
  199|      0|                "MinEditDistMtEph(source: {}, target: {}, memo_entries: {})",
  199|    117|                self.size += 1;
  199|    165|                cursor = &node.left;
  199|      1|            Self {
  199|      1|            self.cached_reduction = self.recalculate_reduction();
  199|  39.5k|            AVLTreeSeqStPerS {
    1|       |//! Copyright © 2025 APAS-VERUS. All rights reserved.
    1|       |//! Copyright © 2025 APAS-VERUS. All rights reserved.
    1|       |//! Copyright © 2025 APAS-VERUS. All rights reserved.
    1|       |//! Copyright © 2025 APAS-VERUS. All rights reserved.
    1|       |//! Copyright © 2025 APAS-VERUS. All rights reserved.
    1|       |//! Copyright © 2025 APAS-VERUS. All rights reserved.
    1|       |//! Copyright © 2025 APAS-VERUS. All rights reserved.
    1|       |//! Copyright © 2025 APAS-VERUS. All rights reserved.
    1|       |//! Copyright © 2025 APAS-VERUS. All rights reserved.
    1|       |//! Copyright © 2025 APAS-VERUS. All rights reserved.
    1|       |//! Copyright © 2025 APAS-VERUS. All rights reserved.
    1|       |//! Copyright © 2025 APAS-VERUS. All rights reserved.
    1|       |//! Copyright © 2025 APAS-VERUS. All rights reserved.
    1|       |//! Copyright © 2025 APAS-VERUS. All rights reserved.
    1|       |//! Copyright © 2025 APAS-VERUS. All rights reserved.
    1|       |//! Copyright © 2025 APAS-VERUS. All rights reserved.
    1|       |//! Copyright © 2025 APAS-VERUS. All rights reserved.
  343|      1|            ("Sorted".to_string(), (1..=size as i32).collect()),
  344|      1|            ("Reverse".to_string(), (1..=size as i32).rev().collect()),
  200|     32|            let _ = result.insert(u.clone(), component.clone());
  200|      3|                write!(f, "{}", node.value)?;
  201|       |        () => {
  201|    156|                        crate::ParaPair!(move || ParamBST::difference_inner(&al, &bl), move || {
  201|      1|                keys_guard[index] = key_prob;
  201|      3|                current = node.next.as_deref();
  201|      6|                        i += 1;
  201|       |    /// - graph: Complete weighted undirected graph (metric)
  202|      2|                right_elements_filtered.remove(0); // Remove the found element
   20|   238k|            Self {
  202|      3|            (h1 + probe_index * h2) % table_size
  202|    436|            new_data[index] = item;
  249|      1|            ("Medium (20 elements)".to_string(), large_example(20)),
  202|      4|            load_factor > 0.7
  202|     50|            move || filter_tail_to_head_mt(verts1, bridges1, flips1, start, mid),
  202|       |    /// - spanning_tree: Spanning tree edges (ideally MST)
  203|      0|                let _ = out.data.insert(x.clone());
  203|      1|            self.cached_reduction = self.recalculate_reduction();
  203|      1|            write!(f, "]")
  203|     50|            move || filter_tail_to_head_mt(verts2, bridges2, flips2, mid, end)
  203|     51|                let _ = new_edges.insert((new_u, new_v, *w, *label));
  203|       |    /// - start: Starting vertex
  204|      0|                        j += 1;
  204|      0|                let _ = self.parent.insert(root_u, root_v);
  204|      0|        print!("splitRank(4) = ([");
  204|      0|            write!(f, "{{")?;
  204|  25.2k|                        let _ = inn.insert(x.clone_mt());
   20|  4.88k|            Self {
  204|       |                pq = pq.insert($x);
  205|      0|                    .join(", ")
  205|      0|                    ParaPair!(move || parallel_in(left_arcs, v_left), move || parallel_in(
  205|      0|                result = result.insert(element.clone());
  205|      1|            self.cached_reduction = self.recalculate_reduction();
  205|      2|                    first_kept = Some(a.nth_cloned(i));
  205|      2|            *self = Self::empty();
  205|      6|    ) -> Option<OrderedFloat<f64>> {
  206|      0|                let _ = self.parent.insert(root_v, root_u);
  206|     16|                        i += 1;
  206|      1|                dimensions_guard[index] = dim;
  206|      2|            acc = f(&acc, a.nth(0));
  206|  3.99k|        ) -> ArraySeqMtEphS<U>
  206|    528|                &|i| {
  206|       |    /// - (tour, weight): Hamiltonian cycle and its total weight
  207|      0|        ) -> (ArraySeqMtPerS<A>, A) {
  207|      0|                    write!(f, ", ")?;
  207|    145|            BSTAVLMtEph {
  207|     20|            collision_chains = (load as f64 * 0.7) as N; // Heuristic estimate
  207|      2|                OrderedSetMtEph {
  207|      3|                        i += 1;
  207|     48|            LeftistHeapPQ {
  207|       |macro_rules! OBSTStEphLit {
  208|      0|                let _ = self.parent.insert(root_v, root_u.clone());
  208|      0|                print!(", ");
  208|      3|                        j += 1;
  208|      6|                Some(entries.nth(size - 1).0.clone())
  209|      0|                let _ = self.rank.insert(root_u, rank_u + 1);
  209|      0|                write!(f, "{}", self.elements.nth(i))?;
  209|      1|            self.cached_reduction = self.recalculate_reduction();
  209|     20|                    new_data[*index] = value.clone();
  209|      2|                load / collision_chains.max(1)
  209|      7|                acc = f(&acc, a.nth(i));
  210|      0|        AllPairsResultStEphInt {
  210|     14|                        i += 1;
  210|     20|                    result = ArraySeqStPerS::from_vec(new_data);
  210|    642|            AVLTreeSeqMtPerS {
   21|      0|                FlatEntry::Occupied(k, _) if k == &key => {
  210|       |macro_rules! MinEditDistMtEphLit {
  211|      0|            write!(f, "}}")
  211|     14|                        j += 1;
  211|    161|                                new_table = ArraySeqStPerS::append(&new_table, &single_seq);
  211|      1|                keys_guard[index].prob = prob;
  211|      1|            self.cached_reduction = self.recalculate_reduction();
  211|      1|    ) -> (std::vec::Vec<V>, OrderedFloat<f64>) {
  211|      2|                OrderedSetMtEph {
  211|    417|            (base_hash + probe_index) % table_size
  211|    487|            BinaryHeapPQ { elements: heapified }
  212|       |        () => {
  212|      0|        let _: UnsortedListPQ<i32> = UnsortedListPQLit![];
  212|      0|        print!("], [");
  212|      1|            Self {
  212|      5|            total_words += word_tokens.length();
  213|      0|        let _: UnsortedListPQ<i32> = UnsortedListPQLit![1, 2, 3];
  214|       |        () => {
  214|       |        () => {
  214|       |    () => {
  214|       |        () => { $crate::Chap37::BSTPlainMtEph::BSTPlainMtEph::BSTPlainMtEph::new() };
  214|      0|                acc = f(&acc, &a.nth(i));
  214|      0|                let _ = out.insert(x.clone());
  214|      0|                    new_chain = ArraySeqStPerS::append(&new_chain, &single_seq);
  214|    313|            LeftistHeapPQ {
  214|      4|                result = result.insert(element.clone());
  215|  1.34k|                words = ArraySeqStPerS::append(&words, &single_seq);
  215|      2|            a.length() == 0
  215|     30|                    new_chain = ArraySeqStPerS::append(&new_chain, &single_seq);
  216|      0|        AllPairsResultStEphFloat {
  216|      0|                    key_existed = true;
  216|      0|                print!(", ");
  216|      0|            Set { data: out }
  216|      0|            writeln!(f, "=== {} ===", self.strategy_name)?;
  216|  1.34k|                current_word = String::new();
  216|    153|            LoadFactorManager {
  216|      1|                i += 1;
  217|       |        () => {
  217|       |    () => {
  217|      0|                    key_existed = true;
  217|     10|        ) -> ArraySeqMtPerS<W>
  217|     13|            t.root = insert_at_link(t.root.take(), 0, item, &mut t.next_key);
  217|      1|            self.cached_reduction = self.recalculate_reduction();
  217|      3|                    result_idx += 1;
  217|       |            for _ in 0..$n { __tree.insert($x.clone()); }
  217|       |    /// - vertices: Set of vertices
  218|      0|                Some(self.elements.nth(self.elements.length() - 1))
  218|      1|                "LabUnDirGraph {{ vertices: {:?}, labeled_edges: {:?} }}",
  218|      1|            TopDownDPMtPerS {
  218|   232M|            1 + b.left_size + b.right_size
  218|     65|                left = a.next.as_deref();
  218|       |    /// - edges: Set of labeled edges
  219|     11|                        crate::ParaPair!(move || ParamTreap::filter_inner(&left, &pred_left), move || {
  219|      4|            self.entries = ArraySeqStEphS::from_vec(difference_entries);
  219|     65|                right = b.next.as_deref();
  219|       |    /// - seed: Random seed for reproducibility
   21|       |        ) -> ArraySeqMtEphS<T>;
   21|       |        ) -> T;
  220|      0|                let _ = roots.insert(root);
  220|     18|                    (1.0 / load_factor) * (1.0 / (1.0 - load_factor)).ln()
  220|      1|            a.length() == 1
  220|      9|                i += 1;
  221|      0|            self.seq_s = s;
   22|    113|            ArraySeqMtEphS {
  221|      2|            *self = Self::empty();
  221|     34|            Self { tree }
  221|     41|            Self { tree }
  221|     41|            Self { tree }
  221|     44|            Self { tree }
  221|     48|            Self { tree }
  221|     48|            Self { tree }
  221|      5|                Some(entries.nth(size - 1).0.clone())
  221|       |macro_rules! MinEditDistStEphLit {
  221|       |    /// - vertices_vec: Vector of vertices
  222|      0|            new_chain = ArraySeqStPerS::append(&new_head, &new_chain);
  222|      0|            self.clear_memo(); // Clear memo when sequences change
  222|     10|                pq = pq.insert(element);
  222|     14|            > = FlatHashTable::create_table(linear_strategy.clone(), table_size);
  222|    271|                        crate::ParaPair!(move || ParamBST::filter_inner(&left, &pred_left), move || {
   22|    234|            Node {
  222|      4|            a.length() == 0
   22|     25|            ArraySeqMtPerS {
  222|       |    /// - edges_vec: Vector of labeled edges
   22|      2|                FlatEntry::Occupied(k, _) if k == &key => {
  222|       |    /// - Set of edge labels in the MST
  223|    129|            new_chain = ArraySeqStPerS::append(&new_head, &new_chain);
  223|    165|            words = ArraySeqStPerS::append(&words, &single_seq);
  223|     16|            TableStPer {
  223|     20|                actual_diversity / expected_diversity
  223|      2|                "AdvancedLinearProbing(clustering_enabled: {})",
  223|      3|        ) -> ArraySeqStPerS<Pair<K, ArraySeqStPerS<V>>> {
  223|       |    /// - mst_labels: Accumulated MST edge labels
  224|      0|                        count += 1;
  224|       |    /// - rng: Random number generator
  225|       |        () => {
  225|   150M|        n.left_size = size_link(&n.left);
  225|      1|            Self {
  225|      2|            self.key == other.key && (self.prob.value() - other.prob.value()).abs() < f64::EPSILON
  225|      4|            self.entries = ArraySeqMtEphS::from_vec(mapped_entries);
  226|       |        () => {{
  226|      0|                "LabDirGraph {{ vertices: {:?}, labeled_arcs: {:?} }}",
  226|      0|    ) -> (Set<V>, HashMap<V, V>) {
  226|   150M|        n.right_size = size_link(&n.right);
  226|     18|                1.0 / (1.0 - load_factor)
  226|  1.99k|                move || <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::map(&left, f_clone),
  227|  1.99k|                move || <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::map(&right, f)
  227|      4|            a.length() == 1
  227|  5.81k|            AVLTreeSeqStPerS {
  227|      6|            write!(f, "({}, {}, {})", self.0, self.1, self.2)
  227|      8|    ) -> Set<usize> {
  227|       |    /// - graph: Complete weighted undirected graph (metric: satisfies triangle inequality)
  227|       |    /// - Set of edge labels in the MST
  228|       |        () => {
  228|       |    () => {
  228|      1|                                result = result.resize(new_size);
  228|       |    /// - spanning_tree: Spanning tree edges (ideally MST)
  229|      0|            self.seq_t = t;
  229|   150M|        n.height = 1 + hl.max(hr);
  229|      7|                acc = f(&acc, &item);
  229|       |    /// - start: Starting vertex for tour
   22|       |        ) -> ArraySeqStPerS<Pair<N, &'static str>>;
   22|       |        ) -> Set<Edge<V>>;
  230|      0|            self.clear_memo(); // Clear memo when sequences change
  230|      0|            writeln!(f, "=== {} ===", self.example_name)?;
  230|      1|            self.seq_s == other.seq_s && self.seq_t == other.seq_t && *self_memo == *other_memo
   23|      0|                    table.table[slot] = FlatEntry::Occupied(key, value);
   23|  1.07k|            Node {
  231|      0|                let _ = map.insert(v.clone(), v.clone());
  231|      0|            writeln!(f, "{}", self.description)?;
   23|    117|            Node {
  231|     20|            SecondaryClusteringMetrics {
   23|    204|            Node {
  232|      0|                new_buckets = ArraySeqStPerS::append(&new_buckets, &single_seq);
  232|     14|            > = FlatHashTable::create_table(quadratic_strategy.clone(), table_size);
  232|      1|            writeln!(f, "  Total clusters: {}", self.total_clusters)?;
  232|      2|            OrderedSetMtEph {
  232|      3|                self.index += 1;
  232|       |    /// - (tour, weight): Hamiltonian cycle and its total weight
  233|      1|            writeln!(f, "  Max cluster size: {}", self.max_cluster_size)?;
   23|    326|            Node {
  233|     29|    ) -> Set<usize> {
  233|  8.96k|                new_buckets = ArraySeqStPerS::append(&new_buckets, &single_seq);
233 |         let _ = source_mut.set(0, 99);
  234|       |        () => {{
  234|       |        () => { $crate::Chap19::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS::from_vec(Vec::new()) };
  234|  1.29k|                new_elements = ArraySeqStPerS::append(&new_elements, &single_seq);
  234|      1|            *self_dims == *other_dims
  234|      1|            writeln!(f, "  Avg cluster size: {:.2}", self.avg_cluster_size)?;
  234|      3|                        *e.get_mut() += 1;
  235|       |        () => {
  235|       |        () => {{
  235|      0|                    move || parallel_nminus(left_arcs, v_left),
  235|      0|                new_elements = ArraySeqStPerS::append(&new_elements, &single_seq);
  235|      0|                probe_index += 1;
  235|      0|        y.left = t2;
  235|      1|            writeln!(f, "  Clustering coefficient: {:.3}", self.clustering_coefficient)?;
  235|      3|                        group.1 = ArraySeqStPerS::from_vec(values);
  236|      0|                    move || parallel_nminus(right_arcs, v_right)
  236|      1|            write!(f, "  Probe variance: {:.3}", self.probe_variance)
  236|      3|                        found_group = true;
  236|       |        ) -> LinkedListStEphS<Pair<A, LinkedListStEphS<Bv>>>;
  237|      0|                writeln!(f, "{}", probe_viz)?;
  237|      0|        x.right = Some(y);
  237|      1|    ) -> (std::vec::Vec<V>, OrderedFloat<f64>) {
  238|      0|                self.num_elements + 1
  238|      1|            Self {
  238|      1|            self.seq_s == other.seq_s && self.seq_t == other.seq_t && *self_memo == *other_memo
  238|     21|            table_size > 8 && // Don't shrink below minimum size
  238|    230|        for _ in 0..size {
  238|     27|        for (_, _, w, label) in edges.iter() {
  238|       |macro_rules! OBSTMtPerLit {
  239|      0|                "DocumentIndex(words: {}, total_mappings: {})",
  239|    129|                self.num_elements + 1
  239|      1|            *self_keys == *other_keys
  239|    230|            x = (x * 1103515245 + 12345) % (1i64 << 31); // Linear congruential generator
   23|       |            loop {
   23|       |        ) -> Set<LabEdge<V, OrderedFloat<f64>>>;
  240|      0|                    self.entries = ArraySeqMtEphS::empty();
  240|     21|                total += *w;
  240|    230|            result.push((x % 1000) as i32);
  241|      0|            NestedHashTable {
   24|      1|                    table.table[slot] = FlatEntry::Occupied(key, value);
  242|      0|            writeln!(f, "{}", self.clustering_analysis)?;
  242|    129|            SeparateChainingHashTable {
  243|    410|            BSTRBMtEph {
  244|       |        () => {
  244|      0|                    let _ = out.insert(Pair(a.clone(), b.clone()));
  244|    175|                node.color = Color::Black;
   24|    494|            Node {
  245|       |    () => {
  245|      0|                let _ = result_map.insert(u.clone(), component.clone());
  245|      0|            write!(f, "{}", self.performance_summary)
  245|     10|            self.entries = filtered;
  245|      1|            AVLTreeSeqMtPerIter {
  245|      2|                    let _ = result.set(*index, value.clone());
  245|     67|                    count += 1;
   24|    608|            Node {
  246|  17.6M|        x.right = t2;
   24|    624|            Node {
  247|       |        () => {
  247|       |        () => {
  247|      0|            Set { data: out }
  247|      1|            AVLTreeSeqStPerIter {
   47|       |        // {2, 7, 8, 11} ∪ {7, 9, 11, 14, 17} = {2, 7, 8, 9, 11, 14, 17}
  248|  17.6M|        y.left = Some(x);
  248|      1|                self.tree = Self::rebuild_from_vec(values);
  248|      8|                acc = f(&acc, a.nth(i));
248 |         let _ = target_mut.set(2, 77);
  249|     28|        for (_, (_, _, label)) in partition.iter() {
  249|    982|            TableStPer { entries: filtered }
   24|       |        ) -> std::vec::Vec<V>;
  250|    157|                    new_table = new_table.insert_without_resize(key.clone(), value.clone());
  250|     15|                acc = f(&acc, a.nth(i));
  250|     28|            let _ = new_mst_labels.insert(*label);
  250|      5|                Some(entries.nth(size - 1).0.clone())
   25|  1.02k|            Node {
  251|      0|            let _ = self.data.insert(x);
  251|      4|                &|i| {
  251|      5|            BinaryHeapPQ { elements: heapified }
   25|  1.76k|            Node {
   25|     20|            for _ in 0..size {
  252|      1|                "MatrixChainMtEph(matrices: {}, memo_entries: {})",
  252|  24.9k|                node.color = Color::Black;
  252|    271|                        crate::ParaPair!(move || ParamBST::reduce_inner(&left, &op_left, left_base), move || {
  252|      4|                        move || ParamTreap::reduce_inner(&left, &op_left, left_base),
  253|      0|                    write!(f, ", ")?;
  253|     11|                    count += 1;
  253|      1|        probe_index += 1;
  253|      1|            *self = Self::empty();
  253|      4|                        move || ParamTreap::reduce_inner(&right, &op_right, right_base)
   25|      3|                FlatEntry::Empty | FlatEntry::Deleted => {
  254|       |        () => {
  254|       |        () => { $crate::Chap19::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS::from_vec(Vec::new()) };
  254|  10.0k|                    result = result.union(&plus_u);
  255|      0|                write!(f, "{}", self.elements.nth(i))?;
  255|     11|            AVLTreeSetMtEph {
  255|      1|                    found_value = Some(pair.1.clone());
  255|      1|                OrderedSetMtEph {
  255|      2|                        b.nth_cloned(i - a.length())
   25|      5|                &|i| {
  255|       |        /// ⭐ THE STAR OPERATION: Efficient meld following right spines!
  256|     14|            ClusteringComparison {
  256|     28|            let _ = full_partition.insert(tail.clone(), head.clone());
  257|      0|            write!(f, "]")
  257|      3|        ) -> ArraySeqStEphS<Pair<K, ArraySeqStEphS<V>>> {
  257|    560|            for _ in 0..max_probes {
  258|       |        ($($id:expr => $content:expr),* $(,)?) => {{
  258|      1|                OrderedSetMtEph {
  258|      1|                values[index] = item;
  258|    312|            LeftistHeapPQ {
  258|     67|                        result = Op::combine(result, Self::range_reduce_link(&node.left, low, high));
  258|       |                .stack_size(32 * 1024 * 1024) // 32MB stack for unconditional parallelism
  259|     42|            let _ = full_partition.insert(v.clone(), v.clone());
  259|    560|                current_pos = (current_pos + h2_value) % table_size;
   25|       |        ) -> UnDirGraphStEph<Set<V>>;
  260|      0|                let _ = s.insert(x);
  260|      2|            BinaryHeapPQ { elements: heapified }
  261|      0|                n.left = Some(rotate_left(left));
  261|      0|                self.cached_reduction = other_reduction;
  261|     20|                self.entries = ArraySeqStEphS::from_vec(updated_entries);
   26|  1.58k|            Node {
   26|  20.5M|            AVLTreeNode {
  262|      0|            Set { data: s }
  262|    821|                        insert_pos = i;
   26|     28|                FlatEntry::Empty | FlatEntry::Deleted => {
  262|       |                .stack_size(32 * 1024 * 1024) // 32MB stack for unconditional parallelism
  263|       |        () => {
  263|      0|                self.cached_reduction = old_reduction;
  263|      0|            ) -> Set<V> {
  263|      0|            write!(f, "{{")?;
  263|      1|            let _ = a.set(index, item);
  263|      5|                cur = n.left.as_deref();
  263|     71|                        result = Op::combine(result, Op::lift(&node.value));
  264|       |        () => {
  264|      2|            acc = f(&acc, &item);
  264|     45|                    non_empty_buckets += 1;
  264|       |                docs = $crate::Chap19::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS::append(&docs, &single_seq);
  265|      1|                self.cached_reduction = (self.reducer)(&old_reduction, &other_reduction);
  265|     45|                    total_chain_length += chain_length;
  266|      2|                .filter_map(|v| {
  267|      0|                    write!(f, ", ")?;
  267|     16|            HashTableStats {
  268|       |        () => {{
  268|       |        () => {{
  268|      0|                n.right = Some(rotate_right(right));
  268|     10|                        total_collisions += chain_length - 1;
  268|    157|                        insertion_pos = Some(hash_pos);
  268|     18|            new_data[index] = item;
  268|      6|                acc = f(&acc, &item);
  268|     74|                        result = Op::combine(result, Self::range_reduce_link(&node.right, low, high));
  269|       |        () => {
  269|       |        () => {
  269|       |        () => {
  269|       |        () => {
  269|       |        () => {
  269|       |        () => {
  269|      0|                write!(f, "{:?}", seq.nth(i))?;
  269|      2|                    values[idx] = val;
  269|  8.29k|                    &|i| {
   26|       |        ) -> Set<(V, LabeledEdge<V>)>;
   26|       |        ) -> std::vec::Vec<V>;
   26|       |        ) -> UnDirGraphMtEph<V>;
  270|      0|            write!(f, "[")?;
  270|      0|            write!(f, "[")?;
  270|  1.98k|                self.entries = ArraySeqStEphS::from_vec(new_entries);
  270|       |                pq = pq.insert($x);
  271|       |        () => {
  271|      0|                    non_empty_buckets += 1;
  271|      0|            write!(f, "}}")
  271|      2|        TextbookExampleResults {
   27|     13|                &|x| {
  271|     45|                    max_chain_length = max_chain_length.max(chain_length);
   27|    199|            Node {
  272|      0|                    total_chain_length += chain_length;
  272|     19|        ) -> f64 {
  273|      0|                            insertion_pos = Some(hash_pos);
  273|      0|                    write!(f, ", ")?;
  273|      1|        ) {
  273|      2|                    let _ = out.set(idx, val);
  273|    494|            AVLTreeSetMtPer {
  273|      8|            values.push(acc.clone()); // Include initial value
   27|      3|                    table.table[slot] = FlatEntry::Occupied(key, value);
  274|      0|        let _: usize = left;
  274|      0|                self.cached_reduction = other_reduction;
  274|      0|                    write!(f, ", ")?;
  274|      7|                    1.0 - (1.0 - load_factor).ln() / load_factor
  274|     82|            (h1_value + probe_index * h2_value) % table_size
  274|      8|            Self {
   27|  49.9M|                    slice[j] = slice[j - 1].clone();
  275|      0|        let _: DocumentCollection = DocumentCollectionLit![
  275|      0|        let _: usize = right;
  275|      0|                        total_collisions += chain_length - 1;
  275|      0|                write!(f, "{:?}", self.nth(i))?;
  275|  3.39k|                            updated.entries.nth(i - 1).clone()
  275|      3|            *self = Self::empty();
  276|      0|            "doc1" => "hello world",
  276|      0|                first = false;
  276|      0|                self.cached_reduction = old_reduction;
  276|     22|                acc = f(&acc, item);
  277|      0|            "doc2" => "world peace"
  277|      0|            write!(f, "]")
  277|      0|            write!(f, "{{")?;
  277|      0|                write!(f, "{}", v)?;
  277|    122|    ) -> Vec<LabeledEdge<V>> {
  277|      4|            self.entries = filtered;
  277|      8|                    result = result.set(*index, value.clone()).unwrap_or(result);
  278|      0|                            insertion_pos = Some(hash_pos);
  278|      0|        let _: SortedListPQ<i32> = SortedListPQLit![];
  278|      0|                    max_chain_length = max_chain_length.max(chain_length);
  278|      0|                *self = Self::empty();
  278|     16|            self.num_collisions = collisions;
  278|     19|                base_score + clustering_penalty + variance_penalty
  278|      1|                self.cached_reduction = (self.reducer)(&old_reduction, &other_reduction);
  278|  20.5M|                debug_assert!(index == 0, "insert_at_link reached None with index > 0");
  278|    973|                    updated.entries.length() + 1,
  279|      0|        let _: DocumentCollection = DocumentCollectionLit![];
  279|      0|        let _: SortedListPQ<i32> = SortedListPQLit![1, 2, 3];
  279|      0|            write!(f, "]")
  279|     16|            self.max_chain_length = max_chain;
  279|     18|                acc = f(&acc, a.nth(i));
  279|      4|                result = result.insert(element.clone());
  279|    803|            a.length() == 0
   27|       |        ) -> Set<LabEdge<V, OrderedFloat<f64>>>;
  280|      0|                load_factor * 100.0 // Simple load factor based score
  280|      0|                    ParaPair!(move || parallel_nplus_of_vertices(left_verts, graph_left), move || {
  280|     16|            self.avg_chain_length = avg_chain;
  280|  20.5M|                *next_key += 1;
  280|     22|                1.0 / (1.0 - load_factor)
  281|      0|                    write!(f, ", ")?;
  281|      0|            write!(f, "{{")?;
  281|     18|            BSTReducedStEph {
  281|      3|            a.length() == 0
   28|     13|            Self {
  281|      3|            self.entries = ArraySeqMtEphS::from_vec(filtered_entries);
  281|    973|                TableStPer { entries }
   28|     20|                buckets = ArraySeqStPerS::append(&buckets, &single_seq);
  282|      1|        ) -> ArraySeqS<Pair<K, ArraySeqS<V>>> {
  282|      1|            OrderedSetStPer {
   28|     28|                    table.table[slot] = FlatEntry::Occupied(key, value);
  283|      0|                write!(f, "{}", seq.nth(i))?;
  283|      2|                .filter_map(|v| {
  283|    366|                probe_index += 1;
  283|      4|            self.entries = filtered;
  283|       |    // ---- Iterator ----
   28|      3|                    table.num_elements += 1;
  284|      0|                    write!(f, ", ")?;
  284|      2|                    write!(f, ", ")?;
  284|    804|            a.length() == 1
   28|  49.9M|                    j -= 1;
  284|       |macro_rules! AVLTreeSeqStPerLit {
  285|       |    () => { < $crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::AVLTreeSeqStPerS<_> as
  285|      0|            write!(f, "}}")
   28|      5|                        n - i,
  286|      0|                    n.left = insert_at_link(n.left.take(), index, value, next_key);
  286|      0|                write!(f, "{:?}", self.elements.nth(i))?;
  286|      3|            a.length() == 1
  286|      3|                write!(f, "{}", self.elements.nth(i))?;
  286|      9|                acc = f(&acc, a.nth(i));
  286|      9|                heaps = next_level;
  287|     17|                acc = f(&acc, a.nth(i));
  287|     23|            Self {
  287|      3|            metrics.secondary_clustering_coefficient > 0.5 || !metrics.table_size_is_prime
  287|  4.12k|            ParamBST {
  288|      0|                pq = pq.insert(element);
  288|      0|            write!(f, "}}")
  288|      1|            write!(f, "]")
  288|      2|                (BSTSizeStEph { root: left_root }, BSTSizeStEph { root: right_root })
   28|    875|            (base_hash + probe_index) % table_size
  288|  97.2M|                    n.right = insert_at_link(n.right.take(), index - left_size - 1, value, next_key);
  289|      2|                "HashTableStats {{ elements: {}, size: {}, load_factor: {:.3}, collisions: {}, max_chain: {}, avg_chain: {:.2} }}",
  289|    439|                        insert_pos = i;
   28|       |    /// - Its coin is heads (true)
  290|     16|        ) -> f64 {
  290|     33|                    new_data[*index] = value.clone();
  290|      9|                &|i| {
   29|      0|                _ => None,
  291|       |        () => {
   29|  11.3k|        Arc::new(Node {
   29|  1.23M|        Rc::new(Node {
  291|     24|        TableStEph {
  291|     33|                    result = ArraySeqStPerS::from_vec(new_data);
   29|    174|            Node {
   29|     22|        ) -> ArraySeqMtEphS<T> {
  292|      8|                    found = true;
   29|     28|                    table.num_elements += 1;
   29|     30|        ) -> T {
  293|     18|                    result = ArraySeqStPerS::append(&result, &single_seq);
   29|     36|            for _ in 0..length {
  294|      0|            write!(f, "{{")?;
  295|       |        () => {
  295|       |        () => {
  295|      0|            writeln!(f, "  Probe sequence length: {}", self.probe_sequence_length)?;
  295|     18|                current_heap = new_heap;
  295|      1|        ) -> (ArraySeqMtPerS<A>, A) {
  295|      2|                a.length() + b.length(),
   29|     54|                &|i0| {
  295|      4|            prefixes.push(acc.clone()); // Include initial value
  296|      0|            writeln!(f, "  Unique probe positions: {}", self.unique_probe_positions)?;
  296|     16|                base_score + secondary_penalty + prime_bonus + diversity_bonus
  296|      1|            Self {
  296|      1|            *self = Self::empty();
  296|   518k|                    &|i| {
  297|       |        () => {
  297|      0|                    write!(f, ", ")?;
  297|      0|            writeln!(f, "  Probe sequence period: {}", self.probe_sequence_period)?;
  297|     18|                acc = f(&acc, a.nth(i));
   97|       |        // {2, 7, 8, 11} ∪ {7, 9, 11, 14, 17} = {2, 7, 8, 9, 11, 14, 17}
  297|      2|             h_i(k) = (h(k) + i + i²) mod m. Keys that hash to the same position will \
  297|      2|            self.key == other.key && (self.prob.value() - other.prob.value()).abs() < f64::EPSILON
  297|      5|        table = table.insert("aa".to_string(), "a".to_string());
  298|      0|                load_factor * 80.0
  298|      1|                        _found_value = Some(pair.1.clone());
  298|  5.74k|                new_table = ArraySeqStPerS::append(&new_table, &single_seq);
  298|      5|        table = table.insert("bb".to_string(), "b".to_string());
  298|     63|                    count += 1;
  299|       |        () => {
  299|      0|                write!(f, "{}", self.elements.nth(i))?;
  299|  10.0k|                    result = result.union(&minus_u);
  299|      5|                acc = f(&acc, a.nth(i));
  299|      5|        table = table.insert("cc".to_string(), "c".to_string());
   29|       |    /// - All edges incident on its endpoints flipped tails (false)
   29|       |        ) -> Set<Set<V>>;
   30|      0|                _ => {
  300|       |        () => { $crate::Chap18::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS::from_vec(Vec::new()) };
  300|      5|        table = table.insert("dd".to_string(), "d".to_string());
   30|  10.0k|                slice[j] = key;
  301|      0|            write!(f, "}}")
  301|    450|            (base_hash + quadratic_offset) % table_size
  301|      5|        table = table.insert("ee".to_string(), "e".to_string());
  301|       |                pq = pq.insert($x);
  302|       |        ($($key:expr => $value:expr),+ $(,)?) => {{
  302|  2.47k|                            self.entries.nth(i - 1).clone()
  302|      4|                acc = f(&acc, a.nth(i));
  302|      5|        table = table.insert("ff".to_string(), "f".to_string());
  302|      6|                        i += 1;
   30|      2|            | _ => false,
  303|      0|            writeln!(f, "  Relative prime validation: {}", self.relative_prime_validation)?;
  303|      5|        table = table.insert("gg".to_string(), "g".to_string());
  303|      6|                        j += 1;
   30|      3|                visited = new_visited;
  304|      0|            OrderedSetStEph {
  304|      0|            write!(f, "  Collision avoidance score: {:.3}", self.collision_avoidance_score)
  304|     10|                cursor = &node.left;
  304|    157|                self.num_elements + 1
  304|      1|                    found = true;
  304|      5|        table = table.insert("hh".to_string(), "h".to_string());
  305|       |        () => {
  305|  2.58k|                    self.entries.length() + 1,
  305|      5|        table = table.insert("ii".to_string(), "i".to_string());
   30|      5|            all_prefixes_vec.push(0); // empty prefix
  306|      3|            *self = Self::empty();
  306|      5|        table = table.insert("jj".to_string(), "j".to_string());
  307|       |        () => {
  307|      2|        TextbookExampleResults {
  307|      6|                    found = true;
  308|       |        () => {
  308|       |        () => { $crate::Chap18::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS::from_vec(Vec::new()) };
  308|      0|                self.num_deleted - 1
  308|      0|            ) -> Set<V> {
  308|  2.58k|                TableStPer { entries }
  308|      4|            self.entries = ArraySeqMtEphS::from_vec(intersection_entries);
  309|      0|        let _: BalancedTreePQ<i32> = BalancedTreePQLit![];
  309|    116|                    count += 1;
  309|      1|                        group.1 = ArraySeqMtEphS::from_vec(values);
  309|      7|            Self {
   31|       |    > {
  310|      0|        let _: BalancedTreePQ<i32> = BalancedTreePQLit![1, 2, 3];
  310|      0|                    write!(f, "  bucket[{}]: ", i)?;
  310|     10|                current_heap = new_heap;
  310|     16|                base_score + independence_bonus + prime_bonus + collision_bonus
  310|      1|                        found_group = true;
  310|      4|                acc = f(&acc, a.nth(i));
   31|      1|                _ => {
   31|  1.17k|            left + right
  312|      0|                candidate += 2;
  312|      0|                load_factor * 60.0
   31|  24.9k|            Node {
   31|      2|            NestedHashTable {
  313|    157|            FlatHashTable {
   31|     39|            AVLTreeNode {
  314|      0|                            write!(f, ", ")?;
  314|      3|            TableStPer { entries: filtered }
  314|      5|                    values[idx] = val;
   31|      4|            SpinLock {
  315|       |        () => {
  315|      0|        let _: ArraySeqStEphS<i32> = ArraySeqStEphS![];
  315|      9|                    n.value = value;
   31|      5|        distances = ArraySeqStPerS::update(&distances, source, 0);
   31|      5|        let _ = distances.set(source, 0);
   31|      5|                        visited = new_visited;
  316|      0|        let _: ArraySeqStEphS<&str> = ArraySeqStEphS!["alpha", "beta"];
  316|      0|                        write!(f, "({} → {})", pair.0, pair.1)?;
  317|      0|        let _: ArraySeqStEphS<i64> = ArraySeqStEphS![1; 2];
   31|      7|            &|x| {
  318|  1.62k|            *guard = new_state;
  318|       |    /// - vertices: Set of vertices
  319|       |        () => {
  319|      3|            TableStPer { entries: filtered }
  319|      5|                pq = pq.insert(element);
  319|       |    /// - edges: Set of labeled edges
  319|       |    // ---- Internal helpers ----
   31|       |        ) -> Option<OrderedF64>;
  320|      4|                acc = f(&acc, a.nth(i));
  320|       |    /// - seed: Random seed for reproducibility
   32|      0|                    table.table[slot] = FlatEntry::Occupied(key, value);
  321|       |        () => { $crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::ArraySeqMtPerS::from_vec(Vec::new()) };
   32|  1.02k|                &|i| {
   32|     12|                visited = new_visited;
   32|     13|            Self {
   32|     15|    ) -> AVLTreeSetStPer<N> {
   32|      1|                    table.table[slot] = FlatEntry::Occupied(key, value);
  322|      0|            write!(f, "}}")
  322|      1|            writeln!(f, "  Collision chains: {}", self.collision_chains)?;
  323|      1|            writeln!(f, "  Max chain length: {}", self.max_chain_length)?;
  323|      3|                    result = ArraySeqStPerS::append(&result, &single_seq);
  323|     51|        ) -> ClusteringPerformanceImpact {
  323|       |    /// - Set of edge labels in the MST
  324|      1|            writeln!(f, "  Avg chain length: {:.2}", self.avg_chain_length)?;
  324|     74|            1 + b.left_size + b.right_size
  325|      0|                    ParaPair!(move || parallel_nminus_of_vertices(left_verts, graph_left), move || {
  325|      5|                acc = f(&acc, &item);
  325|     73|                move || <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::reduce(&left, f_clone, id_clone),
   32|      5|        distances = ArraySeqMtPerS::update(&distances, Pair(source, 0));
   32|      5|        let _ = distances.set(source, 0);
   32|      5|                        rec_stack = new_rec_stack;
  326|       |        () => { $crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::AVLTreeSeqStEphS::from_vec(Vec::new()) };
  326|      5|                    values[idx] = val;
  326|     73|                move || <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::reduce(&right, f_clone2, id)
  326|      7|                        i += 1;
  327|     27|        TableStPer {
  328|       |        () => { $crate::Chap19::ArraySeqMtPer::ArraySeqMtPer::ArraySeqMtPerS::from_vec(Vec::new()) };
  328|     27|            *guard = new_state;
  328|      3|            result = ArraySeqStPerS::append(&result, &single_seq);
  328|      4|                acc = f(&acc, &current);
  328|      9|    ) -> Set<usize> {
  329|       |            for _ in 0..$n { t.push_back($x); }
   32|       |        ) -> Option<OrderedF64>;
  330|      0|                        j += 1;
  330|      1|            writeln!(f, "  Probe sequence diversity: {:.3}", self.probe_sequence_diversity)?;
   33|      0|                    table.num_elements += 1;
  331|      1|            write!(f, "  Table size is prime: {}", self.table_size_is_prime)
  331|     38|        n.left_size = size_link(&n.left);
  331|      5|            output.push_str(&format!("  '{}': {:?}\n", key, sequence));
   33|      1|                    table.num_elements += 1;
  332|     38|        n.right_size = size_link(&n.right);
   33|     24|            running_sum += *a.nth(i);
  332|      5|            let _ = a.set(index, item);
   33|     26|                running_sum += *a.nth(i);
  334|       |            $( { t.push_back($x); } )*
  334|      0|                *self = Self::empty();
  335|       |        () => {
  335|       |        () => {
  335|     12|                acc = f(&acc, a.nth(i));
  335|     38|        n.height = 1 + hl.max(hr);
  335|      3|                        i += 1;
  335|      5|                acc = f(&acc, a.nth(i));
   33|      5|            all_prefixes_vec.push(0); // empty prefix
   33|      5|                        result = new_result;
  336|      3|                        j += 1;
  338|       |        ($($key:expr => $value:expr),+ $(,)?) => {{
  339|       |        () => {
  339|      0|            write!(f, "[")?;
  339|    116|                    count += 1;
   33|       |        ) -> Set<Set<V>>;
   33|       |        ) -> UnDirGraphMtEph<V>;
  340|      2|                    write!(f, ", ")?;
  340|      8|                acc = f(&acc, &current);
   34|      0|    ) -> ArraySeqStPerS<Pair<N, &'static str>> {
  341|      2|        TextbookExampleResults {
  341|     37|        for (_, _, w, label) in edges.iter() {
  342|      0|                    write!(f, ", ")?;
  342|      0|        y.left = t2;
  342|      2|                result = result.meld(heap);
  342|      3|                write!(f, "{}", self.elements.nth(i))?;
   34|     24|            min_prefix = min_prefix.min(running_sum);
  342|      6|                    let _ = out.set(idx, val);
   34|    285|            debug_assert!(value >= 0.0, "Probability must be non-negative");
  343|     28|                total += *w;
  343|    541|            ParamTreap {
  344|       |        ($size:expr) => {
  344|      0|                write!(f, "{}", item)?;
  344|      1|                i += 1;
  344|      1|        ) -> (LinkedListStPerS<A>, A) {
  344|      1|            OrderedTableStPer {
  344|      1|            write!(f, "]")
  345|       |        () => {
  345|      0|        x.right = Some(y);
  345|     51|            ClusteringPerformanceImpact {
  346|      0|            write!(f, "]")
  346|      1|            ("AlmostSorted".to_string(), {
  346|     23|                    result = pair.1.clone();
   34|     66|            AdvancedLinearProbingStrategy {
  347|     23|                    first = false;
   34|      7|            Self {
348 |         let _ = source_mut.set(0, 99);
  349|    108|                    result = reducer(&result, &pair.1);
  349|      3|                acc = f(&acc, a.nth(i));
  349|      4|                    size *= 2;
   34|       |    /// # Arguments
   34|       |    /// # Arguments
   34|       |        ) -> ArraySeqMtPerS<W>
   34|       |        ) -> B;
   34|       |            unsafe {
  350|  1.99k|                move || <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::reduce(&left, f_clone, id_clone),
  350|      7|                j += 1;
   35|      0|                FlatEntry::Occupied(k, _) if k == key => {
  350|       |                table = table.insert($key, $value);
  351|       |        () => {
  351|  1.99k|                move || <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::reduce(&right, f_clone2, id)
  352|       |        () => {
  352|      2|            *self = Self::empty();
   35|     24|            running_sum += a.nth_cloned(i);
  352|      6|                let _ = out.set(idx, val);
   35|      2|                    None => return None, // Cycle detected
  353|      6|            self.entries = ArraySeqMtEphS::from_vec(union_entries);
   35|    390|            (h1 + probe_index * h2_safe) % table_size
  355|      3|                    less_than = less_than.insert(element);
  355|      6|        x.right = t2;
  356|      1|            write!(f, "}}")
  357|      1|                    ParaPair!(move || left_table.reduce_val(), move || right_table.reduce_val());
  357|    233|            AVLTreeSeqStEphS {
  357|      4|                    equal_or_greater = equal_or_greater.insert(element);
  357|       |                pq = pq.insert($x);
  358|      0|        let _: StringNestedHashTable<i32> = NestedHashTableLit!(8, ("key1".to_string(), 1), ("key2".to_string(), 2));
  358|     22|        OrderedTableStPer {
  358|      6|        y.left = Some(x);
   35|       |    /// - Base case: No edges, call base function on vertices
   35|       |    /// * `graph` - Weighted directed graph with float weights (can be negative)
   35|       |    /// * `graph` - Weighted directed graph with integer weights (can be negative)
   35|       |        ) -> OrderedFloat<f64>;
  360|      1|        ) -> ComprehensiveClusteringAnalysis {
  360|      2|        ) -> LinkedListStEphS<Pair<A, LinkedListStEphS<Bv>>> {
  360|      2|            OrderedTableStEph {
   36|      0|                    *self = FlatEntry::Deleted;
  361|      1|            ComprehensiveClusteringAnalysis {
   36|     12|                    components = AVLTreeSeqStPerS::from_vec(vec);
   36|    132|                    left_count += 1;
   36|    135|                    left_count += 1;
   36|     13|                        &|y| {
   36|    157|                    left_count += 1;
  361|      5|                acc = f(&acc, &item);
  362|       |        () => {{
   36|    207|        let _ = write!(&mut buf, "{:?}", key);
   36|     24|            min_prefix = min_prefix.min(running_sum);
   36|     26|                running_sum += a.nth_cloned(i);
363 |         let _ = target_mut.set(2, 77);
  364|      0|                *self = Self::empty();
  364|      1|                "AugOrderedTableStEph(size: {}, reduction: {})",
  364|      4|                        group.1 = ArraySeqMtPerS::from_vec(values);
  365|      0|        let _: BinaryHeapPQ<i32> = BinaryHeapPQLit![];
  365|      4|                        found_group = true;
  366|       |        () => {
  366|      0|        let _: BinaryHeapPQ<i32> = BinaryHeapPQLit![1, 2, 3];
  366|     60|                    hash_value % table_size
   36|  6.96k|            self.height = 1 + height_of(&left).max(height_of(&right));
  369|       |        ($($key:expr => $val:expr),+ $(,)?) => {{
   36|    966|            (base_hash + quadratic_offset) % table_size
   36|       |        ) -> ArraySeqMtEphS<U>;
   36|       |    /// - graph: The undirected graph
   36|       |    /// - graph: The undirected graph to partition
   36|       |    /// - Recursive case: Partition graph, build quotient graph, recur, then expand
   36|       |    /// * `source` - Source vertex (0-indexed)
   36|       |    /// * `source` - Source vertex (0-indexed)
  370|      6|                        i += 1;
  370|      9|            ArraySeqMtEphSliceS {
   37|  1.03k|                    hash ^= byte as u64;
  371|      2|                let _ = out.set(idx, val);
   37|     15|    ) {
   37|      1|                    node.value = value;
   37|      1|            write!(f, "({}, {}, {})", self.0, self.1, self.2)
  372|      0|                n.left = Some(rotate_left(left));
  372|    206|            *guard = new_state;
   37|  22.6k|            ArraySeqMtEphS {
  373|       |        () => {
  373|      0|                        j += 1;
  374|     21|        OrderedTableStEph {
  374|      2|        TextbookExampleResults {
  375|      4|                    left = left.insert(current.clone());
  376|      4|                        i += 1;
  376|      5|                seq = ArraySeqStPerS::append(&seq, &single_seq);
   37|  6.96k|            self.size = 1 + size_of(&left) + size_of(&right);
  377|      1|                    found = true;
  377|      4|                        j += 1;
  378|      1|                    right = right.insert(current.clone());
  379|       |        () => { $crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::ArraySeqMtEphS::from_vec(Vec::new()) };
  379|      1|        > = FlatHashTable::create_table(strategy_composite.clone(), 16);
   37|       |    /// - graph: The undirected graph
   37|       |        ) -> OrderedFloat<f64>;
  380|      0|                n.right = Some(rotate_right(right));
  380|      5|                    right = right.insert(current.clone());
  380|      7|                acc = f(&acc, a.nth(i));
   38|    101|                    right_count += 1;
   38|  1.03k|                    hash = hash.wrapping_mul(0x100000001b3); // FNV prime
   38|    105|                    right_count += 1;
   38|    108|                    left_count += 1;
  381|      0|            writeln!(f, "=== Comprehensive Clustering Analysis ===")?;
  381|     21|                    result = pair.1.clone();
  381|      2|            *self = Self::empty();
   38|    132|                    right_count += 1;
   38|     16|        total - min_prefix
  382|       |        () => {
  382|     21|                    first = false;
  382|    427|                    result = result.set(*index, value.clone()).unwrap_or(result);
  382|      4|            *guard = new_state;
   38|    311|                head = Some(Box::new(NodeE { value, next: head }));
   38|  4.08k|            ArraySeqMtPerS {
   38|    448|            for _ in 0..size {
  384|     99|                    result = reducer(&result, &pair.1);
  385|       |        ($($key:expr => $val:expr),+ $(,)?) => {{
  385|      1|                i += 1;
  385|     40|                    result = pair.1.clone();
  386|      0|        let _: ArraySeqS<i32> = ArraySeqS![];
  386|     40|                    first = false;
  387|      0|        let _: ArraySeqS<&str> = ArraySeqS!["a", "b", "c"];
  388|      0|        let _: ArraySeqS<i64> = ArraySeqS![0; 3];
  388|  3.77k|                    result = reducer(&result, &pair.1);
  388|      4|            OrderedTableMtEph {
  388|      4|            self.entries = ArraySeqMtEphS::from_vec(difference_entries);
   38|       |    /// - graph: The undirected graph to partition
   38|       |    /// - Phase 1: Bellman-Ford on G' (n+1 vertices, m+n edges): Work O((n+1)(m+n)) = O(nm), Span O(nm)
   38|       |    /// # Returns
   38|       |    /// # Returns
   38|       |    /// - seed: Random seed for star partition
  390|      3|                acc = f(&acc, a.nth(i));
   39|      0|                _ => false,
   39|    122|                &|i| {
  391|     39|                debug_assert!(index == 0, "insert_at_link reached None with index > 0");
   39|     13|                                n + 1 - 2 + 1, // z: 2..=n+1 has length n
   39|     16|            TopDownDPStEphS {
   39|     16|            TopDownDPStPerS {
  392|       |        () => {
  392|      0|                writeln!(f, "{}", primary)?;
   39|      2|                    found_idx = Some(idx);
  393|     39|                *next_key += 1;
   39|     35|            for _ in 0..n {
  394|      5|                bucket_counts[hash_value] += 1;
  396|      0|                    total_collisions += 1;
  396|      8|            .map(|lf| {
  397|      0|                writeln!(f, "{}", secondary)?;
  398|      5|                max_count = max_count.max(bucket_counts[hash_value]);
  399|      0|                    n.left = insert_at_link(n.left.take(), index, value, next_key);
  399|      1|                "AugOrderedTableStPer(size: {}, reduction: {})",
  399|      2|        ) -> LinkedListStPerS<Pair<A, LinkedListStPerS<Bv>>> {
   39|       |    /// - A set of edges forming a vertex matching (no two edges share an endpoint)
   39|       |    /// - Base case: No edges, call base function on vertices
   39|       |        ) -> bool;
   39|       |    /// - (centers, partition_map): Set of center vertices and mapping from each vertex to its center
   39|       |    /// - graph: The undirected graph
   39|       |    /// * `Ok(SSSPResultStEphFloat)` - Shortest paths if no negative-weight cycles
   39|       |    /// * `Ok(SSSPResultStEphInt)` - Shortest paths if no negative-weight cycles
   39|       |    /// - Phase 1: Bellman-Ford on G' (n+1 vertices, m+n edges): Work O((n+1)(m+n)) = O(nm), Span O(nm)
   39|       |    /// - Phase 2: Reweight m edges: Work O(m), Span O(m)
   39|       |    /// - seed: Random seed for coin flips
   39|       |        ) -> Set<LabeledEdge<V>>;
    3|       |//! G = (bool seq) seq - for enumerable vertex sets V = {0, 1, ..., n-1}.
    3|       |//! G = (int seq) seq - for enumerable vertex sets V = {0, 1, ..., n-1}.
    3|       |//! G = (V, A:) where the graph is represented as a table mapping vertices to their out-neighbor sets.
    3|       |//! G = (V, A:) where V is a set of vertices and A: ⊆ V × V is a set of directed arcs.
    3|       |//! G = (V, E) where V is a set of vertices and E ⊆ V × V is a set of edges.
    3|       |//! G = (V × V set) table - maps vertices to sets of their out-neighbors.
    3|       |//! Stack - Sequential Ephemeral implementation
  400|      1|                "AugOrderedTableMtEph(size: {}, reduction: {})",
  400|      4|                    result = result.insert(current.clone());
  401|     20|                    n.right = insert_at_link(n.right.take(), index - left_size - 1, value, next_key);
   40|    127|                    right_count += 1;
   40|     12|                    components = AVLTreeSeqStEphS::from_vec(vec);
   40|    136|            LinkedListStEphS { head, len }
   40|     16|        total - min_prefix
   40|     19|    ) -> B {
  402|      0|                writeln!(f, "{}", double)?;
  402|     36|        OrderedTableMtEph {
  403|      0|        let _: LeftistHeapPQ<i32> = LeftistHeapPQLit![];
   40|     38|            for _ in 0..n {
   40|      3|                "DoubleHashing({}, {})",
  404|      0|        let _: LeftistHeapPQ<i32> = LeftistHeapPQLit![1, 2, 3];
   40|     42|                print!(", ");
   40|      5|                current = &mut node.next;
  406|      0|            write!(f, "{}", self.performance_impact)
  406|      1|            write!(f, "[")?;
   40|      7|            Self {
  409|      2|                    write!(f, ", ")?;
   40|       |        ) -> bool;
   40|       |    /// * `Err(String)` - Error message if negative-weight cycle detected
   40|       |    /// * `Err(String)` - Error message if negative-weight cycle detected
   40|       |    /// - Phase 2: Reweight m edges: Work O(m), Span O(m)
   40|       |    /// - Phase 3: n sequential Dijkstra runs: Work O(n * m log n) = O(mn log n), Span O(mn log n)
   40|       |    /// - Recursive case: Parallel partition, parallel quotient construction, recur, then expand
   40|       |    /// - seed: Random seed for reproducibility
  411|       |        () => {
   41|     11|    ) -> LinearProbingHashTable<String, V, StringPositionHashFunction> {
  411|      1|        ) -> std::time::Duration {
  411|      3|                first = false;
   41|     16|            TopDownDPMtEphS {
   41|     16|            TopDownDPMtPerS {
   41|     19|    ) -> (B, AVLTreeSetStPer<N>) {
  412|      3|                write!(f, "{}", item)?;
   41|     35|            for _ in 0..n {
  414|       |        ($($key:expr => $val:expr),+ $(,)?) => {{
  414|      1|            write!(f, "]")
   41|    448|                buckets = ArraySeqStPerS::append(&buckets, &single_seq);
  414|      5|                let _ = hash_fn.hash(key, table_size);
  418|      7|                result = result.insert(mapped);
  419|       |        () => { $crate::Chap18::LinkedListStPer::LinkedListStPer::LinkedListStPerS::from_vec(Vec::new()) };
   41|       |    /// - Phase 3: n sequential Dijkstra runs: Work O(n * m log n) = O(mn log n), Span O(mn log n)
   41|       |    /// - Set of edges forming a spanning tree
   41|       |    /// - Total: Work O(mn log n), Span O(mn log n)
  420|     38|        for _ in 0..length {
   42|     10|            AdjTableGraphMtPer {
   42|     13|        let _ = visited.set(vertex, true);
   42|     14|            for _ in 0..layer_size {
   42|     14|            for _ in 0..layer_size {
  422|      0|                    self.entries = ArraySeqMtEphS::empty();
   42|    228|                &|i| {
   42|     29|            for _ in 0..n {
  423|      0|            writeln!(f, "  Clustering severity: {:?}", self.clustering_severity)?;
   42|     31|                running_min = running_min.min(*all_prefixes.nth(i));
  424|      0|            write!(f, "  Recommended action: {}", self.recommended_action)
  424|       |                table = $crate::Chap43::AugOrderedTableStPer::AugOrderedTableStPer::AugOrderedTableStPerTrait::insert(&table, $k, $v);
   42|      7|                        n, // y: 1..=n has length n
  428|       |        () => { $crate::Chap19::ArraySeqMtEphSlice::ArraySeqMtEphSlice::ArraySeqMtEphSliceS::from_vec(Vec::new()) };
  428|      3|                    n.value = value;
  429|       |        () => { $crate::Chap18::LinkedListStEph::LinkedListStEph::LinkedListStEphS::from_vec(Vec::new()) };
   42|      9|            AdjSeqGraphStEph {
   42|       |    /// # Algorithm
   42|       |    /// # Algorithm
   42|       |    /// - (centers, partition_map): Set of center vertices and mapping from each vertex to its center
   42|       |    /// - graph: The undirected graph
   42|       |    /// - graph: The undirected graph to contract
   42|       |        Minimal,  // < 10% performance degradation
   42|       |        ) -> std::vec::Vec<V>;
   42|       |    /// - Total: Work O(mn log n), Span O(mn log n)
  430|      0|            writeln!(f, "=== Probing Strategy Comparison ===")?;
   43|     10|            AdjMatrixGraphStEph {
   43|     10|            visited = dfs_recursive(graph, visited, neighbor);
   43|     12|                        distances = ArraySeqStPerS::update(&distances, v, dist + 1);
   43|     12|                        let _ = distances.set(v, dist + 1);
  436|      0|                writeln!(f, "  {}. {} (score: {:.2})", i + 1, strategy, score)?;
  439|      0|            writeln!(f, "--- Linear Probing Analysis ---")?;
   43|       |    /// # Arguments
   43|       |    /// - A set of edges forming a vertex matching
   43|       |    /// - base: Function to call on the base case (isolated vertices)
   43|       |            loop {
   43|       |    /// - matching: A vertex matching (set of edges where no two share an endpoint)
   43|       |        Moderate, // 10-30% performance degradation
  440|      0|            writeln!(f, "{}", self.linear_probing)?;
   44|      1|                    FlatEntry::Empty => return None, // Stop at Empty - key not in table
  442|       |        () => {
  442|      0|            writeln!(f, "--- Quadratic Probing Analysis ---")?;
   44|     24|            SeparateChainingHashTable {
   44|      2|            AdvancedLinearProbingStrategy {
  443|      0|            writeln!(f, "{}", self.quadratic_probing)?;
   44|     34|            PQEntry {
  445|      0|            writeln!(f, "--- Double Hashing Analysis ---")?;
  446|      0|            write!(f, "{}", self.double_hashing)
   44|     77|                    &|i| {
   44|     90|                    &|i| {
   44|     98|                    &|i| {
   44|      9|            AdjSeqGraphStPer {
   44|       |    /// # Arguments
   44|       |    /// - expand: Function to expand result from quotient graph to original graph
   44|       |    /// - graph: The undirected graph
   44|       |    /// * `graph` - Weighted directed graph with integer weights (can be negative, no negative cycles)
   44|       |    /// - Phase 1: Bellman-Ford: Work O(nm), Span O(nm) - sequential
   44|       |    /// - Phase 1: Bellman-Ford: Work O(nm), Span O(nm) - sequential
   44|       |        Severe,   // 30-50% performance degradation
   44|       |        ) -> std::vec::Vec<V>;
   45|    114|                        c.nth(i / 2).clone()
   45|     17|            OrderedTableMtPer {
   45|      1|    ) -> Set<Edge<V>> {
   45|      2|                    FlatEntry::Deleted | FlatEntry::Occupied(_, _) => {
   45|      2|                    FlatEntry::Empty => return None,
   45|     31|                running_min = running_min.min(all_prefixes.nth_cloned(i));
   45|      8|            AdjMatrixGraphStPer {
   45|       |        Critical, // > 50% performance degradation
   45|       |    ///    - For each vertex v in parallel:
   45|       |    ///    - For each vertex v in parallel:
   45|       |    /// * `graph` - Weighted directed graph with float weights (can be negative, no negative cycles)
   45|       |    ///    - If find(u) ≠ find(v): add edge to MST, union(u,v)
   45|       |    /// - Phase 2: Reweighting: Work O(m), Span O(m) - sequential
   45|       |    /// - Phase 2: Reweighting: Work O(m), Span O(m) - sequential
   46|     10|            AdjTableGraphStEph {
   46|     14|            AdjTableGraphStPer {
   46|    192|                        sum += a.nth(k);
   46|     19|                    FlatEntry::Deleted | FlatEntry::Occupied(_, _) => {
  464|      9|            self.entries = ArraySeqMtEphS::from_vec(filtered_entries);
   46|     50|    ) -> (Set<V>, HashMap<V, V>) {
   46|     58|                    &|i| {
   46|       |    ///      - Compute Din(v) = min over u ∈ N⁻(v) of (d[u] + w(u,v))
   46|       |    ///      - Compute Din(v) = min over u ∈ N⁻(v) of (d[u] + w(u,v))
   46|       |    /// - Contracted graph where matched edges are merged into single vertices
   46|       |    ///    - Else: skip (would create cycle)
   46|       |    /// - graph: The undirected graph to contract
   46|       |    /// - Phase 3: n Dijkstras via ParaPair! recursion:
   46|       |    /// - Phase 3: n Dijkstras via ParaPair! recursion:
   46|       |    /// # Returns
   46|       |        ) -> Set<LabeledEdge<V>>;
   47|  1.02k|                &|i| {
   47|  1.22k|                self.data[index] = item;
   47|     14|            TweetQueryExamples { index, fw }
   47|     19|                        attempt += 1;
   47|      2|                        attempt += 1;
   47|      3|            &|i| {
   47|     57|                    running_sum += *a.nth(j);
  476|      1|                    self.entries = ArraySeqMtEphS::singleton(Pair(key, combined_value));
   47|      7|            EdgeSetGraphStEph {
   47|     85|            pq = pq.insert(element.clone());
   47|       |        ) -> bool;
   47|       |    /// - Result of type R as computed by base and expand functions
   47|       |    /// # Returns
   47|       |    /// - seed: Random seed for partition
   47|       |    /// - Set of edges forming a spanning tree
   47|       |    ///      - Update d'[v] = min(d[v], Din(v))
   47|       |    ///      - Update d'[v] = min(d[v], Din(v))
   47|       |    ///   * Work O(n * m log n) = O(mn log n)
   47|       |    ///   * Work O(n * m log n) = O(mn log n)
   48|    114|                        f(c.nth(i / 2), a.nth(i - 1))
   48|     11|            self.head = Some(new_node);
   48|     12|                            distances = ArraySeqMtPerS::update(&distances, Pair(v, current_dist + 1));
   48|     12|                            let _ = distances.set(v, current_dist + 1);
   48|     24|            BSTPlainStEph {
   48|     29|            HashTable {
   48|    372|                    is_composite = true;
   48|     57|                    global_max = max_with_neginf(global_max, Some(running_sum));
   48|     76|                    max_sum = max_with_neginf(max_sum, Some(sum));
   48|      7|            EdgeSetGraphStPer {
  489|      2|                        &|i| {
   48|       |    /// - base: Function to call on the base case (isolated vertices)
   48|       |        ) -> bool;
   48|       |    ///    - If no distances changed, return (converged)
   48|       |    ///    - If no distances changed, return (converged)
   48|       |        ) -> Self;
   48|       |    ///   * Span O(log n) recursion depth × O(m log n) per Dijkstra = O(m log² n)
   48|       |    ///   * Span O(log n) recursion depth × O(m log n) per Dijkstra = O(m log² n)
   49|    104|                step += 1;
   49|    114|                &|i| {
   49|    117|            ArraySetStEph {
   49|    151|                                l_idx += 1;
   49|     15|        let _ = visited.set(vertex, true);
   49|     20|                table = self.compute_diagonal(table, k);
   49|       |    /// - expand: Function to expand result from quotient graph to original graph
   49|       |    ///   * However, since all n Dijkstras can run in parallel, effective Span O(m log n)
   49|       |    ///   * However, since all n Dijkstras can run in parallel, effective Span O(m log n)
   50|     10|                let _ = matching.insert(edge.clone());
  502|      4|                    &|i| {
   50|      2|    ) -> LinearProbingHashTable<i32, V, UniversalIntegerHashFunction> {
   50|      3|    ) -> UnDirGraphStEph<V> {
   50|      7|            EdgeSetGraphMtPer {
   50|       |    /// - graph: The undirected graph
   50|       |    ///   * Parallelism Θ(n * m log n) / Θ(m log n) = Θ(n)
   50|       |    ///   * Parallelism Θ(n * m log n) / Θ(m log n) = Θ(n)
   51|      0|            AdjMatrixGraphStEph { matrix, n }
   51|     10|                let _ = matched_vertices.insert(u.clone());
   51|    121|                                r_idx += 1;
   51|      1|            OrderedTableMtPer {
   51|     21|            UnionFind {
   51|      9|                visited = new_visited;
   51|       |    /// - graph: The undirected graph
   51|       |    /// - graph: The undirected graph
   51|       |    /// - graph: Undirected graph (should be a tree)
   51|       |    /// - Total: Work O(mn log n), Span O(m log n), Parallelism Θ(n)
   51|       |    /// - Total: Work O(mn log n), Span O(m log n), Parallelism Θ(n)
   52|      0|                visited = new_visited;
   52|     10|                let _ = matched_vertices.insert(v.clone());
   52|    115|                                idx += 1;
   52|    137|                                idx += 1;
   52|    157|                                idx += 1;
   52|     26|                max_sum = match max_sum {
  524|      2|                self.entries = ArraySeqMtEphS::from_vec(updated_entries);
   52|      8|            running_sum += *a.nth(i);
  529|  2.58M|                    &|i| {
   52|      9|                result = new_result;
   52|       |        ) -> (ArraySeqMtPerS<A>, A);
   52|       |    /// - graph: Weighted undirected graph
   52|       |    /// - matching: A vertex matching (set of edges where no two share an endpoint)
   52|       |    /// - Result of type R as computed by base and expand functions
   52|       |    /// - seed: Random seed for star partition
   52|       |    /// - start: Starting vertex
   53|      0|            AdjMatrixGraphStPer { matrix, n }
   53|      0|    ) -> ArraySeqStPerS<Pair<N, &'static str>> {
   53|      0|                    &|i| {
   53|      0|                result = new_result;
   53|  1.11k|        ParamTreap {
   53|     14|            ArraySetEnumMtEph {
   53|     20|    ) -> Result<SSSPResultStEphFloat, String> {
   53|     23|            ProbeSequenceAnalyzer {
  536|  4.45k|                    self.entries.length() + 1,
   53|     69|            let _ = centers.insert(vertex.clone());
   53|      8|            max_val = max_val.max(running_sum);
   53|      8|            running_sum += a.nth_cloned(i);
   53|       |    /// # Arguments
   53|       |    /// # Arguments
   53|       |    /// - The number of connected components
   53|       |    /// - tree_edges: Set of edges forming the tree
   54|      0|            EdgeSetGraphStEph { vertices: v, edges: e }
   54|     11|    ) -> DoubleHashingHashTable<String, V, StringPositionHashFunction, PolynomialHashFunction> {
   54|     12|                            l_idx += 1;
   54|  1.83k|            for _ in 0..size {
   54|     18|                    node.value = item;
   54|     26|                max_sum = match max_sum {
  543|  4.45k|                self.entries = ArraySeqMtEphS::from_vec(entries_vec);
   54|      5|            SSSPResultStPerInt {
   54|     61|            dist_vec[source] = 0;
   54|     64|                                idx += 1;
   54|     69|            let _ = partition_map.insert(vertex.clone(), vertex.clone());
   54|      8|            max_val = max_val.max(running_sum);
   54|       |    /// * `graph` - Weighted directed graph with float weights (can be negative, no negative cycles)
   54|       |    /// * `graph` - Weighted directed graph with integer weights (can be negative, no negative cycles)
   55|      0|            EdgeSetGraphStPer { vertices: v, edges: e }
   55|    112|            ArraySetStEph {
   55|     14|            current_layer = next_layer;
   55|     14|            current_layer = next_layer;
   55|    222|            let _ = vertex_to_index.insert(v.clone(), i as N);
   55|     42|            SortedListPQ {
   55|     49|            UnsortedListPQ {
   55|     68|            BalancedTreePQ {
   55|     69|            let _ = processed.insert(vertex.clone());
  558|      0|                    self.entries = ArraySeqMtEphS::empty();
   55|     85|            pq = new_pq;
   55|      9|                count += self.adj.nth(i).length();
   55|      9|            let _ = self.set(index, item);
   55|       |    /// - Contracted graph where matched edges are merged into single vertices
   55|       |    /// - Set of edges forming the MST
   55|       |    /// - The number of connected components
   56|     10|    ) -> QuadraticProbingHashTable<String, V, StringPositionHashFunction> {
   56|     14|            current_dist += 1;
   56|     14|            current_dist += 1;
   56|    161|            AVLTreeSetMtPer {
   56|     16|                row[i] = 0;
   56|     19|                | (_, 0) => true,  // Base case: target sum is 0
   56|     19|                    count += neighbors.size();
   56|     20|            .map(|s| {
   56|     23|                            r_idx += 1;
   56|     50|            left_rows * split_cols * right_cols
   56|     71|            dist_vec[source] = OrderedFloat(0.0);
   56|     76|                    guard[index] = item;
   56|       |    /// - graph: Undirected graph (should be a tree)
   56|       |    /// # Returns
   56|       |    /// # Returns
   56|       |    /// - Vector of vertices in Euler tour order
   57|      0|            EdgeSetGraphMtPer { vertices: v, edges: e }
   57|      0|                    new_chain = ArraySeqStPerS::append(&new_chain, &single_seq);
   57|      0|                            right.nth(i - n_left).clone()
   57|     15|            LabDirGraphStEph {
   57|  1.83k|                table = ArraySeqStPerS::append(&table, &single_seq);
   57|     19|    ) -> bool {
   57|  2.75k|            AVLTreeSetStPer {
   57|      3|            UnDirGraphStEph {
   57|     45|            LabUnDirGraphStEph {
   57|      5|            AllPairsResultStPerInt {
   57|      5|                current = &node.next;
   57|      5|            SSSPResultStPerFloat {
   57|     61|            SSSPResultStEphInt {
   57|       |    /// - edges: Set of labeled edges
   57|       |    /// - start: Starting vertex
   58|      0|                &|i| {
   58|     16|                row[i] = OrderedFloat(0.0);
   58|    307|                        count += 1;
   58|     68|            left_rows * split_cols * right_cols
   58|      7|    ) -> Set<LabEdge<V, OrderedFloat<f64>>> {
   58|       |    /// - tree_edges: Set of edges forming the tree
   59|      0|                    key_existed = true;
   59|  11.3k|            AVLTreeSetStEph {
   59|      1|                    FlatEntry::Occupied(k, _) if k == key => {
   59|      3|    ) -> UnDirGraphMtEph<V> {
   59|      5|            AllPairsResultStPerFloat {
   59|     71|            SSSPResultStEphFloat {
   59|     91|            OrderedTableMtPer {
   59|      9|                count += self.adj.nth(i).length();
  600|      4|            self.entries = ArraySeqMtEphS::from_vec(filtered_entries);
   60|    126|            FlatHashTable {
   60|     19|            self.bits.count_ones() // popcount
   60|      3|                    FlatEntry::Occupied(k, _) if k == key => {
   60|      4|            UnDirGraphMtEph {
   60|      6|            self.with_exclusive(|data| {
   60|      9|                | (_, 0) => true,  // Base case: target sum is 0
   60|       |    /// - HashMap mapping vertex → (neighbor, weight, label) for minimum edge
   61|      1|                        table.table[slot] = FlatEntry::Deleted;
   61|    222|            let _ = coin_flips.insert(vertex.clone(), rng.random::<bool>());
   61|      2|    ) -> std::vec::Vec<V> {
   61|      2|                        table.table[slot] = FlatEntry::Deleted;
  614|      0|                    self.entries = ArraySeqMtEphS::empty();
   61|      6|            visited = new_visited;
   61|     74|                    let _ = partition_map.insert(neighbor.clone(), vertex.clone());
   61|       |    /// - Vector of vertices in Euler tour order
   62|     14|                        count += 1;
   62|     19|                        self.subset_sum_rec(i - 1, j)
   62|      1|                        table.num_elements -= 1;
   62|    271|            AVLTreeSetMtPer {
   62|      2|            ProbeSequenceAnalyzer {
   62|      2|                        table.num_elements -= 1;
   62|     36|            self.0.to_bits() == other.0.to_bits()
   62|     37|                Probability::zero() // Base case: empty subsequence
   62|      3|            BalancedTreePQ {
   62|      3|            SortedListPQ {
   62|     48|            AVLTreeSetMtEph {
   62|      4|            ConcurrentStackMt {
   62|      5|            UnsortedListPQ {
   62|     74|                    let _ = processed.insert(neighbor.clone());
   63|     10|            LabDirGraphMtEph {
   63|    116|            TableStEph {
   63|     13|            LabUnDirGraphMtEph {
   63|  1.84k|            AVLTreeSetStPer {
   63|      1|                FlatEntry::Occupied(k, _) if k == &key => {
   63|     25|    ) -> HashMap<V, (V, OrderedFloat<f64>, usize)> {
   63|     27|    ) -> (AVLTreeSetStPer<N>, Vec<N>) {
   63|     39|                        self.min_edit_distance_rec(i - 1, j - 1)
   63|      5|            AllPairsResultStEphInt {
   63|       |    /// # Arguments
   63|       |    /// # Arguments
   63|       |    /// - The coin is heads (probability 1/2)
   64|      0|                    let _ = spanning_edges.insert(edge);
   64|    135|            LabDirGraphStEph { vertices, labeled_arcs }
   64|     13|                        count += neighbors.size();
   64|     14|                    count += neighbors.size();
   64|      1|                    table.table[slot] = FlatEntry::Occupied(key, value);
   64|     51|                    &|i| {
   64|     52|                    &|i| {
   64|     65|            Self {
   64|     65|            Self {
   64|     71|            Self {
   64|     72|            Self {
   64|     73|            Self {
   64|     76|            LabUnDirGraphStEph {
   64|     78|            Self {
   64|     86|                    &|i| {
   64|       |    /// - All adjacent edges are tails
   64|       |    /// * `graph` - Weighted directed graph with non-negative float weights (usize vertices)
   64|       |    /// * `graph` - Weighted directed graph with non-negative integer weights (usize vertices)
   64|       |            loop {
   65|      0|                    FlatEntry::Empty => return false, // Key not found, stop at Empty
   65|  10.9k|            AVLTreeSetStEph {
   65|     14|                | (_, 0) => true,  // Base case: target sum is 0
   65|     16|        let _ = visited.set(vertex, true);
   65|     19|    ) -> Option<(AVLTreeSetStPer<N>, AVLTreeSetStPer<N>, Vec<N>)> {
   65|      1|                    FlatEntry::Empty => return false,
   65|     27|    ) {
   65|      2|            OrderedTableMtPer {
   65|      2|    ) -> QuadraticProbingHashTable<i32, V, UniversalIntegerHashFunction> {
   65|      5|            AllPairsResultStEphFloat {
  656|      4|            self.entries = ArraySeqMtEphS::from_vec(filtered_entries);
   65|     85|            pq = pq.insert(element.clone());
   65|     95|                        self.subset_sum_rec(i - 1, j - element_value) || self.subset_sum_rec(i - 1, j)
   65|       |    /// - edges: Arc-wrapped vector of labeled edges
   65|       |    /// * `source` - Source vertex (0-indexed)
   65|       |    /// * `source` - Source vertex (0-indexed)
   65|       |        /// - v: The element to insert
   66|      0|                    FlatEntry::Deleted | FlatEntry::Occupied(_, _) => {
   66|    107|            TableMtEph {
   66|     16|        let _ = rec_stack.set(vertex, true);
   66|     16|                        self.subset_sum_rec(i - 1, j)
   66|     17|                FlatEntry::Empty | FlatEntry::Deleted => {
   66|      1|                    None => return false,
   66|     21|                            let _ = a.set(lt, xi);
   66|      2|                        count += 1;
   66|      2|                    FlatEntry::Deleted | FlatEntry::Occupied(_, _) => {
   66|      2|            new_chain = ArraySeqStPerS::append(&new_head, &new_chain);
   66|      2|    ) -> std::vec::Vec<V> {
  664|     39|        TableMtEph {
   66|      4|    ) -> DoubleHashingHashTable<i32, V, UniversalIntegerHashFunction, UniversalIntegerHashFunction> {
   66|     73|                    &|i| {
   66|      9|                    move || Self::reduce_contract_parallel(&b, f_solve, id_clone),
   66|       |    /// - start: Start index in edges
   67|     10|                table[i][0] = i;
   67|     12|                candidate += 1;
   67|     17|                    table.table[slot] = FlatEntry::Occupied(key, value);
   67|     18|                table[i][0] = i;
  672|       |        () => {
   67|     21|                            let _ = a.set(i, xlt);
   67|      2|                        attempt += 1;
   67|      3|            write!(f, "[")?;
  675|       |        ($($key:expr => $value:expr),+ $(,)?) => {{
   67|   578k|            AVLTreeSeqStEphS {
   67|  7.96k|                    sum += (ch as u8 - b'a') as N;
   67|      9|                    move || last.clone()
   67|       |    /// - end: End index in edges
   67|       |    /// # Returns
   67|       |    /// # Returns
   68|      0|                        attempt += 1;
   68|    168|                let _ = self.parent.insert(v.clone(), v.clone());
   68|     17|                    table.num_elements += 1;
   68|     26|            AVLTreeSetMtEph {
   68|      2|                        *current = node.next.take();
   68|      4|            total = total.saturating_add(edge_weight);
   68|     63|            left_rows * split_cols * right_cols
   68|     69|                    new_chain = ArraySeqStPerS::append(&new_chain, &single_seq);
   68|      6|            left_rows * split_cols * right_cols
   68|     84|                let _ = self.set(index, value);
   69|      0|                let _ = spanning_edges.insert(edge.clone());
   69|    104|                    sum += (ch as u8 - b'A') as N;
   69|    134|                        1 + std::cmp::min(delete_cost, insert_cost)
   69|    168|                let _ = self.rank.insert(v, 0);
   69|     18|            total = total.saturating_add(edge_weight);
   69|     21|                        lt += 1;
   69|    228|                &|i| {
   69|     29|                0 // Base case: single matrix, no multiplication needed
   69|     51|                &|v| {
   70|      0|                _ => {
   70|     10|                table[i][0] = i;
   70|     14|                    let _ = spanning_edges.insert(edge);
   70|     14|                print!(", ");
   70|     14|                table[0][j] = j;
   70|     14|                table[i][0] = i;
   70|     16|            write!(f, "{{")?;
   70|      1|                    key_existed = true;
   70|     20|        let _ = visited.set(vertex, true);
   70|     21|                        i += 1;
   70|     29|                        current = node.next.as_deref();
   70|      4|            TableStEph {
   70|      4|                    write!(f, ", ")?;
   70|     56|            LabDirGraphMtEph { vertices, labeled_arcs }
   70|     59|            LabUnDirGraphMtEph {
   70|      7|                | (_, 0) => true,  // Base case: target sum is 0
   70|      9|                table[0][j] = j;
   70|       |    /// - graph: The undirected graph
   70|       |    /// - HashMap mapping vertex → (neighbor, weight, label) for minimum edge
   71|      0|                    table.table[slot] = FlatEntry::Occupied(key, value);
   71|     25|                        self.subset_sum_rec(i - 1, j)
   71|     29|                        skipped += 1;
   71|      2|                    Some(node) => {
   71|  43.0k|                        lt += 1;
   71|      7|            hash_val % table.current_size
   71|     87|                    .map(|k| {
   71|       |    /// - seed: Random seed for reproducibility
   72|      0|                    table.num_elements += 1;
   72|    103|                                idx += 1;
   72|    103|                result = result.union(&singleton_set);
   72|    114|                        c_arc.nth_cloned(i / 2)
   72|     13|            ClusteringAnalyzer {
   72|     16|                        self.min_edit_distance_rec(i - 1, j - 1)
   72|  2.40k|            sum % table_size
   72|      2|                        current = &mut node.next;
   72|      2|            Self { tree }
   72|      2|            Self { tree }
   72|      2|            Self { tree }
   72|      2|            Self { tree }
   72|      2|            Self { tree }
   72|      2|            Self { tree }
   72|     34|                    let _ = bridges.insert(u.clone(), (v.clone(), w, label));
   72|  43.0k|                        i += 1;
  248|      1|            ("Small (7 elements)".to_string(), vec![64, 34, 25, 12, 22, 11, 90]),
   72|     49|                                idx += 1;
   72|      4|                        gt -= 1;
   72|     73|                                idx += 1;
   72|      7|                write!(f, "{}", item)?;
   73|     10|                table[0][j] = j;
   73|  26.3k|                            lt += 1;
   73|      2|            OrderedTableMtPer {
   73|      4|            TableMtEph {
   73|     50|                    .map(|k| {
   73|     60|            ) -> Option<V> {
   73|     78|                    ParamBST {
   73|      7|                        self.med_recursive(i - 1, j - 1)
   73|     85|            pq = new_pq;
   73|      9|                table[0][j] = j;
   74|    122|            AVLTreeSetMtEph {
   74|    153|            Self {
   74|  26.3k|                            i += 1;
   74|      3|            AdjTableGraphMtPer {
   74|      3|            let _ = self.set(index, item);
   74|      3|            write!(f, "]")
   74|      4|                        let _ = a.set(i, xgt);
   74|      5|            SSSPResultStPerInt {
   74|     61|                        self.subset_sum_rec(i - 1, j - element_value) || self.subset_sum_rec(i - 1, j)
   74|    771|                        gt -= 1;
   74|      7|                    write!(f, ", ")?;
   74|     81|                Probability::zero() // Base case: empty subsequence
   74|     86|                                idx += 1;
   74|     87|                        left_cost + right_cost
   74|       |    /// - A set of edges forming a vertex matching
   75|    122|    ) -> HashMap<V, (V, OrderedFloat<f64>, usize)> {
   75|    175|                let _ = self.distances.set(v, dist);
   75|     18|            visited = new_visited;
   75|     19|            let _ = new_vertices.insert(representative.clone());
   75|     22|                        lo = mid + 1;
   75|     29|                        OrderedFloat(d_prime.0 - p_u.0 + p_v.0)
   75|      2|            DirGraphStEph {
   75|      4|    ) -> ArraySeqStEphS<B> {
   75|      4|                        let _ = a.set(gt, xi);
   75|      8|                vertices = vertices.insert(seq.nth(i).clone());
   75|       |    /// - graph: Weighted undirected graph
   75|       |        loop {
   75|       |        loop {
   76|    106|                    x.right = y.left.take();
   76|     10|                        let _ = bridges.insert(u.clone(), (v.clone(), w, label));
   76|     12|                    first = false;
   76|     12|        let _ = rec_stack.set(vertex, false);
   76|     14|                        self.subset_sum_rec(i - 1, j)
   76|     18|            result = new_result;
   76|     22|                            gt -= 1;
   76|      7|                        self.med_recursive(i - 1, j - 1, memo)
   76|       |        ) -> (LinkedListStPerS<A>, A);
   76|       |            loop {
   76|       |    /// - start: Starting vertex (arbitrary choice)
   77|      0|            Mapping {
   77|    106|                    y.left = Some(x);
   77|    122|            new_chain = ArraySeqStPerS::append(&new_head, &new_chain);
   77|     12|                        i += 1;
   77|    173|                let _ = self.distances.set(v, dist);
   77|  1.86k|            node.height = 1 + Self::height_link(&node.left).max(Self::height_link(&node.right));
   77|    192|                *node = BalBinTree::node(BalBinTree::leaf(), value, BalBinTree::leaf());
   77|      1|    ) -> Option<OrderedF64> {
   77|     20|                new_buckets = ArraySeqStPerS::append(&new_buckets, &single_seq);
   77|  2.24k|                        i += 1;
   77|     24|                        hi = mid;
   77|  25.0k|            node.height = 1 + Self::height_link(&node.left).max(Self::height_link(&node.right));
   77|      4|                neighbors = neighbors.insert(v.clone());
   77|     50|                        left_cost + right_cost + split_cost
   77|      5|            SSSPResultStPerFloat {
   77|     68|                            min_dist = new_dist;
   77|  7.59k|            node.size = 1 + Self::size_link(&node.left) + Self::size_link(&node.right);
   78|    106|                    *link = Some(y);
   78|    128|                    min_element = current;
   78|  1.46k|                    all_pairs = ArraySeqStPerS::append(&all_pairs, &single_seq);
   78|  1.86k|            node.size = 1 + Self::size_link(&node.left) + Self::size_link(&node.right);
   78|     19|                write!(f, "{}", x)?;
   78|    244|                    x.right = y.left.take();
   78|  25.0k|            node.size = 1 + Self::size_link(&node.left) + Self::size_link(&node.right);
   78|      2|    ) -> Option<OrderedF64> {
   78|      4|            DirGraphMtEph {
   78|      4|                        self.med_recursive_concurrent(i - 1, j - 1)
   78|      4|                        self.med_recursive_concurrent(i - 1, j - 1)
   78|     50|                prob_sum + min_cost
   78|     51|                &|v| {
   78|     56|                        self.min_edit_distance_rec(i - 1, j - 1)
   78|      5|            AllPairsResultStPerInt {
   78|      6|    ) {
   78|  7.89k|                new_node.next = head;
   79|      0|                let _ = self.adj.set(v, neighbors);
   79|    103|                        result1 || result2
   79|    107|            ArraySeqMtEphSliceS {
   79|     18|                right.select(k - (n - right_count))
   79|      1|            OrderedTableMtPer {
   79|     22|                right.select(k - (n - right_count))
   79|    251|                cur = &node.left;
   79|    255|                            i += 1;
   79|     30|                right.select(k - (n - right_count))
   79|      3|            ArraySetStEph { elements: filtered }
   79|  4.84M|                cur = &node.left;
   79|      4|                neighbors = neighbors.insert(v.clone());
   79|    730|                    x.right = y.left.take();
   79|       |    /// - Set of edges forming the MST
   80|      0|                    *link = Some(x);
   80|     16|            write!(f, "}}")
   80|     20|        ) -> AVLTreeSetStEph<V>
   80|      5|            AllPairsResultStPerFloat {
   80|     60|            ) -> Option<V> {
    8|      0|fn main() {
   80|       |    /// - graph: The undirected graph
   81|     10|            .map(|key| {
   81|     15|            all_distances = ArraySeqStEphS::append(&all_distances, &ArraySeqStEphS::singleton(adjusted_row));
   81|      1|            ArraySetEnumMtEph { bits, universe_size: u }
   81|      1|            Self {
   81|  20.5M|                t.root = insert_at_link(t.root.take(), i, v, &mut t.next_key);
   81|  22.9k|                    h.right = x.left.take();
   81|    244|                    y.left = Some(x);
   81|     25|            OrderedSetStPer {
   81|     26|                right.select(k - (n - right_count))
   81|      2|            ClusteringAnalyzer {
   81|     30|            ) -> Option<V> {
   81|    346|                let (_, right) = mid_and_right.split_at_mut(gt - lt);
   81|      7|                0 // Base case: single matrix, no multiplication needed
   81|     77|                    let _ = ng.insert(b.clone());
   81|      7|            hash_val % table.current_size
   81|       |    /// - graph: The undirected graph
   81|       |        /// - v: The element to find
   82|     10|        AllPairsResultStEphFloat {
   82|     15|            all_predecessors = ArraySeqStEphS::append(
   82|     16|                let _ = mst_edges.insert(edge.clone());
   82|     17|            node.left = left;
   82|    244|                    *link = Some(y);
   82|     28|            OrderedSetStEph {
   82|  5.04k|                    ParaPair!(move || parallel_sort(left_vals), move || parallel_sort(right_vals));
   82|      5|        AllPairsResultStEphInt {
   82|      5|                let _ = row.set(v, dist);
   82|     71|                        current = node.next.as_deref();
   82|    730|                    y.left = Some(x);
   82|       |    /// - seed: Random seed for star partition
   83|    103|            (hash_val + (attempt * attempt)) % table.current_size
   83|  1.11k|                index -= ls + 1;
   83|     14|    ) -> UnDirGraphStEph<V> {
   83|     17|            node.right = right;
   83|  22.9k|                    x.color = h.color;
   83|    253|                    let (_, right) = mid_and_right.split_at_mut(gt - lt);
   83|      2|            LoadAndSize {
   83|      2|                self.num_elements + 1
   83|    346|                thread::scope(|scope| {
   83|    381|                    .map(|k| {
   83|      3|                    FlatEntry::Empty => return None,
   83|  4.01M|                index -= ls + 1;
   83|   555k|            debug_assert!(t.length() == length);
   83|      5|                let _ = self.distances.set(u, row);
   83|      6|    ) {
   83|     65|                    let _ = ng.insert(a.clone());
   83|     71|                        taken += 1;
   83|    730|                    *link = Some(y);
   83|     85|            pq = pq.insert(element.clone());
   83|      8|    ) -> Set<LabEdge<V, OrderedFloat<f64>>> {
   83|      8|                    visited = new_visited;
   83|       |    /// - (representatives, component_map): Set of component representatives and
   84|      0|                    *link = Some(x);
   84|  1.11k|                cur = &node.right;
   84|    112|                    y.left = x.right.take();
   84|     13|            (hash_val + attempt) % table.current_size
   84|     16|                    y.left = x.right.take();
   84|      1|            AdjTableGraphMtPer { adj: new_adj }
   84|  22.9k|                    h.color = Color::Red;
   84|      2|                    FlatEntry::Deleted | FlatEntry::Occupied(_, _) => {
   84|     35|                        d_prime - p_u + p_v
   84|      3|            ArraySetStEph { elements: filtered }
   84|  4.01M|                cur = &node.right;
   84|     45|                    let _ = bridges.insert(v.clone(), (u.clone(), w, label));
   84|    494|                        1 + std::cmp::min(delete_cost, insert_cost)
   84|      5|                let _ = row.set(v, dist);
   84|      7|            Mapping {
   84|      8|                    rec_stack = new_rec_stack;
   84|       |        /// - The representative of v's set
   85|      0|                    *link = Some(x);
   85|      0|            ) -> Set<(V, OrderedFloat<f64>)> {
   85|    184|            TableStPer {
   85|      1|            Self {
   85|     20|        ) -> AVLTreeSetMtPer<V>
   85|  22.9k|                    x.left = Some(h);
   85|    253|                    thread::scope(|scope| {
   85|      2|                        attempt += 1;
   85|     38|        for _ in 0..n {
   85|      5|                let _ = self.distances.set(u, row);
   85|  60.0k|                let _ = out.insert(a.clone());
   85|     65|                    changed = true;
   85|      6|                    .map(|k| {
   85|     71|            let _ = result.insert(u.clone(), (v.clone(), w, label));
   85|     77|                        1 + std::cmp::min(delete_cost, insert_cost)
   85|      8|                    result = new_result;
   85|       |    /// - (representatives, component_map): Set of component representatives and
   86|      0|    ) {
   86|    111|            pq = new_pq;
   86|    117|            pq = new_pq;
   86|  1.66k|                result = result.union(&set);
   86|     27|            Self {
   86|    381|                        left_cost + right_cost
   86|     59|                            min_dist = new_dist;
   86|     71|            let _ = result.insert(v.clone(), (u.clone(), w, label));
   87|      0|            ) -> Set<(V, OrderedFloat<f64>)> {
   87|    107|                    h.right = x.left.take();
   87|    112|                    x.right = Some(y);
   87|     16|                    x.right = Some(y);
   87|     24|            let _ = new_vertices.insert(representative.clone());
   87|      2|            EdgeSetGraphStPer {
   87|      4|                        let _ = spanning_edges.insert(original_edge.clone());
   87|      4|                None => return None, // Cycle detected
   87|     50|            table_size / Self::gcd(h2_value, table_size)
   87|      5|        for _ in 0..4 {
   87|     60|            ) -> (AVLTreeSetStEph<V>, AVLTreeSetStEph<Pair<V, P>>)
   87|    694|                new_node = unsafe { Box::from_raw(node_ptr) };
   87|    724|            LeftistHeapNode::Node {
   87|    796|                insert_pos = i + 1;
   88|  10.6k|                result = result.union(&set);
   88|    112|                    *link = Some(x);
   88|     16|                    *link = Some(x);
   88|     16|            Self {
   88|     19|                        let _ = bridges.insert(v.clone(), (u.clone(), w, label));
   88|      1|            OrderedSetStPer {
   88|    218|                    insert_pos = i;
   88|     22|                        self.min_edit_distance_rec(i - 1, j - 1)
   88|     22|    ) -> UnDirGraphMtEph<V> {
   88|  2.95k|                new_buckets = ArraySeqStPerS::append(&new_buckets, &single_seq);
   88|      2|                issues.push(format!("c2 ({}) is not coprime to table size ({})", c2, table_size));
   88|    437|            UnsortedListPQ {
   88|     46|            AVLTreeS {
   88|      4|                        break; // Only need one edge between the two stars
   88|      4|                        in_cluster = true;
   88|      4|                    x.left = y.right.take();
   88|      5|        AllPairsResultStEphFloat {
   89|    107|                    x.color = h.color;
   89|     14|            EdgeSetGraphMtPer {
   89|      1|            OrderedSetStEph {
   89|     31|            Self {
   89|      3|            ArraySetStEph { elements: filtered }
   89|      3|            Self {
   89|     45|                        result1 || result2
   89|      4|                        current_cluster_size = 1;
   89|      4|                    y.right = Some(x);
   89|      6|                        left_cost + right_cost + split_cost
   89|     93|            OrderedTableStPer {
   90|      0|                    *link = Some(y);
   90|      0|                    *link = Some(y);
   90|    107|                    h.color = Color::Red;
   90|     10|    ) -> (Set<V>, HashMap<V, V>) {
   90|    151|                prob_sum + min_cost
   90|      1|            Self {
   90|     21|                    table[i][j] = new_value;
   90|  22.9k|                    *link = Some(x);
   90|    234|                    *link = Some(Box::new(Node::new(value)));
   90|     23|                    table[i][j] = new_value;
   90|     28|                .filter_map(|i| {
   90|     31|                .filter_map(|i| {
   90|      4|            handles.push(thread::spawn(move || {
   90|      4|                    *link = Some(y);
   90|     57|            distances = new_distances;
   90|      7|                let _ = component_map.insert(vertex.clone(), vertex.clone());
   90|    907|                    *link = Some(Box::new(Node::new(value)));
   91|      0|        let _ = visited.set(vertex, true);
   91|  1.02k|                    x.right = y.left.take();
   91|    107|                    x.left = Some(h);
   91|    114|                        let _ = ng.insert(b.clone_mt());
   91|    136|                let _ = self.predecessors.set(v, pred);
   91|  14.3k|                        i += 1;
   91|  1.46k|                word_table = word_table.insert(word.clone(), doc_id.clone(), |_old_doc, new_doc| {
   91|     18|                        current_cluster_size += 1;
   91|     25|            OrderedTableMtPer {
   91|    268|                        insertion_pos = Some(hash_pos);
   91|      2|            total += edge_weight;
   91|     30|            ) -> Option<V> {
   91|     31|            ProbeSequenceVisualization {
   91|      3|            Self {
   91|  4.00k|                for _ in 0..iterations {
   91|      5|            Mapping {
   91|      5|            TableStPer {
   91|      7|            *self = ArraySeqMtEphS::from_vec(data);
   91|     85|            pq = new_pq;
   91|      8|                new_adj = new_adj.insert(u.clone(), AVLTreeSetMtPer::empty());
   91|       |        ) -> ArraySeqS<Pair<K, ArraySeqS<V>>>;
   91|       |        ) -> LinkedListStPerS<Pair<A, LinkedListStPerS<Bv>>>;
   92|      0|                    *link = Some(h);
   92|      0|                    *link = Some(x);
   92|     12|                let _ = new_edges.insert(new_edge);
   92|     21|                    x.left = y.right.take();
   92|     29|                    FlatEntry::Empty | FlatEntry::Deleted => return slot,
   92|      2|            ArraySetEnumMtEph { bits, universe_size: u }
   92|      5|            total += edge_weight;
   92|    624|                    *link = Some(Box::new(Node::new(value)));
   92|     96|            OrderedTableStEph {
   93|      0|                        found = true;
   93|    120|                let _ = self.predecessors.set(v, pred);
   93|     15|            all_distances = ArraySeqStEphS::append(&all_distances, &singleton_dist);
   93|     20|        ) -> ComprehensiveClusteringAnalysis
   93|     25|            Self {
   93|     26|                    FlatEntry::Occupied(k, _) if k == key => return slot,
   93|    280|                self.tree = Self::rebuild_from_vec(values);
   93|     32|            ) -> AVLTreeSetStPer<V>
   93|     34|            pq = new_pq;
   93|      4|                    FlatEntry::Empty | FlatEntry::Deleted => return slot,
   93|      4|                result = result.union(&ng_u);
   93|      6|                self.tree = Self::rebuild_from_vec(values);
   93|      6|                self.tree = Self::rebuild_from_vec(values);
   93|      6|                self.tree = Self::rebuild_from_vec(values);
   93|      6|                self.tree = Self::rebuild_from_vec(values);
   93|      6|                self.tree = Self::rebuild_from_vec(values);
   93|     76|                    x.left = y.right.take();
   93|     88|                        let _ = ng.insert(a.clone_mt());
   94|  1.02k|                    y.left = Some(x);
   94|    107|                    *link = Some(x);
   94|    121|                self.num_elements + 1
   94|     15|            all_predecessors = ArraySeqStEphS::append(&all_predecessors, &singleton_pred);
   94|     16|                new_adj = new_adj.insert(v.clone(), AVLTreeSetMtPer::empty());
   94|      1|                    FlatEntry::Occupied(k, _) if k == key => return slot, // Update existing key
   94|     25|                    _ => attempt += 1,
   94|      2|                        j += 1;
   94|    348|                let _ = self.parent.insert(v.clone(), root.clone());
   94|     59|                    changed = true;
   94|     60|            ) -> (AVLTreeSetMtPer<V>, AVLTreeSetMtPer<Pair<V, P>>)
   94|     83|            OrderedTableMtEph {
   94|      9|            let _ = out.set(0, first);
   95|      0|                result = result.resize(new_size);
   95|  1.02k|                    *link = Some(y);
   95|      1|                    _ => attempt += 1,
   95|     21|                    y.right = Some(x);
   95|     32|            Self {
   95|      4|                issues.join("; ")
   95|      4|                let _ = component_map.insert(vertex.clone(), vertex.clone());
   95|      5|            SSSPResultStPerInt {
   96|      0|                    *link = Some(h);
   96|     12|                    result = result.insert(elem.clone());
   96|  1.81k|                hash_value = (hash_value + (ch as N) * power) % table_size;
   96|      1|            let _ = <AVLTreeS<T> as AVLTreeSeq<T>>::set(self, index, item);
   96|     21|                    *link = Some(y);
   96|      2|                            insertion_pos = Some(hash_pos);
   96|      2|            Self {
   96|    376|            BalancedTreePQ {
   96|      4|                        in_cluster = false;
   96|      4|            OrderedTableStPer {
   96|     51|            move || vertex_bridges_mt(edges1, start, mid),
   96|     59|                    1 + left_h.max(right_h)
   96|      5|            TableStEph {
   96|  60.0k|                let _ = out.insert(b.clone());
   96|     76|                    y.right = Some(x);
   97|      0|                    *link = Some(x);
   97|     12|            Self {
   97|     14|                print!(", ");
   97|  1.81k|                power = (power * self.base) % table_size;
   97|      1|            TopDownDPStPerS {
   97|     25|    ) -> (
   97|     29|                let _ = out.set(index, v.clone());
   97|      2|                    FlatEntry::Occupied(k, _) if k == key => {
   97|     30|            ) -> (AVLTreeSetStPer<V>, AVLTreeSetStPer<Pair<V, P>>)
   97|     46|    ) -> (
   97|      4|                        current_cluster_size = 0;
   97|     51|            move || vertex_bridges_mt(edges2, mid, end)
   97|      5|        AllPairsResultStEphInt {
   97|     76|                    *link = Some(y);
   97|    796|                new_elements = ArraySeqStPerS::append(&new_elements, &single_seq);
97 |     assert!(obst.memo_size() >= 0);
   98|      0|                    *link = Some(x);
   98|    110|                    x.right = y.left.take();
   98|  1.32k|                    x.right = y.left.take();
   98|     14|                new_neighbors = new_neighbors.union(&neighbors);
   98|    266|                result = self.swap_elements(&result, i, parent_idx);
   98|     29|                index += 1;
   98|      2|                    count += 1;
   98|      2|                        table.table[slot] = FlatEntry::Deleted;
   98|    437|            ) -> Vec<T> {
   98|      5|            SSSPResultStPerFloat {
   98|      5|    ) -> (WeightedDirGraphStEphFloat<usize>, usize) {
   98|      6|            self.with_exclusive(|data| {
   98|      7|            Self {
   98|     84|            OrderedSetStPer {
   99|      0|                    *link = Some(x);
   99|      1|            Self {
   99|      1|            write!(f, "[")?;
   99|     24|            AdjTableGraphMtPer {
   99|    266|                i = parent_idx;
   99|      2|            Self {
   99|      2|                        table.num_elements -= 1;
   99|     36|                Probability::zero() // Base case: empty subsequence
   99|      3|            OrderedTableStEph {
   99|      3|                u != &v_clone && w != &v_clone
   99|     49|            distances = new_distances;
   99|  7.83k|                    ParamBST {
  104|       |            // A vertex is a center if it maps to itself
  107|    114|                    if a == &v {
   10|     76|        match (a, b) {
  107|      8|                Self::gcd(b, a % b)
  107|       |    /// A valid MST of n vertices should have n-1 edges.
   10|       |    // A dummy trait as a minimal type checking comment and space for algorithmic analysis.
   11|     57|        match (a, b) {
  133|      1|                "UniversalIntegerHashFunction (a={}, b={}, p={})",
  140|     92|            if a == v {
   14|     42|        match (a, b) {
   15|     32|        match (a, b) {
   15|     42|        match (a, b) {
  157|    107|            if (a == u && b == v) || (a == v && b == u) {
   15|       |    // A dummy trait as a minimal type checking comment and space for algorithmic analysis.
  160|  20.0k|            for a in self.data.iter() {
  166|       |            x: A,
  171|     18|            if a == v {
  172|     14|            let a = (seed * 1103515245 + 12345) % (self.p - 1) + 1; // Ensure a != 0
  173|       |            let __A: $crate::Chap05::SetStEph::SetStEph::Set<$crate::Types::Types::Edge<_>> = $crate::SetLit![];
  177|       |    // A dummy trait as a minimal type checking comment and space for algorithmic analysis.
  178|       |            let __A: $crate::Chap05::SetStEph::SetStEph::Set<_> = {
   18|     32|        match (a, b) {
  188|      6|            if (a == u && b == v) || (a == v && b == u) {
  191|     18|            if a == v {
  206|      0|            x: A,
  208|     12|            if (a == u && b == v) || (a == v && b == u) {
   22|       |//!     V: ["A", "B", "C"],
   22|       |//!     V: ["A", "B", "C"],
   23|       |//!     A: [("A", "B", 3.14), ("B", "C", 2.71)]
   23|       |//!     E: [("A", "B", 3.14), ("B", "C", 2.71)]
  242|      0|            for a in self.data.iter() {
  256|       |    // A dummy trait as a minimal type checking comment and space for algorithmic analysis.
  284|       |        index: &'a DocumentIndex,
   29|      3|            | 'a' | 'e' | 'i' | 'o' | 'u' | 'A' | 'E' | 'I' | 'O' | 'U' => true,
  294|      1|            x: A,
   29|       |        // |{a, b, c}| = 3
  311|       |    // A dummy trait as a minimal type checking comment and space for algorithmic analysis.
  343|      1|            x: A,
  364|       |            let __A: $crate::Chap05::SetStEph::SetStEph::Set<$crate::Types::Types::Edge<_>> = $crate::SetLit![];
   36|      7|        print!("Set A: [");
  369|       |            let __A: $crate::Chap05::SetStEph::SetStEph::Set<_> = {
  407|       |    // A dummy trait as a minimal type checking comment and space for algorithmic analysis.
   45|    332|                Self::gcd(b, a % b)
   51|       |            x: A,
    6|       |//! When a graph has a negative weight cycle, distances to vertices reachable through
   75|       |            x: A,
   79|       |        // |{a, b, c}| = 3
   80|    371|                if a == *v {
   90|    460|                    if a == *v {
   98|  1.15k|            match (a, b) {
   65|     15|            let a_arc2 = Arc::new(a.clone());
   43|     22|            let a_arc = Arc::new(a.clone());
   45|     15|            let a_arc = Arc::new(a.clone());
  104|    114|                    .fold(Probability::zero(), |acc, p| acc + p);
  109|      3|                .fold(OrderedFloat(0.0), |acc, w| acc + w)
  115|    179|                        .fold(Probability::zero(), |acc, p| acc + p)
  120|      2|                .fold(OrderedFloat(0.0), |acc, w| acc + w)
  130|      2|                .fold(OrderedFloat(0.0), |acc, w| acc + w)
  180|      1|                .fold(OrderedFloat(0.0), |acc, w| acc + w)
  195|      2|            (result_seq, acc)
  196|     10|                .fold(base, |acc, value| op(acc, value.clone()))
  196|     10|                .fold(base, |acc, value| op(acc, value.clone()))
  196|     10|                .fold(base, |acc, value| op(acc, value.clone()))
  196|     10|                .fold(base, |acc, value| op(acc, value.clone()))
  196|     25|                .fold(base, |acc, value| op(acc, value.clone()))
  196|     53|                .fold(base, |acc, value| op(acc, value.clone()))
  212|      2|            (result_seq, acc)
  216|      0|            (ArraySeqMtPerS::from_vec(result_vec), acc)
  253|      2|            (result_seq, acc)
  271|      2|            (result_seq, acc)
  281|      8|            (ArraySeqStPerS::from_vec(values), acc)
  302|      1|            (ArraySeqMtPerS::from_vec(values), acc)
  302|      4|            (ArraySeqStEphS::from_vec(prefixes), acc)
  323|      1|            (ArraySeqS::from_vec(prefixes), acc)
  332|      1|            (result_seq, acc)
  338|      1|            (ArraySeqMtPerS::from_vec(values), acc)
  351|      1|            (LinkedListStPerS::from_vec(prefixes), acc)
  364|      1|            (ArraySeqMtEphS::from_vec(values), acc)
  392|      1|            (LinkedListStEphS::from_vec(prefixes), acc)
   67|     87|                    .fold(Probability::zero(), |acc, p| acc + p);
   79|    381|                    .fold(Probability::zero(), |acc, p| acc + p);
  210|      7|                result_seq.set(i, acc.clone()).unwrap();
  269|      6|                result_seq.set(i, acc.clone()).unwrap();
  132|       |            // Access sequences using nth_cloned as nth() not available for MtEph
   71|       |        /// Accessor for metrics field.
  164|     42|                return a.clone();
  265|      1|                return a.clone();
   83|     34|                return a.clone();
   37|       |        /// Acquire lock by taking a ticket and waiting for our turn.
  341|      4|                    "Immediate action required: resize table and use double hashing".to_string()
  221|     20|            let actual_diversity = probe_sequences.len() as f64;
  183|      0|            let actual_new_size = new_size.max(8);
  187|      9|            let actual_new_size = new_size.max(8);
  243|     25|            let actual_new_size = new_size.max(8);
  100|       |            // Add the new element
  102|       |            // Add elements from other that are not in self
  104|       |    /// Add dummy source with zero-weight edges to all vertices
  104|       |            // Add elements after insertion position
  109|       |            // Add edge to MST (except for start vertex)
  111|       |                    // Add to visited
  119|       |                // Add to visited
  120|       |        // Add zero-weight edges from dummy to all original vertices
  125|       |            // Add edge if centers are different
  126|       |            // Add all elements from self
  128|       |            // Add all elements from self
  131|       |            // Add all elements from other
  133|       |            // Add all elements from other
  143|       |            // Add remaining elements
  152|       |    /// Add dummy source with zero-weight edges to all vertices
  152|       |    /// Add dummy source with zero-weight edges to all vertices
  153|       |        // Add starting vertex at end to complete cycle
  159|       |            // Add remaining elements from self
  160|       |        // Add dummy vertex
  163|       |        // Add dummy vertex
  167|       |            // Add remaining elements from other
  171|       |            // Add intersection entries
  172|       |            // Add scaled edges
  173|       |        // Add edges from dummy source to all original vertices
  173|       |            // Add remaining entries from self
  176|       |        // Add edges from dummy source to all original vertices
  176|       |            // Add left difference entries
  179|       |            // Add remaining entries from other
  181|       |            // Add right difference entries
  200|       |        /// Add element at end and bubble up to maintain heap property
  202|       |            // Add element at the end
  213|       |            // Add remaining entries from self
  216|       |            // Add remaining entries from self
  341|       |            // Add remaining entries from self
  347|       |            // Add remaining entries from other
   34|       |        /// Add a weighted edge to the graph
   34|       |        /// Add a weighted edge to the graph (undirected)
  382|       |            // Add remaining entries from self
   38|       |        /// Add a weighted edge to the graph
   38|       |        /// Add a weighted edge to the graph
   38|       |        /// Add a weighted edge to the graph (undirected)
   38|       |        /// Add a weighted edge to the graph (undirected)
   48|       |            // Add edge if neither endpoint is already matched
   57|       |            // Add all neighbors as satellites of this center
   62|       |        /// Add a weighted edge to the graph
   62|       |        /// Add a weighted edge to the graph (undirected)
   62|       |                // Add edge if vertex is not its own center (avoid self-loops)
   63|       |            // Add new entry at head
   71|       |            // Add edge if u is tails and v is heads
   73|       |        // Add all block representatives as vertices
   74|       |            // Add new entry at head
   77|       |            // Add edge if v is tails and u is heads
   81|     16|                // Add edge to MST
   89|       |                // Add edge if not present
   93|       |            // Add edge if centers are different (no self-loops)
   93|       |            // Add elements before insertion position
   96|       |            // Add v to u's adjacency list
   96|       |            // Add v to u's neighbor list
   97|       |            // Add all elements from self
  153|     10|    fn add_dummy_source(
   95|      5|    fn add_dummy_source(
  105|      5|    fn add_dummy_source(graph: &WeightedDirGraphStEphInt<usize>, n: usize) -> (WeightedDirGraphStEphInt<usize>, usize) {
  153|      5|    fn add_dummy_source(graph: &WeightedDirGraphMtEphInt<usize>, n: usize) -> (WeightedDirGraphStEphInt<usize>, usize) {
  113|       |        // Additional demonstrations of other ordering operations
  114|      7|        println!("\n=== Additional Ordering Operations ===");
  173|       |        // Additional set operations testing
   89|       |        /// Additional example: documents with 'food' OR 'fun'
   97|       |        /// Additional example: documents with 'party' AND 'food'
   40|       |        fn add_labeled_arc(&mut self, from: V, to: V, label: L);
   44|       |        fn add_labeled_arc(&mut self, from: V, to: V, label: L);
   81|     15|        fn add_labeled_arc(&mut self, from: V, to: V, label: L) {
   87|      2|        fn add_labeled_arc(&mut self, from: V, to: V, label: L) {
   40|       |        fn add_labeled_edge(&mut self, v1: V, v2: V, label: L);
   44|       |        fn add_labeled_edge(&mut self, v1: V, v2: V, label: L);
   84|    131|        fn add_labeled_edge(&mut self, v1: V, v2: V, label: L) {
   90|      5|        fn add_labeled_edge(&mut self, v1: V, v2: V, label: L) {
  200|      3|        fn add_last(&mut self, value: T) -> &mut Self {
   58|       |        fn add_last(&mut self, value: T) -> &mut Self;
    7|       |//! - Adds `with_exclusive` to project a mutable slice guarded by the single mutex for batch updates.
  116|  1.85k|        fn add(self, other: Self) -> Self { Probability(self.0 + other.0) }
   37|       |        fn add_vertex(&mut self, v: V);
   37|       |        fn add_vertex(&mut self, v: V);
   41|       |        fn add_vertex(&mut self, v: V);
   41|       |        fn add_vertex(&mut self, v: V);
   79|      9|        fn add_vertex(&mut self, v: V) { self.vertices.insert(v); }
   82|    150|        fn add_vertex(&mut self, v: V) { self.vertices.insert(v); }
   85|      3|        fn add_vertex(&mut self, v: V) { self.vertices.insert(v); }
   88|      7|        fn add_vertex(&mut self, v: V) { self.vertices.insert(v); }
  139|       |    // Ad-hoc implementations for specific primitive types to avoid conflicts
   87|       |            // Adjacent if there is an arc either way
   90|       |            // Adjacent if there is an arc either way
  101|     32|            for adj_edge in graph.edges().iter() {
  102|     32|                if adj_edge == edge {
  193|    143|        for adj_edge in graph.edges().iter() {
  194|    143|            if adj_edge == edge {
    4|       |pub mod AdjMatrixGraphStEph {
   36|       |    impl AdjMatrixGraphStEphTrait for AdjMatrixGraphStEph {
    5|       |pub mod AdjMatrixGraphStPer {
   37|       |    impl AdjMatrixGraphStPerTrait for AdjMatrixGraphStPer {
    4|       |pub mod AdjSeqGraphStEph {
   35|       |    impl AdjSeqGraphStEphTrait for AdjSeqGraphStEph {
    5|       |pub mod AdjSeqGraphStPer {
   36|       |    impl AdjSeqGraphStPerTrait for AdjSeqGraphStPer {
    5|       |pub mod AdjTableGraphMtPer {
    4|       |pub mod AdjTableGraphStEph {
    5|       |pub mod AdjTableGraphStPer {
  113|       |            // Adjust distances: δG(u,v) = δG'(u,v) - p(u) + p(v)
  113|       |            // Adjust distances: δG(u,v) = δG'(u,v) - p(u) + p(v)
   75|       |            // Adjust distances: δG(u,v) = δG'(u,v) - p(u) + p(v)
  115|     15|            let adjusted_row = ArraySeqStEphS::tabulate(
  115|     28|            let adjusted_row = ArraySeqStEphS::tabulate(
   68|     15|            let adjusted_row = ArraySeqStEphS::tabulate(
   77|     15|            let adjusted_row = ArraySeqStEphS::tabulate(
  334|       |        /// Advanced meld operations for specific use cases
  363|       |    /// Advanced operations for balanced tree priority queue
    5|       |pub mod AdvancedDoubleHashing {
  175|     16|            strategy: &AdvancedDoubleHashingStrategy<K, H1, H2>,
  198|     16|                strategy_name: "AdvancedDoubleHashing".to_string(),
    5|       |pub mod AdvancedLinearProbing {
   91|     20|            strategy: &AdvancedLinearProbingStrategy<K, H>,
  118|     19|                strategy_name: "AdvancedLinearProbing".to_string(),
    5|       |pub mod AdvancedQuadraticProbing {
  133|     16|            strategy: &AdvancedQuadraticProbingStrategy<K, H>,
  160|     16|                strategy_name: "AdvancedQuadraticProbing".to_string(),
  288|      9|            let a_elem = a_nth(i);
  291|     18|                if a_elem == b_nth(j) {
  123|      9|            match a.expose_internal() {
  159|    511|            match a.expose_internal() {
  175|    315|            match (a.expose_internal(), b.expose_internal()) {
  195|    315|            match (a.expose_internal(), b.expose_internal()) {
  157|     14|            match a.expose_with_priority() {
  173|     14|            match a.expose_with_priority() {
  193|     16|            match a.expose_with_priority() {
  123|  22.7k|            if a.is_empty() {
  124|  2.51M|            if a.is_empty() {
  129|      4|                    ParamBST::join_m(left_union, ak, right_union)
  165|      6|                    ParamTreap::join_with_priority(left_union, ak, ap, right_union)
  167|    254|                    ParamBST::join_m(left_union, ak, right_union)
  182|      2|                        ParamTreap::join_with_priority(left_res, ak, ap, right_res)
  184|    156|                        ParamBST::join_m(left_res, ak, right_res)
  204|      2|                        ParamTreap::join_with_priority(left_res, ak, ap, right_res)
  207|      0|                        ParamBST::join_m(left_res, ak, right_res)
  282|      4|        if a_len != b_len {
  123|    213|            if a.length() <= 1 {
  153|      3|            if a.length() == 0 {
  171|     16|            if a.length() == 0 {
  171|      2|            if a.length() == 0 {
  186|     18|            if a.length() == 0 {
  186|      3|            if a.length() == 0 {
  202|      2|            if a.length() == 0 {
  210|      3|            if a.length() == 0 {
  221|     10|            if a.length() == 0 {
  221|    215|            if a.length() == 0 {
  224|      3|            if a.length() == 0 {
  224|      9|            if a.length() == 1 {
  236|     14|            if a.length() == 0 {
   25|     16|        if a.length() == 0 {
  256|   100k|            if a.length() == 0 {
  259|   100k|            if a.length() == 1 {
  259|      2|            if a.length() == 0 {
   28|     16|        if a.length() == 0 {
  286|     14|            if a.length() == 0 {
  289|     14|            if a.length() == 1 {
  295|      1|            if a.length() == 0 {
  309|    156|            if a.length() == 0 {
  312|    155|            if a.length() == 1 {
  313|      1|            if a.length() == 0 {
  316|      1|            if a.length() == 1 {
  334|  3.99k|            if a.length() == 0 {
  337|  3.99k|            if a.length() == 1 {
  353|      2|            if a.length() == 0 {
   43|     16|        if a.length() == 0 {
   43|      2|            if a.length() == 0 {
   44|      2|            if a.length() == 0 {
   45|     16|        if a.length() == 0 {
  107|       |            // Algorithm 19.3: map f a = tabulate(lambda i.f(a[i]), |a|)
  108|       |            // Algorithm 19.3: map f a = tabulate(lambda i.f(a[i]), |a|)
   10|       |        /// Algorithm 21.1 (2D Points) using ArraySeqPer: points2D via tabulate + flatten
   10|       |        /// Algorithm 21.2 (3D Points) using ArraySeqPer: flatten of nested tabulates
   10|       |        /// Algorithm 21.6 (Prime Sieve) using ArraySeqPer - simplified version
  111|       |            // Algorithm 19.3: map f a = tabulate(lambda i.f(a[i]), |a|)
   11|       |        /// Algorithm 21.5 (Brute Force Solution to the Primes Problem)
  122|       |            // Algorithm 19.3 with parallelism: map f a = tabulate(lambda i.f(a[i]), |a|)
  123|       |            // Algorithm 19.4: append a b = flatten([a, b])
  130|       |            // Algorithm 19.4: append a b = flatten([a, b])
  131|       |            // Algorithm 19.1: empty = tabulate(lambda i.i, 0) - use trait method
  132|       |            // Algorithm 19.4 alternative: append a b = tabulate(select(a,b), |a|+|b|)
  132|       |            // Algorithm 19.4: append a b = flatten([a, b])
  135|       |        /// Algorithm 44.3: find function - simple table lookup
  143|       |            // Algorithm 19.4: append a b = flatten([a, b])
  144|       |        /// Algorithm 44.3: queryAnd - set intersection
  147|       |    /// Algorithm 66.3: Borůvka's MST
  148|       |            // Algorithm 19.2: singleton x = tabulate(lambda i.x, 1) - use trait method
  148|       |        /// Algorithm 44.3: queryOr - set union
  151|       |            // Algorithm 19.4 alternative: append a b = tabulate(select(a,b), |a|+|b|)
  152|       |            // Algorithm 19.5 with parallelism: fork thread per element + serial compaction
  152|       |        /// Algorithm 44.3: queryAndNot - set difference
  153|       |            // Algorithm 19.4 alternative: append a b = tabulate(select(a,b), |a|+|b|)
  153|       |            // Algorithm 19.5: filter f a = flatten(map(deflate f, a))
  156|       |        /// Algorithm 44.3: size function
  158|       |        /// Algorithm from Data Structure 47.6
   15|       |    /// Algorithm 21.1 (2D Points) using ArraySeqPer: points2D via tabulate + flatten.
   15|       |    /// Algorithm 21.2 (3D Points) using ArraySeqPer: flatten of nested tabulates.
   15|       |    /// Algorithm 21.6 (Prime Sieve) using ArraySeqPer - simplified version.
  160|       |        /// Algorithm 44.3: toSeq function
  161|       |            // Algorithm 19.8: iterate f x a = left-to-right traversal
  168|       |            // Algorithm 19.5: filter f a = flatten(map(deflate f, a))
   16|       |    /// Algorithm 21.5 (Brute Force Solution to the Primes Problem)
  170|       |            // Algorithm 19.5 with parallelism: fork thread per element + serial compaction
  170|       |            // Algorithm 19.9: reduce using divide-and-conquer
  176|       |            // Algorithm 19.8: iterate f x a = left-to-right traversal
  182|       |            // Algorithm 19.6: update a (i, x) = tabulate(lambda j. if i = j then x else a[j], |a|)
  185|       |            // Algorithm 19.3 with parallelism: map f a = tabulate(lambda i.f(a[i]), |a|)
  185|       |            // Algorithm 19.9: reduce using divide-and-conquer
  185|       |        /// Algorithm from Data Structure 47.6
  186|       |            // Algorithm 19.10: scan using contraction (simplified version)
  195|       |            // Algorithm 19.8: iterate f x a = left-to-right traversal
  201|       |            // Algorithm 19.10: scan using contraction (simplified version)
  209|       |            // Algorithm 19.5 with parallelism: fork thread per element + serial compaction
    4|       |pub mod Algorithm21_1 {
    4|       |pub mod Algorithm21_2 {
  214|       |            // Algorithm 19.7: isEmpty a = |a| = 0
    4|       |pub mod Algorithm21_5 {
    4|       |pub mod Algorithm21_6 {
  219|       |            // Algorithm 19.7: isSingleton a = |a| = 1
  220|       |            // Algorithm 19.9 with parallelism: always parallel divide-and-conquer
  221|       |            // Algorithm 19.7: isEmpty a = |a| = 0
  224|       |            // Algorithm 19.6: update a (i, x) = tabulate(lambda j. if i = j then x else a[j], |a|)
  225|       |            // Algorithm 19.8: iterate f x a = left-to-right traversal
  226|       |            // Algorithm 19.7: isSingleton a = |a| = 1
  231|       |            // Algorithm 19.6: update a (i, x) = tabulate(lambda j. if i = j then x else a[j], |a|)
  235|       |            // Algorithm 19.9 with parallelism: always parallel divide-and-conquer
  242|       |            // Algorithm 19.4: append a b = flatten(<a, b>)
  244|       |            // Algorithm 19.10: scan using contraction (simplified version)
  248|       |            // Algorithm 19.4 alternative: append a b = tabulate(select(a, b), |a| + |b|)
   24|       |    /// Algorithm 61.4: Parallel Vertex Matching
  258|       |            // Algorithm 19.10: scan using contraction (simplified version)
   26|       |    /// Algorithm 62.3: Parallel Star Partition
  278|       |            // Algorithm 19.7: isEmpty a = |a| = 0
   27|       |    /// Algorithm 61.3: Greedy Vertex Matching
  280|       |            // Algorithm 19.7: isEmpty a = |a| = 0
  283|       |            // Algorithm 19.7: isSingleton a = |a| = 1
  285|       |            // Algorithm 19.7: isSingleton a = |a| = 1
  285|       |            // Algorithm 19.9: divide-and-conquer parallel reduce
  288|       |            // Algorithm 19.4 alternative: append a b = tabulate(select(a,b), |a|+|b|)
  290|       |            // Algorithm 19.6: update a (i, x) = tabulate(lambda j. if i = j then x else a[j], |a|)
   30|       |    /// **Algorithm 58.2**: Iterative k-hop distance computation
   30|       |    /// **Algorithm 58.2**: Iterative k-hop distance computation
   30|       |    /// Algorithm 59.1: Johnson's All-Pairs Shortest Paths
  312|       |            // Algorithm 19.10: scan using contraction (simplified for slice)
   31|       |    /// Algorithm 59.1: Johnson's All-Pairs Shortest Paths (Float version)
   32|       |    /// Algorithm:
   32|       |        /// Algorithm 19.11 (Function nth). Return a reference to the element at `index`. <br/>
   32|       |    /// Algorithm 61.6: Sequential Edge Contraction
   32|       |    /// Algorithm 62.5: Star Contraction (Sequential)
  336|       |            // Algorithm 19.8: iterate f x a (sequential left-to-right)
   35|       |    /// Algorithm 59.1: Johnson's All-Pairs Shortest Paths (Parallel)
   35|       |    /// Algorithm 59.1: Johnson's All-Pairs Shortest Paths (Parallel - Float version)
   36|       |    /// Algorithm 61.6: Parallel Edge Contraction
   36|       |    /// Algorithm 62.5: Star Contraction (Parallel)
   37|       |    /// Algorithm 65.2: Kruskal's MST Algorithm
    3|       |//! Bellman-Ford's Algorithm - Single Source Shortest Path with arbitrary edge weights (float)
    3|       |//! Bellman-Ford's Algorithm - Single Source Shortest Path with arbitrary edge weights (integer)
    3|       |//! Dijkstra's Algorithm - Single Source Shortest Path (SSSP+) for non-negative float edge weights
    3|       |//! Dijkstra's Algorithm - Single Source Shortest Path (SSSP+) for non-negative integer edge weights
   40|       |    /// Algorithm 63.2: Count Connected Components
   42|       |    /// Algorithm:
   43|       |    /// Algorithm 63.2: Count Connected Components (Parallel)
   44|       |        /// Algorithm 18.3 (tabulate). Build a sequence by applying `f` to each index. <br/>
   48|       |        /// Algorithm 18.4 (map). Transform each element via `f`. <br/>
   48|       |    /// Algorithm 66.3: Find vertex bridges
    4|       |//! Implements Algorithm 53.4 - Generic Graph Search with pluggable frontier selection.
    4|       |//! Implements Algorithm 53.7 - Priority Queue Search framework.
    4|       |//! Implements Algorithm 59.1 from the textbook.
    4|       |//! Implements Algorithm 59.1 from the textbook.
    4|       |//! Implements Algorithm 59.1 from the textbook with parallelism in Phase 3.
    4|       |//! Implements Algorithm 59.1 from the textbook with parallelism in Phase 3.
    4|       |//! Implements Algorithm 62.3: Parallel Star Partition using randomized coin flips.
    4|       |//! Implements Algorithm 62.5: Star Contraction (parallel version)
    4|       |//! Implements Algorithm 62.5: Star Contraction (sequential version)
    4|       |//! Implements Algorithm 65.1: Prim's algorithm for computing Minimum Spanning Trees.
    4|       |//! Implements Algorithm 65.2: Kruskal's algorithm for computing Minimum Spanning Trees.
    4|       |//! Implements Algorithm 66.2 and 66.3: Borůvka's algorithm for computing Minimum Spanning Trees
   58|       |    /// **Algorithm 57.2**: Priority-First Search using Priority Queue
   58|       |    /// **Algorithm 57.2**: Priority-First Search using Priority Queue
    5|       |//! - Algorithm 61.3: Greedy Vertex Matching (sequential)
    5|       |//! - Algorithm 61.4: Parallel Vertex Matching (randomized with fork/join)
    5|       |//! - Algorithm 61.6: Parallel Edge Contraction (Sequential version)
    5|       |//! - Algorithm 61.6: Parallel Edge Contraction (with fork/join parallelism)
    5|       |//! - Algorithm 63.2: count_components
    5|       |//! - Algorithm 63.2: count_components (parallel)
    5|       |//! Implements Algorithm 57.2 from the textbook using priority queues.
    5|       |//! Implements Algorithm 57.2 from the textbook using priority queues.
    5|       |//! Implements Algorithm 58.2 from the textbook.
    5|       |//! Implements Algorithm 58.2 from the textbook.
   61|       |        /// Algorithm 44.2: Make Index
   64|       |    /// Algorithm 65.1: Prim's MST Algorithm
    6|       |//! - Algorithm 63.3: connected_components
    6|       |//! - Algorithm 63.3: connected_components (parallel)
   70|       |            // Algorithm 19.1: empty = tabulate(lambda i.i, 0)
   70|       |        /// Algorithm from Data Structure 47.6
   71|       |    /// Algorithm 63.3: Connected Components
   73|       |    /// Algorithm 63.3: Connected Components (Parallel)
   76|       |            // Algorithm 19.1: empty = tabulate(lambda i.i, 0)
   77|       |            // Algorithm 19.1: empty = tabulate(lambda i.i, 0)
   78|       |            // Algorithm 19.2: singleton x = tabulate(lambda i.x, 1)
   84|       |            // Algorithm 19.2: singleton x = tabulate(lambda i.x, 1)
   85|       |            // Algorithm 19.2: singleton x = tabulate(lambda i.x, 1)
   86|       |        /// Algorithm 18.21 (collect). Group values with equal keys under `cmp`. <br/>
   87|       |            // Algorithm 53.4: Generic Graph Search
   88|       |            // Algorithm 19.1: empty = tabulate(lambda i.i, 0)
   96|       |            // Algorithm 19.2: singleton x = tabulate(lambda i.x, 1)
   97|       |    /// Algorithm 66.2: Bridge star partition
  162|      0|        output.push_str("- All implementations produce identical, correctly sorted results\n");
  169|      2|2. Rehash all existing elements into new table
  192|     21|            let all = self.values_in_order();
   27|     12|        let all: ArraySeqStPerS<N> = <ArraySeqStPerS<N> as ArraySeqStPerTrait<N>>::tabulate(&|i| i + 2, n - 2);
   35|     16|        let all: ArraySeqStPerS<B> =
    3|       |//! Finds all strongly connected components using ephemeral structures.
    3|       |//! Finds all strongly connected components using transpose and DFS.
   50|       |        /// All distances are set to UNREACHABLE, all predecessors to NO_PREDECESSOR.
   50|       |        /// All distances are set to UNREACHABLE except diagonal (0), all predecessors to NO_PREDECESSOR.
   51|       |        /// All distances are set to UNREACHABLE, all predecessors to NO_PREDECESSOR.
   51|       |        /// All distances are set to UNREACHABLE except diagonal (0), all predecessors to NO_PREDECESSOR.
   52|       |        /// All distances are set to UNREACHABLE except diagonal (0.0), all predecessors to NO_PREDECESSOR.
   53|       |        /// All distances are set to UNREACHABLE, all predecessors to NO_PREDECESSOR.
   53|       |        /// All distances are set to UNREACHABLE, all predecessors to NO_PREDECESSOR.
   53|       |        /// All distances are set to UNREACHABLE except diagonal (0.0), all predecessors to NO_PREDECESSOR.
    6|       |//! - All functionality lives in the library; benches/tests import the crate APIs.
    6|       |//! - All operations delegate to OrderedTableStPer
   38|       |        fn all(a: &ArraySeqStPerS<B>) -> B;
   55|     18|        fn all(a: &ArraySeqStPerS<B>) -> B { ArraySeqStPerS::reduce(a, &|x, y| *x && *y, true) }
  115|      7|            if all_adjacent_tails {
   12|       |        fn all_contiguous_subseqs<T: StT>(a: &ArraySeqStPerS<T>) -> ArraySeqStPerS<ArraySeqStPerS<T>>;
  155|      0|        let all_correct = correctness_verification();
   80|     10|        let (all_distances, all_predecessors) = parallel_dijkstra_all(&reweighted_graph, &potentials, 0, n, n);
   80|      5|        let (all_distances, all_predecessors) = parallel_dijkstra_all(&reweighted_graph, &potentials, 0, n, n);
   83|     10|            distances: all_distances,
   83|      5|            distances: all_distances,
   89|      5|            distances: all_distances,
   98|      5|            distances: all_distances,
  352|      1|            let all_elements = self.to_vec();
   35|       |            // Allow values > 1.0 for costs in dynamic programming
   92|       |                // Allow setting at index 0 on empty tree (append to empty)
   16|       |pub mod AllPairsResultStEphFloat {
   48|       |    /// `AllPairsResultStEphFloat` containing n×n distance matrix and predecessor matrix
   51|       |    impl AllPairsResultStEphFloat {
   57|       |    /// `AllPairsResultStEphFloat` containing n×n distance matrix and predecessor matrix
   15|       |pub mod AllPairsResultStEphInt {
   47|       |    /// `AllPairsResultStEphInt` containing n×n distance matrix and predecessor matrix
   49|       |    impl AllPairsResultStEphInt {
   57|       |    /// `AllPairsResultStEphInt` containing n×n distance matrix and predecessor matrix
   16|       |pub mod AllPairsResultStPerFloat {
   50|       |    impl AllPairsResultStPerFloat {
   15|       |pub mod AllPairsResultStPerInt {
   48|       |    impl AllPairsResultStPerInt {
   39|       |        fn all_parallel(a: &ArraySeqMtPerS<B>) -> B;
   66|      2|        fn all_parallel(a: &ArraySeqMtPerS<B>) -> B {
   84|     10|            predecessors: all_predecessors,
   84|      5|            predecessors: all_predecessors,
   90|      5|            predecessors: all_predecessors,
   99|      5|            predecessors: all_predecessors,
   36|      5|            let all_prefixes = ArraySeqStEphS::from_vec(all_prefixes_vec);
   39|      5|            let all_prefixes = ArraySeqMtEphS::from_vec(all_prefixes_vec);
   10|       |    const ALPHA: f64 = 0.75;
   12|       |    const ALPHA: f64 = 0.75;
  304|       |            // Already sorted, just convert to vector
  335|       |            // Already sorted, just convert to vector
  116|       |        // Already-Sorted Example
  184|       |        fn already_sorted_example() -> HeapsortComparison<i32>;
  131|       |            // Always parallel for MT - divide and conquer
  226|       |                // Always parallel for MT - divide and conquer
  227|       |                // Always parallel for MT - divide and conquer
  241|       |                // Always parallel for MT - divide and conquer
   10|       |//! **Algorithmic Analysis:**
   10|       |//! **Algorithmic Analysis:**
   10|       |//! **Algorithmic Analysis:**
   10|       |//! **Algorithmic Analysis:**
   10|       |//! **Algorithmic Analysis:**
   10|       |//! **Algorithmic Analysis:**
   11|       |//! **Algorithmic Analysis:**
   11|       |//! **Algorithmic Analysis:**
   11|       |//! **Algorithmic Analysis:**
   11|       |//! **Algorithmic Analysis:**
  180|      2|- Amortized analysis still holds with proper thresholds
  373|      1|                    recommended_action: "Analysis disabled".to_string(),
    3|       |//! Comprehensive analysis of primary and secondary clustering phenomena
    4|       |//! Work/Span Analysis:
    4|       |//! Work/Span Analysis:
    4|       |//! Work/Span Analysis (with extract-parallelize-rebuild pattern):
    7|       |//! **Algorithmic Analysis:**
    7|       |//! **Algorithmic Analysis:**
    7|       |//! **Algorithmic Analysis:**
    7|       |//! **Algorithmic Analysis:**
    7|       |//! **Algorithmic Analysis:**
    7|       |//! **Algorithmic Analysis:**
    7|       |//! **Algorithmic Analysis:**
    8|       |//! **Algorithmic Analysis:**
    8|       |//! **Algorithmic Analysis:**
   64|       |        pub analysis_enabled: B,
  103|       |        /// Analyze quadratic probing sequence
  129|       |        /// Analyze quadratic probing clustering
  132|       |        /// Analyze double hashing quality for a specific key and table size
  142|       |        /// Analyze double hashing sequence
  153|       |        /// Analyze secondary clustering in a hash table
  171|       |        /// Analyze collision pattern in probe sequence
  171|       |        /// Analyze double hashing quality
  187|       |            // Analyze collision chains by tracking probe sequences
  215|       |            // Analyze linear probing
  225|       |            // Analyze quadratic probing
  235|       |            // Analyze double hashing
  252|       |        // Analyze clustering
  258|       |        /// Analyze the theoretical complexity of each heapsort variant
  264|       |    /// Analyze the theoretical complexity of each heapsort variant
  320|       |        // Analyze double hashing quality
  347|       |        // Analyze quality
  347|       |        // Analyze secondary clustering
  456|       |        // Analyze with moderate load factor and prime table size
   51|       |        /// Analyze primary clustering in a hash table
   68|       |        /// Analyze linear probing sequence
   87|       |        /// Analyze linear probing clustering
  173|     90|        fn analyze_collision_pattern(&self, sequence: &[N]) -> String {
  253|      2|        let analyzer = ProbeSequenceAnalyzer::new();
  287|      2|        let analyzer = ProbeSequenceAnalyzer::new();
  322|      2|        let analyzer = ProbeSequenceAnalyzer::new();
  356|      2|        let analyzer = ProbeSequenceAnalyzer::new();
  389|      2|        let analyzer = ProbeSequenceAnalyzer::new();
  407|      2|        let analyzer = ProbeSequenceAnalyzer::new();
  454|      1|        let analyzer = ClusteringAnalyzer::new();
  464|      1|        let analyzer = ClusteringAnalyzer::new();
   51|     15|        let ancestors = ancestors.insert(vertex);
   41|     19|        if ancestors.find(&vertex) {
   42|     19|        if ancestors.find(&vertex) {
  138|       |        /// and of length `length` without copying or allocation (zero‑copy view). <br/>
   20|       |        /// and for prime sizes, ensure < m and non-zero.
   67|     24|                format!("h2(k)={} and table_size={} are relatively prime", h2_value, table_size)
   70|      2|                    "h2(k)={} and table_size={} are NOT relatively prime (gcd={})",
   25|      7|                return a.nth(0).clone();
  260|  50.0k|                return a.nth(0).clone();
  313|     82|                return a.nth(0).clone();
  360|     40|                return a.nth(0).clone();
  401|     34|                return a.nth(0).clone();
  290|      8|                return a.nth_cloned(0);
  338|  2.00k|                return a.nth_cloned(0);
   37|      7|                return a.nth_cloned(0);
  144|      3|                result.set(i, a.nth_cloned(i)).unwrap();
  216|      3|                    result.set(result_idx, a.nth_cloned(i)).unwrap();
  142|     15|                result.set(i, a.nth(i).clone()).unwrap();
   32|       |        fn any(a: &ArraySeqStPerS<B>) -> B;
   53|     18|        fn any(a: &ArraySeqStPerS<B>) -> B { ArraySeqStPerS::reduce(a, &|x, y| *x || *y, false) }
   33|       |        fn any_parallel(a: &ArraySeqMtPerS<B>) -> B;
   61|      2|        fn any_parallel(a: &ArraySeqMtPerS<B>) -> B {
  100|       |        /// APAS: Work Θ(len), Span Θ(1)
  101|       |        /// APAS: Work Θ(|A|), Span Θ(1)
  102|       |    /// APAS: Work O(n), Span O(n)
  102|       |        /// APAS: Work Θ(1), Span Θ(1)
  103|       |        /// APAS: Work Θ(|a|+|b|), Span Θ(1)
  103|       |        /// APAS: Work Θ(|E|), Span Θ(1)
  104|       |        /// APAS: Work O(α(n)), Span O(α(n)) amortized
  104|       |        /// APAS: Work Θ(1), Span Θ(1)
  105|       |        /// APAS: Work Θ(1), Span Θ(1)
  106|       |        // APAS - work O(lg |t|), span O(lg |t|)
  106|       |        /// APAS: Work Θ(|a|), Span Θ(1)
  107|       |        // APAS - work O(1), span O(1)
  108|       |        /// APAS: Work Θ(1), Span Θ(1)
  109|       |        /// APAS: Work Θ(Σ|a[i]|), Span Θ(1)
  110|       |        /// APAS: Work Θ(n), Span Θ(n)
  111|       |        /// APAS: Work Θ(1), Span Θ(1)
  112|       |    /// APAS: Work O((n + m) lg n), Span O((n + m) lg n)
  112|       |        /// APAS: Work Θ(|A|), Span Θ(1)
  112|       |        /// APAS: Work Θ(|a|+|updates|), Span Θ(1)
  112|       |        /// APAS: Work Θ(n), Span Θ(1)
  114|       |        /// APAS: Work Θ(1), Span Θ(1)
  114|       |        /// APAS: Work Θ(|A|), Span Θ(1)
  114|       |        /// APAS: Work Θ(n), Span Θ(1)
  114|       |        /// APAS: Work Θ(n), Span Θ(1)
  115|       |        /// APAS: Work Θ(1), Span Θ(1)
  115|       |        /// APAS: Work Θ(1), Span Θ(1)
  117|       |        /// APAS: Work Θ(1), Span Θ(1)
  117|       |        /// APAS: Work Θ(1), Span Θ(1)
  117|       |        /// APAS: Work Θ(|a|), Span Θ(log|a|)
  117|       |        /// APAS: Work Θ(|E|), Span Θ(1)
  118|       |    /// APAS: Work O(n), Span O(n)
  118|       |        /// APAS: Work Θ(1), Span Θ(1)
  118|       |        /// APAS: Work Θ(1), Span Θ(1)
  119|       |        // APAS - work O(lg |t|), span O(lg |t|)
  119|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   11|       |        /// APAS is underspecified with:
   11|       |        /// APAS: Work Θ(1), Span Θ(1)
   11|       |        /// APAS: Work Θ(1), Span Θ(1)
   11|       |        /// APAS: Work Θ(1), Span Θ(1)
   11|       |        /// APAS: Work Θ(|a|·|b|), Span Θ(|a|·|b|)
   11|       |        /// APAS: Work Θ(n²), Span Θ(lg n)
   11|       |        /// APAS: Work Θ(n²), Span Θ(lg n)
   11|       |        /// APAS: Work Θ(n²), Span Θ(n²)
   11|       |        /// APAS: Work Θ(n³), Span Θ(lg n)
   11|       |        /// APAS: Work Θ(n³), Span Θ(n³)
   11|       |        /// APAS: Work Θ(n lg n), Span Θ(lg n)
   11|       |        /// APAS: Work Θ(n), Span Θ(n)
   11|       |        /// APAS: Work Θ(n), Span Θ(n)
   11|       |        /// APAS: Work Θ(n), Span Θ(n)
  120|       |        /// APAS: Work Θ(1), Span Θ(1)
  121|       |        /// APAS: Work Θ(1), Span Θ(1)
  121|       |        /// APAS: Work Θ(1), Span Θ(1)
  121|       |        /// APAS: Work Θ(|pairs|²), Span Θ(1)
  123|       |        /// APAS: Work Θ(1), Span Θ(1)
  124|       |    /// APAS: Work O(n + m), Span O(log n)
  124|       |        /// APAS: Work Θ(1), Span Θ(1)
  124|       |        /// APAS: Work Θ(1), Span Θ(1)
  124|       |        /// APAS: Work Θ(|E|), Span Θ(1)
  125|       |        /// APAS: Work Θ(len), Span Θ(1)
  126|       |        /// APAS: Work Θ(1), Span Θ(1)
  127|       |        // APAS - work O(1), span O(1)
  127|       |        /// APAS: Work Θ(1), Span Θ(1)
  127|       |        /// APAS: Work Θ(|a|), Span Θ(1)
  127|       |        /// APAS: Work Θ(|data|), Span Θ(1)
  128|       |        /// APAS: Work Θ(|a|+|b|), Span Θ(1)
  129|       |        /// APAS: Work Θ(len), Span Θ(1)
  129|       |        /// APAS: Work Θ(n), Span Θ(n)
   12|       |        /// APAS: Work Θ(n^{3/2}), Span Θ(lg n)
   12|       |        /// APAS: Work Θ(n log n), Span Θ(n log n)
   12|       |        /// APAS: Work Θ(n), Span Θ(n)
   12|       |        /// APAS: Work Θ(φⁿ), Span Θ(n)
  130|       |    /// APAS: Work O(n), Span O(n)
  130|       |        /// APAS: Work Θ(|a|), Span Θ(1)
  130|       |        /// APAS: Work Θ(length), Span Θ(1)
  130|       |        /// APAS: Work Θ(n), Span Θ(1)
  131|       |        // APAS - work O(lg |t|), span O(lg |t|)
  131|       |        /// APAS: Work Θ(|a|), Span Θ(1)
  132|       |        /// APAS: Work Θ(n), Span Θ(1)
  133|       |        /// APAS: Work Θ(|a|), Span Θ(1)
  133|       |        /// APAS: Work Θ(|a|), Span Θ(1)
  134|       |        /// APAS: Work Θ(1), Span Θ(1)
  135|       |        /// APAS: Work Θ(n), Span Θ(1)
  136|       |        /// APAS: Work O(α(n)), Span O(α(n)) amortized
  136|       |        /// APAS: Work Θ(len), Span Θ(1)
  137|       |    // APAS trait implementations are automatic due to blanket impl in Types.rs
  137|       |        /// APAS: Work Θ(|a|+|updates|), Span Θ(1)
  138|       |        /// APAS: Work Θ(|a|), Span Θ(log|a|)
  139|       |        /// APAS: Work Θ(1), Span Θ(1)
  139|       |        /// APAS: Work Θ(|a|+|b|), Span Θ(1)
   13|       |        /// APAS: Work Θ(1), Span Θ(1)
   13|       |        /// APAS: Work Θ(1), Span Θ(1)
   13|       |        /// APAS: Work Θ(1), Span Θ(1)
   13|       |        /// APAS: Work Θ(n log n), Span Θ(log n)
   13|       |        /// APAS: Work Θ(n), Span Θ(log n)
   13|       |        /// APAS: Work Θ(n), Span Θ(log n)
  140|       |        // APAS - work O(m · lg (n / m)), span O(lg n)
  140|       |        /// APAS: Work Θ(1), Span Θ(1)
  140|       |        /// APAS: Work Θ(1), Span Θ(1)
  142|       |        /// APAS: Work Θ(1), Span Θ(1)
  142|       |        /// APAS: Work Θ(|a|), Span Θ(1)
  143|       |        // APAS - work O(lg (|left| + |right|)), span O(lg (|left| + |right|))
  143|       |        /// APAS: Work Θ(1), Span Θ(1)
  143|       |        /// APAS: Work Θ(1), Span Θ(1)
  144|       |        /// APAS: Work Θ(1), Span Θ(1)
  145|       |        /// APAS: Work Θ(1), Span Θ(1)
  145|       |        /// APAS: Work Θ(Σ|a[i]|), Span Θ(1)
  146|       |    /// APAS: Work O(n), Span O(n)
  146|       |        /// APAS: Work Θ(|a|+|b|), Span Θ(1)
  146|       |        /// APAS: Work Θ(lg(n)), Span Θ(lg(n))
  146|       |        /// APAS: Work Θ(Σ|ss[i]|), Span Θ(1)
  147|       |        /// APAS: Work Θ(lg(n)), Span Θ(lg(n))
  148|       |        /// APAS (ephemeral set Θ(lg n)); MtPer path-copy Θ(lg n) allocations. Work Θ(lg n), Span Θ(lg n)
  148|       |        /// APAS: Work Θ(1), Span Θ(1)
  149|       |        /// APAS (ephemeral set Θ(lg n)); StPer path-copy Θ(lg n) allocations. Work Θ(lg n), Span Θ(lg n)
  149|       |    /// APAS: Work O((n+m) lg n), Span O((n+m) lg n)
  149|       |        /// APAS: Work O(n α(n)), Span O(n α(n))
  149|       |        /// APAS: Work Θ(|a|²), Span Θ(1)
  149|       |        /// APAS: Work Θ(|a|), Span Θ(1)
   14|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   14|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   14|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   14|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   14|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   14|       |        /// APAS: Work Θ(1), Span Θ(1)
   14|       |        /// APAS: Work Θ(n log n), Span Θ(log n)
  151|       |        /// APAS: Work Θ(|updates|), Span Θ(1)
  152|       |    /// APAS: Work O(m log n), Span O(m log n)
  152|       |        /// APAS: Work Θ(1), Span Θ(1)
  152|       |        /// APAS: Work Θ(|a|), Span Θ(1)
  152|       |        /// APAS: Work Θ(n), Span Θ(1)
  153|       |        /// APAS: Work Θ(1), Span Θ(1)
  154|       |        // APAS - work O(m · lg (n / m)), span O(lg n)
  154|       |        /// APAS: Work Θ(1), Span Θ(1)
  154|       |        /// APAS: Work Θ(1), Span Θ(1)
  155|       |        /// APAS: Work Θ(1), Span Θ(1)
  155|       |        /// APAS: Work Θ(|a|), Span Θ(1)
  155|       |        /// APAS: Work Θ(|a|), Span Θ(log|a|)
  156|       |        // APAS - work O(m · lg (n / m)), span O(lg n)
  156|       |        /// APAS: Work Θ(1), Span Θ(1)
  157|       |        /// APAS: Work Θ(1), Span Θ(1)
  157|       |        /// APAS: Work Θ(1), Span Θ(1)
  158|       |        /// APAS: Work Θ(1 + lg|a|), Span Θ(1 + lg|a|)
  158|       |        /// APAS: Work Θ(|a|), Span Θ(1)
  159|       |        /// APAS: Work Θ(1 + lg|a|), Span Θ(1 + lg|a|)
   15|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   15|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   15|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   15|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   15|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   15|       |        /// APAS: Work Θ(1), Span Θ(1)
   15|       |        /// APAS: Work Θ(n log n), Span Θ(log n)
   15|       |        /// APAS: Work Θ(√n), Span Θ(lg n)
   15|       |        /// APAS: Work Θ(n), Span Θ(log n)
   15|       |        /// APAS: Work Θ(n), Span Θ(log n)
  160|       |        /// APAS: Work Θ(|a|), Span Θ(1)
  160|       |        /// APAS: Work Θ(|pairs|²), Span Θ(1)
  161|       |    /// APAS: Work O((n + m) lg n), Span O(lg² n)
  161|       |        /// APAS: Work Θ(|a|), Span Θ(1)
  164|       |        /// APAS: Work Θ(|A|), Span Θ(1)
  165|       |    /// APAS: Work O((n+m) lg n), Span O((n+m) lg n)
  165|       |    /// APAS: Work O(n), Span O(n)
  166|       |    /// APAS: Work O(|MST|), Span O(|MST|)
  166|       |        /// APAS: Work Θ(|a|), Span Θ(1)
  168|       |        /// APAS: Work Θ(|a|), Span Θ(log|a|)
  169|       |        /// APAS: Work Θ(|a|), Span Θ(1)
   16|       |        /// APAS: Work O(|V| + |E|), Span O(d·lg n) where d is diameter
   16|       |        /// APAS: Work O(|V| + |E|), Span O(d·lg n) where d is diameter
   16|       |        /// APAS: Work Θ(1), Span Θ(1)
   16|       |        /// APAS: Work Θ(1), Span Θ(1)
   16|       |        /// APAS: Work Θ(1), Span Θ(1)
   16|       |        /// APAS: Work Θ(n log n), Span Θ(n log n)
   16|       |        /// APAS: Work Θ(n log n), Span Θ(n log n)
   16|       |        /// APAS: Work Θ(n), Span Θ(log n)
   16|       |        /// APAS: Work Θ(n), Span Θ(log n)
  170|       |        // APAS - work O(m · lg (n / m)), span O(lg n)
  172|       |        // APAS - work O(m · lg (n / m)), span O(lg n)
  172|       |        /// APAS: Work Θ(|a|), Span Θ(1)
  173|       |        /// APAS: Work Θ(|a|), Span Θ(1)
  174|       |        /// APAS: Work Θ(|A|), Span Θ(1)
  176|       |        /// APAS: Work Θ(Σ|ss[i]|), Span Θ(1)
  179|       |        /// APAS: Work Θ(|a|²), Span Θ(1)
   17|       |        /// APAS: Work O(|V| + |E|), Span O(1)
   17|       |        /// APAS: Work Θ(1) expected, Θ(n) worst case, Span Θ(1)
   17|       |        /// APAS: Work Θ(1), Span Θ(1)
   17|       |        /// APAS: Work Θ(1), Span Θ(1)
   17|       |        /// APAS: Work Θ(n log n), Span Θ(log n)
   17|       |        /// APAS: Work Θ(n), Span Θ(1)
  181|       |        /// APAS: Work Θ(n), Span Θ(1)
  186|       |        /// APAS: Work Θ(index), Span Θ(index)
  189|       |        /// APAS: Work Θ(1), Span Θ(1)
   18|       |        /// APAS: hh(k) must be relatively prime to m.
   18|       |        /// APAS: Work Θ(1), Span Θ(1)
   18|       |        /// APAS: Work Θ(1), Span Θ(1)
   18|       |        /// APAS: Work Θ(1), Span Θ(1)
   18|       |        /// APAS: Work Θ(1), Span Θ(1)
   18|       |        /// APAS: Work Θ(1), Span Θ(1)
   18|       |        /// APAS: Work Θ(1), Span Θ(1)
   18|       |        /// APAS: Work Θ(|a|·|b|), Span Θ(lg |a|)
   18|       |    /// APAS: Work: Θ(n²), Span: Θ(lg n)
   18|       |        /// APAS: Work Θ(n log n), Span Θ(log n)
   18|       |        /// APAS: Work Θ(n), Span Θ(n)
   18|       |        /// APAS: Work Θ(|V| + |E|), Span Θ(1)
   18|       |        /// APAS: Work Θ(|V| + |E|), Span Θ(1)
  190|       |        // APAS - work O(m · lg (n / m)), span O(lg n)
  192|       |        // APAS - work O(m · lg (n / m)), span O(lg n)
  192|       |        /// APAS: Work Θ(index), Span Θ(index)
  195|       |        /// APAS: Work Θ(1), Span Θ(1)
  196|       |        /// APAS: Work Θ(1), Span Θ(1).
  197|       |    /// APAS: Work O(n+m), Span O(n+m)
  198|       |        /// APAS: Work Θ(1), Span Θ(1)
  199|       |        /// APAS: Work Θ(1), Span Θ(1).
   19|       |        /// APAS: Work O(|V| + |E|), Span O(lg² |V|)
   19|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   19|       |        /// APAS: Work Θ(1), Span Θ(1)
   19|       |        /// APAS: Work Θ(1), Span Θ(1)
   19|       |        /// APAS: Work Θ(|a|·|b|), Span Θ(lg |a|)
   19|       |        /// APAS: Work Θ(|E|), Span Θ(|E|)
   19|       |        /// APAS: Work Θ(n log n), Span Θ(log n)
   19|       |        /// APAS: Work Θ(n), Span Θ(log n)
  201|       |        /// APAS: Work Θ(n), Span Θ(1)
  202|       |        /// APAS: Work Θ(1), Span Θ(1).
  204|       |        /// APAS: Work Θ(|a|), Span Θ(1)
  205|       |        /// APAS: Work Θ(lg(n)), Span Θ(lg(n)).
  207|       |    /// APAS: Work O((n+m) lg n), Span O(lg² n)
  207|       |        /// APAS: Work Θ(start+length), Span Θ(start+length)
  208|       |        /// APAS: Work Θ(lg(n)), Span Θ(lg(n)).
   20|       |        /// APAS: Work O(|E|), Span O(lg |V|)
   20|       |        /// APAS: Work O(m log m), Span O(m log m) where m = |E|
   20|       |        /// APAS: Work O((n + m) lg n), Span O((n + m) lg n)
   20|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   20|       |        /// APAS: Work O(|V|), Span O(|V|)
   20|       |        /// APAS: Work Θ(1), Span Θ(1)
   20|       |        /// APAS: Work Θ(1), Span Θ(1)
   20|       |        /// APAS: Work Θ(1), Span Θ(1)
   20|       |        /// APAS: Work Θ(1), Span Θ(1)
   20|       |        /// APAS: Work Θ(1), Span Θ(1)
   20|       |        /// APAS: Work Θ(1), Span Θ(1)
   20|       |        /// APAS: Work Θ(1), Span Θ(1)
   20|       |        /// APAS: Work Θ(1), Span Θ(1)
   20|       |        /// APAS: Work Θ(1), Span Θ(1)
   20|       |        /// APAS: Work Θ(1), Span Θ(1)
   20|       |    /// APAS: Work: Θ(n²), Span: Θ(lg n)
   20|       |    /// APAS: Work: Θ(n lg n), Span: Θ(lg n)
   20|       |        /// APAS: Work Θ(n log n) expected, Θ(n²) worst, Span Θ(n log n) expected, Θ(n²) worst
   20|       |        /// APAS: Work Θ(n log n), Span Θ(n log n)
   20|       |    /// APAS: Work Θ(φⁿ), Span Θ(n)
  210|       |        // APAS - work O(|t|), span O(lg |t|)
  210|       |        /// APAS: Work Θ(|a| + |b|), Span Θ(1)
  213|       |    /// APAS: Work O(m log n), Span O(m log n)
  213|       |        // APAS - work O(|t|), span O(lg |t|)
  213|       |        /// APAS: Work Θ(|a|), Span Θ(1)
  214|       |        /// APAS: Work Θ(1), Span Θ(1).
  217|       |    /// APAS: Work O(m log n), Span O(log² n)
  219|       |        /// APAS: Work Θ(Σ|ss[i]|), Span Θ(Σ|ss[i]|)
   21|       |        /// APAS: Work O(|E|), Span O(1)
   21|       |        /// APAS: Work O(|E|), Span O(|E|)
   21|       |        /// APAS: Work O(|E|), Span O(|E|)
   21|       |        /// APAS: Work Θ(1) expected, Θ(n) worst case, Span Θ(1)
   21|       |        /// APAS: Work Θ(1), Span Θ(1)
   21|       |        /// APAS: Work Θ(1), Span Θ(1)
   21|       |        /// APAS: Work Θ(1), Span Θ(1)
   21|       |        /// APAS: Work Θ(1), Span Θ(1)
   21|       |    /// APAS: Work: Θ(n^{3/2}), Span: Θ(lg n)
   21|       |    /// APAS: Work: Θ(n³), Span: Θ(lg n)
   21|       |    /// APAS: Work: Θ(n³), Span: Θ(n³)
   21|       |        /// APAS: Work Θ(n log n), Span Θ(log² n)
   21|       |        /// APAS: Work Θ(n), Span Θ(1)
  221|       |    /// APAS: Work O((n+m) lg n), Span O(lg² n)
  221|       |        /// APAS: Work Θ(1), Span Θ(1).
  222|       |        /// APAS: Work Θ(index), Span Θ(index)
  223|       |    /// APAS: Work O(n+m), Span O(n+m)
  223|       |        /// APAS: Work Θ(1), Span Θ(1).
  225|       |        /// APAS: Work Θ(|a| + |updates|), Span Θ(1)
  226|       |        /// APAS: Work Θ(1 + lg(|a|)), Span Θ(1 + lg(|a|)).
  228|       |        /// APAS: Work Θ(|a| + |updates|), Span Θ(1)
   22|       |            // APAS: hh(k) must be non-zero and coprime to m
   22|       |        /// APAS: Work O(|E|), Span O(lg |V|)
   22|       |        /// APAS: Work O(n²), Span O(n²)
   22|       |        /// APAS: Work O(n²), Span O(n²)
   22|       |        /// APAS: Work O(n³), Span O(n³)
   22|       |        /// APAS: Work O(n³), Span O(n³)
   22|       |        /// APAS: Work O(|V| + |E|), Span O(lg |V|)
   22|       |        /// APAS: Work O(|V|), Span O(|V|)
   22|       |        /// APAS: Work Θ(1), Span Θ(1)
   22|       |        /// APAS: Work Θ(1), Span Θ(1)
   22|       |        /// APAS: Work Θ(n³), Span Θ(log n)
   22|       |        /// APAS: Work Θ(n log n) expected, Θ(n²) worst, Span Θ(log² n) expected, Θ(n) worst
   22|       |        /// APAS: Work Θ(n log n) expected, Θ(n²) worst, Span Θ(log² n) expected, Θ(n) worst
   22|       |        /// APAS: Work Θ(n log n), Span Θ(log n)
   22|       |        /// APAS: Work Θ(|V| + |E|), Span Θ(1)
   22|       |        /// APAS: Work Θ(|V| + |E|), Span Θ(1)
   22|       |        /// APAS: Work Θ(|V| + |E|), Span Θ(1)
   22|       |        /// APAS: Work Θ(|V| + |E|), Span Θ(1)
  231|       |        // APAS - work O(|t|), span O(lg |t|)
  231|       |        /// APAS: Work Θ(|a|²), Span Θ(|a|²)
  234|       |    /// APAS: Work O(m), Span O(m)
  234|       |        // APAS - work O(|t|), span O(lg |t|)
  237|       |        /// APAS: Work Θ(|a|), Span Θ(|a|)
  238|       |        // APAS - work O(|t|), span O(lg |t|)
   23|       |        /// APAS: Work O(|E|), Span O(lg |E|)
   23|       |        /// APAS: Work O(m log n), Span O(m log n) where m = |E|, n = |V|
   23|       |        /// APAS: Work O((n + m) lg n), Span O(lg² n)
   23|       |        /// APAS: Work O(nm), Span O(n lg n) where n = |V|, m = |E|
   23|       |        /// APAS: Work O(nm), Span O(n lg n) where n = |V|, m = |E|
   23|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   23|       |        /// APAS: Work Θ(1), Span Θ(1)
   23|       |        /// APAS: Work Θ(1), Span Θ(1)
   23|       |        /// APAS: Work Θ(|E|), Span Θ(|E|)
   23|       |        /// APAS: Work Θ(n²), Span Θ(log n)
   23|       |        /// APAS: Work Θ(n log n) expected, Θ(n²) worst, Span Θ(n log n) expected, Θ(n²) worst
   23|       |        /// APAS: Work Θ(n), Span Θ(n)
   23|       |        /// APAS: Work Θ(|V| + |A|), Span Θ(1)
   23|       |        /// APAS: Work Θ(|V| + |A|), Span Θ(1)
   23|       |        /// APAS: Work Θ(|V| + |E|), Span Θ(1)
   23|       |        /// APAS: Work Θ(|V| + |E|), Span Θ(1)
  240|       |        /// APAS: Work Θ(|a|), Span Θ(|a|)
  241|       |        // APAS - work O(|t|), span O(lg |t|)
  243|       |        /// APAS: Work Θ(|a|), Span Θ(|a|)
  246|       |        /// APAS: Work Θ(|a|²), Span Θ(|a|²)
   24|       |        /// APAS: Work O(m log n), Span O(m log n) where m = |E|, n = |V|
   24|       |        /// APAS: Work O(m log n), Span O(m log n) where m = |E|, n = |V|
   24|       |        /// APAS: Work O(n²), Span O(lg n)
   24|       |        /// APAS: Work O(n²), Span O(n)
   24|       |        /// APAS: Work O(n³), Span O(lg n)
   24|       |        /// APAS: Work O(n³), Span O(n)
   24|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   24|       |        /// APAS: Work O(α(n)), Span O(α(n)) amortized (inverse Ackermann)
   24|       |        /// APAS: Work Θ(1), Span Θ(1)
   24|       |        /// APAS: Work Θ(1), Span Θ(1)
   24|       |        /// APAS: Work Θ(1), Span Θ(1)
   24|       |        /// APAS: Work Θ(1), Span Θ(1)
   24|       |        /// APAS: Work Θ(length), Span Θ(1)
   24|       |        /// APAS: Work Θ(n log n), Span Θ(n log n)
   24|       |        /// APAS: Work Θ(n), Span Θ(n)
   24|       |        /// APAS: Work Θ(|pairs|), Span Θ(1)
   25|       |        /// APAS: Work O(1), Span O(1).
   25|       |        /// APAS: Work O(|V| + |E|), Span O(lg |V|)
   25|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   25|       |        /// APAS: Work Θ(1), Span Θ(1)
   25|       |        /// APAS: Work Θ(1), Span Θ(1)
   25|       |        /// APAS: Work Θ(n log n) expected, Θ(n²) worst, Span Θ(log² n) expected, Θ(n) worst
   25|       |        /// APAS: Work Θ(n log n) expected, Θ(n²) worst, Span Θ(log² n) expected, Θ(n) worst
   25|       |        /// APAS: Work Θ(n), Span Θ(1)
   25|       |        /// APAS: Work Θ(n), Span Θ(log n)
   25|       |        /// APAS: Work Θ(|v|), Span Θ(1)
  262|       |        // APAS - work O(|t|), span O(lg |t|)
  262|       |        // APAS - work O(|t|), span O(lg |t|)
  269|       |        // APAS - work O(|t|), span O(|t|)
   26|       |        /// APAS: Work O(mn log n), Span O(mn log n) where n = |V|, m = |E|
   26|       |        /// APAS: Work O(m), Span O(1)
   26|       |        /// APAS: Work Θ(1) expected, Θ(n) worst case, Span Θ(1)
   26|       |        /// APAS: Work Θ(1), Span Θ(1)
   26|       |        /// APAS: Work Θ(1), Span Θ(1)
   26|       |        /// APAS: Work Θ(1), Span Θ(1)
   26|       |        /// APAS: Work Θ(1), Span Θ(1)
   26|       |        /// APAS: Work Θ(1), Span Θ(1)
   26|       |        /// APAS: Work Θ(n²), Span Θ(n²)
   26|       |        /// APAS: Work Θ(n log n) expected, Θ(n²) worst, Span Θ(n log n) expected, Θ(n²) worst
   26|       |        /// APAS: Work Θ(n), Span Θ(n)
   26|       |        /// APAS: Work Θ(|V| + |A|), Span Θ(1)
   26|       |        /// APAS: Work Θ(|V| + |E|), Span Θ(1)
  272|       |        // APAS - work O(|t|), span O(|t|)
  279|       |    /// APAS: Work Θ(n²), Span Θ(1) - simple membership test both ways
   27|       |        /// APAS: Work O(mn log n), Span O(mn log n) where n = |V|, m = |E|
   27|       |        /// APAS: Work O(|V| + |E|), Span O(lg² |V|)
   27|       |        /// APAS: Work O(|V|), Span O(lg |V|)
   27|       |        /// APAS: Work Θ(1), Span Θ(1)
   27|       |        /// APAS: Work Θ(1), Span Θ(1)
   27|       |        /// APAS: Work Θ(n²), Span Θ(n²)
   27|       |        /// APAS: Work Θ(n), Span Θ(n)
   27|       |        /// APAS: Work Θ(|V| + |A|), Span Θ(1)
   27|       |        /// APAS: Work Θ(|V| + |E|), Span Θ(1)
  284|       |        // APAS - work O(1), span O(1)
  287|       |        /// APAS: Work O(1), Span O(1)
   28|       |        /// APAS: Work O((n + m) lg n), Span O((n + m) lg n)
   28|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   28|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   28|       |        /// APAS: Work O(α(n)), Span O(α(n)) amortized
   28|       |        /// APAS: Work Θ(1), Span Θ(1)
   28|       |        /// APAS: Work Θ(1), Span Θ(1)
   28|       |        /// APAS: Work Θ(1), Span Θ(1)
   28|       |        /// APAS: Work Θ(1), Span Θ(1)
   28|       |        /// APAS: Work Θ(1 + Σ i=0..n-1 W(f(i))), Span Θ(1 + max i=0..n-1 S(f(i)))
   28|       |        /// APAS: Work Θ(1 + Σ i=0..n-1 W(f(i))), Span Θ(1 + max i=0..n-1 S(f(i)))
   28|       |        /// APAS: Work Θ(n²), Span Θ(n²)
   28|       |        /// APAS: Work Θ(n log n) expected, Θ(n²) worst, Span Θ(log² n) expected, Θ(n) worst
   28|       |        /// APAS: Work Θ(n log n) expected, Θ(n²) worst, Span Θ(log² n) expected, Θ(n) worst
  290|       |        /// APAS: Work O(1), Span O(1)
  292|       |        // APAS - work O(1), span O(1)
  293|       |        /// APAS: Work O(1), Span O(1)
  296|       |        // APAS - work O(1), span O(1)
  296|       |        /// APAS: Work O(1), Span O(1)
  299|       |        /// APAS: Work O(1), Span O(1)
   29|       |        /// APAS: Work O(1) expected, Span O(1).
   29|       |        /// APAS: Work O(|V| + |E|), Span O(lg |V|)
   29|       |        /// APAS: Work O(|V| + |E|), Span O(lg |V|)
   29|       |        /// APAS: Work O(|V|), Span O(|V|)
   29|       |        /// APAS: Work Θ(1) expected, Θ(n) worst case, Span Θ(1)
   29|       |        /// APAS: Work Θ(1), Span Θ(1)
   29|       |        /// APAS: Work Θ(1), Span Θ(1)
   29|       |        /// APAS: Work Θ(1), Span Θ(1)
   29|       |        /// APAS: Work Θ(1), Span Θ(1)
   29|       |        /// APAS: Work Θ(1), Span Θ(1)
   29|       |        /// APAS: Work Θ(1), Span Θ(1)
   29|       |        /// APAS: Work Θ(1), Span Θ(1)
   29|       |        /// APAS: Work Θ(1), Span Θ(1)
   29|       |        /// APAS: Work Θ(n²), Span Θ(n²)
   29|       |        /// APAS: Work Θ(n), Span Θ(1)
   29|       |    /// APAS: Work: Θ(√n), Span: Θ(lg n)
   29|       |        /// APAS: Work Θ(n), Span Θ(n)
   29|       |        /// APAS: Work Θ(n), Span Θ(n)
   29|       |        /// APAS: Work Θ(|r|), Span Θ(1)
  300|       |        // APAS - work O(1), span O(1)
  302|       |        // APAS - work O(lg |t|), span O(lg |t|)
  305|       |        // APAS - work O(lg |t|), span O(lg |t|)
  307|       |        // APAS - work O(1), span O(1)
  308|       |        // APAS - work O(lg |t|), span O(lg |t|)
   30|       |        /// APAS: Work O(1), Span O(1)
   30|       |        /// APAS: Work O(m), Span O(1)
   30|       |        /// APAS: Work Θ(1), Span Θ(1)
   30|       |        /// APAS: Work Θ(1), Span Θ(1)
   30|       |        /// APAS: Work Θ(1), Span Θ(1)
   30|       |        /// APAS: Work Θ(1), Span Θ(1)
   30|       |        /// APAS: Work Θ(1), Span Θ(1)
   30|       |        /// APAS: Work Θ(1), Span Θ(1)
   30|       |        /// APAS: Work Θ(|a| + |b|), Span Θ(1)
   30|       |    /// APAS: Work: Θ(|a|·|b|), Span: Θ(|a|·|b|)
   30|       |        /// APAS: Work Θ(n), Span Θ(n)
  311|       |        // APAS - work O(lg |t|), span O(lg |t|)
  311|       |        // APAS - work O(lg |t|), span O(lg |t|)
  314|       |        // APAS - work O(lg (|t_1| + |t_2|)), span O(lg (|t_1| + |t_2|))
  314|       |    /// APAS: Work O(m log n), Span O(log² n)
  317|       |        // APAS - work O(m · lg (n / m)), span O(lg n)
   31|       |        /// APAS: Work O(1), Span O(1)
   31|       |        /// APAS: Work O(mn log n), Span O(m log n) where n = |V|, m = |E|
   31|       |        /// APAS: Work O(mn log n), Span O(m log n) where n = |V|, m = |E|
   31|       |        /// APAS: Work O(|V| + |E|), Span O(lg² |V|)
   31|       |        /// APAS: Work O(|V|), Span O(lg |V|)
   31|       |        /// APAS: Work Θ(1), Span Θ(1)
   31|       |        /// APAS: Work Θ(1), Span Θ(1)
   31|       |        /// APAS: Work Θ(1), Span Θ(1)
   31|       |        /// APAS: Work Θ(1 + Σ x∈a W(f(x))), Span Θ(1 + max x∈a S(f(x)))
   31|       |        /// APAS: Work Θ(1 + Σ x∈a W(f(x))), Span Θ(1 + max x∈a S(f(x)))
   31|       |    /// APAS: Work Θ(|E| × avg_degree), Span Θ(log |E| + avg_degree)
   31|       |        /// APAS: Work Θ(n), Span Θ(log n)
  320|       |        // APAS - work O(m · lg (n / m)), span O(lg n)
  321|       |        // APAS - work O(lg |t|), span O(lg |t|)
  323|       |        // APAS - work O(m · lg (n / m)), span O(lg n)
  326|       |        // APAS - work O(|t|), span O(lg |t|)
  329|       |        // APAS - work O(|t|), span O(lg |t|)
   32|       |        /// APAS: Work O(m log n), Span O(m log n)
   32|       |        /// APAS: Work O((n + m) lg n), Span O(lg² n)
   32|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   32|       |        /// APAS: Work O(α(n)), Span O(α(n)) amortized
   32|       |        /// APAS: Work Θ(1), Span Θ(1)
   32|       |        /// APAS: Work Θ(1), Span Θ(1)
   32|       |        /// APAS: Work Θ(1), Span Θ(1)
   32|       |        /// APAS: Work Θ(1), Span Θ(1)
   32|       |        /// APAS: Work Θ(1), Span Θ(1)
   32|       |        /// APAS: Work Θ(1), Span Θ(1)
   32|       |        /// APAS: Work Θ(1), Span Θ(1)
   32|       |        /// APAS: Work Θ(1), Span Θ(1)
   32|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   32|       |        /// APAS: Work Θ(|E|), Span Θ(1)
   32|       |    /// APAS: Work Θ(|E|), Span Θ(|E|)
   32|       |    /// APAS: Work Θ(n + m), Span Θ(n + m)
   32|       |        /// APAS: Work Θ(|R|), Span Θ(1)
  331|       |        // APAS - work O(lg |t|), span O(lg |t|)
  331|       |    /// APAS: Work Θ(1), Span Θ(1)
  334|       |        // APAS - work O(|t|), span O(|t|)
  336|       |    /// APAS: Work Θ(1), Span Θ(1)
  337|       |    /// APAS: Work O(m), Span O(m)
   33|       |    /// APAS: Work O((n+m) lg n), Span O(lg² n)
   33|       |        /// APAS: Work O(|V|), Span O(|V|)
   33|       |        /// APAS: Work Θ(1), Span Θ(1)
   33|       |        /// APAS: Work Θ(1), Span Θ(1)
   33|       |        /// APAS: Work Θ(1), Span Θ(1)
   33|       |        /// APAS: Work Θ(1), Span Θ(1)
   33|       |        /// APAS: Work Θ(1), Span Θ(1)
   33|       |        /// APAS: Work Θ(1), Span Θ(1)
   33|       |        /// APAS: Work Θ(1), Span Θ(1)
   33|       |        /// APAS: Work Θ(1), Span Θ(1)
   33|       |        /// APAS: Work Θ(|a| + |b|), Span Θ(1)
   33|       |        /// APAS: Work Θ(|a|), Span Θ(lg |a|)
  340|       |        // APAS - work O(1), span O(1)
  344|       |        // APAS - work O(lg |t|), span O(lg |t|)
  348|       |        // APAS - work O(1), span O(1)
  348|       |        // APAS - work O(lg (|t_1| + |t_2|)), span O(lg (|t_1| + |t_2|))
   34|       |        /// APAS: Work O(1), Span O(1)
   34|       |    /// APAS: Work O(n + m), Span O(lg n)
   34|       |        /// APAS: Work Θ(1), Span Θ(1)
   34|       |        /// APAS: Work Θ(1), Span Θ(1)
   34|       |        /// APAS: Work Θ(1), Span Θ(1)
   34|       |        /// APAS: Work Θ(1), Span Θ(1)
   34|       |        /// APAS: Work Θ(1), Span Θ(1)
   34|       |        /// APAS: Work Θ(1), Span Θ(1)
  352|       |        // APAS - work O(1), span O(1)
  352|       |        // APAS - work O(m · lg (n / m)), span O(lg n)
  356|       |        // APAS - work O(1), span O(1)
  356|       |        // APAS - work O(m · lg (n / m)), span O(lg n)
   35|       |        /// APAS: Work O(|V| + |E|), Span O(lg² |V|)
   35|       |    /// APAS: Work Θ(1) expected, Θ(n) worst case, Span Θ(1)
   35|       |        /// APAS: Work Θ(1), Span Θ(1)
   35|       |        /// APAS: Work Θ(1), Span Θ(1)
   35|       |        /// APAS: Work Θ(1), Span Θ(1)
   35|       |        /// APAS: Work Θ(1), Span Θ(1)
   35|       |        /// APAS: Work Θ(1), Span Θ(1)
   35|       |        /// APAS: Work Θ(1), Span Θ(1)
   35|       |        /// APAS: Work Θ(1), Span Θ(1)
   35|       |        /// APAS: Work Θ(1), Span Θ(1)
   35|       |        /// APAS: Work Θ(1), Span Θ(1)
   35|       |        /// APAS: Work Θ(1), Span Θ(1)
  360|       |        // APAS - work O(1), span O(1)
  360|       |        // APAS - work O(m · lg (n / m)), span O(lg n)
  364|       |        // APAS - work O(lg |t|), span O(lg |t|)
  364|       |        // APAS - work O(|t|), span O(lg |t|)
   36|       |    /// **APAS Analysis:** Work O(mn log n), Span O(m log n)
   36|       |        /// APAS: Work O(m log n), Span O(log² n)
   36|       |        /// APAS: Work O(m log n), Span O(m log n)
   36|       |        /// APAS: Work O(n α(n)), Span O(n α(n))
   36|       |        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)
   36|       |        /// APAS: Work Θ(1), Span Θ(1)
   36|       |        /// APAS: Work Θ(1), Span Θ(1)
   36|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   36|       |        /// APAS: Work Θ(|E|), Span Θ(1)
   36|       |        /// APAS: Work Θ(n²), Span Θ(n²) - dominated by worst implementation
   36|       |        /// APAS: Work Θ(n), Span Θ(n)
   36|       |        /// APAS: Work Θ(n), Span Θ(n)
   36|       |        /// APAS: Work Θ(|parts| × |a|²), Span Θ(1)
  370|       |        // APAS - work O(|t|), span O(lg |t|)
  375|       |        // APAS - work O(lg |t|), span O(lg |t|)
  376|       |        // APAS - work O(|t|), span O(|t|)
   37|       |    /// **APAS Analysis:** Work O(mn log n), Span O(m log n)
   37|       |        /// APAS: Work O(1), Span O(1)
   37|       |        /// APAS: Work Θ(1 + |a| + |b|), Span Θ(1)
   37|       |        /// APAS: Work Θ(1 + |a| + |b|), Span Θ(1)
   37|       |        /// APAS: Work Θ(1), Span Θ(1)
   37|       |        /// APAS: Work Θ(1), Span Θ(1)
   37|       |        /// APAS: Work Θ(1), Span Θ(1)
   37|       |        /// APAS: Work Θ(1), Span Θ(1)
   37|       |        /// APAS: Work Θ(index), Span Θ(index)
   37|       |        /// APAS: Work Θ(|m|), Span Θ(1)
   37|       |        /// APAS: Work Θ(n), Span Θ(log n)
   37|       |        /// APAS: Work Θ(|s| * W(f)), Span Θ(lg |s| + S(f))
  385|       |        // APAS - work O(lg |t|), span O(lg |t|)
   38|       |        /// APAS: Work O(1) expected, Span O(1).
   38|       |    /// APAS: Work O((n + m) lg n), Span O((n + m) lg n)
   38|       |        /// APAS: Work O(|V|² log |V|), Span O(|V| log |V|)
   38|       |        /// APAS: Work Θ(1), Span Θ(1)
   38|       |        /// APAS: Work Θ(1), Span Θ(1)
   38|       |        /// APAS: Work Θ(1), Span Θ(1)
   38|       |        /// APAS: Work Θ(1), Span Θ(1)
   38|       |        /// APAS: Work Θ(1), Span Θ(1)
   38|       |        /// APAS: Work Θ(1), Span Θ(1)
   38|       |    /// APAS: Work Θ(1), Span Θ(1)
   38|       |        /// APAS: Work Θ(|R|), Span Θ(1)
   38|       |    /// APAS: Work Θ(|V| + |E|), Span Θ(|V| + |E|)
  398|       |        // APAS - work O(lg |t|), span O(lg |t|)
   39|       |        /// APAS: Work O(|V| + |E|), Span O(lg² |V|)
   39|       |        /// APAS: Work Θ(1) expected, Θ(n) worst case, Span Θ(1)
   39|       |        /// APAS: Work Θ(1), Span Θ(1)
   39|       |        /// APAS: Work Θ(1), Span Θ(1)
   39|       |        /// APAS: Work Θ(1), Span Θ(1)
   39|       |        /// APAS: Work Θ(1), Span Θ(1)
   39|       |        /// APAS: Work Θ(1), Span Θ(1)
   39|       |        /// APAS: Work Θ(1), Span Θ(1)
   39|       |    /// APAS: Work: Θ(|a|·|b|), Span: Θ(lg |a|)
   39|       |        /// APAS: Work Θ(n), Span Θ(n)
  402|       |        // APAS - work O(lg (|t_1| + |t_2|)), span O(lg (|t_1| + |t_2|))
  406|       |        // APAS - work O(m · lg (n / m)), span O(lg n)
   40|       |        /// APAS: Work O(1), Span O(1)
   40|       |        /// APAS: Work O(m), Span O(1)
   40|       |    /// APAS: Work O((n+m) lg n), Span O((n+m) lg n)
   40|       |        /// APAS: Work O(|V|² log |V|), Span O(|V|² log |V|)
   40|       |        /// APAS: Work Θ(1 + |a| + |b|), Span Θ(1)
   40|       |        /// APAS: Work Θ(1 + |a| + |b|), Span Θ(1)
   40|       |        /// APAS: Work Θ(1) expected, Θ(n) worst case, Span Θ(1)
   40|       |        /// APAS: Work Θ(1), Span Θ(1)
   40|       |        /// APAS: Work Θ(|a| × |b|), Span Θ(1)
   40|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   40|       |        /// APAS: Work Θ(|E|), Span Θ(1)
   40|       |        /// APAS: Work Θ(n²), Span Θ(n²) - dominated by worst implementation
   40|       |        /// APAS: Work Θ(start+length), Span Θ(start+length)
  410|       |        // APAS - work O(m · lg (n / m)), span O(lg n)
  414|       |        // APAS - work O(m · lg (n / m)), span O(lg n)
  418|       |        // APAS - work O(|t|), span O(lg |t|)
   41|       |        /// APAS: Work Θ(1), Span Θ(1)
   41|       |        /// APAS: Work Θ(1), Span Θ(1)
   41|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   41|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   41|       |        /// APAS: Work Θ(|a| * W(f)), Span Θ(lg |a| + S(f))
   41|       |        /// APAS: Work Θ(|E|), Span Θ(1)
   41|       |        /// APAS: Work Θ(|E|), Span Θ(1)
   41|       |        /// APAS: Work Θ(|m|), Span Θ(1)
   41|       |        /// APAS: Work Θ(n), Span Θ(n)
  422|       |        // APAS - work O(|t|), span O(lg |t|)
   42|       |    /// **APAS Analysis:** Work O(mn log n), Span O(m log n), Parallelism Θ(n)
   42|       |    /// **APAS Analysis:** Work O(mn log n), Span O(m log n), Parallelism Θ(n)
   42|       |        /// APAS: Work O(m log n), Span O(log² n)
   42|       |    /// APAS: Work O((n + m) lg n), Span O(lg² n)
   42|       |        /// APAS: Work Θ(1), Span Θ(1)
   42|       |        /// APAS: Work Θ(1), Span Θ(1)
   42|       |        /// APAS: Work Θ(n), Span Θ(n)
   42|       |    /// APAS: Work Θ(|V| + |E|), Span Θ(log |V| + log |E|)
  431|       |        // APAS - work O(|t|), span O(|t|)
   43|       |        /// APAS: Work O(1), Span O(1)
   43|       |        /// APAS: Work Θ(1), Span Θ(1)
   43|       |        /// APAS: Work Θ(1), Span Θ(1)
   43|       |        /// APAS: Work Θ(n), Span Θ(n)
   44|       |        /// APAS: Work Θ(1), Span Θ(1)
   44|       |        /// APAS: Work Θ(1), Span Θ(1)
   44|       |        /// APAS: Work Θ(1), Span Θ(1)
   44|       |        /// APAS: Work Θ(1), Span Θ(1).
   44|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   44|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   44|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   44|       |        /// APAS: Work Θ(|E|), Span Θ(1)
   44|       |        /// APAS: Work Θ(|E|), Span Θ(1)
   44|       |        /// APAS: Work Θ(|E|), Span Θ(1)
   44|       |        /// APAS: Work Θ(|u_set| × |A|), Span Θ(1)
   44|       |        /// APAS: Work Θ(|u_set| × |E|), Span Θ(1)
   45|       |        /// APAS: Work Θ(1), Span Θ(1)
   45|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   45|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   45|       |        /// APAS: Work Θ(|a| * W(f)), Span Θ(lg |a| + S(f))
   45|       |        /// APAS: Work Θ(|E|), Span Θ(1)
   45|       |        /// APAS: Work Θ(|E|), Span Θ(1)
   45|       |        /// APAS: Work Θ(n), Span Θ(n)
   45|       |        /// APAS: Work Θ(n), Span Θ(n)
   46|       |        /// APAS: Work O(lg |t|), Span O(lg |t|)
   46|       |        /// APAS: Work O(m), Span O(m) where m is initial size.
   46|       |    /// APAS: Work O((n+m) lg n), Span O((n+m) lg n)
   46|       |    /// APAS: Work Θ(1), Span Θ(1)
   46|       |        /// APAS: Work Θ(1 + Σ i=0..|a|-1 W(f(a[i]))), Span Θ(1 + max i S(f(a[i])))
   46|       |        /// APAS: Work Θ(1 + Σ i=0..|a|-1 W(f(a[i]))), Span Θ(1 + max i S(f(a[i])))
   46|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   46|       |        /// APAS: Work Θ(|a|), Span Θ(|a|)
   46|       |        /// APAS: Work Θ(|E|), Span Θ(1)
   46|       |    /// APAS: Work Θ(n log n), Span Θ(n log n)
   46|       |        /// APAS: Work Θ(|V| + |E|), Span Θ(1)
   46|       |        /// APAS: Work Θ(|V| + |E|), Span Θ(1)
   47|       |    /// APAS: Work O((n+m) lg n), Span O(lg² n)
   47|       |    /// APAS: Work O(n), Span O(n)
   47|       |        /// APAS: Work Θ(1), Span Θ(1)
   47|       |        /// APAS: Work Θ(1), Span Θ(1).
   47|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   47|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   47|       |        /// APAS: Work Θ(|E|), Span Θ(1)
   47|       |        /// APAS: Work Θ(|u_set| × |A|), Span Θ(1)
   47|       |        /// APAS: Work Θ(|u_set| × |E|), Span Θ(1)
   48|       |    /// APAS: Work O(m lg n), Span O(m lg n)
   48|       |        /// APAS: Work Θ(1), Span Θ(1)
   48|       |        /// APAS: Work Θ(1), Span Θ(1)
   48|       |        /// APAS: Work Θ(1), Span Θ(1)
   48|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   48|       |        /// APAS: Work Θ(|E|), Span Θ(1)
   49|       |        /// APAS: Work O(1) expected, Span O(1).
   49|       |        /// APAS: Work O(lg |t|), Span O(lg |t|)
   49|       |        /// APAS: Work O(m), Span O(1)
   49|       |        /// APAS: Work Θ(1), Span Θ(1).
   49|       |        /// APAS: Work Θ(|a|+|b|), Span Θ(|a|+|b|)
   49|       |    /// APAS: Work: Θ(|a|·|b|), Span: Θ(lg |a|)
   49|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   49|       |        /// APAS: Work Θ(|E|), Span Θ(1)
   49|       |        /// APAS: Work Θ(m * lg(1 + n/m)), Span Θ(lg(n + m))
   50|       |        /// APAS: Work Θ(1), Span Θ(1)
   50|       |        /// APAS: Work Θ(1), Span Θ(1)
   50|       |        /// APAS: Work Θ(1), Span Θ(1)
   50|       |        /// APAS: Work Θ(1), Span Θ(1).
   50|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   50|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   50|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   50|       |        /// APAS: Work Θ(|E|), Span Θ(1)
   51|       |        /// APAS: Work O(1), Span O(1).
   51|       |    /// APAS: Work Θ(1), Span Θ(1)
   51|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   51|       |        /// APAS: Work Θ(|E|), Span Θ(1)
   51|       |        /// APAS: Work Θ(lg(n)), Span Θ(lg(n)).
   51|       |        /// APAS: Work Θ(|v|), Span Θ(1)
   52|       |        // APAS - work O(lg |t|), span O(lg |t|)
   52|       |    /// APAS: Work O(n), Span O(n)
   52|       |        /// APAS: Work Θ(|a|), Span Θ(lg |a|)
   52|       |        /// APAS: Work Θ(index), Span Θ(index)
   52|       |        /// APAS: Work Θ(length), Span Θ(1)
   53|       |    /// APAS: Work O(m), Span O(m)
   53|       |    /// APAS: Work Θ(1), Span Θ(1)
   53|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   53|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   53|       |        /// APAS: Work Θ(|E|), Span Θ(1)
   53|       |        /// APAS: Work Θ(|E|), Span Θ(1)
   53|       |        /// APAS: Work Θ(lg(n)), Span Θ(lg(n)).
   53|       |        /// APAS: Work Θ(m * lg(1 + n/m)), Span Θ(lg(n + m))
   53|       |    /// APAS: Work Θ(n log n), Span Θ(n log n)
   53|       |        /// APAS: Work Θ(|u_set| × |A|), Span Θ(1)
   54|       |        /// APAS: Work Θ(1), Span Θ(1)
   54|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   55|       |        /// APAS: Work O(1) expected, Span O(1).
   55|       |        // APAS - work O(lg |t|), span O(lg |t|)
   55|       |        /// APAS: Work Θ(1), Span Θ(1).
   55|       |        /// APAS: Work Θ(1), Span Θ(1).
   55|       |        /// APAS: Work Θ(|a|), Span Θ(|a|)
   55|       |        /// APAS: Work Θ(|a|), Span Θ(lg |a|)
   56|       |        /// APAS: Work amortized Θ(1), worst case Θ(n), Span amortized Θ(1), worst case Θ(n)
   56|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   56|       |        /// APAS: Work Θ(|E|), Span Θ(1)
   56|       |        /// APAS: Work Θ(|u_set| × |A|), Span Θ(1)
   56|       |        /// APAS: Work Θ(|u_set| × |A|), Span Θ(1)
   56|       |        /// APAS: Work Θ(W_action), Span Θ(S_action)
   57|       |        /// APAS: Work Θ(1), Span Θ(1).
   57|       |        /// APAS: Work Θ(m * lg(1 + n/m)), Span Θ(lg(n + m))
   58|       |        // APAS - work O(lg (|t_1| + |t_2|)), span O(lg (|t_1| + |t_2|))
   58|       |        /// APAS: Work Θ(|a|), Span Θ(|a|)
   59|       |        /// APAS: Work O(1) expected, Span O(1).
   59|       |        /// APAS: Work Θ(1), Span Θ(1)
   59|       |        /// APAS: Work Θ(1), Span Θ(1).
   59|       |        /// APAS: Work Θ(1), Span Θ(1).
   59|       |        /// APAS: Work Θ(|u_set| × |A|), Span Θ(1)
   60|       |        /// APAS: Work O(1) expected, Span O(1).
   60|       |        /// APAS: Work Θ(1), Span Θ(1)
   60|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   60|       |        /// APAS: Work Θ(|E|), Span Θ(1)
   60|       |    /// APAS: Work Θ(n log n), Span Θ(n log n)
   61|       |        // APAS - work O(m · lg (n / m)), span O(lg n)
   61|       |    /// APAS: Work O(m), Span O(log m)
   61|       |        /// APAS: Work Θ(1 + lg(|a|)), Span Θ(1 + lg(|a|)).
   61|       |        /// APAS: Work Θ(1), Span Θ(1)
   61|       |    /// APAS: Work Θ(1), Span Θ(1)
   61|       |    /// APAS: Work Θ(1), Span Θ(1)
   61|       |        /// APAS: Work Θ(|a|+|updates|), Span Θ(|a|+|updates|)
   61|       |        /// APAS: Work Θ(lg |a|), Span Θ(lg |a|)
   62|       |        /// APAS: Work Θ(1), Span Θ(1)
   62|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   63|       |        /// APAS: Work Θ(1), Span Θ(1)
   63|       |        /// APAS: Work Θ(1), Span Θ(1)
   63|       |        /// APAS: Work Θ(lg(n)), Span Θ(lg(n)).
   63|       |        /// APAS: Work Θ(n log n), Span Θ(log² n)
   64|       |        /// APAS: Work O(1) expected, Span O(1).
   64|       |        // APAS - work O(m · lg (n / m)), span O(lg n)
   64|       |        /// APAS: Work Θ(1), Span Θ(1)
   64|       |        /// APAS: Work Θ(1), Span Θ(1)
   64|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   64|       |        /// APAS: Work Θ(|a|+|updates|), Span Θ(|a|+|updates|)
   64|       |        /// APAS: Work Θ(|E|), Span Θ(1)
   64|       |        /// APAS: Work Θ(n log n), Span Θ(log² n)
   65|       |        // APAS - work O(1), span O(1)
   65|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   65|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   65|       |        /// APAS: Work Θ(|base| + |updates|), Span Θ(|base| + |updates|)
   65|       |        /// APAS: Work Θ(lg |a|), Span Θ(lg |a|)
   66|       |    /// APAS: Work Θ(|E| × avg_degree), Span Θ(|E| × avg_degree)
   67|       |        // APAS - work O(m · lg (n / m)), span O(lg n)
   67|       |        /// APAS: Work Θ(|a|), Span Θ(|a|)
   67|       |        /// APAS: Work Θ(lg(n)), Span Θ(lg(n)).
   67|       |    /// APAS: Work Θ(n log n), Span Θ(n log n)
   68|       |        /// APAS: Work O(1) expected, Span O(1).
   68|       |        /// APAS: Work O(1) expected, Span O(1).
   68|       |        /// APAS: Work Θ(1), Span Θ(1)
   68|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   68|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   68|       |        /// APAS: Work Θ(lg |a|), Span Θ(lg |a|)
   69|       |        /// APAS: Work Θ(1) expected, Θ(n) worst case, Span Θ(1)
   69|       |        /// APAS: Work Θ(1), Span Θ(1)
   69|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   70|       |        // APAS - work O(|t|), span O(lg |t|)
   70|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   70|       |        /// APAS: Work Θ(|a|), Span Θ(|a|)
   70|       |        /// APAS: Work Θ(|E|), Span Θ(1)
   70|       |        /// APAS: Work Θ(n), Span Θ(log n)
   71|       |    /// APAS: Work O(m lg n), Span O(m lg n)
   71|       |        /// APAS: Work Θ(1), Span Θ(1).
   71|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   71|       |        /// APAS: Work Θ(|E|), Span Θ(1)
   71|       |        /// APAS: Work Θ(m * lg(1 + n/m)), Span Θ(lg(n + m))
   71|       |        /// APAS: Work Θ(n), Span Θ(log n)
   72|       |        /// APAS: Work Θ(|a|), Span Θ(1)
   73|       |        // APAS - work O(|t|), span O(lg |t|)
   74|       |        /// APAS: Work Θ(1), Span Θ(1)
   74|       |    /// APAS: Work Θ(1), Span Θ(1)
   74|       |        /// APAS: Work Θ(m * lg(1 + n/m)), Span Θ(lg(n + m))
   75|       |        // APAS - work O(1), span O(1)
   75|       |        /// APAS: Work O(1), Span O(1).
   75|       |        /// APAS: Work Θ(1), Span Θ(1).
   76|       |    /// APAS: Work O((n+m) lg n), Span O((n+m) lg n)
   76|       |        // APAS - work O(|t|), span O(|t|)
   76|       |        /// APAS: Work Θ(|a|), Span Θ(1)
   77|       |    /// APAS: Work O(m), Span O(m)
   77|       |    /// APAS: Work O((n+m) lg n), Span O(lg² n)
   77|       |        /// APAS: Work O(α(n)), Span O(α(n)) amortized (inverse Ackermann)
   77|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   77|       |        /// APAS: Work Θ(|a|), Span Θ(|a|)
   77|       |        /// APAS: Work Θ(|a|), Span Θ(lg |a|)
   77|       |        /// APAS: Work Θ(|E|), Span Θ(1)
   79|       |        /// APAS: Work Θ(1), Span Θ(1)
   79|       |        /// APAS: Work Θ(n), Span Θ(1)
    7|       |        /// APAS: Work O(n²), Span O(n log n)
   80|       |        /// APAS: Work Θ(1 + lg(|a|)), Span Θ(1 + lg(|a|)).
   80|       |        /// APAS: Work Θ(|a|²), Span Θ(|a|²)
   80|       |        /// APAS: Work Θ(|a|), Span Θ(1)
   80|       |    /// APAS: Work Θ(t × i), Span Θ(i)
   81|       |    /// APAS: Work Θ(1), Span Θ(1)
   82|       |        // APAS - work O(1), span O(1)
   82|       |    /// APAS: Work O(m), Span O(lg m)
   82|       |        /// APAS: Work Θ(1), Span Θ(1)
   82|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   83|       |        /// APAS: Work Θ(Σ|ss[i]|), Span Θ(Σ|ss[i]|)
   84|       |        // APAS - work O(lg (|left| + |right|)), span O(lg (|left| + |right|))
   84|       |        /// APAS: Work Θ(1), Span Θ(1)
   85|       |        /// APAS: Work Θ(1), Span Θ(1)
   86|       |        /// APAS: Work Θ(|a|²), Span Θ(|a|²)
   88|       |        /// APAS: Work Θ(1), Span Θ(1)
   88|       |        /// APAS: Work Θ(|A|), Span Θ(1)
   88|       |        /// APAS: Work Θ(|E|), Span Θ(1)
   88|       |    /// APAS: Work Θ(n²), Span Θ(n²) - dominated by worst implementation
   89|       |        /// APAS: Work Θ(1), Span Θ(1)
   91|       |        /// APAS: Work Θ(1), Span Θ(1)
   92|       |        // APAS - work O(1), span O(1)
   93|       |        /// APAS: Work Θ(1) expected, Θ(n) worst case, Span Θ(1)
   94|       |    /// APAS: Work O(|MST|), Span O(|MST|)
   94|       |        /// APAS: Work Θ(n), Span Θ(1)
   94|       |        /// APAS: Work Θ(n), Span Θ(n)
   95|       |    /// APAS: Work Θ(n²), Span Θ(n²) - dominated by worst implementation
   96|       |        /// APAS: Work Θ(n), Span Θ(1)
   97|       |        /// APAS: Work Θ(|a|), Span Θ(1)
   99|       |        /// APAS: Work Θ(1), Span Θ(1)
    9|       |        /// APAS: Work Θ(1) expected, Θ(n) worst case, Span Θ(1)
   11|       |//! use apas_ai::Chap06::LabDirGraphStEph::LabDirGraphStEph::LabDirGraphStEphTrait;
   11|       |//! use apas_ai::Chap06::LabUnDirGraphStEph::LabUnDirGraphStEph::LabUnDirGraphStEphTrait;
   10|       |//! use apas_ai::Chap06::WeightedDirGraphStEphFloat::WeightedDirGraphStEphFloat::*;
   10|       |//! use apas_ai::Chap06::WeightedUnDirGraphStEphFloat::WeightedUnDirGraphStEphFloat::*;
   12|       |//! use apas_ai::WeightedDirGraphStEphFloatLit;
   12|       |//! use apas_ai::WeightedUnDirGraphStEphFloatLit;
  105|       |        fn append(a: &ArraySeqStPerS<T>, b: &ArraySeqStPerS<T>) -> ArraySeqStPerS<T>;
  122|    180|        fn append(a: &ArraySeqStPerS<T>, b: &ArraySeqStPerS<T>) -> ArraySeqStPerS<T> {
  129|      8|        fn append(a: &ArraySeqStEphS<T>, b: &ArraySeqStEphS<T>) -> ArraySeqStEphS<T> {
  130|       |        fn append(a: &ArraySeqMtEphS<T>, b: &ArraySeqMtEphS<T>) -> ArraySeqMtEphS<T>;
  131|      2|        fn append(a: &ArraySeqMtEphS<T>, b: &ArraySeqMtEphS<T>) -> ArraySeqMtEphS<T> {
  141|       |        fn append(a: &ArraySeqStEphS<T>, b: &ArraySeqStEphS<T>) -> ArraySeqStEphS<T>;
  142|    107|        fn append(a: &ArraySeqMtPerS<T>, b: &ArraySeqMtPerS<T>) -> ArraySeqMtPerS<T> {
  148|       |        fn append(a: &ArraySeqMtPerS<T>, b: &ArraySeqMtPerS<T>) -> ArraySeqMtPerS<T>;
  165|  63.0k|        fn append(a: &ArraySeqStPerS<T>, b: &ArraySeqStPerS<T>) -> ArraySeqStPerS<T> {
  210|    130|        fn append(a: &ArraySeqStEphS<T>, b: &ArraySeqStEphS<T>) -> ArraySeqStEphS<T> {
  212|       |        fn append(a: &Self, b: &Self) -> Self;
  218|      1|        fn append(a: &ArraySeqS<T>, b: &ArraySeqS<T>) -> ArraySeqS<T> {
  237|  2.00k|        fn append(a: &ArraySeqMtEphS<T>, b: &ArraySeqMtEphS<T>) -> ArraySeqMtEphS<T> {
  240|    150|        fn append(a: &ArraySeqMtPerS<T>, b: &ArraySeqMtPerS<T>) -> ArraySeqMtPerS<T> {
  241|      1|        fn append(a: &Self, b: &Self) -> Self {
  259|      4|        fn append(a: &LinkedListStPerS<T>, b: &LinkedListStPerS<T>) -> LinkedListStPerS<T> {
  289|      3|        fn append(a: &Self, b: &Self) -> Self {
   38|       |        fn append(a: &ArraySeqMtPerS<T>, b: &ArraySeqMtPerS<T>) -> ArraySeqMtPerS<T>;
   39|       |        fn append(a: &ArraySeqStEphS<T>, b: &ArraySeqStEphS<T>) -> ArraySeqStEphS<T>;
   39|       |        fn append(a: &ArraySeqStPerS<T>, b: &ArraySeqStPerS<T>) -> ArraySeqStPerS<T>;
   40|       |        fn append(a: &ArraySeqMtEphS<T>, b: &ArraySeqMtEphS<T>) -> ArraySeqMtEphS<T>;
   51|       |        fn append(a: &LinkedListStPerS<T>, b: &LinkedListStPerS<T>) -> LinkedListStPerS<T>;
   60|       |        fn append(a: &ArraySeqS<T>, b: &ArraySeqS<T>) -> ArraySeqS<T>;
   65|       |        fn append(a: &Self, b: &Self) -> Self;
  131|      1|        fn append_select(a: &ArraySeqStPerS<T>, b: &ArraySeqStPerS<T>) -> ArraySeqStPerS<T> {
  150|      1|        fn append_select(a: &ArraySeqStEphS<T>, b: &ArraySeqStEphS<T>) -> ArraySeqStEphS<T> {
  152|      1|        fn append_select(a: &ArraySeqMtEphS<T>, b: &ArraySeqMtEphS<T>) -> ArraySeqMtEphS<T> {
  247|      1|        fn append_select(a: &Self, b: &Self) -> Self {
  287|      2|        fn append_select(a: &ArraySeqMtPerS<T>, b: &ArraySeqMtPerS<T>) -> ArraySeqMtPerS<T> {
   42|       |        fn append_select(a: &ArraySeqMtEphS<T>, b: &ArraySeqMtEphS<T>) -> ArraySeqMtEphS<T>;
   42|       |        fn append_select(a: &ArraySeqStEphS<T>, b: &ArraySeqStEphS<T>) -> ArraySeqStEphS<T>;
   42|       |        fn append_select(a: &ArraySeqStPerS<T>, b: &ArraySeqStPerS<T>) -> ArraySeqStPerS<T>;
   66|       |        fn append_select(a: &Self, b: &Self) -> Self;
   76|       |        fn append_select(a: &ArraySeqMtPerS<T>, b: &ArraySeqMtPerS<T>) -> ArraySeqMtPerS<T>;
  341|      8|                if applied.insert(idx) {
  242|       |            // Apply each update
  221|      1|- Use appropriate load factor thresholds
  195|       |    /// Approximate Metric TSP (Parallel version)
  215|       |    /// Approximate Metric TSP
   39|       |        fn approx_metric_tsp_mt<V: StT + MtT + Hash + Ord + 'static>(
   41|       |        fn approx_metric_tsp<V: StT + Hash + Ord>(
  105|       |        /// Arc count (alias for edge count in undirected graphs)
  139|       |        /// Arc count (alias for edge count in undirected graphs)
  189|       |        /// Arc count (alias for edge count in undirected graphs)
  190|       |        /// Arc count (alias for edge count in undirected graphs)
    5|       |//! Labeled arc filtering (out_neighbors, in_neighbors) are parallel.
    5|       |//! Weighted arc filtering (out_neighbors_weighted, in_neighbors_weighted) is parallel.
    5|       |//! Weighted arc filtering (out_neighbors_weighted, in_neighbors_weighted) is parallel.
  106|     43|        edges: Arc<ArraySeqStEphS<Edge<V>>>,
  171|     17|                inner: Arc::clone(&self.inner),
  371|      9|                inner: Arc::clone(&self.inner),
   92|     25|                inner: Arc::clone(&self.inner),
   19|       |            f: Arc<F>,
   19|       |            f: Arc<F>,
   27|     22|            f: Arc<F>,
   27|     30|            f: Arc<F>,
  108|    112|        partition_map: Arc<HashMap<V, V>>,
  137|     99|        partition_map: Arc<HashMap<V, V>>,
  166|    120|        bridges: Arc<HashMap<V, (V, OrderedFloat<f64>, usize)>>,
  167|    120|        coin_flips: Arc<HashMap<V, bool>>,
  274|    122|        partition: Arc<HashMap<V, V>>,
   33|       |        inner: Arc<Inner<T>>,
   20|       |        inner: Arc<Mutex<AVLTreeSetStEph<T>>>,
   17|       |        memo: Arc<Mutex<HashMap<(usize, i32), bool>>>,
   18|       |        memo: Arc<Mutex<HashMap<(usize, i32), bool>>>,
   18|       |        memo: Arc<Mutex<HashMap<(usize, usize), usize>>>,
   19|       |        memo: Arc<Mutex<HashMap<(usize, usize), usize>>>,
   23|       |        memo: Arc<Mutex<HashMap<(usize, usize), usize>>>,
   23|       |        memo: Arc<Mutex<HashMap<(usize, usize), usize>>>,
   24|       |        memo: Arc<Mutex<HashMap<(usize, usize), Probability>>>,
   24|       |        memo: Arc<Mutex<HashMap<(usize, usize), Probability>>>,
   35|       |        memo_table: Arc<Mutex<HashMap<(usize, usize), usize>>>,
   35|       |        memo_table: Arc<Mutex<HashMap<(usize, usize), usize>>>,
   23|       |        keys: Arc<Mutex<Vec<KeyProb<T>>>>,
   22|       |        dimensions: Arc<Mutex<Vec<MatrixDim>>>,
  128|     21|            table: &Arc<Mutex<Vec<Vec<usize>>>>,
  128|     21|            table: &Arc<Mutex<Vec<Vec<usize>>>>,
  138|      1|                dimensions: Arc::new(dimensions),
  153|     17|                dimensions: Arc::new(dimensions),
   80|    107|                inner: Arc::new(Inner::new(data)),
  147|     12|                keys: Arc::new(key_probs),
  154|      1|                keys: Arc::new(key_probs),
   63|     48|                inner: Arc::new(Mutex::new(AVLTreeSetStEph::empty())),
   75|    122|                inner: Arc::new(Mutex::new(AVLTreeSetStEph::from_seq(seq))),
   69|     26|                inner: Arc::new(Mutex::new(AVLTreeSetStEph::singleton(x))),
  148|      1|                dimensions: Arc::new(Mutex::new(dimensions)),
  163|     19|                dimensions: Arc::new(Mutex::new(dimensions)),
  101|      1|                memo: Arc::new(Mutex::new(HashMap::new())),
  108|      1|                memo: Arc::new(Mutex::new(HashMap::new())),
  108|      5|                memo: Arc::new(Mutex::new(HashMap::new())),
  111|      1|                memo: Arc::new(Mutex::new(HashMap::new())),
  116|      6|                memo: Arc::new(Mutex::new(HashMap::new())),
  118|      7|                memo: Arc::new(Mutex::new(HashMap::new())),
  124|      1|                memo: Arc::new(Mutex::new(HashMap::new())),
  132|     27|                memo: Arc::new(Mutex::new(HashMap::new())),
  132|      2|                memo: Arc::new(Mutex::new(HashMap::new())),
  135|      1|                memo: Arc::new(Mutex::new(HashMap::new())),
  139|      1|                memo: Arc::new(Mutex::new(HashMap::new())),
  142|      2|                memo: Arc::new(Mutex::new(HashMap::new())),
  147|      2|                memo: Arc::new(Mutex::new(HashMap::new())),
  148|     12|                memo: Arc::new(Mutex::new(HashMap::new())),
  149|      1|                memo: Arc::new(Mutex::new(HashMap::new())),
  154|     17|                memo: Arc::new(Mutex::new(HashMap::new())),
  155|      1|                memo: Arc::new(Mutex::new(HashMap::new())),
  160|     22|                memo: Arc::new(Mutex::new(HashMap::new())),
  164|     19|                memo: Arc::new(Mutex::new(HashMap::new())),
  167|      1|                memo: Arc::new(Mutex::new(HashMap::new())),
  221|      1|                memo_table: Arc::new(Mutex::new(HashMap::new())),
   44|     16|                memo_table: Arc::new(Mutex::new(HashMap::new())),
   44|     16|                memo_table: Arc::new(Mutex::new(HashMap::new())),
  256|     11|                inner: Arc::new(Mutex::new((*inner).clone())),
  159|     22|                keys: Arc::new(Mutex::new(key_probs)),
  166|      1|                keys: Arc::new(Mutex::new(key_probs)),
  171|      0|                memo_table: Arc::new(Mutex::new(memo)),
  141|      2|                dimensions: Arc::new(Mutex::new(Vec::new())),
  146|      2|                keys: Arc::new(Mutex::new(Vec::new())),
   46|     17|                inner: Arc::new(OrderedTableStPer::empty()),
   52|      1|                inner: Arc::new(OrderedTableStPer::singleton(k, v)),
  153|    134|                root: Arc::new(RwLock::new(None)),
  184|    144|                root: Arc::new(RwLock::new(None)),
  188|    135|                root: Arc::new(RwLock::new(None)),
  208|    145|                root: Arc::new(RwLock::new(None)),
  244|    410|                root: Arc::new(RwLock::new(None)),
   28|    608|                left: Arc::new(RwLock::new(None)),
  288|  4.12k|                root: Arc::new(RwLock::new(None)),
   29|    608|                right: Arc::new(RwLock::new(None)),
  344|    541|                root: Arc::new(RwLock::new(None)),
   75|    153|                root: Arc::new(RwLock::new(None)),
  100|  7.83k|                        root: Arc::new(RwLock::new(Some(Box::new(NodeInner { key, size, left, right })))),
   54|  1.11k|            root: Arc::new(RwLock::new(Some(Box::new(NodeInner {
   66|      2|                inner: Arc::new((*self.inner).delete(k)),
   80|      1|                inner: Arc::new((*self.inner).filter(f)),
   60|     91|                inner: Arc::new((*self.inner).insert(k, v)),
   74|      2|                inner: Arc::new((*self.inner).map(f)),
  131|      2|                dimensions: Arc::new(Vec::new()),
  134|      1|                keys: Arc::new(Vec::new()),
   17|       |        inner: Arc<OrderedTableStPer<K, V>>,
  379|      2|            if Arc::ptr_eq(&self.inner, &other.inner) && self.range == other.range {
   35|       |        root: Arc<RwLock<Link<T>>>,
   37|       |        root: Arc<RwLock<Link<T>>>,
   37|       |        root: Arc<RwLock<Link<T>>>,
   37|       |        root: Arc<RwLock<Link<T>>>,
   43|       |        root: Arc<RwLock<Link<T>>>,
   27|       |        root: Arc<RwLock<Option<Box<NodeInner<T>>>>>,
   30|       |        root: Arc<RwLock<Option<Box<NodeInner<T>>>>>,
  138|      0|                        s.insert((arcs[0].0.clone_mt(), arcs[0].2));
  148|      0|                        s.insert((arcs[0].0.clone_mt(), arcs[0].2));
   86|      0|                        s.insert((arcs[0].1.clone_mt(), arcs[0].2));
   93|      0|                        s.insert((arcs[0].1.clone_mt(), arcs[0].2));
  108|       |        /// Arcs (alias for edges in undirected graphs)
  113|    135|            let arcs: Vec<LabEdge<V, L>> = self.labeled_arcs.iter().cloned().collect();
  116|      2|            let arcs: Vec<LabEdge<V, i32>> = self.labeled_arcs().iter().cloned().collect();
  123|      1|            let arcs: Vec<LabEdge<V, OrderedF64>> = self.labeled_arcs().iter().cloned().collect();
  142|       |        /// Arcs (alias for edges in undirected graphs)
  147|  26.3k|            let arcs: Vec<Edge<V>> = self.A.iter().cloned().collect();
  165|     68|            let arcs: Vec<LabEdge<V, L>> = self.labeled_arcs.iter().cloned().collect();
  186|       |            let arcs = $crate::SetLit![ $( ($from, $to, OrderedFloat($weight as f64)) ),* ];
  187|       |            $crate::Chap06::WeightedDirGraphStEphFloat::WeightedDirGraphStEphFloat::WeightedDirGraphStEphFloat::from_weighted_edges(vertices, arcs)
  191|       |            let arcs = $crate::SetLit![ $( ($from, $to, OrderedFloat($weight as f64)) ),* ];
  192|       |            $crate::Chap06::WeightedDirGraphMtEphFloat::WeightedDirGraphMtEphFloat::WeightedDirGraphMtEphFloat::from_weighted_edges(vertices, arcs)
  192|       |        /// Arcs (alias for edges in undirected graphs)
  193|       |        /// Arcs (alias for edges in undirected graphs)
  197|  31.7k|            let arcs: Vec<Edge<V>> = self.A.iter().cloned().collect();
   64|     31|            let arcs: Vec<LabEdge<V, i32>> = self.labeled_arcs().iter().cloned().collect();
   68|     56|            let arcs: Vec<LabEdge<V, OrderedF64>> = self.labeled_arcs().iter().cloned().collect();
   31|       |        fn arcs(&self) -> &Set<Edge<V>>;
   34|       |        fn arcs(&self) -> &Set<Edge<V>>;
   34|       |        fn arcs(&self) -> Set<Edge<V>>;
   38|       |        fn arcs(&self) -> Set<Edge<V>>;
   71|      5|        fn arcs(&self) -> Set<Edge<V>> {
   77|      4|        fn arcs(&self) -> Set<Edge<V>> {
   82|      4|        fn arcs(&self) -> &Set<Edge<V>> { &self.A }
   85|      4|        fn arcs(&self) -> &Set<Edge<V>> { &self.A }
  107|     43|        vertex_map: Arc<std::collections::HashMap<V, V>>,
  210|      0|            match Arc::try_unwrap(self.dimensions) {
  264|      0|            match Arc::try_unwrap(self.dimensions) {
  209|      0|            match Arc::try_unwrap(self.keys) {
  265|      1|            match Arc::try_unwrap(self.keys) {
   23|       |        keys: Arc<Vec<KeyProb<T>>>,
  273|    122|        edges: Arc<Vec<LabeledEdge<V>>>,
   72|    122|        edges: Arc<Vec<LabeledEdge<V>>>,
   22|       |        dimensions: Arc<Vec<MatrixDim>>,
  165|    120|        vertices: Arc<Vec<V>>,
   13|       |        /// are given a cost specification for insert: for a sequence of length n the cost of insert
   89|       |    impl<T, Args, Output> MtFn<Args, Output> for T where T: Fn(Args) -> Output + Send + Sync + 'static {}
   94|       |    impl<T, Args, Output> MtFnClone<Args, Output> for T where T: Fn(Args) -> Output + Send + Sync + Clone + 'static {}
  105|       |    /// Arguments:
  105|       |    /// Arguments:
  107|       |        /// Arguments:
  127|       |    /// Arguments:
  133|       |    /// Arguments:
  139|       |        /// Arguments:
  155|       |    /// Arguments:
  164|       |    /// Arguments:
  200|       |    /// Arguments:
  216|       |    /// Arguments:
  220|       |    /// Arguments:
  226|       |    /// Arguments:
  317|       |    /// Arguments:
   35|       |    /// Arguments:
   35|       |    /// Arguments:
   36|       |    /// Arguments:
   37|       |    /// Arguments:
   38|       |    /// Arguments:
   41|       |    /// Arguments:
   41|       |    /// Arguments:
   43|       |    /// Arguments:
   45|       |    /// Arguments:
   49|       |    /// Arguments:
   50|       |    /// Arguments:
   50|       |    /// Arguments:
   50|       |    /// Arguments:
   51|       |    /// Arguments:
   55|       |    /// Arguments:
   56|       |    /// Arguments:
   64|       |        /// Arguments:
   64|       |    /// Arguments:
   69|       |    /// Arguments:
   74|       |    /// Arguments:
   79|       |    /// Arguments:
   80|       |        /// Arguments:
   80|       |    /// Arguments:
  112|       |    // Arithmetic operations
  119|       |    // ArithmeticT: Type supporting arithmetic operations (for reductions)
  122|       |    impl<T> ArithmeticT for T where T: StT + std::ops::Add<Output = T> + Default + Copy {}
   53|       |    impl<T: ArithmeticT> ReduceOp<T, T> for SumOp<T> {
  320|       |    macro_rules! ArrayMtPerSLit {
  179|     96|            let array_seq = self.base_table.collect();
  192|    116|            let array_seq = self.base_table.collect();
  204|     59|            let array_seq = ArraySeqStPerS::tabulate(&|i| seq.nth(i).clone(), seq.length());
  209|      8|            let array_seq = ArraySeqStPerS::tabulate(&|i| seq.nth(i).clone(), seq.length());
  221|    149|            let array_seq = self.base_table.collect();
  226|     59|            let array_seq = ArraySeqStPerS::tabulate(&|i| seq.nth(i).clone(), seq.length());
  234|     10|            let array_seq = ArraySeqStPerS::tabulate(&|i| seq.nth(i).clone(), seq.length());
    4|       |pub mod ArraySeq {
    4|       |pub mod ArraySeqMtEph {
    6|       |pub mod ArraySeqMtEph {
  168|      1|            write!(f, "ArraySeqMtEphS[")?;
  126|     21|            seq_s: &ArraySeqMtEphS<char>,
  127|     21|            seq_t: &ArraySeqMtEphS<char>,
   31|       |        seq_s: ArraySeqMtEphS<char>,
   31|       |        seq_s: ArraySeqMtEphS<char>,
   33|       |        seq_t: ArraySeqMtEphS<char>,
   33|       |        seq_t: ArraySeqMtEphS<char>,
   34|      1|                return ArraySeqMtEphS::empty();
   67|    107|                entries: ArraySeqMtEphS::empty(),
  170|      5|                entries: ArraySeqMtEphS::from_vec(entries),
  665|     39|            entries: ArraySeqMtEphS::from_vec(entries),
  296|      0|                return ArraySeqMtEphS::from_vec(vec![]);
  212|      0|                return ArraySeqMtEphS::from_vec(Vec::new());
  216|  2.00k|                return ArraySeqMtEphS::from_vec(vec![val]);
  315|      2|                    groups.push(Pair(key.clone(), ArraySeqMtEphS::from_vec(vec![value])));
    9|       |pub mod ArraySeqMtEphSlice {
  427|       |    macro_rules! ArraySeqMtEphSliceSLit {
  314|      0|                return (<ArraySeqMtEphSliceS<T> as ArraySeqMtEphSliceTrait<T>>::empty(), id);
  187|      1|                return ArraySeqMtEphSliceS::<U>::from_vec(Vec::new());
  378|       |    macro_rules! ArraySeqMtEphSLit {
  110|      1|                multiset: ArraySeqMtEphS::new(0, T::default()),
  122|      1|                source: ArraySeqMtEphS::new(0, T::default()),
  123|      1|                target: ArraySeqMtEphS::new(0, T::default()),
   17|       |        entries: ArraySeqMtEphS<Pair<K, V>>,
   39|      6|                return ArraySeqMtEphS::singleton(id.clone());
   74|      4|                entries: ArraySeqMtEphS::singleton(Pair(key, value)),
  104|      2|            a: &ArraySeqMtEphS<T>,
  120|       |            a: &ArraySeqMtEphS<T>,
  135|      0|                return <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::empty();
  155|      4|                &|i| <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::select(a, b, i).unwrap(),
  172|      0|                return <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::empty();
   17|       |        multiset: ArraySeqMtEphS<T>,
   17|       |        source: ArraySeqMtEphS<T>,
   18|       |            a: &ArraySeqMtEphS<T>,
   18|       |            a: &ArraySeqMtEphS<T>,
   18|       |        target: ArraySeqMtEphS<T>,
  198|      0|                return <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::empty();
  204|  3.99k|            a: &ArraySeqMtEphS<T>,
  260|      0|                return (<ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::empty(), id);
   26|     22|            a: &ArraySeqMtEphS<T>,
   26|     30|            a: &ArraySeqMtEphS<T>,
   34|       |            a: &ArraySeqMtEphS<T>,
   94|      1|                return <ArraySeqMtEphS<T> as ArraySeqMtEphTraitChap18<T>>::empty();
   28|      2|            return ArraySeqMtEphS::tabulate(&|_| UNREACHABLE, n);
    9|       |        ArraySeqMtEphS, ArraySeqMtEphTrait as ArraySeqMtEphTraitImported,
    4|       |pub mod ArraySeqMtPer {
    6|       |pub mod ArraySeqMtPer {
  102|      2|            write!(f, "ArraySeqMtPerS[")?;
  327|       |    macro_rules! ArraySeqMtPerS {
   46|     16|                        return ArraySeqMtPerS::append(left, right);
   48|     15|                        return ArraySeqMtPerS::append(right, left);
  126|     21|            seq_s: &ArraySeqMtPerS<char>,
  127|     21|            seq_t: &ArraySeqMtPerS<char>,
   31|       |        seq_s: ArraySeqMtPerS<char>,
   31|       |        seq_s: ArraySeqMtPerS<char>,
   33|       |        seq_t: ArraySeqMtPerS<char>,
   33|       |        seq_t: ArraySeqMtPerS<char>,
   33|     14|                return ArraySeqMtPerS::empty();
  129|    108|                return ArraySeqMtPerS::from_vec(values);
  354|      0|                return ArraySeqMtPerS::from_vec(vec![]);
  222|      1|                return ArraySeqMtPerS::from_vec(Vec::new());
  226|      5|                return ArraySeqMtPerS::from_vec(vec![result]);
  370|      4|                    groups.push(Pair(key.clone(), ArraySeqMtPerS::from_vec(vec![value.clone()])));
  100|      1|                multiset: ArraySeqMtPerS::new(0, T::default()),
  106|      1|                source: ArraySeqMtPerS::new(0, T::default()),
  107|      1|                target: ArraySeqMtPerS::new(0, T::default()),
  271|      1|            _changes: &ArraySeqMtPerS<Pair<N, T>>,
   70|       |            changes: &ArraySeqMtPerS<Pair<N, T>>,
  119|    213|            a: &ArraySeqMtPerS<T>,
  141|       |            a: &ArraySeqMtPerS<T>,
  154|      0|                return <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::empty();
  164|       |            a: &ArraySeqMtPerS<T>,
   16|       |        multiset: ArraySeqMtPerS<T>,
   16|       |        source: ArraySeqMtPerS<T>,
   17|       |        target: ArraySeqMtPerS<T>,
  204|      0|            a: &ArraySeqMtPerS<T>,
  215|     10|            a: &ArraySeqMtPerS<T>,
  292|      1|            a: &ArraySeqMtPerS<T>,
   32|       |            a: &ArraySeqMtPerS<T>,
   49|       |            a: &ArraySeqMtPerS<T>,
   28|      2|            return ArraySeqMtPerS::tabulate(&|_| UNREACHABLE, n);
   52|      0|                return ArraySeqMtPerS::tabulate(
  372|       |    macro_rules! ArraySeqS {
  154|      0|                return ArraySeqS::from_vec(Vec::new());
  221|      0|                return ArraySeqS::from_vec(Vec::new());
  385|      0|    fn _arrayseqs_macro_type_checks() {
  280|      1|            pairs: &ArraySeqS<Pair<K, V>>,
   89|       |            pairs: &ArraySeqS<Pair<K, V>>,
  119|      0|                return <ArraySeqS<T> as ArraySeq<T>>::empty();
    4|       |pub mod ArraySeqStEph {
    4|       |pub mod ArraySeqStEph {
  307|       |    macro_rules! ArraySeqStEphS {
   11|       |        matrix: ArraySeqStEphS<ArraySeqStEphS<bool>>,
  103|      1|        weights: &ArraySeqStEphS<ArraySeqStEphS<i64>>,
   39|       |            weights: &ArraySeqStEphS<ArraySeqStEphS<i64>>,
   11|       |        adj: ArraySeqStEphS<ArraySeqStEphS<N>>,
   33|     15|        graph: &ArraySeqStEphS<ArraySeqStEphS<N>>,
   36|     19|        graph: &ArraySeqStEphS<ArraySeqStEphS<N>>,
   52|     19|        graph: &ArraySeqStEphS<ArraySeqStEphS<N>>,
   61|     27|        graph: &ArraySeqStEphS<ArraySeqStEphS<N>>,
   82|      0|        graph: &ArraySeqStEphS<ArraySeqStEphS<N>>,
   97|     30|        graph: &ArraySeqStEphS<ArraySeqStEphS<N>>,
  131|      1|        weights: &ArraySeqStEphS<ArraySeqStEphS<OrderedF64>>,
   31|       |            weights: &ArraySeqStEphS<ArraySeqStEphS<OrderedF64>>,
   47|       |            weights: &ArraySeqStEphS<ArraySeqStEphS<OrderedF64>>,
   77|      2|        weights: &ArraySeqStEphS<ArraySeqStEphS<OrderedF64>>,
   99|      4|        coins: &ArraySeqStEphS<B>,
   29|       |        seq_s: ArraySeqStEphS<char>,
   29|       |        seq_s: ArraySeqStEphS<char>,
   31|       |        seq_t: ArraySeqStEphS<char>,
   31|       |        seq_t: ArraySeqStEphS<char>,
  107|    112|        edges: &ArraySeqStEphS<Edge<V>>,
  136|     99|        edges: &ArraySeqStEphS<Edge<V>>,
   73|      4|        edges: &ArraySeqStEphS<Edge<V>>,
   98|      4|        edges: &ArraySeqStEphS<Edge<V>>,
  105|      0|            return (ArraySeqStEphS::empty(), ArraySeqStEphS::empty());
  105|      0|            return (ArraySeqStEphS::empty(), ArraySeqStEphS::empty());
  142|      0|            return ArraySeqStEphS::empty();
  151|     29|                return ArraySeqStEphS::empty();
   22|      1|                return ArraySeqStEphS::empty();
   50|    117|                elements: ArraySeqStEphS::empty(),
   64|    116|                entries: ArraySeqStEphS::empty(),
   78|      0|                return ArraySeqStEphS::empty();
   80|      0|            return ArraySeqStEphS::empty();
   89|      1|                return ArraySeqStEphS::empty();
   43|      9|                adj: ArraySeqStEphS::from_vec(adj_lists),
   93|     20|        ArraySeqStEphS::tabulate(&|i| ArraySeqStEphS::from_vec(adj_vecs[i].clone()), n)
  292|     24|            entries: ArraySeqStEphS::from_vec(entries),
   97|      5|                entries: ArraySeqStEphS::from_vec(entries),
   44|     10|                matrix: ArraySeqStEphS::from_vec(matrix_rows),
  128|      1|                matrix: ArraySeqStEphS::from_vec(new_matrix_vec),
  112|    118|                elements: ArraySeqStEphS::from_vec(result),
  149|      9|                return ArraySeqStEphS::from_vec(std::vec![edge.clone()]);
  102|      1|        distances: &ArraySeqStEphS<i64>,
  134|      5|        potentials: &ArraySeqStEphS<i64>,
  184|      5|        potentials: &ArraySeqStEphS<i64>,
   38|       |            distances: &ArraySeqStEphS<i64>,
   93|     25|        potentials: &ArraySeqStEphS<i64>,
  253|       |    macro_rules! ArraySeqStEphSLit {
  314|      0|    fn _arrayseqstephs_macro_type_checks() {
  101|      1|                source: ArraySeqStEphS::new(0, T::default()),
  102|      1|                target: ArraySeqStEphS::new(0, T::default()),
   91|      1|                multiset: ArraySeqStEphS::new(0, T::default()),
  119|      5|        potentials: &ArraySeqStEphS<OrderedF64>,
  130|      1|        distances: &ArraySeqStEphS<OrderedF64>,
  187|     10|        potentials: &ArraySeqStEphS<OrderedF64>,
   46|       |            distances: &ArraySeqStEphS<OrderedF64>,
   93|     46|        potentials: &ArraySeqStEphS<OrderedF64>,
   14|       |        entries: ArraySeqStEphS<Pair<K, V>>,
  163|       |            pairs: &ArraySeqStEphS<Pair<K, V>>,
  255|      3|            pairs: &ArraySeqStEphS<Pair<K, V>>,
   27|      6|                return ArraySeqStEphS::singleton(id.clone());
   71|      4|                entries: ArraySeqStEphS::singleton(Pair(key, value)),
   56|    112|                elements: ArraySeqStEphS::singleton(x),
  101|     25|                return <ArraySeqStEphS<T> as ArraySeqStEphTraitChap18<T>>::empty();
   11|       |        elements: ArraySeqStEphS<T>,
  133|      0|                return <ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::empty();
  153|      4|                &|i| <ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::select(a, b, i).unwrap(),
   15|       |        multiset: ArraySeqStEphS<T>,
   15|       |        source: ArraySeqStEphS<T>,
   16|       |        target: ArraySeqStEphS<T>,
  203|      0|                return (<ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::empty(), id);
  212|      0|            &|_| ArraySeqStEphS::tabulate(&|_| OrderedF64::from(f64::INFINITY), n),
   27|      2|            return ArraySeqStEphS::tabulate(&|_| UNREACHABLE, n);
    4|       |pub mod ArraySeqStPer {
    4|       |pub mod ArraySeqStPer {
  299|       |    macro_rules! ArraySeqStPerS {
  131|      8|                elements: ArraySeqStPerS::append(&self.elements, &other.elements),
   89|    437|                elements: ArraySeqStPerS::append(&self.elements, &single_seq),
   12|       |        matrix: ArraySeqStPerS<ArraySeqStPerS<bool>>,
  102|      1|        weights: &ArraySeqStPerS<ArraySeqStPerS<i64>>,
   38|       |            weights: &ArraySeqStPerS<ArraySeqStPerS<i64>>,
   12|       |        adj: ArraySeqStPerS<ArraySeqStPerS<N>>,
   29|     15|        graph: &ArraySeqStPerS<ArraySeqStPerS<N>>,
   37|     19|        graph: &ArraySeqStPerS<ArraySeqStPerS<N>>,
   59|     27|        graph: &ArraySeqStPerS<ArraySeqStPerS<N>>,
   60|     19|        graph: &ArraySeqStPerS<ArraySeqStPerS<N>>,
   97|      0|        graph: &ArraySeqStPerS<ArraySeqStPerS<N>>,
   99|     30|        graph: &ArraySeqStPerS<ArraySeqStPerS<N>>,
  130|      1|        weights: &ArraySeqStPerS<ArraySeqStPerS<OrderedF64>>,
   30|       |            weights: &ArraySeqStPerS<ArraySeqStPerS<OrderedF64>>,
   46|       |            weights: &ArraySeqStPerS<ArraySeqStPerS<OrderedF64>>,
   76|      1|        weights: &ArraySeqStPerS<ArraySeqStPerS<OrderedF64>>,
   13|       |        buckets: ArraySeqStPerS<ArraySeqStPerS<Pair<K, V>>>,
   19|       |        buckets: ArraySeqStPerS<ArraySeqStPerS<Pair<K, V>>>,
   29|       |        seq_s: ArraySeqStPerS<char>,
   29|       |        seq_s: ArraySeqStPerS<char>,
   31|       |        seq_t: ArraySeqStPerS<char>,
   31|       |        seq_t: ArraySeqStPerS<char>,
  178|    243|                elements: ArraySeqStPerS::empty(),
   28|      1|                return ArraySeqStPerS::empty();
   56|     42|                elements: ArraySeqStPerS::empty(),
   56|     49|                elements: ArraySeqStPerS::empty(),
   84|      0|                return ArraySeqStPerS::empty();
   86|    184|                entries: ArraySeqStPerS::empty(),
   41|       |        table: ArraySeqStPerS<Entry<K, V>>,
   45|      9|                adj: ArraySeqStPerS::from_vec(adj_lists),
   95|     20|        ArraySeqStPerS::tabulate(&|i| ArraySeqStPerS::from_vec(adj_vecs[i].clone()), n)
  190|      6|                entries: ArraySeqStPerS::from_vec(all_entries),
  328|     27|            entries: ArraySeqStPerS::from_vec(entries),
   46|      8|                matrix: ArraySeqStPerS::from_vec(matrix_rows),
  114|     11|                adj: ArraySeqStPerS::from_vec(new_adj_vec),
  142|      1|                adj: ArraySeqStPerS::from_vec(new_adj_vec),
  136|     11|                matrix: ArraySeqStPerS::from_vec(new_matrix_vec),
  158|      1|                matrix: ArraySeqStPerS::from_vec(new_matrix_vec),
  159|     10|                entries: ArraySeqStPerS::from_vec(result_entries),
  224|     16|                entries: ArraySeqStPerS::from_vec(result_entries),
  225|      0|                return ArraySeqStPerS::from_vec(vec![]);
   23|      0|            return ArraySeqStPerS::from_vec(Vec::new());
   23|      0|            return ArraySeqStPerS::from_vec(Vec::new());
   23|      3|            return ArraySeqStPerS::from_vec(Vec::new());
   24|      0|            return ArraySeqStPerS::from_vec(Vec::new());
   24|      1|            return ArraySeqStPerS::from_vec(Vec::new());
   25|      2|            return ArraySeqStPerS::from_vec(Vec::new());
  241|      6|                    groups.push(Pair(key.clone(), ArraySeqStPerS::from_vec(vec![value.clone()])));
  101|      1|        distances: &ArraySeqStPerS<i64>,
   37|       |            distances: &ArraySeqStPerS<i64>,
  233|       |    macro_rules! ArraySeqStPerSLit {
   13|       |            a: &ArraySeqStPerS<N>,
   20|       |            a: &ArraySeqStPerS<N>,
   32|      0|        a: &ArraySeqStPerS<N>,
   51|      0|        a: &ArraySeqStPerS<N>,
   82|      1|                multiset: ArraySeqStPerS::new(0, T::default()),
   86|      1|                source: ArraySeqStPerS::new(0, T::default()),
   87|      1|                target: ArraySeqStPerS::new(0, T::default()),
  129|      1|        distances: &ArraySeqStPerS<OrderedF64>,
   45|       |            distances: &ArraySeqStPerS<OrderedF64>,
  124|       |            a: &ArraySeqStPerS<Pair<K, V>>,
   14|       |        entries: ArraySeqStPerS<Pair<K, V>>,
  221|      3|            a: &ArraySeqStPerS<Pair<K, V>>,
  185|     96|                elements: ArraySeqStPerS::singleton(element),
   63|      3|                elements: ArraySeqStPerS::singleton(element),
   63|      5|                elements: ArraySeqStPerS::singleton(element),
   92|      5|                entries: ArraySeqStPerS::singleton(Pair(key, value)),
   14|       |            b: &ArraySeqStPerS<&'static str>,
   21|       |            b: &ArraySeqStPerS<&'static str>,
   33|      0|        b: &ArraySeqStPerS<&'static str>,
   52|      0|        b: &ArraySeqStPerS<&'static str>,
   13|       |        elements: ArraySeqStPerS<T>,
   13|       |        elements: ArraySeqStPerS<T>,
   13|       |        elements: ArraySeqStPerS<T>,
   15|       |        multiset: ArraySeqStPerS<T>,
   15|       |        source: ArraySeqStPerS<T>,
   16|       |        target: ArraySeqStPerS<T>,
   27|      2|            return ArraySeqStPerS::tabulate(&|_| UNREACHABLE, n);
   53|     52|                &|i| ArraySeqStPerS::tabulate(&|j| if i == j { 0 } else { UNREACHABLE }, n),
   55|     52|                &|i| ArraySeqStPerS::tabulate(&|j| if i == j { OrderedFloat(0.0) } else { UNREACHABLE }, n),
   75|      5|                distances: ArraySeqStPerS::update(&self.distances, v, dist),
   78|      5|                distances: ArraySeqStPerS::update(&self.distances, v, dist),
   79|      5|                distances: ArraySeqStPerS::update(&self.distances, u, updated_row),
   81|      5|                distances: ArraySeqStPerS::update(&self.distances, u, updated_row),
  100|      5|                predecessors: ArraySeqStPerS::update(&self.predecessors, v, pred),
  102|      5|                predecessors: ArraySeqStPerS::update(&self.predecessors, u, updated_row),
  104|      5|                predecessors: ArraySeqStPerS::update(&self.predecessors, u, updated_row),
   97|      5|                predecessors: ArraySeqStPerS::update(&self.predecessors, v, pred),
  100|      1|        path: &ArraySeqStPerS<usize>,
  101|      1|        path: &ArraySeqStPerS<usize>,
  128|      1|        path: &ArraySeqStPerS<usize>,
  129|      1|        path: &ArraySeqStPerS<usize>,
   29|       |            path: &ArraySeqStPerS<usize>,
   30|       |            path: &ArraySeqStPerS<usize>,
   36|       |            path: &ArraySeqStPerS<usize>,
   37|       |            path: &ArraySeqStPerS<usize>,
   44|       |            path: &ArraySeqStPerS<usize>,
   45|       |            path: &ArraySeqStPerS<usize>,
   75|      1|        path: &ArraySeqStPerS<usize>,
   76|      2|        path: &ArraySeqStPerS<usize>,
    7|       |pub mod ArraySetEnumMtEph {
  171|       |    macro_rules! ArraySetEnumMtEphLit {
   51|       |    impl ArraySetEnumMtEphTrait for ArraySetEnumMtEph {
    4|       |pub mod ArraySetStEph {
  149|      1|            keys: &ArraySetStEph<K>,
   45|       |            keys: &ArraySetStEph<K>,
  150|       |    macro_rules! ArraySetStEphLit {
  100|     22|        <UnDirGraphMtEph<V> as UnDirGraphMtEphTrait<V>>::FromSets(centers.clone(), quotient_edges)
  105|      0|            <ArraySeqMtPerS<T> as ArraySeqMtPerTraitChap18<T>>::subseq_copy(self, start, length)
  105|     14|        <UnDirGraphStEph<V> as UnDirGraphStEphTrait<V>>::FromSets(centers.clone(), quotient_edges)
  109|     53|            <ArraySeqStPerS<U> as ArraySeqStPerTrait<U>>::tabulate(&|i| f(a.nth(i)), a.length())
   10|       |        ArraySeqMtEphS as ArraySeqMtEphSChap18, ArraySeqMtEphTrait as ArraySeqMtEphTraitChap18,
  112|     45|            <ArraySeqStEphS<U> as ArraySeqStEphTrait<U>>::tabulate(&|i| f(a.nth(i)), a.length())
  128|    180|            <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::flatten(&sequences)
  132|      7|            <Self as ArraySeqMtEphSliceTrait<T>>::tabulate(&|_| unreachable!("empty sequence has no elements"), 0)
  133|      1|            <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::tabulate(
  134|       |                <ArraySeqStPerS<T> as IntoIterator>::IntoIter,
  135|      4|                    <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::select(a, b, i)
  135|       |                <ArraySeqStPerS<T> as IntoIterator>::IntoIter,
  139|    105|            <ArraySeqMtPerS<W> as ArraySeqMtPerTrait<W>>::append(&left_result, &right_result)
  140|      4|                total_cluster_elements as f64 / total_clusters as f64
  146|     22|                <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::singleton(x.clone())
  148|    107|            <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::flatten(&sequences)
  148|     27|                <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::empty()
  152|      1|            <ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::tabulate(
  152|       |                <ArraySeqStPerS<T> as IntoIterator>::IntoIter,
  153|       |                <ArraySeqStPerS<T> as IntoIterator>::IntoIter,
  154|      1|            <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::tabulate(
  155|     46|                <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::deflate(pred, x)
  157|      4|            <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::flatten(&deflated)
  161|     17|                <ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::singleton(x.clone())
  163|     18|                <ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::empty()
  166|       |                <ArraySeqStEphS<T> as IntoIterator>::IntoIter,
  167|       |                <ArraySeqStEphS<T> as IntoIterator>::IntoIter,
  170|     31|                <ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::deflate(pred, x)
  172|      5|            <ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::flatten(&deflated)
  175|      0|                <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::empty()
  178|      3|                (diff as f64) / (table_size as f64)
  183|      1|            <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::tabulate(
  184|       |                <ArraySeqStEphS<T> as IntoIterator>::IntoIter,
  185|       |                <ArraySeqStEphS<T> as IntoIterator>::IntoIter,
  191|      2|            <ArraySeqMtPerS<T> as ArraySeqMtPerTraitChap18<T>>::ninject(a, updates)
  194|     72|                vals.push(all[i as usize].clone());
  200|    190|            <ArraySeqStPerS<T> as ArraySeqStPerTraitChap18<T>>::flatten(s)
  203|       |                <ArraySeqStEphS<T> as IntoIterator>::IntoIter,
  204|       |                <ArraySeqStEphS<T> as IntoIterator>::IntoIter,
  205|      2|            <ArraySeqStPerS<T> as ArraySeqStPerTraitChap18<T>>::inject(a, updates)
  210|      3|            <ArraySeqStPerS<T> as ArraySeqStPerTraitChap18<T>>::ninject(a, updates)
  214|      2|                load as f64 / collision_chains as f64
  217|      7|            <ArraySeqStEphS<T> as ArraySeqStEphTraitChap18<T>>::flatten(s)
   22|      3|            <ArraySeqStPerS<ArraySeqStPerS<ArraySeqStPerS<T>>> as ArraySeqStPerTrait<
  225|     84|            <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::tabulate(
  227|    706|                num_elements as f64 / table_size as f64
  230|  1.99k|            <ArraySeqMtEphS<U> as ArraySeqMtEphTrait<U>>::append(&left_result, &right_result)
  232|      1|            <ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::tabulate(
  233|     16|            Self::height_link(&*guard) as N
  235|      0|                <Self as ArraySeqMtEphSliceTrait<T>>::empty()
  235|    106|                    <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::reduce(&left, f_clone, id_clone)
  244|      1|            <Self as ArraySeqMtEphSliceTrait<T>>::flatten(&sequences)
  249|      6|                    <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::reduce(&left, f_clone, id_clone)
  250|      1|            <Self as ArraySeqMtEphSliceTrait<T>>::tabulate(
  258|    109|            <ArraySeqMtPerS<T> as ArraySeqMtPerTraitChap18<T>>::flatten(ss)
  262|      1|            <ArraySeqMtPerS<T> as ArraySeqMtPerTraitChap18<T>>::collect(a, cmp)
  265|     16|                num_elements as f64 / table_size as f64
   26|      5|                    <ArraySeqStPerS<ArraySeqStPerS<T>> as ArraySeqStPerTrait<ArraySeqStPerS<T>>>::tabulate(
  266|    422|            <ArraySeqMtPerS<T> as ArraySeqMtPerTraitChap18<T>>::inject(values, changes)
  276|      2|            <ArraySeqMtEphS<T> as ArraySeqMtEphTraitChap18<T>>::flatten(s)
  276|      7|                total_chain_length as f64 / non_empty_buckets as f64
   28|     13|            <ArraySeqStPerS<ArraySeqStPerS<N>> as ArraySeqStPerTrait<ArraySeqStPerS<N>>>::tabulate(
  283|      0|                total_chain_length as f64 / non_empty_buckets as f64
   28|      4|        > as ArraySeqStPerTrait<
  289|      2|            <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::tabulate(
  291|      1|            <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::tabulate(
  291|      9|                    <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::select(a, b, i)
  309|      2|                ((self.elements.length() as f64).log2().floor() as N) + 1
  312|      1|                <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::singleton(x.clone())
  314|      1|                <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::empty()
   33|    890|                    <ArraySeqStPerS<N> as ArraySeqStPerTrait<N>>::tabulate(&|j0| i * (j0 + 2), len)
   35|      3|            <ArraySeqStPerS<ArraySeqStPerS<T>> as ArraySeqStPerTrait<ArraySeqStPerS<T>>>::flatten(&nested);
  358|      3|                ((self.elements.length() as f64).log2().ceil() as N).max(1)
   36|     27|            <ArraySeqStPerS<B> as ArraySeqStPerTrait<B>>::tabulate(&|i| is_divisible(n, i + 1), k);
   38|    207|        hasher.finish() as i64
   48|  1.38k|            (hasher.finish() as N) % table_size
   66|      1|            <ArraySeqMtEphS<T> as ArraySeqMtEphTraitChap18<T>>::new(length, init_value)
   71|      1|            <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::tabulate(
   72|    198|                    <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::append(&left_mid, &right)
   72|      2|            <ArraySeqStPerS<T> as ArraySeqStPerTraitChap18<T>>::new(length, init_value)
   73|      1|            <ArraySeqStEphS<T> as ArraySeqStEphTraitChap18<T>>::new(length, init_value)
   77|     28|            <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::tabulate(
   78|     19|            <ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::tabulate(
   79|      1|            <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::tabulate(&|_| item.clone(), 1)
   81|      2|                table.num_elements as f64 / table.current_size as f64
   84|      1|            <ArraySeqMtPerS<T> as ArraySeqMtPerTraitChap18<T>>::new(length, init_value)
   85|     23|            <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::tabulate(&|_| item.clone(), 1)
   85|     37|                    <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::append(&root_left, &right)
   86|     18|            <ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::tabulate(&|_| item.clone(), 1)
   89|      2|            <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::tabulate(
    8|       |        ArraySeqStEphS as ArraySeqStEphSChap18, ArraySeqStEphTrait as ArraySeqStEphTraitChap18,
    8|       |        ArraySeqStPerS as ArraySeqStPerSChap18, ArraySeqStPerTrait as ArraySeqStPerTraitChap18,
   94|      0|            <ArraySeqStPerS<T> as ArraySeqStPerTraitChap18<T>>::subseq_copy(self, start, length)
   95|     15|            <ArraySeqStEphS<T> as ArraySeqStEphTraitChap18<T>>::subseq(self, start, length)
   96|      3|        <UnDirGraphStEph<V> as UnDirGraphStEphTrait<V>>::FromSets(new_vertices, new_edges)
   97|      2|            <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::tabulate(&|_| item.clone(), 1)
   99|      3|        <UnDirGraphMtEph<V> as UnDirGraphMtEphTrait<V>>::FromSets(new_vertices, new_edges_set)
  316|       |        /// Assess performance impact based on probe counts and clustering score
  318|     51|        fn assess_performance_impact(
  134|      0|        fn as_slice(&self) -> &[T] { &self.data }
   34|       |        fn as_slice(&self) -> &[T];
   43|       |        /// Associative binary operation: f(a, b)
  264|      1|        fn as_tree(&self) -> &BSTAVLMtEph<T> { &self.tree }
  264|      1|        fn as_tree(&self) -> &BSTBBAlphaMtEph<T> { &self.tree }
  264|      1|        fn as_tree(&self) -> &BSTRBMtEph<T> { &self.tree }
  264|      1|        fn as_tree(&self) -> &BSTSplayMtEph<T> { &self.tree }
  264|      1|        fn as_tree(&self) -> &BSTTreapMtEph<T> { &self.tree }
  347|      1|        fn as_tree(&self) -> &BSTPlainMtEph<T> { &self.tree }
   59|       |        fn as_tree(&self) -> &BSTAVLMtEph<T>;
   59|       |        fn as_tree(&self) -> &BSTBBAlphaMtEph<T>;
   59|       |        fn as_tree(&self) -> &BSTPlainMtEph<T>;
   59|       |        fn as_tree(&self) -> &BSTRBMtEph<T>;
   59|       |        fn as_tree(&self) -> &BSTSplayMtEph<T>;
   59|       |        fn as_tree(&self) -> &BSTTreapMtEph<T>;
   27|      9|                        &|j| a.subseq_copy(i, j + 1),
   63|      4|                head: AtomicPtr::new(null_mut()),
   21|       |        head: AtomicPtr<Node<T>>,
   15|       |        ticket: AtomicUsize,
   16|       |        turn: AtomicUsize,
   32|      4|                ticket: AtomicUsize::new(0),
   33|      4|                turn: AtomicUsize::new(0),
  269|      1|        fn atomicWrite(
   68|       |        fn atomicWrite(
  122|      2|                // Attach u's tree under v's tree
  125|    119|                // Attach v's tree under u's tree
  126|     19|            while attempt < table.current_size {
   40|      5|            while attempt < table.current_size {
   41|     38|            while attempt < max_attempts {
   56|      1|            while attempt < table.current_size {
   57|      5|            while attempt < max_attempts {
   70|      0|            for attempt in 0..table.current_size {
   79|     19|            while attempt < table.current_size {
   89|     56|            while attempt < max_attempts {
   90|      5|            while attempt < table.current_size {
   94|      4|            while attempt < table.current_size {
   67|       |        // Augmented operations (ADT 43.3) - the key innovation
   70|       |        // Augmented operations (ADT 43.3) - the key innovation
   75|       |        // Augmented operations (ADT 43.3) - the key innovation with parallelism
    6|       |pub mod AugOrderedTableMtEph {
  418|       |    macro_rules! AugOrderedTableMtEphLit {
    4|       |pub mod AugOrderedTableStEph {
  385|       |    macro_rules! AugOrderedTableStEphLit {
    4|       |pub mod AugOrderedTableStPer {
  420|       |    macro_rules! AugOrderedTableStPerLit {
   26|       |    /// Auxiliary function that returns strengthened result.
   26|       |    /// Auxiliary function that returns strengthened result, using parallel recursion.
  168|      6|                if a.value != b.value {
  215|     66|                if a.value != b.value {
  213|     20|            let avg_chain_length = if collision_chains > 0 {
  257|       |        pub avg_chain_length: f64,
  275|      9|            let avg_chain_length = if non_empty_buckets > 0 {
  282|      0|            let avg_chain_length = if non_empty_buckets > 0 {
   28|       |        pub avg_chain_length: f64,
  139|      4|            let avg_cluster_size = if total_clusters > 0 {
   25|       |        pub avg_cluster_size: f64,
  401|      1|            let avg_count = keys.len() as f64 / table_size as f64;
    2|       |//! Implicit-order AVL tree providing O(lg(n)) nth and set by maintaining subtree sizes.
    2|       |//! Ephemeral AVL-balanced binary search tree with `find` support and public traversal helpers.
    2|       |//! Ephemeral AVL-balanced binary search tree with interior locking for multi-threaded access.
  122|    533|                let avl_seq = AVLTreeSeqStPerS::from_vec(doc_vec);
  162|     23|            let avl_seq = docs.to_seq();
    6|       |//! - `AVLTreeNode<T>` stores `value`, `height`, `left_size`, `right_size`, and children.
    5|       |//! - `AVLTreeRoot<T>` stores a balanced binary tree; in-order traversal defines the sequence order.
   10|       |pub mod AVLTreeSeq {
    4|       |pub mod AVLTreeSeqMtPer {
   57|    161|                elements: AVLTreeSeqMtPerS::empty(),
  105|    216|                elements: AVLTreeSeqMtPerS::from_vec(vals),
  123|     75|                    elements: AVLTreeSeqMtPerS::from_vec(vals),
  164|      3|                    elements: AVLTreeSeqMtPerS::from_vec(vals),
  210|    121|                    elements: AVLTreeSeqMtPerS::from_vec(vals),
   63|    271|                elements: AVLTreeSeqMtPerS::singleton(x),
   20|       |        elements: AVLTreeSeqMtPerS<T>,
    4|       |pub mod AVLTreeSeqStEph {
  325|       |    macro_rules! AVLTreeSeqStEphLit {
  171|      2|                return AVLTreeSeqStEphS::empty();
   60|  11.3k|                elements: AVLTreeSeqStEphS::empty(),
   66|  10.9k|                elements: AVLTreeSeqStEphS::singleton(x),
   13|       |        elements: AVLTreeSeqStEphS<T>,
    4|       |pub mod AVLTreeSeqStPer {
   56|     68|                elements: AVLTreeSeqStPerS::empty(),
   58|  2.75k|                elements: AVLTreeSeqStPerS::empty(),
  154|      5|                elements: AVLTreeSeqStPerS::from_vec(merged),
  115|    117|                elements: AVLTreeSeqStPerS::from_vec(values),
  203|      2|                elements: AVLTreeSeqStPerS::from_vec(values),
  245|      2|                        elements: AVLTreeSeqStPerS::from_vec(values),
   97|    376|                elements: AVLTreeSeqStPerS::from_vec(values),
  168|     26|                    elements: AVLTreeSeqStPerS::from_vec(vec_elements),
  179|  37.6k|                    elements: AVLTreeSeqStPerS::from_vec(vec_elements),
   63|      3|                elements: AVLTreeSeqStPerS::singleton(element),
   64|  1.84k|                elements: AVLTreeSeqStPerS::singleton(x),
   11|       |        elements: AVLTreeSeqStPerS<T>,
   13|       |        elements: AVLTreeSeqStPerS<T>,
    9|       |pub mod AVLTreeSetMtEph {
  290|       |    macro_rules! AVLTreeSetMtEphLit {
   90|     30|                frontier: &AVLTreeSetMtEph<Pair<Pair<P, V>, V>>,
  122|     75|                return AVLTreeSetMtPer {
  163|      3|                return AVLTreeSetMtPer {
  209|    121|                return AVLTreeSetMtPer {
    5|       |//! Uses AVLTreeSetMtPer with Arc-based backing for PARALLEL operations.
    9|       |pub mod AVLTreeSetMtPer {
   51|      7|                vertices: AVLTreeSetMtPer::empty(),
   52|      7|                edges: AVLTreeSetMtPer::empty(),
   65|      8|            self.adj.find(u).unwrap_or_else(|| AVLTreeSetMtPer::empty())
  306|       |    macro_rules! AVLTreeSetMtPerLit {
   79|     60|                frontier: &AVLTreeSetMtPer<Pair<Pair<P, V>, V>>,
   93|     60|                frontier: AVLTreeSetMtPer<Pair<Pair<P, V>, V>>,
   16|       |        edges: AVLTreeSetMtPer<Pair<V, V>>,
   15|       |        vertices: AVLTreeSetMtPer<V>,
   83|     20|            visited: AVLTreeSetMtPer<V>,
   84|     20|            frontier: AVLTreeSetMtPer<V>,
   92|     60|                visited: AVLTreeSetMtPer<V>,
    4|       |pub mod AVLTreeSetStEph {
  129|     14|                self.adj.insert(v, AVLTreeSetStEph::empty(), |_, new| new.clone());
   23|      1|            return AVLTreeSetStEph::empty();
   48|      7|                vertices: AVLTreeSetStEph::empty(),
   49|      7|                edges: AVLTreeSetStEph::empty(),
   83|     28|                base_set: AVLTreeSetStEph::empty(),
  149|      9|                base_set: AVLTreeSetStEph::from_seq(eph_seq),
  216|       |    macro_rules! AVLTreeSetStEphLit {
   72|     60|                frontier: &AVLTreeSetStEph<Pair<Pair<P, V>, V>>,
   86|     60|                frontier: AVLTreeSetStEph<Pair<Pair<P, V>, V>>,
   13|       |        edges: AVLTreeSetStEph<Pair<V, V>>,
   90|      1|                base_set: AVLTreeSetStEph::singleton(x),
   14|       |        base_set: AVLTreeSetStEph<T>,
   12|       |        vertices: AVLTreeSetStEph<V>,
   78|     20|            visited: AVLTreeSetStEph<V>,
   79|     20|            frontier: AVLTreeSetStEph<V>,
   85|     60|                visited: AVLTreeSetStEph<V>,
    4|       |pub mod AVLTreeSetStPer {
  132|     17|                new_adj.insert(v, AVLTreeSetStPer::empty())
   23|      2|            return AVLTreeSetStPer::empty();
   25|      5|        dfs_recursive(graph, AVLTreeSetStPer::empty(), source)
   49|      7|                vertices: AVLTreeSetStPer::empty(),
   50|      7|                edges: AVLTreeSetStPer::empty(),
   82|     25|                base_set: AVLTreeSetStPer::empty(),
  144|     53|                base_set: AVLTreeSetStPer::from_seq(seq),
  211|       |    macro_rules! AVLTreeSetStPerLit {
  100|     30|        visited: AVLTreeSetStPer<N>,
   30|     15|        visited: AVLTreeSetStPer<N>,
   38|     19|        visited: AVLTreeSetStPer<N>,
   39|     19|        ancestors: AVLTreeSetStPer<N>,
   60|     27|        visited: AVLTreeSetStPer<N>,
   61|     19|        visited: AVLTreeSetStPer<N>,
   62|     19|        rec_stack: AVLTreeSetStPer<N>,
   98|      0|        visited: AVLTreeSetStPer<N>,
   80|     30|                frontier: &AVLTreeSetStPer<Pair<Pair<P, V>, V>>,
   96|     30|                frontier: AVLTreeSetStPer<Pair<Pair<P, V>, V>>, // ((priority, vertex), vertex)
   14|       |        edges: AVLTreeSetStPer<Pair<V, V>>,
   89|      1|                base_set: AVLTreeSetStPer::singleton(x),
   13|       |        base_set: AVLTreeSetStPer<T>,
   13|       |        vertices: AVLTreeSetStPer<V>,
   91|     32|                visited: AVLTreeSetStPer<V>,
   92|     32|                frontier: AVLTreeSetStPer<V>,
   95|     30|                visited: AVLTreeSetStPer<V>,
  235|     10|                return <AVLTreeS<T> as AVLTreeSeq<T>>::empty();
  104|     13|            if b == 0 {
  144|      2|                .map(|(a, b)| Pair(a, b))
   15|       |        clustering_enabled: B,
  161|  20.0k|                for b in other.data.iter() {
  163|      0|                .map(|(a, b)| Pair(a, b))
  167|     29|            entries.sort_by(|a, b| a.0.cmp(&b.0));
   16|       |        clustering_enabled: B,
  173|     14|            let b = (a * 1103515245 + 12345) % self.p;
  174|     14|            UniversalIntegerHashFunction::new(a, b)
  176|      0|                .map(|(a, b)| Pair(a, b))
   17|       |        clustering_enabled: B,
   17|       |//! graph.add_weighted_edge("A", "B", OrderedFloat(3.14));
   17|       |//! graph.add_weighted_edge("A", "B", OrderedFloat(3.14));
   17|       |        prime_validation_enabled: B,
  187|     17|            all_entries.sort_by(|a, b| a.0.cmp(&b.0));
   18|       |        prime_validation_enabled: B,
  195|      0|                .map(|(a, b)| Pair(a, b))
  214|      0|                .map(|(a, b)| Pair(a, b))
  243|      0|                for b in other.data.iter() {
  246|       |    impl<A, B> From<(A, B)> for Pair<A, B> {
  250|       |    impl<A, B> From<Pair<A, B>> for (A, B) {
  251|     32|            performance_ranking.sort_by(|a, b| a.1.partial_cmp(&b.1).unwrap_or(std::cmp::Ordering::Equal));
  260|     44|                updated_entries.sort_by(|a, b| a.0.cmp(&b.0));
  269|   551k|                new_entries.sort_by(|a, b| a.0.cmp(&b.0));
  304|      7|            entries.sort_by(|a, b| a.0.cmp(&b.0));
   31|     22|            let b = ArraySeqStEphS::tabulate(
   33|    114|            let b = ArraySeqStEphS::tabulate(&|i| f(a.nth(2 * i), a.nth(2 * i + 1)), half);
  340|      9|            entries.sort_by(|a, b| a.0.cmp(&b.0));
  387|      6|            left.iter().zip(right.iter()).all(|(a, b)| a == b)
   42|    436|            if b == 0 {
   46|     22|            let b = ArraySeqMtEphS::tabulate(
   48|     15|            let b = ArraySeqMtEphS::tabulate(
  542|  2.58M|                entries_vec.sort_by(|a, b| a.0.cmp(&b.0));
   56|  10.0k|                m.insert(a, b);
  677|      7|            entries.sort_by(|a, b| a.0.cmp(&b.0));
   95|     10|            entries.sort_by(|a, b| a.0.cmp(&b.0));
   40|       |        /// Backing storage using Vec for efficient push/pop
  160|      0|        output.push_str("- Balanced tree also achieves Θ(n log n) with good constants\n");
  281|      1|            write!(f, "BalancedTreePQ[")?;
    4|       |pub mod BalancedTreePQ {
  294|       |    macro_rules! BalancedTreePQLit {
  308|      0|    fn _balanced_tree_pq_lit_type_checks() {
  150|       |        pub balanced_tree_result: Vec<T>,
  126|       |    macro_rules! BalBinNodeLit {
  103|    226|                | BalBinTree::Leaf => 0,
  106|      8|            | BalBinTree::Leaf => None,
  121|      1|            | BalBinTree::Leaf => None,
  123|     10|                | BalBinTree::Leaf => Some(&inner.value),
  131|      1|            | BalBinTree::Leaf => None,
  133|     10|                | BalBinTree::Leaf => Some(&inner.value),
   49|     24|                root: BalBinTree::leaf(),
   59|      3|                | BalBinTree::Leaf => true,
   66|    220|                | BalBinTree::Leaf => <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::empty(),
   76|    192|            | BalBinTree::Leaf => {
   79|     48|                | BalBinTree::Leaf => <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::empty(),
   91|      9|            | BalBinTree::Leaf => false,
   92|     80|                | BalBinTree::Leaf => 0,
   60|      3|                | BalBinTree::Node(_) => false,
  107|  5.11k|            | BalBinTree::Node(inner) => {
  122|     28|            | BalBinTree::Node(inner) => match &inner.left {
  132|    126|            | BalBinTree::Node(inner) => match &inner.right {
   79|  5.08k|            | BalBinTree::Node(inner) => {
   92|  5.12k|            | BalBinTree::Node(inner) => {
  104|    197|                | BalBinTree::Node(node) => 1 + node.left.size() + node.right.size(),
   67|    198|                | BalBinTree::Node(node) => {
   80|     37|                | BalBinTree::Node(node) => {
   93|     59|                | BalBinTree::Node(node) => {
    4|       |pub mod BalBinTreeStEph {
   12|       |        root: BalBinTree<T>,
  103|       |        // Base case: empty range
  103|       |        // Base case: empty range
  108|       |        // Base case: single vertex
  108|       |        // Base case: single vertex
  111|     27|            let base = self.range.start;
  118|       |            // Base case: process single edge
  119|       |            // Base case: process single edge
  121|       |            // Base cases
  123|       |            // Base cases
  146|       |            // Base case: check single edge
  148|       |            // Base case: process single edge
  152|       |        // Base: when no edges, return number of vertices
  153|      1|        let base = |vertices: &Set<V>| vertices.size();
  158|      1|        star_contract(graph, &base, &expand)
  162|       |            // Base case: sequences of length 0 or 1 are already sorted
  168|       |        // Base: when no edges, each vertex maps to itself
  169|      1|        let base = |vertices: &Set<V>| {
  169|       |        // Base case: no edges remaining
  177|       |            // Base case: check single vertex
  191|      1|        star_contract(graph, &base, &expand)
   20|       |            // Base case: empty or single element
   20|       |            // Base case: empty sequence
   20|       |        // Base set operations (ADT 41.1) - delegated
  210|       |        // Base: when no edges, return number of vertices
  211|      1|        let base = |vertices: &Set<V>| vertices.size();
   21|       |        // Base set operations (ADT 41.1) - ephemeral semantics
   21|       |        // Base set operations (ADT 41.1) - ephemeral semantics with parallelism
   21|       |        // Base table operations (ADT 42.1) - delegated
   21|       |        // Base table operations (ADT 42.1) - ephemeral semantics
  227|       |        // Base: when no edges, each vertex maps to itself
  228|      0|        let base = |vertices: &Set<V>| {
  234|       |        // Base case: no edges remaining
   23|       |            // Base case: empty sequence returns None (-∞)
   24|       |        // Base table operations (ADT 42.1) - ephemeral semantics with parallelism
   25|       |            // Base case: single element
   26|       |            // Base case: empty sequence returns None (-∞)
   30|       |        // Base case: empty sequence
   30|       |        // Base case: empty sequence
   32|       |            // Base case: empty or single element
   32|       |            // Base case: empty sequence
   32|       |            // Base case: empty sequence returns None (-∞)
   33|       |            // Base case: empty sequence returns None (-∞)
   33|       |        // Base table operations (ADT 42.1) - delegated to OrderedTableStPer
   33|       |        // Base table operations (ADT 42.1) - ephemeral semantics
   33|       |        // Base table operations (ADT 42.1) - ephemeral semantics with parallelism
  341|       |            // Base cases
   35|       |        // Base case: single element
   35|       |        // Base case: single element
   37|       |            // Base case: single element
   42|       |            // Base case for small merges
   43|       |    /// Base case: No edges means each vertex is its own component.
   44|    259|            let base = (table_size - 1) as u64;
   46|       |        // Base: no edges means no spanning tree edges
   47|      1|        let base = |_vertices: &Set<V>| SetLit![];
   49|       |        // Base: no edges means no spanning tree edges (isolated vertices)
   50|      5|        let base = |_vertices: &Set<V>| SetLit![];
   54|       |        // Base case: no edges
   55|       |        // Base case: no edges, each vertex is own component
   57|       |        // Base case: no edges, each vertex is own component
   59|       |        // Base case: no edges
   63|       |            // Base cases
   66|       |            // Base cases
   68|       |            // Base cases
   68|       |            // Base cases
   73|       |            // Base cases
   74|       |            // Base cases
   74|       |        // Base set operations - delegate to backing store
   75|       |        // Base set operations - delegate to backing store with ephemeral semantics
   81|       |            // Base case: sequences of length 0 or 1 are already sorted
   82|       |            // Base case: single edge contributes bridges for both endpoints
   82|       |        // Base table operations - delegate to backing store
   84|       |                // Base case: extract key directly
   85|       |        // Base table operations - delegate to backing store with ephemeral semantics
   86|       |        // Base case: no edges, each vertex maps to itself
   87|       |        // Base table operations - delegate to backing store with ephemeral semantics and parallelism
   91|       |        // Base case: no edges, each vertex maps to itself
   96|      5|        star_contract(graph, &base, &expand)
  172|       |        /// Based on textbook analysis: 1 + n(n+1)/2m ≈ n/4 for worst case
  210|       |        /// Based on theoretical analysis: approximately 1/(1-α) for unsuccessful search
  264|       |        /// Based on theoretical analysis for prime table sizes
   56|     11|            return base(graph.vertices());
   61|      7|            return base(graph.vertices());
  210|    417|            let base_hash = self.base_hash.hash(key, table_size);
   27|    875|            let base_hash = self.base_hash.hash(key, table_size);
  299|    450|            let base_hash = self.base_hash.hash(key, table_size);
   34|    966|            let base_hash = self.base_hash.hash(key, table_size);
   59|       |    /// Baseline Sequential Version of Parallel Matching
    6|       |//! - Baseline sequential version of parallel matching algorithm
  275|     19|                let base_score = load_factor * 100.0; // Base score from load factor
  292|     16|                let base_score = load_factor * 80.0; // Quadratic probing generally better than linear
  306|     16|                let base_score = load_factor * 60.0; // Double hashing generally best
  335|     23|            if base.size() == 0 {
  370|     21|            if base.size() == 0 {
  374|     40|            if base.size() == 0 {
  142|      1|            let base_table = OrderedTableStEph::tabulate(f, keys);
  144|      1|            let base_table = OrderedTableStPer::tabulate(f, keys);
  153|      1|            let base_table = OrderedTableMtEph::tabulate(f, keys);
   44|       |                // because scan_contract is exclusive (doesn't include the last element in each prefix)
   31|   100k|            let begin = start.min(total);
   40|    110|            let begin = start.min(total);
  303|      6|            let b_elem = b_nth(j);
  306|     12|                if b_elem == a_nth(i) {
   22|       |        /// Bellman-Ford single source shortest path algorithm
   22|       |        /// Bellman-Ford single source shortest path algorithm
    9|       |//! - Bellman-Ford: Work O(nm), Span O(n lg n) where n = |V|, m = |E|
    9|       |//! - Bellman-Ford: Work O(nm), Span O(n lg n) where n = |V|, m = |E|
   24|       |        fn bellman_ford(graph: &WeightedDirGraphStEphFloat<usize>, source: usize) -> SSSPResultStEphFloat;
   24|       |        fn bellman_ford(graph: &WeightedDirGraphStEphInt<usize>, source: usize) -> Result<SSSPResultStEphInt, String>;
   53|      5|        let bellman_ford_result = match bellman_ford(&graph_with_dummy, dummy_idx) {
   54|      5|        let bellman_ford_result = match bellman_ford(&graph_with_dummy, dummy_idx) {
   64|     10|        let bellman_ford_result = match bellman_ford(&graph_with_dummy, dummy_idx) {
   64|      5|        let bellman_ford_result = match bellman_ford(&graph_with_dummy, dummy_idx) {
   12|       |pub mod BellmanFordStEphFloat {
   12|       |pub mod BellmanFordStEphInt {
  431|      0|            writeln!(f, "Best strategy: {}", self.best_strategy)?;
  253|     14|            let best_strategy = performance_ranking[0].0.clone();
   55|       |        pub best_strategy: String,
  304|      2|             providing better distribution than linear probing."
  112|  11.0k|                let bf = Self::height_link(&node.left) - Self::height_link(&node.right);
  112|    807|                let bf = Self::height_link(&node.left) - Self::height_link(&node.right);
  113|  11.0k|                if bf > 1 {
  113|    807|                if bf > 1 {
    3|       |//! Queue-based BFS for finding distances and reachability from a source vertex.
    3|       |//! Queue-based BFS for finding distances and reachability from a source vertex.
   16|       |        fn bfs(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>, source: N) -> ArraySeqStEphS<N>;
   16|       |        fn bfs(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>, source: N) -> ArraySeqStPerS<N>;
   17|       |        fn bfs(graph: &ArraySeqMtEphS<ArraySeqMtEphS<N>>, source: N) -> ArraySeqMtEphS<N>;
   17|       |        fn bfs(graph: &ArraySeqMtPerS<ArraySeqMtPerS<N>>, source: N) -> ArraySeqMtPerS<N>;
    6|       |pub mod BFSMtEph {
    6|       |pub mod BFSMtPer {
    6|       |pub mod BFSStEph {
    6|       |pub mod BFSStPer {
   29|       |            // b[i] = f(a[2i], a[2i+1])
   31|       |            // b[i] = f(a[2i], a[2i+1])
   41|       |            // b[i] = f(a[2i], a[2i+1])
   43|       |            // b[i] = f(a[2i], a[2i+1])
  115|       |                // Binary search in left sequence
  159|      0|        output.push_str("- Binary heap and leftist heap provide optimal Θ(n log n) performance\n");
  224|       |            // Binary search since entries are sorted by key
  229|       |            // Binary search on sorted entries
  232|       |            // Binary search in sorted sequence
    2|       |//! Ephemeral binary search tree built on `BBTEph` primitives.
    2|       |//! Ephemeral binary search tree built on `BBTEph` primitives with fine-grained locking.
  393|       |            // Binary search since entries are sorted by key
   69|       |                // Binary search in right sequence
  337|      1|            write!(f, "BinaryHeapPQ[")?;
    4|       |pub mod BinaryHeapPQ {
   79|       |        // BinaryHeapPQ is a min-heap
   79|       |        // BinaryHeapPQ is a min-heap
  350|       |    macro_rules! BinaryHeapPQLit {
  364|      0|    fn _binary_heap_pq_lit_type_checks() {
  151|       |        pub binary_heap_result: Vec<T>,
  275|      5|                let b_index = index - a.length();
  276|      5|                if b_index < b.length() {
   67|     10|                if *bit {
   54|     14|                bits: bitbox![0; u],
   18|       |        bits: BitBox,     // 1 bit per element
    4|       |//! Uses `bitvec::BitBox` for true 1-bit-per-element storage (vs 1-byte-per-element in `Vec<bool>`).
   14|       |    use bitvec::prelude::*;
  126|      4|                    let (bl, _, br) = ParamBST::split_inner(b, &ak);
  160|      6|                    let (bl, _, br) = ParamTreap::split_inner(b, &ak);
  162|    254|                    let (bl, _, br) = ParamBST::split_inner(b, &ak);
  176|      6|                    let (bl, found, br) = ParamTreap::split_inner(b, &ak);
  178|    156|                    let (bl, found, br) = ParamBST::split_inner(b, &ak);
  196|      7|                    let (bl, found, br) = ParamTreap::split_inner(b, &ak);
  199|    156|                    let (bl, found, br) = ParamBST::split_inner(b, &ak);
  121|     23|            let block_u = vertex_map.get(u).unwrap().clone();
  124|     23|            if block_u != block_v {
  128|      0|                    Edge(block_v, block_u)
   82|     18|            let block_u = vertex_to_block.get(u).unwrap().clone();
   86|     18|            if block_u != block_v {
   90|      0|                    Edge(block_v, block_u)
  122|     23|            let block_v = vertex_map.get(v).unwrap().clone();
  126|     17|                    Edge(block_u, block_v)
   83|     18|            let block_v = vertex_to_block.get(v).unwrap().clone();
   88|     12|                    Edge(block_u, block_v)
   38|      0|                v.push(Pair(*a.nth(i), *b.nth(j)));
   37|       |        fn boruvka_mst_mt<V: StT + Hash + Ord + Send + Sync + 'static>(
   43|       |        fn boruvka_mst_mt_with_seed<V: StT + Hash + Ord + Send + Sync + 'static>(
   33|       |        fn boruvka_mst<V: StT + Hash + Ord>(edges: &Set<LabeledEdge<V>>) -> Set<LabeledEdge<V>>;
   37|       |        fn boruvka_mst_with_seed<V: StT + Hash + Ord>(edges: &Set<LabeledEdge<V>>, seed: u64) -> Set<LabeledEdge<V>>;
    7|       |pub mod BoruvkaMtEph {
   31|       |        /// Borůvka's MST algorithm
   35|       |        /// Borůvka's MST with random seed
    7|       |pub mod BoruvkaStEph {
  168|       |        // Both approaches should yield the same result
  219|      1|- Handle both growth and shrinkage
    7|       |pub mod BottomUpDPMtEph {
   36|       |    impl BottomUpDPMtEphS {
    7|       |pub mod BottomUpDPMtPer {
   36|       |    impl BottomUpDPMtPerS {
    7|       |pub mod BottomUpDPStEph {
   34|       |    impl BottomUpDPStEphS {
    7|       |pub mod BottomUpDPStPer {
   34|       |    impl BottomUpDPStPerS {
  120|      0|                    // Box drop handles node and value cleanup
   38|       |        fw: Box<dyn Fn(&Word) -> DocumentSet>,
   97|  7.20k|            let boxed = unsafe { Box::from_raw(node_ptr) };
   15|       |            left: Box<LeftistHeapNode<T>>,
   16|       |            right: Box<LeftistHeapNode<T>>,
   89|    724|                left: Box::new(final_left),
   90|    724|                right: Box::new(final_right),
  217|    313|                    left: Box::new(LeftistHeapNode::Leaf),
  218|    313|                    right: Box::new(LeftistHeapNode::Leaf),
   13|       |        data: Box<[T]>,
   13|       |        data: Box<[T]>,
   13|       |        data: Box<[T]>,
   17|       |        data: Box<[T]>,
  163|      6|                            ParamTreap::union_inner(&ar, &br)
  179|      6|                            ParamTreap::intersect_inner(&ar, &br)
  181|    156|                            ParamBST::intersect_inner(&ar, &br)
  199|      7|                            ParamTreap::difference_inner(&ar, &br)
  202|    156|                            ParamBST::difference_inner(&ar, &br)
  120|    675|                        let branch = if target < &node.key {
   88|  6.97k|                        let branch = if value < node.key {
   24|       |        /// Bridge-based star partition
  195|     50|        let bridges1 = bridges.clone();
  175|     25|        let bridges = vertex_bridges(edges);
  198|     50|        let bridges2 = bridges;
  242|     20|        let bridges = vertex_bridges_mt(edges_arc.clone(), 0, edges_len);
  148|     20|        let bridges_arc = Arc::new(bridges);
   70|     78|            match bridges.get(&u) {
   82|     78|            match bridges.get(&v) {
   30|       |        fn bridge_star_partition_mt<V: StT + Hash + Ord + Send + Sync + 'static>(
   26|       |        fn bridge_star_partition<V: StT + Hash + Ord>(
  187|       |        // Brute force work: O(n * m) where n is documents, m is average content length
  188|      1|        let brute_force_work = tweets.length(); // Represents O(n) complexity
  190|      1|        (indexed_work, brute_force_work)
    2|       |//! Key-Value BST (dictionary/table) with ephemeral treap structure.
    2|       |//! Size-augmented BST with O(1) size queries and rank/select operations.
    4|       |pub mod BSTAVLMtEph {
  262|       |    macro_rules! BSTAVLMtEphLit {
   65|     72|                tree: BSTAVLMtEph::new(),
   14|       |        tree: BSTAVLMtEph<T>,
    4|       |pub mod BSTAVLStEph {
  246|       |    macro_rules! BSTAVLStEphLit {
    4|       |pub mod BSTBBAlphaMtEph {
  253|       |    macro_rules! BSTBBAlphaMtEphLit {
   65|     65|                tree: BSTBBAlphaMtEph::new(),
   14|       |        tree: BSTBBAlphaMtEph<T>,
    4|       |pub mod BSTBBAlphaStEph {
  268|       |    macro_rules! BSTBBAlphaStEphLit {
    4|       |pub mod BSTKeyValueStEph {
  227|       |    macro_rules! BSTKeyValueStEphLit {
    4|       |pub mod BSTParaMtEph {
    4|       |pub mod BSTParaStEph {
    4|       |pub mod BSTParaTreapMtEph {
    4|       |pub mod BSTPlainMtEph {
  213|       |    macro_rules! BSTPlainMtEphLit {
   65|     78|                tree: BSTPlainMtEph::new(),
   14|       |        tree: BSTPlainMtEph<T>,
    4|       |pub mod BSTPlainStEph {
  140|       |    macro_rules! BSTPlainStEphLit {
    4|       |pub mod BSTRBMtEph {
  307|       |    macro_rules! BSTRBMtEphLit {
   65|     73|                tree: BSTRBMtEph::new(),
   14|       |        tree: BSTRBMtEph<T>,
    4|       |pub mod BSTRBStEph {
  270|       |    macro_rules! BSTRBStEphLit {
    4|       |pub mod BSTReducedStEph {
  278|       |        for BSTReducedStEph<K, V, R, Op>
  338|       |    macro_rules! BSTReducedStEphLit {
    4|       |pub mod BSTSetAVLMtEph {
  268|       |    macro_rules! BSTSetAVLMtEphLit {
    4|       |pub mod BSTSetBBAlphaMtEph {
  268|       |    macro_rules! BSTSetBBAlphaMtEphLit {
    4|       |pub mod BSTSetPlainMtEph {
  351|       |    macro_rules! BSTSetPlainMtEphLit {
    4|       |pub mod BSTSetRBMtEph {
  268|       |    macro_rules! BSTSetRBMtEphLit {
    4|       |pub mod BSTSetSplayMtEph {
  268|       |    macro_rules! BSTSetSplayMtEphLit {
    4|       |pub mod BSTSetTreapMtEph {
  268|       |    macro_rules! BSTSetTreapMtEphLit {
    4|       |pub mod BSTSizeStEph {
  294|       |    macro_rules! BSTSizeStEphLit {
  285|      1|                (self.clone(), BSTSizeStEph::new())
    4|       |pub mod BSTSplayMtEph {
  213|       |    macro_rules! BSTSplayMtEphLit {
   65|     65|                tree: BSTSplayMtEph::new(),
   14|       |        tree: BSTSplayMtEph<T>,
    4|       |pub mod BSTSplayStEph {
  189|       |    macro_rules! BSTSplayStEphLit {
    4|       |pub mod BSTTreapMtEph {
  246|       |    macro_rules! BSTTreapMtEphLit {
   65|     71|                tree: BSTTreapMtEph::new(),
   14|       |        tree: BSTTreapMtEph<T>,
    4|       |pub mod BSTTreapStEph {
  224|       |    macro_rules! BSTTreapStEphLit {
  105|       |        /// Bubble down element at index i to maintain heap property
  206|       |            // Bubble up from the last position
  237|       |            // Bubble down from root
   84|       |        /// Bubble up element at index i to maintain heap property
  106|    231|        fn bubble_down(&self, mut i: N, heap: &ArraySeqStPerS<T>) -> ArraySeqStPerS<T> {
   85|    487|        fn bubble_up(&self, mut i: N) -> ArraySeqStPerS<T> {
  271|      6|                .map(|Pair(key, bucket)| Pair(key, ArraySeqStEphS::from_vec(bucket)))
  294|      2|                .map(|Pair(key, bucket)| Pair(key, ArraySeqS::from_vec(bucket)))
  395|      5|                if bucket_counts[hash_value] > 1 {
  151|      0|                let bucket_to_use = if i == hash_code {
  156|      8|                let bucket_to_use = if i == hash_code {
  226|      0|                let bucket_to_use = if i == hash_code {
  227|  8.96k|                let bucket_to_use = if i == hash_code {
   71|     20|                let bucket_to_use = if i == hash_code {
   82|  2.95k|                let bucket_to_use = if i == hash_code {
    9|       |        /// BUG: claude-4-sonet's span analysis differs from APAS (APAS assumes O(log n) span insert operation)
  102|       |    /// Build new edge set in parallel using divide-and-conquer
  103|       |        // Build quotient graph in parallel
  108|       |        // Build edge index for O(1) coin lookups
  130|       |                    // Build priority set from visited vertices
  136|       |            // Build priority set from visited vertices
  151|       |        // Build persistent table
  155|       |        /// Build heap from arbitrary sequence (bottom-up heapify)
  160|       |        /// Build balanced tree from values in in-order order.
  160|       |        // Build ephemeral table
  161|       |        /// Build balanced tree from values in in-order order.
  169|       |        // Build multi-threaded table
  186|       |        // Build full partition map (including identity for non-contracted vertices)
  253|       |        // Build full partition map (including identity for non-contracted vertices)
  255|       |        /// Build heap using bottom-up heapify (more efficient than repeated insertion)
  264|       |        /// Build heap using parallel reduce with meld operations
   37|       |            // Build result using tabulate (no Vec!)
   63|       |        // Build quotient graph by routing edges through partition map
   65|       |        // Build quotient graph in parallel
   69|       |        // Build the new contracted graph
   73|       |    /// Build quotient graph from partition
   78|       |    /// Build quotient graph from partition (parallel version)
   90|       |            // Build new sequence with element inserted at correct position
   94|       |        // Build partition map Arc for sharing across threads
   98|       |        // Build quotient graph
  121|    648|    fn build_balanced_from_slice<T: StTInMtT>(a: &[T]) -> Link<T> {
  122|  39.5k|    fn build_balanced_from_slice<T: StT>(a: &[T]) -> Link<T> {
  198|    648|                root: build_balanced_from_slice(&values),
  200|  39.5k|                root: build_balanced_from_slice(&values[..]),
  121|  1.39k|        fn build_balanced(values: &[T]) -> Link<T> {
  163|    537|        fn build_balanced(values: &[T]) -> Link<T> {
  105|     43|    fn build_edges_parallel<V: StT + MtT + Hash + Ord + 'static>(
  113|      1|            let builder = QueryBuilder::new(&self.index);
  119|     23|    fn build_quotient_edges_parallel<V: StT + MtT + Hash + Ord + 'static>(
  120|     11|    fn build_quotient_edges<V: StT + Hash + Ord>(
   84|     22|    fn build_quotient_graph_parallel<V: StT + MtT + Hash + Ord + 'static>(
   79|     14|    fn build_quotient_graph<V: StT + Hash + Ord>(
   20|       |        /// Builds a sequence containing a single element
   68|       |        /// Builds a sequence containing a single element.
   66|      7|        print!("getRange(A, 'burt', 'mike') = [");
   82|       |                        // but dependencies limit effectiveness
    5|       |//! algorithm by Michael Shamos (CMU CS, 1977), using strengthening and ParaPair! with 32MB stack
    5|       |//! algorithm by Michael Shamos (CMU CS, 1977), using the strengthening technique to avoid
   62|       |    /// by flipping a coin for each edge and selecting edges where:
   36|  1.03k|                    let byte = *key_ptr.add(i);
  110|     38|            edges.iter().zip(coins.iter()).map(|(e, c)| (e.clone(), *c)).collect();
  107|     32|                AdvancedQuadraticProbingStrategy::new_with_coefficients(DefaultHashFunction, c1, c2);
   41|      5|                "QuadraticProbing({}, c1={}, c2={})",
   18|       |//! graph.add_weighted_edge("B", "C", OrderedFloat(2.71));
   18|       |//! graph.add_weighted_edge("B", "C", OrderedFloat(2.71));
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |// Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
    1|       |//! Copyright (C) 2025 Acar, Blelloch and Milnes from 'Algorithms Parallel and Sequential'.
  313|      4|                "AdvancedQuadraticProbing(c1={}, c2={}, clustering_enabled={}, prime_validation={})",
   82|      7|            if c2 == 0 {
   28|      5|        match *c {
   36|     15|            let c = Self::scan_contract(&b, f, id.clone());
   59|     15|            let c = Self::scan_contract_parallel(&b, f_solve, id);
  174|      2|- Better cache locality
  143|      1|            let cached_reduction = Self::calculate_reduction(&base_table, &reducer, &identity);
  145|      1|            let cached_reduction = Self::calculate_reduction(&base_table, &reducer, &identity);
  154|      1|            let cached_reduction = Self::calculate_reduction(&base_table, &reducer, &identity);
  117|     52|                    return cached_result;
  119|     38|                    return cached_result;
   60|      9|                return cached_result;
   63|      9|                return cached_result;
   64|      9|                    return cached_result;
   64|      9|                    return cached_result;
  151|       |            // Calculate period for double hashing
  155|       |            // Calculate probe sequence period
  207|       |        // Calculate total words across all documents
  222|       |        /// Calculate current load factor
  242|       |        /// Calculate new table size for growth
  245|       |        /// Calculate new table size for shrinkage
  266|       |        /// Calculate clustering score for linear probing
  267|       |            // Calculate total length
  284|       |        /// Calculate clustering score for quadratic probing
  302|       |        /// Calculate clustering score for double hashing
   50|       |        /// Calculate cost of multiplying matrices from i to j with split at k
   52|       |        /// Calculate cost of multiplying matrices from i to j with split at k
   61|       |        /// Calculate cost of multiplying matrices from i to j with split at k
   62|       |        /// Calculate cost of multiplying matrices from i to j with split at k
  304|     16|        fn calculate_double_hashing_score(&self, metrics: &Option<DoubleHashingMetrics>, load_factor: f64) -> f64 {
  268|     19|        fn calculate_linear_clustering_score(
  286|     16|        fn calculate_quadratic_clustering_score(
  334|     23|        fn calculate_reduction(base: &OrderedTableStEph<K, V>, reducer: &F, identity: &V) -> V {
  369|     21|        fn calculate_reduction(base: &OrderedTableStPer<K, V>, reducer: &F, identity: &V) -> V {
  373|     40|        fn calculate_reduction(base: &OrderedTableMtEph<K, V>, reducer: &F, identity: &V) -> V {
   40|    525|        let candidates: ArraySeqStPerS<N> = <ArraySeqStPerS<N> as ArraySeqStPerTrait<N>>::tabulate(&|i| i + 2, n - 1);
  133|      0|            panic!("normalize_edge cannot create LabEdge without a label - method signature needs revision")
  183|      0|            panic!("normalize_edge cannot create LabEdge without a label - method signature needs revision")
  109|       |            // Can't use tabulate with closure capture, implement directly
  255|      1|                return capacity * 2; // Simple doubling
  172|       |        /// capacity==len, else shrinks and moves elements.
   64|     15|            let c_arc = Arc::new(c);
    5|       |//! of Carnegie Mellon University CS in 1977, overnight, after hearing about the problem
    5|       |//! of Carnegie Mellon University CS in 1977. This parallel version uses ParaPair! for
   17|       |        /// Cartesian product using functional approach with tabulate + flatten
   26|       |    /// Cartesian product by explicit loops (x-major then y).
   45|       |    /// Cartesian product using map + flatten: flatten(map(\x. map(\y. (x,y)) b) a)
   19|       |        fn cartesian_functional(
   12|       |        fn cartesian_loops(
  237|      0|        fn CartesianProduct<U: StT + Hash + Clone>(&self, other: &Set<U>) -> Set<Pair<T, U>>
   42|       |        fn CartesianProduct<U: StT + Hash>(&self, other: &Set<U>) -> Set<Pair<T, U>>;
  147|       |    /// Case-insensitive string equality
  101|    222|            let center = p_seq.nth(i as N).clone();
   60|      0|                        Edge(vertex.clone(), center.clone())
   66|      9|                        Edge(vertex.clone(), center.clone())
  101|      8|        let (centers, partition_map) = parallel_star_partition(graph, seed);
   61|     14|        let (centers, partition_map) = sequential_star_partition(graph);
   61|      5|        let (centers, partition_map) = sequential_star_partition(graph);
   63|     15|        let (centers, partition_map) = parallel_star_partition(graph, seed);
   66|     22|        let (centers, partition_map) = parallel_star_partition(graph, seed);
   96|      6|        let (centers, partition_map) = sequential_star_partition(graph);
  210|  8.76k|        for ch in content_lower.chars() {
   64|  10.9k|            for ch in key.chars() {
   95|  1.81k|            for ch in key.chars() {
  110|      0|            let chain = self.buckets.nth(hash_code);
  119|     99|            let chain = self.buckets.nth(hash_code);
  130|      0|            let chain = self.buckets.nth(hash_code);
  135|      3|            let chain = self.buckets.nth(hash_code);
   14|       |        pub chain: Container,
  188|      0|                let chain = self.buckets.nth(i);
  193|    160|                let chain = self.buckets.nth(i);
  205|      0|            let chain = self.buckets.nth(hash_code);
  206|    129|            let chain = self.buckets.nth(hash_code);
  260|    112|                let chain = self.buckets.nth(i);
  267|      0|                let chain = self.buckets.nth(i);
  307|      0|                let chain = self.buckets.nth(i);
   47|      2|            let chain = self.buckets.nth(hash_code);
   58|    122|            let chain = self.buckets.nth(hash_code);
   18|       |    /// Chained Hash Table trait - extends ParaHashTableStEphTrait.
    2|       |//! LinkedList Chained Hash Table - Sequential Ephemeral (Chapter 47).
    2|       |//! Struct Chained Hash Table - Sequential Ephemeral (Chapter 47).
    2|       |//! Vec Chained Hash Table - Sequential Ephemeral (Chapter 47).
    5|       |pub mod ChainedHashTable {
  261|    112|                let chain_length = chain.length();
  263|    112|                if chain_length > 0 {
  267|     45|                    if chain_length > 1 {
  268|      0|                let chain_length = chain.length();
  270|      0|                if chain_length > 0 {
  274|      0|                    if chain_length > 1 {
  309|      0|                if chain.length() > 0 {
  102|     49|            if !changed {
   93|     57|            if !changed {
   14|       |        // Chapter 18 wrappers
   25|      1|        println!("=== Chapter 42 Example 42.1: Table Operations ===");
  311|      1|        output.push_str("=== Chapter 47 Hash Table Examples ===\n\n");
    4|       |pub mod Chapter36Mt {
    4|       |pub mod Chapter36MtSlice {
    4|       |pub mod Chapter36St {
   64|       |        // Chapter 19 specific functions
   45|      2|            ArraySeqStPerS<Pair<N, char>>,
   49|      3|                <ArraySeqStPerS<Pair<N, char>> as ArraySeqStPerTrait<Pair<N, char>>>::tabulate(
   56|      2|        <ArraySeqStPerS<Pair<N, char>> as ArraySeqStPerTrait<Pair<N, char>>>::flatten(&nested)
  103|       |                // Characters match: take diagonal value
  105|       |                // Characters match: take diagonal value
  106|       |                // Characters don't match: take minimum of insert/delete + 1
  108|       |                // Characters don't match: take minimum of insert/delete + 1
  130|       |                        // Characters match: no edit needed
  132|       |                        // Characters match: no edit needed
  133|       |                        // Characters don't match: explore branches in parallel
  135|       |                        // Characters don't match: explore branches in parallel
  138|       |                // Characters match: take diagonal value
  139|       |                // Characters match: take diagonal value
  141|       |                // Characters don't match: take minimum of insert/delete + 1
  142|       |                // Characters don't match: take minimum of insert/delete + 1
   62|       |                        // Characters match, no edit needed
   65|       |                        // Characters don't match, try both operations
   71|       |                        // Characters match, no edit needed
   72|       |                        // Characters match: no edit needed
   75|       |                        // Characters don't match: try insert, delete, or substitute
   75|       |                        // Characters match: no edit needed
   77|       |                        // Characters match, no edit needed
   77|       |                        // Characters match: no edit needed
   77|       |                        // Characters match: no edit needed
   78|       |                        // Characters don't match: try insert, delete, or substitute
   80|       |                        // Characters don't match, try both operations
   80|       |                        // Characters don't match: try insert, delete, or substitute
   80|       |                        // Characters don't match: try insert, delete, or substitute
   87|       |                        // Characters match, no edit needed
  101|       |            // Check for convergence (Line 9-10)
  102|       |            // Check both orientations since this is undirected
  102|       |        /// Check if stack is empty.
  103|       |            // Check memo first (thread-safe)
  105|       |            // Check resize
  106|       |                // Check if adjacent edge is incident on u or v
  107|       |            // Check both orientations since this is undirected
  107|       |            // Check if edge exists in tree_edges
  107|       |            // Check if we've reached |V| rounds without convergence (Line 8)
  109|       |        /// Check if subproblem is memoized
   10|       |        /// Check if a number is even
  110|       |        /// Check if a position in the table is occupied
  111|       |        // Check edge count
  111|       |            // Check if key already exists
  113|       |            // Check memo table first
  114|       |            // Check for duplicate domain elements
  115|       |        /// Check if the graph is connected (all vertices reachable from any vertex)
  115|       |            // Check memo table first
  116|       |        // Check all edges are from original graph
  116|       |            // Check if we've reached |V| rounds without convergence (Line 8)
  120|       |        /// Check if sequences are empty
  123|       |        /// Check if sequences are empty
  125|       |        /// Check if sequences are empty
  129|       |        /// Check if sequences are empty
  134|       |        /// Check if two elements are in the same set
  147|       |            // Check resize
   14|       |        /// Check if a character is a vowel (case-insensitive)
  158|       |        /// Check if sequences are empty
  159|       |        /// Check if sequences are empty
  162|       |        /// Check if leftist property is maintained
  165|       |        /// Check if all results are properly sorted
  166|       |            // Check resize down
  170|       |        /// Check if subproblem is memoized
  172|       |        /// Check if heap property is maintained
  173|       |            // Check resize down
  177|       |    /// Check if an edge should be selected
  183|       |        /// Check if subproblem is memoized
  187|       |        // Check if this edge flipped heads
  192|       |        // Check if all edges incident on u and v flipped tails (except this one)
  198|       |            // Check if adjacent edge is incident on u or v
  198|       |        /// Check if clustering is problematic for given load factor
  204|       |        /// Check if sequences are empty
  209|       |        /// Check if sequences are empty
  222|       |        /// Check if element exists in the priority queue
  222|       |                            // Check resize down
  230|       |        /// Check if double hashing configuration is optimal
  231|       |        /// Check if table should be resized up
  236|       |        /// Check if table should be resized down
   23|       |    /// Check if a number is even
  250|       |            // Check if key already exists
   26|       |    /// Check if a character is a vowel (case-insensitive)
  284|       |        /// Check if secondary clustering is problematic
  301|       |        /// Check if the heap property is maintained (for testing)
  308|       |        /// Check if the list is properly sorted (for testing)
  317|       |        /// Check if a sequence is sorted
  317|       |        /// Check if number is prime
   31|       |        /// Check if two elements are in the same set
  322|       |        /// Check if leftist property is maintained (for testing)
  336|       |    /// Check if a sequence is sorted
  339|       |        /// Check if the tree maintains sorted order (for testing)
   33|       |        /// Check if path exists
   33|       |        /// Check if stack is empty
   33|       |        /// Check if vertex is reachable
   34|       |        /// Check if path exists
   34|       |        /// Check if vertex is reachable
   35|       |        /// Check if path exists
   36|       |        /// Check if path exists
   36|       |        /// Check if vertex is reachable
   36|       |        /// Check if vertex is reachable
   40|       |        /// Check if a number is prime
   44|       |            // Check if x is NOT in composites
  469|       |            // Check if key already exists
   49|       |            // Check if key exists and remove old entry
   49|       |        /// Check if two numbers are relatively prime (gcd = 1)
   49|       |            // Check memo first
   50|       |            // Check memo first
   51|       |            // Check memo first (thread-safe)
   55|       |            // Check memo first (thread-safe)
   56|       |            // Check memo first
   58|       |            // Check memo table first
   59|       |            // Check memo first
   60|       |            // Check if key exists and remove old entry
   60|       |            // Check memo table first
   60|       |            // Check memo table first
   61|       |            // Check memo first (thread-safe)
   61|       |            // Check memo table first
   63|       |        /// Check if heap property is satisfied
   63|       |            // Check memo first
   64|       |            // Check memo first
   68|       |            // Check memo first
   71|       |            // Check memo first (thread-safe)
   74|       |                        // Check for overflow before adding
   75|       |            // Check memo first
   78|       |        /// Check if the graph is connected (all vertices reachable from any vertex)
   79|       |            // Check if u and v are in different components
   85|       |                    // Check if this original edge connects the two centers (in either direction)
   90|       |            // Check if edge already exists
   90|       |            // Check memo first (thread-safe)
   92|       |            // Check for convergence (Line 9-10)
   92|       |            // Check resize
   93|       |            // Check if this edge flipped heads
   93|       |            // Check memo first (thread-safe)
   95|       |        /// Check if subproblem is memoized
   96|       |            // Check both orientations since this is undirected
   96|       |            // Check if edge is in tree and not yet traversed
   98|       |            // Check if all edges incident on u and v flipped tails (except this one)
   99|       |            // Check memo first (thread-safe)
  101|       |    /// Checks:
  102|       |        /// Checks if vertex v is reachable from source.
  105|       |        /// Checks if vertex v is reachable from source.
  105|       |        /// Checks if vertex v is reachable from vertex u.
  107|       |        /// Checks if vertex v is reachable from vertex u.
  107|       |        /// Checks if vertex v is reachable from vertex u.
  109|       |        /// Checks if vertex v is reachable from vertex u.
   63|       |        /// Checks if the stack is empty
   95|       |        /// Checks if vertex v is reachable from source.
   97|       |        /// Checks if vertex v is reachable from source.
   69|      2|            let chess_docs = (self.fw)(&"chess".to_string());
   83|      2|            let chess_docs = (self.fw)(&"chess".to_string());
  152|     34|                    let child = node.left.clone();
  174|    190|                    let child = node.right.clone();
  211|  8.76k|            if ch.is_alphabetic() {
   66|  10.9k|                if ch.is_ascii_lowercase() {
  278|     18|                for chunk in heaps.chunks(2) {
  279|     18|                    if chunk.len() == 2 {
  110|     27|            let clamped_end = clamped_start.saturating_add(length).min(local_len);
  109|     27|            let clamped_start = start.min(local_len);
  107|     27|        fn clamp_subrange(&self, start: N, length: N) -> Range<N> {
  100|       |        /// Claude Work: O(log n), Span: O(log n)
  100|       |        /// Claude Work: O(n³) - O(n²) subproblems, each O(n) work
  100|       |        /// Claude Work: O(|S|*|T|) where |S|=source length, |T|=target length
  101|       |        /// Claude Span: O(log(|S|+|T|)) with aggressive parallelism
  101|       |        /// Claude Span: O(n log n) - maximum recursion depth O(n), each level O(log n) parallel reduction
  101|       |        /// Claude Work: O(1) - constant time lookup
  101|       |        /// Claude Work: O(log n), Span: O(log n)
  101|       |        /// Claude Work: Θ(1 + α) expected, Span: Θ(1 + α) expected
  101|       |        /// Claude Work: Θ(log n), Span: Θ(log n)
  102|       |        /// Claude Span: O(1) - constant time lookup
  102|       |        /// Claude Work: O(log min(a,b)), Span: O(log min(a,b))
  102|       |        /// Claude Work: O(|S|*|T|) where |S|=source length, |T|=target length
  103|       |        /// Claude Span: O(log(|S|+|T|)) with aggressive parallelism
  103|       |        /// Claude Work: O(1), Span: O(1)
  103|       |        /// Claude Work: O(log n), Span: O(log n)
  103|       |        /// Claude Work: O(n), Span: O(log n)
  104|       |        /// Claude Work: O(lg n), Span: O(lg n)
  104|       |        /// Claude Work: O(log n), Span: O(log n)
  104|       |        /// Claude Work: O(log n), Span: O(log n)
  104|       |        /// Claude Work: O(n), Span: O(log n)
  104|       |        /// Claude Work: Θ(min(max_probes, m)), Span: Θ(min(max_probes, m))
  105|       |        /// Claude Work: O(1) - constant time access
  106|       |        /// Claude Span: O(1) - constant time access
  106|       |        /// Claude Work: O(1) - constant time insertion
  106|       |        /// Claude Work: O(log n), Span: O(log n)
  107|       |        /// Claude Span: O(1) - constant time insertion
  107|       |        /// Claude Work: O(lg n), Span: O(lg n)
  107|       |        /// Claude Work: O(lg n), Span: O(lg n)
  107|       |        /// Claude Work: O(log n), Span: O(log n)
  107|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  109|       |        /// Claude Work: O(log n), Span: O(log n)
  109|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  109|       |        /// Claude Work: Θ(1), Span: Θ(1)
  110|       |        /// Claude Work: O(1) - constant time lookup
  110|       |        /// Claude Work: O(1) per call with memoization, O(|S|*|T|) total
  110|       |        /// Claude Work: O(1), Span: O(1)
  110|       |        /// Claude Work: O(lg n), Span: O(lg n)
  110|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  110|       |        /// Claude Work: O(n), Span: O(log n)
  111|       |        /// Claude Span: O(1) - constant time lookup
  111|       |        /// Claude Span: O(log(|S|+|T|)) - parallel recursive branches
  111|       |        /// Claude Work: O(1) - constant time access
  111|       |        /// Claude Work: O(log n), Span: O(log n)
  111|       |        /// Claude Work: Θ(1), Span: Θ(1)
  112|       |        /// Claude Span: O(1) - constant time access
  112|       |        /// Claude Work: O(1) per call with memoization, O(|S|*|T|) total
  112|       |        /// Claude Work: O(1), Span: O(1)
  113|       |        /// Claude Span: O(log(|S|+|T|)) - parallel recursive branches
  113|       |        /// Claude Work: O(1), Span: O(1)
  113|       |        /// Claude Work: O(lg n), Span: O(lg n)
  113|       |        /// Claude Work: O(log n), Span: O(log n)
  114|       |        /// Claude Work: O(1) - constant time access
  114|       |        /// Claude Work: Θ(1), Span: Θ(1)
  114|       |        /// Claude Work: Θ(1 + α) expected, Span: Θ(1 + α) expected
  115|       |        /// Claude Span: O(1) - constant time access
  115|       |        /// Claude Work: O(1) - constant time lookup
  115|       |        /// Claude Work: O(log n), Span: O(log n)
  115|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  115|       |        /// Claude Work: Θ(1), Span: Θ(1)
  115|       |    /// Claude Work: Θ(n log n), Span: Θ(n log n) - optimal complexity with superior meld
  116|       |        /// Claude Span: O(1) - constant time lookup
  116|       |        /// Claude Work: O(1) - constant time access
  116|       |        /// Claude Work: O(1) - constant time access
  116|       |        /// Claude Work: O(lg n), Span: O(lg n)
  116|       |        /// Claude Work: O(lg n), Span: O(lg n)
  116|       |        /// Claude Work: O(log n), Span: O(log n)
  117|       |        /// Claude Span: O(1) - constant time access
  117|       |        /// Claude Span: O(1) - constant time access
  117|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  118|       |        /// Claude Work: O(n), Span: O(log n)
  119|       |        /// Claude Work: O(1) - constant time access
  119|       |        /// Claude Work: O(1), Span: O(1)
  120|       |        /// Claude Span: O(1) - constant time access
  120|       |        /// Claude Work: O(1) - constant time access
  120|       |        /// Claude Work: O(log n), Span: O(log n)
  120|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  121|       |        /// Claude Span: O(1) - constant time access
  121|       |        /// Claude Work: O(1) - constant time access
  121|       |        /// Claude Work: O(1) - constant time check
  121|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  121|       |        /// Claude Work: O(n log n), Span: O(log² n)
  121|       |        /// Claude Work: Θ(1), Span: Θ(1)
  121|       |        /// Claude Work: Θ(m log(1 + n/m)), Span: Θ(log n + log m)
  122|       |        /// Claude Span: O(1) - constant time access
  122|       |        /// Claude Span: O(1) - constant time check
  122|       |        /// Claude Work: O(lg n), Span: O(lg n)
  122|       |        /// Claude Work: Θ(1 + α) expected, Span: Θ(1 + α) expected
  123|       |        /// Claude Work: O(1) - constant time per cell
  123|       |        /// Claude Work: O(1) - constant time per cell
  123|       |        /// Claude Work: O(n), Span: O(log n)
  124|       |        /// Claude Span: O(1) - constant time per cell
  124|       |        /// Claude Span: O(1) - constant time per cell
  124|       |        /// Claude Work: O(1) - constant time check
  124|       |        /// Claude Work: O(lg n), Span: O(lg n)
  124|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  124|       |        /// Claude Work: Θ(1), Span: Θ(1)
  124|       |        /// Claude Work: Θ(c), Span: Θ(c) where c is number of clusters
  125|       |        /// Claude Span: O(1) - constant time check
  125|       |        /// Claude Work: O(1) - constant time access
  126|       |        /// Claude Span: O(1) - constant time access
  126|       |        /// Claude Work: O(1) - constant time check
  126|       |        /// Claude Work: O(1) - constant time clear
  126|       |        /// Claude Work: O(n log n), Span: O(log² n)
  126|       |        /// Claude Work: O(n), Span: O(log n)
  127|       |        /// Claude Span: O(1) - constant time check
  127|       |        /// Claude Span: O(1) - constant time clear
  127|       |        /// Claude Work: O(n), Span: O(log n)
  127|       |        /// Claude Work: O(n), Span: O(log n) - Parallel domain extraction
  127|       |        /// Claude Work: Θ(m + n), Span: Θ(m + n)
  128|       |        /// Claude Work: O(n), Span: O(log n)
  128|       |        /// Claude Work: Θ(1), Span: Θ(1)
  129|       |        /// Claude Work: O(1) - constant time update
  129|       |        /// Claude Work: O(lg n), Span: O(lg n)
  129|       |        /// Claude Work: O(n log n), Span: O(log² n)
  130|       |        /// Claude Span: O(1) - constant time update
  130|       |        /// Claude Work: O(1) - constant time check
  130|       |        /// Claude Work: O(n log n), Span: O(log² n) - Parallel tabulation
  130|       |        /// Claude Work: Θ(m), Span: Θ(m) where m is table size
  131|       |        /// Claude Span: O(1) - constant time check
  131|       |        /// Claude Work: O(1) - constant time update
  131|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  131|       |        /// Claude Work: Θ(1 + α) expected, Span: Θ(1 + α) expected
  132|       |        /// Claude Span: O(1) - constant time update
  133|       |        /// Claude Work: O(n), Span: O(log n)
  133|       |        /// Claude Work: Θ(m), Span: Θ(m) where m is table size
  134|       |        /// Claude Work: O(1) - constant time update
  134|       |        /// Claude Work: O(log n), Span: O(log n)
  135|       |        /// Claude Span: O(1) - constant time update
  135|       |        /// Claude Work: O(1) - constant time clear
  135|       |        /// Claude Work: O(lg n), Span: O(lg n)
  135|       |        /// Claude Work: O(n), Span: O(log n)
  135|       |        /// Claude Work: Θ(n), Span: Θ(n)
  136|       |        /// Claude Span: O(1) - constant time clear
  136|       |        /// Claude Work: Θ(m + n), Span: Θ(m + n)
  137|       |        /// Claude Work: O(n), Span: O(lg n)
  138|       |        /// Claude Work: O(n), Span: O(log n)
  139|       |        /// Claude Work: O(1) - constant time update
  139|       |        /// Claude Work: O(n log n), Span: O(log² n)
  139|       |        /// Claude Work: O(n), Span: O(lg n)
  139|       |        /// Claude Work: Θ(1), Span: Θ(1)
  140|       |        /// Claude Span: O(1) - constant time update
  140|       |        /// Claude Work: O(n), Span: O(lg n)
  140|       |        /// Claude Work: O(n), Span: O(log n) - Parallel map
  141|       |        /// Claude Work: O(n log n), Span: O(log² n)
  141|       |        /// Claude Work: Θ(1), Span: Θ(1)
  142|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  142|       |        /// Claude Work: O(n), Span: O(lg n)
  142|       |        /// Claude Work: Θ(1), Span: Θ(1)
  143|       |        /// Claude Work: O(1), Span: O(1)
  143|       |        /// Claude Work: O(m log(1 + n/m)), Span: O(log n + log m)
  143|       |        /// Claude Work: O(n), Span: O(lg n)
  143|       |        /// Claude Work: Θ(min(max_probes, m)), Span: Θ(min(max_probes, m))
  145|       |        /// Claude Work: Θ(1), Span: Θ(1)
  146|       |        /// Claude Work: O(1), Span: O(1)
  146|       |        /// Claude Work: O(n), Span: O(lg n)
  147|       |        /// Claude Work: O(m log(1 + n/m)), Span: O(log n + log m)
  147|       |        /// Claude Work: O(n), Span: O(log n)
  149|       |        /// Claude Work: O(1) - constant time access
  149|       |        /// Claude Work: O(log n), Span: O(log n)
  149|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  150|       |        /// Claude Span: O(1) - constant time access
  150|       |        /// Claude Work: O(1) - constant time access
  150|       |        /// Claude Work: O(log n), Span: O(log n)
  151|       |        /// Claude Span: O(1) - constant time access
  151|       |        /// Claude Work: O(m log(1 + n/m)), Span: O(log n + log m)
  153|       |        /// Claude Work: O(n), Span: O(lg n)
  154|       |        /// Claude Work: O(1) - constant time access
  154|       |        /// Claude Work: Θ(m), Span: Θ(m) where m is table size
  155|       |        /// Claude Span: O(1) - constant time access
  155|       |        /// Claude Work: O(1) - constant time access
  155|       |        /// Claude Work: O(1), Span: O(1)
  155|       |        /// Claude Work: O(log n), Span: O(log n)
  155|       |        /// Claude Work: O(n), Span: O(lg n)
  156|       |        /// Claude Span: O(1) - constant time access
  156|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  157|       |        /// Claude Work: 1/(1-α) expected for unsuccessful, (1/α)ln(1/(1-α)) expected for successful
  158|       |        /// Claude Work: Θ(n log n), Span: Θ(log² n)
  159|       |        /// Claude Work: O(1) - constant time check
  159|       |        /// Claude Work: O(n), Span: O(log n)
  159|       |        /// Claude Work: O(n), Span: O(log n) - Parallel filter
  160|       |        /// Claude Span: O(1) - constant time check
  160|       |        /// Claude Work: O(1) - constant time check
  160|       |        /// Claude Work: O(log n), Span: O(log n)
  161|       |        /// Claude Span: O(1) - constant time check
  162|       |        /// Claude Work: O(n), Span: O(log n)
  163|       |        /// Claude Work: O(1) - constant time access
  163|       |        /// Claude Work: O(n), Span: O(log n)
  164|       |        /// Claude Span: O(1) - constant time access
  164|       |        /// Claude Work: O(n), Span: O(lg n)
  165|       |        /// Claude Work: O(1) - constant time update
  165|       |        /// Claude Work: O(1) - constant time update
  165|       |        /// Claude Work: O(log n), Span: O(log n)
  166|       |        /// Claude Span: O(1) - constant time update
  166|       |        /// Claude Span: O(1) - constant time update
  166|       |        /// Claude Work: O(n), Span: O(lg n)
  168|       |        /// Claude Work: O(n), Span: O(lg n)
  169|       |        /// Claude Work: O(log n), Span: O(log n)
  169|       |        /// Claude Work: Θ(1), Span: Θ(1)
   16|       |        /// Claude Work: O(1), Span: O(1)
  170|       |        /// Claude Work: O(1) - constant time update
  170|       |        /// Claude Work: O(n), Span: O(log n)
  171|       |        /// Claude Span: O(1) - constant time update
  171|       |        /// Claude Work: O(1) - constant time lookup
  171|       |        /// Claude Work: O(log n), Span: O(log n)
  172|       |        /// Claude Span: O(1) - constant time lookup
  172|       |        /// Claude Work: Θ(1), Span: Θ(1)
  172|       |        /// Claude Work: Θ(m), Span: Θ(m) where m is table size
  172|       |        /// Claude Work: Θ(n), Span: Θ(n) where n is sequence length
  173|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  173|       |        /// Claude Work: Θ(1), Span: Θ(1)
  175|       |        /// Claude Work: Θ(1), Span: Θ(1)
  175|       |        /// Claude Work: Θ(1), Span: Θ(1)
  176|       |        /// Claude Work: O(1) - constant time access
  176|       |        /// Claude Work: O(log n), Span: O(log n)
  177|       |        /// Claude Span: O(1) - constant time access
  177|       |        /// Claude Work: O(n), Span: O(lg n)
  177|       |        /// Claude Work: O(n), Span: O(log n)
  178|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  178|       |        /// Claude Work: O(n), Span: O(log n) - Parallel reduction
  178|       |        /// Claude Work: Θ(n log n), Span: Θ(n log n)
  178|       |        /// Claude Work: Θ(n), Span: Θ(n)
  179|       |        /// Claude Work: O(1) - constant time lookup
  179|       |        /// Claude Work: O(n), Span: O(lg n)
  180|       |        /// Claude Span: O(1) - constant time lookup
  181|       |        /// Claude Work: O(m + n), Span: O(log(m + n))
  181|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  182|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  182|       |        /// Claude Work: Θ(1), Span: Θ(1)
  184|       |        /// Claude Work: O(1) - constant time lookup
  184|       |        /// Claude Work: O(n), Span: O(log n)
  184|       |        /// Claude Work: Similar to lookup, Span: Similar to lookup
  184|       |        /// Claude Work: Θ(1), Span: Θ(1)
  185|       |        /// Claude Span: O(1) - constant time lookup
  185|       |        /// Claude Work: O(log n), Span: O(log n)
  185|       |        /// Claude Work: Θ(n), Span: Θ(n)
  187|       |        /// Claude Work: O(1) - constant time insertion
  187|       |        /// Claude Work: O(n), Span: O(log n)
  188|       |        /// Claude Span: O(1) - constant time insertion
  188|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  189|       |        /// Claude Work: O(log n), Span: O(log n)
  189|       |        /// Claude Work: Θ(1), Span: Θ(1)
  189|       |        /// Claude Work: Θ(1), Span: Θ(1)
   18|       |        /// Claude Work: Θ(n²), Span: Θ(n²) - inefficient due to O(n) deleteMin
  190|       |        /// Claude Work: O(log n), Span: O(log n)
  190|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  190|       |        /// Claude Work: O(n), Span: O(log n)
  191|       |        /// Claude Work: O(log n), Span: O(log n)
  192|       |        /// Claude Work: O(1) - constant time lookup
  192|       |        /// Claude Work: Θ(1), Span: Θ(1)
  193|       |        /// Claude Span: O(1) - constant time lookup
  194|       |        /// Claude Work: O(m + n), Span: O(log(m + n)) - Parallel intersection
  194|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  194|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  195|       |        /// Claude Work: O(1) - constant time access
  195|       |        /// Claude Work: Θ(1), Span: Θ(1)
  196|       |        /// Claude Span: O(1) - constant time access
  196|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  197|       |        /// Claude Work: O(log min(h2_value, table_size)), Span: O(log min(h2_value, table_size))
  199|       |        /// Claude Work: O(log n), Span: O(log n)
  199|       |        /// Claude Work: Θ(1), Span: Θ(1)
  199|       |        /// Claude Work: Θ(log n), Span: Θ(log n)
   19|       |        /// Claude Work: Θ(m), Span: Θ(m)
  200|       |        /// Claude Work: O(1) - constant time access
  200|       |        /// Claude Work: O(1) - constant time access
  200|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  201|       |        /// Claude Span: O(1) - constant time access
  201|       |        /// Claude Span: O(1) - constant time access
  201|       |        /// Claude Work: O(log n), Span: O(log n)
  202|       |        /// Claude Work: O(m + n), Span: O(log(m + n)) - Parallel union
  202|       |    /// Claude Work: O(m), Span: O(1) where m is the length of the content string
  202|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  204|       |        /// Claude Work: O(log n), Span: O(log n)
  204|       |        /// Claude Work: O(log n), Span: O(log n)
  204|       |        /// Claude Work: Θ(min(max_probes, m)), Span: Θ(min(max_probes, m))
  205|       |        /// Claude Work: O(1) - constant time access
  205|       |        /// Claude Work: O(1) - constant time check
  205|       |        /// Claude Work: Θ(1), Span: Θ(1)
  206|       |        /// Claude Span: O(1) - constant time access
  206|       |        /// Claude Span: O(1) - constant time check
  206|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  207|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  208|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  208|       |        /// Claude Work: Θ(1), Span: Θ(1)
   20|       |        /// Claude Work: O(1), Span: O(1)
   20|       |    /// Claude Work: Θ(1), Span: Θ(1)
  210|       |        /// Claude Work: O(1) - constant time check
  210|       |        /// Claude Work: O(1) - constant time clear
  210|       |        /// Claude Work: O(m + n), Span: O(log(m + n)) - Parallel difference
  210|       |        /// Claude Work: Θ(m), Span: Θ(m) where m is table size
  211|       |        /// Claude Span: O(1) - constant time check
  211|       |        /// Claude Span: O(1) - constant time clear
  211|       |        /// Claude Work: Θ(1), Span: Θ(1)
  212|       |        /// Claude Work: O(log n), Span: O(log n)
  212|       |        /// Claude Work: O(n), Span: O(lg n)
  212|       |        /// Claude Work: Θ(1), Span: Θ(1)
  213|       |        /// Claude Work: O(n), Span: O(log n) - Parallel restrict
  214|       |        /// Claude Work: O(log n), Span: O(log n)
  214|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  214|       |        /// Claude Work: Θ(log n), Span: Θ(log n)
  215|       |        /// Claude Work: O(1) - constant time clear
  215|       |        /// Claude Work: O(lg n), Span: O(lg n)
  215|       |        /// Claude Work: Θ(1), Span: Θ(1)
  216|       |        /// Claude Span: O(1) - constant time clear
  216|       |        /// Claude Work: O(n), Span: O(log n) - Parallel subtract
  217|       |        /// Claude Work: O(log(m + n)), Span: O(log(m + n))
  218|       |        /// Claude Work: O(1) - constant time update
  218|       |        /// Claude Work: O(lg n), Span: O(lg n)
  218|       |        /// Claude Work: O(log(m + n)), Span: O(log(m + n))
  219|       |        /// Claude Span: O(1) - constant time update
  219|       |        /// Claude Work: O(n), Span: O(log n)
  220|       |        /// Claude Work: O(log n), Span: O(log n)
  220|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  220|       |        /// Claude Work: O(n), Span: O(lg n)
  221|       |        /// Claude Work: O(lg n), Span: O(lg n)
  221|       |        /// Claude Work: O(log n), Span: O(log n)
  224|       |        /// Claude Work: O(lg n), Span: O(lg n)
  224|       |        /// Claude Work: Θ(1), Span: Θ(1)
  225|       |        /// Claude Work: O(log n), Span: O(log n)
  225|       |        /// Claude Work: O(n), Span: O(lg n)
  226|       |        /// Claude Work: O(1) - constant time update
  226|       |        /// Claude Work: O(log(m + n)), Span: O(log(m + n))
  226|       |        /// Claude Work: O(log n), Span: O(log n)
  227|       |        /// Claude Span: O(1) - constant time update
  227|       |        /// Claude Work: O(lg n), Span: O(lg n)
  228|       |        /// Claude Work: O(lg n), Span: O(lg n)
  229|       |        /// Claude Work: O(log n), Span: O(log n)
   22|       |        /// Claude Work: O(k), Span: O(k) where k is path length
   22|       |    /// Claude Work: Θ(1), Span: Θ(1)
   22|       |        /// Claude Work: Θ(n²), Span: Θ(n²) - inefficient due to O(n) insert
  231|       |        /// Claude Work: O(lg n), Span: O(lg n)
  231|       |        /// Claude Work: Θ(1), Span: Θ(1)
  233|       |        /// Claude Work: O(log n), Span: O(log n)
  233|       |        /// Claude Work: O(n + m), Span: O(lg n + lg m)
  233|       |        /// Claude Work: Θ(log n), Span: Θ(log n)
  234|       |        /// Claude Work: O(lg n), Span: O(lg n)
  236|       |        /// Claude Work: O(log n), Span: O(log n)
  237|       |        /// Claude Work: O(lg n), Span: O(lg n)
  237|       |        /// Claude Work: O(log n), Span: O(log n)
  239|       |        /// Claude Work: O(log n), Span: O(log n)
   23|       |        /// Claude Work: O(k), Span: O(k) where k is path length
   23|       |    /// Claude Work: Θ(1), Span: Θ(1)
  240|       |        /// Claude Work: O(lg n), Span: O(lg n)
  240|       |        /// Claude Work: O(log n), Span: O(log n)
  240|       |        /// Claude Work: Θ(1), Span: Θ(1)
  240|       |        /// Claude Work: Θ(log n), Span: Θ(log n)
  241|       |        /// Claude Work: Θ(n), Span: Θ(n)
  242|       |        /// Claude Work: Θ(√m), Span: Θ(√m)
  242|       |    /// Claude Work: Θ(m), Span: Θ(m)
  243|       |        /// Claude Work: O(log n), Span: O(log n)
  244|       |        /// Claude Work: O(log n), Span: O(log n)
  245|       |        /// Claude Work: O(1), Span: O(1)
  245|       |        /// Claude Work: Θ(m + n), Span: Θ(m + n)
  246|       |        /// Claude Work: O(n), Span: O(lg n)
  248|       |        /// Claude Work: O(log n), Span: O(log n)
  248|       |        /// Claude Work: Θ(1), Span: Θ(1)
  248|       |        /// Claude Work: Θ(min(max_probes, period)), Span: Θ(min(max_probes, period))
  249|       |        /// Claude Work: O(lg n), Span: O(lg n)
   24|       |        /// Claude Work: O(1), Span: O(1)
  251|       |        /// Claude Work: O(lg n), Span: O(lg n)
  251|       |    /// Claude Work: Θ(k * m), Span: Θ(k * m) where k is number of keys
  252|       |        /// Claude Work: O(lg n), Span: O(lg n)
  252|       |        /// Claude Work: O(n log log n), Span: O(n log log n)
  253|       |        /// Claude Work: O(log n), Span: O(log n)
  253|       |        /// Claude Work: O(log n), Span: O(log n)
  254|       |        /// Claude Work: O(log n), Span: O(log n)
  254|       |        /// Claude Work: Θ(log m + log n), Span: Θ(log m + log n)
  254|       |        /// Claude Work: Θ(n), Span: Θ(n)
  255|       |        /// Claude Work: O(lg n), Span: O(lg n)
  258|       |        /// Claude Work: O(lg n), Span: O(lg n)
   25|       |        /// Claude Work: Θ(1), Span: Θ(1)
  261|       |        /// Claude Work: O(lg n), Span: O(lg n)
  261|       |        /// Claude Work: O(log n), Span: O(log n)
  263|       |        /// Claude Work: O(log n), Span: O(log n)
  263|       |        /// Claude Work: Θ(1), Span: Θ(1)
  263|       |        /// Claude Work: Θ(n), Span: Θ(n)
  264|       |        /// Claude Work: O(lg n), Span: O(lg n)
  265|       |        /// Claude Work: Θ(1), Span: Θ(1)
  266|       |        /// Claude Work: Θ(1), Span: Θ(1)
  267|       |        /// Claude Work: Θ(1), Span: Θ(1)
  268|       |        /// Claude Work: O(log n), Span: O(log n)
  268|       |        /// Claude Work: Θ(1), Span: Θ(1)
  269|       |        /// Claude Work: O(lg n), Span: O(lg n)
  269|       |        /// Claude Work: O(log(m + n)), Span: O(log(m + n))
  269|       |        /// Claude Work: Θ(1), Span: Θ(1)
   26|       |        /// Claude Work: O(k), Span: O(k) where k is path length
   26|       |        /// Claude Work: Θ(n log n), Span: Θ(n log n) - optimal complexity
  271|       |        /// Claude Work: O(log n), Span: O(log n)
  272|       |        /// Claude Work: O(log n), Span: O(log n)
  278|       |        /// Claude Work: Θ(1), Span: Θ(1)
   27|       |        /// Claude Work: O(k), Span: O(k) where k is path length
   27|       |        /// Claude Work: Θ(1), Span: Θ(1)
  280|       |        /// Claude Work: O(log(m + n)), Span: O(log(m + n))
  282|       |        /// Claude Work: O(lg n), Span: O(lg n)
  282|       |        /// Claude Work: O(lg n), Span: O(lg n)
  282|       |        /// Claude Work: O(n), Span: O(log n) - Sequential split (AVLTreeSeq not thread-safe)
  283|       |        /// Claude Work: O(log n), Span: O(log n)
  285|       |        /// Claude Work: O(lg n), Span: O(lg n)
  285|       |        /// Claude Work: O(lg n), Span: O(lg n)
  285|       |        /// Claude Work: Θ(1), Span: Θ(1)
  285|       |        /// Claude Work: Θ(1), Span: Θ(1)
  285|       |    /// Claude Work: Θ(k * m), Span: Θ(k * m) where k is number of keys
  288|       |        /// Claude Work: O(lg n), Span: O(lg n)
  289|       |        /// Claude Work: O(log n), Span: O(log n)
  291|       |        /// Claude Work: Θ(1), Span: Θ(1)
  292|       |        /// Claude Work: Θ(n), Span: Θ(n)
  295|       |        /// Claude Work: O(lg n), Span: O(lg n)
  295|       |        /// Claude Work: Θ(1), Span: Θ(1)
  297|       |        /// Claude Work: Θ(1), Span: Θ(1)
  298|       |        /// Claude Work: O(lg n), Span: O(lg n)
   29|       |    /// Claude Work: Θ(1), Span: Θ(1)
   29|       |    /// Claude Work: Θ(1), Span: Θ(1)
  300|       |        /// Claude Work: O(log n), Span: O(log n)
  301|       |        /// Claude Work: O(lg n), Span: O(lg n)
  303|       |        /// Claude Work: Θ(1), Span: Θ(1)
  304|       |        /// Claude Work: O(lg n), Span: O(lg n)
  305|       |        /// Claude Work: Θ(1), Span: Θ(1)
  306|       |        /// Claude Work: O(log n), Span: O(log n)
   30|       |        /// Claude Work: Θ(n log n), Span: Θ(n log n) - optimal complexity
  310|       |        /// Claude Work: O(log(m + n)), Span: O(log(m + n))
  310|       |    /// Claude Work: Θ(m), Span: Θ(m)
  312|       |        /// Claude Work: O(1), Span: O(1)
  313|       |        /// Claude Work: O(log n), Span: O(log n) - Sequential (AVLTreeSeq not thread-safe)
  316|       |        /// Claude Work: O(lg n), Span: O(lg n)
  316|       |        /// Claude Work: O(log n), Span: O(log n)
  317|       |        /// Claude Work: O(lg n), Span: O(lg n)
  317|       |        /// Claude Work: O(log n), Span: O(log n)
  317|       |        /// Claude Work: Θ(1), Span: Θ(1)
   31|       |        /// Claude Work: O(1) - constant time construction
  320|       |        /// Claude Work: O(lg n), Span: O(lg n)
  320|       |    /// Claude Work: Θ(k * m), Span: Θ(k * m) where k is number of keys
  323|       |        /// Claude Work: O(lg n), Span: O(lg n)
  325|       |        /// Claude Work: O(1), Span: O(1)
  327|       |        /// Claude Work: O(log n), Span: O(log n)
  329|       |        /// Claude Work: O(lg n), Span: O(lg n)
   32|       |        /// Claude Span: O(1) - constant time construction
   32|       |        /// Claude Work: Θ(1), Span: Θ(1)
   32|       |        /// Claude Work: Θ(1), Span: Θ(1)
   32|       |    /// Claude: Work Θ(|E| × avg_degree), Span Θ(log |E| + avg_degree),
  330|       |        /// Claude Work: O(log n), Span: O(log n)
  334|       |    /// Claude Work: Θ(m), Span: Θ(m)
  336|       |        /// Claude Work: O(lg n), Span: O(lg n)
  337|       |    /// Claude Work: Θ(m), Span: Θ(m)
   33|       |        /// Claude Work: O(k²), Span: O(k²) for k-vertex path
   33|       |    /// Claude: Work Θ(|E|), Span Θ(|E|), Parallelism Θ(1) - inherently sequential
   33|       |        /// Claude Work: Θ(m), Span: Θ(m)
  347|       |        /// Claude Work: O(1), Span: O(1)
  347|       |        /// Claude Work: O(log n), Span: O(log n)
   34|       |        /// Claude Work: O(k²), Span: O(k²) for k-vertex path
   34|       |    /// Claude Work: Θ(log min(a,b)), Span: Θ(log min(a,b))
   34|       |        /// Claude Work: Θ(n log n), Span: Θ(n log n) - optimal complexity
  351|       |        /// Claude Work: O(lg n), Span: O(lg n)
  354|       |        /// Claude Work: Θ(1), Span: Θ(1)
  354|       |    /// Claude Work: Θ(k * m), Span: Θ(k * m) where k is number of keys
  357|       |        /// Claude Work: O(n), Span: O(log n) - Sequential (AVLTreeSeq not thread-safe)
   35|       |    /// Claude Work: Θ(√n), Span: Θ(√n)
  361|       |    /// Claude Work: Θ(m), Span: Θ(m)
   37|       |    /// **Claude Analysis:**
  387|       |    /// Claude Work: Θ(f * k * m), Span: Θ(f * k * m) where f is number of load factors
   38|       |    /// **Claude Analysis:**
   38|       |        /// Claude Work: Θ(1 + α) expected, Span: Θ(1 + α) expected
   38|       |        /// Claude Work: Θ(n²), Span: Θ(n²) - dominated by worst implementation
   39|       |    /// Claude Work: Θ(1), Span: Θ(1)
   39|       |    /// Claude: Work Θ(|V| + |E|), Span Θ(|V| + |E|), Parallelism Θ(1) - sequential
  405|       |    /// Claude Work: Θ(k * m), Span: Θ(k * m) where k is number of keys
   40|       |        /// Claude Work: O(1) - constant time access
   40|       |        /// Claude Work: O(log min(a,b)), Span: O(log min(a,b))
   41|       |        /// Claude Span: O(1) - constant time access
   41|       |        /// Claude Work: O(k²), Span: O(k²) for k-vertex path
   41|       |        /// Claude Work: Θ(√n), Span: Θ(√n)
   42|       |        /// Claude Work: O(k²), Span: O(k²) for k-vertex path
   42|       |        /// Claude Work: Θ(1), Span: Θ(1)
   42|       |    /// Claude Work: Θ(1), Span: Θ(1)
   43|       |    /// **Claude Analysis:**
   43|       |    /// **Claude Analysis:**
   43|       |    /// Claude Work: Θ(n²), Span: Θ(n²) - inefficient due to O(n) deleteMin
   43|       |    /// Claude: Work Θ(|V| + |E|), Span Θ(log |V| + log |E|),
   44|       |        /// Claude Work: O(k*|S|) - each subproblem computed once
  452|       |    /// Claude Work: Θ(m), Span: Θ(m)
   45|       |        /// Claude Span: O(|S|) - maximum recursion depth
   45|       |        /// Claude Work: O(1) - constant time construction
   45|       |        /// Claude Work: O(k*|S|) - each subproblem computed once across all threads
  462|       |    /// Claude Work: Θ(k * m), Span: Θ(k * m) where k is number of load factors tested
   46|       |        /// Claude Span: O(1) - constant time construction
   46|       |        /// Claude Span: O(|S|) - maximum recursion depth, parallelism O(k)
   46|       |        /// Claude Work: O(|S|*|T|) - each subproblem computed once
   47|       |        /// Claude Span: O(|S|+|T|) - maximum recursion depth
   49|       |        /// Claude Work: O(|S|*|T|) - each subproblem computed once across all threads
   49|       |    /// Claude Work: Θ(1), Span: Θ(1)
   49|       |        /// Claude Work: Θ(m), Span: Θ(m)
  100|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1) - locks mutex
  100|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
  101|       |        /// claude-4-sonet: Work Θ(len), Span Θ(len), Parallelism Θ(1) - sequential copy
  102|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(|A|), Parallelism Θ(1) - sequential filter
  103|       |    /// claude-4-sonet: Work O(n), Span O(n) [sequential]
  103|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1) - locks mutex
  104|       |        /// claude-4-sonet: Work Θ(|a|+|b|), Span Θ(|a|+|b|), Parallelism Θ(1) - sequential
  104|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(|E|), Parallelism Θ(1) - sequential sum
  105|       |        /// claude-4-sonet: Work O(α(n)), Span O(α(n)) amortized
  105|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1) - single atomic load
  106|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1) - locks mutex
  107|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) - sequential
  109|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   10|       |        /// claude-4-sonet: Work Θ(1) expected under low contention, Θ(n) worst case with n concurrent operations, Span Θ(1) - CAS retry loop
  110|       |        /// claude-4-sonet: Work Θ(Σ|a[i]|), Span Θ(Σ|a[i]|), Parallelism Θ(1) - sequential
  111|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1) - sequential append
  111|       |    /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(|V|), Parallelism Θ(1)
  112|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
  113|       |    /// claude-4-sonet: Work O((n + m) lg n), Span O((n + m) lg n)
  113|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(log |A|), Parallelism Θ(|A|/log |A|) - parallel divide-and-conquer filter
  113|       |        /// claude-4-sonet: Work Θ(|a|+|updates|), Span Θ(|a|+|updates|), Parallelism Θ(1) - sequential with HashSet
  113|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1) - sequential
  115|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
  115|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(|A|), Parallelism Θ(1) - sequential sum
  115|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1) - sequential
  115|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1) - sequential
  116|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
  116|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
  118|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
  118|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
  118|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(log|a|), Parallelism Θ(|a|/log|a|) - parallel via ParaPair! divide-and-conquer
  118|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(|E|), Parallelism Θ(1) - sequential sum
  119|       |    /// claude-4-sonet: Work O(n), Span O(n)
  119|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
  119|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
  120|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(log |A|), Parallelism Θ(|A|/log |A|) - parallel divide-and-conquer filter
  120|       |    /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(|V| × log |V|), Parallelism Θ(|E|/|V|)
  121|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
  122|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
  122|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
  122|       |        /// claude-4-sonet: Work Θ(|pairs|²), Span Θ(|pairs|²), Parallelism Θ(1) - sequential with linear search
  124|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
  125|       |    /// claude-4-sonet: Work O(n + m), Span O(log n) [parallel iteration with ParaPair!]
  125|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
  125|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
  125|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(|E|), Parallelism Θ(1) - sequential sum
  126|       |        /// claude-4-sonet: Work Θ(len), Span Θ(len), Parallelism Θ(1) - sequential copy, locks mutex
  127|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
  128|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
  128|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) - sequential fold
  128|       |        /// claude-4-sonet: Work Θ(|data|), Span Θ(1)
  129|       |        /// claude-4-sonet: Work Θ(|a|+|b|), Span Θ(|a|+|b|), Parallelism Θ(1) - sequential
   12|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1) - constant time pivot selection
   12|       |        /// claude-4-sonet: Work Θ(|key|), Span Θ(|key|), Parallelism Θ(1)
   12|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   12|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   12|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
  130|       |        /// claude-4-sonet: Work Θ(len), Span Θ(len), Parallelism Θ(1) - sequential copy
  130|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1) where n=stack size - sequential drain, one pop at a time
  131|       |    /// claude-4-sonet: Work O(n), Span O(n)
  131|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) - sequential reduction
  131|       |        /// claude-4-sonet: Work Θ(length), Span Θ(1)
  131|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1) - sequential
  132|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) - sequential
  133|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1) - copies entire array
  134|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) - sequential
  134|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) - sequential prefix sum
  134|       |    /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(|V|), Parallelism Θ(1)
  135|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1) - in-place, locks mutex
  136|       |        /// claude-4-sonet: Work Θ(|a|+|updates|), Span Θ(|a|+|updates|), Parallelism Θ(1) - sequential, overwrites on conflict
  136|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1) - sequential
  137|       |        /// claude-4-sonet: Work O(α(n)), Span O(α(n)) amortized
  137|       |        /// claude-4-sonet: Work Θ(len), Span Θ(len), Parallelism Θ(1) - sequential copy
  138|       |        /// claude-4-sonet: Work Θ(|a|+|updates|), Span Θ(|a|+|updates|), Parallelism Θ(1) - sequential
  139|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) when F is cheap, better when F is expensive - asymmetric fork-join recursion
   13|       |        /// claude-4-sonet: Work Θ(n) expected, Θ(n²) worst case; Span Θ(log² n) expected (with parallel filter), Parallelism Θ(n/log² n) expected
   13|       |        /// claude-4-sonet: Work Θ(n) expected, Θ(n²) worst case; Span Θ(n) (sequential), Parallelism Θ(1)
   13|       |        /// claude-4-sonet: Work Θ(n) expected, Θ(n²) worst case; Span Θ(n) (sequential), Parallelism Θ(1)
   13|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   13|       |        /// claude-4-sonet: Work Θ(φⁿ), Span Θ(n), Parallelism Θ(φⁿ/n) - parallel binary recursion via ParaPair!
  140|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
  140|       |        /// claude-4-sonet: Work Θ(|a|+|b|), Span Θ(|a|+|b|), Parallelism Θ(1) - sequential
  141|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
  141|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1) - locks mutex
  143|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) - sequential
  144|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1) - locks mutex
  146|       |        /// claude-4-sonet: Work Θ(Σ|a[i]|), Span Θ(Σ|a[i]|), Parallelism Θ(1) - sequential
  147|       |    /// claude-4-sonet: Work O(n), Span O(n)
  147|       |        /// claude-4-sonet: Work Θ(|a|+|b|), Span Θ(|a|+|b|), Parallelism Θ(1) - sequential
  147|       |        /// claude-4-sonet: Work Θ(Σ|ss[i]|), Span Θ(Σ|ss[i]|), Parallelism Θ(1) - sequential
  149|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1) - in-place mutation
   14|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1) - constant time pivot selection
   14|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1) - constant time pivot selection
   14|       |        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   14|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
  150|       |    /// claude-4-sonet: Work O((n+m) lg n), Span O((n+m) lg n)
  150|       |        /// claude-4-sonet: Work O(n α(n)), Span O(n α(n))
  150|       |        /// claude-4-sonet: Work Θ(|a|²), Span Θ(|a|²), Parallelism Θ(1) - sequential with linear search
  150|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) - sequential
  152|       |        /// claude-4-sonet: Work Θ(|updates|), Span Θ(|updates|), Parallelism Θ(1) - sequential in-place
  153|       |    /// claude-4-sonet: Work O(m log n), Span O(m log n) [sequential, expected O(log n) rounds]
  153|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) - sequential fold
  153|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1) - copies entire array
  155|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
  156|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) - sequential
  156|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(log|a|), Parallelism Θ(|a|/log|a|) - parallel via ParaPair! divide-and-conquer
  158|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
  159|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) - sequential fold
   15|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1) - constant time median-of-3
   15|       |        /// claude-4-sonet: Work Θ(n) expected, Θ(n²) worst case; Span Θ(log² n) expected (with parallel filter), Parallelism Θ(n/log² n) expected
   15|       |        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   15|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   15|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   15|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
  161|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) - sequential prefix sum
  161|       |        /// claude-4-sonet: Work Θ(|pairs|²), Span Θ(|pairs|²), Parallelism Θ(1) - sequential with linear search
  162|       |    /// claude-4-sonet: Work O((n + m) lg n), Span O(lg² n), Parallelism Θ((n+m)/lg² n)
  162|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) - sequential prefix sum
  165|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(|A|), Parallelism Θ(1) - sequential sum
  166|       |    /// claude-4-sonet: Work O((n+m) lg n), Span O((n+m) lg n)
  166|       |    /// claude-4-sonet: Work O(n), Span O(n)
  167|       |    /// claude-4-sonet: Work O(|MST|), Span O(|MST|)
  167|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) - sequential fold
  169|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(log|a|), Parallelism Θ(|a|/log|a|) - parallel via ParaPair! divide-and-conquer
   16|       |        /// claude-4-sonet: Work Θ(n²), Span Θ(n²), Parallelism Θ(1)
   16|       |        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   16|       |        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   16|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
  170|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) - sequential reduction
  173|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) - sequential prefix sum
  174|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) - sequential prefix sum
  175|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(|A|), Parallelism Θ(1) - sequential sum
  177|       |        /// claude-4-sonet: Work Θ(Σ|ss[i]|), Span Θ(Σ|ss[i]|), Parallelism Θ(1) - sequential
   17|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   17|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   17|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   17|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   17|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   17|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   17|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   17|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1) - constant time median-of-3
   17|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1) - constant time median-of-3
   17|       |        /// claude-4-sonet: Work Θ(n²), Span Θ(n²), Parallelism Θ(1)
   17|       |        /// claude-4-sonet: Work Θ(n log n), Span Θ(n log n), Parallelism Θ(1)
   17|       |        /// claude-4-sonet: Work Θ(n), Span Θ(1)
   17|       |        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   17|       |        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
  180|       |        /// claude-4-sonet: Work Θ(|a|²), Span Θ(|a|²), Parallelism Θ(1) - sequential with linear search
  182|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1) - sequential
  187|       |        /// claude-4-sonet: Work Θ(index), Span Θ(index), Parallelism Θ(1) - sequential traversal and in-place
   18|       |        /// claude-4-sonet: Work Θ(1) expected under low contention, Θ(n) worst case with n concurrent operations, Span Θ(1), Parallelism Θ(1) - CAS retry loop
   18|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   18|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   18|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   18|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   18|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   18|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   18|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   18|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   18|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   18|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   18|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   18|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1) - constant time random selection
  190|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1) - cached length
  193|       |        /// claude-4-sonet: Work Θ(index), Span Θ(index), Parallelism Θ(1) - sequential traversal
  196|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
  198|       |    /// claude-4-sonet: Work O(n+m), Span O(n+m) [Limited parallelism due to DFS]
  199|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   19|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   19|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   19|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   19|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   19|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   19|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   19|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   19|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   19|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   19|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   19|       |        /// claude-4-sonet: Work Θ(length), Span Θ(1), Parallelism Θ(1).
   19|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   19|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   19|       |        /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(|V| + |E|), Parallelism Θ(1) - sequential
   19|       |        /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(|V| + |E|), Parallelism Θ(1) - sequential
  202|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1) - sequential
  205|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) - sequential
  208|       |    /// claude-4-sonet: Work O((n+m) lg n), Span O(lg² n), Parallelism Θ((n+m)/lg² n)
  208|       |        /// claude-4-sonet: Work Θ(start+length), Span Θ(start+length), Parallelism Θ(1) - sequential traversal and copy
   20|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   20|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   20|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   20|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   20|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   20|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   20|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   20|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   20|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   20|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   20|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   20|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   20|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   20|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   20|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1) - constant time random selection
   20|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1) - constant time random selection
   20|       |        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
  211|       |        /// claude-4-sonet: Work Θ(|a| + |b|), Span Θ(|a| + |b|), Parallelism Θ(1) - sequential
  214|       |    /// claude-4-sonet: Work O(m log n), Span O(m log n)
  214|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) - sequential
  217|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
  218|       |    /// claude-4-sonet: Work O(m log n), Span O(log² n) [O(log n) rounds × O(log n) span per round]
   21|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   21|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   21|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   21|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   21|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   21|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   21|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   21|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   21|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   21|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   21|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   21|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   21|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   21|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   21|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   21|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   21|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   21|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   21|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   21|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   21|       |        /// claude-4-sonet: Work Θ(n log n) expected, Θ(n²) worst, Span Θ(n log n) expected, Θ(n²) worst, Parallelism Θ(1) - sequential divide-and-conquer
   21|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   21|       |        /// claude-4-sonet: Work Θ(Σ deg(v)), Span Θ(Σ deg(v)), Parallelism Θ(1)
   21|       |    /// claude-4-sonet: Work Θ(φⁿ), Span Θ(n), Parallelism Θ(φⁿ/n) - parallel binary recursion via ParaPair!
  220|       |        /// claude-4-sonet: Work Θ(Σ|ss[i]|), Span Θ(Σ|ss[i]|), Parallelism Θ(1) - sequential
  222|       |    /// claude-4-sonet: Work O((n+m) lg n), Span O(lg² n), Parallelism Θ((n+m)/lg² n)
  223|       |        /// claude-4-sonet: Work Θ(index), Span Θ(index), Parallelism Θ(1) - in-place, sequential traversal
  224|       |    /// claude-4-sonet: Work O(n+m), Span O(n+m)
  226|       |        /// claude-4-sonet: Work Θ(|a| + |updates|), Span Θ(|a| + |updates|), Parallelism Θ(1) - sequential with HashSet
  229|       |        /// claude-4-sonet: Work Θ(|a| + |updates|), Span Θ(|a| + |updates|), Parallelism Θ(1) - sequential, overwrites on conflict
   22|       |        /// claude-4-sonet: Work Θ(1) expected under low contention, Θ(n) worst case with n waiting threads, Span Θ(1) - sequential ticket acquisition
   22|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   22|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   22|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   22|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   22|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   22|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   22|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   22|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   22|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   22|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   22|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   22|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   22|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   22|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   22|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   22|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   22|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   22|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   22|       |        /// claude-4-sonet: Work Θ(n²), Span Θ(n²), Parallelism Θ(1)
   22|       |        /// claude-4-sonet: Work Θ(n log n), Span Θ(log² n), Parallelism Θ(n/log n)
   22|       |        /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(log |V| × log |E|), Parallelism Θ(|E|/log |V|)
   22|       |        /// claude-4-sonet: Work Θ(Σ deg(v)), Span Θ(Σ deg(v)), Parallelism Θ(1)
  232|       |        /// claude-4-sonet: Work Θ(|a|²), Span Θ(|a|²), Parallelism Θ(1) - sequential with linear search
  235|       |    /// claude-4-sonet: Work O(m), Span O(m)
  238|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) - sequential fold
   23|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   23|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   23|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   23|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   23|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   23|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   23|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   23|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   23|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   23|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   23|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   23|       |        /// claude-4-sonet: Work Θ(deg(u)), Span Θ(deg(u)), Parallelism Θ(1)
   23|       |        /// claude-4-sonet: Work Θ(|key|), Span Θ(|key|), Parallelism Θ(1)
   23|       |        /// claude-4-sonet: Work Θ(n²), Span Θ(n²), Parallelism Θ(1)
   23|       |        /// claude-4-sonet: Work Θ(n³), Span Θ(n³), Parallelism Θ(1)
   23|       |        /// claude-4-sonet: Work Θ(n log n) expected, Θ(n²) worst, Span Θ(log² n) expected, Θ(n) worst, Parallelism Θ(n/log n) expected - parallel divide-and-conquer with unconditional thread spawning
   23|       |        /// claude-4-sonet: Work Θ(n log n) expected, Θ(n²) worst, Span Θ(log² n) expected, Θ(n) worst, Parallelism Θ(n/log n) expected - parallel divide-and-conquer with unconditional thread spawning (slice-based)
   23|       |        /// claude-4-sonet: Work Θ(u), Span Θ(1)
   23|       |        /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(|V| + |E|), Parallelism Θ(1) - sequential
   23|       |        /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(|V| + |E|), Parallelism Θ(1) - sequential
   23|       |        /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(|V| + |E|), Parallelism Θ(1) - sequential
   23|       |        /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(|V| + |E|), Parallelism Θ(1) - sequential
  241|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) - sequential prefix computation
  244|       |        /// claude-4-sonet: Work Θ(|a|log|a|), Span Θ(|a|log|a|), Parallelism Θ(1) - sequential divide-and-conquer (no parallelism)
  247|       |        /// claude-4-sonet: Work Θ(|a|²), Span Θ(|a|²), Parallelism Θ(1) - naive scan calling reduce repeatedly
   24|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(deg(u)), Span Θ(deg(u)), Parallelism Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(log |V| + log |E|), Span Θ(log |V| + log |E|), Parallelism Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(n²), Span Θ(n²), Parallelism Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(n log n) expected, Θ(n²) worst, Span Θ(n log n) expected, Θ(n²) worst, Parallelism Θ(1) - sequential divide-and-conquer with median-of-3 pivot
   24|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   24|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1) - sequential
   24|       |        /// claude-4-sonet: Work Θ(|V| + |A|), Span Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(|V| + |A|), Span Θ(|V| + |A|), Parallelism Θ(1) - sequential
   24|       |        /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(|V| + |E|), Parallelism Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(|V| + |E|), Parallelism Θ(1)
   24|       |        /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(|V| + |E|), Parallelism Θ(1) - sequential
   25|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   25|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   25|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   25|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   25|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   25|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   25|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   25|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   25|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   25|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   25|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   25|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   25|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1) - atomic increment releases next thread
   25|       |        /// claude-4-sonet: Work Θ(length), Span Θ(1)
   25|       |        /// claude-4-sonet: Work Θ(length), Span Θ(length), Parallelism Θ(1)
   25|       |        /// claude-4-sonet: Work Θ(length), Span Θ(length), Parallelism Θ(1)
   25|       |        /// claude-4-sonet: Work Θ(length), Span Θ(log length), Parallelism Θ(length/log length)
   25|       |        /// claude-4-sonet: Work Θ(n log n), Span Θ(n log n), Parallelism Θ(1)
   25|       |        /// claude-4-sonet: Work Θ(n log n), Span Θ(n log n), Parallelism Θ(1)
   25|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   25|       |        /// claude-4-sonet: Work Θ(|pairs|), Span Θ(1)
   25|       |        /// claude-4-sonet: Work Θ(u/w) where w is word size, Span Θ(u/w)
   26|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   26|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   26|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   26|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   26|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   26|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   26|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   26|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   26|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   26|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   26|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   26|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   26|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   26|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   26|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   26|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   26|       |        /// claude-4-sonet: Work Θ(log n) average, Θ(n) worst case; Span Θ(log n) average, Parallelism Θ(1)
   26|       |        /// claude-4-sonet: Work Θ(log |V|), Span Θ(log |V|), Parallelism Θ(1)
   26|       |        /// claude-4-sonet: Work Θ(n log n) expected, Θ(n²) worst, Span Θ(log² n) expected, Θ(n) worst, Parallelism Θ(n/log n) expected - parallel divide-and-conquer with median-of-3 pivot
   26|       |        /// claude-4-sonet: Work Θ(n log n) expected, Θ(n²) worst, Span Θ(log² n) expected, Θ(n) worst, Parallelism Θ(n/log n) expected - parallel divide-and-conquer with median-of-3 pivot (slice-based)
   26|       |        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   26|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   26|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   26|       |        /// claude-4-sonet: Work Θ(|v|), Span Θ(1)
   26|       |        /// claude-4-sonet: Work Θ(|V|), Span Θ(|V|), Parallelism Θ(1)
   26|       |        /// claude-4-sonet: Work Θ(|V|), Span Θ(|V|), Parallelism Θ(1)
   27|       |        /// claude-4-sonet: Work Θ(1) expected under low contention, Θ(n) worst case with n concurrent pushes, Span Θ(1) - CAS retry loop
   27|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   27|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   27|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   27|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   27|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   27|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   27|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   27|       |        /// claude-4-sonet: Work Θ(length), Span Θ(1)
   27|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   27|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   27|       |        /// claude-4-sonet: Work Θ(n log n) expected, Θ(n²) worst, Span Θ(n log n) expected, Θ(n²) worst, Parallelism Θ(1) - sequential divide-and-conquer with random pivot
   27|       |        /// claude-4-sonet: Work Θ(n log n), Span Θ(n log n), Parallelism Θ(1)
   27|       |        /// claude-4-sonet: Work Θ(n log n), Span Θ(n log n), Parallelism Θ(1)
   27|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   27|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   27|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   27|       |        /// claude-4-sonet: Work Θ(|set|), Span Θ(|set|)
   27|       |        /// claude-4-sonet: Work Θ(|V| + |A|), Span Θ(1)
   27|       |        /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(1)
  280|       |    /// claude-4-sonet: Work Θ(n²), Span Θ(1) - simple membership test both ways
  288|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   28|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   28|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   28|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   28|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   28|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   28|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   28|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   28|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   28|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   28|       |        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized with locking
   28|       |        /// claude-4-sonet: Work Θ(log n) average, Θ(n) worst case; Span Θ(log n) average, Parallelism Θ(1)
   28|       |        /// claude-4-sonet: Work Θ(log n) average, Θ(n) worst case; Span Θ(log n) average with locking
   28|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected with locking
   28|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   28|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   28|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   28|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   28|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   28|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   28|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   28|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   28|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   28|       |        /// claude-4-sonet: Work Θ(log |V| + log |E|), Span Θ(log |V| + log |E|), Parallelism Θ(1)
   28|       |        /// claude-4-sonet: Work Θ(log |V| + log |E|), Span Θ(log |V| + log |E|), Parallelism Θ(1)
   28|       |        /// claude-4-sonet: Work Θ(log |V|), Span Θ(log |V|), Parallelism Θ(1)
   28|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   28|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   28|       |        /// claude-4-sonet: Work Θ(n + Σᵢ W(f(i))), Span Θ(log n + maxᵢ S(f(i))), Parallelism Θ(n)
   28|       |        /// claude-4-sonet: Work Θ(|V| + |A|), Span Θ(|V| + |A|), Parallelism Θ(1) - sequential
   28|       |        /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(|V| + |E|), Parallelism Θ(1) - sequential
  291|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
  294|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
  297|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   29|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   29|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   29|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   29|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   29|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   29|       |        /// claude-4-sonet: Work Θ(|keys| × W(f)), Span Θ(|keys| × S(f)), Parallelism Θ(1)
   29|       |        /// claude-4-sonet: Work Θ(k×|S|), Span Θ(|S|), Parallelism Θ(1)
   29|       |        /// claude-4-sonet: Work Θ(log |E|), Span Θ(log |E|), Parallelism Θ(1)
   29|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   29|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   29|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   29|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)
   29|       |        /// claude-4-sonet: Work Θ(n log n) expected, Θ(n²) worst, Span Θ(log² n) expected, Θ(n) worst, Parallelism Θ(n/log n) expected - parallel divide-and-conquer with random pivot
   29|       |        /// claude-4-sonet: Work Θ(n log n) expected, Θ(n²) worst, Span Θ(log² n) expected, Θ(n) worst, Parallelism Θ(n/log n) expected - parallel divide-and-conquer with random pivot (slice-based)
   29|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   29|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   29|       |        /// claude-4-sonet: Work Θ(n + Σᵢ W(f(i))), Span Θ(n + maxᵢ S(f(i))), Parallelism Θ(1)
   29|       |        /// claude-4-sonet: Work Θ(n + Σᵢ W(f(i))), Span Θ(n + maxᵢ S(f(i))), Parallelism Θ(1)
   29|       |        /// claude-4-sonet: Work Θ(u), Span Θ(1)
  300|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   30|       |        /// claude-4-sonet: Work Θ(1 + deg(u)), Span Θ(1 + deg(u)), Parallelism Θ(1)
   30|       |        /// claude-4-sonet: Work Θ(1) expected under low contention, Θ(n) worst case with n concurrent pops, Span Θ(1) - CAS retry loop
   30|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   30|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   30|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   30|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   30|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   30|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   30|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   30|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   30|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   30|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   30|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   30|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   30|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   30|       |        /// claude-4-sonet: Work Θ(|a| + Σₓ W(f(x))), Span Θ(log |a| + maxₓ S(f(x))), Parallelism Θ(|a|)
   30|       |        /// claude-4-sonet: Work Θ(k×|S|), Span Θ(|S|), Parallelism Θ(1)
   30|       |        /// claude-4-sonet: Work Θ(k×|S|), Span Θ(|S|), Parallelism Θ(k)
   30|       |        /// claude-4-sonet: Work Θ(log |E|), Span Θ(log |E|), Parallelism Θ(1)
   30|       |        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized with locking
   30|       |        /// claude-4-sonet: Work Θ(log n) average, Θ(n) worst case; Span Θ(log n) average, Parallelism Θ(1)
   30|       |        /// claude-4-sonet: Work Θ(log n) average, Θ(n) worst case; Span Θ(log n) average with locking
   30|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected with locking
   30|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   30|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   30|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   30|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   30|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   30|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   30|       |        /// claude-4-sonet: Work Θ(log |V|), Span Θ(log |V|), Parallelism Θ(1)
   30|       |        /// claude-4-sonet: Work Θ(log |V|), Span Θ(log |V|), Parallelism Θ(1)
   30|       |        /// claude-4-sonet: Work Θ(log |V|), Span Θ(log |V|), Parallelism Θ(1)
   30|       |        /// claude-4-sonet: Work Θ(n log n), Span Θ(log² n), Parallelism Θ(n/log² n)
   30|       |        /// claude-4-sonet: Work Θ(n log n), Span Θ(log n), Parallelism Θ(n)
   30|       |        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   30|       |        /// claude-4-sonet: Work Θ(n + Σᵢ W(f(i))), Span Θ(1 + maxᵢ S(f(i))), Parallelism Θ(n) when f is Θ(1)
   30|       |        /// claude-4-sonet: Work Θ(|r|), Span Θ(1)
   30|       |        /// claude-4-sonet: Work Θ(|S|×|T|), Span Θ(|S|+|T|), Parallelism Θ(1)
  315|       |    /// claude-4-sonet: Work O(m log n), Span O(log² n)
   31|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   31|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   31|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   31|       |        /// claude-4-sonet: Work Θ(|a| + |b|), Span Θ(1)
   31|       |        /// claude-4-sonet: Work Θ(deg(u)), Span Θ(deg(u)), Parallelism Θ(1)
   31|       |        /// claude-4-sonet: Work Θ(|E| log |V|), Span Θ(|E| log |V|), Parallelism Θ(1)
   31|       |        /// claude-4-sonet: Work Θ(k×|S|), Span Θ(|S|), Parallelism Θ(k)
   31|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   31|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   31|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   31|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   31|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   31|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)
   31|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   31|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   31|       |        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(n × S(f)), Parallelism Θ(1)
   31|       |        /// claude-4-sonet: Work Θ(|S|×|T|), Span Θ(|S|+|T|), Parallelism Θ(1)
   31|       |        /// claude-4-sonet: Work Θ(|S|×|T|), Span Θ(|S|+|T|), Parallelism Θ(min(|S|,|T|))
   31|       |        /// claude-4-sonet: Work Θ(u), Span Θ(1)
   32|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   32|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   32|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   32|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   32|       |        /// claude-4-sonet: Work Θ(|a| + Σₓ W(f(x))), Span Θ(1 + maxₓ S(f(x))), Parallelism Θ(|a|) when f is Θ(1)
   32|       |        /// claude-4-sonet: Work Θ(|a| + Σₓ W(f(x))), Span Θ(|a| + maxₓ S(f(x))), Parallelism Θ(1)
   32|       |        /// claude-4-sonet: Work Θ(|a| + Σₓ W(f(x))), Span Θ(|a| + maxₓ S(f(x))), Parallelism Θ(1)
   32|       |        /// claude-4-sonet: Work Θ(deg(u)), Span Θ(deg(u)), Parallelism Θ(1)
   32|       |        /// claude-4-sonet: Work Θ(|E| log |V|), Span Θ(|E| log |V|), Parallelism Θ(1)
   32|       |        /// claude-4-sonet: Work Θ(|keys| × W(f)), Span Θ(log |keys| + S(f)), Parallelism Θ(|keys|/(log |keys| + S(f)))
   32|       |        /// claude-4-sonet: Work Θ(log |E|), Span Θ(log |E|), Parallelism Θ(1)
   32|       |        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized with locking
   32|       |        /// claude-4-sonet: Work Θ(log n) average, Θ(n) worst case; Span Θ(log n) average, Parallelism Θ(1)
   32|       |        /// claude-4-sonet: Work Θ(log n) average, Θ(n) worst case; Span Θ(log n) average with locking
   32|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected with locking
   32|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   32|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   32|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   32|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   32|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   32|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   32|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   32|       |        /// claude-4-sonet: Work Θ(log |V|), Span Θ(log |V|), Parallelism Θ(1)
   32|       |        /// claude-4-sonet: Work Θ(log |V|), Span Θ(log |V|), Parallelism Θ(1)
   32|       |        /// claude-4-sonet: Work Θ(n²), Span Θ(n²), Parallelism Θ(1)
   32|       |        /// claude-4-sonet: Work Θ(n log n), Span Θ(log n), Parallelism Θ(n)
   32|       |        /// claude-4-sonet: Work Θ(n log n), Span Θ(log n), Parallelism Θ(n)
   32|       |        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   32|       |        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   32|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   32|       |        /// claude-4-sonet: Work Θ(|S|×|T|), Span Θ(|S|+|T|), Parallelism Θ(min(|S|,|T|))
   32|       |        /// claude-4-sonet: Work Θ((|V| + |E|) log |V|), Span Θ(log² |V| + log |E|), Parallelism Θ(|E|/log |V|)
  338|       |    /// claude-4-sonet: Work O(m), Span O(m)
   33|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   33|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   33|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   33|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   33|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   33|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   33|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   33|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1) - single atomic load
   33|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(|A|), Parallelism Θ(1) - sequential map
   33|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(|E|), Parallelism Θ(1)
   33|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(|E|), Parallelism Θ(1) - sequential map
   33|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   33|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   33|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   33|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)
   33|       |        /// claude-4-sonet: Work Θ(n²), Span Θ(n²), Parallelism Θ(1)
   33|       |    /// claude-4-sonet: Work Θ(n + m), Span Θ(n + m)
   33|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   33|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   33|       |        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(n × S(f)), Parallelism Θ(1)
   33|       |        /// claude-4-sonet: Work Θ(|R|), Span Θ(1)
   33|       |        /// claude-4-sonet: Work Θ(u + |seq|), Span Θ(1)
   34|       |    /// claude-4-sonet: Work O((n+m) lg n), Span O(lg² n), Parallelism Θ((n+m)/lg² n)
   34|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   34|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   34|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   34|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   34|       |        /// claude-4-sonet: Work Θ(|a| + |b|), Span Θ(1)
   34|       |        /// claude-4-sonet: Work Θ(|E| log |V|), Span Θ(log |E| × log |V|), Parallelism Θ(|E|/log |E|)
   34|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(|E|), Parallelism Θ(1)
   34|       |        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized with locking
   34|       |        /// claude-4-sonet: Work Θ(log n) average, Θ(n) worst case; Span Θ(log n) average, Parallelism Θ(1)
   34|       |        /// claude-4-sonet: Work Θ(log n) average, Θ(n) worst case; Span Θ(log n) average with locking
   34|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected with locking
   34|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   34|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   34|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   34|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   34|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   34|       |        /// claude-4-sonet: Work Θ(log |V|), Span Θ(log |V|), Parallelism Θ(1)
   34|       |        /// claude-4-sonet: Work Θ(log |V|), Span Θ(log |V|), Parallelism Θ(1)
   34|       |        /// claude-4-sonet: Work Θ(log |V|), Span Θ(log |V|), Parallelism Θ(1)
   34|       |        /// claude-4-sonet: Work Θ(n log n), Span Θ(n log n), Parallelism Θ(1)
   34|       |        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   34|       |        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   34|       |        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   34|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   34|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   34|       |        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(log n + S(f)), Parallelism Θ(n/(log n + S(f)))
   35|       |    /// claude-4-sonet: Work O(n + m), Span O(lg n), Parallelism Θ((n+m)/lg n)
   35|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   35|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   35|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   35|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   35|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   35|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   35|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   35|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1) - cached length
   35|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   35|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   35|       |        /// claude-4-sonet: Work Θ(log |V|), Span Θ(log |V|), Parallelism Θ(1)
   35|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   35|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   35|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)
   35|       |        /// claude-4-sonet: Work Θ(n³), Span Θ(n²), Parallelism Θ(1)
   35|       |        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(n × S(f)), Parallelism Θ(1)
   35|       |        /// claude-4-sonet: Work Θ(u), Span Θ(log u), Parallelism Θ(u/log u)
   36|       |    /// claude-4-sonet: Work Θ(1) expected, Θ(n) worst case, Span Θ(1), Parallelism Θ(1)
   36|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   36|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   36|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   36|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   36|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   36|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   36|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   36|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   36|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   36|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(log |E|), Parallelism Θ(|E|/log |E|)
   36|       |        /// claude-4-sonet: Work Θ(|keys| × W(f)), Span Θ(|keys| × S(f)), Parallelism Θ(1)
   36|       |        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized with locking
   36|       |        /// claude-4-sonet: Work Θ(log n) average, Θ(n) worst case; Span Θ(log n) average with locking
   36|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected with locking
   36|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   36|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   36|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   36|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   36|       |        /// claude-4-sonet: Work Θ(log |V| + log |E|), Span Θ(log |V| + log |E|), Parallelism Θ(1)
   36|       |        /// claude-4-sonet: Work Θ(log |V|), Span Θ(log |V|), Parallelism Θ(1)
   36|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   36|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))
   36|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))
   36|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))
   36|       |        /// claude-4-sonet: Work Θ(n³), Span Θ(n²), Parallelism Θ(1)
   36|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   36|       |        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(log n + S(f)), Parallelism Θ(n/(log n + S(f)))
   36|       |        /// claude-4-sonet: Work Θ((|V| + |E|) log |V|), Span Θ((|V| + |E|) log |V|), Parallelism Θ(1)
   36|       |        /// claude-4-sonet: Work Θ((|V| + |E|) log |V|), Span Θ((|V| + |E|) log |V|), Parallelism Θ(1)
   37|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   37|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   37|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   37|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   37|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   37|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   37|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   37|       |        /// claude-4-sonet: Work Θ(|a| + |b|), Span Θ(log(|a| + |b|)), Parallelism Θ((|a|+|b|)/log(|a|+|b|))
   37|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(|A|), Parallelism Θ(1) - sequential map
   37|       |        /// claude-4-sonet: Work Θ(|E| log |E|), Span Θ(|E| log |E|), Parallelism Θ(1)
   37|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(|E|), Parallelism Θ(1) - sequential map
   37|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   37|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   37|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   37|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)
   37|       |        /// claude-4-sonet: Work Θ(n³), Span Θ(n²), Parallelism Θ(1)
   37|       |        /// claude-4-sonet: Work Θ(n³), Span Θ(n log n), Parallelism Θ(n²/log n)
   37|       |        /// claude-4-sonet: Work Θ(n³), Span Θ(n log n), Parallelism Θ(n²/log n)
   37|       |        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   37|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   37|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   37|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1) - sequential traversal with append
   37|       |        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(n × S(f)), Parallelism Θ(1)
   37|       |        /// claude-4-sonet: Work Θ(|parts| × |a|²), Span Θ(1)
   37|       |        /// claude-4-sonet: Work Θ(u/w), Span Θ(u/w)
   38|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   38|       |        /// claude-4-sonet: Work Θ(|a| + |b|), Span Θ(|a| + |b|), Parallelism Θ(1)
   38|       |        /// claude-4-sonet: Work Θ(|a| + |b|), Span Θ(|a| + |b|), Parallelism Θ(1)
   38|       |        /// claude-4-sonet: Work Θ(|E| log |E|), Span Θ(|E| log |E|), Parallelism Θ(1)
   38|       |        /// claude-4-sonet: Work Θ(index), Span Θ(index), Parallelism Θ(1) - sequential traversal
   38|       |        /// claude-4-sonet: Work Θ(|keys| × W(f)), Span Θ(log |keys| + S(f)), Parallelism Θ(|keys|/(log |keys| + S(f)))
   38|       |        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized with locking
   38|       |        /// claude-4-sonet: Work Θ(log n) average, Θ(n) worst case; Span Θ(log n) average with locking
   38|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected with locking
   38|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   38|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   38|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   38|       |        /// claude-4-sonet: Work Θ(log |V| + log |E|), Span Θ(log |V| + log |E|), Parallelism Θ(1)
   38|       |        /// claude-4-sonet: Work Θ(log |V| + log |E|), Span Θ(log |V| + log |E|), Parallelism Θ(1)
   38|       |        /// claude-4-sonet: Work Θ(log |V|), Span Θ(log |V|), Parallelism Θ(1)
   38|       |        /// claude-4-sonet: Work Θ(m log(1 + n/m)), Span Θ(log n + log m)
   38|       |        /// claude-4-sonet: Work Θ(m log(1 + n/m)), Span Θ(log n + log m)
   38|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   38|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))
   38|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))
   38|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))
   38|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))
   38|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)
   38|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)
   38|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)
   38|       |        /// claude-4-sonet: Work Θ(|m|), Span Θ(1)
   38|       |        /// claude-4-sonet: Work Θ(n³), Span Θ(n²), Parallelism Θ(1)
   38|       |        /// claude-4-sonet: Work Θ(n³), Span Θ(n log n), Parallelism Θ(n²/log n)
   38|       |        /// claude-4-sonet: Work Θ(n³), Span Θ(n log n), Parallelism Θ(n²/log n)
   38|       |        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   38|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   38|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   38|       |        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(n × S(f)), Parallelism Θ(1)
   39|       |    /// claude-4-sonet: Work O((n + m) lg n), Span O((n + m) lg n)
   39|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   39|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   39|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   39|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   39|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   39|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   39|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   39|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   39|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   39|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   39|       |        /// claude-4-sonet: Work Θ(|a| + |b|), Span Θ(1)
   39|       |        /// claude-4-sonet: Work Θ(|a| + Σᵢ W(f(aᵢ))), Span Θ(log |a| + maxᵢ S(f(aᵢ))), Parallelism Θ(|a|)
   39|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   39|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   39|       |        /// claude-4-sonet: Work Θ(log |V| + log |E|), Span Θ(log |V| + log |E|), Parallelism Θ(1)
   39|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   39|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)
   39|       |        /// claude-4-sonet: Work Θ(n), Span Θ(1)
   39|       |        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   39|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   39|       |        /// claude-4-sonet: Work Θ(|R|), Span Θ(1)
   39|       |        /// claude-4-sonet: Work Θ(|S|×|T|), Span Θ(|S|+|T|), Parallelism Θ(1)
   39|       |        /// claude-4-sonet: Work Θ(|S|×|T|), Span Θ(|S|+|T|), Parallelism Θ(1)
   39|       |        /// claude-4-sonet: Work Θ(u/w), Span Θ(u/w)
   39|       |        /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(|V|), Parallelism Θ(1)
   40|       |        /// claude-4-sonet: Work Θ(1) expected under low contention, Θ(n) worst case with n waiting threads, Span Θ(1) - sequential ticket acquisition
   40|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   40|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   40|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   40|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   40|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   40|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   40|       |        /// claude-4-sonet: Work Θ(|E| log |V| + |E| log |E|), Span Θ(log |E| × log |V|), Parallelism Θ(|E|/log |E|)
   40|       |        /// claude-4-sonet: Work Θ(|keys| × W(f)), Span Θ(|keys| × S(f)), Parallelism Θ(1)
   40|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   40|       |        /// claude-4-sonet: Work Θ(log |V| + log |E|), Span Θ(log |V| + log |E|), Parallelism Θ(1)
   40|       |        /// claude-4-sonet: Work Θ(log |V| + log |E|), Span Θ(log |V| + log |E|), Parallelism Θ(1)
   40|       |        /// claude-4-sonet: Work Θ(log |V| + log |E|), Span Θ(log |V| + log |E|), Parallelism Θ(1)
   40|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   40|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   40|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   40|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   40|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   40|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   40|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   40|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))
   40|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))
   40|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))
   40|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))
   40|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1) - sequential traversal with append
   40|       |        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(n × S(f)), Parallelism Θ(1)
   40|       |        /// claude-4-sonet: Work Θ((|V| + |E|) log |V|), Span Θ(|V| log |V|), Parallelism Θ(1)
   41|       |    /// claude-4-sonet: Work O((n+m) lg n), Span O((n+m) lg n)
   41|       |        /// claude-4-sonet: Work Θ(1) expected, Θ(n) worst case, Span Θ(1) - CAS retry loop
   41|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   41|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   41|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   41|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   41|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   41|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   41|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   41|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   41|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   41|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   41|       |        /// claude-4-sonet: Work Θ(|a| + |b|), Span Θ(1)
   41|       |        /// claude-4-sonet: Work Θ(|a| × |b|), Span Θ(1)
   41|       |        /// claude-4-sonet: Work Θ(|a| + |b|), Span Θ(|a| + |b|), Parallelism Θ(1)
   41|       |        /// claude-4-sonet: Work Θ(|a| + |b|), Span Θ(|a| + |b|), Parallelism Θ(1)
   41|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(|A|), Parallelism Θ(1) - sequential search
   41|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(log |a|), Parallelism Θ(|a|/log |a|)
   41|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(|E|), Parallelism Θ(1) - sequential search
   41|       |        /// claude-4-sonet: Work Θ(log |E|), Span Θ(log |E|), Parallelism Θ(1)
   41|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   41|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   41|       |        /// claude-4-sonet: Work Θ(n log n), Span Θ(log n), Parallelism Θ(n)
   41|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   41|       |        /// claude-4-sonet: Work Θ(start+length), Span Θ(start+length), Parallelism Θ(1) - sequential copy
   41|       |        /// claude-4-sonet: Work Θ(|S|×|T|), Span Θ(|S|+|T|), Parallelism Θ(min(|S|,|T|))
   41|       |        /// claude-4-sonet: Work Θ(|S|×|T|), Span Θ(|S|+|T|), Parallelism Θ(min(|S|,|T|))
   41|       |        /// claude-4-sonet: Work Θ(u/w), Span Θ(u/w)
   42|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   42|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   42|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   42|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(1)
   42|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(|A|), Parallelism Θ(1) - sequential search
   42|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(1)
   42|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(|E|), Parallelism Θ(1) - sequential search
   42|       |        /// claude-4-sonet: Work Θ(log |E|), Span Θ(log |E|), Parallelism Θ(1)
   42|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   42|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   42|       |        /// claude-4-sonet: Work Θ(log |V| + log |E|), Span Θ(log |V| + log |E|), Parallelism Θ(1)
   42|       |        /// claude-4-sonet: Work Θ(m log(1 + n/m)), Span Θ(log n + log m)
   42|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   42|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   42|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   42|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   42|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   42|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   42|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   42|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))
   42|       |        /// claude-4-sonet: Work Θ(|m|), Span Θ(1)
   42|       |        /// claude-4-sonet: Work Θ(n log n), Span Θ(log² n), Parallelism Θ(n/log² n)
   42|       |        /// claude-4-sonet: Work Θ(n log n), Span Θ(n log n), Parallelism Θ(1)
   42|       |        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   42|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   42|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   42|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   42|       |        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(log n + S(f)), Parallelism Θ(n/(log n + S(f)))
   42|       |        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(n × S(f)), Parallelism Θ(1)
   43|       |    /// claude-4-sonet: Work O((n + m) lg n), Span O(lg² n), Parallelism Θ((n+m)/lg² n)
   43|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   43|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   43|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   43|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   43|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   43|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   43|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   43|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   43|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   43|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   43|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   43|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   43|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   43|       |        /// claude-4-sonet: Work Θ(|a| + |updates|), Span Θ(log |a| + log |updates|)
   43|       |        /// claude-4-sonet: Work Θ(|keys| × W(f)), Span Θ(log |keys| + S(f)), Parallelism Θ(|keys|/(log |keys| + S(f)))
   43|       |        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized with locking
   43|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   43|       |        /// claude-4-sonet: Work Θ(n log n), Span Θ(n log n), Parallelism Θ(1)
   43|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   43|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1) - sequential tree traversal
   44|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   44|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   44|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   44|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   44|       |        /// claude-4-sonet: Work Θ(log |E|), Span Θ(log |E|), Parallelism Θ(1)
   44|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   44|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   44|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   44|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   44|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   44|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   44|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   44|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   44|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   44|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   44|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   44|       |        /// claude-4-sonet: Work Θ(n log n), Span Θ(log n), Parallelism Θ(n)
   44|       |        /// claude-4-sonet: Work Θ(n log n), Span Θ(n log n), Parallelism Θ(1)
   44|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1) - sequential
   44|       |        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(n × S(f)), Parallelism Θ(1)
   44|       |        /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(|V| × log |V|), Parallelism Θ(|E|/|V|)
   45|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   45|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   45|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   45|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   45|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   45|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   45|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   45|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   45|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   45|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1).
   45|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1)
   45|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(|A|), Parallelism Θ(1) - sequential search
   45|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(|A|), Parallelism Θ(1) - sequential search
   45|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(log |A|), Parallelism Θ(|A|/log |A|) - parallel divide-and-conquer in NPlus+NMinus
   45|       |        /// claude-4-sonet: Work Θ(|a| + Σᵢ W(f(aᵢ))), Span Θ(1 + maxᵢ S(f(aᵢ))), Parallelism Θ(|a|)
   45|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(|E|), Parallelism Θ(1) - sequential search
   45|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(|E|), Parallelism Θ(1) - sequential search
   45|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(log |E|), Parallelism Θ(|E|/log |E|) - parallel divide-and-conquer filter
   45|       |        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized with locking
   45|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected with locking
   45|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   45|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   45|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   45|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   45|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   45|       |        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(log n + S(f)), Parallelism Θ(n/(log n + S(f)))
   45|       |        /// claude-4-sonet: Work Θ(|u_set| × |A|), Span Θ(1)
   45|       |        /// claude-4-sonet: Work Θ(|u_set| × |E|), Span Θ(1)
   45|       |        /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(|V|), Parallelism Θ(1)
   46|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   46|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   46|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(|A|), Parallelism Θ(1) - sequential map
   46|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(|A|), Parallelism Θ(1) - sequential search
   46|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(|E|), Parallelism Θ(1) - sequential map
   46|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(|E|), Parallelism Θ(1) - sequential search
   46|       |        /// claude-4-sonet: Work Θ(log n) amortized, Span Θ(log n)
   46|       |        /// claude-4-sonet: Work Θ(log n) average, Span Θ(log n)
   46|       |        /// claude-4-sonet: Work Θ(log n) expected, Span Θ(log n)
   46|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n)
   46|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n)
   46|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n)
   46|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   46|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   46|       |        /// claude-4-sonet: Work Θ(m log(1 + n/m)), Span Θ(log n + log m)
   46|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   46|       |        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   46|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1) - sequential tree traversal
   46|       |        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(log n + S(f)), Parallelism Θ(n/(log n + S(f)))
   46|       |        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(n × S(f)), Parallelism Θ(1)
   46|       |        /// claude-4-sonet: Work Θ((|V| + |E|) log |V|), Span Θ(|V| log |V|), Parallelism Θ(1)
   46|       |        /// claude-4-sonet: Work Θ((|V| + |E|) log |V|), Span Θ(|V| log |V|), Parallelism Θ(1)
   46|       |        /// claude-4-sonet: Work Θ((|V| + |E|) log |V|), Span Θ(|V| log |V|), Parallelism Θ(1)
   47|       |    /// claude-4-sonet: Work O((n+m) lg n), Span O((n+m) lg n)
   47|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   47|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   47|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   47|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1)
   47|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1)
   47|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) - sequential
   47|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(|A|), Parallelism Θ(1) - sequential search
   47|       |        /// claude-4-sonet: Work Θ(|a| + Σᵢ W(f(aᵢ))), Span Θ(|a| + maxᵢ S(f(aᵢ))), Parallelism Θ(1)
   47|       |        /// claude-4-sonet: Work Θ(|a| + Σᵢ W(f(aᵢ))), Span Θ(|a| + maxᵢ S(f(aᵢ))), Parallelism Θ(1)
   47|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(|E|), Parallelism Θ(1) - sequential search
   47|       |        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized, Parallelism Θ(1)
   47|       |        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized with locking
   47|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected with locking
   47|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   47|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   47|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   47|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   47|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   47|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)
   47|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   47|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   47|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   47|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   47|       |        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(log n + S(f)), Parallelism Θ(n/(log n + S(f)))
   47|       |        /// claude-4-sonet: Work Θ(|S|×|T|), Span Θ(|S|+|T|), Parallelism Θ(1)
   47|       |        /// claude-4-sonet: Work Θ(|S|×|T|), Span Θ(|S|+|T|), Parallelism Θ(1)
   47|       |        /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(|V| + |E|), Parallelism Θ(1) - sequential
   47|       |        /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(|V| + |E|), Parallelism Θ(1) - sequential
   48|       |    /// claude-4-sonet: Work O((n+m) lg n), Span O(lg² n), Parallelism Θ((n+m)/lg² n)
   48|       |    /// claude-4-sonet: Work O(n), Span O(n) [DFS is inherently sequential]
   48|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   48|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(1)
   48|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(|A|), Parallelism Θ(1) - sequential filter
   48|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(|E|), Parallelism Θ(1) - sequential filter
   48|       |        /// claude-4-sonet: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|))
   48|       |        /// claude-4-sonet: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|))
   48|       |        /// claude-4-sonet: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|))
   48|       |        /// claude-4-sonet: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|))
   48|       |        /// claude-4-sonet: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|))
   48|       |        /// claude-4-sonet: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|))
   48|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   48|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   48|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   48|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)
   48|       |        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   48|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   48|       |        /// claude-4-sonet: Work Θ(|u_set| × |A|), Span Θ(log |u_set| + log |A|), Parallelism Θ((|u_set| × |A|)/(log |u_set| + log |A|)) - parallel map-reduce
   48|       |        /// claude-4-sonet: Work Θ(|u_set| × |E|), Span Θ(log |u_set| + log |E|), Parallelism Θ((|u_set| × |E|)/(log |u_set| + log |E|)) - parallel map-reduce
   48|       |        /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(|V|), Parallelism Θ(1)
   49|       |    /// claude-4-sonet: Work O(m lg n), Span O(m lg n) [sequential]
   49|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   49|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   49|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   49|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   49|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   49|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   49|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   49|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   49|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(|A|), Parallelism Θ(1) - sequential search
   49|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(log |a|), Parallelism Θ(|a|/log |a|)
   49|       |        /// claude-4-sonet: Work Θ(|a| × W(f)), Span Θ(|a| × S(f)), Parallelism Θ(1)
   49|       |        /// claude-4-sonet: Work Θ(|a| × W(f)), Span Θ(|a| × S(f)), Parallelism Θ(1)
   49|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(|E|), Parallelism Θ(1) - sequential search
   49|       |        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized, Parallelism Θ(1)
   49|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)
   49|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)
   49|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected with locking
   49|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   49|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   49|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   49|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   49|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   49|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   49|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))
   49|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)
   49|       |        /// claude-4-sonet: Work Θ(|S|×|T|), Span Θ(|S|+|T|), Parallelism Θ(min(|S|,|T|))
   49|       |        /// claude-4-sonet: Work Θ(|S|×|T|), Span Θ(|S|+|T|), Parallelism Θ(min(|S|,|T|))
   50|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   50|       |        /// claude-4-sonet: Work Θ(|a|+|b|), Span Θ(|a|+|b|), Parallelism Θ(1) - sequential
   50|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(|A|), Parallelism Θ(1) - sequential map
   50|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(|E|), Parallelism Θ(1) - sequential map
   50|       |        /// claude-4-sonet: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|))
   50|       |        /// claude-4-sonet: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|))
   50|       |        /// claude-4-sonet: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|))
   50|       |        /// claude-4-sonet: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|))
   50|       |        /// claude-4-sonet: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|))
   50|       |        /// claude-4-sonet: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|))
   50|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)
   50|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   50|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   50|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   50|       |        /// claude-4-sonet: Work Θ(m log(1 + n/m)), Span Θ(log(n + m)), Parallelism Θ(m/log(n + m))
   50|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   50|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))
   50|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)
   51|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   51|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   51|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   51|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   51|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   51|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   51|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   51|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1).
   51|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   51|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1) - atomic increment releases next thread
   51|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(1)
   51|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1)
   51|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1)
   51|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(|A|), Parallelism Θ(1) - sequential filter
   51|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(log |a|), Parallelism Θ(|a|/log |a|)
   51|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(log |A|), Parallelism Θ(|A|/log |A|) - parallel divide-and-conquer filter
   51|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(1)
   51|       |        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized, Parallelism Θ(1)
   51|       |        /// claude-4-sonet: Work Θ(log n) average, Θ(n) worst case; Span Θ(log n) average with locking
   51|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)
   51|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)
   51|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   51|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   51|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   51|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   51|       |        /// claude-4-sonet: Work Θ(log(|self| + |other|)), Span Θ(log(|self| + |other|)), Parallelism Θ(1)
   51|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))
   51|       |        /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(|V|), Parallelism Θ(1)
   52|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(log |A|), Parallelism Θ(|A|/log |A|) - parallel divide-and-conquer filter
   52|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(log |E|), Parallelism Θ(|E|/log |E|) - parallel divide-and-conquer filter
   52|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)
   52|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   52|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   52|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   52|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))
   52|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   52|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   52|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   52|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   52|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   52|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   52|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   52|       |        /// claude-4-sonet: Work Θ(|v|), Span Θ(1)
   53|       |    /// claude-4-sonet: Work O(n), Span O(n) [DFS is inherently sequential]
   53|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   53|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   53|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   53|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   53|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1)
   53|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1)
   53|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(log |a|), Parallelism Θ(|a|/log |a|)
   53|       |        /// claude-4-sonet: Work Θ(index), Span Θ(index), Parallelism Θ(1) - sequential traversal
   53|       |        /// claude-4-sonet: Work Θ(length), Span Θ(1)
   53|       |        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized, Parallelism Θ(1)
   53|       |        /// claude-4-sonet: Work Θ(log n) average, Θ(n) worst case; Span Θ(log n) average with locking
   53|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)
   53|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)
   53|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   53|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   53|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   53|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   53|       |        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)
   53|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))
   53|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   53|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   53|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   53|       |        /// claude-4-sonet: Work Θ(Σ |sᵢ|), Span Θ(1)
   54|       |    /// claude-4-sonet: Work O(m), Span O(m) [sequential iteration]
   54|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(|A|), Parallelism Θ(1) - sequential map
   54|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(log |A|), Parallelism Θ(|A|/log |A|) - parallel divide-and-conquer filter
   54|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(|E|), Parallelism Θ(1) - sequential map
   54|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(log |E|), Parallelism Θ(|E|/log |E|) - calls parallel NG
   54|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)
   54|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   54|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   54|       |        /// claude-4-sonet: Work Θ(m log(1 + n/m)), Span Θ(log(n + m)), Parallelism Θ(m/log(n + m))
   54|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)
   54|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   54|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   54|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   54|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   54|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   54|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   54|       |        /// claude-4-sonet: Work Θ(|u_set| × |A|), Span Θ(1)
   54|       |    /// claude-4-sonet: Work Θ(|V| log |V| + |E|), Span Θ(|V| log |V|), Parallelism Θ(1)
   55|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   55|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   55|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(log |A|), Parallelism Θ(|A|/log |A|) - parallel divide-and-conquer filter
   55|       |        /// claude-4-sonet: Work Θ(length), Span Θ(1)
   55|       |        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized, Parallelism Θ(1)
   55|       |        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized with locking
   55|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)
   55|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)
   55|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   55|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   55|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   55|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   55|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))
   55|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   55|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   55|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   55|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   55|       |        /// claude-4-sonet: Work Θ((|V| + |E|) log |V|), Span Θ(|V| log |V|), Parallelism Θ(1)
   55|       |        /// claude-4-sonet: Work Θ(Σᵢ |sᵢ|), Span Θ(Σᵢ |sᵢ|), Parallelism Θ(1)
   55|       |        /// claude-4-sonet: Work Θ(Σᵢ |sᵢ|), Span Θ(Σᵢ |sᵢ|), Parallelism Θ(1)
   56|       |        /// claude-4-sonet: Work Θ(1) amortized per call, Θ(|S|×|T|) total; Span Θ(|S|+|T|)
   56|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) - sequential
   56|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)
   56|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   56|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   56|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)
   56|       |        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   56|       |        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   56|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   56|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   56|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   56|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   56|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   56|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   57|       |        /// claude-4-sonet: Work amortized Θ(1), worst case Θ(n), Span amortized Θ(1), worst case Θ(n)
   57|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   57|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   57|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   57|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(|A|), Parallelism Θ(1) - sequential filter
   57|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(log |a|), Parallelism Θ(|a|/log |a|)
   57|       |        /// claude-4-sonet: Work Θ(|a| + |updates|), Span Θ(|a| + |updates|), Parallelism Θ(1)
   57|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(|E|), Parallelism Θ(1) - sequential filter
   57|       |        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized with locking
   57|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)
   57|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)
   57|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected with locking
   57|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   57|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   57|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   57|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   57|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   57|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))
   57|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   57|       |        /// claude-4-sonet: Work Θ(|S|+|T|), Span Θ(|S|+|T|)
   57|       |        /// claude-4-sonet: Work Θ(|S|+|T|), Span Θ(|S|+|T|)
   57|       |        /// claude-4-sonet: Work Θ(|u_set| × |A|), Span Θ(1)
   57|       |        /// claude-4-sonet: Work Θ(|u_set| × |A|), Span Θ(log |u_set| + log |A|), Parallelism Θ((|u_set| × |A|)/(log |u_set| + log |A|)) - parallel map-reduce
   57|       |        /// claude-4-sonet: Work Θ(W_action + 1), Span Θ(S_action + 1), Parallelism Θ(W_action/S_action) - dominated by action complexity
   58|       |        /// claude-4-sonet: Work Θ(1) amortized per call, Θ(|S|×|T|) total; Span Θ(|S|+|T|)
   58|       |        /// claude-4-sonet: Work Θ(1) amortized per call, Θ(|S|×|T|) total; Span Θ(|S|+|T|)
   58|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   58|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   58|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   58|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   58|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   58|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   58|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   58|       |        /// claude-4-sonet: Work Θ(m log(1 + n/m)), Span Θ(log(n + m)), Parallelism Θ(m/log(n + m))
   58|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   58|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   58|       |    /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(|V|), Parallelism Θ(1)
   59|       |        /// claude-4-sonet: Work Θ(1) amortized per call, Θ(|S|×|T|) total; Span Θ(|S|+|T|)
   59|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   59|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(1)
   59|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) - sequential
   59|       |        /// claude-4-sonet: Work Θ(|a| + |updates|), Span Θ(|a| + |updates|), Parallelism Θ(1)
   59|       |        /// claude-4-sonet: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|)), Parallelism Θ(1)
   59|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected with locking
   59|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   59|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   59|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking
   59|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   59|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   59|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   59|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   59|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   59|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   59|       |        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(log n + S(f)), Parallelism Θ(n/(log n + S(f)))
   59|       |        /// claude-4-sonet: Work Θ(n + Σᵢ W(f(i))), Span Θ(1 + maxᵢ S(f(i))), Parallelism Θ(n)
   59|       |        /// claude-4-sonet: Work Θ(Σ |sᵢ|), Span Θ(log(Σ |sᵢ|))
   60|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   60|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   60|       |        /// claude-4-sonet: Work Θ(log(|self| + |other|)), Span Θ(log(|self| + |other|)), Parallelism Θ(1)
   60|       |        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))
   60|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   60|       |        /// claude-4-sonet: Work Θ(|S|+|T|), Span Θ(|S|+|T|)
   60|       |        /// claude-4-sonet: Work Θ(|S|+|T|), Span Θ(|S|+|T|)
   60|       |        /// claude-4-sonet: Work Θ(|u_set| × |A|), Span Θ(log |u_set| + log |A|), Parallelism Θ((|u_set| × |A|)/(log |u_set| + log |A|)) - parallel map-reduce
   61|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   61|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   61|       |        /// claude-4-sonet: Work Θ(|a|²) worst case, Span Θ(|a|²) worst case
   61|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(log |A|), Parallelism Θ(|A|/log |A|) - parallel divide-and-conquer filter
   61|       |        /// claude-4-sonet: Work Θ(|a| + Σₓ W(f(x))), Span Θ(1 + maxₓ S(f(x))), Parallelism Θ(|a|)
   61|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(log |E|), Parallelism Θ(|E|/log |E|) - parallel divide-and-conquer filter
   61|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   61|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   61|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   61|       |        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   61|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   61|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   61|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   61|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   61|       |    /// claude-4-sonet: Work Θ(|V| log |V| + |E|), Span Θ(|V| log |V|), Parallelism Θ(1)
   61|       |    /// claude-4-sonet: Work Θ(|V| log |V| + |E|), Span Θ(|V| log |V|), Parallelism Θ(1)
   62|       |    /// claude-4-sonet: Work O(m), Span O(log m) [parallel reduce with ParaPair!]
   62|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   62|       |        /// claude-4-sonet: Work Θ(|a|+|updates|), Span Θ(|a|+|updates|), Parallelism Θ(1) - sequential with HashSet
   62|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   62|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   62|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   62|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   62|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   62|       |    /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(|V| × log |V|), Parallelism Θ(|E|/|V|)
   63|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   63|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   63|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(1)
   63|       |        /// claude-4-sonet: Work Θ(|a| + Σᵢ W(f(aᵢ))), Span Θ(1 + maxᵢ S(f(aᵢ))), Parallelism Θ(|a|)
   63|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   63|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   64|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   64|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   64|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   64|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   64|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   64|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   64|       |        /// claude-4-sonet: Work Θ(n log n), Span Θ(n log n), Parallelism Θ(1)
   65|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   65|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   65|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(log |A|), Parallelism Θ(|A|/log |A|) - parallel divide-and-conquer filter
   65|       |        /// claude-4-sonet: Work Θ(|a|+|updates|), Span Θ(|a|+|updates|), Parallelism Θ(1) - sequential, overwrites on conflict
   65|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(log |E|), Parallelism Θ(|E|/log |E|) - parallel divide-and-conquer filter
   65|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   65|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   65|       |        /// claude-4-sonet: Work Θ(n log n), Span Θ(log² n), Parallelism Θ(n/log n)
   65|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   65|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   65|       |        /// claude-4-sonet: Work Θ(|values| + |changes|), Span Θ(log |values| + log |changes|)
   65|       |    /// claude-4-sonet: Work Θ(|V| log |V| + |E|), Span Θ(|V| log |V|), Parallelism Θ(1)
   66|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(1)
   66|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(log |A|), Parallelism Θ(|A|/log |A|) - calls parallel InDegree + OutDegree
   66|       |        /// claude-4-sonet: Work Θ(|base| + |updates|), Span Θ(|base| + |updates|), Parallelism Θ(1)
   66|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   66|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   66|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   67|       |        /// claude-4-sonet: Work Θ(|changes|), Span Θ(log |changes|)
   67|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   67|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   67|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   68|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   68|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) - sequential fold
   68|       |        /// claude-4-sonet: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|)), Parallelism Θ(1)
   68|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   68|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   68|       |        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   69|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   69|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(1)
   69|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(log |A|), Parallelism Θ(|A|/log |A|) - calls parallel NMinus
   69|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   69|       |    /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(|V|), Parallelism Θ(1)
   70|       |        /// claude-4-sonet: Work Θ(1) expected under low contention, Θ(n) worst case with n concurrent pushes, Span Θ(1), Parallelism Θ(1) - CAS retry loop
   70|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   70|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(|A|), Parallelism Θ(1) - sequential filter
   70|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   70|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   70|       |    /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(|V|), Parallelism Θ(1)
   71|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   71|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) - sequential prefix computation
   71|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(|A|), Parallelism Θ(1) - sequential search
   71|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(|E|), Parallelism Θ(1) - sequential search
   71|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   71|       |        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   71|       |    /// claude-4-sonet: Work Θ(|V| log |V| + |E|), Span Θ(|V| log |V|), Parallelism Θ(1)
   72|       |    /// claude-4-sonet: Work O(m lg n), Span O(m lg n) [sequential]
   72|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(log |A|), Parallelism Θ(|A|/log |A|) - calls parallel NPlus
   72|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(|E|), Parallelism Θ(1) - sequential sum
   72|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   72|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   72|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   72|       |    /// claude-4-sonet: Work Θ(|V| log |V| + |E|), Span Θ(|V| log |V|), Parallelism Θ(1)
   72|       |    /// claude-4-sonet: Work Θ(|V| log |V| + |E|), Span Θ(|V| log |V|), Parallelism Θ(1)
   73|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   73|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(1)
   73|       |        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   74|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   74|       |        /// claude-4-sonet: Work Θ(log(|self| + |other|)), Span Θ(log(|self| + |other|)), Parallelism Θ(1)
   74|       |    /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(|V| × log |V|), Parallelism Θ(|E|/|V|)
   75|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1) - just wraps vector
   75|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   76|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   77|       |    /// claude-4-sonet: Work O((n+m) lg n), Span O((n+m) lg n)
   77|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(1)
   78|       |    /// claude-4-sonet: Work O(m), Span O(m)
   78|       |    /// claude-4-sonet: Work O((n+m) lg n), Span O(lg² n), Parallelism Θ((n+m)/lg² n)
   78|       |        /// claude-4-sonet: Work O(α(n)), Span O(α(n)) amortized
   78|       |        /// claude-4-sonet: Work Θ(|a|log|a|), Span Θ(|a|log|a|), Parallelism Θ(1) - sequential divide-and-conquer (no parallelism)
   78|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(|A|), Parallelism Θ(1) - sequential map
   78|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(|E|), Parallelism Θ(1) - sequential map
   80|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1) - just unwraps
   80|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)
   80|       |        /// claude-4-sonet: Work Θ(min(|S|,|T|)), Span Θ(1), Parallelism Θ(min(|S|,|T|))
   80|       |        /// claude-4-sonet: Work Θ(min(|S|,|T|)), Span Θ(1), Parallelism Θ(min(|S|,|T|))
   80|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1) - sequential
   81|       |        /// claude-4-sonet: Work Θ(|a|²), Span Θ(|a|²), Parallelism Θ(1) - naive scan calling reduce repeatedly
   81|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(1)
   81|       |    /// claude-4-sonet: Work Θ(t × i) where t=threads, i=iterations, Span Θ(i) assuming bounded contention, Parallelism Θ(t) - linear speedup under low contention
   81|       |    /// claude-4-sonet: Work Θ(|V| + |E|), Span Θ(|V|), Parallelism Θ(1)
   82|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   82|       |    /// claude-4-sonet: Work Θ(|V| log |V| + |E|), Span Θ(|V| log |V|), Parallelism Θ(1)
   83|       |    /// claude-4-sonet: Work O(m), Span O(lg m), Parallelism Θ(m/lg m)
   83|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   83|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(|A|), Parallelism Θ(1) - sequential sum
   84|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   84|       |        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with parallel reduce_val, Parallelism Θ(n/log n)
   84|       |        /// claude-4-sonet: Work Θ(Σ|ss[i]|), Span Θ(Σ|ss[i]|), Parallelism Θ(1) - sequential
   85|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1) - reference operation
   86|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1)
   86|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   87|       |        /// claude-4-sonet: Work Θ(|a|²), Span Θ(|a|²), Parallelism Θ(1) - sequential with linear search
   88|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n)
   89|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   89|       |        /// claude-4-sonet: Work Θ(|A|), Span Θ(|A|), Parallelism Θ(1) - sequential filter
   89|       |        /// claude-4-sonet: Work Θ(|E|), Span Θ(|E|), Parallelism Θ(1) - sequential filter
    8|       |        /// claude-4-sonet: Work Θ(n²), Span Θ(n²), Parallelism Θ(1)
   90|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   90|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)
   92|       |        /// claude-4-sonet: Work Θ(1), Span Θ(1), Parallelism Θ(1)
   92|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)
   94|       |        /// claude-4-sonet: Work Θ(1) expected under low contention, Θ(n) worst case with n concurrent pops, Span Θ(1), Parallelism Θ(1) - CAS retry loop
   94|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)
   95|       |    /// claude-4-sonet: Work O(|MST|), Span O(|MST|)
   95|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1) - sequential
   95|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1) - sequential split and copy
   96|       |        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)
   97|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1) - sequential
   98|       |        /// claude-4-sonet: Work Θ(|a|), Span Θ(|a|), Parallelism Θ(1) - sequential
   98|       |        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)
   15|       |        /// claude-4-sonnet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   18|       |        /// claude-4-sonnet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   24|       |        /// claude-4-sonnet: Work Θ(n³), Span Θ(log n), Parallelism Θ(n³/log n)
   25|       |        /// claude-4-sonnet: Work Θ(n²), Span Θ(log n), Parallelism Θ(n²/log n)
   65|       |        /// claude-4-sonnet: Work Θ(n log n), Span Θ(log² n), Parallelism Θ(n/log n)
   66|       |        /// claude-4-sonnet: Work Θ(n log n), Span Θ(log² n), Parallelism Θ(n/log n)
   72|       |        /// claude-4-sonnet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   73|       |        /// claude-4-sonnet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)
   50|       |        /// Claude Span: O(|S|+|T|) - maximum recursion depth, parallelism O(min(|S|,|T|))
   50|       |        /// Claude Work: O(1) - constant time construction
   50|       |        /// Claude Work: O(log min(a,b)), Span: O(log min(a,b))
   50|       |        /// Claude Work: Θ(log m + log n), Span: Θ(log m + log n)
   51|       |        /// Claude Span: O(1) - constant time construction
   51|       |        /// Claude Work: Θ(1), Span: Θ(1)
   52|       |        /// Claude Work: Θ(m), Span: Θ(m) where m is table size
   53|       |        /// Claude Work: O(k*|S|) - each subproblem computed once
   53|       |        /// Claude Work: O(n³) - O(n²) subproblems, each O(n) work
   53|       |        /// Claude Work: Θ(1) expected, Span: Θ(1) expected
   53|       |        /// Claude Work: Θ(1), Span: Θ(1)
   53|       |        /// Claude Work: Θ(1), Span: Θ(1)
   53|       |        /// Claude Work: Θ(1), Span: Θ(1)
   54|       |        /// Claude Span: O(n²) - maximum recursion depth O(n), each level O(n) work
   54|       |        /// Claude Span: O(|S|) - maximum recursion depth
   54|       |        /// Claude Work: O(n), Span: O(log n)
   54|       |        /// Claude Work: Θ(n), Span: Θ(n)
   55|       |        /// Claude Work: O(k*|S|) - each subproblem computed once across all threads
   55|       |        /// Claude Work: O(log min(h2_value, table_size)), Span: O(log min(h2_value, table_size))
   56|       |        /// Claude Span: O(|S|) - maximum recursion depth, parallelism O(k)
   56|       |        /// Claude Work: O(n) - n comparisons
   57|       |        /// Claude Span: O(log n) - parallel reduction tree
   60|       |        /// Claude Work: O(n³) - O(n²) subproblems, each O(n) work
   60|       |        /// Claude Work: O(n log n), Span: O(log² n)
   60|       |        /// Claude Work: Θ(1), Span: Θ(1)
   60|       |        /// Claude Work: Θ(1), Span: Θ(1)
   60|       |        /// Claude Work: Θ(1), Span: Θ(1)
   60|       |        /// Claude Work: Θ(1), Span: Θ(1)
   60|       |        /// Claude Work: Θ(|string|), Span: Θ(|string|)
   61|       |        /// Claude Span: O(n²) - maximum recursion depth O(n), each level O(n) work
   61|       |        /// Claude Work: O(|S|*|T|) - each subproblem computed once
   61|       |    /// Claude Work: Θ(1), Span: Θ(1)
   61|       |    /// Claude Work: Θ(n²), Span: Θ(n²) - inefficient due to O(n) insert
   62|       |        /// Claude Span: O(|S|+|T|) - maximum recursion depth
   62|       |        /// Claude Work: O(n) - n comparisons
   63|       |        /// Claude Span: O(log n) - parallel reduction tree
   63|       |        /// Claude Work: O(n log log n), Span: O(n log log n)
   65|       |        /// Claude Work: O(n³) - O(n²) subproblems, each O(n) work
   65|       |        /// Claude Work: O(n) - n comparisons
   65|       |        /// Claude Work: O(|S|*|T|) - each subproblem computed once across all threads
   66|       |        /// Claude Span: O(log n) - parallel reduction tree
   66|       |        /// Claude Span: O(n²) - maximum recursion depth O(n), each level O(n) work
   66|       |        /// Claude Span: O(|S|+|T|) - maximum recursion depth, parallelism O(min(|S|,|T|))
   67|       |        /// Claude Work: Θ(1), Span: Θ(1)
   67|       |    /// Claude: Work Θ(|E| × avg_degree), Span Θ(|E| × avg_degree), Parallelism Θ(1) - sequential baseline
   67|       |        /// Claude Work: Θ(log n), Span: Θ(log n)
   67|       |        /// Claude Work: Θ(n), Span: Θ(n)
   69|       |        /// Claude Work: 1/(1-α) expected, Span: 1/(1-α) expected
   69|       |        /// Claude Work: Θ(min(max_probes, m)), Span: Θ(min(max_probes, m))
   70|       |        /// Claude Work: Θ(1), Span: Θ(1)
   72|       |        /// Claude Work: O(n³) - O(n²) subproblems, each O(n) work
   72|       |        /// Claude Work: O(n) - n comparisons
   73|       |        /// Claude Span: O(log n) - parallel reduction tree
   73|       |        /// Claude Span: O(n²) - maximum recursion depth O(n), each level O(n) work
   74|       |        /// Claude Work: Θ(√m), Span: Θ(√m)
   75|       |        /// Claude Work: O(1), Span: O(1)
   76|       |        /// Claude Work: O(1), Span: O(1)
   77|       |        /// Claude Work: O(1), Span: O(1)
   77|       |        /// Claude Work: O(min(|S|,|T|)) - diagonal length
   77|       |        /// Claude Work: O(min(|S|,|T|)) - diagonal length
   77|       |        /// Claude Work: Θ(n), Span: Θ(n)
   78|       |        /// Claude Span: O(min(|S|,|T|)) - sequential diagonal computation
   78|       |        /// Claude Span: O(min(|S|,|T|)) - sequential diagonal computation
   78|       |        /// Claude Work: O(1), Span: O(1)
   78|       |        /// Claude Work: Θ(log n), Span: Θ(log n)
   79|       |        /// Claude Work: O(1), Span: O(1)
   79|       |        /// Claude Work: Θ(1), Span: Θ(1)
   79|       |    /// Claude Work: Θ(n log n), Span: Θ(n log n) - optimal complexity
   80|       |        /// Claude Work: O(1), Span: O(1)
   81|       |        /// Claude Work: O(1), Span: O(1)
   81|       |        /// Claude Work: O(1), Span: O(1)
   82|       |        /// Claude Work: O(log min(h2_value, table_size)), Span: O(log min(h2_value, table_size))
   84|       |        /// Claude Work: O(1), Span: O(1)
   84|       |        /// Claude Work: O(1), Span: O(1)
   84|       |        /// Claude Work: O(1), Span: O(1)
   84|       |        /// Claude Work: O(log n), Span: O(log n)
   84|       |        /// Claude Work: O(n³) - O(n²) subproblems, each O(n) work
   84|       |        /// Claude Work: Θ(1), Span: Θ(1)
   85|       |        /// Claude Span: O(n log n) - maximum recursion depth O(n), each level O(log n) parallel reduction
   86|       |        /// Claude Work: O(1), Span: O(1)
   87|       |        /// Claude Work: O(1), Span: O(1)
   87|       |        /// Claude Work: O(1), Span: O(1)
   87|       |        /// Claude Work: O(1), Span: O(1)
   87|       |        /// Claude Work: O(1), Span: O(1)
   87|       |        /// Claude Work: O(n), Span: O(log n)
   88|       |        /// Claude Work: Θ(m), Span: Θ(m) where m is table size
   89|       |        /// Claude Work: O(1), Span: O(1)
   90|       |        /// Claude Work: O(1), Span: O(1)
   90|       |        /// Claude Work: O(1), Span: O(1)
   90|       |        /// Claude Work: O(n³) - O(n²) subproblems, each O(n) work
   90|       |        /// Claude Work: Θ(|string|), Span: Θ(|string|)
   91|       |        /// Claude Span: O(n log n) - maximum recursion depth O(n), each level O(log n) parallel reduction
   91|       |        /// Claude Work: O(1) - constant time access
   91|       |        /// Claude Work: O(m * log m), Span: O(m * log m) where m is table_size
   92|       |        /// Claude Span: O(1) - constant time access
   92|       |        /// Claude Work: O(1), Span: O(1)
   93|       |        /// Claude Work: O(1), Span: O(1)
   93|       |        /// Claude Work: O(log n), Span: O(log n)
   93|       |        /// Claude Work: O(n³) - O(n²) subproblems, each O(n) work
   93|       |        /// Claude Work: Θ(n), Span: Θ(n)
   94|       |        /// Claude Span: O(n log n) - maximum recursion depth O(n), each level O(log n) parallel reduction
   94|       |        /// Claude Work: O(1) - constant time update
   94|       |        /// Claude Work: O(1), Span: O(1)
   94|       |        /// Claude Work: O(1), Span: O(1)
   94|       |        /// Claude Work: O(log n), Span: O(log n)
   95|       |        /// Claude Span: O(1) - constant time update
   96|       |        /// Claude Work: O(1) - constant time lookup
   96|       |        /// Claude Work: O(1) - constant time per cell
   96|       |        /// Claude Work: O(log n), Span: O(log n)
   97|       |        /// Claude Span: O(1) - constant time lookup
   97|       |        /// Claude Span: O(1) - constant time per cell
   97|       |        /// Claude Work: O(1), Span: O(1)
   97|       |        /// Claude Work: O(1), Span: O(1)
   97|       |        /// Claude Work: O(log n), Span: O(log n)
   97|       |        /// Claude Work: O(n), Span: O(log n)
   97|       |    /// Claude Work: Θ(n log n), Span: Θ(n log n) - optimal complexity
   98|       |        /// Claude Work: O(1) - constant time per cell
   99|       |        /// Claude Span: O(1) - constant time per cell
   99|       |        /// Claude Work: O(1), Span: O(1)
  111|       |            // Clear memo for fresh computation
  116|       |            // Clear memo for fresh computation
  120|       |            // Clear memo for fresh computation
  124|       |            // Clear memo for fresh computation
  124|       |            // Clear memo since multiset changed
  125|       |        /// Clear memoization table
  130|       |            // Clear memo for fresh computation
  132|       |            // Clear memo for fresh computation
  134|       |        /// Clear memoization table
  135|       |            // Clear memo since source changed
  136|       |            // Clear memo for fresh computation
  140|       |            // Clear memo for fresh computation
  141|       |            // Clear memo since target changed
  146|       |            // Clear memo since multiset changed
  147|       |            // Clear memo since keys changed
  151|       |            // Clear memo since dimensions changed
  155|       |            // Clear memo since probabilities changed
  160|       |            // Clear memo since dimensions changed
  162|       |            // Clear memo since source changed
  163|       |            // Clear memo for fresh computation
  165|       |            // Clear current edges and re-add with scaled weights
  167|       |            // Clear memo for fresh computation
  169|       |            // Clear memo since target changed
  178|       |            // Clear memo for fresh computation
  184|       |            // Clear memo for fresh computation
  197|       |            // Clear memo since dimensions changed
  203|       |            // Clear memo since keys changed
  208|       |            // Clear memo since dimensions changed
  209|       |        /// Clear memoization table
  213|       |            // Clear memo since probabilities changed
  214|       |        /// Clear memoization table
  220|       |            // Clear current set (ephemeral behavior)
  274|       |            // Clear current table (ephemeral behavior)
  295|       |            // Clear current set (ephemeral behavior)
  351|       |            // Clear current table (ephemeral behavior)
   44|       |        /// Clear memoization table
   46|       |        /// Clear memoization table
   52|       |        /// Clear memoization table
   53|       |        /// Clear memoization table
   54|       |        /// Clear memoization table
   56|       |        /// Clear memoization table
   56|       |        /// Clear memoization table
   56|       |        /// Clear memoization table
  128|      2|        fn clear_memo(&mut self) { self.memo.clear(); }
  145|      3|        fn clear_memo(&mut self) { self.memo.clear(); }
  151|      1|        fn clear_memo(&mut self) {
  161|      2|        fn clear_memo(&mut self) { self.memo.clear(); }
  166|      1|        fn clear_memo(&mut self) { self.memo.clear(); }
  174|      1|        fn clear_memo(&mut self) {
  218|      1|        fn clear_memo(&mut self) {
  223|      1|        fn clear_memo(&mut self) {
   45|       |        fn clear_memo(&mut self);
   47|       |        fn clear_memo(&mut self);
   53|       |        fn clear_memo(&mut self);
   54|       |        fn clear_memo(&mut self);
   55|       |        fn clear_memo(&mut self);
   57|       |        fn clear_memo(&mut self);
   57|       |        fn clear_memo(&mut self);
   57|       |        fn clear_memo(&mut self);
  100|       |            T: Clone;
  102|     10|            T: Clone,
  103|     82|            X: Clone,
  104|     82|            Y: Clone,
  106|       |            T: Clone;
  109|       |    impl<T: Clone> ArraySeqS<T> {
   10|       |    #[derive(Debug, Clone)]
   10|       |    #[derive(Debug, Clone)]
   10|       |    #[derive(Debug, Clone)]
   10|       |    #[derive(PartialEq, Clone, Debug)]
  115|      1|            T: Clone,
  117|  44.2k|            T: Clone,
   11|       |    #[derive(PartialEq, Clone, Debug)]
   11|       |    #[derive(PartialEq, Clone, Debug)]
   11|       |    #[derive(PartialEq, Clone, Debug)]
   11|       |    #[derive(PartialEq, Clone, Debug)]
  128|     11|            T: Clone,
   12|       |    #[derive(Debug, Clone)]
   12|       |    #[derive(Debug, Clone)]
   12|       |    #[derive(Debug, Clone)]
   12|       |    #[derive(Debug, Clone)]
   12|       |    #[derive(Debug, Clone)]
   12|       |    #[derive(Debug, Clone)]
   12|       |    #[derive(Debug, Clone, Default)]
   12|       |    #[derive(Debug, Clone, PartialEq)]
   12|       |    #[derive(Debug, Clone, PartialEq)]
  145|       |    #[derive(Debug, Clone, PartialEq)]
   14|       |    #[derive(Debug, Clone)]
   14|       |    #[derive(Debug, Clone)]
   14|       |    #[derive(Debug, Clone)]
   14|       |    #[derive(Debug, Clone)]
   14|       |    #[derive(PartialEq, Clone)]
   14|       |    #[derive(PartialEq, Clone)]
  157|      1|            T: Clone + PartialEq,
  157|      5|            T: Clone,
   15|       |    #[derive(Debug, Clone, PartialEq)]
   16|       |    #[derive(PartialEq, Clone)]
  184|       |    impl<T: Clone> ArraySeq<T> for ArraySeqS<T> {
  185|       |            T: Clone;
  187|      1|            T: Clone,
   18|       |    #[derive(Debug, Clone)]
  199|      0|            T: Clone,
   19|       |    #[derive(Debug, Clone)]
   20|       |    #[derive(PartialEq, Clone)]
  210|      0|            T: Clone,
  229|     12|            T: Clone + Eq,
   22|       |            T: Clone;
  230|      0|            T: Clone,
  239|      0|            T: Clone,
   23|       |    #[derive(PartialEq, Clone)]
   23|       |    #[derive(PartialEq, Clone, Debug)]
   24|       |    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
  250|       |    #[derive(Debug, Clone)]
  254|      1|            T: Clone,
   25|       |    #[derive(Debug, Clone)]
   27|      1|            T: Clone,
   27|       |    #[derive(Debug, Clone)]
   27|       |            T: Clone;
   29|     49|            T: Clone,
   31|       |    #[derive(Debug, Clone)]
   32|       |    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
   33|       |    #[derive(Debug, Clone)]
   33|       |    #[derive(Debug, Clone)]
   33|       |    #[derive(Debug, Clone)]
   33|       |    #[derive(Debug, Clone)]
   33|       |    #[derive(Debug, Clone)]
   33|       |    #[derive(Debug, Clone)]
   35|       |    #[derive(Debug, Clone)]
   35|       |    #[derive(Debug, Clone)]
   35|       |    #[derive(Debug, Clone)]
   36|       |            X: Clone;
   38|       |    #[derive(Debug, Clone)]
   39|       |    #[derive(Debug, Clone)]
   41|       |    #[derive(Debug, Clone)]
   42|       |    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
   42|       |            Y: Clone;
   48|       |            X: Clone,
   49|       |            Y: Clone;
   50|       |    #[derive(Debug, Clone)]
   56|       |            T: Clone;
   60|       |    #[derive(Debug, Clone)]
   64|       |    #[derive(Debug, Clone)]
   73|       |    #[derive(Debug, Clone)]
   81|     10|            X: Clone,
   83|       |            T: Clone + Eq;
   92|     10|            Y: Clone,
   99|      0|            T: Clone,
    9|       |    #[derive(Debug, Clone, PartialEq)]
  126|      1|        fn clone_mt(&self) -> Self {
  135|      1|        fn clone_mt(&self) -> Self { self.clone() }
  142|  1.29k|        fn clone_mt(&self) -> Self { *self }
  148|      1|        fn clone_mt(&self) -> Self { *self }
  154|  65.3k|        fn clone_mt(&self) -> Self { *self }
  160|      1|        fn clone_mt(&self) -> Self { *self }
  166|      1|        fn clone_mt(&self) -> Self { *self }
  172|      1|        fn clone_mt(&self) -> Self { *self }
  178|      1|        fn clone_mt(&self) -> Self { *self }
  184|      1|        fn clone_mt(&self) -> Self { *self }
  191|      1|        fn clone_mt(&self) -> Self { self.clone() }
  198|      1|        fn clone_mt(&self) -> Self { *self }
   67|       |        fn clone_mt(&self) -> Self;
  182|    233|        fn clone(&self) -> Self {
  190|  5.80k|        fn clone(&self) -> Self {
  209|    642|        fn clone(&self) -> Self {
  226|  5.81k|        fn clone(&self) -> Self {
  253|     11|        fn clone(&self) -> Self {
  272|    494|        fn clone(&self) -> Self {
  281|      1|        fn clone(&self) -> Self {
  303|      0|        fn clone(&self) -> Self {
  343|      1|        fn clone(&self) -> Self {
  356|    233|        fn clone(&self) -> Self {
  359|      2|        fn clone(&self) -> Self {
  369|      9|        fn clone(&self) -> Self {
  387|      4|        fn clone(&self) -> Self {
   64|  1.42k|        fn clone(&self) -> Self {
   86|  1.03k|        fn clone(&self) -> Self { ArraySeqMtEphS::from_vec(self.to_vec()) }
   90|     25|        fn clone(&self) -> Self {
   40|       |        for ClosurePriority<V, P, F>
  151|      1|        let club_results = doc_set_to_sorted_vec(&examples.search_club());
  153|      1|        if club_results != expected_club {
  193|     33|                pattern.push_str(&format!("Final cluster of {} consecutive positions", consecutive_count));
  145|       |            // Clustering coefficient: how much clustering deviates from uniform distribution
  241|      0|            writeln!(f, "Clustering Analysis:")?;
   38|       |    /// Clustering Severity Classification
   48|       |    /// Clustering Comparison Results
   60|       |    /// Clustering Analysis Engine
  262|      2|        let clustering_analysis = "Linear probing exhibits primary clustering where keys that hash to the same \
  296|      2|        let clustering_analysis = "Quadratic probing with prime table size avoids primary clustering by using \
  331|      2|        let clustering_analysis = "Double hashing uses h_i(k) = (h₁(k) + i·h₂(k)) mod m where h₁ and h₂ are \
  362|      2|        let clustering_analysis = "Comparison shows: (1) Linear probing creates consecutive probe sequences leading \
   37|       |        pub clustering_analysis: String,
    5|       |pub mod ClusteringAnalysis {
   68|       |    impl ClusteringAnalyzer {
  147|      4|            let clustering_coefficient = if expected_avg_cluster_size > 0.0 {
   26|       |        pub clustering_coefficient: f64,
  276|     19|                let clustering_penalty = m.clustering_coefficient * 50.0;
  369|      1|                performance_impact: ClusteringPerformanceImpact {
  113|     19|            let clustering_score = self.calculate_linear_clustering_score(&primary_clustering, load_factor);
  124|     19|                overall_clustering_score: clustering_score,
  155|     16|            let clustering_score = self.calculate_quadratic_clustering_score(&secondary_clustering, load_factor);
  166|     16|                overall_clustering_score: clustering_score,
  193|     16|            let clustering_score = self.calculate_double_hashing_score(&double_hashing_quality, load_factor);
  204|     16|                overall_clustering_score: clustering_score,
   34|       |        pub clustering_severity: ClusteringSeverity,
  340|       |                | ClusteringSeverity::Critical => {
  335|     47|                | ClusteringSeverity::Minimal => "Current configuration is optimal".to_string(),
  372|      1|                    clustering_severity: ClusteringSeverity::Minimal,
  336|       |                | ClusteringSeverity::Moderate => {
  339|      0|                | ClusteringSeverity::Severe => "Switch to double hashing or resize table".to_string(),
  126|     21|            if clusters.is_empty() {
  262|      6|                    if cmp(&group.0, &key) == O::Equal {
  232|      6|                    if cmp(&key, &group.0) == O::Equal {
  303|      2|                    if cmp(&key, &group.0) == O::Equal {
  361|      7|                    if cmp(&key, &group.0) == O::Equal {
   41|     38|        fn cmp(&self, other: &Self) -> Ordering {
   41|     63|        fn cmp(&self, other: &Self) -> Ordering {
   53|     29|        fn cmp(&self, other: &Self) -> Ordering { self.priority.cmp(&other.priority) }
   73|    632|        fn cmp(&self, other: &Self) -> Ordering {
   83|      1|                issues.push("c2 coefficient is zero (reduces to linear probing)".to_string());
  117|       |        // Coin flips for all vertices
  139|       |        // Coin flips (sequential for consistent seed)
  160|     34|        let coins1 = edge_coins.clone();
  163|     34|        let coins2 = edge_coins;
   61|      4|        let coins = flip_coins_parallel(&edges_seq, &mut rng);
  111|       |            // Collect results from all threads FIRST (without holding lock)
  111|       |            // Collect results from all threads FIRST (without holding lock)
  162|       |        /// Collect in-order values to Vec.
  163|       |        /// Collect in-order values to Vec.
  180|       |        // Collect new MST labels from partition
  199|       |            // Collect results serially
  247|       |        // Collect new MST labels from partition
   58|       |            // Collect edges from partition map (vertex → center edges)
   88|       |            // Collect diagonal positions
   88|       |            // Collect diagonal positions
  151|       |        fn collect(a: &ArraySeqMtEphS<Pair<T, T>>, cmp: fn(&T, &T) -> O) -> ArraySeqMtEphS<Pair<T, ArraySeqMtEphS<T>>>;
  181|       |        fn collect(a: &ArraySeqMtPerS<Pair<T, T>>, cmp: fn(&T, &T) -> O) -> ArraySeqMtPerS<Pair<T, ArraySeqMtPerS<T>>>;
  233|       |        fn collect<A: StT, Bv: StT>(
  261|      1|        fn collect(a: &ArraySeqMtPerS<Pair<T, T>>, cmp: fn(&T, &T) -> O) -> ArraySeqMtPerS<Pair<T, ArraySeqMtPerS<T>>> {
  294|      1|        fn collect(a: &ArraySeqMtEphS<Pair<T, T>>, cmp: fn(&T, &T) -> O) -> ArraySeqMtEphS<Pair<T, ArraySeqMtEphS<T>>> {
  352|      2|        fn collect(a: &ArraySeqMtPerS<Pair<T, T>>, cmp: fn(&T, &T) -> O) -> ArraySeqMtPerS<Pair<T, ArraySeqMtPerS<T>>> {
  357|      2|        fn collect<A: StT, Bv: StT>(
  396|      2|        fn collect<A: StT, Bv: StT>(
   62|       |        fn collect(a: &ArraySeqMtPerS<Pair<T, T>>, cmp: fn(&T, &T) -> O) -> ArraySeqMtPerS<Pair<T, ArraySeqMtPerS<T>>>;
   88|       |        fn collect<A: StT, Bv: StT>(
  269|      3|            let collected: Vec<Pair<K, ArraySeqStEphS<V>>> = groups
   30|       |    /// collecting all edges from star partitions.
  134|     72|        fn collect_in_order(tree: &Self, out: &mut Vec<T>) {
  271|  1.27k|        fn collect_in_order(tree: &Self, out: &mut Vec<T>) {
  274|      0|        fn collect_in_order(tree: &Self, out: &mut Vec<T>) {
  286|      1|3. statistics Collection:
  123|       |        fn collect<K: StT, V: StT>(
  162|       |        fn collect<K: StT, V: StT>(
  220|      3|        fn collect<K: StT, V: StT>(
  254|      3|        fn collect<K: StT, V: StT>(
  279|      1|        fn collect<K: Clone + Eq, V: Clone>(
   88|       |        fn collect<K: Clone + Eq, V: Clone>(
  161|     18|        fn collect_keys(link: &Link<K, V>, out: &mut Vec<K>) {
  234|    116|        fn collect_keys(link: &Link<K, V, R>, out: &mut Vec<K>) {
  178|     96|        fn collect(&self) -> AVLTreeSeqStPerS<Pair<K, V>> {
  191|    116|        fn collect(&self) -> AVLTreeSeqStPerS<Pair<K, V>> {
  213|      1|        fn collect(&self) -> AVLTreeSeqStPerS<Pair<K, V>> { self.base_table.collect() }
  220|    149|        fn collect(&self) -> AVLTreeSeqStPerS<Pair<K, V>> {
  226|      1|        fn collect(&self) -> AVLTreeSeqStPerS<Pair<K, V>> { self.base_table.collect() }
  247|      1|        fn collect(&self) -> AVLTreeSeqStPerS<Pair<K, V>> { self.base_table.collect() }
  286|    116|        fn collect(&self) -> ArraySeqStEphS<Pair<K, V>> { self.entries.clone() }
  322|    134|        fn collect(&self) -> ArraySeqStPerS<Pair<K, V>> { self.entries.clone() }
   49|       |        fn collect(&self) -> AVLTreeSeqStPerS<Pair<K, V>>;
   52|       |        fn collect(&self) -> AVLTreeSeqStPerS<Pair<K, V>>;
   53|       |        fn collect(&self) -> AVLTreeSeqStPerS<Pair<K, V>>;
   54|       |        fn collect(&self) -> ArraySeqStEphS<Pair<K, V>>;
   57|       |        fn collect(&self) -> ArraySeqMtEphS<Pair<K, V>>;
   57|       |        fn collect(&self) -> AVLTreeSeqStPerS<Pair<K, V>>;
   59|       |        fn collect(&self) -> AVLTreeSeqStPerS<Pair<K, V>>;
   62|       |        fn collect(&self) -> AVLTreeSeqStPerS<Pair<K, V>>;
  659|    149|        fn collect(&self) -> ArraySeqMtEphS<Pair<K, V>> { self.entries.clone() }
   78|       |        fn collect(&self) -> ArraySeqStPerS<Pair<K, V>>;
  113|  1.39k|        fn collect_values(link: &Link<T>, out: &mut Vec<T>) {
  155|    537|        fn collect_values(link: &Link<T>, out: &mut Vec<T>) {
  169|     11|        fn collect_values(link: &Link<K, V>, out: &mut Vec<V>) {
  242|    116|        fn collect_values(link: &Link<K, V, R>, out: &mut Vec<V>) {
  183|       |            // Collision avoidance score based on probe sequence coverage
  224|      0|            write!(f, "Collision pattern: {}", self.collision_pattern)
  184|     20|            let collision_avoidance_score = (unique_probe_positions as f64) / (table_size as f64);
   30|       |        pub collision_avoidance_score: f64,
  309|     16|                let collision_bonus = m.collision_avoidance_score * -10.0;
  188|       |            let collision_chains;
   26|       |        pub collision_chains: N,
  127|     32|            let collision_pattern = self.analyze_collision_pattern(&probe_sequence);
  156|     27|            let collision_pattern = self.analyze_collision_pattern(&probe_sequence);
   25|       |        pub collision_pattern: String,
   88|     31|            let collision_pattern = self.analyze_collision_pattern(&probe_sequence);
   11|       |    enum Color {
   13|       |    enum Color {
   21|       |        color: Color,
   23|       |        color: Color,
  120|  22.1k|                    | Color::Black => Color::Red,
  122|    132|                    | Color::Black => Color::Red,
  125|      0|                        | Color::Black => Color::Red,
  127|      0|                        | Color::Black => Color::Red,
  131|      0|                        | Color::Black => Color::Red,
  133|      0|                        | Color::Black => Color::Red,
  119|      0|                    | Color::Red => Color::Black,
  121|      0|                    | Color::Red => Color::Black,
  124|  22.1k|                        | Color::Red => Color::Black,
  126|    132|                        | Color::Red => Color::Black,
  130|  22.1k|                        | Color::Red => Color::Black,
  132|    132|                        | Color::Red => Color::Black,
   31|    174|                color: Color::Red,
   33|  24.9k|                color: Color::Red,
   14|       |        pub cols: usize,
   14|       |        pub cols: usize,
   16|       |        pub cols: usize,
   16|       |        pub cols: usize,
  106|       |                // Combine: merged_left + [pivot] + merged_right
  145|       |        // Combine results
  145|       |        // Combine results
  150|       |        // Combine results (union of sets)
  152|       |                // Combine: merged_left + [pivot] + merged_right
  168|       |            // Combine all three parts
  170|       |        // Combine results
  187|       |            // Combine: parallel merge the two sorted halves
  259|       |            // Combine reductions
  272|       |            // Combine reductions
  286|      4|            let combine = Arc::new(combine);
  313|      6|            let combine = Arc::new(combine);
   50|       |        // Combine: compute strengthened result
   56|       |        // Combine: compute strengthened result
   90|       |            // Combine: handle subsequence spanning the cut
   95|       |            // Combine: merge the two sorted halves
   97|       |            // Combine: handle subsequence spanning the cut (parallel suffix/prefix computation)
   44|       |        fn combine(a: R, b: R) -> R;
   55|  2.38k|        fn combine(a: T, b: T) -> T { a + b }
   69|     46|        fn combine(a: N, b: N) -> N { a + b }
  485|      2|                let combined_clone = combined_value.clone();
  492|      0|                                Pair(key_clone.clone(), combined_clone.clone())
  146|     10|        let combined_dist = ArraySeqStEphS::append(&left_dist, &right_dist);
  146|     18|        let combined_dist = ArraySeqStEphS::append(&left_dist, &right_dist);
  147|     17|                    let combined_left = ParamTreap::join_pair_inner(split_left, r_left);
  147|     10|        let combined_pred = ArraySeqStEphS::append(&left_pred, &right_pred);
  147|     18|        let combined_pred = ArraySeqStEphS::append(&left_pred, &right_pred);
  149|     10|        (combined_dist, combined_pred)
  149|     18|        (combined_dist, combined_pred)
  148|     17|                    let combined_right = ParamTreap::join_pair_inner(split_right, r_right);
  134|      6|                        let combined_value = combine(&pair1.1, &pair2.1);
  135|      6|                        intersection_entries.push(Pair(pair1.0.clone(), combined_value));
  150|     11|                        let combined_value = combine(val1, val2);
  151|     11|                        result_entries.push(Pair(key1.clone(), combined_value));
  165|      3|                        let combined_value = combine(&pair1.1, &pair2.1);
  166|      3|                        union_entries.push(Pair(pair1.0.clone(), combined_value));
  253|     20|                let combined_value = combine(&existing_value, &value);
  255|    973|                let combined_value = combine(&existing_value, &value);
  259|     20|                updated_entries.push(Pair(key, combined_value));
  300|      6|                        let combined_value = combine(&pair1.1, &pair2.1);
  301|      6|                        intersection_entries.push(Pair(pair1.0.clone(), combined_value));
  333|      3|                        let combined_value = combine(&pair1.1, &pair2.1);
  334|      3|                        union_entries.push(Pair(pair1.0.clone(), combined_value));
  472|      3|                let combined_value = combine(&existing_value, &value);
  505|      2|                            Pair(key.clone(), combined_value.clone())
  102|       |    // Common pattern: Fn(&T) -> B + Send + Sync + 'static (appears 10+ times)
  107|       |    // Common pattern: Fn(T) -> B + Send + Sync + 'static (for Copy types like N)
  115|       |    // Common pattern: StT + MtT + Hash + Ord (appears in graph modules)
  120|       |    // Common pattern: StT + std::ops::Add<Output = T> + Default + Copy
   77|       |    // Common pattern: StTInMtT + Ord + 'static (appears 15+ times)
   82|       |    // Common pattern: StTInMtT + 'static (appears 15+ times)
   87|       |    // Common pattern: Fn(...) + Send + Sync + 'static (appears 30+ times)
   92|       |    // Common pattern: Fn(...) + Send + Sync + Clone + 'static (appears 20+ times)
   97|       |    // Common pattern: Fn(&V, &V) -> V + Clone + Send + Sync + 'static (appears 8+ times)
  203|       |        /// Compare all three probing strategies for a given key and table size
  209|       |        /// Compare all three probing strategies
  231|       |            // Compare the contents of the Arc<Mutex<Vec>>
  236|       |            // Compare the contents of the Arc<Mutex<Vec>>
   37|       |        /// Compare all heapsort implementations on the same input
   39|       |        fn compare_all_heapsorts<T: StT + Ord>(sequence: &[T]) -> HeapsortComparison<T>;
  353|       |    /// Compares all three strategies with the same keys and table size
  308|      6|            .all(|comparison| comparison.all_results_match() && comparison.all_results_sorted())
  148|       |                    // Complement: flip all entries except diagonal
  113|      1|        fn complement(&self) -> Self {
  142|      1|        fn complement(&self) -> Self {
   33|       |        fn complement(&self) -> Self;
   34|       |        fn complement(&self) -> Self;
  272|      1|Exercise 47.7: Complete Flat Hash Table Implementation
  115|       |            // Complex query: (fun AND party) OR (chess AND NOT food)
  282|       |    /// Complex query builder for chaining operations
  304|       |        /// Complex query: (word1 AND word2) OR (word3 AND NOT word4)
   62|       |        /// Complex query from textbook:
   77|       |        /// Complex query from textbook:
  145|       |        // Complexity Analysis
  147|      0|        let complexity = complexity_analysis();
  259|       |        fn complexity_analysis() -> Vec<(String, String, String)>;
  158|      1|        let complex_results = examples.complex_query_fun_and_food_or_chess();
  166|      1|        if complex_vec != expected_complex {
  108|     33|            let component = component_map_quotient.get(v).unwrap_or(v);
  119|     20|        (visited, component)
  185|     12|                let component = component_map.get(v).unwrap_or(v);
  199|     32|            let component = component_map.get(v).unwrap_or(v);
  244|      0|                let component = component_map.get(v).unwrap_or(v);
  111|      8|        let component_map = compose_maps_parallel(&partition_map, &component_map_quotient);
  112|      6|        (representatives, component_map)
  113|      8|        (representatives, component_map)
  182|      2|                      (reps, component_map): (Set<V>, HashMap<V, V>)| {
  241|      0|                      (reps, component_map): (Set<V>, HashMap<V, V>)| {
   33|     12|                if component.size() > 0 {
   34|     12|                if component.size() > 0 {
  105|       |        // Compose maps: for each vertex u, map it to C[P[u]]
  110|       |        // Compose maps in parallel
  191|      8|    fn compose_maps_parallel<V: StT + MtT + Hash + Ord + 'static>(
  424|       |        // Composite table size analysis
  434|      2|            clustering_analysis: "Composite table size may limit probe sequence coverage".to_string(),
  428|      2|        let composite_results = TextbookExampleResults {
  438|      2|        (prime_results, composite_results)
   37|     13|        let composites: ArraySeqStPerS<N> = <ArraySeqStPerS<N> as ArraySeqStPerTrait<N>>::flatten(&nested);
  426|      2|        let composite_sequences = vec![analyzer.analyze_quadratic_probing(test_key, composite_size, 1, 1)];
  433|      2|            probe_sequences: composite_sequences,
  425|      2|        let composite_size = 16;
  431|      2|            table_size: composite_size,
   47|  48.7k|                if *composites.nth(i) == *x {
   16|       |    /// Comprehension form: 〈(x,y,z): 0 ≤ x ≤ n−1, 1 ≤ y ≤ n, 2 ≤ z ≤ n+1〉
  307|       |    /// Comprehensive demonstration of all examples
  352|       |    /// Comprehensive Probe Sequence Comparison
  375|      2|            example_name: "Comprehensive Probe Sequence Comparison".to_string(),
    6|       |//! redundant computation and achieve O(n) work complexity.
  101|       |        /// Compute greatest common divisor
  101|       |        /// Compute minimum edit distance with parallel subproblem exploration
  104|       |                // Compute costs for each possible split in parallel
  106|       |                // Compute costs for each possible root in parallel
  111|       |                // Compute out-neighbors of all newly visited vertices
  114|       |                // Compute costs for each possible split in parallel
  118|       |                // Compute costs for each possible root in parallel
   11|       |        /// Compute maximum contiguous subsequence sum using optimal scan-based algorithm.
  123|       |        /// Compute clustering metrics from cluster sizes
  125|       |            // Compute reduced value: f(left_reduced, f(node_value, right_reduced))
  144|       |    /// Compute tour weight
   14|       |        /// Compute maximum contiguous subsequence sum using parallel optimal scan-based algorithm.
  152|       |        // Compute remaining vertices (not contracted)
  161|       |    /// Compute tour weight
  164|       |    /// Compute total MST weight
   17|       |        /// Compute second hash value for double hashing.
   20|       |        /// Compute maximum contiguous subsequence sum using brute force.
   21|       |        /// Compute Euler tour of a tree
   21|       |        /// Compute maximum contiguous subsequence sum using reduction to MCSSS.
  232|       |    /// Compute MST weight from edge labels
   25|       |        /// Compute total weight of MST
   28|       |            // Compute all prefix sums manually (inclusive)
   29|       |        // Compute all inclusive prefix sums
   29|       |            // Compute hash from key bytes using FNV-1a algorithm
   29|       |        /// Compute total weight of MST
   30|       |        /// Compute minimum edit distance between sequences
   31|       |            // Compute all prefix sums manually (inclusive)
   31|       |        /// Compute minimum edit distance where |S|=source length, |T|=target length
   32|       |        /// Compute minimum edit distance with parallel DP where |S|=source length, |T|=target length
   32|       |        /// Compute total weight of a tour
  335|       |    /// Compute MST weight from edge labels
   33|       |        /// Compute minimum edit distance with parallel DP where |S|=source length, |T|=target length
   35|       |        /// Compute optimal matrix chain multiplication cost using dynamic programming
   36|       |        /// Compute optimal matrix chain multiplication cost where n=number of matrices
   37|       |        /// Compute optimal BST cost using dynamic programming
   38|       |        /// Compute minimum edit distance using bottom-up diagonal pebbling
   38|       |        /// Compute minimum edit distance using bottom-up diagonal pebbling
   38|       |            // Compute minimum prefix up to each position (inclusive)
   38|       |        /// Compute optimal BST cost where n=number of keys
   38|       |        /// Compute optimal matrix chain multiplication cost where n=number of matrices
   38|       |        /// Compute optimal matrix chain multiplication cost where n=number of matrices
   39|       |        /// Compute greatest common divisor using Euclidean algorithm
   39|       |        /// Compute optimal BST cost where n=number of keys
   39|       |        /// Compute optimal BST cost where n=number of keys
   39|       |        /// Compute total weight of MST
   40|       |        /// Compute minimum edit distance using parallel bottom-up diagonal pebbling
   40|       |        /// Compute minimum edit distance using parallel bottom-up diagonal pebbling
   41|       |            // Compute minimum prefix up to each position (inclusive)
   42|       |                // Compute sum for each subsequence starting at position i
   43|       |                    // Compute sum of subsequence a[i..=j]
   46|       |        /// Compute minimum edit distance using top-down memoization
   46|       |        /// Compute minimum edit distance using top-down memoization
   47|       |        // Compute all inclusive prefix sums and return maximum
   48|       |        /// Compute minimum edit distance using concurrent top-down memoization
   48|       |        /// Compute minimum edit distance using concurrent top-down memoization
   48|       |        /// Compute total weight of MST
   50|       |            // Compute maximum over all ending positions
   61|       |        /// Compute maximum contiguous subsequence sum using divide-and-conquer.
   62|       |        /// Compute maximum contiguous subsequence sum using parallel divide-and-conquer.
   68|       |        /// Compute maximum contiguous subsequence sum using parallel strengthened divide-and-conquer.
   69|       |                // Compute Din(v) = min over u in N⁻(v) of (d[u] + w(u,v))
   69|       |        /// Compute maximum contiguous subsequence sum using strengthened divide-and-conquer.
   76|       |        /// Compute one diagonal of the DP table
   76|       |        /// Compute one diagonal of the DP table
   79|       |                // Compute Din(v) = min over u in N⁻(v) of (d[u] + w(u,v))
   79|       |        /// Compute one diagonal of the DP table in parallel
   79|       |        /// Compute one diagonal of the DP table in parallel
   92|       |    /// Compute total MST weight
   95|       |        /// Compute value for a single DP table cell
   97|       |        /// Compute value for a single DP table cell
   99|       |        /// Compute minimum edit distance with parallel subproblem exploration
   99|       |            // Compute out-neighbors (sequential loop, but union is parallel)
  100|     23|        fn compute_cell_value(&self, table: &Vec<Vec<usize>>, i: usize, j: usize) -> usize {
   98|     21|        fn compute_cell_value(&self, table: &Vec<Vec<usize>>, i: usize, j: usize) -> usize {
  125|     21|        fn compute_cell_value_static(
  125|     21|        fn compute_cell_value_static(
  125|     21|        fn compute_clustering_metrics(&self, clusters: Vec<N>, load: N, size: N) -> PrimaryClusteringMetrics {
   81|     13|        fn compute_diagonal_parallel(&self, table: Arc<Mutex<Vec<Vec<usize>>>>, k: usize) {
   81|     16|        fn compute_diagonal_parallel(&self, table: Arc<Mutex<Vec<Vec<usize>>>>, k: usize) {
   79|     13|        fn compute_diagonal(&self, table: &mut Vec<Vec<usize>>, k: usize) {
   79|     20|        fn compute_diagonal(&self, mut table: Vec<Vec<usize>>, k: usize) -> Vec<Vec<usize>> {
   43|      7|    fn compute_finish_order(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>) -> AVLTreeSeqStPerS<N> {
   47|      7|    fn compute_finish_order(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>) -> AVLTreeSeqStEphS<N> {
  101|       |    /// Computes a greedy matching and contracts it.
   13|       |        /// Computes topological sort of a DAG
  149|       |    /// Computes the Minimum Spanning Tree using recursive bridge-based contraction.
   14|       |        /// Computes topological sort of a DAG
  160|       |    /// Computes a parallel matching and contracts it.
   18|       |    /// Computes topological sort of a DAG.
   19|       |    /// Computes topological sort of a DAG.
  214|       |    /// Computes the Minimum Spanning Tree using recursive bridge-based contraction.
   23|       |        /// Computes the total weight of a path given edge weights (integer).
   24|       |        /// Computes the hash index for a key.
   24|       |        /// Computes the total weight of a path given edge weights (integer).
   26|       |    /// Computes a vertex matching using randomized symmetry breaking.
   27|       |        /// Computes the total weight of a path with floating-point weights.
   28|       |    /// Computes a star partition using randomized coin flips:
   28|       |    /// Computes single-source shortest paths for arbitrary edge weights (including negative)
   28|       |    /// Computes single-source shortest paths for arbitrary edge weights (including negative)
   28|       |        /// Computes the total weight of a path with floating-point weights.
   29|       |    /// Computes a spanning tree by recursively applying star contraction and
   31|       |    /// Computes a spanning tree using parallel star contraction.
   36|       |    /// Computes topological sort of a DAG.
   39|       |    /// Computes the Minimum Spanning Tree by sorting edges and greedily adding them.
   42|       |    /// Computes topological sort of a DAG.
   50|       |    /// Computes the total weight of a path given edge weights (integer version).
   51|       |    /// Computes the total weight of a path given edge weights.
   56|       |    /// Computes single-source shortest paths for non-negative edge weights
   56|       |    /// Computes single-source shortest paths for non-negative edge weights
   66|       |    /// Computes the Minimum Spanning Tree using priority-first search.
   73|       |    /// Computes all connected components and returns a mapping from each vertex
   73|       |    /// Computes the total weight of a path with floating-point weights.
   74|       |    /// Computes the total weight of a path with floating-point weights.
   75|       |    /// Computes all connected components in parallel.
    5|       |//! Demonstrates computing the weight of a path in a weighted graph.
  128|       |        /// Concatenate the two unsorted lists
  246|       |        /// Concatenate arrays and re-heapify
   18|       |    /// Concurrent stack backed by a Treiber-style CAS list.
   34|       |        /// Concurrent memoization table for subproblem results
   34|       |        /// Concurrent memoization table for subproblem results
    5|       |//! using concurrent HashMap for thread-safe subproblem caching.
    5|       |//! using concurrent HashMap with in-place mutations for thread-safe subproblem caching.
    2|       |//! Strongly Connected Components - Sequential Ephemeral (Chapter 55, Algorithm 55.18).
    2|       |//! Strongly Connected Components - Sequential Persistent (Chapter 55, Algorithm 55.18).
   37|       |        fn connected_components_hof<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> Set<Set<V>>;
   40|       |        fn connected_components_hof<V: StT + MtT + Hash + Ord + 'static>(graph: &UnDirGraphMtEph<V>) -> Set<Set<V>>;
   32|       |        fn connected_components_mt<V: StT + MtT + Hash + Ord + 'static>(graph: &UnDirGraphMtEph<V>) -> Set<Set<V>>;
   29|       |        fn connected_components<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> Set<Set<V>>;
   10|       |pub mod ConnectivityMtEph {
   10|       |pub mod ConnectivityStEph {
   46|       |        // Conquer: parallel recursive solve using ParaPair! with 32MB stack
   46|       |        // Conquer: recursively solve with strengthened interface
   86|       |            // Conquer: recursively solve subproblems
   87|       |            // Conquer: parallel recursive solve using ParaPair! with 32MB stack
  185|    837|                    if consecutive_count > 1 {
  192|     89|            if consecutive_count > 1 {
  299|      1|   - Consider Robin Hood hashing variants
   16|       |    /// Construct primes using a sieve: generate composites, then filter candidates.
   16|       |    /// Construct the sequence of 2D points (x, y) with 0 ≤ x < n and 1 ≤ y < n,
   49|       |        /// Construct an empty tree.
   54|       |        /// Construct an empty tree (alias).
   70|       |        /// Construct a singleton sequence.
  330|       |    /// Constructor functions for common nested hash table configurations
   37|       |    /// Constructor functions for linear probing hash tables
   50|       |    /// Constructor functions for double hashing hash tables
   52|       |    /// Constructor functions for quadratic probing hash tables
   24|       |        /// Constructs a sequence from the provided vector
   26|       |    /// Constructs a star partition by iteratively selecting vertices:
   73|       |        /// Constructs a sequence from the provided vector without additional copying.
   76|       |        /// Constructs a sequence from an owned boxed slice.
   85|       |        /// Constructs a sequence from a Vec without exposing it to callers.
   11|       |    /// Container type is abstract - can be Vec, LinkedList, Seq, etc.
   89|  5.13k|    fn contains_node<'a, T: StT + Ord>(node: &'a BalBinTree<T>, target: &T) -> B {
  134|    148|        fn contains(&self, target: &T) -> B { if self.find(target).is_some() { true } else { false } }
  167|    152|        fn contains(&self, target: &T) -> B { self.find(target).is_some() }
  169|      8|        fn contains(&self, target: &T) -> B { self.find(target).is_some() }
  199|    110|        fn contains(&self, target: &T) -> B { self.find(target).is_some() }
  204|    111|        fn contains(&self, target: &T) -> B { self.find(target).is_some() }
  205|      2|        fn contains(&self, key: &K) -> B { self.find(key).is_some() }
  206|     92|        fn contains(&self, target: &T) -> B { if self.find(target).is_some() { true } else { false } }
  222|   232k|        fn contains(&self, target: &T) -> B { self.find(target).is_some() }
  226|     39|        fn contains(&self, target: &T) -> B { self.find(target).is_some() }
  236|      1|        fn contains(&self, value: &T) -> B { self.tree.contains(value) }
  236|      1|        fn contains(&self, value: &T) -> B { self.tree.contains(value) }
  236|      1|        fn contains(&self, value: &T) -> B { self.tree.contains(value) }
  236|      1|        fn contains(&self, value: &T) -> B { self.tree.contains(value) }
  236|      1|        fn contains(&self, value: &T) -> B { self.tree.contains(value) }
  236|      1|        fn contains(&self, value: &T) -> B { self.tree.contains(value) }
  248|      0|        fn contains(&self, target: &T) -> B { self.find(target).is_some() }
  250|    111|        fn contains(&self, target: &T) -> B { self.find(target).is_some() }
  259|     13|        fn contains(&self, target: &T) -> B { self.find(target).is_some() }
  261|    403|        fn contains(&self, target: &T) -> B { self.find(target).is_some() }
  308|     59|        fn contains(&self, key: &K) -> B { self.find(key).is_some() }
   31|       |        fn contains(&self, target: &T) -> B;
   31|       |        fn contains(&self, value: &T) -> B;
   31|       |        fn contains(&self, value: &T) -> B;
   31|       |        fn contains(&self, value: &T) -> B;
   31|       |        fn contains(&self, value: &T) -> B;
   31|       |        fn contains(&self, value: &T) -> B;
   31|       |        fn contains(&self, value: &T) -> B;
   48|       |        fn contains(&self, target: &T) -> B;
   50|       |        fn contains(&self, target: &T) -> B;
   50|       |        fn contains(&self, target: &T) -> B;
   50|       |        fn contains(&self, target: &T) -> B;
   52|       |        fn contains(&self, target: &T) -> B;
   54|       |        fn contains(&self, target: &T) -> B;
   54|       |        fn contains(&self, target: &T) -> B;
   54|       |        fn contains(&self, target: &T) -> B;
   54|       |        fn contains(&self, target: &T) -> B;
   55|       |        fn contains(&self, key: &K) -> B;
   55|       |        fn contains(&self, target: &T) -> B;
   55|       |        fn contains(&self, target: &T) -> B;
   60|       |        fn contains(&self, target: &T) -> B;
   63|    133|        fn contains(&self, target: &T) -> B { contains_node(&self.root, target) }
   95|       |        fn contains(&self, key: &K) -> B;
   70|    258|                let content = &doc.1;
  205|    269|        let content_lower = content.to_lowercase();
    2|       |//! Maximum Contiguous Subsequence Sum - Brute Force (Chapter 28, Algorithm 28.8).
    2|       |//! Maximum Contiguous Subsequence Sum - Divide and Conquer (Chapter 28, Algorithm 28.17).
    2|       |//! Maximum Contiguous Subsequence Sum - Parallel Divide and Conquer (Chapter 28, Algorithm 28.17).
    2|       |//! Maximum Contiguous Subsequence Sum - Parallel Optimal (Chapter 28, Algorithm 28.16).
    2|       |//! Maximum Contiguous Subsequence Sum - Parallel Strengthened Divide and Conquer (Chapter 28, Algorithm 28.19).
    2|       |//! Maximum Contiguous Subsequence Sum - Reduced Force (Chapter 28, Algorithm 28.13).
    2|       |//! Maximum Contiguous Subsequence Sum - Strengthened Divide and Conquer (Chapter 28, Algorithm 28.19).
    2|       |//! Maximum Contiguous Subsequence Sum - Work Optimal (Chapter 28, Algorithm 28.16).
  170|     20|                        // Continue probing
  198|      0|                        // Continue probing
   46|      2|                        // Continue probing past Deleted or non-matching Occupied
   67|      0|                        // Continue probing
  130|       |            // Contract if u is Tail and v is Head
   27|       |        /// Contract graph to just vertices (no edges)
   28|       |            // Contract: pair up elements and apply f
   30|       |            // Contract: pair up elements and apply f
   31|       |        /// Contract graph to just vertices (no edges)
   40|       |            // Contract: pair up elements and apply f in parallel
   42|       |            // Contract: pair up elements and apply f in parallel
   30|       |        fn contract_round_mt<V: StT + MtT + Hash + Ord + 'static>(
   29|       |        fn contract_round<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> UnDirGraphStEph<V>;
   34|       |    /// Contracts edges in a matching by merging their endpoints.
   38|       |    /// Contracts edges in a matching by merging their endpoints in parallel.
   33|       |        fn contract_to_vertices_mt<V: StT + MtT + Hash + Ord + 'static>(graph: &UnDirGraphMtEph<V>) -> Set<V>;
   29|       |        fn contract_to_vertices<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> Set<V>;
  110|       |    /// Convenience wrapper that performs contraction with identity base/expand.
  140|       |        // Convenience APIs kept for older tests (set-like operations over sequence storage)
  142|       |    // Convenience macro for creating probability literals
  159|       |    /// Convenience wrapper that performs contraction with identity base/expand.
   15|       |    /// Convenience functions for weighted directed graphs with integer weights
   15|       |    /// Convenience functions for weighted undirected graphs with integer weights
   19|       |    /// Convenience functions for weighted directed graphs with floating-point weights (multi-threaded)
   19|       |    /// Convenience functions for weighted directed graphs with integer weights (multi-threaded)
   19|       |    /// Convenience functions for weighted undirected graphs with floating-point weights (multi-threaded)
   19|       |    /// Convenience functions for weighted undirected graphs with integer weights (multi-threaded)
  216|       |    /// Convenience functions for common operations
  229|       |    /// Convenience function for staged computation pattern (Example 44.2)
  242|       |    // Convenience type aliases for common float types
  282|       |    /// Convenience functions for common operations
  313|       |    /// Convenience functions for common operations
   33|       |    /// Convenience function wrapping the trait method.
  369|       |    /// Convenience functions for common operations
   43|       |    /// Convenience functions for weighted directed graphs with floating-point weights
   43|       |    /// Convenience functions for weighted undirected graphs with floating-point weights
  110|       |            // Convert to vector, remove first element, rebuild tree
  116|       |                // Convert ArraySeqStPerS to AVLTreeSeqStPerS
  120|       |        // Convert sequence to set
  124|       |                // Convert sequence to set to eliminate duplicates
  129|       |            // Convert ephemeral sequence to persistent sequence
  141|       |            // Convert persistent sequence to ephemeral sequence
  154|       |        // Convert MtEph graph to StEph for Bellman-Ford
  157|       |        // Convert MtEph graph to StEph for Bellman-Ford
  180|       |            // Convert ArraySeqStPerS to AVLTreeSeqStPerS
  190|       |        /// Convert to vector for testing (in-order traversal)
  193|       |            // Convert ArraySeqStEphS to AVLTreeSeqStPerS
  198|       |            // Convert to vector, remove last element, rebuild tree
  203|       |            // Convert to ArraySeqStPerS for filtering operations
  208|       |            // Convert to ArraySeqStPerS for filtering operations
  211|       |            // Convert back to AVLTreeSeqStPerS
  216|       |            // Convert back to AVLTreeSeqStPerS
  222|       |            // Convert ArraySeqMtEphS to AVLTreeSeqStPerS
  225|       |            // Convert to ArraySeqStPerS for filtering operations
  227|       |        /// Convert to vector (for testing)
  231|       |            // Convert back to AVLTreeSeqStPerS
  233|       |            // Convert to ArraySeqStPerS for filtering operations
  239|       |            // Convert back to AVLTreeSeqStPerS
  293|       |        /// Convert to vector (for testing)
  313|       |        /// Convert Vec to ArraySeqStPerS for use with APAS sequence types
  315|       |        /// Convert Vec to AVLTreeSeqStPerS for use with balanced tree operations
  323|       |    /// Convert Vec to ArraySeqStPerS for use with APAS sequence types
  324|       |        /// Convert to vector (for testing)
  328|       |        /// Convert to vector (for testing)
  333|       |    /// Convert Vec to AVLTreeSeqStPerS for use with balanced tree operations
  352|       |        // Convert AVLTreeSeqStPerS to Vec for TableStPer helper
  368|       |        // Convert persistent sequence to Vec for TableStEph helper
  381|       |        /// Convert to vector (for testing)
  396|       |        // Convert persistent sequence to Vec for TableMtEph helper
  419|       |        // Convert each sorted sequence to a leftist heap
   45|       |        /// Convert value to reduced form
   51|       |        // Convert edges to a sequence for parallel processing
   65|       |                // Convert character to position (a=0, b=1, ..., z=25)
   81|       |            // Convert to vector, insert in sorted position, rebuild tree
   89|       |        // Convert edges to sequence for parallel processing
   89|       |        // Convert to sequence
   28|       |        /// Converts this sequence into its backing vector
   55|       |        /// Converts document set to sequence
   78|       |        /// Converts this sequence into its backing vector.
   10|       |    #[derive(Clone, Copy, PartialEq, Eq, Debug)]
  114|       |        // Copy all original edges
   12|       |    #[derive(Clone, Copy, PartialEq, Eq, Debug)]
  165|       |        // Copy all original edges
  168|       |        // Copy all original edges
   16|       |    #[derive(Clone, Copy, Debug, PartialEq)]
  195|       |    impl<T: Copy + Debug> AVLTreeSeq<T> for AVLTreeS<T> {
  206|       |    #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
  222|       |    #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
   26|       |    #[derive(Clone, Copy)]
   29|       |    impl<T: Copy + Debug> AVLTreeNode<T> {
   86|       |    impl<T: Copy + Debug> AVLTreeS<T> {
   22|       |    /// Core API for `MathSeqS<T>`.
   95|       |        /// Core meld operation - follows right spines (Data Structure 45.3 algorithm)
  153|       |        // Correctness Verification
  261|       |        fn correctness_verification() -> bool;
   15|       |        /// cost of sort using our composition rules described in Section (Work, Span, and Parallel
  215|      1|- amortized cost per operation remains O(1)
  279|      1|   - Cost: O(n) work, O(n) span
   51|       |        /// Cost = rows[i] * cols[k] * cols[j] (scalar multiplications)
   53|       |        /// Cost = rows[i] * cols[k] * cols[j] (scalar multiplications)
   62|       |        /// Cost dominated by Table.collect which performs a sort
   62|       |        /// Cost = rows[i] * cols[k] * cols[j] (scalar multiplications)
   63|       |        /// Cost = rows[i] * cols[k] * cols[j] (scalar multiplications)
   63|    114|                return costs[0];
   69|     68|                return costs[0];
   72|    179|                return costs[0];
   79|     63|                return costs[0];
  105|     39|                let costs: Vec<usize> = (i..j)
  107|     60|                let costs: Vec<Probability> = (0..l)
  115|     35|                let costs: Vec<usize> = (i..j)
  119|     71|                let costs: Vec<Probability> = (0..l)
   59|    168|            if costs.is_empty() {
   65|     97|            if costs.is_empty() {
   68|    287|            if costs.is_empty() {
   75|     91|            if costs.is_empty() {
   62|    168|            if costs.len() == 1 {
   68|     97|            if costs.len() == 1 {
   71|    287|            if costs.len() == 1 {
   78|     91|            if costs.len() == 1 {
  210|      1|  - Could be parallelized to O(log n) span
  143|     11|                        if count > 1 {
  146|       |        /// Count total number of nodes in the heap
  148|     10|                if count == 0 {
  225|      0|                        if count > 1 {
  230|      0|                if count == 0 {
   23|       |        /// Count connected components using star contraction
   26|       |        /// Count connected components using parallel star contraction
   31|       |        /// Count components using higher-order function approach
   34|       |        /// Count components using higher-order function approach
   46|    429|                    while count < i {
   33|       |        fn count_components_hof<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> N;
   36|       |        fn count_components_hof<V: StT + MtT + Hash + Ord + 'static>(graph: &UnDirGraphMtEph<V>) -> N;
   28|       |        fn count_components_mt<V: StT + MtT + Hash + Ord + 'static>(graph: &UnDirGraphMtEph<V>) -> N;
   25|       |        fn count_components<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> N;
  171|      1|        let count_result = examples.count_fun_but_not_chess();
  172|      1|        if count_result != 2 {
  228|      6|                match counts.entry(x.clone()) {
  238|      3|            order.into_iter().map(|x| (*counts.get(&x).unwrap(), x)).collect()
   10|       |    use crate::*;
   11|       |    use crate::*;
   11|       |    use crate::ArraySeqMtEphSLit;
   11|       |    use crate::ArraySeqMtEphSLit;
    9|       |    use crate::ArraySeqStEphS;
    9|       |    use crate::ArraySeqStEphS;
    9|       |    use crate::ArraySeqStPerS;
    9|       |    use crate::ArraySeqStPerS;
   10|       |    use crate::Chap05::RelationStEph::RelationStEph::*;
   10|       |    use crate::Chap05::SetStEph::SetStEph::*;
   11|       |    use crate::Chap05::SetStEph::SetStEph::*;
   11|       |    use crate::Chap05::SetStEph::SetStEph::*;
   11|       |    use crate::Chap05::SetStEph::SetStEph::*;
   11|       |    use crate::Chap05::SetStEph::SetStEph::*;
   11|       |    use crate::Chap05::SetStEph::SetStEph::*;
   11|       |    use crate::Chap05::SetStEph::SetStEph::*;
   11|       |    use crate::Chap05::SetStEph::SetStEph::*;
   12|       |    use crate::Chap05::SetStEph::SetStEph::*;
   12|       |    use crate::Chap05::SetStEph::SetStEph::*;
   12|       |    use crate::Chap05::SetStEph::SetStEph::*;
   12|       |    use crate::Chap05::SetStEph::SetStEph::*;
   12|       |    use crate::Chap05::SetStEph::SetStEph::*;
   12|       |    use crate::Chap05::SetStEph::SetStEph::*;
   12|       |    use crate::Chap05::SetStEph::SetStEph::*;
   12|       |    use crate::Chap05::SetStEph::SetStEph::*;
   12|       |    use crate::Chap05::SetStEph::SetStEph::*;
   12|       |    use crate::Chap05::SetStEph::SetStEph::*;
   12|       |    use crate::Chap05::SetStEph::SetStEph::*;
   12|       |    use crate::Chap05::SetStEph::SetStEph::*;
   12|       |    use crate::Chap05::SetStEph::SetStEph::*;
   13|       |    use crate::Chap05::SetStEph::SetStEph::*;
   13|       |    use crate::Chap05::SetStEph::SetStEph::*;
   13|       |    use crate::Chap05::SetStEph::SetStEph::*;
   14|       |    use crate::Chap05::SetStEph::SetStEph::*;
   14|       |    use crate::Chap05::SetStEph::SetStEph::*;
   15|       |    use crate::Chap05::SetStEph::SetStEph::*;
   15|       |    use crate::Chap05::SetStEph::SetStEph::*;
   15|       |    use crate::Chap05::SetStEph::SetStEph::*;
   16|       |    use crate::Chap05::SetStEph::SetStEph::*;
   18|       |    use crate::Chap05::SetStEph::SetStEph::*;
   18|       |    use crate::Chap05::SetStEph::SetStEph::*;
   37|       |    use crate::Chap05::SetStEph::SetStEph::*;
   37|       |    use crate::Chap05::SetStEph::SetStEph::*;
    9|       |    use crate::Chap05::SetStEph::SetStEph::*;
    9|       |    use crate::Chap05::SetStEph::SetStEph::*;
    9|       |    use crate::Chap05::SetStEph::SetStEph::*;
    9|       |    use crate::Chap05::SetStEph::SetStEph::*;
    9|       |    use crate::Chap05::SetStEph::SetStEph::*;
    9|       |    use crate::Chap05::SetStEph::SetStEph::*;
   13|       |    use crate::Chap06::LabDirGraphMtEph::LabDirGraphMtEph::*;
   13|       |    use crate::Chap06::LabDirGraphMtEph::LabDirGraphMtEph::*;
   19|       |    use crate::Chap06::LabDirGraphMtEph::LabDirGraphMtEph::LabDirGraphMtEphTrait;
   19|       |    use crate::Chap06::LabDirGraphMtEph::LabDirGraphMtEph::LabDirGraphMtEphTrait;
   10|       |    use crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::*;
   16|       |    use crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::*;
   16|       |    use crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::*;
   20|       |    use crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::*;
   20|       |    use crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::*;
   38|       |    use crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::*;
   16|       |    use crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::LabDirGraphStEphTrait;
   16|       |    use crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::LabDirGraphStEphTrait;
   16|       |    use crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::LabDirGraphStEphTrait;
   16|       |    use crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::LabDirGraphStEphTrait;
   13|       |    use crate::Chap06::LabUnDirGraphMtEph::LabUnDirGraphMtEph::*;
   13|       |    use crate::Chap06::LabUnDirGraphMtEph::LabUnDirGraphMtEph::*;
   13|       |    use crate::Chap06::LabUnDirGraphMtEph::LabUnDirGraphMtEph::*;
   10|       |    use crate::Chap06::LabUnDirGraphStEph::LabUnDirGraphStEph::*;
   12|       |    use crate::Chap06::LabUnDirGraphStEph::LabUnDirGraphStEph::*;
   15|       |    use crate::Chap06::LabUnDirGraphStEph::LabUnDirGraphStEph::*;
   15|       |    use crate::Chap06::LabUnDirGraphStEph::LabUnDirGraphStEph::*;
   38|       |    use crate::Chap06::LabUnDirGraphStEph::LabUnDirGraphStEph::*;
   12|       |    use crate::Chap06::UnDirGraphMtEph::UnDirGraphMtEph::*;
   12|       |    use crate::Chap06::UnDirGraphMtEph::UnDirGraphMtEph::*;
   13|       |    use crate::Chap06::UnDirGraphMtEph::UnDirGraphMtEph::*;
   13|       |    use crate::Chap06::UnDirGraphMtEph::UnDirGraphMtEph::*;
   14|       |    use crate::Chap06::UnDirGraphMtEph::UnDirGraphMtEph::*;
   17|       |    use crate::Chap06::UnDirGraphMtEph::UnDirGraphMtEph::*;
   12|       |    use crate::Chap06::UnDirGraphStEph::UnDirGraphStEph::*;
   13|       |    use crate::Chap06::UnDirGraphStEph::UnDirGraphStEph::*;
   13|       |    use crate::Chap06::UnDirGraphStEph::UnDirGraphStEph::*;
   13|       |    use crate::Chap06::UnDirGraphStEph::UnDirGraphStEph::*;
   14|       |    use crate::Chap06::UnDirGraphStEph::UnDirGraphStEph::*;
   16|       |    use crate::Chap06::UnDirGraphStEph::UnDirGraphStEph::*;
   21|       |    use crate::Chap06::WeightedDirGraphMtEphFloat::WeightedDirGraphMtEphFloat::*;
   21|       |    use crate::Chap06::WeightedDirGraphMtEphInt::WeightedDirGraphMtEphInt::*;
   17|       |    use crate::Chap06::WeightedDirGraphStEphFloat::WeightedDirGraphStEphFloat::*;
   22|       |    use crate::Chap06::WeightedDirGraphStEphFloat::WeightedDirGraphStEphFloat::*;
   17|       |    use crate::Chap06::WeightedDirGraphStEphFloat::WeightedDirGraphStEphFloat::WeightedDirGraphStEphFloat;
   17|       |    use crate::Chap06::WeightedDirGraphStEphFloat::WeightedDirGraphStEphFloat::WeightedDirGraphStEphFloat;
   17|       |    use crate::Chap06::WeightedDirGraphStEphInt::WeightedDirGraphStEphInt::*;
   22|       |    use crate::Chap06::WeightedDirGraphStEphInt::WeightedDirGraphStEphInt::*;
   17|       |    use crate::Chap06::WeightedDirGraphStEphInt::WeightedDirGraphStEphInt::WeightedDirGraphStEphInt;
   17|       |    use crate::Chap06::WeightedDirGraphStEphInt::WeightedDirGraphStEphInt::WeightedDirGraphStEphInt;
   14|       |    use crate::Chap18::ArraySeq::ArraySeq::*;
    6|       |    use crate::Chap18::ArraySeq::ArraySeq::ArraySeq;
    6|       |    use crate::Chap18::ArraySeq::ArraySeq::ArraySeq;
   10|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
   10|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
   11|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
   12|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
   12|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
   12|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
   12|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
   14|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
   14|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
    8|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
    8|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
    8|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::{
    9|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
    9|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
    9|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::*;
    9|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::{
   12|       |    use crate::Chap18::ArraySeqMtEph::ArraySeqMtEph::ArraySeqMtEphS;
   10|       |    use crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::*;
   10|       |    use crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::*;
   11|       |    use crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::*;
   11|       |    use crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::*;
   14|       |    use crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::*;
   14|       |    use crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::*;
    7|       |    use crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::*;
    8|       |    use crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::*;
    8|       |    use crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::{ArraySeqMtPerS as ArraySeqMtPerSChap18, ArraySeqMtPerTrait as ArraySeqMtPerTraitChap18};
   10|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   10|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   10|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   10|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   10|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   12|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   12|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   13|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   14|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   14|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   14|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   15|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   18|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   18|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   18|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   23|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   23|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
    6|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
    6|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
    6|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
    6|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
    6|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
    6|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
    6|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
    6|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
    6|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
    6|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
    7|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::{
    8|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
    8|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
    8|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::*;
   10|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS;
   11|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS;
   16|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS;
   17|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS;
   17|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS;
   18|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS;
   18|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS;
    8|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::{ArraySeqStEphS, ArraySeqStEphTrait};
    8|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::{ArraySeqStEphS, ArraySeqStEphTrait};
    8|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::{ArraySeqStEphS, ArraySeqStEphTrait};
    8|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::{ArraySeqStEphS, ArraySeqStEphTrait};
   10|       |    use crate::Chap18::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphTrait;
   10|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
   10|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
   10|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
   12|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
   12|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    6|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::{
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
   11|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS;
   12|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS;
   16|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS;
   17|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS;
   18|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS;
   18|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS;
   19|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS;
   19|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS;
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::{ArraySeqStPerS, ArraySeqStPerTrait};
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::{ArraySeqStPerS, ArraySeqStPerTrait};
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::{ArraySeqStPerS, ArraySeqStPerTrait};
    8|       |    use crate::Chap18::ArraySeqStPer::ArraySeqStPer::{ArraySeqStPerS, ArraySeqStPerTrait};
    8|       |    use crate::Chap19::ArraySeqMtEphSlice::ArraySeqMtEphSlice::*;
   10|       |    use crate::Chap19::ArraySeqStPer::ArraySeqStPer::*;
   17|       |    use crate::Chap19::ArraySeqStPer::ArraySeqStPer::*;
   17|       |    use crate::Chap19::ArraySeqStPer::ArraySeqStPer::*;
   18|       |    use crate::Chap19::ArraySeqStPer::ArraySeqStPer::*;
   18|       |    use crate::Chap19::ArraySeqStPer::ArraySeqStPer::*;
    7|       |    use crate::Chap21::Exercise21_8::Exercise21_8::is_prime;
    7|       |    use crate::Chap23::BalBinTreeStEph::BalBinTreeStEph::BalBinTree;
   13|       |    use crate::Chap27::ScanContractMtEph::ScanContractMtEph::ScanContractMtEphTrait;
    9|       |    use crate::Chap27::ScanContractMtEph::ScanContractMtEph::ScanContractMtEphTrait;
   11|       |    use crate::Chap27::ScanContractStEph::ScanContractStEph::ScanContractStEphTrait;
    7|       |    use crate::Chap27::ScanContractStEph::ScanContractStEph::ScanContractStEphTrait;
    7|       |    use crate::Chap27::ScanContractStEph::ScanContractStEph::ScanContractStEphTrait;
   14|       |    use crate::Chap37::AVLTreeSeqMtPer::AVLTreeSeqMtPer::*;
   10|       |    use crate::Chap37::AVLTreeSeqMtPer::AVLTreeSeqMtPer::AVLTreeSeqMtPerTrait;
   11|       |    use crate::Chap37::AVLTreeSeqMtPer::AVLTreeSeqMtPer::AVLTreeSeqMtPerTrait;
    9|       |    use crate::Chap37::AVLTreeSeqMtPer::AVLTreeSeqMtPer::AVLTreeSeqMtPerTrait;
   14|       |    use crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::*;
    7|       |    use crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::*;
    8|       |    use crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::*;
    9|       |    use crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::*;
    9|       |    use crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::{AVLTreeSeqStEphS, AVLTreeSeqStEphTrait};
    6|       |    use crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::AVLTreeSeqStEphTrait;
    6|       |    use crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::AVLTreeSeqStEphTrait;
    6|       |    use crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::AVLTreeSeqStEphTrait;
    6|       |    use crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::AVLTreeSeqStEphTrait;
    6|       |    use crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::AVLTreeSeqStEphTrait;
    9|       |    use crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::AVLTreeSeqStEphTrait;
   10|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::*;
   13|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::*;
    6|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::*;
    7|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::*;
    7|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::*;
    7|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::*;
    7|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::*;
    8|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::*;
    8|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::*;
    8|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::*;
    8|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::*;
    9|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::*;
    9|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::*;
    9|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::{AVLTreeSeqStPerS, AVLTreeSeqStPerTrait};
    9|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::{AVLTreeSeqStPerS, AVLTreeSeqStPerTrait};
    6|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::AVLTreeSeqStPerTrait;
    7|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::AVLTreeSeqStPerTrait;
    8|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::AVLTreeSeqStPerTrait;
    9|       |    use crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::AVLTreeSeqStPerTrait;
    9|       |    use crate::Chap37::BSTAVLMtEph::BSTAVLMtEph::*;
    9|       |    use crate::Chap37::BSTBBAlphaMtEph::BSTBBAlphaMtEph::*;
    9|       |    use crate::Chap37::BSTPlainMtEph::BSTPlainMtEph::*;
    9|       |    use crate::Chap37::BSTRBMtEph::BSTRBMtEph::*;
    9|       |    use crate::Chap37::BSTSplayMtEph::BSTSplayMtEph::*;
    9|       |    use crate::Chap39::BSTTreapMtEph::BSTTreapMtEph::*;
   11|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::*;
   12|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::*;
   12|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::*;
   14|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::*;
    6|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::*;
    8|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::*;
    8|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::*;
    8|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::*;
    8|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::*;
    9|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::*;
    9|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::*;
    9|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::*;
    9|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::*;
    8|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::ArraySetStEphTrait;
    8|       |    use crate::Chap41::ArraySetStEph::ArraySetStEph::ArraySetStEphTrait;
   10|       |    use crate::Chap41::AVLTreeSetMtEph::AVLTreeSetMtEph::*;
   10|       |    use crate::Chap41::AVLTreeSetMtPer::AVLTreeSetMtPer::*;
   11|       |    use crate::Chap41::AVLTreeSetMtPer::AVLTreeSetMtPer::*;
   12|       |    use crate::Chap41::AVLTreeSetMtPer::AVLTreeSetMtPer::*;
    7|       |    use crate::Chap41::AVLTreeSetMtPer::AVLTreeSetMtPer::*;
   10|       |    use crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::*;
   15|       |    use crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::*;
    7|       |    use crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::*;
    7|       |    use crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::*;
    7|       |    use crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::*;
    7|       |    use crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::*;
    7|       |    use crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::*;
    9|       |    use crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::*;
    9|       |    use crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::*;
    9|       |    use crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::*;
   10|       |    use crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::*;
   10|       |    use crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::*;
   10|       |    use crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::*;
   10|       |    use crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::*;
    7|       |    use crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::*;
    8|       |    use crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::*;
    8|       |    use crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::*;
    9|       |    use crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::*;
    9|       |    use crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::*;
    9|       |    use crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::*;
   12|       |    use crate::Chap42::TableMtEph::TableMtEph::*;
    7|       |    use crate::Chap42::TableMtEph::TableMtEph::*;
  403|     36|            base_table: crate::Chap42::TableMtEph::TableMtEph::from_sorted_entries(elements),
    8|       |    use crate::Chap42::TableStEph::TableStEph::*;
    9|       |    use crate::Chap42::TableStEph::TableStEph::*;
  375|     21|            base_table: crate::Chap42::TableStEph::TableStEph::from_sorted_entries(elements),
   11|       |    use crate::Chap42::TableStPer::TableStPer::*;
    9|       |    use crate::Chap42::TableStPer::TableStPer::*;
    9|       |    use crate::Chap42::TableStPer::TableStPer::*;
  359|     22|            base_table: crate::Chap42::TableStPer::TableStPer::from_sorted_entries(elements),
    7|       |    use crate::Chap43::OrderedSetStPer::OrderedSetStPer::*;
   15|       |    use crate::Chap43::OrderedTableMtEph::OrderedTableMtEph::*;
    9|       |    use crate::Chap43::OrderedTableMtPer::OrderedTableMtPer::*;
   10|       |    use crate::Chap43::OrderedTableStEph::OrderedTableStEph::*;
    9|       |    use crate::Chap43::OrderedTableStEph::OrderedTableStEph::*;
   10|       |    use crate::Chap43::OrderedTableStPer::OrderedTableStPer::*;
   13|       |    use crate::Chap43::OrderedTableStPer::OrderedTableStPer::*;
    9|       |    use crate::Chap43::OrderedTableStPer::OrderedTableStPer::*;
    7|       |    use crate::Chap44::DocumentIndex::DocumentIndex::*;
    8|       |    use crate::Chap45::BalancedTreePQ::BalancedTreePQ::*;
   16|       |    use crate::Chap45::BinaryHeapPQ::BinaryHeapPQ::*;
   18|       |    use crate::Chap45::BinaryHeapPQ::BinaryHeapPQ::*;
   18|       |    use crate::Chap45::BinaryHeapPQ::BinaryHeapPQ::*;
    9|       |    use crate::Chap45::BinaryHeapPQ::BinaryHeapPQ::*;
    7|       |    use crate::Chap45::HeapsortExample::HeapsortExample::*;
   10|       |    use crate::Chap45::LeftistHeapPQ::LeftistHeapPQ::*;
   11|       |    use crate::Chap45::SortedListPQ::SortedListPQ::*;
   12|       |    use crate::Chap45::UnsortedListPQ::UnsortedListPQ::*;
    8|       |    use crate::Chap47clean::ChainedHashTable::ChainedHashTable::*;
    8|       |    use crate::Chap47clean::ChainedHashTable::ChainedHashTable::*;
    9|       |    use crate::Chap47clean::ChainedHashTable::ChainedHashTable::*;
    8|       |    use crate::Chap47clean::FlatHashTable::FlatHashTable::*;
    8|       |    use crate::Chap47clean::FlatHashTable::FlatHashTable::*;
    8|       |    use crate::Chap47clean::FlatHashTable::FlatHashTable::*;
    7|       |    use crate::Chap47clean::ParaHashTableStEph::ParaHashTableStEph::*;
    7|       |    use crate::Chap47clean::ParaHashTableStEph::ParaHashTableStEph::*;
    7|       |    use crate::Chap47clean::ParaHashTableStEph::ParaHashTableStEph::*;
    7|       |    use crate::Chap47clean::ParaHashTableStEph::ParaHashTableStEph::*;
    7|       |    use crate::Chap47clean::ParaHashTableStEph::ParaHashTableStEph::*;
    7|       |    use crate::Chap47clean::ParaHashTableStEph::ParaHashTableStEph::*;
    7|       |    use crate::Chap47clean::ParaHashTableStEph::ParaHashTableStEph::*;
    8|       |    use crate::Chap47clean::ParaHashTableStEph::ParaHashTableStEph::*;
   11|       |    use crate::Chap50::Probability::Probability::Probability;
   11|       |    use crate::Chap50::Probability::Probability::Probability;
    9|       |    use crate::Chap50::Probability::Probability::Probability;
    9|       |    use crate::Chap50::Probability::Probability::Probability;
   19|       |    use crate::Chap56::AllPairsResultStEphFloat::AllPairsResultStEphFloat::AllPairsResultStEphFloat;
   24|       |    use crate::Chap56::AllPairsResultStEphFloat::AllPairsResultStEphFloat::AllPairsResultStEphFloat;
   19|       |    use crate::Chap56::AllPairsResultStEphInt::AllPairsResultStEphInt::AllPairsResultStEphInt;
   24|       |    use crate::Chap56::AllPairsResultStEphInt::AllPairsResultStEphInt::AllPairsResultStEphInt;
   12|       |    use crate::Chap56::PathWeightUtilsStEph::PathWeightUtilsStEph::*;
   13|       |    use crate::Chap56::PathWeightUtilsStEph::PathWeightUtilsStEph::path_weight_int;
   18|       |    use crate::Chap56::SSSPResultStEphFloat::SSSPResultStEphFloat::SSSPResultStEphFloat;
   19|       |    use crate::Chap56::SSSPResultStEphFloat::SSSPResultStEphFloat::SSSPResultStEphFloat;
   18|       |    use crate::Chap56::SSSPResultStEphInt::SSSPResultStEphInt::SSSPResultStEphInt;
   19|       |    use crate::Chap56::SSSPResultStEphInt::SSSPResultStEphInt::SSSPResultStEphInt;
   20|       |    use crate::Chap57::DijkstraStEphFloat::DijkstraStEphFloat::dijkstra;
   25|       |    use crate::Chap57::DijkstraStEphFloat::DijkstraStEphFloat::dijkstra;
   20|       |    use crate::Chap57::DijkstraStEphInt::DijkstraStEphInt::dijkstra;
   25|       |    use crate::Chap57::DijkstraStEphInt::DijkstraStEphInt::dijkstra;
   21|       |    use crate::Chap58::BellmanFordStEphFloat::BellmanFordStEphFloat::bellman_ford;
   26|       |    use crate::Chap58::BellmanFordStEphFloat::BellmanFordStEphFloat::bellman_ford;
   21|       |    use crate::Chap58::BellmanFordStEphInt::BellmanFordStEphInt::bellman_ford;
   26|       |    use crate::Chap58::BellmanFordStEphInt::BellmanFordStEphInt::bellman_ford;
   15|       |    use crate::Chap61::VertexMatchingMtEph::VertexMatchingMtEph::parallel_matching_mt;
   15|       |    use crate::Chap61::VertexMatchingStEph::VertexMatchingStEph::greedy_matching;
   13|       |    use crate::Chap62::StarContractionMtEph::StarContractionMtEph::star_contract_mt;
   19|       |    use crate::Chap62::StarContractionMtEph::StarContractionMtEph::star_contract_mt;
   13|       |    use crate::Chap62::StarContractionStEph::StarContractionStEph::star_contract;
   17|       |    use crate::Chap62::StarContractionStEph::StarContractionStEph::star_contract;
   16|       |    use crate::Chap62::StarPartitionMtEph::StarPartitionMtEph::parallel_star_partition;
   20|       |    use crate::Chap62::StarPartitionMtEph::StarPartitionMtEph::parallel_star_partition;
   14|       |    use crate::Chap62::StarPartitionStEph::StarPartitionStEph::sequential_star_partition;
   18|       |    use crate::Chap62::StarPartitionStEph::StarPartitionStEph::sequential_star_partition;
   13|       |    use crate::Chap65::UnionFindStEph::UnionFindStEph::UnionFind;
    8|       |    use crate::DocumentCollectionLit;
    8|       |    use crate::OrderedSetStPerLit;
   16|       |    use crate::OrderedTableMtEphLit;
   11|       |    use crate::OrderedTableStEphLit;
   11|       |    use crate::OrderedTableStPerLit;
   10|       |    use crate::ParaPair;
   10|       |    use crate::ParaPair;
   10|       |    use crate::ParaPair;
   11|       |    use crate::ParaPair;
   11|       |    use crate::ParaPair;
   11|       |    use crate::ParaPair;
   11|       |    use crate::ParaPair;
   12|       |    use crate::ParaPair;
   12|       |    use crate::ParaPair;
   12|       |    use crate::ParaPair;
   12|       |    use crate::ParaPair;
   13|       |    use crate::ParaPair;
   13|       |    use crate::ParaPair;
   14|       |    use crate::ParaPair;
   14|       |    use crate::ParaPair;
   14|       |    use crate::ParaPair;
   14|       |    use crate::ParaPair;
   14|       |    use crate::ParaPair;
   14|       |    use crate::ParaPair;
   14|       |    use crate::ParaPair;
   15|       |    use crate::ParaPair;
   16|       |    use crate::ParaPair;
   16|       |    use crate::ParaPair;
   17|       |    use crate::ParaPair;
   17|       |    use crate::ParaPair;
   21|       |    use crate::ParaPair;
    7|       |    use crate::ParaPair;
   11|       |    use crate::prob;
   11|       |    use crate::prob;
   10|       |    use crate::SetLit;
   10|       |    use crate::SetLit;
   10|       |    use crate::SetLit;
   10|       |    use crate::SetLit;
   11|       |    use crate::SetLit;
   12|       |    use crate::SetLit;
   13|       |    use crate::SetLit;
   13|       |    use crate::SetLit;
   13|       |    use crate::SetLit;
   14|       |    use crate::SetLit;
   14|       |    use crate::SetLit;
   14|       |    use crate::SetLit;
   14|       |    use crate::SetLit;
   14|       |    use crate::SetLit;
   14|       |    use crate::SetLit;
   14|       |    use crate::SetLit;
   15|       |    use crate::SetLit;
   15|       |    use crate::SetLit;
   15|       |    use crate::SetLit;
   15|       |    use crate::SetLit;
   15|       |    use crate::SetLit;
   16|       |    use crate::SetLit;
   16|       |    use crate::SetLit;
   17|       |    use crate::SetLit;
   17|       |    use crate::SetLit;
   18|       |    use crate::SetLit;
   19|       |    use crate::SetLit;
   22|       |    use crate::SetLit;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   10|       |    use crate::Types::Types::*;
   11|       |    use crate::Types::Types::*;
   11|       |    use crate::Types::Types::*;
   11|       |    use crate::Types::Types::*;
   11|       |    use crate::Types::Types::*;
   11|       |    use crate::Types::Types::*;
   11|       |    use crate::Types::Types::*;
   11|       |    use crate::Types::Types::*;
   11|       |    use crate::Types::Types::*;
   11|       |    use crate::Types::Types::*;
   11|       |    use crate::Types::Types::*;
   11|       |    use crate::Types::Types::*;
   11|       |    use crate::Types::Types::*;
   11|       |    use crate::Types::Types::*;
   11|       |    use crate::Types::Types::*;
   11|       |    use crate::Types::Types::*;
   11|       |    use crate::Types::Types::*;
   11|       |    use crate::Types::Types::*;
   11|       |    use crate::Types::Types::*;
   11|       |    use crate::Types::Types::*;
   11|       |    use crate::Types::Types::*;
   11|       |    use crate::Types::Types::*;
   11|       |    use crate::Types::Types::*;
   11|       |    use crate::Types::Types::*;
   11|       |    use crate::Types::Types::*;
   11|       |    use crate::Types::Types::*;
   11|       |    use crate::Types::Types::*;
   11|       |    use crate::Types::Types::*;
   12|       |    use crate::Types::Types::*;
   12|       |    use crate::Types::Types::*;
   12|       |    use crate::Types::Types::*;
   12|       |    use crate::Types::Types::*;
   12|       |    use crate::Types::Types::*;
   12|       |    use crate::Types::Types::*;
   12|       |    use crate::Types::Types::*;
   12|       |    use crate::Types::Types::*;
   12|       |    use crate::Types::Types::*;
   12|       |    use crate::Types::Types::*;
   12|       |    use crate::Types::Types::*;
   12|       |    use crate::Types::Types::*;
   12|       |    use crate::Types::Types::*;
   12|       |    use crate::Types::Types::*;
   12|       |    use crate::Types::Types::*;
   12|       |    use crate::Types::Types::*;
   12|       |    use crate::Types::Types::*;
   12|       |    use crate::Types::Types::*;
   13|       |    use crate::Types::Types::*;
   13|       |    use crate::Types::Types::*;
   13|       |    use crate::Types::Types::*;
   13|       |    use crate::Types::Types::*;
   13|       |    use crate::Types::Types::*;
   13|       |    use crate::Types::Types::*;
   13|       |    use crate::Types::Types::*;
   13|       |    use crate::Types::Types::*;
   13|       |    use crate::Types::Types::*;
   13|       |    use crate::Types::Types::*;
   13|       |    use crate::Types::Types::*;
   13|       |    use crate::Types::Types::*;
   13|       |    use crate::Types::Types::*;
   13|       |    use crate::Types::Types::*;
   13|       |    use crate::Types::Types::*;
   14|       |    use crate::Types::Types::*;
   14|       |    use crate::Types::Types::*;
   14|       |    use crate::Types::Types::*;
   14|       |    use crate::Types::Types::*;
   15|       |    use crate::Types::Types::*;
   15|       |    use crate::Types::Types::*;
   15|       |    use crate::Types::Types::*;
   15|       |    use crate::Types::Types::*;
   15|       |    use crate::Types::Types::*;
   15|       |    use crate::Types::Types::*;
   15|       |    use crate::Types::Types::*;
   15|       |    use crate::Types::Types::*;
   15|       |    use crate::Types::Types::*;
   15|       |    use crate::Types::Types::*;
   15|       |    use crate::Types::Types::*;
   15|       |    use crate::Types::Types::*;
   15|       |    use crate::Types::Types::*;
   15|       |    use crate::Types::Types::*;
   15|       |    use crate::Types::Types::*;
   15|       |    use crate::Types::Types::*;
   15|       |    use crate::Types::Types::*;
   15|       |    use crate::Types::Types::*;
   15|       |    use crate::Types::Types::*;
   16|       |    use crate::Types::Types::*;
   16|       |    use crate::Types::Types::*;
   16|       |    use crate::Types::Types::*;
   16|       |    use crate::Types::Types::*;
   16|       |    use crate::Types::Types::*;
   16|       |    use crate::Types::Types::*;
   17|       |    use crate::Types::Types::*;
   17|       |    use crate::Types::Types::*;
   17|       |    use crate::Types::Types::*;
   17|       |    use crate::Types::Types::*;
   17|       |    use crate::Types::Types::*;
   18|       |    use crate::Types::Types::*;
   18|       |    use crate::Types::Types::*;
   18|       |    use crate::Types::Types::*;
   18|       |    use crate::Types::Types::*;
   18|       |    use crate::Types::Types::*;
   18|       |    use crate::Types::Types::*;
   19|       |    use crate::Types::Types::*;
   19|       |    use crate::Types::Types::*;
   19|       |    use crate::Types::Types::*;
   19|       |    use crate::Types::Types::*;
   19|       |    use crate::Types::Types::*;
   19|       |    use crate::Types::Types::*;
   20|       |    use crate::Types::Types::*;
   20|       |    use crate::Types::Types::*;
   20|       |    use crate::Types::Types::*;
   20|       |    use crate::Types::Types::*;
   20|       |    use crate::Types::Types::*;
   20|       |    use crate::Types::Types::*;
   22|       |    use crate::Types::Types::*;
   22|       |    use crate::Types::Types::*;
   23|       |    use crate::Types::Types::*;
   27|       |    use crate::Types::Types::*;
   27|       |    use crate::Types::Types::*;
   39|       |    use crate::Types::Types::*;
   39|       |    use crate::Types::Types::*;
    6|       |    use crate::Types::Types::*;
    7|       |    use crate::Types::Types::*;
    7|       |    use crate::Types::Types::*;
    7|       |    use crate::Types::Types::*;
    7|       |    use crate::Types::Types::*;
    7|       |    use crate::Types::Types::*;
    7|       |    use crate::Types::Types::*;
    7|       |    use crate::Types::Types::*;
    7|       |    use crate::Types::Types::*;
    7|       |    use crate::Types::Types::*;
    7|       |    use crate::Types::Types::*;
    7|       |    use crate::Types::Types::*;
    7|       |    use crate::Types::Types::*;
    7|       |    use crate::Types::Types::*;
    7|       |    use crate::Types::Types::*;
    7|       |    use crate::Types::Types::*;
    7|       |    use crate::Types::Types::*;
    7|       |    use crate::Types::Types::*;
    7|       |    use crate::Types::Types::*;
    7|       |    use crate::Types::Types::*;
    7|       |    use crate::Types::Types::*;
    7|       |    use crate::Types::Types::*;
    7|       |    use crate::Types::Types::*;
    7|       |    use crate::Types::Types::*;
    8|       |    use crate::Types::Types::*;
    8|       |    use crate::Types::Types::*;
    8|       |    use crate::Types::Types::*;
    8|       |    use crate::Types::Types::*;
    8|       |    use crate::Types::Types::*;
    8|       |    use crate::Types::Types::*;
    8|       |    use crate::Types::Types::*;
    8|       |    use crate::Types::Types::*;
    8|       |    use crate::Types::Types::*;
    8|       |    use crate::Types::Types::*;
    8|       |    use crate::Types::Types::*;
    8|       |    use crate::Types::Types::*;
    8|       |    use crate::Types::Types::*;
    8|       |    use crate::Types::Types::*;
    8|       |    use crate::Types::Types::*;
    8|       |    use crate::Types::Types::*;
    8|       |    use crate::Types::Types::*;
    8|       |    use crate::Types::Types::*;
    8|       |    use crate::Types::Types::*;
    8|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
    9|       |    use crate::Types::Types::*;
  101|       |            // Create mutable copy for memoization
  102|       |            // Create mutable copy for memoization
  108|       |        /// Create new advanced double hashing strategy
  108|       |        // Create vertices including dummy
  112|       |            // Create new sequence without the minimum element
  113|       |        /// Create new advanced quadratic probing strategy with default coefficients
  115|       |            // Create new table with updated entry
  120|       |            // Create mutable copy for memoization
  120|       |        /// Create strategy with validation disabled (for performance comparison)
  123|       |            // Create new sequence without the first element
  124|       |            // Create mutable copy for memoization
  127|       |        /// Create strategy with custom coefficients
  136|       |        /// Create priority queue from existing sequence
  140|       |        /// Create strategy with all features disabled (for performance comparison)
  153|       |    /// Create result for negative cycle case
  159|       |        /// Create priority queue from sequence by inserting elements one by one
   15|       |        /// Create a new empty Union-Find structure
   15|       |//! // Create graph using API
   15|       |//! // Create graph using API
  164|       |        /// Create new instance with updated memoization table
  169|       |        /// Create sequence from a Vec (used by `arrayseq!` and tests). <br/>
  171|       |        // Create an ordered set of integers
  175|       |            // Create boolean sequence for keep/filter results
  179|       |        /// Create priority queue from sequence by insertion sort
   17|       |        /// Create from vertices and weighted edges
   17|       |        /// Create from vertices and weighted edges
   17|       |        /// Create new bottom-up DP solver
   17|       |        /// Create new bottom-up DP solver
   17|       |        /// Create new probability from f64
   17|       |        /// Create new top-down DP solver
   17|       |        /// Create new top-down DP solver
   18|       |        /// Create a new sequence of length `length` with each element initialized to `init_value`. <br/>
   19|       |        /// Create new bottom-up DP solver
   19|       |        /// Create new bottom-up DP solver
   19|       |        /// Create new top-down DP solver
   19|       |        /// Create new top-down DP solver
  206|       |    /// Create result for negative cycle case
  209|       |    /// Create result for negative cycle case
   20|       |        /// Create empty nested hash table with given initial size
   20|       |//! // Create graph using macro with APAS notation (A: for directed arcs)
   20|       |//! // Create graph using macro with APAS notation (E: for undirected edges)
  212|       |            // Create test key for analysis
  218|       |        /// Create priority queue from vector (for testing)
   21|       |        /// Create from vertices and weighted edges
   21|       |        /// Create from vertices and weighted edges
   21|       |        /// Create from vertices and weighted edges
   21|       |        /// Create from vertices and weighted edges
   21|       |        /// Create new empty stack
   21|       |        /// Create new subset sum solver
   21|       |        /// Create new subset sum solver
  229|       |            // Create new sequence with last element at root and without the last element
   22|       |        /// Create new minimum edit distance solver
   22|       |        /// Create new minimum edit distance solver
   22|       |        /// Create new subset sum solver
  230|       |            // Create new sequence without the last element
  234|       |        /// Create singleton and meld with existing heap
   23|       |        /// Create new minimum edit distance solver
   23|       |        /// Create new subset sum solver
  240|       |            // Create a mutable copy of the base sequence
  248|       |        // Create a table with 50% load factor (α = 1/2)
   24|       |        /// Create new minimum edit distance solver
   25|       |        /// Create new all-pairs result
   25|       |        /// Create new SSSP result
   25|       |        // Create the ordered set A = {'artie', 'burt', 'finn', 'mike', 'rachel', 'sam', 'tina'}
   26|       |        /// Create from multiset
   26|       |        /// Create from multiset
   26|       |        /// Create new all-pairs result
   26|       |        /// Create new matrix chain solver
   26|       |        /// Create new matrix chain solver
   26|       |        /// Create new SSSP result
  270|       |            // Create singletons for each element
  277|      1|   - Create new table with target size
   27|       |        /// Create from multiset
   27|       |        /// Create from source and target sequences
   27|       |        /// Create from source and target sequences
   27|       |        /// Create new all-pairs result
   27|       |        // Create tables using different implementations
  284|       |        /// Create priority queue from vector (for testing)
   28|       |        /// Create from multiset
   28|       |        /// Create from source and target sequences
   28|       |        /// Create new all-pairs result
   28|       |        /// Create new matrix chain solver
   28|       |        /// Create new matrix chain solver
   28|       |        /// Create new optimal BST solver
   28|       |        /// Create new optimal BST solver
   28|       |        /// Create new SSSP result
   28|       |        /// Create new SSSP result
   29|       |        /// Create from matrix dimensions
   29|       |        /// Create from matrix dimensions
   29|       |        /// Create from source and target sequences
   29|       |        /// Create new optimal BST solver
   29|       |        /// Create new optimal BST solver
   30|       |        /// Create a new probability value
  315|       |        /// Create priority queue from vector (for testing)
   31|       |        /// Create from keys and probabilities
   31|       |        /// Create from keys and probabilities
   31|       |        /// Create from matrix dimensions
   31|       |        /// Create from matrix dimensions
   31|       |        /// Create new advanced linear probing strategy
  325|       |        /// Create priority queue from vector (for testing)
   32|       |        /// Create from dimension pairs (rows, cols)
   32|       |        /// Create from dimension pairs (rows, cols)
   32|       |        /// Create from keys and probabilities
   32|       |        /// Create from keys and probabilities
  343|       |        // Create a table with prime size 17
   34|       |        /// Create from dimension pairs (rows, cols)
   34|       |        /// Create from dimension pairs (rows, cols)
   34|       |        /// Create from key-probability pairs
   34|       |        /// Create from key-probability pairs
  353|       |        /// Create empty analysis for disabled analyzer
   35|       |        /// Create from key-probability pairs
   35|       |        /// Create from key-probability pairs
  371|       |        /// Create priority queue from vector (for testing)
   39|       |        // Create candidates: 2, 3, ..., n
   41|       |        /// Create strategy with clustering analysis disabled
   44|       |        /// Create infinity value for fold operations
   44|       |            // Create mutable copy for computation
   44|       |            // Create mutable DP table for computation
   45|       |        /// Create from vertices and weighted edges
   45|       |        /// Create from vertices and weighted edges
   46|       |        /// Create a new empty Union-Find structure
   46|       |            // Create shared DP table for parallel computation
   46|       |            // Create shared mutable DP table for parallel computation
   47|       |            // Create a new sequence from the elements
   49|       |            // Create a new sequence from the elements
   49|       |        // Create vertex to index mapping for inject operation
   49|       |        /// Create zero probability
   50|       |        /// Create new probe sequence analyzer
   51|       |        // Create a mapping from original vertices to their block representatives
   52|       |            // Create mutable copy of memo table for computation
   59|       |        /// Create minimal analyzer for performance testing
   62|       |        // Create a mapping from original vertices to their block representatives
   69|       |        /// Create new clustering analyzer
   73|       |        /// Create a new node with correct rank and leftist property
   75|       |            // Create sequence of singleton sets ⟨{x} : x ∈ a⟩
   77|       |            // Create sequence of singleton sets ⟨{x} : x ∈ a⟩
   78|       |        /// Create minimal analyzer for performance testing
   82|       |        // Create a map from edges to their coin flips (heads = true, tails = false)
   93|       |        /// Create new instance with updated memoization table
  355|      1|        fn create_empty_analysis(
  136|      0|    fn create_negative_cycle_result(n: usize) -> AllPairsResultStEphFloat {
  154|      0|    fn create_negative_cycle_result(n: usize) -> AllPairsResultStEphInt {
  207|      0|    fn create_negative_cycle_result(n: usize) -> AllPairsResultStEphInt {
  210|      0|    fn create_negative_cycle_result(n: usize) -> AllPairsResultStEphFloat {
   58|      0|                return create_negative_cycle_result(n);
   68|      0|                return create_negative_cycle_result(n);
   68|      0|                return create_negative_cycle_result(n);
   16|       |        /// Creates an empty sequence
   21|       |    /// Creates the document index for the tweet collection
  230|       |    /// Creates a partially applied find function for a given index
   29|       |    /// Creates a partially applied find function for the tweet index
   31|       |        /// Creates an index from a sequence of (id, contents) pairs
   43|       |        /// Creates heap from sequence using bottom-up heapify
   43|       |        /// Creates priority queue from sequence
   43|       |        /// Creates priority queue from sequence by sorting
   43|       |        /// Creates priority queue from sequence using balanced tree construction
   45|       |        /// Creates an empty hash table with the given initial size.
   45|       |        /// Creates a new empty stack
   49|       |        /// Creates a new all-pairs result structure initialized for n vertices.
   49|       |        /// Creates a new SSSP result structure initialized for n vertices from given source.
   50|       |        /// Creates a new all-pairs result structure initialized for n vertices.
   50|       |        /// Creates a new SSSP result structure initialized for n vertices from given source.
   51|       |        /// Creates a new all-pairs result structure initialized for n vertices.
   52|       |        /// Creates a new all-pairs result structure initialized for n vertices.
   52|       |        /// Creates a new SSSP result structure initialized for n vertices from given source.
   52|       |        /// Creates a new SSSP result structure initialized for n vertices from given source.
   55|       |        /// Creates heap from sequence using reduce with meld
   63|       |        /// Creates an empty sequence.
   47|     29|        fn createTable(hash_fn: HashFun<Key>, initial_size: N) -> HashTable<Key, Value, Entry, Metrics> {
  101|     16|            let crossing_pair = ParaPair!(move || max_suffix_sum(&left_for_suffix), move || max_prefix_sum(
   25|       |        // cs = 〈 i * j : 2 ≤ i ≤ floor(sqrt(n)) , 2 ≤ j ≤ n/i 〉
  272|      1|                let cur = self.current.take();
   90|     14|        match cur {
   90|     67|        match cur {
  312|      0|                let curr = self.elements.nth(i);
  343|      4|                let curr = self.elements.nth(i);
  105|  5.50k|                let current = self.elements.nth(i);
  106|  5.50k|                if current < min_element {
  109|     15|            while current != self.source {
  111|      4|            while current != self.source {
  116|      4|            while current != self.source {
  119|      4|            while current != self.source {
  122|      4|            while current != u {
  124|      4|            while current != u {
  124|      4|            while current != u {
  126|      4|            while current != u {
  131|     33|                match current {
  142|     88|                match current {
  225|     26|                let current = self.elements.nth(i);
  226|     26|                if current == element {
  229|     19|                if current > element {
  242|      7|                if current == element {
  249|      5|                if current > element {
  262|      7|            for current in values.iter() {
  263|      7|                if current >= min_val && current <= max_val {
  277|      0|                let current = self.clone();
  279|      0|                return (current, Self::empty());
  298|      8|                let current = a.nth(i).clone();
  327|      4|                let current = a.nth_cloned(i);
  333|      0|                let current = self.clone();
  335|      0|                return (current, Self::empty());
  339|      8|                let current = a.nth_cloned(i);
  363|      0|                let current = self.clone();
  365|      0|                return (current, Self::empty());
  373|     10|                let current = self.elements.nth(i);
  374|     10|                if current < element {
  398|     10|                let current = self.elements.nth(i);
  416|      7|                let current = self.elements.nth(i);
   65|      4|                match current {
   68|     29|                match current {
   76|    319|                let current = self.elements.nth(i);
   77|    319|                if current < min_element {
   79|     72|                match current {
   83|    974|                let current = self.elements.nth(i);
   90|    518|                let current = result.nth(i);
   93|    518|                if current >= parent {
  100|      2|                (neighbor.clone(), current.clone())
   92|      2|                (neighbor.clone(), current.clone())
   66|    224|                let current_dist = *distances.get(&v).unwrap_or(&i64::MAX);
   76|    183|                let current_dist = *distances.get(&v).unwrap_or(&OrderedF64::from(f64::INFINITY));
  163|      1|            let current_edges: Vec<_> = self.labeled_arcs().iter().cloned().collect();
  289|     21|            while !current_heap.is_empty() {
  305|     12|            while !current_heap.is_empty() {
  116|      4|            while !current.is_null() {
   38|     19|        while !current_layer.is_empty() {
   38|     19|        while !current_layer.is_empty() {
  165|     41|            while !current_pq.is_empty() {
   27|       |        pub current_size: N,
  221|    269|        if !current_word.is_empty() {
   11|       |    /// Custom linked list node.
   19|       |    /// Custom linked list for chained hash table.
    3|       |//! Uses custom linked list struct for separate chaining collision resolution.
    7|       |//! the cycle become arbitrarily small (approach negative infinity).
    6|       |pub mod CycleDetectStEph {
    6|       |pub mod CycleDetectStPer {
    3|       |//! Detects cycles in directed graphs using ancestor tracking.
    3|       |//! Detects cycles in directed graphs using ephemeral ancestor tracking.
    3|       |//! Sorts DAG vertices in topological order using decreasing finish times.
    3|       |//! Sorts DAG vertices in topological order using ephemeral structures.
  118|      9|            let data = repeat_vec(length, init_value);
   12|       |    /// Data Type 18.1 (Boolean) type used by APAS.
  141|      5|            quick_sort(&mut data);
  150|      5|            let data = vec![item];
  164|     10|            let data: Vec<T> = guard[sub.start..sub.end].iter().cloned().collect();
   16|       |    /// Data Type 18.1: Generic sequence trait for array-backed sequences.
   16|       |    /// Data Type 18.1 (Ordering) relationships used by APAS, using Rust's as it matches.
  182|      5|            quick_sort(&mut data);
   22|       |    /// Data Type 45.1: Meldable Priority Queue with efficient O(log n) meld
   38|       |    /// Data Structure 47.6: Parametric Flat Hash Table
   90|      7|            quick_sort(&mut data);
  120|  13.3k|                    if data[i] < pivot {
  122|   425k|                        if data[i] < pivot {
  161|  8.92k|                    if data[i] < pivot {
  162|  2.17k|                        if data[i] < pivot {
   69|  46.1k|                    if data[i] < pivot {
   71|  26.6k|                        if data[i] < pivot {
   51|      1|        table_eph.insert(4, "Dave".to_string(), |_old, new| new.clone());
   54|      1|        table_mt.insert(4, "Dave".to_string(), |_old, new| new.clone());
  109|       |    #[derive(Clone, Debug)]
   10|       |    #[derive(Clone, Debug)]
   10|       |    #[derive(Clone, Debug)]
   10|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   10|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   11|       |    #[derive(Clone, Debug)]
   11|       |    #[derive(Clone, Debug)]
   11|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   11|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   11|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   11|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   12|       |    #[derive(Clone, Debug)]
   12|       |    #[derive(Clone, Debug)]
   12|       |    #[derive(Clone, Debug)]
   12|       |    #[derive(Clone, Debug)]
   12|       |    #[derive(Clone, Debug)]
   12|       |    #[derive(Clone, Debug)]
   12|       |    #[derive(Clone, Debug)]
   12|       |    #[derive(Clone, Debug)]
   12|       |    #[derive(Clone, Debug)]
   12|       |    #[derive(Clone, Debug, PartialEq)]
   12|       |    #[derive(Clone, Debug, PartialEq)]
   12|       |    #[derive(Clone, Debug, PartialEq)]
   13|       |    #[derive(Clone, Debug)]
   13|       |    #[derive(Clone, Debug)]
   13|       |    #[derive(Clone, Debug)]
   13|       |    #[derive(Clone, Debug, PartialEq)]
   13|       |    #[derive(Clone, Debug, PartialEq)]
   13|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   13|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   13|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   13|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   13|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   13|       |    #[derive(Clone, Debug, PartialEq, Eq)]
  140|       |    #[derive(Clone, Debug)]
  148|       |    #[derive(Clone, Debug)]
   14|       |    #[derive(Clone, Debug)]
   14|       |    #[derive(Clone, Debug)]
   14|       |    #[derive(Clone, Debug)]
   14|       |    #[derive(Clone, Debug)]
   14|       |    #[derive(Clone, Debug)]
   14|       |    #[derive(Clone, Debug)]
   15|       |    #[derive(Clone, Debug)]
   15|       |    #[derive(Clone, Debug)]
   15|       |    #[derive(Clone, Debug)]
   16|       |    #[derive(Clone, Debug)]
   16|       |    #[derive(Clone, Debug, PartialEq)]
   16|       |    #[derive(Clone, Debug, PartialEq)]
   17|       |    #[derive(Clone, Debug)]
   18|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   18|       |    #[derive(Clone, Debug, PartialEq, Eq)]
  208|       |    #[derive(Clone, Debug)]
   20|       |    #[derive(Clone, Debug)]
   20|       |    #[derive(Clone, Debug)]
   20|       |    #[derive(Clone, Debug)]
   20|       |    #[derive(Clone, Debug, PartialEq)]
   20|       |    #[derive(Clone, Debug, PartialEq)]
   20|       |    #[derive(Clone, Debug, PartialEq)]
   21|       |    #[derive(Clone, Debug)]
   21|       |    #[derive(Clone, Debug)]
   21|       |    #[derive(Clone, Debug, PartialEq)]
   23|       |    #[derive(Clone, Debug, PartialEq)]
  246|       |    impl Debug for DocumentIndex {
   24|       |    #[derive(Clone, Debug, PartialEq)]
  261|       |    impl<T: Debug + Copy> std::fmt::Debug for AVLTreeS<T> {
   26|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   26|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   26|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   26|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   28|       |    #[derive(Clone, Debug)]
   28|       |    #[derive(Clone, Debug)]
   28|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   28|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   30|       |    #[derive(Clone, Debug)]
   30|       |    #[derive(Clone, Debug, PartialEq)]
  333|       |    impl<T: Debug> Debug for ArraySeqS<T> {
   35|       |    #[derive(Clone, Debug)]
  360|       |            #[derive(Clone, Debug)]
   36|       |    #[derive(Clone, Debug)]
   39|       |    #[derive(Clone, Debug)]
   40|       |    #[derive(Clone, Debug, PartialEq)]
   41|       |    #[derive(Clone, Debug)]
   41|       |    #[derive(Clone, Debug)]
   43|       |    #[derive(Clone, Debug)]
   49|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   50|       |    #[derive(Clone, Debug)]
   56|       |    #[derive(Clone, Debug)]
   57|       |    #[derive(Clone, Debug, PartialEq, Eq)]
   62|       |    #[derive(Clone, Debug)]
   80|       |    #[derive(Clone, Debug)]
   96|       |    impl Debug for Probability {
    9|       |    #[derive(Clone, Debug)]
    9|       |    #[derive(Clone, Debug)]
    9|       |    #[derive(Clone, Debug)]
  103|      1|            T: Default,
  107|      1|            T: Default,
  109|      0|        fn default() -> Self { Self::new() }
  110|      0|        fn default() -> Self { Self::new() }
  117|      0|        fn default() -> Self { Self::empty() }
  119|      1|            T: Default,
  130|      0|        fn default() -> Self { Self::empty() }
  131|       |    impl Default for BottomUpDPStPerS {
  132|      1|        fn default() -> Self {
  139|       |    /// Default key equality using Rust's PartialEq
  139|       |    impl Default for BottomUpDPStEphS {
  140|      3|        fn default() -> Self {
  146|      0|        fn default() -> Self { Self::empty() }
  146|       |    impl Default for TopDownDPStPerS {
  147|      4|        fn default() -> Self {
  147|       |    impl Default for TopDownDPStEphS {
  148|      4|        fn default() -> Self {
  164|       |    impl Default for BottomUpDPMtPerS {
  165|      1|        fn default() -> Self {
  175|       |    impl Default for BottomUpDPMtEphS {
  176|      1|        fn default() -> Self {
  178|      0|        fn default() -> Self { Self::empty() }
  179|      0|        fn default() -> Self { Self::empty() }
  186|      0|        fn default() -> Self { Self::empty() }
  217|      0|        fn default() -> Self { Self::empty() }
  227|      0|        fn default() -> Self { Self::new() }
  234|       |    impl Default for TopDownDPMtPerS {
  235|      4|        fn default() -> Self {
  242|       |    impl Default for TopDownDPMtEphS {
  243|      4|        fn default() -> Self {
  245|      0|        fn default() -> Self { Self::empty() }
  249|      0|        fn default() -> Self { Self::empty() }
   24|       |            T: Default;
   24|       |            T: Default;
   25|       |            T: Default;
   25|       |            T: Default;
   25|       |            T: Default;
  268|      0|        fn default() -> Self { Self::empty() }
   26|       |            T: Default;
   26|       |            T: Default;
  276|      1|        fn default() -> Self { Self::empty() }
   27|       |            T: Default;
  332|      1|        fn default() -> Self { Self::empty() }
  366|      1|        fn default() -> Self { Self::empty() }
   55|       |    impl Default for Probability {
   56|      0|        fn default() -> Self { Probability::zero() }
   64|      0|        fn default() -> Self { Self::new() }
   65|     28|        fn default() -> Self { Self::new() }
   66|      0|        fn default() -> Self { Self::new() }
   66|      0|        fn default() -> Self { Self::new() }
   66|      1|        fn default() -> Self { Self::new() }
   66|      1|        fn default() -> Self { Self::new() }
   66|      1|        fn default() -> Self { Self::new() }
   66|      1|        fn default() -> Self { Self::new() }
   66|      1|        fn default() -> Self { Self::new() }
   67|      0|        fn default() -> Self { Self::new() }
   68|      0|        fn default() -> Self { Self::new() }
   72|      1|        fn default() -> Self { Self::new() }
   73|      1|        fn default() -> Self { Self::new() }
   74|       |    impl Default for SpinLock {
   75|      0|        fn default() -> Self { SpinLock::new() }
   79|      1|            T: Default,
   83|      1|            T: Default,
   86|      0|        fn default() -> Self { Self::empty() }
   88|      1|            T: Default,
   97|      1|            T: Default,
   98|      1|            T: Default,
  146|     27|                AdvancedDoubleHashingStrategy::new(DefaultHashFunction, DefaultHashFunction);
  221|     14|                AdvancedLinearProbingStrategy<String, DefaultHashFunction>,
  231|     14|                AdvancedQuadraticProbingStrategy<String, DefaultHashFunction>,
  237|     14|                AdvancedDoubleHashingStrategy::new(DefaultHashFunction, DefaultHashFunction);
  378|      1|            AdvancedQuadraticProbingStrategy<String, DefaultHashFunction>,
  102|       |        /// Definition 18.19 (scan). Prefix-reduce returning partial sums and total. <br/>
  137|       |        /// Definition 18.2 (subseq view). Return a slice for the subsequence starting at `start`
  146|       |        /// Definition 18.12 (subseq). Extract a contiguous subsequence starting at `start` with length `length`. <br/>
  207|       |    /// Definition 47.2: α = n/m
   28|       |        /// Definition 18.1 (length). Return the number of elements. <br/>
   36|       |        /// Definition 18.1 (empty). Construct the empty sequence. <br/>
   40|       |        /// Definition 18.1 (singleton). Construct a singleton sequence containing `item`. <br/>
   52|       |        /// Definition 18.12 (subseq). Extract a contiguous subsequence, truncating out-of-bounds ranges. <br/>
   58|       |        /// Definition 18.13 (append). Concatenate two sequences. <br/>
    5|       |//! Abstract: Definition 17.1 (Sequence) — runtime-sized, dense-domain sequence (0..n-1),
   62|       |        /// Definition 18.14 (filter). Keep elements satisfying `pred`. <br/>
   66|       |        /// Definition 18.15 (flatten). Concatenate a sequence of sequences. <br/>
   70|       |        /// Definition 18.16 (update). Return a copy with the index replaced by the new value. <br/>
   74|       |        /// Definition 18.17 (inject). Apply updates, keeping the first update per index. <br/>
   78|       |        /// Definition 18.5 (isEmpty). true iff the sequence has length zero. <br/>
   82|       |        /// Definition 18.5 (isSingleton). true iff the sequence has length one. <br/>
   93|       |        /// Definition 18.7 (iterate). Fold with accumulator `seed`.
   96|       |        /// Definition 18.18 (reduce). Combine elements using associative `f` and identity `id`. <br/>
  154|     46|            let deflated = <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::map(a, &|x| {
  169|     31|            let deflated = <ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::map(a, &|x| {
  143|     49|        fn deflate<F: Fn(&T) -> B>(f: &F, x: &T) -> ArraySeqStPerS<T> {
  158|     35|        fn deflate<F: Fn(&T) -> B>(f: &F, x: &T) -> ArraySeqStEphS<T> {
  160|      1|        fn deflate<F: Fn(&T) -> B + Send + Sync>(f: &F, x: &T) -> ArraySeqMtEphS<T> {
  218|       |        fn deflate<F: Fn(&T) -> B>(f: &F, x: &T) -> Self;
  309|      2|        fn deflate<F: Fn(&T) -> B + Send + Sync>(f: &F, x: &T) -> ArraySeqMtPerS<T> {
  311|      3|        fn deflate<F: Fn(&T) -> B>(f: &F, x: &T) -> Self {
   44|       |        fn deflate<F: Fn(&T) -> B + Send + Sync>(f: &F, x: &T) -> ArraySeqMtEphS<T>;
   45|       |        fn deflate<F: Fn(&T) -> B>(f: &F, x: &T) -> ArraySeqStEphS<T>;
   45|       |        fn deflate<F: Fn(&T) -> B>(f: &F, x: &T) -> ArraySeqStPerS<T>;
   78|       |        fn deflate<F: Fn(&T) -> B + Send + Sync>(f: &F, x: &T) -> ArraySeqMtPerS<T>;
  371|      2|             probing degrades rapidly beyond α = 0.7."
  123|       |        /// Degree (in undirected graphs, in-degree equals total degree)
  126|       |        /// Degree (in undirected graphs, out-degree equals total degree)
  151|       |        /// Degree (in undirected graphs, in-degree equals total degree)
  154|       |        /// Degree (in undirected graphs, out-degree equals total degree)
  201|       |        /// Degree (in undirected graphs, in-degree equals total degree)
  204|       |        /// Degree (in undirected graphs, out-degree equals total degree)
  208|       |        /// Degree (in undirected graphs, in-degree equals total degree)
  211|       |        /// Degree (in undirected graphs, out-degree equals total degree)
  100|     22|        fn Degree(&self, v: &V) -> N { self.NG(v).size() }
  146|     12|        fn Degree(&self, v: &V) -> N { self.InDegree(v) + self.OutDegree(v) }
  185|     83|        fn Degree(&self, v: &V) -> N { self.NG(v).size() }
  337|  1.57k|        fn Degree(&self, v: &V) -> N { self.InDegree(v) + self.OutDegree(v) }
   52|       |        fn Degree(&self, v: &V) -> N;
   55|       |        fn Degree(&self, v: &V) -> N;
   64|       |        fn Degree(&self, v: &V) -> N;
   67|       |        fn Degree(&self, v: &V) -> N;
  346|       |            // Delegate to Chap18 implementation concept - apply updates with leftmost wins
  357|       |            // Delegate to Chap18 implementation concept - apply updates with rightmost wins
  106|       |        // Delete an entry to create a "Dead" slot
  194|       |        // Delete operation
   50|      3|        fn delete_chained(table: &mut HashTable<Key, Value, Entry, Metrics>, key: &Key) -> B {
  107|     14|                let delete_cost = table[i - 1][j];
  109|     15|                let delete_cost = table[i - 1][j];
  142|     14|                let delete_cost = table_guard[i - 1][j];
  143|     14|                let delete_cost = table_guard[i - 1][j];
  145|     29|                        let delete_cost = handle2.join().unwrap();
  147|     22|                        let delete_cost = handle2.join().unwrap();
   66|    134|                        let delete_cost = self.min_edit_distance_rec(i - 1, j);
   77|      6|                        let delete_cost = 1 + self.med_recursive(i - 1, j);
   80|      6|                        let delete_cost = 1 + self.med_recursive(i - 1, j, memo);
   81|    494|                        let delete_cost = self.min_edit_distance_rec(i - 1, j);
   82|      6|                        let delete_cost = 1 + self.med_recursive_concurrent(i - 1, j);
   82|     77|                        let delete_cost = handle1.join().unwrap();
   84|      6|                        let delete_cost = 1 + self.med_recursive_concurrent(i - 1, j);
   98|     96|                        let delete_cost = handle1.join().unwrap();
   18|       |        /// Deleted slot - previously occupied, now available for insertion
  109|      1|        fn delete_edge(&mut self, u: &V, v: &V) { self.edges.delete(&Pair(u.clone(), v.clone())); }
  133|      1|        fn delete_edge(&mut self, u: &V, v: &V) {
   41|       |        fn delete_edge(&mut self, u: &V, v: &V);
   42|       |        fn delete_edge(&mut self, u: &V, v: &V);
  104|      1|        fn delete_edge(&self, u: &V, v: &V) -> Self {
  118|      1|        fn delete_edge(&self, u: &V, v: &V) -> Self {
  119|      1|        fn delete_edge(&self, u: N, v: N) -> Self {
  121|      1|        fn delete_edge(&self, u: &V, v: &V) -> Self {
  140|      2|        fn delete_edge(&self, u: &V, v: &V) -> Self {
   33|       |        fn delete_edge(&self, u: N, v: N) -> Self;
   37|       |        fn delete_edge(&self, u: &V, v: &V) -> Self;
   41|       |        fn delete_edge(&self, u: &V, v: &V) -> Self;
   43|       |        fn delete_edge(&self, u: &V, v: &V) -> Self;
   45|       |        fn delete_edge(&self, u: &V, v: &V) -> Self;
  205|      4|        fn delete_last(&mut self) -> Option<T> { self.data.pop() }
   62|       |        fn delete_last(&mut self) -> Option<T>;
  270|      1|                "O(n) deleteMin dominates".to_string(),
   84|       |            // deleteMin from priority queue
   84|       |            // deleteMin from priority queue
  103|    118|        fn delete_min(&self) -> (Self, Option<T>) {
  116|    254|        fn delete_min(&self) -> (Self, Option<T>) {
  216|    404|        fn delete_min(&self) -> (Self, Option<T>) {
  242|    115|        fn delete_min(&self) -> (Self, Option<T>) {
   34|       |        fn delete_min(&self) -> (Self, Option<T>)
   34|       |        fn delete_min(&self) -> (Self, Option<T>)
   34|       |        fn delete_min(&self) -> (Self, Option<T>)
   34|       |        fn delete_min(&self) -> (Self, Option<T>)
   46|       |        fn delete_min(&self) -> (Self, Option<T>)
   95|    233|        fn delete_min(&self) -> (Self, Option<T>) {
  101|      2|        fn delete(&mut self, x: &T) { self.base_set.delete(x); }
  117|      7|        fn delete(&mut self, k: &K) -> Option<V> {
  121|      8|        fn delete(&mut self, k: &K) -> Option<V> {
  125|      3|        fn delete(&mut self, x: &T) {
  130|      3|        fn delete(&mut self, k: &K) -> Option<V> {
  136|      5|        fn delete(&mut self, k: &K) -> Option<V> {
  150|     48|        fn delete(&mut self, x: &T) {
  156|      1|        fn delete(&mut self, x: N) {
  237|     24|        fn delete(&mut self, x: &T) {
  243|     10|        fn delete(&mut self, key: &K) {
  244|      1|        fn delete(&mut self, target: &T) {
  244|      1|        fn delete(&mut self, target: &T) { BSTSetAVLMtEph::delete(self, target) }
  244|      1|        fn delete(&mut self, target: &T) { BSTSetBBAlphaMtEph::delete(self, target) }
  244|      1|        fn delete(&mut self, target: &T) { BSTSetRBMtEph::delete(self, target) }
  244|      1|        fn delete(&mut self, target: &T) { BSTSetSplayMtEph::delete(self, target) }
  244|      1|        fn delete(&mut self, target: &T) { BSTSetTreapMtEph::delete(self, target) }
   33|      0|        fn delete(&mut self, key: &Key) -> B {
   33|       |        fn delete(&mut self, x: &T);
   33|       |        fn delete(&mut self, x: &T);
   34|      2|        fn delete(&mut self, key: &Key) -> B {
   35|      2|        fn delete(&mut self, key: &Key) -> B {
   37|       |        fn delete(&mut self, k: &K) -> Option<V>;
   38|       |        fn delete(&mut self, x: &T);
   39|       |        fn delete(&mut self, key: &Key) -> B;
   39|       |        fn delete(&mut self, target: &T);
   39|       |        fn delete(&mut self, target: &T);
   39|       |        fn delete(&mut self, target: &T);
   39|       |        fn delete(&mut self, target: &T);
   39|       |        fn delete(&mut self, target: &T);
   39|       |        fn delete(&mut self, target: &T);
   40|       |        fn delete(&mut self, k: &K) -> Option<V>;
   40|       |        fn delete(&mut self, x: &T);
  412|     11|        fn delete(&mut self, key: &K) {
   41|       |        fn delete(&mut self, k: &K) -> Option<V>;
   41|       |        fn delete(&mut self, k: &K) -> Option<V>;
   44|       |        fn delete(&mut self, key: &K);
   45|       |        fn delete(&mut self, x: &T);
   46|       |        fn delete(&mut self, x: N);
   47|       |        fn delete(&mut self, key: &K);
   62|      3|        fn delete(&mut self, key: &Key) -> B {
   98|      2|        fn delete(&mut self, x: &T) {
   48|       |        /// Deletes from the chain at the hashed bucket.
   67|       |        /// Deletes a key from the hash table if it exists.
  104|      2|        fn delete(&self, x: &T) -> Self {
  112|      8|        fn delete(&self, k: &K) -> Self {
  125|      2|        fn delete(&self, k: &K) -> Self {
  148|     22|        fn delete(&self, x: &T) -> Self {
  168|      2|        fn delete(&self, key: &T) {
  247|    982|        fn delete(&self, key: &K) -> Self {
  249|      8|        fn delete(&self, x: &T) -> Self {
  307|       |        fn delete(&self, key: &T);
  323|     27|        fn delete(&self, key: &T) {
   32|       |        fn delete(&self, k: &K) -> Self;
   32|       |        fn delete(&self, x: &T) -> Self;
   33|       |        fn delete(&self, k: &K) -> Self;
  377|      4|        fn delete(&self, key: &T) {
   38|       |        fn delete(&self, x: &T) -> Self;
   39|       |        fn delete(&self, k: &K) -> Self;
   45|       |        fn delete(&self, x: &T) -> Self;
   46|       |        fn delete(&self, key: &T);
   51|       |        fn delete(&self, key: &T);
   64|      2|        fn delete(&self, k: &K) -> Self {
   66|       |        fn delete(&self, key: &K) -> Self;
   54|      1|        fn delete(table: &mut HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> B {
   54|      3|        fn delete(table: &mut HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> B {
   59|      1|        fn delete(table: &mut HashTable<Key, Value, Vec<(Key, Value)>, Metrics>, key: &Key) -> B {
   69|      1|        fn delete(table: &mut HashTable<Key, Value, LinkedList<(Key, Value)>, Metrics>, key: &Key) -> B {
   69|       |        fn delete(table: &mut HashTable<Key, Value, Entry, Metrics>, key: &Key) -> B;
   92|      3|        fn delete(table: &mut HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> B {
   94|      1|        fn delete(table: &mut HashTable<Key, Value, ChainList<Key, Value>, Metrics>, key: &Key) -> B {
   37|       |        fn delete_vertex(&mut self, v: &V);
   38|       |        fn delete_vertex(&mut self, v: &V);
   83|      1|        fn delete_vertex(&mut self, v: &V) {
   99|      1|        fn delete_vertex(&mut self, v: &V) {
  106|      1|        fn delete_vertex(&self, v: &V) -> Self {
   33|       |        fn delete_vertex(&self, v: &V) -> Self;
   37|       |        fn delete_vertex(&self, v: &V) -> Self;
   39|       |        fn delete_vertex(&self, v: &V) -> Self;
   41|       |        fn delete_vertex(&self, v: &V) -> Self;
   79|      1|        fn delete_vertex(&self, v: &V) -> Self {
   94|      1|        fn delete_vertex(&self, v: &V) -> Self {
   96|      1|        fn delete_vertex(&self, v: &V) -> Self {
  108|       |        // Demonstrate tabulate operation
  111|       |        /// Demonstrate query builder pattern
  124|       |        // Demonstrate set operations
  132|       |    /// Demonstrate all heapsort variants on the same input
  144|       |    /// Demonstrate performance characteristics of different table implementations
  145|       |        // Demonstrate the conceptual steps:
  152|       |        // Demonstrate join operation
   16|       |        /// Demonstrate ordered set operations
  181|       |        /// Demonstrate heapsort on reverse-sorted input (worst case for some algorithms)
  183|       |        /// Demonstrate heapsort on already-sorted input
  184|       |        // Demonstrate all ordering operations
  185|       |        /// Demonstrate heapsort on input with duplicates
  187|       |        /// Demonstrate heapsort on single element
  189|       |        /// Demonstrate heapsort on empty input
   18|       |        /// Demonstrate table operations with different implementations
  193|       |        /// Demonstrate the efficiency difference between implementations
  193|       |    /// Demonstrate the tokenization process
  203|       |    /// Demonstrate heapsort on reverse-sorted input (worst case for some algorithms)
  209|       |    /// Demonstrate heapsort on already-sorted input
  215|       |    /// Demonstrate heapsort on input with duplicates
   21|       |        /// Demonstrate set operations with different implementations
  221|       |    /// Demonstrate heapsort on single element
  227|       |    /// Demonstrate heapsort on empty input
  245|       |    /// Demonstrate the efficiency difference between implementations
   28|       |        /// Demonstrate various hash table operations
   37|       |        // Demonstrate find operation
  409|       |        /// Demonstrate the power of O(log n) meld operations
  412|       |        /// Demonstrate parallel heap construction
  416|       |    /// Demonstrate the power of O(log n) meld operations
  429|       |    /// Demonstrate parallel heap construction
   42|       |        // Demonstrate insert operation (persistent vs ephemeral)
   57|       |        // Demonstrate domain operation
   67|       |        // Demonstrate map operation
   91|       |        // Demonstrate filter operation
   30|       |        fn demonstrate_hash_operations();
   18|       |        fn demonstrate_ordered_operations();
   12|       |        /// Demonstrates Example 43.1 from the textbook with lexicographic ordering
  167|       |    /// Demonstrates ordering operations with integer sets for additional clarity
   21|       |    /// Demonstrates Example 43.1 from the textbook with lexicographic ordering
  241|       |    /// Demonstrates worst-case clustering when α = 1/2
  273|      2|            description: "Demonstrates how linear probing creates primary clusters that degrade performance"
  309|       |    /// Demonstrates h1(k) = k mod m, h2(k) = 1 + (k mod (m-1))
  319|       |    /// Demonstrates how double hashing achieves near-optimal probe sequence distribution
  336|       |    /// Demonstrates quadratic probing with m=17 (prime), c1=1, c2=1
  343|      2|            description: "Demonstrates double hashing with h₁(k) = k mod m, h₂(k) = 1 + (k mod (m-1))".to_string(),
   35|       |    /// Demonstrates the example queries from the textbook
  404|       |    /// Demonstrates the importance of prime table sizes for quadratic probing
  451|       |    /// Demonstrates clustering analysis across all three probing strategies
   45|       |    /// Demonstrates heapsort on the standard textbook example dataset
   23|       |        fn demonstrate_set_operations();
   20|       |        fn demonstrate_table_operations();
   80|  7.58k|            fn descend<T: StTInMtT + Ord>(link: &Link<T>, value: T) -> bool {
   33|       |        pub description: String,
  103|      4|        fn description(&self) -> String { format!("PolynomialHashFunction (base={})", self.base) }
  131|      1|        fn description(&self) -> String {
   17|       |        fn description(&self) -> String;
  369|      3|                fn description(&self) -> String { $desc.to_string() }
   51|      0|        fn description(&self) -> String { "DefaultHashFunction (Rust built-in)".to_string() }
   75|     11|        fn description(&self) -> String { "StringPositionHashFunction (Example 47.1)".to_string() }
  344|      1|                if desired_size <= 1 {
   65|       |        pub detailed_metrics: B,
    2|       |//! Cycle Detection - Sequential Ephemeral (Chapter 55, Algorithm 55.10).
    2|       |//! Cycle Detection - Sequential Persistent (Chapter 55, Algorithm 55.10).
   13|       |        /// Detects if a directed graph contains a cycle
   13|       |        /// Detects if a directed graph contains a cycle
   18|       |    /// Detects if a directed graph contains a cycle.
   18|       |    /// Detects if a directed graph contains a cycle.
   40|       |                    // Determine position in left and right sequences
    3|       |//! Recursive DFS for finding reachable vertices from a source vertex.
    3|       |//! Recursive DFS using ephemeral arrays for efficient visited tracking.
   70|       |    /// DFS helper for Euler tour
   75|       |    /// DFS helper for Euler tour
   35|     19|    fn dfs_check_cycle(
   36|     19|    fn dfs_check_cycle(
   27|      6|                if dfs_check_cycle(graph, &mut visited, &mut ancestors, start) {
   55|     13|            if dfs_check_cycle(graph, visited, ancestors, neighbor) {
   58|     27|    fn dfs_finish_order(
   60|     27|    fn dfs_finish_order(
   81|      0|    fn dfs_finish_order(
   96|      0|    fn dfs_finish_order(
   51|     19|    fn dfs_finish_order_cycle_detect(
   59|     19|    fn dfs_finish_order_cycle_detect(
   28|      7|                if !dfs_finish_order_cycle_detect(graph, &mut visited, &mut rec_stack, &mut result, start) {
   29|      7|                match dfs_finish_order_cycle_detect(graph, visited, rec_stack, result, start) {
   71|     12|            if !dfs_finish_order_cycle_detect(graph, visited, rec_stack, result, neighbor) {
   81|     12|            match dfs_finish_order_cycle_detect(graph, visited, rec_stack, result, neighbor) {
   15|       |        fn dfs(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>, source: N) -> AVLTreeSetStEph<N>;
   15|       |        fn dfs(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>, source: N) -> AVLTreeSetStPer<N>;
   96|     30|    fn dfs_reach(
   98|     30|    fn dfs_reach(
   28|     15|    fn dfs_recursive(
   32|     15|    fn dfs_recursive(
    6|       |pub mod DFSStEph {
    6|       |pub mod DFSStPer {
    5|       |//! parallel diagonal pebbling for multi-threaded computation.
    5|       |//! parallel diagonal pebbling with in-place mutations for multi-threaded computation.
  173|      3|                let diff = if h1_value > h2_value {
  131|      1|        let difference = table1.difference(&table2);
  185|       |        // Difference: {1, 2, 3, 4, 5} \ {4, 5, 6, 7, 8} = {1, 2, 3}
  186|      2|        let difference = set1.difference(&set2);
  192|     16|        fn difference_inner(a: &Self, b: &Self) -> Self {
  194|    315|        fn difference_inner(a: &Self, b: &Self) -> Self {
  121|      1|        fn difference(&mut self, other: &Self) {
  122|      1|        fn difference(&mut self, other: &Self) {
  182|      3|        fn difference(&mut self, other: &Self) { self.base_table.difference(&other.base_table); }
  189|      4|        fn difference(&mut self, other: &Self) {
  195|      1|        fn difference(&mut self, other: &Self) {
  203|      1|        fn difference(&mut self, other: &Self) {
  211|      3|        fn difference(&mut self, other: &Self) { self.base_table.difference(&other.base_table); }
  357|      4|        fn difference(&mut self, other: &Self) {
   40|       |        fn difference(&mut self, other: &Self);
   41|       |        fn difference(&mut self, other: &Self);
   41|       |        fn difference(&mut self, other: &Self);
   43|       |        fn difference(&mut self, other: &Self);
   49|       |        fn difference(&mut self, other: &Self);
   53|       |        fn difference(&mut self, other: &Self);
   53|       |        fn difference(&mut self, other: &Self);
   54|       |        fn difference(&mut self, other: &Self);
  113|     56|        fn difference(&self, other: &Self) -> Self {
  115|     62|        fn difference(&self, other: &Self) -> Self {
  130|      1|        fn difference(&self, other: &Self) -> Self {
  132|      1|        fn difference(&self, other: &Self) -> Self {
  157|      2|        fn difference(&self, other: &Self) -> Self {
  186|     62|        fn difference(&self, other: &Self) -> Self {
  192|      1|        fn difference(&self, other: &Self) -> Self {
  194|     16|        fn difference(&self, other: &Self) -> Self {
  208|      1|        fn difference(&self, other: &Self) -> Self {
  250|      1|        fn difference(&self, other: &Self) -> Self { BSTSetAVLMtEph::difference(self, other) }
  250|      1|        fn difference(&self, other: &Self) -> Self { BSTSetBBAlphaMtEph::difference(self, other) }
  250|      1|        fn difference(&self, other: &Self) -> Self { BSTSetRBMtEph::difference(self, other) }
  250|      1|        fn difference(&self, other: &Self) -> Self { BSTSetSplayMtEph::difference(self, other) }
  250|      1|        fn difference(&self, other: &Self) -> Self { BSTSetTreapMtEph::difference(self, other) }
  277|      1|        fn difference(&self, other: &Self) -> Self {
  325|       |        fn difference(&self, other: &Self) -> Self;
   32|       |        fn difference(&self, other: &Self) -> Self;
   32|       |        fn difference(&self, other: &Self) -> Self;
   34|       |        fn difference(&self, other: &Self) -> Self;
  362|      3|        fn difference(&self, other: &Self) -> Self { ParamBST::difference_inner(self, other) }
   39|       |        fn difference(&self, other: &Self) -> Self;
   39|       |        fn difference(&self, other: &Self) -> Self;
   40|       |        fn difference(&self, other: &Self) -> Self;
   40|       |        fn difference(&self, other: &Self) -> Self;
  416|      2|        fn difference(&self, other: &Self) -> Self { ParamTreap::difference_inner(self, other) }
   45|       |        fn difference(&self, other: &Self) -> Self;
   45|       |        fn difference(&self, other: &Self) -> Self;
   45|       |        fn difference(&self, other: &Self) -> Self;
   45|       |        fn difference(&self, other: &Self) -> Self;
   45|       |        fn difference(&self, other: &Self) -> Self;
   45|       |        fn difference(&self, other: &Self) -> Self;
   46|       |        fn difference(&self, other: &Self) -> Self;
   47|       |        fn difference(&self, other: &Self) -> Self;
   59|       |        fn difference(&self, other: &Self) -> Self;
   69|       |        fn difference(&self, other: &Self) -> Self;
   87|      3|        fn difference(&self, other: &Self) -> Self {
    8|       |//! - Dijkstra: Work O(m log n), Span O(m log n) where m = |E|, n = |V|
    8|       |//! - Dijkstra: Work O(m log n), Span O(m log n) where m = |E|, n = |V|
   25|       |        fn dijkstra(graph: &WeightedDirGraphStEphFloat<usize>, source: usize) -> SSSPResultStEphFloat;
   25|       |        fn dijkstra(graph: &WeightedDirGraphStEphInt<usize>, source: usize) -> SSSPResultStEphInt;
  111|     15|            let dijkstra_result = dijkstra(graph, u);
  111|     28|            let dijkstra_result = dijkstra(graph, u);
   65|     15|            let dijkstra_result = dijkstra(&reweighted_graph, u);
   73|     15|            let dijkstra_result = dijkstra(&reweighted_graph, u);
   23|       |        /// Dijkstra's single source shortest path algorithm
   23|       |        /// Dijkstra's single source shortest path algorithm
   10|       |pub mod DijkstraStEphFloat {
   10|       |pub mod DijkstraStEphInt {
  156|      1|            let dim = MatrixDim { rows, cols };
  203|      1|            let dim = MatrixDim { rows, cols };
  105|     10|            let dimensions = dim_pairs
  117|     10|            let dimensions = dim_pairs
  144|     17|            let dimensions: Vec<MatrixDim> = dim_pairs
  154|     19|            let dimensions: Vec<MatrixDim> = dim_pairs
  170|     10|                let dimensions_guard = self.dimensions.lock().unwrap();
  188|      8|            let dimensions_guard = self.dimensions.lock().unwrap();
  214|      7|            let dimensions_guard = self.dimensions.lock().unwrap();
  247|      1|                let dimensions_guard = self.dimensions.lock().unwrap();
  267|      0|                    let dimensions_guard = arc.lock().unwrap();
  279|      0|            let dimensions_guard = self.dimensions.lock().unwrap();
  289|      0|            let dimensions_guard = self.dimensions.lock().unwrap();
   64|     63|            let dimensions_guard = self.dimensions.lock().unwrap();
  169|     10|            let dimensions_len = {
  174|     10|            if dimensions_len <= 1 {
  184|      8|            self.matrix_chain_rec(0, dimensions_len - 1)
  246|      1|            let dimensions_len = {
  145|      2|        fn dimensions_mut(&mut self) -> &mut Vec<MatrixDim> { &mut self.dimensions }
   43|       |        fn dimensions_mut(&mut self) -> &mut Vec<MatrixDim>;
  132|      1|        fn dimensions(&self) -> &Vec<MatrixDim> { &self.dimensions }
  143|      9|        fn dimensions(&self) -> &Vec<MatrixDim> { &self.dimensions }
  173|      6|        fn dimensions(&self) -> &Arc<Vec<MatrixDim>> { &self.dimensions }
  187|      8|        fn dimensions(&self) -> Vec<MatrixDim> {
   40|       |        fn dimensions(&self) -> &Vec<MatrixDim>;
   40|       |        fn dimensions(&self) -> &Vec<MatrixDim>;
   42|       |        fn dimensions(&self) -> &Arc<Vec<MatrixDim>>;
   42|       |        fn dimensions(&self) -> Vec<MatrixDim>;
    7|       |pub mod DirGraphMtEph {
  361|       |    macro_rules! DirGraphMtEphLit {
  117|      0|                graph: DirGraphMtEph<V>,
  262|      0|                graph: DirGraphMtEph<V>,
  307|      0|                graph: DirGraphMtEph<V>,
    4|       |pub mod DirGraphStEph {
  103|       |    // DirGraphStEph-compatible interface for undirected graphs
  137|       |    // DirGraphStEph-compatible interface for labeled undirected graphs
  187|       |    // DirGraphStEph-compatible interface for labeled undirected graphs
  188|       |    // DirGraphStEph-compatible interface for undirected graphs
  170|       |    macro_rules! DirGraphStEphLit {
  100|       |    impl Display for Probability {
  139|       |    impl Display for BottomUpDPStPerS {
  139|       |    impl Display for MatrixChainStPerS {
  147|       |    impl Display for BottomUpDPStEphS {
  154|       |    impl Display for TopDownDPStPerS {
  155|       |    impl Display for TopDownDPStEphS {
  164|       |    impl Display for MatrixDim {
  171|       |    impl Display for MatrixChainStEphS {
  172|       |    impl Display for BottomUpDPMtPerS {
  183|       |    impl Display for BottomUpDPMtEphS {
  189|       |    impl Display for MatrixChainMtPerS {
  203|       |    impl Display for MatrixDim {
  214|       |    impl Display for ProbeSequenceVisualization {
  224|       |    impl Display for MatrixDim {
  228|       |    impl Display for TextbookExampleResults {
  229|       |    impl Display for PrimaryClusteringMetrics {
  235|       |    impl Display for DocumentIndex {
  240|       |    impl Display for MatrixChainMtEphS {
  242|       |    impl Display for TopDownDPMtPerS {
  250|       |    impl Display for TopDownDPMtEphS {
   27|       |    impl<K: Display, V: Display> Display for Pair<K, V> {
  285|       |    impl Display for HashTableStats {
  292|       |    impl Display for DoubleHashingMetrics {
  294|       |    impl Display for MatrixDim {
  319|       |    impl Display for SecondaryClusteringMetrics {
  337|       |    impl<T: Display> Display for ArraySeqS<T> {
   35|       |    impl<A: Display, B: Display, C: Display> Display for Triple<A, B, C> {
  379|       |    impl Display for ComprehensiveClusteringAnalysis {
  410|       |    impl Display for ClusteringPerformanceImpact {
  428|       |    impl Display for ClusteringComparison {
   48|       |    impl<K: Display, V: Display> Display for KeyVal<K, V> {
   51|       |    impl Display for PQEntry {
   51|       |    impl Display for PQEntry {
    6|       |use std::fmt::{Debug, Display};
    6|       |use std::fmt::{Debug, Display};
    6|       |use std::fmt::{Debug, Display, Formatter, Result};
    7|       |use std::fmt::{Debug, Display};
    7|       |use std::fmt::{Debug, Display};
    7|       |use std::fmt::{Debug, Display};
    7|       |use std::fmt::{Debug, Display};
    7|       |use std::fmt::{Debug, Display};
    8|       |use std::fmt::{Debug, Display};
    8|       |use std::fmt::{Debug, Display};
  106|     71|                    let dist = *distances.get(&v).unwrap_or(&OrderedF64::from(f64::INFINITY));
  107|     71|                    result.set_distance(v, dist);
   37|     17|            let dist = *distances.nth(u);
   37|     17|            let dist = *distances.nth(u);
   38|     17|            if dist != UNREACHABLE {
   38|     17|            if dist != UNREACHABLE {
   89|    111|                let dist = entry.dist;
   89|    117|                let dist = entry.dist;
   97|     71|                    let dist = *distances.get(&v).unwrap_or(&i64::MAX);
   98|     71|                    result.set_distance(v, dist);
   98|     97|                visited.insert(v, dist);
   98|     99|                visited.insert(v, dist);
   99|     97|                result.set_distance(v, dist);
   99|     99|                result.set_distance(v, dist);
   40|       |        /// Distance from source to each vertex (i64::MAX for unreachable).
   40|       |        /// Distance matrix: distances.nth(u).nth(v) is the distance from u to v.
   41|       |        /// Distance from source to each vertex (i64::MAX for unreachable).
   41|       |        /// Distance matrix: distances.nth(u).nth(v) is the distance from u to v.
   42|       |        /// Distance matrix: distances.nth(u).nth(v) is the distance from u to v.
   43|       |        /// Distance from source to each vertex (OrderedFloat(f64::INFINITY) for unreachable).
   43|       |        /// Distance from source to each vertex (OrderedFloat(f64::INFINITY) for unreachable).
   43|       |        /// Distance matrix: distances.nth(u).nth(v) is the distance from u to v.
  102|     19|                reconstruct_predecessors(graph, &distances, &mut result, source);
  111|     19|                reconstruct_predecessors(graph, &distances, &mut result, source);
  137|      0|        let distances = ArraySeqStEphS::tabulate(&|_| ArraySeqStEphS::tabulate(&|_| OrderedFloat(f64::INFINITY), n), n);
  155|      0|        let distances = ArraySeqStEphS::tabulate(&|_| ArraySeqStEphS::tabulate(&|_| i64::MAX, n), n);
  208|      0|        let distances = ArraySeqStEphS::tabulate(&|_| ArraySeqStEphS::tabulate(&|_| i64::MAX, n), n);
  211|      0|        let distances = ArraySeqStEphS::tabulate(
   41|       |        pub distances: ArraySeqStPerS<ArraySeqStPerS<i64>>,
   41|       |        pub distances: ArraySeqStPerS<i64>,
   42|       |        pub distances: ArraySeqStEphS<ArraySeqStEphS<i64>>,
   42|       |        pub distances: ArraySeqStEphS<i64>,
   43|       |        pub distances: ArraySeqStPerS<ArraySeqStPerS<OrderedF64>>,
   44|       |        pub distances: ArraySeqStEphS<ArraySeqStEphS<OrderedF64>>,
   44|       |        pub distances: ArraySeqStEphS<OrderedF64>,
   44|       |        pub distances: ArraySeqStPerS<OrderedF64>,
   52|     18|            let distances = ArraySeqStPerS::tabulate(&|i| if i == source { 0 } else { UNREACHABLE }, n);
   52|      5|            let distances = ArraySeqStPerS::tabulate(
   54|      5|            let distances = ArraySeqStPerS::tabulate(
   55|     18|            let distances = ArraySeqStPerS::tabulate(&|i| if i == source { OrderedFloat(0.0) } else { UNREACHABLE }, n);
   55|     61|            let distances = ArraySeqStEphS::from_vec(dist_vec);
   57|     71|            let distances = ArraySeqStEphS::from_vec(dist_vec);
   59|      5|            let distances = ArraySeqStEphS::from_vec(dist_matrix);
   61|      5|            let distances = ArraySeqStEphS::from_vec(dist_matrix);
   31|       |        fn distance(&self, u: N, v: N) -> Option<i32>;
   31|       |        fn distance(&self, v: N) -> Option<i32>;
   32|       |        fn distance(&self, u: N, v: N) -> Option<i32>;
   32|       |        fn distance(&self, v: N) -> Option<i32>;
   33|       |        fn distance(&self, u: N, v: N) -> Option<OrderedF64>;
   34|       |        fn distance(&self, u: N, v: N) -> Option<OrderedF64>;
   34|       |        fn distance(&self, v: N) -> Option<OrderedF64>;
   34|       |        fn distance(&self, v: N) -> Option<OrderedF64>;
   47|     18|                        if distances.nth_cloned(v) == UNREACHABLE {
   42|     18|                    if *distances.nth(v) == UNREACHABLE {
   42|     18|                    if *distances.nth(v) == UNREACHABLE {
   47|     18|                        if *distances.nth(v) == UNREACHABLE {
  128|     15|            let dist_seq = ArraySeqStEphS::singleton(adjusted_row);
  128|     28|            let dist_seq = ArraySeqStEphS::singleton(adjusted_row);
  130|     15|            return (dist_seq, pred_seq);
  130|     28|            return (dist_seq, pred_seq);
  115|      2|            let dist_u = distances.nth(u).clone();
  116|      2|            let dist_u = *distances.nth(u);
  119|      2|            if dist_u != i64::MAX && dist_v != dist_u.saturating_add(edge_weight) {
  120|      2|            if dist_u != i64::MAX && dist_v != dist_u.saturating_add(edge_weight) {
  144|      2|            let dist_u = distances.nth(u).clone();
  145|      2|            let dist_u = *distances.nth(u);
  148|      2|            if dist_u.is_finite() && ((dist_v - (dist_u + edge_weight)).abs() > epsilon) {
  149|      2|            if dist_u.is_finite() && ((dist_v - (dist_u + edge_weight)).abs() > epsilon) {
  116|      2|            let dist_v = distances.nth(v).clone();
  117|      2|            let dist_v = *distances.nth(v);
  145|      2|            let dist_v = distances.nth(v).clone();
  146|      2|            let dist_v = *distances.nth(v);
    5|       |pub mod DivConReduceMt {
   42|       |    impl DivConReduceMtTrait for ArraySeqMtPerS<N> {
    4|       |pub mod DivConReduceSt {
   41|       |    impl DivConReduceStTrait for ArraySeqStPerS<N> {
  295|     16|                let diversity_bonus = (1.0 - m.probe_sequence_diversity) * 15.0;
  167|       |            // Divide: split at midpoint
  192|       |        // Divide and conquer
  294|       |        // Divide and conquer
   41|       |        // Divide: split at midpoint
   41|       |        // Divide: split at midpoint
   81|       |            // Divide: split at midpoint
   82|       |            // Divide: split at midpoint
   86|       |            // Divide: split at midpoint
   90|       |        // Divide and conquer
  134|      1|        fn div(self, other: Self) -> Self { Probability(self.0 / other.0) }
  210|      5|            let doc = tweets.nth(i);
   68|    258|                let doc = docs.nth(i);
  104|    533|                let _doc_id = &entry.1; // Single document ID
  119|  1.46k|                    let doc_id = doc_ids.nth(k);
  131|     22|            let doc_id = seq.nth(i);
  161|      2|            let doc_id = complex_results.nth(i);
  166|     49|                let doc_id = avl_seq.nth(i);
   69|    258|                let doc_id = &doc.0;
   88|  1.46k|                let doc_id = &pair.1;
  293|      3|            DocumentIndex::query_and(&docs_a, &docs_b)
  297|      2|            DocumentIndex::query_or(&docs_a, &docs_b)
  301|      2|            DocumentIndex::query_and_not(&docs_a, &docs_b)
  125|    533|                let doc_set = AVLTreeSetStPer::from_seq(avl_seq);
   19|       |    /// Document collection type - sequence of (id, contents) pairs
   22|       |    /// Document Index structure implementing Data Type 44.1
  257|       |    macro_rules! DocumentCollectionLit {
  274|      0|    fn _document_collection_lit_type_checks() {
  204|      1|        let document_count = tweets.length();
  175|       |    impl DocumentIndex {
   37|       |        index: DocumentIndex,
    4|       |pub mod DocumentIndex {
   59|       |    impl DocumentIndexTrait for DocumentIndex {
  102|      1|            let domain = self.adj.domain();
  110|      1|            let domain = new_adj.domain();
   50|      8|            let domain = self.adj.domain();
   56|      6|            let domain = self.adj.domain();
   58|      1|        println!("\n--- Domain Operations ---");
   58|      7|            let domain = self.adj.domain();
   72|      1|            let domain = self.adj.domain();
   60|      1|        let domain_eph = table_eph.domain();
   61|      1|        let domain_mt = table_mt.domain();
   59|      1|        let domain_per = table_per_new.domain();
  119|     25|        fn domain(&self) -> ArraySetStEph<K> { self.base_table.domain() }
  124|     11|        fn domain(&self) -> ArraySetStEph<K> { self.base_table.domain() }
  128|      3|        fn domain(&self) -> ArraySetStEph<K> { self.base_table.domain() }
  138|      1|        fn domain(&self) -> ArraySetStEph<K> { self.base_table.domain() }
  140|      1|        fn domain(&self) -> ArraySetStEph<K> { self.base_table.domain() }
  144|      1|        fn domain(&self) -> ArraySetStEph<K> { self.base_table.domain() }
  211|      2|        fn domain(&self) -> Vec<N> { (0..self.data.len()).collect() }
   28|       |        fn domain(&self) -> ArraySetStEph<K>;
   31|       |        fn domain(&self) -> ArraySetStEph<K>;
   34|       |        fn domain(&self) -> ArraySetStEph<K>;
   34|       |        fn domain(&self) -> Set<X>
   35|       |        fn domain(&self) -> ArraySetStEph<K>;
   35|       |        fn domain(&self) -> ArraySetStEph<K>;
   39|       |        fn domain(&self) -> ArraySetStEph<K>;
   39|       |        fn domain(&self) -> Set<X>;
   40|       |        fn domain(&self) -> ArraySetStEph<K>;
   42|       |        fn domain(&self) -> ArraySetStEph<K>;
   42|       |        fn domain(&self) -> ArraySetStEph<K>;
   42|       |        fn domain(&self) -> ArraySetStEph<K>;
   70|      9|        fn domain(&self) -> ArraySetStEph<K> { self.inner.domain() }
   74|       |        fn domain(&self) -> Vec<N>;
   76|     13|        fn domain(&self) -> ArraySetStEph<K> {
   79|     10|        fn domain(&self) -> Set<X>
   79|      5|        fn domain(&self) -> ArraySetStEph<K> {
   96|     28|        fn domain(&self) -> ArraySetStEph<K> {
   98|      6|        fn domain(&self) -> Set<X> { self.rel.domain() }
   51|      8|            let domain_seq = domain.to_seq();
   71|      5|            let domain_set = self.adj.domain();
  220|       |        // Don't forget the last word
   11|       |    /// Double Hashing Flat Hash Table implementation.
  120|       |            // Double hashing: (h1(key) + i·h2(key)) mod size
  160|     27|                strategy_name: "Double Hashing".to_string(),
   21|       |    /// Double Hashing Quality Metrics
  267|       |        /// Double hashing: h_i(k) = (h1(k) + i * h2(k)) mod m
  294|      0|            writeln!(f, "Double Hashing Quality Metrics:")?;
    3|       |//! Uses double hashing for open addressing collision resolution.
  238|     14|            let double_analysis = self.analyze_double_hashing(&double_strategy, &test_key, table_size, load_factor);
  259|     14|                double_hashing: double_analysis,
  247|     14|                ("DoubleHashing".to_string(), double_analysis.overall_clustering_score),
    5|       |pub mod DoubleHashFlatHashTable {
  114|       |        for DoubleHashFlatHashTableStEph
   16|       |    impl DoubleHashFlatHashTableStEph {
   58|       |        for DoubleHashFlatHashTableStEph
    4|       |pub mod DoubleHashing {
   54|       |        pub double_hashing: ComprehensiveClusteringAnalysis,
  136|      0|                return DoubleHashingMetrics {
  184|     16|            let double_hashing_quality = if self.detailed_metrics {
   23|       |        pub double_hashing_quality: Option<DoubleHashingMetrics>,
  236|     14|            let double_strategy: AdvancedDoubleHashingStrategy<String, DefaultHashFunction, DefaultHashFunction> =
   71|     51|                    if d_prime.0.is_infinite() {
  117|     51|                    let d_prime = dijkstra_result.get_distance(v);
  117|     86|                    let d_prime = dijkstra_result.get_distance(v);
  118|     51|                    if d_prime == i64::MAX {
  118|     86|                    if d_prime == OrderedF64::from(f64::INFINITY) {
   70|     51|                    let d_prime = dijkstra_result.get_distance(v);
   79|     51|                    let d_prime = dijkstra_result.get_distance(v);
   80|     51|                    if d_prime == i64::MAX {
  114|      4|        fn drop(&mut self) {
  106|      5|        let dummy_idx = n;
   99|      5|        let dummy_idx = n;
  119|       |                    panic!("MappingLit!: duplicate domain element {:?}", key);
  123|       |        // Duplicates Example
  125|      0|        let duplicates = example_45_2_duplicates();
    8|       |//! - Duplicates are supported naturally; a `dup_key` monotonically increases to distinguish insertion order if needed.
  186|       |        fn duplicates_example() -> HeapsortComparison<i32>;
    2|       |//! Bottom-Up Dynamic Programming - Ephemeral Multi-Threaded Implementation
    2|       |//! Bottom-Up Dynamic Programming - Ephemeral Single-Threaded Implementation
    2|       |//! Bottom-Up Dynamic Programming - Persistent Multi-Threaded Implementation
    2|       |//! Bottom-Up Dynamic Programming - Persistent Single-Threaded Implementation
    2|       |//! Top-Down Dynamic Programming - Ephemeral Multi-Threaded Implementation
    2|       |//! Top-Down Dynamic Programming - Ephemeral Single-Threaded Implementation
    2|       |//! Top-Down Dynamic Programming - Persistent Multi-Threaded Implementation
    2|       |//! Top-Down Dynamic Programming - Persistent Single-Threaded Implementation.
  118|       |            &|_v, _e, _centers, _part, result| result,
  152|       |            let __E: $crate::Chap05::SetStEph::SetStEph::Set<$crate::Types::Types::Edge<_>> = $crate::SetLit![];
  157|       |            let __E: $crate::Chap05::SetStEph::SetStEph::Set<_> = {
  169|      6|            let e = start.saturating_add(length).min(n);
  170|      6|            if e <= s {
  171|       |            &|_v, _e, _centers, _part, result| result,
  184|     18|            let e = start.saturating_add(length).min(n);
  186|      2|            let e = (start + length).min(n);
  187|     24|            let e = start.saturating_add(length).min(n);
  188|     24|            if e <= s {
  191|      2|            let e = start.saturating_add(length).min(n);
  192|      2|            if e <= s {
   21|       |        key_equality: E,
  233|     12|            let e = start.saturating_add(length).min(n);
  234|     12|            if e <= s {
  237|       |            let __E: $crate::Chap05::SetStEph::SetStEph::Set<$crate::Types::Types::Edge<_>> = $crate::SetLit![];
  242|       |            let __E: $crate::Chap05::SetStEph::SetStEph::Set<_> = {
   69|     27|        edges_vec.sort_by(|e1, e2| {
   50|    885|            let e = start.saturating_add(length).min(n);
   74|  8.14k|            let e = start.saturating_add(length).min(n);
   89|     15|            for e in self.data.iter() {
  100|       |    /// Each vertex flips a coin (Heads/Tails). Edges from Tail→Head are contracted.
  202|      1|3. For each key-value pair, rehash and insert into new table
  208|      1|  - Each rehash and insert is O(1) expected
   35|       |    /// Each edge in the matching forms a block of two vertices.
   39|       |    /// Each edge in the matching forms a block of two vertices.
   54|      1|        println!("  Each cycle around 1→2→1 subtracts 2, approaching -∞");
  148|      2|                .map(|edge| (edge.0.clone(), edge.1.clone(), edge.2))
  150|      1|                .map(|edge| (edge.0.clone(), edge.1.clone(), edge.2))
  156|      2|                .map(|edge| (edge.0.clone(), edge.1.clone(), edge.2))
  158|      1|                .map(|edge| (edge.0.clone(), edge.1.clone(), edge.2))
  100|     14|            for edge in tree_edges.iter() {
  109|     14|            for edge in tree_edges.iter() {
  112|     17|                    let edge = if parent_v < u {
  117|     14|        for edge in tree_edges.iter() {
  174|      2|                self.add_labeled_arc(edge.0, edge.1, edge.2 * factor);
  119|     23|            let edge = edges.nth(start as N);
  120|     67|            let edge = edges.nth(start as N);
  122|      9|        for edge in selected.iter() {
  126|     41|        for edge in graph.edges().iter() {
  130|       |        // Edge Cases
  138|     92|        for edge in graph.labeled_edges().iter() {
  147|     38|            let edge = edges.nth(start as N);
  149|     61|            let edge = edges.nth(start as N);
  151|     45|        for edge in pair.1.iter() {
  152|     31|        for edge in pair.1.iter() {
  155|    107|        for edge in graph.labeled_edges().iter() {
  169|     18|        for edge in graph.labeled_edges().iter() {
  170|     19|        for edge in mst_edges.iter() {
  173|      3|            for edge in current_edges {
  179|       |    /// Edge is selected if its coin is heads and all adjacent edges have tails
  180|     38|        for edge in pair.1.iter() {
  186|      6|        for edge in graph.labeled_edges().iter() {
  189|     18|        for edge in graph.labeled_edges().iter() {
  205|       |    /// Edge wrapper to enable Display/Debug for pairs (V,V) under baseline bounds.
  206|     12|        for edge in graph.labeled_edges().iter() {
  108|      2|                .map(|edge| edge.2)
  119|      1|                .map(|edge| edge.2)
  129|      1|                .map(|edge| edge.2)
  147|      2|                .min_by_key(|edge| edge.2)
  149|      1|                .min_by_key(|edge| edge.2)
  155|      2|                .max_by_key(|edge| edge.2)
  157|      1|                .max_by_key(|edge| edge.2)
  179|      1|                .map(|edge| edge.2)
   27|    287|            for edge in labeled_edges {
   27|     82|            for edge in labeled_edges {
   31|     20|            for edge in labeled_edges {
   31|     20|            for edge in labeled_edges {
   31|     39|            for edge in labeled_edges {
   31|     48|            for edge in labeled_edges {
   44|       |    /// Edge with label: (u, v, weight, label)
   45|     29|        for edge in graph.edges().iter() {
   53|       |    /// Edge with label: (u, v, weight, label)
   55|    236|            for edge in labeled_edges {
   55|      6|        for edge in matching.iter() {
   55|     82|            for edge in labeled_edges {
   59|      0|                    let edge = if vertex < center {
    5|       |//! Labeled edge filtering (neighbors) is parallel.
    5|       |//! Weighted edge filtering (neighbors_weighted) is parallel.
    5|       |//! Weighted edge filtering (neighbors_weighted) is parallel.
   65|     14|                    let edge = if vertex < center {
   66|    162|        for edge in graph.edges().iter() {
   66|     78|        for edge in edges.iter() {
   68|      0|            for edge in quotient_edges.iter() {
   68|      6|            for edge in matching.iter() {
   76|     24|        for edge in edges_vec.iter() {
   80|     18|        for edge in graph.edges().iter() {
   85|     12|        for edge in graph.edges().iter() {
   86|     47|        for edge in graph.edges().iter() {
   87|      0|        for edge in tree_edges.iter() {
   90|     12|        for edge in graph.edges().iter() {
   90|      1|                    let edge = seq.nth(i);
   98|     14|        for edge in mst_edges.iter() {
   98|      2|            for edge in edges_to_remove {
  106|    114|                    let Edge(a, b) = &edges[0];
   79|    371|            for Edge(a, b) in self.E.iter().cloned() {
   89|    588|                for Edge(a, b) in edges {
   77|      4|                let Edge(c1, c2) = quotient_edge;
  109|      4|        let edge_coin_map: std::collections::HashMap<Edge<V>, bool> =
  108|     12|                    if edge_coins.get(adj_edge).copied().unwrap_or(false) {
  200|     32|                if edge_coins.get(adj_edge).copied().unwrap_or(false) {
  188|     38|        if !edge_coins.get(edge).copied().unwrap_or(false) {
   94|     12|            if !edge_coins.get(edge).copied().unwrap_or(false) {
    7|       |pub mod EdgeContractionMtEph {
    8|       |pub mod EdgeContractionStEph {
   23|       |        fn edge_contract_mt<V: StT + MtT + Hash + Ord + 'static>(
   22|       |        fn edge_contract<V: StT + Hash + Ord>(
  108|      8|            if edge_found {
  117|      8|            if edge_found {
   89|      8|            let edge_key = if current < neighbor {
   97|      8|            let edge_key = if current < neighbor {
  334|       |    macro_rules! EdgeList {
  320|       |    macro_rules! EdgeLit {
  149|      0|                    if edges[0].0 == v {
   86|      0|                    if edges[0].0 == v {
   93|      0|                    if edges[0].0 == v {
   88|      0|                        s.insert((edges[0].1.clone_mt(), edges[0].2));
   92|      0|                        s.insert((edges[0].0.clone_mt(), edges[0].2));
   95|      0|                        s.insert((edges[0].1.clone_mt(), edges[0].2));
   99|      0|                        s.insert((edges[0].0.clone_mt(), edges[0].2));
  112|      5|            WeightedDirGraphStEphFloat::from_weighted_edges(vertices, edges),
  140|     45|        let edges1 = edges.clone();
  141|     20|        let edges1 = edges.clone();
  114|       |            let edges = $crate::SetLit![ $( ($v1, $v2, $weight) ),* ];
  115|       |            $crate::Chap06::WeightedUnDirGraphStEphInt::WeightedUnDirGraphStEphInt::WeightedUnDirGraphStEphInt::from_weighted_edges(vertices, edges)
  159|     34|        let edges1 = edges.clone();
  169|     38|        let edges1 = edges.clone();
  116|       |            let edges = $crate::SetLit![ $( ($from, $to, $weight) ),* ];
  117|       |            $crate::Chap06::WeightedDirGraphStEphInt::WeightedDirGraphStEphInt::WeightedDirGraphStEphInt::from_weighted_edges(vertices, edges)
  124|    263|            let edges: Vec<LabEdge<V, L>> = self.labeled_edges.iter().cloned().collect();
  126|      5|            WeightedDirGraphStEphInt::from_weighted_edges(vertices, edges),
  296|     51|        let edges1 = edges.clone();
  132|       |            let edges = $crate::SetLit![ $( ($v1, $v2, $weight) ),* ];
  133|       |            $crate::Chap06::WeightedUnDirGraphMtEphInt::WeightedUnDirGraphMtEphInt::WeightedUnDirGraphMtEphInt::from_weighted_edges(vertices, edges)
  133|      5|        WeightedDirGraphStEphFloat::from_weighted_edges(vertices, edges)
  144|       |            let edges = $crate::SetLit![ $( ($v1, $v2, OrderedFloat($weight as f64)) ),* ];
  145|       |            $crate::Chap06::WeightedUnDirGraphMtEphFloat::WeightedUnDirGraphMtEphFloat::WeightedUnDirGraphMtEphFloat::from_weighted_edges(vertices, edges)
  150|      5|        WeightedDirGraphStEphInt::from_weighted_edges(vertices, edges)
  167|       |            let edges = $crate::SetLit![ $( ($v1, $v2, OrderedFloat($weight as f64)) ),* ];
  168|       |            $crate::Chap06::WeightedUnDirGraphStEphFloat::WeightedUnDirGraphStEphFloat::WeightedUnDirGraphStEphFloat::from_weighted_edges(vertices, edges)
  176|       |            let edges = $crate::SetLit![ $( ($from, $to, $weight) ),* ];
  177|       |            $crate::Chap06::WeightedDirGraphMtEphInt::WeightedDirGraphMtEphInt::WeightedDirGraphMtEphInt::from_weighted_edges(vertices, edges)
  178|      5|        (WeightedDirGraphStEphInt::from_weighted_edges(vertices, edges), n)
  181|     10|        (WeightedDirGraphStEphFloat::from_weighted_edges(vertices, edges), n)
   92|     51|        let edges1 = edges.clone();
  142|     45|        let edges2 = edges.clone();
  143|     20|        let edges2 = edges;
  162|     34|        let edges2 = edges;
  171|     38|        let edges2 = edges.clone();
  298|     51|        let edges2 = edges;
  229|      8|        boruvka_mst(vertices, edges, SetLit![], &mut rng)
   93|     51|        let edges2 = edges;
   64|      1|            let edges: Vec<LabEdge<V, i32>> = self.labeled_edges().iter().cloned().collect();
   68|      1|            let edges: Vec<LabEdge<V, OrderedF64>> = self.labeled_edges().iter().cloned().collect();
   84|    134|            let edges: Vec<Edge<V>> = self.E.iter().cloned().collect();
  114|      4|        let edges_arc = Arc::new(edges.clone());
  241|     20|        let edges_arc = Arc::new(edges_vec);
   94|      3|        let edges_arc = Arc::new(edges_seq);
   31|     23|            Self::from_vertices_and_labeled_edges(vertices, edge_set)
   31|     65|            Self::from_vertices_and_labeled_arcs(vertices, edge_set)
   35|     13|            Self::from_vertices_and_labeled_arcs(vertices, edge_set)
   35|     16|            Self::from_vertices_and_labeled_arcs(vertices, edge_set)
   35|      7|            Self::from_vertices_and_labeled_edges(vertices, edge_set)
   35|      7|            Self::from_vertices_and_labeled_edges(vertices, edge_set)
   59|     23|            Self::from_vertices_and_labeled_edges(vertices, edge_set)
   59|     56|            Self::from_vertices_and_labeled_arcs(vertices, edge_set)
    7|       |pub mod EdgeSetGraphMtPer {
    4|       |pub mod EdgeSetGraphStEph {
    5|       |pub mod EdgeSetGraphStPer {
  240|     20|        let edges_len = edges_vec.len();
   28|       |        fn edges(&self) -> &AVLTreeSetStEph<Pair<V, V>>;
   29|       |        fn edges(&self) -> &AVLTreeSetStPer<Pair<V, V>>;
   31|       |        fn edges(&self) -> &AVLTreeSetMtPer<Pair<V, V>>;
   31|       |        fn edges(&self) -> &Set<Edge<V>>;
   34|       |        fn edges(&self) -> &Set<Edge<V>>;
   34|       |        fn edges(&self) -> Set<Edge<V>>;
   38|       |        fn edges(&self) -> Set<Edge<V>>;
   63|      0|        fn edges(&self) -> &AVLTreeSetStEph<Pair<V, V>> { &self.edges }
   64|      0|        fn edges(&self) -> &AVLTreeSetStPer<Pair<V, V>> { &self.edges }
   64|     65|        fn edges(&self) -> &Set<Edge<V>> { &self.E }
   66|      0|        fn edges(&self) -> &AVLTreeSetMtPer<Pair<V, V>> { &self.edges }
   67|    152|        fn edges(&self) -> &Set<Edge<V>> { &self.E }
   74|     23|        fn edges(&self) -> Set<Edge<V>> {
   80|      1|        fn edges(&self) -> Set<Edge<V>> {
  124|     23|        let edges_seq = ArraySeqStEphS::from_vec(edges_vec);
   53|      4|        let edges_seq: ArraySeqStEphS<Edge<V>> = ArraySeqStEphS::from_vec(edges_vec);
   91|     22|        let edges_seq = ArraySeqStEphS::from_vec(edges_vec);
   92|      3|        let edges_seq = ArraySeqStEphS::from_vec(edges_vec);
  170|     33|        if edges.size() == 0 {
   86|      1|            let edges_to_remove: Vec<Pair<V, V>> = {
  123|     23|        let edges_vec: std::vec::Vec<Edge<V>> = graph.edges().iter().cloned().collect();
  331|      9|        let edges_vec: Vec<LabeledEdge<V>> = edges.iter().cloned().collect();
  332|      9|        boruvka_mst_mt(vertices_vec, edges_vec, SetLit![], &mut rng)
   52|      4|        let edges_vec: std::vec::Vec<Edge<V>> = graph.edges().iter().cloned().collect();
   90|     22|        let edges_vec: std::vec::Vec<Edge<V>> = graph.edges().iter().cloned().collect();
   91|      3|        let edges_vec: std::vec::Vec<Edge<V>> = graph.edges().iter().cloned().collect();
  235|     29|        if edges_vec.is_empty() {
  118|     14|            let Edge(u, v) = edge;
  120|     23|            let Edge(u, v) = edge;
  121|     67|            let Edge(u, v) = edge;
  127|     41|            let Edge(u, v) = edge;
  150|     61|            let Edge(u, v) = edge;
  185|     38|        let Edge(u, v) = edge;
   46|     29|            let Edge(u, v) = edge;
   56|      6|            let Edge(u, v) = edge;
   67|    162|            let Edge(u, v) = edge;
   69|      6|                let Edge(u, v) = edge;
   81|     12|                    let Edge(u, v) = original_edge;
   81|     18|            let Edge(u, v) = edge;
   87|     47|            let Edge(u, v) = edge;
   89|      0|            let Edge(u, v) = edge;
   91|     12|            let Edge(u, v) = edge;
  182|     38|        edge: &Edge<V>,
  117|      2|            let edge_weight = weights.nth(u).nth(v).clone();
  118|      2|            let edge_weight = *weights.nth(u).nth(v);
  146|      2|            let edge_weight = weights.nth(u).nth(v).clone();
  147|      2|            let edge_weight = *weights.nth(u).nth(v);
   67|      4|            let edge_weight = weights.nth(u).nth(v).clone();
   68|     18|            let edge_weight = *weights.nth(u).nth(v);
   90|      2|            let edge_weight = weights.nth(u).nth(v).clone();
   91|      5|            let edge_weight = *weights.nth(u).nth(v);
  108|  8.12k|            for Edge(x, y) in self.A.iter().cloned() {
  118|  9.13k|            for Edge(x, y) in self.A.iter().cloned() {
  152|  91.6k|                for Edge(x, y) in arcs {
  167|      0|                    let Edge(x, y) = &arcs[0];
  202|   107k|                for Edge(x, y) in arcs {
  217|      0|                    let Edge(x, y) = &arcs[0];
  137|       |        // Efficiency Analysis
  139|      0|        let efficiency = example_45_2_efficiency_demonstration();
  194|       |        fn efficiency_demonstration() -> Vec<(String, Vec<i32>)>;
  317|       |        /// Efficient range reduction for TRAMLAW/QADSAN scenarios
  330|       |        /// Efficient range reduction for TRAMLAW/QADSAN scenarios
  352|       |        /// Efficient range reduction for TRAMLAW/QADSAN scenarios
   73|       |        /// Efficient range reduction: getRange followed by reduceVal
   76|       |        /// Efficient range reduction: getRange followed by reduceVal
   81|       |        /// Efficient range reduction for TRAMLAW/QADSAN scenarios
  411|       |        fn efficient_multi_way_merge<T: StT + Ord>(sequences: Vec<Vec<T>>) -> Vec<T>;
  104|    128|                let elem = other.elements.nth(i);
  105|     38|                let elem = self.elements.nth(i);
  106|  5.17k|                let elem = self.elements.nth(i);
  107|      7|                let elem = self.elements.nth(i);
  113|     28|            for elem in &other.elements {
  116|     77|                let elem = self.elements.nth(i);
  117|    117|                    let elem = self.elements.nth(i);
  118|     89|                let elem = self.elements.nth(i);
  126|  6.51k|                let elem = self.elements.nth(i);
  128|  35.4k|                let elem = self.elements.nth(i);
  130|   543k|                let elem = self.elements.nth(i);
  133|  1.85k|                let elem = other.elements.nth(i);
  135|  10.8k|                let elem = other.elements.nth(i);
  151|     41|                let elem = self.elements.nth(i);
  152|     41|                if elem != x {
  154|     80|                let elem = self.elements.nth(i);
  155|     80|                if elem != x {
  158|      8|                    let elem = self.elements.nth(i);
  161|      2|                let elem = self.elements.nth(i);
  169|      5|                let elem = other.elements.nth(j);
  177|     53|                let elem = seq.nth(i);
  178|     53|                if elem < k {
  182|     25|                let elem = seq.nth(i);
  183|     25|                if elem < k {
  191|     96|                let elem = seq.nth(i);
  192|     96|                if elem > k {
  196|     26|                let elem = seq.nth(i);
  197|     26|                if elem > k {
  232|  1.29k|                let elem = self.elements.nth(i);
  233|      0|                let elem = self.elements.nth(i);
  239|    941|                let elem = self.elements.nth(mid);
  243|     86|                let elem = seq.nth(i);
  244|     86|                if elem < k {
  251|     16|                let elem = seq.nth(i);
  252|     16|                if elem < k {
  321|      3|                    let elem = self.elements.nth(i);
   34|    332|                let elem = self.nth(i);
   34|    353|                let elem = self.nth(i);
   34|    375|                let elem = self.nth(i);
   35|    332|                if elem < &pivot {
   35|    353|                if elem < &pivot {
   35|    375|                if elem < &pivot {
   36|    330|                let elem = self.nth_cloned(i);
   37|    330|                if elem < pivot {
   47|    254|                            let elem = self.nth(j);
   47|    293|                            let elem = self.nth(j);
   47|    312|                            let elem = self.nth(j);
   48|    254|                            if elem < &pivot {
   48|    293|                            if elem < &pivot {
   48|    312|                            if elem < &pivot {
   49|    173|                            let elem = self.nth_cloned(j);
   50|    173|                            if elem < pivot {
   52|     58|                                    return elem;
   67|    177|                            let elem = self.nth(j);
   67|    186|                            let elem = self.nth(j);
   67|    308|                            let elem = self.nth(j);
   68|    177|                            if elem > &pivot {
   68|    186|                            if elem > &pivot {
   68|    308|                            if elem > &pivot {
   69|    249|                            let elem = self.nth_cloned(j);
   70|    103|                let elem = seq.nth(i).clone();
   70|    249|                            if elem > pivot {
   72|     73|                                    return elem;
   79|  1.66k|                let elem = seq.nth(i).clone();
   81|  10.6k|                let elem = seq.nth(i).clone();
   87|     11|                let elem = seq.nth_cloned(i);
   88|     11|                if elem < u {
   94|     24|                let elem = self.elements.nth(i);
   95|    796|                let elem = self.elements.nth(i);
   96|     25|                let elem = self.elements.nth(i);
   50|     77|                                    return elem.clone();
   50|     90|                                    return elem.clone();
   50|     98|                                    return elem.clone();
   70|     51|                                    return elem.clone();
   70|     52|                                    return elem.clone();
   70|     86|                                    return elem.clone();
  240|    941|                match elem.cmp(x) {
  100|    123|        for element in sequence {
  116|  5.50k|                    let element = self.elements.nth(i);
  118|     99|        for element in sequence {
  132|       |                // Element doesn't exist, add it
  134|      0|        output.push_str(&format!("Single element - All match: {}\n", single.all_results_match()));
  140|  11.7k|                let element = if k == i {
  154|      5|                let element = elements.nth(i);
  161|       |                // Element already exists, return unchanged
  163|      6|                let element = seq.nth(i);
  164|       |                // Element doesn't exist, add it
  183|     10|                let element = seq.nth(i);
  204|      0|                let element = elements.nth(i);
  213|      4|                let element = elements.nth(i);
  214|      1|- Each element pays for future elements
  216|    313|                    key: element,
  221|     12|            for element in vec {
  250|       |                    // Element not found (would be here if it existed)
  278|      4|                let element = elements.nth(i);
  287|      0|            for element in vec {
  318|      6|            for element in vec {
  326|      4|        for element in vec {
  353|      8|            for element in all_elements {
  354|      7|                if element < *value {
  374|      6|            for element in vec {
   46|     99|        for element in sequence {
   61|       |                        // Element too large, skip it
   64|     99|        for element in sequence {
   65|       |                        // Element too large, skip it
   70|       |                        // Element too large, skip it
   75|       |                        // Element too large, skip it
   82|     99|        for element in sequence {
   84|    974|                if element <= *current {
   87|  3.20k|                if element <= *current {
   94|    376|            values.insert(insert_pos, element);
  341|      1|                "  elements: {}, size: {}, deleted: {}",
  396|       |            let elements = vec![$($x),*];
   59|    114|                    let element_value: i32 = (*self.multiset.nth(i - 1)).into();
   60|    114|                    if element_value > j {
   63|    119|                    let element_value: i32 = self.multiset.nth(i - 1).clone().into();
   64|    119|                    if element_value > j {
   68|     86|                    let element_value: i32 = (*self.multiset.nth(i - 1)).into();
   69|     86|                    if element_value > j {
   73|     59|                    let element_value: i32 = self.multiset.nth_cloned(i - 1).into();
   74|     59|                    if element_value > j {
  105|      6|                    let (elem_i, keep) = handle.join().unwrap();
  146|     56|                let elem_other = other.elements.nth(j);
  145|     56|                let elem_self = self.elements.nth(i);
  148|     56|                if elem_self <= elem_other {
  100|       |            } else {
  102|     60|                    } else if target < &node.key {
  103|     10|                } else if index == ls {
  103|    110|                } else {
  103|  1.32k|                } else {
  103|       |            } else {
  104|      1|                } else {
  104|     43|                } else if index == ls {
  104|    824|                    } else if target < &node.key {
  104|       |                    } else {
  105|    361|                } else if key > node.key {
  105|       |                } else {
  105|       |            } else {
  105|       |            } else {
  106|       |                    } else {
  106|       |                } else {
  106|       |            } else {
  106|       |            } else {
  107|       |            } else {
  108|       |            } else {
  109|     30|                } else {
  109|       |            } else {
  110|      0|                } else {
  110|  1.13k|                } else if value > node.key {
  110|     23|                } else {
  110|  4.99k|                } else if target < &inner.value {
  110|       |            } else {
  110|       |            } else {
  111|    109|                    } else if b == &v {
  111|  2.63k|                } else if value > node.key {
  111|     32|                } else if (xm <= x0 && x0 <= xl) || (xl <= x0 && x0 <= xm) {
  112|     11|                } else {
  112|  1.94k|                        } else if (xm <= x0 && x0 <= xl) || (xl <= x0 && x0 <= xm) {
  112|       |                } else {
  112|       |            } else {
  113|       |                } else {
  113|       |            } else {
  114|       |                        } else {
  114|       |                    } else {
  114|       |                    } else {
  114|       |                    } else {
  114|       |                    } else {
  114|       |                    } else {
  114|       |                    } else {
  114|       |                    } else {
  115|       |                } else {
  115|       |                } else {
  119|     14|                    } else if xi > pivot {
  120|  10.9k|                } else if bf < -1 {
  120|    791|                } else if bf < -1 {
  120|       |                    } else {
  120|       |                    } else {
  120|       |                } else {
  120|       |            } else {
  120|       |            } else {
  121|  2.65k|                    } else if value > node.key {
  121|     28|                } else {
  121|      6|                    } else {
  122|     25|                    } else {
  122|  5.02k|                } else if labeled_edge.1 == *v {
  122|       |                        } else {
  123|    326|            } else {
  123|  5.43k|                } else if value > node.key {
  123|       |                    } else {
  124|  1.02k|            } else {
  124|    141|            } else if rank_u > rank_v {
  124|    174|            } else {
  124|      8|                    } else {
  124|  9.14k|                    } else if data[i] > pivot {
  124|       |            } else {
  125|       |                } else {
  126|   387k|                        } else if data[i] > pivot {
  126|       |            } else {
  127|    119|            } else {
  127|  3.16k|                    } else {
  127|       |                } else {
  128|       |                    } else {
  129|   381k|                        } else {
  129|       |                } else {
  129|       |                } else {
  129|       |            } else {
  130|  2.48k|            } else {
  131|     28|                } else {
  131|       |                    } else {
  131|       |                    } else {
  131|       |                    } else {
  131|       |                    } else {
  131|       |                    } else {
  131|       |                    } else {
  132|      2|                } else {
  132|    665|                    } else if key < &node.key {
  132|    809|                    } else if labeled_edge.1 == *v {
  132|       |                    } else {
  133|       |            } else {
  133|       |            } else {
  134|    495|                    } else if target < &node.key {
  134|       |                    } else {
  134|       |                    } else {
  135|    295|                    } else if target < &node.key {
  135|       |                } else {
  135|       |            } else {
  136|  1.05k|            } else {
  136|       |                    } else {
  136|       |            } else {
  137|     10|                } else {
  137|      2|                } else {
  137|       |                    } else {
  137|       |            } else {
  139|    263|                    } else if target < &node.key {
  139|    697|                    } else if value > node.key {
  139|  9.15k|                    } else if value > node.key {
  139|       |            } else {
  140|      0|                } else {
  140|       |                    } else {
  140|       |                    } else {
  140|       |            } else {
  141|    693|                    } else {
  141|  9.00k|                    } else {
  141|       |                    } else {
  141|       |            } else {
  141|       |            } else {
  142|  11.3k|                } else if k == j {
  142|     66|            } else if b == v {
  144|       |                } else {
  145|      1|                } else {
  146|     11|                } else if value > pivot {
  146|     16|                } else if value > pivot {
  146|     17|                } else if value > pivot {
  146|     28|                } else if value > pivot {
  146|      9|                } else if value > pivot {
  146|      9|                } else if value > pivot {
  147|     25|                    } else if target < &node.key {
  147|       |            } else {
  148|     10|                } else {
  148|     12|                } else {
  148|     22|                } else {
  148|      5|                } else {
  148|      5|                } else {
  148|      7|                } else {
  148|       |            } else {
  149|       |                    } else {
  149|       |            } else {
  150|    158|                } else {
  150|      2|                } else {
  150|       |                    } else {
  150|       |                    } else {
  150|       |            } else {
  151|      6|                    } else {
  152|     29|                } else {
  153|      0|                    } else if edges[0].1 == v {
  153|       |                } else {
  154|       |            } else {
  155|       |                    } else {
  156|     16|                    } else if xi > pivot {
  158|       |                    } else {
  158|       |                } else {
  158|       |                } else {
  158|       |            } else {
  159|    152|                    } else if target < &node.key {
  159|  2.01M|                    } else if target < &node.key {
  159|       |            } else {
  160|    542|                } else if value > node.key {
  161|      8|                    } else {
  161|       |                    } else {
  161|       |                    } else {
  162|    541|                } else {
  162|       |                    } else {
  162|       |                } else {
  162|       |            } else {
  164|      5|                } else {
  164|       |                    } else {
  164|       |            } else {
  165|  4.65k|                    } else if data[i] > pivot {
  165|       |            } else {
  165|       |            } else {
  166|  1.17k|                        } else if data[i] > pivot {
  168|  3.49k|                    } else {
  168|       |            } else {
  169|    998|                        } else {
  170|       |            } else {
  170|       |            } else {
  172|       |                    } else {
  173|     12|            } else if b == v {
  173|     16|            } else if a.length() == 1 {
  175|       |                    } else {
  175|       |                } else {
  175|       |            } else {
  176|       |            } else {
  177|   112k|                } else if value > node.key {
  177|    762|                } else if key > node.key {
  178|    976|                    } else if target < &node.key {
  178|       |            } else {
  179|   112k|                } else {
  179|      1|                } else {
  179|       |            } else {
  180|       |                    } else {
  180|       |                    } else {
  181|     20|                    } else if target < &node.key {
  182|       |                    } else {
  182|       |            } else {
  183|       |                    } else {
  183|       |                    } else {
  184|    370|                } else {
  184|       |                } else {
  184|       |            } else {
  185|       |                    } else {
  185|       |            } else {
  186|      3|                } else {
  186|       |                    } else {
  186|       |            } else {
  188|     17|            } else if a.length() == 1 {
  190|       |            } else {
  191|    106|                    } else if key == &node.key {
  192|       |                    } else {
  193|     12|            } else if b == v {
  193|    199|            } else {
  193|       |                    } else {
  193|       |            } else {
  194|       |            } else {
  195|  1.47k|                    } else if target < &node.key {
  196|       |            } else {
  197|      1|                } else {
  197|       |                    } else {
  198|       |            } else {
  203|       |                    } else {
  205|      0|            } else if rank_u > rank_v {
  205|  1.63k|                    } else if key < &node.key {
  206|       |                    } else {
  207|      0|            } else {
  207|    101|                    } else if rank == left_size + 1 {
  207|       |                                } else {
  207|       |                    } else {
  207|       |            } else {
  209|       |                    } else {
  209|       |            } else {
  210|       |            } else {
  213|  6.99k|            } else if !current_word.is_empty() {
  215|      0|                } else {
  215|       |            } else {
  216|     30|                } else {
  217|       |            } else {
  219|       |        } else {
  220|       |            } else {
  221|       |                } else {
  222|       |                    } else {
  223|    215|            } else if a.length() == 1 {
  224|       |                    } else {
  224|       |            } else {
  224|       |            } else {
  225|       |                    } else {
  225|       |            } else {
  226|       |            } else {
  227|       |                    } else {
  228|       |                } else {
  229|       |                } else {
  234|       |            } else {
  236|       |                    } else {
  236|       |            } else {
  237|       |            } else {
  238|     14|            } else if a.length() == 1 {
  238|       |            } else {
  238|       |            } else {
  240|       |            } else {
  246|     67|                } else {
  249|       |            } else {
  252|      8|                } else if &pair.0 > k {
  254|     11|                } else {
  254|      7|                } else {
  254|       |                    } else {
  258|       |            } else {
  262|      1|            } else if other_size == 0 {
  262|       |            } else {
  264|      1|            } else {
  264|       |            } else {
  265|      4|                } else {
  265|      4|                } else if current > max_val {
  266|       |            } else {
  269|       |                    } else {
  272|  4.37k|                        } else if i == insert_pos {
  274|       |                        } else {
  274|       |            } else {
  275|      1|            } else if other_size == 0 {
  275|       |                } else {
  276|       |            } else {
  277|      1|            } else {
  277|       |            } else {
  278|       |                } else {
  278|       |            } else {
  279|       |            } else {
  281|     13|                    } else {
  282|       |            } else {
  284|      3|            } else if rank >= self.size() {
  284|       |            } else {
  286|       |                    } else {
  286|       |            } else {
  287|  97.2M|                } else {
  288|      2|                } else {
  290|      1|            } else if right.base_table.size() == 0 {
  292|       |            } else {
  294|      4|                } else {
  294|       |                } else {
  297|       |            } else {
  299|  5.06k|                        } else if i == insert_pos {
  299|     63|                } else {
   29|       |        } else {
  301|      2|                } else if value > pivot {
  301|      6|                } else {
  301|       |                        } else {
  303|      1|                } else {
  303|       |            } else {
  308|       |            } else {
  309|       |            } else {
   30|       |            } else {
  310|    116|                } else {
  311|       |            } else {
  311|       |            } else {
  313|       |            } else {
  314|     24|                } else if index == left_size {
  315|       |            } else {
  317|       |                } else {
  322|       |            } else {
  325|       |        } else {
  326|      4|            } else if clustering_score < 100.0 {
  328|      4|            } else if clustering_score < 150.0 {
  330|       |            } else {
  340|    116|                } else {
  342|       |            } else {
  348|    108|                } else {
  352|       |            } else {
  356|      4|                } else {
  357|       |            } else {
   35|       |            } else {
  360|       |            } else {
  366|      4|                } else {
   37|    196|                } else if elem > &pivot {
   37|    200|                } else if elem > &pivot {
   37|    240|                } else if elem > &pivot {
  376|      6|                } else if current == element {
  379|      5|                } else {
  383|     99|                } else {
  387|  3.77k|                } else {
   38|       |            } else {
   39|    222|                } else if elem > pivot {
   39|       |            } else {
  400|     20|                } else {
   40|      1|            } else if (xm <= x0 && x0 <= xl) || (xl <= x0 && x0 <= xm) {
  405|      4|                } else {
   42|      1|            } else if (xm <= x0 && x0 <= xl) || (xl <= x0 && x0 <= xm) {
  427|      5|                } else if index == left_size {
   42|       |            } else {
  430|       |                } else {
   43|      2|            } else if (xm <= x0 && x0 <= xl) || (xl <= x0 && x0 <= xm) {
   43|       |            } else {
   44|       |            } else {
   44|       |            } else {
   45|       |            } else {
   46|       |                    } else {
   47|       |                    } else {
   48|       |            } else {
  493|       |                            } else {
   49|       |            } else {
   50|    151|                            } else {
  506|       |                        } else {
  525|       |            } else {
  532|       |                        } else {
   53|     35|                        } else if l_idx < n_left {
   54|       |            } else {
   55|     23|                        } else {
   56|       |                        } else {
   57|     76|                } else {
   58|      0|                } else {
   60|     44|            } else if k < n - right_count {
   60|     47|            } else if k < n - right_count {
   60|     51|            } else if k < n - right_count {
   60|       |            } else {
   61|       |                    } else {
   62|     47|            } else if k < n - right_count {
   62|       |            } else {
   62|       |            } else {
   62|       |            } else {
   63|      6|                } else if labeled_edge.1 == *v {
   63|       |                    } else {
   63|       |                } else {
   63|       |            } else {
   64|       |                    } else {
   64|       |            } else {
   65|       |                        } else {
   67|       |                    } else {
   67|       |                    } else {
   68|     51|                    } else if l_idx < n_left {
   68|  7.96k|                } else if ch.is_ascii_uppercase() {
   68|       |            } else {
   69|     69|                } else {
   70|       |                    } else {
   70|       |            } else {
   71|     16|                    } else if xi > pivot {
   71|       |            } else {
   72|      2|                    } else if labeled_edge.1 == *v {
   72|       |                    } else {
   72|       |            } else {
   72|       |            } else {
   72|       |            } else {
   73|  43.0k|                    } else if data[i] > pivot {
   73|       |                    } else {
   73|       |                    } else {
   73|       |                    } else {
   73|       |                } else {
   74|       |                    } else {
   75|     12|                } else {
   75|  26.3k|                        } else if data[i] > pivot {
   75|       |            } else {
   76|     12|                    } else {
   76|  2.24k|                    } else {
   76|     24|                    } else {
   76|      2|                    } else if labeled_edge.1 == *v {
   76|       |                } else {
   77|       |                    } else {
   77|       |                    } else {
   77|       |            } else {
   78|    255|                        } else {
   79|    106|                } else {
   79|  6.03k|                    } else if value > node.key {
   79|  6.97k|                    } else if value > node.key {
   79|       |                    } else {
   79|       |                    } else {
   79|       |                    } else {
   80|  2.40k|            } else if index == ls {
   80|  6.41M|            } else if index == ls {
   80|       |            } else {
   81|  10.9k|                    } else if value > node.key {
   81|       |                    } else {
   81|       |                    } else {
   81|       |            } else {
   82|  1.11k|            } else {
   82|    253|                    } else if self.0 > other.0 {
   82|    294|                } else if b == *v {
   82|  4.01M|            } else {
   82|  5.01k|                } else if value > inner.value {
   82|       |                    } else {
   82|       |            } else {
   82|       |            } else {
   83|    244|                } else {
   83|       |                    } else {
   83|       |                } else {
   84|    730|                } else {
   84|       |                    } else {
   84|       |                } else {
   84|       |                } else {
   86|       |            // Else: skip edge (would form cycle)
   88|       |                    } else {
   89|    112|                } else {
   89|     16|                } else {
   89|       |                    } else {
   89|       |                } else {
   89|       |            } else {
   90|      0|                    } else if edges[0].1 == v {
   90|     18|                    } else {
   90|       |                        } else {
   90|       |            } else {
   90|       |            } else {
   91|      0|                } else {
   91|      4|                } else {
   91|       |            } else {
   91|       |            } else {
   92|  14.3k|                    } else {
   92|    346|                    } else if b == *v {
   93|       |                } else {
   93|       |            } else {
   93|       |            } else {
   94|       |                } else {
   94|       |                } else {
   94|       |            } else {
   95|    107|                } else {
   95|      1|                } else if (xm <= x0 && x0 <= xl) || (xl <= x0 && x0 <= xm) {
   95|  5.00k|                } else if target < &inner.value {
   95|      6|                } else if labeled_edge.1 == *v {
   95|       |                    } else {
   95|       |                } else {
   95|       |            } else {
   96|  1.02k|                } else {
   97|      0|                    } else if edges[0].1 == v {
   97|     21|                } else {
   97|       |                } else {
   97|       |                } else {
   98|     76|                } else {
   98|       |                } else {
   98|       |            } else {
   99|       |            } else {
  263|      0|            let elts = (0..self.length()).map(|i| self.nth(i));
  175|     26|                data: elts.into_boxed_slice(),
   21|   238k|                data: elts.into_boxed_slice(),
   21|  4.88k|                data: elts.into_boxed_slice(),
  110|       |        fn empty() -> ArraySeqMtEphS<T>;
  119|       |        fn empty() -> ArraySeqMtPerS<T>;
  126|      0|        fn empty() -> Self { Self { data: Vec::new() } }
  126|       |        fn empty() -> ArraySeqStEphS<T>;
  129|      0|        fn empty() -> ArraySeqS<T> { ArraySeqS::from_vec(Vec::new()) }
  130|      7|        fn empty() -> Self {
  133|      0|        let empty = example_45_2_empty();
  141|       |        fn empty() -> Self;
  142|       |        fn empty() -> Self;
  143|  11.3k|        fn empty() -> Self { AVLTreeSeqStEphS::new_root() }
  144|    269|        fn empty() -> ArraySeqStPerS<T> { ArraySeqStPerS::empty() }
   14|       |        /// Empty slot - never occupied
  167|    166|        fn empty() -> Self { AVLTreeSeqMtPerS { root: None } }
  168|  2.82k|        fn empty() -> Self { AVLTreeSeqStPerS { root: None } }
  176|    243|        fn empty() -> Self {
  177|      0|        fn empty() -> Self { MathSeqS { data: Vec::new() } }
  185|      0|        fn empty() -> Set<T> { Set { data: HashSet::new() } }
  188|     31|        fn empty() -> ArraySeqStEphS<T> { ArraySeqStEphS::empty() }
  189|      0|        fn empty() -> ArraySeqMtPerS<T> { ArraySeqMtPerS::empty() }
   18|       |        fn empty() -> ArraySeqMtPerS<T>;
   18|       |        fn empty() -> ArraySeqStEphS<T>;
   18|       |        fn empty() -> ArraySeqStPerS<T>;
   18|       |        fn empty() -> Self;
   18|       |        fn empty() -> Self;
  191|      1|        fn empty() -> ArraySeqMtEphS<T> { ArraySeqMtEphS::empty() }
  195|      0|        fn empty() -> ArraySeqS<T> { ArraySeqS::empty() }
  197|     18|        fn empty() -> AVLTreeS<T> { AVLTreeS::new_root() }
  197|       |        fn empty() -> Self;
   19|       |        fn empty() -> Self;
   19|       |        fn empty() -> Self;
   19|       |        fn empty() -> Self;
   19|       |        fn empty() -> Self;
   19|       |        fn empty() -> Self;
   19|       |        fn empty() -> Self;
   19|       |        fn empty() -> Self;
   19|       |        fn empty() -> Self;
  206|     48|        fn empty() -> Self {
   20|       |        fn empty() -> ArraySeqMtEphS<T>;
   20|       |        fn empty() -> Set<T>;
   21|       |        fn empty() -> Self;
   21|       |        fn empty() -> Self;
   21|       |        fn empty() -> Self;
   21|       |        fn empty() -> Self;
   21|       |        fn empty() -> Self;
   21|       |        fn empty() -> Self;
   21|       |        fn empty() -> Self;
  226|      3|        fn empty() -> Self { Self::empty() }
  226|      3|        fn empty() -> Self { Self::empty() }
  226|      3|        fn empty() -> Self { Self::empty() }
  226|      3|        fn empty() -> Self { Self::empty() }
  226|      3|        fn empty() -> Self { Self::empty() }
  226|      3|        fn empty() -> Self { Self::empty() }
   22|       |        fn empty() -> DirGraphStEph<V>;
   22|       |        fn empty() -> Relation<X, Y>;
   22|       |        fn empty() -> Self;
   22|       |        fn empty() -> Self;
   22|       |        fn empty() -> Self;
   22|       |        fn empty() -> Self;
   22|       |        fn empty() -> UnDirGraphStEph<V>;
  235|      0|        fn empty() -> LinkedListStPerS<T> { LinkedListStPerS::empty() }
   23|       |        fn empty() -> Mapping<X, Y>;
   24|       |        fn empty() -> Self;
   24|       |        fn empty() -> Self;
   24|       |        fn empty() -> Self;
   24|       |        fn empty() -> Self;
   25|       |        fn empty() -> DirGraphMtEph<V>;
   25|       |        fn empty() -> Self;
   25|       |        fn empty() -> Self;
   25|       |        fn empty() -> Self;
   25|       |        fn empty() -> Self;
   25|       |        fn empty() -> UnDirGraphMtEph<V>;
  267|      1|        fn empty() -> Self { LinkedListStEphS::empty() }
   26|       |        fn empty() -> Self;
   26|       |        fn empty() -> Self;
   27|       |        fn empty() -> Self;
   27|       |        fn empty() -> Self;
  286|       |              $crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::AVLTreeSeqStPerTrait<_> >::empty() };
   28|       |        fn empty() -> Self;
   29|       |        fn empty() -> Self;
   29|       |        fn empty() -> Self;
   30|       |        fn empty() -> LinkedListStPerS<T>;
   31|       |        fn empty() -> Self;
   38|       |        fn empty() -> ArraySeqS<T>;
   41|     10|        fn empty() -> Self {
   42|       |        fn empty() -> Self;
   44|     17|        fn empty() -> Self {
   45|     10|        fn empty() -> Self {
   45|     14|        fn empty() -> Self {
   46|      7|        fn empty() -> Self {
   46|       |        fn empty() -> Self;
   46|       |        fn empty() -> Self;
   47|      7|        fn empty() -> Self {
   48|    117|        fn empty() -> Self {
   49|      7|        fn empty() -> Self {
   52|       |        fn empty() -> AVLTreeS<T>;
   54|     42|        fn empty() -> Self {
   54|     49|        fn empty() -> Self {
   54|     68|        fn empty() -> Self {
   55|    161|        fn empty() -> Self {
   56|     15|        fn empty() -> Self {
   56|  2.75k|        fn empty() -> Self {
   56|      3|        fn empty() -> UnDirGraphStEph<V> {
   56|     45|        fn empty() -> Self {
   58|  11.3k|        fn empty() -> Self {
   59|      4|        fn empty() -> UnDirGraphMtEph<V> {
   61|     48|        fn empty() -> Self {
   62|     10|        fn empty() -> Self {
   62|    116|        fn empty() -> Self {
   62|     13|        fn empty() -> Self {
   65|    107|        fn empty() -> Self {
   69|      1|        fn empty() -> ArraySeqMtEphS<T> {
   73|      6|        fn empty() -> Relation<X, Y> { Relation { pairs: SetLit![] } }
   74|      2|        fn empty() -> DirGraphStEph<V> {
   75|     28|        fn empty() -> ArraySeqStPerS<T> {
   76|      0|        fn empty() -> Mapping<X, Y> {
   76|     19|        fn empty() -> ArraySeqStEphS<T> {
   77|      4|        fn empty() -> DirGraphMtEph<V> {
   79|     33|        fn empty() -> Self { OrderedSetMtEph { elements: Vec::new() } }
   80|     25|        fn empty() -> Self {
   81|     28|        fn empty() -> Self {
   84|    184|        fn empty() -> Self {
   87|      2|        fn empty() -> ArraySeqMtPerS<T> {
   88|     93|        fn empty() -> Self {
   90|       |        fn empty() -> ArraySeqStPerS<T>;
   91|     96|        fn empty() -> Self {
   93|     83|        fn empty() -> Self {
   26|     20|                let empty_chain = ArraySeqStPerS::empty();
   39|    448|                let empty_chain = ArraySeqStPerS::empty();
   55|  1.83k|                let empty_entry = Entry::Empty;
  190|       |        fn empty_example() -> HeapsortComparison<i32>;
   37|      9|            let empty_list = ArraySeqStEphS::empty();
   39|      9|            let empty_list = ArraySeqStPerS::empty();
   35|       |        fn empty(reducer: F, identity: V) -> Self;
   35|       |        fn empty(reducer: F, identity: V) -> Self;
   35|       |        fn empty(reducer: F, identity: V) -> Self;
   85|     27|        fn empty(reducer: F, identity: V) -> Self {
   88|     31|        fn empty(reducer: F, identity: V) -> Self {
   94|     32|        fn empty(reducer: F, identity: V) -> Self {
  133|      1|            let empty_s = ArraySeqStPerS::new(0, ' ');
  141|      3|            let empty_s = ArraySeqStEphS::new(0, ' ');
  148|      4|            let empty_s = ArraySeqStPerS::new(0, ' ');
  149|      4|            let empty_s = ArraySeqStEphS::new(0, ' ');
  166|      1|            let empty_s = ArraySeqMtPerS::new(0, ' ');
  177|      1|            let empty_s = ArraySeqMtEphS::new(0, ' ');
  236|      4|            let empty_s = ArraySeqMtPerS::new(0, ' ');
  244|      4|            let empty_s = ArraySeqMtEphS::new(0, ' ');
  134|      1|            let empty_t = ArraySeqStPerS::new(0, ' ');
  135|      1|            Self::new(empty_s, empty_t)
  142|      3|            let empty_t = ArraySeqStEphS::new(0, ' ');
  143|      3|            Self::new(empty_s, empty_t)
  149|      4|            let empty_t = ArraySeqStPerS::new(0, ' ');
  150|      4|            let empty_t = ArraySeqStEphS::new(0, ' ');
  150|      4|            Self::new(empty_s, empty_t)
  151|      4|            Self::new(empty_s, empty_t)
  167|      1|            let empty_t = ArraySeqMtPerS::new(0, ' ');
  168|      1|            Self::new(empty_s, empty_t)
  178|      1|            let empty_t = ArraySeqMtEphS::new(0, ' ');
  179|      1|            Self::new(empty_s, empty_t)
  237|      4|            let empty_t = ArraySeqMtPerS::new(0, ' ');
  238|      4|            Self::new(empty_s, empty_t)
  245|      4|            let empty_t = ArraySeqMtEphS::new(0, ' ');
  246|      4|            Self::new(empty_s, empty_t)
   30|       |        fn empty(u: N) -> Self;
   74|     12|        fn empty(u: N) -> Self { Self::new(u) }
   32|   100k|            let end = start.saturating_add(length).min(total);
   41|    110|            let end = start.saturating_add(length).min(total);
   84|     13|            let end = min(k, s_len);
   84|     20|            let end = min(k, s_len);
   86|     13|            let end = min(k, s_len);
   86|     16|            let end = min(k, s_len);
   98|     18|            let end = self.range.end;
  143|      0|            let end_exclusive = start.saturating_add(length).min(sequence_length);
  152|      1|            let end_exclusive = start.saturating_add(length).min(sequence_length);
  153|      1|            if end_exclusive <= start_index {
  317|      2|            let end_idx = ((1 << (level + 1)) - 1).min(self.elements.length()); // 2^(level+1) - 1
   51|     26|                let ending_max = *all_prefixes.nth(i) - *min_prefixes.nth(i - 1);
   53|     26|                let ending_max = all_prefixes.nth_cloned(i) - min_prefixes.nth_cloned(i - 1);
  226|      2|            let end_pos = match self.elements.binary_search(k2) {
  127|       |            // Ensure v is in vertex set
  130|       |            // Ensure v is in vertex set
  149|       |            // Ensure h2_value is not zero (would cause infinite loop)
  272|       |            // Ensure h2_value is not zero to avoid infinite loops
  292|      1|   - Ensure probe sequences visit all positions
   32|       |            // Ensure h2 is not 0 (would cause infinite loop)
   47|       |            // Ensure odd for power-of-2 coprimality
   78|       |            // Ensure leftist property: left subtree has >= rank than right subtree
   89|       |            // Ensure both vertices exist
  107|      4|            let entries = ArraySeqStPerS::tabulate(
  120|      8|            let entries = ArraySeqStPerS::tabulate(
  136|      3|            let entries = self.collect();
  147|      3|            let entries = self.collect();
  150|      3|            let entries = self.collect();
  164|      6|            let entries = self.collect();
  166|      3|            let entries = self.collect();
  185|      2|            let entries = self.word_to_docs.collect();
  185|      6|            let entries = self.collect();
  193|     10|            let entries = self.collect();
  203|     10|            let entries = self.collect();
  206|      8|            let entries = self.collect();
  214|      9|            let entries = self.collect();
  216|      8|            let entries = self.collect();
  227|     12|            let entries = self.collect();
  228|     10|            let entries = self.collect();
  235|      8|            let entries = self.collect();
  241|     12|            let entries = self.collect();
  242|      3|            let entries = self.collect();
  245|      8|            let entries = self.collect();
  255|      3|            let entries = self.collect();
  256|     12|            let entries = self.collect();
  268|    973|                let entries = ArraySeqStPerS::tabulate(
  270|     12|            let entries = self.collect();
  274|      9|            let entries = self.collect();
  284|      3|            let entries = self.collect();
  285|     10|            let entries = self.collect();
  291|      8|            let entries = self.collect();
  295|  2.58k|                let entries = ArraySeqStPerS::tabulate(
  302|     11|            let entries = self.collect();
  308|      9|            let entries = self.collect();
  315|     25|            let entries = self.collect();
  318|      4|            let entries = self.collect();
  319|     13|            let entries = self.collect();
  329|      2|            let entries = self.collect();
  332|     11|            let entries = self.collect();
  349|     14|            let entries = self.collect();
  359|      2|            let entries = self.collect();
  194|     10|            if entries.length() == 0 {
  207|      8|            if entries.length() == 0 {
  236|      8|            if entries.length() == 0 {
  102|    533|                let entry = word_entries.nth(i);
  103|     47|                    let entry = Pair(Pair(p.clone(), v.clone()), v.clone());
  108|     23|                    let entry = Pair(Pair(p.clone(), v.clone()), v.clone());
  108|      8|                let entry = Pair(Pair(p.clone(), v.clone()), v.clone());
   10|       |    /// Entry type for flat hash tables using open addressing.
  116|     23|                let entry = Pair(Pair(p.clone(), v.clone()), v.clone());
  132|     14|                let entry = Pair(Pair(p.clone(), v.clone()), v.clone());
  143|     14|                let entry = Pair(Pair(p.clone(), v.clone()), v.clone());
  148|      8|                let entry = Pair(Pair(p.clone(), v.clone()), v.clone());
  165|    827|                let entry = self.table.nth(hash_pos);
  167|    827|                match entry {
  189|     30|                let entry = entries.nth(i);
  193|     22|                let entry = self.table.nth(hash_pos);
  195|     22|                match entry {
   20|       |    /// Entry type is parametric - can be ChainEntry, LinkedList, or any type implementing EntryTrait.
  247|      1|        let entry = &table[pos];
  248|    342|                let entry = self.table.nth(i);
  264|    523|                let entry = self.table.nth(hash_pos);
  266|    523|                match entry {
    2|       |//! Binary entry point for `apas-ai` (not used by library tests/benches).
  348|      8|                let entry = self.table.nth(i);
  349|      8|                match entry {
   34|       |    /// Entry type must implement this trait to define how Key and Value are stored.
   46|       |    /// Entry type is parametric - can be FlatEntry or any type implementing EntryTrait.
   87|    870|                let entry = self.table.nth(hash_pos);
   89|    870|                match entry {
   95|     34|            let entry = match entry_opt {
   96|     47|                    let entry = Pair(Pair(p.clone(), v.clone()), v.clone());
  169|     20|                    | Entry::Dead => {
  197|      0|                    | Entry::Dead => {
   22|      1|                | Entry::Dead => write!(f, "Dead"),
  271|       |                    | Entry::Dead => {
  351|      0|                    | Entry::Dead => writeln!(f, "  [{}]: Dead", i)?,
   94|       |                    | Entry::Dead => {
  168|     24|                    | Entry::Empty => return None,
  196|      5|                    | Entry::Empty => return (self.clone(), false),
   21|      1|                | Entry::Empty => write!(f, "Empty"),
  267|       |                    | Entry::Empty => {
  350|      7|                    | Entry::Empty => writeln!(f, "  [{}]: Empty", i)?,
   90|       |                    | Entry::Empty => {
  172|    783|                    | Entry::Live(existing_key, value) => {
  200|     17|                    | Entry::Live(existing_key, _) => {
  276|    366|                    | Entry::Live(existing_key, _) => {
   99|    600|                    | Entry::Live(existing_key, _) => {
   23|      1|                | Entry::Live(key, value) => write!(f, "Live({}, {})", key, value),
  352|      1|                    | Entry::Live(key, value) => writeln!(f, "  [{}]: {} → {}", i, key, value)?,
  233|      3|                    | Entry::Occupied(mut e) => {
  118|  4.94k|                let entry_to_use = if i == pos {
  205|    161|                                let entry_to_use = if i == hash_pos {
  292|  5.74k|                let entry_to_use = if i == pos {
  229|      3|                    | Entry::Vacant(e) => {
   10|       |    pub enum BalBinTree<T: StT> {
   11|       |    pub enum LeftistHeapNode<T: StT + Ord> {
   12|       |    pub enum Entry<K: StT, V: StT> {
   12|       |    pub enum Exposed<T: MtKey> {
   13|       |    pub enum Exposed<T: StT + Ord> {
   13|       |    pub enum FlatEntry<Key, Value> {
   14|       |    pub enum Exposed<T: MtKey> {
   41|       |    pub enum ClusteringSeverity {
   50|       |    pub enum PrimTreeSeqStTree<T: StT> {
   17|       |    /// Enumerated values in `std::cmp::Ordering` are named: Less, Equal, Greater.
  121|      1|        println!("  Ephemeral: key 20 -> {:?}", table_eph_tab.find(&20));
   17|       |    /// Ephemeral single-threaded matrix chain multiplication solver using dynamic programming
   19|       |    /// Ephemeral multi-threaded matrix chain multiplication solver using parallel dynamic programming
   19|       |    /// Ephemeral single-threaded optimal binary search tree solver using dynamic programming
   20|       |    /// Ephemeral multi-threaded optimal binary search tree solver using parallel dynamic programming
    2|       |//! Multi-threaded ephemeral enumerated set using bit array.
    2|       |//! Multi-threaded ephemeral matrix chain multiplication implementation using Vec and Arc<Mutex<Vec>> for mutable thread safety.
    2|       |//! Multi-threaded ephemeral optimal binary search tree implementation using Vec and Arc<Mutex<Vec>> for mutable thread safety.
    2|       |//! Multi-threaded ephemeral ordered set implementation using custom backing store.
    2|       |//! Multi-threaded ephemeral ordered table implementation extending TableMtEph.
    2|       |//! Multi-threaded ephemeral reducer-augmented ordered table implementation.
    2|       |//! Multi-threaded ephemeral set implementation using AVLTreeSetStEph as backing store.
    2|       |//! Single-threaded ephemeral array sequence (mutable) implementation.
    2|       |//! Single-threaded ephemeral ordered set implementation extending AVLTreeSetStEph.
    2|       |//! Single-threaded ephemeral ordered table implementation extending TableStEph.
    2|       |//! Single-threaded ephemeral reducer-augmented ordered table implementation.
    2|       |//! Single-threaded ephemeral set implementation using ArraySeqStEph as backing store.
    2|       |//! Single-threaded ephemeral set implementation using AVLTreeSeqStEph as backing store.
   52|      1|        println!("After ephemeral insert - table size: {}", table_eph.size());
    8|       |//! Uses ephemeral array sequences for efficient in-place updates.
    8|       |//! Uses ephemeral array sequences for efficient in-place updates.
    8|       |//! Uses ephemeral array sequences for efficient in-place updates.
    8|       |//! Uses ephemeral array sequences for efficient in-place updates.
    8|       |//! Uses ephemeral data structures for path manipulation.
  188|      1|        let eph_map_time = start.elapsed();
  130|     38|            let eph_seq = self.base_set.to_seq();
  147|      9|            let eph_seq = AVLTreeSeqStEphS::from_vec(elements);
  166|      1|        let eph_time = start.elapsed();
  137|      1|        let epsilon = 1e-9;
  138|      1|        let epsilon = 1e-9;
  102|       |    impl<T: Eq + Hash> Set<T> {
   11|       |    #[derive(PartialEq, Eq)]
  187|       |    impl Eq for MatrixChainMtPerS {}
   18|       |    #[derive(PartialEq, Eq)]
  238|       |    impl Eq for MatrixChainMtEphS {}
  245|       |    impl<T: Eq + Copy + Debug> PartialEq for AVLTreeS<T> {
  259|       |    impl<T: Eq + Copy + Debug> Eq for AVLTreeS<T> {}
   30|       |    #[derive(Clone, Eq, PartialEq, Debug)]
   30|       |    #[derive(Clone, Eq, PartialEq, Debug)]
  331|       |    impl<T: Eq> Eq for ArraySeqS<T> {}
   35|       |    #[derive(Clone, Eq, PartialEq, Debug)]
   52|       |    impl<A: Eq + Hash, B: Eq + Hash> Mapping<A, B> {
   56|       |    impl<T: Eq + Hash> PartialEq for Set<T> {
   60|       |    impl<T: Eq + Hash> Eq for Set<T> {}
   62|       |    impl<T: Eq + Hash + std::fmt::Debug> std::fmt::Debug for Set<T> {
   66|       |    impl Eq for Probability {}
   68|       |    impl<T: Eq + Hash + std::fmt::Display> std::fmt::Display for Set<T> {
   85|       |    impl<T: Eq + Hash> Hash for Set<T> {
    9|       |    #[derive(PartialEq, Eq, Debug)]
   47|     24|                key_equality: eq_fn,
  139|      0|        fn eq(&self, other: &Self) -> bool { self.multiset == other.multiset }
  144|    219|        fn eq(&self, a: &K, b: &K) -> bool { a == b }
  144|      2|        fn eq(&self, other: &Self) -> bool { self.V == other.V && self.E == other.E }
  147|      0|        fn eq(&self, other: &Self) -> bool { self.source == other.source && self.target == other.target }
  152|      3|        fn eq(&self, a: &String, b: &String) -> bool { a.to_lowercase() == b.to_lowercase() }
  161|      2|        fn eq(&self, other: &Self) -> bool {
  163|      0|        fn eq(&self, other: &Self) -> bool { self.multiset == other.multiset }
  165|      0|        fn eq(&self, other: &Self) -> bool { self.V == other.V && self.A == other.A }
  184|      1|        fn eq(&self, other: &Self) -> bool { self.dimensions == other.dimensions }
  186|      2|        fn eq(&self, other: &Self) -> bool { self.source == other.source && self.target == other.target }
  188|      1|        fn eq(&self, other: &Self) -> bool { self.keys == other.keys }
  208|     15|        fn eq(&self, other: &Self) -> bool {
  211|      6|        fn eq(&self, other: &Self) -> bool {
  224|      2|        fn eq(&self, other: &Self) -> bool {
  227|      1|        fn eq(&self, other: &Self) -> bool {
  229|      3|        fn eq(&self, other: &Self) -> bool { self.V == other.V && self.E == other.E }
  230|      1|        fn eq(&self, other: &Self) -> bool {
  235|      1|        fn eq(&self, other: &Self) -> bool {
  235|      1|        fn eq(&self, other: &Self) -> bool {
  246|      0|        fn eq(&self, other: &Self) -> bool {
  253|      2|        fn eq(&self, other: &Self) -> bool {
   25|       |        fn eq(&self, a: &K, b: &K) -> bool;
  296|      2|        fn eq(&self, other: &Self) -> bool {
  328|      0|        fn eq(&self, other: &Self) -> bool { self.data == other.data }
  340|      4|        fn eq(&self, other: &Self) -> bool {
  356|      0|        fn eq(&self, other: &Self) -> bool { self.V == other.V && self.A == other.A }
  378|      2|        fn eq(&self, other: &Self) -> bool {
   42|    136|        fn eq(&self, other: &Self) -> bool { self.data[..] == other.data[..] }
   57|     21|        fn eq(&self, other: &Self) -> bool { self.data == other.data }
   59|      0|        fn eq(&self, other: &Self) -> bool { self.pairs == other.pairs }
   60|     36|        fn eq(&self, other: &Self) -> bool {
   64|      0|        fn eq(&self, other: &Self) -> bool { self.rel == other.rel }
   71|     11|        fn eq(&self, other: &Self) -> bool {
   75|     63|        fn eq(&self, other: &Self) -> bool { self.data[..] == other.data[..] }
   86|      7|        fn eq(&self, other: &Self) -> bool { self.data == other.data }
   90|     11|        fn eq(&self, other: &Self) -> bool { self.to_vec() == other.to_vec() }
  361|      1|            (less_than, equal_or_greater)
  213|      0|        fn equals(&mut self, u: &V, v: &V) -> B { self.find(u) == self.find(v) }
   33|       |        fn equals(&mut self, u: &V, v: &V) -> B;
   55|      0|            | Err(_) => return create_negative_cycle_result(n),
   56|       |            | Err(_) => {
   66|       |            | Err(_) => {
   66|       |            | Err(_) => {
  211|      0|                | Err(arc) => (*arc).clone().into_iter(),
  212|      0|                | Err(arc) => (*arc).clone().into_iter(),
  266|      0|                | Err(arc) => {
  267|      0|                | Err(arc) => {
  137|      2|                return Err("Index out of bounds");
  199|      1|                return Err("Index out of bounds");
   58|      0|                    return Err("Index out of bounds");
  109|      1|                return Err("Negative-weight cycle detected".to_string());
  118|      1|                return Err("Negative-weight cycle detected".to_string());
   27|  17.4k|                    | Err(observed) => current = observed,
  114|      0|        Err("Algorithm error: max rounds exceeded".to_string())
  123|      0|        Err("Algorithm error: max rounds exceeded".to_string())
  159|      4|                | Err(pos) => {
  179|      4|                | Err(pos) => {
  193|      0|                | Err(pos) => pos,
  224|      1|                | Err(pos) => pos,
  228|      1|                | Err(pos) => pos,
  241|      4|                | Err(pos) => pos,
   91|    266|                | Err(pos) => {
  171|       |        /// Estimate expected probe count for unsuccessful search
  183|       |        /// Estimate expected probe count for successful search
  206|       |            // Estimate collision chains based on load factor and probe diversity
  209|       |        /// Estimate expected probe count for double hashing
  255|       |        // Estimate probe counts
  263|       |        /// Estimate expected probe count for quadratic probing
  323|       |        // Estimate probe counts for 50% load factor
  350|       |        // Estimate probe counts for 50% load factor
  212|      1|        let euler = euler_tour_mt(graph, start, spanning_tree);
  239|      1|        let euler = euler_tour(graph, start, spanning_tree);
   45|       |    /// Euler Tour of a Tree (Parallel version, but DFS remains sequential)
   47|       |    /// Euler Tour of a Tree
    5|       |//! - Euler tour of spanning tree
    5|       |//! Note: Euler tour remains sequential (DFS-based), but included for API completeness
   71|      6|    fn euler_tour_dfs<V: StT + MtT + Hash + Ord>(
   76|      6|    fn euler_tour_dfs<V: StT + Hash + Ord>(
  123|      2|        if euler_tour.is_empty() {
  139|      2|        if euler_tour.is_empty() {
   21|       |        fn euler_tour_mt<V: StT + MtT + Hash + Ord + 'static>(
   23|       |        fn euler_tour<V: StT + Hash + Ord>(
   44|       |                        // Even index: use scan result from contracted sequence
   71|       |                        // Even index: use scan result from contracted sequence
  112|       |    /// Example 47.6: Insertion with collision handling
  115|       |        // Example 41.3: fromSeq a = Seq.reduce Set.union ∅ ⟨{x} : x ∈ a⟩
   11|       |        /// Example 45.2: Textbook heapsort demonstration
  127|       |        // Example 41.3: Two implementations of fromSeq
   12|       |        /// Example 3.2 (Cost of Insertion Sort). Considering insertion sort example, suppose that we
   12|       |        /// Example 47.1: String hash function demonstration
   13|       |        /// Example 41.1 cases using ArraySetStEph
  141|      1|        println!("\n=== Example 42.1 Complete ===");
   14|       |        /// Example 42.1: Basic table operations demonstration
   15|       |        /// Example 45.2: Reverse-sorted input demonstration
  164|      7|        println!("\n=== Example 43.1 Complete ===");
   16|       |        /// Example 47.1: Demonstrate hash function on sample strings
   16|       |        /// Example demonstrating a negative weight cycle
  179|       |        /// Example from textbook - demonstrate heapsort on a small dataset
   17|       |        /// Example 41.1 cases using AVLTreeSetStEph
   17|       |        /// Example demonstrating path weight computation with integer weights.
  197|       |    /// Example from textbook - demonstrate heapsort on a small dataset
   19|       |        /// Example 45.2: Already-sorted input demonstration
   20|       |        /// Example 47.2: Linear probing hash table demonstration
   20|       |        /// Example showing that shortest paths are undefined in presence of negative cycles
   21|       |        /// Example demonstrating path weight computation with floating-point weights.
   23|      7|        println!("=== Example 43.1: Ordered Set Operations ===");
   23|       |    /// Example 42.1: Basic table operations demonstration
   23|       |        /// Example 45.2: Input with duplicates demonstration
   24|       |        /// Example 47.3: Separate chaining hash table demonstration
   25|       |    /// Example demonstrating a negative weight cycle.
   25|       |        /// Example with negative edge weights.
  272|      2|            example_name: "Example 47.4: Linear Probing Primary Clustering".to_string(),
   27|       |        // Example 41.1 cases using ArraySetStEph
   27|       |    /// Example 44.2: Staged computation pattern
   27|       |        /// Example 45.2: Single element demonstration
  296|       |        // Example 47.2 data
   29|       |    /// Example demonstrating path weight computation with integer weights.
  308|      2|            example_name: "Example 47.5: Quadratic Probing with Prime Table".to_string(),
  313|       |        // Example 47.1
   31|       |        /// Example 45.2: Empty input demonstration
  321|       |        // Example 47.2
  327|       |        // Example 47.4
  333|       |    /// Example demonstrating probe sequence generation and analysis
   33|       |    /// Example 47.1: String hash function demonstration
  342|      2|            example_name: "Example 47.6: Double Hashing Optimal Distribution".to_string(),
   35|       |        /// Example 45.2: Efficiency comparison demonstration
  360|       |    /// Example demonstrating the importance of prime table sizes
   36|       |    /// Example 47.1: Demonstrate hash function on sample strings
  374|       |    // Example usage of the macro
    3|       |//! Implements Example 11.10 using the project Parallel Pair abstraction.
   15|       |        fn example_41_1_array_set();
   19|       |        fn example_41_1_avl_set();
    4|       |pub mod Example41_3 {
   16|       |        fn example_42_1();
    4|       |pub mod Example42_1 {
    4|       |pub mod Example43_1 {
    4|       |pub mod Example44_1 {
   44|       |    /// Example 45.2: Textbook heapsort demonstration
    4|       |pub mod Example45_2 {
   21|       |        fn example_45_2_already_sorted() -> HeapsortComparison<i32>;
   25|       |        fn example_45_2_duplicates() -> HeapsortComparison<i32>;
   37|       |        fn example_45_2_efficiency_demonstration() -> Vec<(String, Vec<i32>)>;
   33|       |        fn example_45_2_empty() -> HeapsortComparison<i32>;
   17|       |        fn example_45_2_reverse_sorted() -> HeapsortComparison<i32>;
   29|       |        fn example_45_2_single_element() -> HeapsortComparison<i32>;
   13|       |        fn example_45_2_textbook_example() -> HeapsortComparison<i32>;
   45|       |    /// Example demonstrating path weight computation with floating-point weights.
  460|       |    /// Example: Load Factor Impact Analysis
   18|       |        fn example_47_1_demonstration() -> Vec<(String, N)>;
   14|       |        fn example_47_1_hash_function() -> StringPositionHashFunction;
   22|       |        fn example_47_2_linear_probing();
   26|       |        fn example_47_3_separate_chaining();
   49|       |    /// Example: Sum reduction for numeric values
   50|       |        /// Example query: searching for 'fun' should return {"jack", "mary", "peter"}
   51|       |    /// Example 45.2: Reverse-sorted input demonstration
   53|       |        /// Example query: searching for 'club' should return {"mary"}
    8|       |pub mod Example56_1 {
    9|       |pub mod Example56_3 {
   56|       |        /// Example query: searching for 'food' should return {"nick", "peter"}
   57|       |    /// Example showing that shortest paths are undefined in presence of negative cycles.
   58|       |    /// Example 45.2: Already-sorted input demonstration
   59|       |    /// Example: Max reduction for ordered values
   59|       |        /// Example query: searching for 'chess' should return {"jack"}
   61|       |            // Example 41.3: fromSeq a = Seq.reduce Set.union ∅ ⟨{x} : x ∈ a⟩
   61|       |        /// Example 47.1: Sum character positions modulo table size
   63|       |    /// Example 47.2: Separate chaining demonstration
   63|       |    /// Example: Count reduction (counts number of elements)
   65|       |        // Example 41.3: fromSeq a = Seq.reduce Set.union ∅ ⟨{x} : x ∈ a⟩
   65|       |    /// Example 45.2: Input with duplicates demonstration
   66|       |    /// Example 47.4: Flat table probe sequence demonstration
   69|       |            // Example 41.3: fromSeq a = Seq.reduce Set.union ∅ ⟨{x} : x ∈ a⟩
   71|       |            // Example 41.3: fromSeq a = Seq.reduce Set.union ∅ ⟨{x} : x ∈ a⟩
   72|       |    /// Example 45.2: Single element demonstration
   77|       |        // Example 41.1 cases using AVLTreeSetStEph
   79|       |    /// Example 45.2: Empty input demonstration
   81|       |    /// Example with negative edge weights.
   86|       |    /// Example 45.2: Efficiency comparison demonstration
   95|       |    /// Example 47.5: Deleted entry handling demonstration
   99|      0|        output.push_str("=== Example 45.2: Heapsort Algorithm Demonstrations ===\n\n");
   32|       |        pub example_name: String,
   18|       |        fn example_negative_cycle();
   26|       |        fn example_negative_weights();
   22|       |        fn example_path_weight_float();
   18|       |        fn example_path_weight_int();
  141|      1|        let examples = TweetQueryExamples::new();
    3|       |//! Textbook Examples 47.4, 47.5, 47.6 and additional demonstrations
    7|       |//! # Examples
    7|       |//! # Examples
   22|       |        fn example_undefined_shortest_path();
   54|       |        /// Execute action while holding the lock.
   10|       |        /// Exercise 21.5: Generate all contiguous subsequences using nested tabulate + flatten
    4|       |pub mod Exercise12_1 {
    4|       |pub mod Exercise12_2 {
    4|       |pub mod Exercise12_5 {
  128|       |    /// Exercise 47.1: Nested table implementation using Table ADT
  145|       |    /// Exercise 63.1: Count Components using star_contract higher-order function
   14|       |        /// Exercise 21.8 / Algorithm 21.4 (Brute Force Primality Test)
  155|       |    /// Exercise 47.2: Table size reduction analysis
   15|       |    /// Exercise 21.5: Generate all contiguous subsequences using nested tabulate + flatten.
  161|       |    /// Exercise 63.2: Connected Components using star_contract higher-order function
   18|       |        /// Exercise 21.7: Comprehension with conditionals
  192|       |    /// Exercise 47.3: Resize operation implementation and cost analysis
  205|       |    /// Exercise 63.1: Count Components using star_contract_mt higher-order function
    4|       |pub mod Exercise21_5 {
    4|       |pub mod Exercise21_7 {
    4|       |pub mod Exercise21_8 {
  219|       |    /// Exercise 63.2: Connected Components using star_contract_mt higher-order function
  228|       |    /// Exercise 47.6: Higher-order function implementation
   22|       |    /// Exercise 21.8 / Algorithm 21.4 (Brute Force Primality Test)
  269|       |    /// Exercise 47.7: Complete flat hash table implementation
   27|       |    /// Exercise 64.2: Spanning Tree via Star Contraction
   29|       |    /// Exercise 64.2: Spanning Tree via Star Contraction (Parallel)
   34|       |    /// Exercise 21.7: Comprehension with conditionals
    4|       |//! Implements Exercise 64.2: Compute spanning tree using parallel star contraction.
    4|       |//! Implements Exercise 64.2: Compute spanning tree using star contraction.
    7|       |//! - Exercise 63.1: count_components using star_contract
    7|       |//! - Exercise 63.1: count_components using star_contract
    8|       |//! - Exercise 63.2: connected_components using star_contract
    8|       |//! - Exercise 63.2: connected_components using star_contract
  335|       |        // Exercises
  100|    600|                        if existing_key == &key {
  173|    783|                        if existing_key == key {
  201|     17|                        if existing_key == key {
  277|    366|                        if existing_key == &key {
   88|     12|            if exists {
  155|       |        // Expand: just return the recursive result (no expansion needed for counting)
  156|      1|        let expand = |_v: &Set<V>, _e: &Set<Edge<V>>, _centers: &Set<V>, _part: &HashMap<V, V>, r: N| r;
  177|       |        // Expand: compose partition map P with component map C
  178|      1|        let expand = |_v: &Set<V>,
  213|       |        // Expand: just return the recursive result
  214|      1|        let expand = |_v: &Set<V>, _e: &Set<Edge<V>>, _centers: &Set<V>, _part: &HashMap<V, V>, r: N| r;
  236|       |        // Expand: compose partition map P with component map C
  237|      0|        let expand = |_v: &Set<V>,
   38|       |            // Expand: reconstruct result
   49|       |        // Expand: add star partition edges to recursive result
   50|      1|        let expand = |_v: &Set<V>,
   52|       |        // Expand: add star partition edges and map quotient tree edges back
   53|      5|        let expand = |_v: &Set<V>,
   61|       |            // Expand: reconstruct result using parallel tabulation
  158|     13|            let expected = &self.binary_heap_result; // Use binary heap as reference
  179|       |            // Expected probes for unsuccessful search: 1/(1-α)
  190|       |            // Expected probes for successful search: (1/α) * ln(1/(1-α))
  415|      0|                "  Expected successful probes: {:.2}",
  420|      0|                "  Expected unsuccessful probes: {:.2}",
   65|       |        /// Expected result: ⟨'jack', 'peter'⟩
   80|       |        /// Expected result: 2 (mary and peter)
  146|      4|            let expected_avg_cluster_size = if size > 0 { load as f64 / size as f64 } else { 0.0 };
  152|      1|        let expected_club = vec!["mary".to_string()];
  165|      1|        let expected_complex = vec!["jack".to_string(), "peter".to_string()];
  220|     20|            let expected_diversity = size.min(100) as f64;
  109|      4|        let expected_edges = if n_vertices > 0 { n_vertices - 1 } else { 0 };
  109|      5|        let expected_edges = if n > 0 { n - 1 } else { 0 };
   81|      0|        let expected_edges = if n > 0 { n - 1 } else { 0 };
  145|      1|        let expected_fun = vec!["jack".to_string(), "mary".to_string(), "peter".to_string()];
   32|       |        pub expected_successful_probes: f64,
   33|       |        pub expected_unsuccessful_probes: f64,
   75|     20|        fn explore<V, G, S>(
   80|     20|        fn explore<V, G, S>(
   82|     60|            fn explore<V, P, G, PF>(
   88|     32|            fn explore<V, G, S>(
   89|     60|            fn explore<V, P, G, PF>(
   92|     30|            fn explore<V, P, G, PF>(
  110|      1|            match exposed {
   69|     81|            match exposed {
   95|  7.83k|            match exposed {
  103|      3|                | Exposed::Leaf => None,
  110|  1.75k|                | Exposed::Leaf => (ParamBST::new(), false, ParamBST::new()),
  111|      0|                | Exposed::Leaf => ParamTreap::new(),
  113|      0|                | Exposed::Leaf => left,
  124|      5|                | Exposed::Leaf => b.clone(),
  135|     28|                | Exposed::Leaf => None,
  136|     39|                | Exposed::Leaf => {}
  147|    291|                | Exposed::Leaf => left,
  160|    257|                | Exposed::Leaf => b.clone(),
  176|    159|                | (Exposed::Leaf, _) | (_, Exposed::Leaf) => ParamBST::new(),
  177|      5|                | Exposed::Leaf => None,
  196|    156|                | (Exposed::Leaf, _) => ParamBST::new(),
  217|    276|                | Exposed::Leaf => ParamBST::new(),
  245|    277|                | Exposed::Leaf => identity,
  273|    645|                | Exposed::Leaf => {}
  276|      0|                | Exposed::Leaf => {}
  335|    160|                | Exposed::Leaf => None,
  389|      7|                | Exposed::Leaf => None,
   70|      3|                | Exposed::Leaf => ParamBST::new(),
   82|     29|                | Exposed::Leaf => (ParamBST::new(), false, ParamBST::new()),
   96|      5|                | Exposed::Leaf => ParamBST::new(),
  114|      3|                | Exposed::Node(_, key, _) => {
  148|     28|                | Exposed::Node(_, key, _) => {
  125|      4|                | Exposed::Node(al, ak, ar) => {
  161|    254|                | Exposed::Node(al, ak, ar) => {
  177|    156|                | (Exposed::Node(al, ak, ar), _) => {
  198|    156|                | (Exposed::Node(al, ak, ar), _) => {
  104|      5|                | Exposed::Node(left, key, _) => match ParamBST::min_key(&left) {
  111|  6.12k|                | Exposed::Node(left, root_key, right) => match key.cmp(&root_key) {
  112|      1|                | Exposed::Node(left, key, right) => {
  136|  1.29k|                | Exposed::Node(left, key, _) => match ParamBST::min_key(&left) {
  137|     33|                | Exposed::Node(left, key, right) => {
  178|     17|                | Exposed::Node(left, root_key, right) => match key.cmp(&root_key) {
  218|    271|                | Exposed::Node(left, key, right) => {
  246|    271|                | Exposed::Node(left, key, right) => {
  274|    631|                | Exposed::Node(left, key, right) => {
  277|      0|                | Exposed::Node(left, key, right) => {
  336|  5.12k|                | Exposed::Node(left, root_key, right) => match key.cmp(&root_key) {
  390|    792|                | Exposed::Node(left, root_key, right) => match key.cmp(&root_key) {
   71|     78|                | Exposed::Node(left, key, right) => {
   83|     51|                | Exposed::Node(left, root_key, right) => match key.cmp(&root_key) {
   97|  7.83k|                | Exposed::Node(left, key, right) => {
   60|    196|        fn expose_internal(&self) -> Exposed<T> {
   67|    802|        fn expose_internal(&self) -> Exposed<T> {
   84|  18.9k|        fn expose_internal(&self) -> Exposed<T> {
   40|       |        /// Exposes the internal structure as Zero, One, or Two parts
   93|       |        /// Exposes the internal structure as `Zero`, `One`, or `Two` parts.
  138|      0|        fn expose(&self) -> PrimTreeSeqStTree<T> {
  153|      2|        fn expose(&self) -> Exposed<T> { self.expose_internal() }
  292|       |        fn expose(&self) -> Exposed<T>;
  294|      3|        fn expose(&self) -> Exposed<T> { self.expose_internal() }
  350|      3|        fn expose(&self) -> Exposed<T> { self.expose_internal() }
   36|       |        fn expose(&self) -> Exposed<T>;
   36|       |        fn expose(&self) -> Exposed<T>;
   42|       |        fn expose(&self) -> PrimTreeSeqStTree<T>;
  147|       |    /// Expresses countComponents in terms of starContract (Algorithm 62.5).
  163|       |    /// Expresses connectedComponents in terms of starContract (Algorithm 62.5).
   28|       |    /// Extends ordered table operations with efficient reduction
   28|       |    /// Extends ordered table operations with efficient reduction and in-place mutations
   31|       |    /// Extends ordered table operations with efficient reduction and thread-safe operations
  132|       |            // Extract data from both mutexes
  160|       |        /// Extract all elements in sorted order (heapsort-like operation)
  201|       |            // Extract data from both mutexes
  208|       |            // Extract Vec from Arc - this consumes the Arc
  209|       |            // Extract Vec from Arc - this consumes the Arc
  210|       |        /// Extract all elements in sorted order (already sorted)
  219|       |        /// Extract all elements in sorted order (already sorted)
  263|       |            // Extract Vec from Arc<Mutex<Vec>> - this consumes the Arc
  264|       |            // Extract Vec from Arc<Mutex<Vec>> - this consumes the Arc
  284|       |        /// Extract all elements in sorted order (heapsort)
  300|       |        /// Extract all elements in sorted order
  425|       |        // Extract all elements in sorted order
   52|       |            // Extract result from bottom-right corner
   52|       |            // Extract result from bottom-right corner
   54|       |            // Extract result from bottom-right corner
   54|       |            // Extract result from bottom-right corner
   62|       |        // Extract potentials
   72|       |        // Extract potentials
   72|       |        // Extract potentials
   82|       |            // Extract data from mutex
   91|       |            // Extract minimum priority vertex
   13|       |//! - `extract_path`: Work O(k), Span O(k) where k is path length
   13|       |//! - `extract_path`: Work O(k), Span O(k) where k is path length
   13|       |//! - `extract_path`: Work O(k), Span O(k) where k is path length
   13|       |//! - `extract_path`: Work O(k), Span O(k) where k is path length
   14|       |//! - `extract_path`: Work O(k), Span O(k) where k is path length
   14|       |//! - `extract_path`: Work O(k), Span O(k) where k is path length
   14|       |//! - `extract_path`: Work O(k), Span O(k) where k is path length
   14|       |//! - `extract_path`: Work O(k), Span O(k) where k is path length
  100|       |        /// Extracts the shortest path from source to vertex v by following predecessors.
  105|       |        /// Extracts the shortest path from source to vertex v by following predecessors.
  108|       |        /// Extracts the shortest path from source to vertex v by following predecessors.
  108|       |        /// Extracts the shortest path from u to v by following predecessors.
  110|       |        /// Extracts the shortest path from u to v by following predecessors.
  110|       |        /// Extracts the shortest path from u to v by following predecessors.
  112|       |        /// Extracts the shortest path from u to v by following predecessors.
   98|       |        /// Extracts the shortest path from source to vertex v by following predecessors.
  105|      2|            f: F,
  117|      6|            let f = Arc::new(f);
  120|    213|            f: F,
  121|       |            f: F,
  142|       |            f: F,
  150|      1|            reducer: F,
  165|       |            f: &F,
  175|      3|            self.base_table.intersection(&other.base_table, f);
  176|      4|            let f = Arc::new(f);
  184|      1|            self.base_table.intersection(&other.base_table, f);
  190|      1|            self.base_table.union(&other.base_table, f);
  192|      1|            self.base_table.intersection(&other.base_table, f);
  198|      1|            self.base_table.union(&other.base_table, f);
  199|      3|            self.base_table.intersection(&other.base_table, f);
  205|      0|            f: &F,
  205|  3.99k|            f: F,
  207|      5|            self.base_table.union(&other.base_table, f);
   20|       |        reducer: F,
   20|       |        reducer: F,
  216|     10|            f: F,
  222|      3|            self.base_table.reduce(init, f)
   22|       |        f: F,
  230|      3|            let f = Arc::new(f);
  239|      1|    operation: F
   23|       |        reducer: F,
   26|       |        f: F,
   28|       |        f: F,
  293|      1|            f: &F,
   32|       |        f: F,
   33|       |            f: F,
  342|      1|            f: &F,
   35|       |            f: F,
  377|      3|                        format_node(left, f, depth + 1)?;
  378|      3|                        format_node(right, f, depth + 1)?;
  385|      1|            format_node(&self.root, f, 0)
   46|       |            reducer: F,
   50|       |            f: &F,
  178|     16|            load_factor: f64,
  210|       |        max_load_factor: f64,
  211|       |        min_load_factor: f64,
  271|     19|            load_factor: f64,
  289|     16|            load_factor: f64,
  320|     51|            successful_probes: f64,
  321|     51|            unsuccessful_probes: f64,
  322|     51|            clustering_score: f64,
  359|      1|            load_factor: f64,
  176|      1|                return f64::INFINITY;
  187|      1|                return f64::INFINITY;
  214|      0|                return f64::INFINITY;
  268|      2|                return f64::INFINITY;
   74|       |            f: &F,
   97|      1|            let f = Arc::new(f);
   97|    437|                f: F,
  163|      2|1. Load factor α falls below a threshold (e.g., α < 0.25)
  281|      1|2. load factor Management:
  108|      0|                return false;
  113|      0|                return false;
  113|      1|            return false;
  114|      0|                return false;
  117|      0|                return false;
  120|      0|                return false;
  121|      0|                return false;
  121|      0|                return false;
  126|      1|                clustering_enabled: false,
  127|      0|                return false;
  127|      1|                prime_validation_enabled: false,
  141|      0|                    relative_prime_validation: false,
  142|      0|                return false;
  143|      0|                return false;
  144|      1|                            return false;
  147|      0|            return false;
  147|      4|                clustering_enabled: false,
  148|      4|                prime_validation_enabled: false,
  149|      0|                return false;
  149|      1|                    return false;
  150|      0|                return false;
  154|      0|            return false;
  158|      1|                self.bits.set(x, false);
  163|      0|                return false;
  167|      0|            return false;
  169|      1|                    return false;
  169|      1|                    table_size_is_prime: false,
  173|      0|            return false;
  181|      0|                    table_size_is_prime: false,
  189|     21|            return false;
  201|      8|                    return false; // Adjacent edge flipped heads
  210|      0|                return false;
  213|      0|                return false;
  216|      1|                    return false;
  217|      1|                    return false;
  226|      0|                            return false;
  231|      0|                    return false;
  238|      0|            (self.clone(), false)
  248|      0|                return false;
  252|      0|                    return false;
  254|      1|            (self.clone(), false)
  255|      0|                return false;
  259|      1|                    return false;
  283|      1|            return false;
   29|      0|                (AVLTreeSetStEph::empty(), false)
  297|      1|                return false;
  312|      0|                return false;
  314|      0|                    return false;
  320|      1|                return false;
   32|      2|            return false;
  326|      1|                return false;
  332|      1|                    return false;
   33|      2|                (AVLTreeSetStEph::singleton(first), false)
   34|      0|                (AVLTreeSetMtPer::empty(), false)
  342|      1|                return false;
  345|      0|                    return false;
  346|      1|                    return false;
   38|      0|                (AVLTreeSetStPer::empty(), false)
   38|      2|                (AVLTreeSetMtPer::singleton(first), false)
  383|      0|                return false;
   42|      3|                (AVLTreeSetStPer::singleton(first), false)
   44|      2|        assert_eq!(set_search.find(&4), false);
   44|      3|                return false;
   46|      1|            return false;
   46|      2|                clustering_enabled: false,
   47|      1|            return (false, visited);
   50|     20|                return false;
   56|      6|                    return false;
   58|      0|                return (false, "h2(k) cannot be zero".to_string());
   59|      2|            return false; // Cycle detected
   62|      0|                return false;
   62|      0|                return (false, "Table size cannot be zero".to_string());
   64|      2|                visualization_enabled: false,
   67|      0|                return false;
   71|      0|                        return false;
   71|      0|                return false;
   72|      4|                return false; // Cycle detected
   73|      1|                return false;
   76|      0|                return false;
   77|      0|                        return false;
   77|      2|                    return false;
   78|      0|                | (false, true) => Ordering::Less,    // everything < NaN
   79|       |                | (false, false) => {
   82|      2|                analysis_enabled: false,
   83|      2|                detailed_metrics: false,
   84|      0|            return false;
   85|      5|                            return false;
   91|      0|                return false;
   94|      2|        assert_eq!(set_search.find(&4), false);
   99|      1|                return false;
   38|     10|            let false_row = ArraySeqStEphS::from_vec(vec![false; n]);
   40|      8|            let false_row = ArraySeqStPerS::from_vec(vec![false; n]);
  177|      1|        fn family_description(&self) -> String { format!("UniversalIntegerHashFamily (p={})", self.p) }
   37|       |        fn family_description(&self) -> String;
  103|      6|                    let f_clone = Arc::clone(&f);
  134|      5|            let f_clone = f.clone();
  135|    105|            let f_clone = f.clone();
  192|      4|            let f_clone = f.clone();
  194|      8|                let f_clone = f.clone();
  223|  1.99k|            let f_clone = f.clone();
  233|    106|                let f_clone2 = f.clone();
  247|      6|                let f_clone2 = f.clone();
  232|    106|                let f_clone = f.clone();
  321|     73|            let f_clone2 = f.clone();
  233|      4|            let f_clone = f.clone();
  346|  1.99k|            let f_clone2 = f.clone();
  246|      6|                let f_clone = f.clone();
  249|      3|            let f_clone = f.clone();
  320|     73|            let f_clone = f.clone();
  345|  1.99k|            let f_clone = f.clone();
   44|     22|            let f_clone = Arc::clone(&f);
  255|     29|                    if f_clone(&pair.0, &pair.1) {
   57|     22|            let f_combine = Arc::clone(&f);
   46|     15|            let f_contract = Arc::clone(&f);
  301|      1|All these features are implemented in our FlatHashTable module
  118|    117|                    if f(elem) {
   95|     24|                if f(elem) {
   97|     25|                if f(elem) {
   40|      1|        "Hardware fetch_add completes in one atomic operation; the CAS loop may repeat under contention, so it cannot outperform native fetch_add."
   11|       |        fn fetch_add_cas(&self, delta: usize) -> usize;
   21|  8.00k|        fn fetch_add_cas(&self, delta: usize) -> usize {
   14|       |    impl FetchAddCasTrait for AtomicUsize {
   66|     15|            let f_expand = Arc::clone(&f);
   15|       |        fn fib(n: N) -> N;
    5|       |pub mod FibonacciMt {
  390|       |        /// Filter elements based on a predicate
   42|       |        // Filter out composites to get primes
    7|       |//! - filter: Work Θ(n), Span Θ(log n) via PARALLEL map-reduce
    7|       |//! - filter: Work Θ(n), Span Θ(log n) via PARALLEL map-reduce
   92|      1|        println!("\n--- Filter Operations ---");
  107|      4|            let filtered: Vec<T> = self
  107|      4|            let filtered: Vec<T> = self
  107|      4|            let filtered: Vec<T> = self
  107|      4|            let filtered: Vec<T> = self
  107|      6|            let filtered: Vec<T> = self
  107|      9|            let filtered: Vec<T> = self
  116|    108|            let filtered = ArraySeqStEphS::filter(&self.entries, &|pair| f(&pair.0, &pair.1));
  124|      3|            let filtered: Vec<T> = self
  124|      3|            let filtered: Vec<T> = self
  124|      3|            let filtered: Vec<T> = self
  124|      4|            let filtered: Vec<T> = self
  124|      4|            let filtered: Vec<T> = self
  124|      7|            let filtered: Vec<T> = self
  125|      3|            let filtered = parallel_filter(vals, f);
  126|     12|            let filtered = ArraySeqStEphS::filter(&self.elements, &|elem| elem != x);
  133|    143|            let filtered = ArraySeqStPerS::filter(&self.entries, &|pair| f(&pair.0, &pair.1));
  180|     13|            let filtered: Vec<T> = self
  180|      6|            let filtered: Vec<T> = self
  180|      6|            let filtered: Vec<T> = self
  180|      6|            let filtered: Vec<T> = self
  180|      7|            let filtered: Vec<T> = self
  180|      7|            let filtered: Vec<T> = self
  244|     25|            let filtered = ArraySeqStEphS::filter(&self.entries, &|pair| &pair.0 != key);
  248|  8.32k|            let filtered = ArraySeqStPerS::filter(&self.entries, &|pair| &pair.0 != key);
  254|     52|                let filtered = ArraySeqStEphS::filter(&self.entries, &|pair| pair.0 != key);
  262|      1|            let filtered: Vec<T> = self
  276|     20|            let filtered = ArraySeqStEphS::filter(&self.entries, &|pair| keys.find(&pair.0));
  279|      1|            let filtered: Vec<T> = self
   28|     12|        let filtered: ArraySeqStPerS<N> = <ArraySeqStPerS<N> as ArraySeqStPerTrait<N>>::filter(&all, &|x| is_prime(*x));
  282|     20|            let filtered = ArraySeqStEphS::filter(&self.entries, &|pair| !keys.find(&pair.0));
  313|     19|            let filtered = ArraySeqStPerS::filter(&self.entries, &|pair| keys.find(&pair.0));
  318|     19|            let filtered = ArraySeqStPerS::filter(&self.entries, &|pair| !keys.find(&pair.0));
   35|      8|        let filtered = set_nums.filter(|&x| x < 7);
   43|    525|        let filtered: ArraySeqStPerS<N> = <ArraySeqStPerS<N> as ArraySeqStPerTrait<N>>::filter(&candidates, &|x| {
   69|      6|            let filtered = self.edges.filter(|edge| &edge.0 == &u_clone);
   72|      7|            let filtered = self.edges.filter(|edge| &edge.0 == &u_clone);
   74|      6|            let filtered = self.edges.filter(move |edge| &edge.0 == &u_clone);
   78|      3|            let filtered = ArraySeqStEphS::filter(&self.elements, &f);
   83|     13|            let filtered = ArraySeqStEphS::filter(&self.elements, &|elem| other.find(elem));
   85|      8|        let filtered = set_nums.filter(|&x| x < 7);
   88|     13|            let filtered = ArraySeqStEphS::filter(&self.elements, &|elem| !other.find(elem));
   41|      5|        let filtered_a = <ArraySeqStPerS<N> as ArraySeqStPerTrait<N>>::filter(a, &|x| is_even(x));
   42|      5|        let filtered_b = <ArraySeqStPerS<char> as ArraySeqStPerTrait<char>>::filter(b, &|y| is_vowel(y));
  104|      1|        fn filter<F: Fn(&T) -> B>(&mut self, f: F) {
  105|    145|        fn filter<F: Fn(&T) -> B + Send + Sync + 'static>(&mut self, f: F) { self.elements.retain(|x| f(x)); }
  108|       |        fn filter<F: Fn(&T) -> B>(a: &ArraySeqStPerS<T>, pred: &F) -> ArraySeqStPerS<T>;
  111|      1|        fn filter<F: Fn(&T) -> B>(&self, f: F) -> Self {
  111|     75|        fn filter<F: Fn(&T) -> B + Send + Sync + Clone + 'static>(&self, f: F) -> Self {
  115|      3|        fn filter<F: Fn(&K, &V) -> B>(&mut self, f: F) {
  132|      7|        fn filter<F: Fn(&K, &V) -> B>(&self, f: F) -> Self {
  133|       |        fn filter<F: Fn(&T) -> B + Send + Sync>(a: &ArraySeqMtEphS<T>, pred: &F) -> ArraySeqMtEphS<T>;
  136|      4|        fn filter<F: Fn(&K, &V) -> B>(&self, f: F) -> Self {
  144|       |        fn filter<F: Fn(&T) -> B>(a: &ArraySeqStEphS<T>, pred: &F) -> ArraySeqStEphS<T>;
  148|      3|        fn filter<F: Fn(&K, &V) -> B>(&self, f: F) -> Self {
  151|      3|        fn filter<F: Fn(&T) -> B + Send + Sync + Clone + 'static>(a: &ArraySeqMtPerS<T>, pred: F) -> ArraySeqMtPerS<T> {
  151|       |        fn filter<F: Fn(&T) -> B + Send + Sync>(a: &ArraySeqMtPerS<T>, pred: &F) -> ArraySeqMtPerS<T>;
  152|      4|        fn filter<F: Fn(&T) -> B>(a: &ArraySeqStPerS<T>, pred: &F) -> ArraySeqStPerS<T> {
  167|      5|        fn filter<F: Fn(&T) -> B>(a: &ArraySeqStEphS<T>, pred: &F) -> ArraySeqStEphS<T> {
  169|      2|        fn filter<F: Fn(&T) -> B + Send + Sync + Clone + 'static>(a: &ArraySeqMtEphS<T>, pred: F) -> ArraySeqMtEphS<T> {
  176|  1.08k|        fn filter<F: Fn(&T) -> B>(a: &ArraySeqStPerS<T>, pred: &F) -> ArraySeqStPerS<T> {
  208|      3|        fn filter<F: Fn(&T) -> B + Send + Sync + Clone + 'static>(a: &Self, pred: F) -> Self {
  215|       |        fn filter<F: Fn(&T) -> B>(a: &Self, pred: &F) -> Self;
  222|     58|        fn filter<F: Fn(&T) -> B>(a: &ArraySeqStEphS<T>, pred: &F) -> ArraySeqStEphS<T> {
  229|      3|        fn filter<F: Fn(&K, &V) -> B + Send + Sync + 'static>(&mut self, f: F) {
  233|      1|        fn filter<F: Fn(&T) -> B>(a: &ArraySeqS<T>, pred: &F) -> ArraySeqS<T> {
  250|      1|        fn filter<F: Fn(&T) -> B + Send + Sync>(a: &ArraySeqMtEphS<T>, pred: &F) -> ArraySeqMtEphS<T> {
  251|      2|        fn filter<F: Fn(&T) -> B + Send + Sync>(a: &ArraySeqMtPerS<T>, pred: &F) -> ArraySeqMtPerS<T> {
  258|      1|        fn filter<F: FnMut(&T) -> bool>(&self, predicate: F) -> Self { BSTSetAVLMtEph::filter(self, predicate) }
  258|      1|        fn filter<F: FnMut(&T) -> bool>(&self, predicate: F) -> Self { BSTSetBBAlphaMtEph::filter(self, predicate) }
  258|      1|        fn filter<F: FnMut(&T) -> bool>(&self, predicate: F) -> Self { BSTSetRBMtEph::filter(self, predicate) }
  258|      1|        fn filter<F: FnMut(&T) -> bool>(&self, predicate: F) -> Self { BSTSetSplayMtEph::filter(self, predicate) }
  258|      1|        fn filter<F: FnMut(&T) -> bool>(&self, predicate: F) -> Self { BSTSetTreapMtEph::filter(self, predicate) }
  284|      2|        fn filter<F: Fn(&T) -> B>(a: &LinkedListStPerS<T>, pred: &F) -> LinkedListStPerS<T> {
   28|       |        fn filter<F: Fn(&T) -> B>(&self, f: F) -> Self;
   28|       |        fn filter<F: Fn(&T) -> B>(&self, f: F) -> Self;
  300|      3|        fn filter<F: Fn(&T) -> B>(a: &Self, pred: &F) -> Self {
   30|       |        fn filter<F: Fn(&T) -> B>(&self, f: F) -> Self;
  328|       |        fn filter<F: Pred<T>>(&self, predicate: F) -> Self;
   34|       |        fn filter<F: Fn(&K, &V) -> B>(&mut self, f: F);
   34|       |        fn filter<F: Fn(&T) -> B>(&self, f: F) -> Self;
   35|       |        fn filter<F: Fn(&T) -> B>(&mut self, f: F);
   35|       |        fn filter<F: Fn(&T) -> B + Send + Sync + Clone + 'static>(&self, f: F) -> Self;
   35|       |        fn filter<F: Fn(&T) -> B + Send + Sync + Clone + 'static>(&self, f: F) -> Self;
   35|       |        fn filter<F: Pred<T>>(&mut self, f: F);
  366|      5|        fn filter<F: Fn(&T) -> bool + Send + Sync + 'static>(&self, predicate: F) -> Self {
   36|       |        fn filter<F: PredVal<N> + Clone>(&self, f: F) -> Self;
   37|       |        fn filter<F: Fn(&K, &V) -> B + Send + Sync + 'static>(&mut self, f: F);
   38|       |        fn filter<F: Fn(&K, &V) -> B>(&self, f: F) -> Self;
   40|       |        fn filter<F: Fn(&T) -> B + Send + Sync + Clone + 'static>(a: &ArraySeqMtPerS<T>, pred: F) -> ArraySeqMtPerS<T>;
   41|       |        fn filter<F: Fn(&K, &V) -> B>(&self, f: F) -> Self;
  420|      3|        fn filter<F: Pred<T>>(&self, predicate: F) -> Self { ParamTreap::filter_parallel(self, predicate) }
   45|       |        fn filter<F: Fn(&K, &V) -> B>(&self, f: F) -> Self;
   46|       |        fn filter<F: Fn(&T) -> B + Send + Sync + Clone + 'static>(a: &ArraySeqMtEphS<T>, pred: F) -> ArraySeqMtEphS<T>;
   47|       |        fn filter<F: Fn(&K, &V) -> B>(&self, f: F) -> Self;
   48|       |        fn filter<F: Fn(&K, &V) -> B + Send + Sync + 'static>(&self, f: F) -> Self;
   48|       |        fn filter<F: Fn(&T) -> B>(a: &ArraySeqStEphS<T>, pred: &F) -> ArraySeqStEphS<T>;
   48|       |        fn filter<F: Fn(&T) -> B>(a: &ArraySeqStPerS<T>, pred: &F) -> ArraySeqStPerS<T>;
   53|       |        fn filter<F: FnMut(&T) -> bool>(&self, predicate: F) -> Self;
   53|       |        fn filter<F: FnMut(&T) -> bool>(&self, predicate: F) -> Self;
   53|       |        fn filter<F: FnMut(&T) -> bool>(&self, predicate: F) -> Self;
   53|       |        fn filter<F: FnMut(&T) -> bool>(&self, predicate: F) -> Self;
   53|       |        fn filter<F: FnMut(&T) -> bool>(&self, predicate: F) -> Self;
   53|       |        fn filter<F: FnMut(&T) -> bool>(&self, predicate: F) -> Self;
   57|       |        fn filter<F: Fn(&T) -> B>(a: &LinkedListStPerS<T>, pred: &F) -> LinkedListStPerS<T>;
   64|       |        fn filter<F: Fn(&T) -> B>(a: &ArraySeqS<T>, pred: &F) -> ArraySeqS<T>;
   64|       |        fn filter<F: Fn(&T) -> B + Send + Sync + Clone + 'static>(a: &Self, pred: F) -> Self;
   72|       |        fn filter<F: Fn(&T) -> bool + Send + Sync + 'static>(&self, predicate: F) -> Self;
   77|      3|        fn filter<F: Fn(&T) -> B>(&self, f: F) -> Self {
   78|      1|        fn filter<F: Fn(&K, &V) -> B>(&self, f: F) -> Self {
   81|      3|        fn filter<F: Fn(&T) -> B + Send + Sync + Clone + 'static>(&self, f: F) -> Self {
   91|      7|        fn filter<F: Fn(&T) -> B>(&self, f: F) -> Self {
   93|      7|        fn filter<F: Fn(&T) -> B>(&self, f: F) -> Self {
   95|      1|        fn filter<F: PredVal<N> + Clone>(&self, f: F) -> Self {
  160|      3|        fn filter<F>(&self, f: F) -> Self
  331|      1|        fn filter<F>(&self, predicate: F) -> Self
  167|      1|        fn filter<G: Fn(&K, &V) -> B>(&self, f: G) -> Self {
  169|      1|        fn filter<G: Fn(&K, &V) -> B>(&self, f: G) -> Self {
  178|      1|        fn filter<G: Fn(&K, &V) -> B + Send + Sync + 'static>(&self, f: G) -> Self {
   43|       |        fn filter<G: Fn(&K, &V) -> B>(&self, f: G) -> Self;
   45|       |        fn filter<G: Fn(&K, &V) -> B>(&self, f: G) -> Self;
   50|       |        fn filter<G: Fn(&K, &V) -> B + Send + Sync + 'static>(&self, f: G) -> Self;
    5|       |//! Arc filtering (NPlus, NMinus) and vertex map-reduce (NGOfVertices, etc.) are parallel.
    5|       |//! Edge filtering (NG) and vertex map-reduce (NGOfVertices) are parallel.
  212|     25|        fn filter_inner<F: Pred<T>>(tree: &Self, predicate: &Arc<F>) -> Self {
  215|    547|        fn filter_inner<F: Fn(&T) -> bool + Send + Sync + 'static>(tree: &Self, predicate: &Arc<F>) -> Self {
  233|      3|        fn filter_parallel<F: Pred<T>>(tree: &Self, predicate: F) -> Self {
  236|      5|        fn filter_parallel<F: Fn(&T) -> bool + Send + Sync + 'static>(tree: &Self, predicate: F) -> Self {
  117|       |    /// Filters out self-edges (where both endpoints map to same super-vertex).
  164|    120|    fn filter_tail_to_head_mt<V: StT + Hash + Ord + Send + Sync + 'static>(
  131|     19|            let final_adj = if new_adj.find(&v).is_none() {
   79|    724|            let (final_left, final_right) = if left_rank >= right_rank {
  130|     36|                word_to_docs: final_table,
   55|      3|            let final_table = table.lock().unwrap();
   55|      4|            let final_table = table.lock().unwrap();
  100|       |            // Find minimum element and its index
   10|       |        /// Find maximum element via reduce.
  110|       |    /// Find all vertices reachable from source using breadth-first search.
  114|       |                // Find smallest among current, left child, right child
  119|       |    /// Find all vertices reachable from source using breadth-first search.
   11|       |        /// Find maximum element via parallel reduce.
  133|       |    /// Find all vertices reachable from source using breadth-first search.
  136|       |            // Find which in-neighbor u gave us the shortest path
  145|       |            // Find which in-neighbor u gave us the shortest path
  174|       |        // Find vertex bridges
  177|       |            // Find edge weight
  190|       |            // Find key position
  201|       |            // Find first kept value and create result sequence
   20|       |        /// Find vertex bridges for Borůvka's algorithm
   22|       |        /// Find vertex bridges for parallel Borůvka's algorithm
  239|       |        // Find vertex bridges (parallel)
   23|       |        /// Find the representative (root) of the set containing v with path compression
  257|       |                // Find insertion point
   27|       |        /// Find connected components using star contraction
  284|       |                // Find insertion point
  304|       |        /// Find next prime number >= n (for table sizing)
   30|       |        /// Find connected components using parallel star contraction
   35|       |        /// Find components using higher-order function approach
   38|      1|        println!("\n--- Find Operations ---");
   38|       |        /// Find components using higher-order function approach
   42|       |        // find {6, 2, 9, 11, 8} 4 = false
   62|       |        /// Find next prime greater than or equal to n
   68|       |        /// Find minimum element (leftmost in balanced tree)
   73|       |        /// Find the representative (root) of the set containing v
   78|       |        /// Find correct position and insert to maintain sorted order
   79|       |                // Find an original edge that connects the two stars (centers c1 and c2)
   80|       |            // Find insertion position using binary search approach
   80|       |        /// Find the period of the probe sequence for given h2_value and table_size
   83|       |            // Find insertion position
   84|       |            // Find insertion position
   88|       |            // Find first Empty or Deleted slot (can reuse Deleted slots for insertion)
   92|       |        // find {6, 2, 9, 11, 8} 4 = false
   94|       |        /// Find minimum and remove it, creating new list without that element
  126|    777|        fn find_link<'a>(link: &'a Link<K, V>, key: &K) -> Option<&'a V> {
  128|    614|        fn find_link<'a>(link: &'a Link<T>, target: &T) -> Option<&'a T> {
  129|    449|        fn find_link<'a>(link: &'a Link<T>, target: &T) -> Option<&'a T> {
  133|    397|        fn find_link<'a>(link: &'a Link<T>, target: &T) -> Option<&'a T> {
  141|     40|        fn find_link<'a>(link: &'a Link<T>, target: &T) -> Option<&'a T> {
  153|    213|        fn find_link<'a>(link: &'a Link<T>, target: &T) -> Option<&'a T> {
  153|  2.24M|        fn find_link<'a>(link: &'a Link<T>, target: &T) -> Option<&'a T> {
  172|  1.19k|        fn find_link<'a>(link: &'a Link<T>, target: &T) -> Option<&'a T> {
  175|     32|        fn find_link<'a>(link: &'a Link<T>, target: &T) -> Option<&'a T> {
  189|  1.92k|        fn find_link<'a>(link: &'a Link<T>, target: &T) -> Option<&'a T> {
  199|  1.91k|        fn find_link<'a>(link: &'a Link<K, V, R>, key: &K) -> Option<&'a V> {
   96|     70|        fn find_link<'a>(link: &'a Link<T>, target: &T) -> Option<&'a T> {
   98|  1.00k|        fn find_link<'a>(link: &'a Link<T>, target: &T) -> Option<&'a T> {
   71|     60|            fn find_min_priority<V: StT + Ord, P: StT + Ord>(
   78|     60|            fn find_min_priority<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static>(
   79|     30|            fn find_min_priority<V: StT + Ord, P: StT + Ord>(
   89|     30|            fn find_min_priority<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static>(
  191|     21|        fn find_min(&self) -> Option<&T> {
  226|     22|        fn find_min(&self) -> Option<&T> {
   26|       |        fn find_min(&self) -> Option<&T>;
   26|       |        fn find_min(&self) -> Option<&T>;
   26|       |        fn find_min(&self) -> Option<&T>;
   26|       |        fn find_min(&self) -> Option<&T>;
   38|       |        fn find_min(&self) -> Option<&T>;
   69|     21|        fn find_min(&self) -> Option<&T> {
   69|     30|        fn find_min(&self) -> Option<&T> {
   69|     31|        fn find_min(&self) -> Option<&T> {
  180|      0|        fn find(&mut self, v: &V) -> V {
   25|       |        fn find(&mut self, v: &V) -> V;
  104|  5.11k|    fn find_node<'a, T: StT + Ord>(node: &'a BalBinTree<T>, target: &T) -> Option<&'a T> {
  115|    850|            fn find_rec<T: StTInMtT + Ord>(link: &Link<T>, target: &T) -> Option<T> {
   14|       |        /// Finds strongly connected components in a directed graph
   14|       |        /// Finds strongly connected components in a directed graph
   19|       |    /// Finds all prime numbers less than n using brute force primality testing.
   19|       |    /// Finds strongly connected components in a directed graph.
   19|       |    /// Finds strongly connected components in a directed graph.
   35|       |        /// Finds documents containing the given word
   54|       |        /// Finds the first available slot (Empty or Deleted) for insertion.
  102|    326|        fn find(&self, k: &K) -> Option<V> { self.base_table.find(k) }
  105|    195|        fn find(&self, k: &K) -> Option<V> { self.base_table.find(k) }
  105|     40|        fn find(&self, k: &K) -> Option<V> { self.base_table.find(k) }
  107|    118|        fn find(&self, k: &K) -> Option<V> { self.base_table.find(k) }
  108|     38|        fn find(&self, k: &K) -> Option<V> { self.base_table.find(k) }
  114|    175|        fn find(&self, target: &T) -> Option<T> {
  114|     37|        fn find(&self, k: &K) -> Option<V> { self.base_table.find(k) }
  116|    724|        fn find(&self, x: &T) -> B {
  136|     82|        fn find(&self, word: &Word) -> DocumentSet {
  139|  38.2k|        fn find(&self, x: &T) -> B {
  141|   556k|        fn find(&self, x: &T) -> B {
  154|     70|        fn find(&self, x: N) -> B { if x < self.universe_size { self.bits[x] } else { false } }
  162|    178|        fn find(&self, target: &T) -> Option<T> {
  167|     10|        fn find(&self, target: &T) -> Option<&T> { Self::find_link(&self.root, target) }
  175|     22|        fn find(&self, key: &T) -> Option<T> {
  194|    154|        fn find(&self, target: &T) -> Option<T> {
  201|    134|        fn find(&self, target: &T) -> Option<T> {
  202|    119|        fn find(&self, target: &T) -> Option<&T> { Self::find_link(&self.root, target) }
  203|    112|        fn find(&self, key: &K) -> Option<&V> { Self::find_link(&self.root, key) }
  217|   232k|        fn find(&self, target: &T) -> Option<T> {
  223|  2.44k|        fn find(&self, key: &K) -> Option<V> {
  224|     61|        fn find(&self, target: &T) -> Option<&T> { Self::find_link(&self.root, target) }
  228|  4.02k|        fn find(&self, key: &K) -> Option<V> {
  231|    493|        fn find(&self, x: &T) -> B {
  232|    605|        fn find(&self, x: &T) -> B {
  234|      1|        fn find(&self, value: &T) -> Option<T> { self.tree.find(value) }
  234|      1|        fn find(&self, value: &T) -> Option<T> { self.tree.find(value) }
  234|      1|        fn find(&self, value: &T) -> Option<T> { self.tree.find(value) }
  234|      1|        fn find(&self, value: &T) -> Option<T> { self.tree.find(value) }
  234|      1|        fn find(&self, value: &T) -> Option<T> { self.tree.find(value) }
  234|      1|        fn find(&self, value: &T) -> Option<T> { self.tree.find(value) }
  246|      0|        fn find(&self, target: &T) -> Option<&T> { Self::find_link(&self.root, target) }
  248|    216|        fn find(&self, target: &T) -> Option<&T> { Self::find_link(&self.root, target) }
  256|    445|        fn find(&self, target: &T) -> Option<T> {
  257|     15|        fn find(&self, target: &T) -> Option<&T> { Self::find_link(&self.root, target) }
   28|       |        fn find(&self, k: &K) -> Option<V>;
   28|       |        fn find(&self, x: &T) -> B;
   29|       |        fn find(&self, k: &K) -> Option<V>;
   29|       |        fn find(&self, k: &K) -> Option<V>;
   29|       |        fn find(&self, target: &T) -> Option<&T>;
   29|       |        fn find(&self, value: &T) -> Option<T>;
   29|       |        fn find(&self, value: &T) -> Option<T>;
   29|       |        fn find(&self, value: &T) -> Option<T>;
   29|       |        fn find(&self, value: &T) -> Option<T>;
   29|       |        fn find(&self, value: &T) -> Option<T>;
   29|       |        fn find(&self, value: &T) -> Option<T>;
   29|       |        fn find(&self, x: &T) -> B;
   29|       |        fn find(&self, x: &T) -> B;
  306|    280|        fn find(&self, key: &K) -> Option<&V> { Self::find_link(&self.root, key) }
  310|       |        fn find(&self, key: &T) -> Option<T>;
   32|       |        fn find(&self, k: &K) -> Option<V>;
  333|  5.28k|        fn find(&self, key: &T) -> Option<T> {
   36|       |        fn find(&self, word: &Word) -> DocumentSet;
   36|       |        fn find(&self, x: &T) -> B;
   36|       |        fn find(&self, x: &T) -> B;
   37|       |        fn find(&self, k: &K) -> Option<V>;
   37|       |        fn find(&self, k: &K) -> Option<V>;
   37|       |        fn find(&self, k: &K) -> Option<V>;
  387|    799|        fn find(&self, key: &T) -> Option<T> {
   38|       |        fn find(&self, x: &T) -> B;
  392|  4.74k|        fn find(&self, key: &K) -> Option<V> {
   42|       |        fn find(&self, key: &K) -> Option<V>;
   43|       |        fn find(&self, x: &T) -> B;
   43|       |        fn find(&self, x: &T) -> B;
   44|       |        fn find(&self, x: N) -> B;
   45|       |        fn find(&self, key: &K) -> Option<V>;
   46|       |        fn find(&self, target: &T) -> Option<T>;
   48|       |        fn find(&self, key: &T) -> Option<T>;
   48|       |        fn find(&self, target: &T) -> Option<T>;
   48|       |        fn find(&self, target: &T) -> Option<T>;
   48|       |        fn find(&self, target: &T) -> Option<T>;
   50|       |        fn find(&self, target: &T) -> Option<&T>;
   52|       |        fn find(&self, target: &T) -> Option<&T>;
   52|       |        fn find(&self, target: &T) -> Option<&T>;
   52|       |        fn find(&self, target: &T) -> Option<&T>;
   52|       |        fn find(&self, target: &T) -> Option<&T>;
   53|       |        fn find(&self, key: &K) -> Option<&V>;
   54|       |        fn find(&self, key: &T) -> Option<T>;
   54|       |        fn find(&self, target: &T) -> Option<T>;
   54|       |        fn find(&self, target: &T) -> Option<T>;
   56|    125|        fn find(&self, k: &K) -> Option<V> { self.inner.find(k) }
   58|       |        fn find(&self, target: &T) -> Option<&T>;
   61|    125|        fn find(&self, target: &T) -> Option<&T> { find_node(&self.root, target) }
   63|       |        fn find(&self, key: &K) -> Option<V>;
   85|    221|        fn find(&self, x: &T) -> B { self.elements.binary_search(x).is_ok() }
   93|       |        fn find(&self, key: &K) -> Option<&V>;
   94|     70|        fn find(&self, x: &T) -> B { self.base_set.find(x) }
   95|     58|        fn find(&self, x: &T) -> B { self.base_set.find(x) }
  124|     19|        fn find_slot(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> N {
   56|       |        fn find_slot(table: &HashTable<Key, Value, Entry, Metrics>, key: &Key) -> N;
   86|     31|        fn find_slot(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> N {
   87|      4|        fn find_slot(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> N {
   22|      7|        let finish_order = compute_finish_order(graph);
   22|      7|        let finish_order = compute_finish_order(graph);
  102|      3|                if !first {
  116|       |                    // (First time we reach u with minimum distance through PQ ordering)
  116|       |                    // (First time we reach u with minimum distance through PQ ordering)
  122|      1|            let first = it.next().expect("length > 0 but iter was empty").clone();
  130|      6|                if !first {
  148|      6|                if !first {
  177|      3|                if !first {
  195|      3|                if !first {
  273|      0|                if !first {
   32|      2|                let first = seq.nth(0).clone();
  345|    131|                if first {
   37|      2|                let first = seq.nth(0).clone();
  380|    120|                if first {
  384|  3.81k|                if first {
  408|      3|                if !first {
   41|      3|                let first = seq.nth(0).clone();
   46|       |        // first A → 'artie'
   73|     19|                if !first {
   86|       |                    // First element has minimum priority (sorted by (P, V) pair)
   92|      9|            let first = it.next().expect("length > 0 but iter was empty").clone();
  135|      8|            let first_elem = if a.length() > 0 {
  137|      2|            let first_elem = if a.length() > 0 {
  209|      2|            let first_kept = first_kept.unwrap();
  192|     10|        fn first_key(&self) -> Option<K> {
  205|      8|        fn first_key(&self) -> Option<K> {
  216|      3|        fn first_key(&self) -> Option<K> { self.base_table.first_key() }
  229|      3|        fn first_key(&self) -> Option<K> { self.base_table.first_key() }
  234|      8|        fn first_key(&self) -> Option<K> {
  250|      3|        fn first_key(&self) -> Option<K> { self.base_table.first_key() }
   52|       |        fn first_key(&self) -> Option<K>;
   55|       |        fn first_key(&self) -> Option<K>;
   57|       |        fn first_key(&self) -> Option<K>;
   60|       |        fn first_key(&self) -> Option<K>;
   63|       |        fn first_key(&self) -> Option<K>;
   66|       |        fn first_key(&self) -> Option<K>;
  144|      6|        fn first(&self) -> Option<T> { self.elements.first().cloned() }
  151|     12|        fn first(&self) -> Option<T> {
  156|      5|        fn first(&self) -> Option<T> {
   48|       |        fn first(&self) -> Option<T>;
   49|       |        fn first(&self) -> Option<T>;
   49|       |        fn first(&self) -> Option<T>;
  105|    111|                result.set(i, f(i)).unwrap();
   98|     13|                result.set(i, f(i)).unwrap();
  137|   116k|        fn fix_up(link: &mut Link<T>) {
  139|    619|        fn fix_up(link: &mut Link<T>) {
  233|      1|The parametric flat hash table operations can be unified with a single higher-order function:
   44|       |    /// Flat Hash Table trait - extends ParaHashTableStEphTrait.
  338|      1|            writeln!(f, "FlatHashTable ({}) {{", self.probe_sequence.strategy_name())?;
    4|       |pub mod FlatHashTable {
    5|       |pub mod FlatHashTable {
  134|     16|            table: &FlatHashTable<K, String, AdvancedQuadraticProbingStrategy<K, H>>,
  157|     21|            table: &FlatHashTable<K, V, Self>,
  237|      1|    table: &FlatHashTable<K, V>,
   92|     20|            table: &FlatHashTable<K, String, AdvancedLinearProbingStrategy<K, H>>,
  273|       |            // Flatten by copying all elements
   33|       |        // flatten twice
   35|       |    /// flatten 〈 〈 (x, y) : y ∈ b | isVowel y 〉 : x ∈ a | isEven x 〉
  111|       |        fn flatten(a: &ArraySeqStPerS<ArraySeqStPerS<T>>) -> ArraySeqStPerS<T>;
  147|       |        fn flatten(a: &ArraySeqStEphS<ArraySeqStEphS<T>>) -> ArraySeqStEphS<T>;
  187|    229|        fn flatten(a: &ArraySeqStPerS<ArraySeqStPerS<T>>) -> ArraySeqStPerS<T> {
  233|     12|        fn flatten(a: &ArraySeqStEphS<ArraySeqStEphS<T>>) -> ArraySeqStEphS<T> {
  244|      1|        fn flatten(a: &ArraySeqS<ArraySeqS<T>>) -> ArraySeqS<T> {
   68|       |        fn flatten(a: &ArraySeqS<ArraySeqS<T>>) -> ArraySeqS<T>;
  198|    190|        fn flatten(s: &ArraySeqStPerS<ArraySeqStPerS<T>>) -> ArraySeqStPerS<T> {
  215|      7|        fn flatten(s: &ArraySeqStEphS<ArraySeqStEphS<T>>) -> ArraySeqStEphS<T> {
  274|      2|        fn flatten(s: &ArraySeqMtEphS<ArraySeqMtEphS<T>>) -> ArraySeqMtEphS<T> {
   54|       |        fn flatten(s: &ArraySeqMtEphS<ArraySeqMtEphS<T>>) -> ArraySeqMtEphS<T>;
   56|       |        fn flatten(s: &ArraySeqStEphS<ArraySeqStEphS<T>>) -> ArraySeqStEphS<T>;
   56|       |        fn flatten(s: &ArraySeqStPerS<ArraySeqStPerS<T>>) -> ArraySeqStPerS<T>;
  262|      2|        fn flatten(sequences: &[ArraySeqMtEphSliceS<T>]) -> Self {
   67|       |        fn flatten(sequences: &[ArraySeqMtEphSliceS<T>]) -> Self;
  148|       |        fn flatten(ss: &ArraySeqMtEphS<ArraySeqMtEphS<T>>) -> ArraySeqMtEphS<T>;
  178|       |        fn flatten(ss: &ArraySeqMtPerS<ArraySeqMtPerS<T>>) -> ArraySeqMtPerS<T>;
  221|       |        fn flatten(ss: &LinkedListStEphS<LinkedListStEphS<T>>) -> LinkedListStEphS<T>;
  256|    109|        fn flatten(ss: &ArraySeqMtPerS<ArraySeqMtPerS<T>>) -> ArraySeqMtPerS<T> {
  283|      3|        fn flatten(ss: &ArraySeqMtEphS<ArraySeqMtEphS<T>>) -> ArraySeqMtEphS<T> {
  320|      3|        fn flatten(ss: &LinkedListStEphS<LinkedListStEphS<T>>) -> LinkedListStEphS<T> {
  341|    111|        fn flatten(ss: &ArraySeqMtPerS<ArraySeqMtPerS<T>>) -> ArraySeqMtPerS<T> {
  385|      3|        fn flatten(ss: &LinkedListStPerS<LinkedListStPerS<T>>) -> LinkedListStPerS<T> {
   60|       |        fn flatten(ss: &ArraySeqMtPerS<ArraySeqMtPerS<T>>) -> ArraySeqMtPerS<T>;
   85|       |        fn flatten(ss: &LinkedListStPerS<LinkedListStPerS<T>>) -> LinkedListStPerS<T>;
  112|    217|                let f_left = f.clone();
  136|      0|            let f_left = f.clone();
  297|      6|            let f_left = f.clone();
   72|      4|    fn flip_coins_parallel<V: StT + MtT + 'static>(
  116|  22.1k|        fn flip_colors(link: &mut Link<T>) {
  118|    132|        fn flip_colors(link: &mut Link<T>) {
  160|   116k|            let flip_needed = match link {
  164|   116k|            if flip_needed {
  196|     50|        let flips1 = coin_flips.clone();
  199|     50|        let flips2 = coin_flips;
  149|     20|        let flips_arc = Arc::new(coin_flips);
    6|       |//! with floating-point edge weights. Stores distance and predecessor arrays for path reconstruction.
    6|       |//! with floating-point edge weights. Stores distance and predecessor arrays for path reconstruction.
    6|       |//! with floating-point edge weights. Stores distance matrix and predecessor matrix for path reconstruction.
    6|       |//! with floating-point edge weights. Stores distance matrix and predecessor matrix for path reconstruction.
  101|      2|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  101|      4|        fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult { write!(f, "{}", self.0) }
  116|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  119|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  125|      2|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  127|      2|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  131|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  133|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  134|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  136|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  140|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  140|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { write!(f, "V={} E={:?}", self.V, self.E) }
  140|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  143|      2|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  145|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  148|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  151|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  152|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  153|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  155|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  156|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  159|      4|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  161|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { write!(f, "V={} A={:?}", self.V, self.A) }
  161|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { write!(f, "({}: {:.3})", self.key, self.prob) }
  165|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  165|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { write!(f, "{}×{}", self.rows, self.cols) }
  167|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  167|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  169|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  172|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  172|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  173|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  183|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  184|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  190|      0|        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  190|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  190|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  192|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
   19|      3|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  194|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  198|      0|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  199|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { write!(f, "({}: {:.3})", self.key, self.prob) }
  203|      0|        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  204|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { write!(f, "{}×{}", self.rows, self.cols) }
  209|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  210|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, "({}, {})", self.0, self.1) }
  215|      0|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  215|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  216|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  217|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  220|      2|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  223|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  225|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { write!(f, "{}×{}", self.rows, self.cols) }
  225|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, "V={} E={:?}", self.V, self.E) }
  226|      6|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  229|      0|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  230|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  232|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { write!(f, "({}: {:.3})", self.key, self.prob) }
  234|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  236|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  241|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  243|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  246|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  247|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  249|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  251|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  262|      0|        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  262|      0|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  269|      0|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  269|      0|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  276|      0|        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  280|      0|        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  280|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
   28|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, "({} -> {})", self.0, self.1) }
  283|      0|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  286|      2|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  293|      0|        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  293|      0|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  295|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { write!(f, "{}×{}", self.rows, self.cols) }
  297|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  304|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { write!(f, "({}: {:.3})", self.key, self.prob) }
  310|      4|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  320|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  334|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult { f.debug_list().entries(self.data.iter()).finish() }
  336|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  337|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  338|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
  343|      0|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  352|      0|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, "V={} A={:?}", self.V, self.A) }
  361|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
   36|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  370|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  375|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  380|      0|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  394|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
  396|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  397|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  403|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
  408|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  410|      1|        fn fmt(&self, f: &mut Formatter<'_>) -> Result {
  411|      0|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  429|      0|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   48|     12|        fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult { f.debug_list().entries(self.data.iter()).finish() }
   49|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   52|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult { write!(f, "({}, {})", self.dist, self.vertex) }
   52|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult { write!(f, "({}, {})", self.dist, self.vertex) }
   61|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult { write!(f, "({}, {})", self.priority, self.vertex) }
   63|     12|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   65|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { std::fmt::Debug::fmt(&self.pairs, f) }
   66|      3|        fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
   69|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { Debug::fmt(&self.rel, f) }
   69|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { std::fmt::Display::fmt(&self.pairs, f) }
   69|     16|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   72|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> Result { Display::fmt(&self.rel, f) }
   81|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult { f.debug_list().entries(self.data.iter()).finish() }
   92|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   97|      2|        fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult { write!(f, "Probability({})", self.0) }
   98|      1|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   99|      0|        fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
  100|     10|        pub fn from_vec(values: Vec<T>) -> AVLTreeS<T>
  100|      1|        pub fn in_order(&self) -> ArraySeqStPerS<T> {
  100|      1|    pub fn validate_subpath_property_int(
  100|      5|        pub fn extract_path(&self, v: usize) -> Option<ArraySeqStPerS<usize>> {
  101|    423|        pub fn size(&self) -> N {
  102|      1|        pub fn med_memoized_parallel(&mut self) -> usize {
  102|      2|        pub fn extract_path(&self, v: usize) -> Option<ArraySeqStPerS<usize>> {
  102|     31|        pub fn iter<'a>(&'a self) -> AVLTreeSeqIterStEph<'a, T> { AVLTreeSeqIterStEph::new(&self.root) }
  103|      0|        pub fn lookup(&self, key: &K) -> Option<&V>
  103|      1|        pub fn get_memoized(&self, i: usize, j: usize) -> Option<usize> { self.memo_table.get(&(i, j)).copied() }
  103|    235|        pub fn in_neighbors_weighted(&self, v: &V) -> Set<(V, OrderedFloat<f64>)> {
  103|      3|        pub fn set(&mut self, index: N, item: T) -> Result<&mut Self, &'static str> { self.update(index, item) }
  103|      4|        pub fn is_reachable(&self, v: usize) -> bool { self.get_distance(v) != UNREACHABLE }
  103|     89|        pub fn push_back(&mut self, value: T) {
  103|  93.7k|        pub fn empty() -> Set<T> { Set { data: HashSet::new() } }
  104|      0|        pub fn singleton(item: T) -> Self { LinkedListStPerS::from_vec(vec![item]) }
  104|      1|        pub fn med_memoized_parallel(&self) -> usize {
  105|      2|        pub fn total_weight(&self) -> OrderedFloat<f64> {
  105|     32|        pub fn analyze_quadratic_probing(&self, key: &str, table_size: N, c1: N, c2: N) -> ProbeSequenceVisualization {
  105|      4|        pub fn intersection(&self, other: &Self) -> Self {
  105|      4|        pub fn intersection(&self, other: &Self) -> Self {
  105|      4|        pub fn intersection(&self, other: &Self) -> Self {
  105|      4|        pub fn intersection(&self, other: &Self) -> Self {
  105|      6|        pub fn intersection(&self, other: &Self) -> Self {
  105|      8|        pub fn singleton(x: T) -> Set<T> {
  105|      9|        pub fn intersection(&self, other: &Self) -> Self {
  106|      0|        pub fn pre_order(&self) -> ArraySeqStPerS<T> {
  106|    167|        pub fn from_vec(elts: Vec<T>) -> Self {
  106|      1|        pub fn get_all_words(&self) -> ArraySeqStPerS<Word> { self.index.get_all_words() }
  106|      1|        pub fn sizeA(&self) -> N { self.sizeE() }
  106|      4|        pub fn is_reachable(&self, u: usize, v: usize) -> bool { self.get_distance(u, v) != UNREACHABLE }
  106|      4|        pub fn is_reachable(&self, v: usize) -> bool { self.get_distance(v).is_finite() }
  107|      2|        pub fn extract_path(&self, v: usize) -> Option<ArraySeqStPerS<usize>> {
  107|      5|        pub fn memo_size(&self) -> usize { self.memo_table.len() }
  107|      5|    pub fn verify_spanning_tree<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>, tree_edges: &Set<Edge<V>>) -> B {
  108|      0|        pub fn insert_memo(&mut self, i: usize, j: usize, value: usize) { self.memo_table.insert((i, j), value); }
  108|     10|        pub fn contains_value(&self, target: &T) -> B {
  108|      4|        pub fn is_reachable(&self, u: usize, v: usize) -> bool { self.get_distance(u, v).is_finite() }
  108|      4|        pub fn is_reachable(&self, u: usize, v: usize) -> bool { self.get_distance(u, v) != UNREACHABLE }
  108|      4|    pub fn verify_mst_size<V: StT + Hash + Ord>(n_vertices: N, mst_edges: &Set<LabEdge<V, OrderedFloat<f64>>>) -> B {
  109|      1|        pub fn arcs(&self) -> &Set<Edge<V>> { self.edges() }
  109|      1|        pub fn get_word_count(&self) -> N { self.index.word_count() }
  110|    144|        pub fn union(&mut self, u: &V, v: &V) {
  110|      1|    pub fn contract_round<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> UnDirGraphStEph<V> {
  110|      2|        pub fn extract_path(&self, u: usize, v: usize) -> Option<ArraySeqStPerS<usize>> {
  110|      2|        pub fn extract_path(&self, v: usize) -> Option<ArraySeqStPerS<usize>> {
  110|      4|        pub fn is_reachable(&self, u: usize, v: usize) -> bool { self.get_distance(u, v).is_finite() }
  110|     54|        pub fn new(hash1: H1, hash2: H2) -> Self {
  111|  12.7k|        pub fn size(&self) -> N { self.data.len() }
  112|      1|        pub fn is_memoized(&self, i: usize, j: usize) -> bool { self.memo_table.contains_key(&(i, j)) }
  112|      1|        pub fn NPlus(&self, v: &V) -> Set<V> { self.NG(v) }
  112|      1|        pub fn query_builder_example(&self) -> DocumentSet {
  112|     25|    pub fn bridge_star_partition<V: StT + Hash + Ord>(
  112|      2|        pub fn extract_path(&self, u: usize, v: usize) -> Option<ArraySeqStPerS<usize>> {
  112|      2|        pub fn extract_path(&self, u: usize, v: usize) -> Option<ArraySeqStPerS<usize>> {
   11|     23|    pub fn create_tweet_collection() -> DocumentCollection {
  112|      4|    pub fn reachable<V: StT + Ord, G>(graph: &G, source: V) -> AVLTreeSetStEph<V>
  112|      7|        pub fn join(tree: PrimTreeSeqStTree<T>) -> Self {
  113|      1|    pub fn example_47_6_collision_handling() -> LinearProbingHashTable<String, String, StringPositionHashFunction> {
  113|      1|        pub fn to_arrayseq(&self) -> ArraySeqS<T>
  113|     20|        pub fn vertex_degree(&self, v: &V) -> usize { self.neighbors(v).size() }
  113|      4|        pub fn s_length(&self) -> usize { self.seq_s.length() }
  113|  8.38k|        pub fn mem(&self, x: &T) -> B { if self.data.contains(x) { true } else { false } }
  114|      2|        pub fn extract_path(&self, u: usize, v: usize) -> Option<ArraySeqStPerS<usize>> {
  114|      2|        pub fn in_neighbors_weighted(&self, v: &V) -> Set<(V, i32)> {
  114|      3|    pub fn contract_to_vertices<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> Set<V> {
  115|      1|        pub fn NMinus(&self, v: &V) -> Set<V> { self.NG(v) }
  115|  44.2k|        pub fn union(&self, other: &Set<T>) -> Set<T>
  116|     12|        pub fn iter(&self) -> std::slice::Iter<'_, T> { self.data.iter() }
  116|     14|    pub fn heapsort_leftist_heap<T: StT + Ord>(sequence: &[T]) -> Vec<T> {
  116|    170|        pub fn length(&self) -> N { self.len }
  116|      1|        pub fn total_weight(&self) -> OrderedFloat<f64> {
  116|     25|        pub fn new(hash_fn: H) -> Self {
  116|      3|        pub fn insert_value(&mut self, value: T) { self.push_back(value); }
  116|      5|        pub fn s_length(&self) -> usize { self.seq_s.length() }
  116|     99|        pub fn lookup(&self, key: &K) -> Option<&V> {
  116|      9|        pub fn is_connected(&self) -> bool {
  117|     16|        pub fn new(a: u64, b: u64) -> Self {
  117|      1|        pub fn get_memoized(&self, i: usize, j: usize) -> Option<usize> { self.memo_table.get(&(i, j)).copied() }
  117|      8|        pub fn delete_value(&mut self, target: &T) -> bool {
  118|      1|        pub fn NPlusOfVertices(&self, u_set: &Set<V>) -> Set<V> { self.NGOfVertices(u_set) }
  118|    226|        pub fn nth(&self, index: N) -> &T {
  118|      4|        pub fn s_length(&self) -> usize { self.seq_s.length() }
  118|      4|        pub fn t_length(&self) -> usize { self.seq_t.length() }
  119|      1|        pub fn total_weight(&self) -> i32 { self.labeled_edges().iter().map(|edge| edge.2).sum() }
  119|      6|        pub fn iter_mut(&mut self) -> std::slice::IterMut<'_, T> { self.data.iter_mut() }
  121|      1|        pub fn in_neighbors_weighted(&self, v: &V) -> Set<(V, OrderedFloat<f64>)> {
  121|      1|        pub fn NMinusOfVertices(&self, u_set: &Set<V>) -> Set<V> { self.NGOfVertices(u_set) }
  121|      4|    pub fn reachable<V: StTInMtT + Ord + 'static, G>(graph: &G, source: V) -> AVLTreeSetMtPer<V>
  121|      5|        pub fn t_length(&self) -> usize { self.seq_t.length() }
  122|      1|        pub fn new_minimal(hash1: H1, hash2: H2) -> Self {
  122|      2|    pub fn shortcut_tour_mt<V: StT + MtT + Hash + Ord>(euler_tour: &[V]) -> std::vec::Vec<V> {
  122|      3|        pub fn difference(&self, other: &Self) -> Self {
  122|      3|        pub fn difference(&self, other: &Self) -> Self {
  122|      3|        pub fn difference(&self, other: &Self) -> Self {
  122|      4|        pub fn difference(&self, other: &Self) -> Self {
  122|      4|        pub fn difference(&self, other: &Self) -> Self {
  122|      4|        pub fn s_length(&self) -> usize { self.seq_s.length() }
  122|     69|        pub fn vertex_degree(&self, v: &V) -> usize { self.neighbors(v).size() }
  122|      7|        pub fn difference(&self, other: &Self) -> Self {
  123|      0|        pub fn delete(&self, key: &K) -> (Self, bool)
  123|     13|        pub fn empty() -> Self { Self { data: Vec::new() } }
  123|      2|        pub fn is_empty(&self) -> bool { self.seq_s.length() == 0usize && self.seq_t.length() == 0usize }
  123|      4|        pub fn t_length(&self) -> usize { self.seq_t.length() }
  124|      1|        pub fn edges_above_weight(&self, threshold: OrderedFloat<f64>) -> Set<(V, V, OrderedFloat<f64>)> {
  124|      1|        pub fn InDegree(&self, v: &V) -> N { self.Degree(v) }
  124|     65|        pub fn subseq_copy(&self, start: N, length: N) -> Self {
  126|      0|        pub fn singleton(item: T) -> Self { Self { data: vec![item] } }
  126|     11|    pub fn doc_set_to_sorted_vec(docs: &DocumentSet) -> Vec<DocumentId> {
  126|     11|        pub fn intersection(&self, other: &Set<T>) -> Set<T>
  126|      1|        pub fn total_weight(&self) -> OrderedFloat<f64> {
  126|      2|    pub fn example_41_3_from_seq_demonstration() {
  126|      2|        pub fn is_empty(&self) -> bool { self.seq_s.length() == 0usize && self.seq_t.length() == 0usize }
  127|      1|        pub fn OutDegree(&self, v: &V) -> N { self.Degree(v) }
  127|      1|    pub fn validate_subpath_property_float(
  127|      4|        pub fn t_length(&self) -> usize { self.seq_t.length() }
  128|      1|        pub fn clear_memo(&mut self) { self.memo_table.clear(); }
  128|      1|    pub fn validate_subpath_property_float(
  128|      2|        pub fn is_empty(&self) -> bool { self.seq_s.length() == 0usize && self.seq_t.length() == 0usize }
  129|      2|    pub fn exercise_47_1_nested_implementation() -> String {
  129|     36|        pub fn from_vec(data: Vec<T>) -> Self { Self { data } }
  129|     42|        pub fn new_with_coefficients(hash_fn: H, c1: N, c2: N) -> Self {
  131|     16|        pub fn analyze_quadratic_probing<K: StT, H: HashFunClone<K>>(
  131|      1|        pub fn drain(&self) -> Vec<T> {
  131|      1|        pub fn set_s(&mut self, s: ArraySeqStEphS<char>) { self.seq_s = s; }
  132|      2|        pub fn is_empty(&self) -> bool { self.seq_s.length() == 0usize && self.seq_t.length() == 0usize }
  132|      3|        pub fn delete(&self, key: &K) -> (Self, bool) {
  132|      4|        pub fn iter<'a>(&'a self) -> AVLTreeSeqIter<'a, T> { AVLTreeSeqIter::new(&self.root) }
  132|      4|        pub fn with_len(length: N, init_value: T) -> Self {
  133|      0|        pub fn set_s(&mut self, s: ArraySeqStEphS<char>) {
  133|     13|    pub fn compare_all_heapsorts<T: StT + Ord>(sequence: &[T]) -> HeapsortComparison<T> {
  134|     20|        pub fn analyze_double_hashing_quality(&self, key: &K, table_size: N) -> DoubleHashingMetrics {
  134|     20|    pub fn bridge_star_partition_mt<V: StT + Hash + Ord + Send + Sync + 'static>(
  134|      3|        pub fn push_back(&mut self, value: T) {
  134|     80|        pub fn vertex_degree(&self, v: &V) -> usize { self.neighbors(v).size() }
  135|      1|        pub fn edges_below_weight(&self, threshold: OrderedFloat<f64>) -> Set<(V, V, OrderedFloat<f64>)> {
  135|      1|    pub fn reachable<V: StT + Ord, G>(graph: &G, source: V) -> AVLTreeSetStPer<V>
  136|      1|        pub fn set_t(&mut self, t: ArraySeqStEphS<char>) { self.seq_t = t; }
  137|      1|        pub fn clear_memo(self) -> Self {
  137|      3|        pub fn partition(&self, parts: &Set<Set<T>>) -> B {
  138|      2|    pub fn shortcut_tour<V: StT + Hash + Ord>(euler_tour: &[V]) -> std::vec::Vec<V> {
  139|      5|        pub fn split(&self, pivot: &T) -> (Self, B, Self) {
  139|      5|        pub fn split(&self, pivot: &T) -> (Self, B, Self) {
  139|      6|        pub fn split(&self, pivot: &T) -> (Self, B, Self) {
  139|      6|        pub fn split(&self, pivot: &T) -> (Self, B, Self) {
  139|      7|        pub fn split(&self, pivot: &T) -> (Self, B, Self) {
  139|      7|        pub fn split(&self, pivot: &T) -> (Self, B, Self) {
  140|      0|        pub fn subseq(&self, start: N, length: N) -> &[T] {
  140|      1|        pub fn sizeA(&self) -> N { self.labeled_edges().size() }
  140|      1|    pub fn verify_textbook_examples() -> bool {
  141|      0|        pub fn set_t(&mut self, t: ArraySeqStEphS<char>) {
  141|      3|        pub fn contains_value(&self, target: &T) -> B
  142|      4|        pub fn new_minimal(hash_fn: H, c1: N, c2: N) -> Self {
  143|      1|        pub fn arcs(&self) -> Set<LabEdge<V, L>> { self.labeled_edges().clone() }
  144|     27|        pub fn analyze_double_hashing(&self, key: &str, table_size: N) -> ProbeSequenceVisualization {
  144|      2|        pub fn min_weight_edge(&self) -> Option<(V, V, OrderedFloat<f64>)> {
  145|    138|        pub fn equals(&mut self, u: &V, v: &V) -> B { self.find(u) == self.find(v) }
  145|      1|    pub fn performance_comparison() {
  146|      1|        pub fn min_weight_edge(&self) -> Option<(V, V, OrderedFloat<f64>)> {
  146|      1|        pub fn NPlus(&self, v: &V) -> Set<V> { self.neighbors(v) }
  148|      1|    pub fn tour_weight_mt<V: StT + MtT + Hash + Ord>(
  149|      1|        pub fn NMinus(&self, v: &V) -> Set<V> { self.neighbors(v) }
  149|      1|        pub fn subseq_copy(&self, start: N, length: N) -> ArraySeqS<T> {
  151|      1|    pub fn count_components_hof<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> N {
  151|      1|        pub fn insert_all(&self, elements: &ArraySeqStPerS<T>) -> Self {
  151|      4|        pub fn s_length(&self) -> usize { self.seq_s.length() }
  152|      2|        pub fn max_weight_edge(&self) -> Option<(V, V, OrderedFloat<f64>)> {
  152|      3|        pub fn InDegree(&self, v: &V) -> N { self.neighbors(v).size() }
  152|      4|        pub fn s_length(&self) -> usize { self.seq_s.length() }
  153|      1|        pub fn insert_value(&mut self, value: T) { self.push_back(value); }
  154|     17|        pub fn num_sets(&mut self) -> usize {
  154|      1|        pub fn max_weight_edge(&self) -> Option<(V, V, OrderedFloat<f64>)> {
  155|      1|        pub fn delete_value(&mut self, target: &T) -> bool
  155|     21|        pub fn analyze_secondary_clustering<V: StT>(
  155|      3|        pub fn OutDegree(&self, v: &V) -> N { self.neighbors(v).size() }
  155|      5|        pub fn CartesianProduct<U: StT + Hash + Clone>(&self, other: &Set<U>) -> Set<Pair<T, U>>
  156|      2|    pub fn exercise_47_2_size_reduction() -> String {
  156|      4|        pub fn t_length(&self) -> usize { self.seq_t.length() }
  157|     13|        pub fn all_results_match(&self) -> bool {
  157|      4|        pub fn t_length(&self) -> usize { self.seq_t.length() }
  159|    229|        pub fn lookup(&self, key: &K) -> Option<&V> {
  159|      2|        pub fn join_pair(left: Self, right: Self) -> Self {
  159|      3|        pub fn join_pair(left: Self, right: Self) -> Self {
  159|      3|        pub fn join_pair(left: Self, right: Self) -> Self {
  159|      3|        pub fn join_pair(left: Self, right: Self) -> Self {
  159|      3|        pub fn join_pair(left: Self, right: Self) -> Self {
  159|      5|        pub fn join_pair(left: Self, right: Self) -> Self {
  161|      2|        pub fn is_empty(&self) -> bool { self.seq_s.length() == 0usize && self.seq_t.length() == 0usize }
  161|      7|        pub fn extract_all_sorted(&self) -> ArraySeqStPerS<T> {
  161|      9|        pub fn new() -> Self {
  162|      0|        pub fn update(&mut self, (index, item): (N, T)) -> &mut ArraySeqS<T> {
  162|      1|        pub fn scale_weights(&mut self, factor: OrderedFloat<f64>) {
  162|      2|        pub fn is_empty(&self) -> bool { self.seq_s.length() == 0usize && self.seq_t.length() == 0usize }
  163|     33|    pub fn boruvka_mst<V: StT + Hash + Ord>(
  163|      4|    pub fn contract_to_vertices_mt<V: StT + MtT + Hash + Ord + 'static>(
   16|     38|        pub fn new(hash_fn: H) -> Self {
  165|      4|        pub fn memo_size(&self) -> usize {
  166|     13|        pub fn all_results_sorted(&self) -> bool {
  166|      2|        pub fn total_weight(&self) -> i32 { self.labeled_arcs().iter().map(|edge| edge.2).sum() }
  167|      0|        pub fn set_s(&mut self, s: ArraySeqMtEphS<char>) { self.seq_s = s; }
  167|      0|        pub fn with_memo_table(self, memo: HashMap<(usize, usize), usize>) -> Self {
  167|      1|    pub fn connected_components_hof<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> (Set<V>, HashMap<V, V>) {
  167|      2|    pub fn tour_weight<V: StT + Hash + Ord>(
  167|      4|        pub fn join_m(left: Self, pivot: T, right: Self) -> Self {
  167|      4|        pub fn join_m(left: Self, pivot: T, right: Self) -> Self {
  167|      4|        pub fn join_m(left: Self, pivot: T, right: Self) -> Self {
  167|      4|        pub fn join_m(left: Self, pivot: T, right: Self) -> Self {
  167|      5|        pub fn join_m(left: Self, pivot: T, right: Self) -> Self {
  167|      6|        pub fn join_m(left: Self, pivot: T, right: Self) -> Self {
  168|      0|    pub fn run_integer_example() {
  168|   212k|        pub fn insert(&mut self, x: T) -> &mut Self {
  168|      9|    pub fn mst_weight<V: StT + Hash>(mst_edges: &Set<LabEdge<V, OrderedFloat<f64>>>) -> OrderedFloat<f64> {
  170|      1|    pub fn contract_round_mt<V: StT + MtT + Hash + Ord + 'static>(
  172|      0|        pub fn set_t(&mut self, t: ArraySeqMtEphS<char>) { self.seq_t = t; }
  172|      2|    pub fn additional_set_operations() {
   17|     23|        pub fn new(hash1: H1, hash2: H2) -> Self {
  173|     16|        pub fn analyze_double_hashing<K: StT, H1: HashFunClone<K>, H2: HashFunClone<K>>(
  173|      1|        pub fn is_memoized(&self, i: usize, j: usize) -> bool {
  173|     26|        pub fn from_vec(elts: Vec<T>) -> ArraySeqS<T> {
  173|  78.1k|        pub fn iter(&self) -> std::collections::hash_set::Iter<'_, T> { self.data.iter() }
  174|     26|        pub fn estimate_unsuccessful_probe_count(&self, load_factor: f64) -> f64 {
  175|     23|        pub fn FromVec(v: Vec<T>) -> Set<T> {
  176|     13|        pub fn filter<F>(&self, mut predicate: F) -> Self
  176|      1|        pub fn total_weight(&self) -> OrderedFloat<f64> {
  176|      6|        pub fn filter<F>(&self, mut predicate: F) -> Self
  176|      6|        pub fn filter<F>(&self, mut predicate: F) -> Self
  176|      6|        pub fn filter<F>(&self, mut predicate: F) -> Self
  176|      7|        pub fn filter<F>(&self, mut predicate: F) -> Self
  176|      7|        pub fn filter<F>(&self, mut predicate: F) -> Self
  177|      0|        pub fn empty() -> Self {
  178|      4|        pub fn memo_size(&self) -> usize {
  179|      0|        pub fn iter(&self) -> std::slice::Iter<'_, T> { self.data.iter() }
  179|      0|        pub fn resize(&self, new_size: N) -> Self
  180|      1|    pub fn performance_comparison_demo() -> (N, N) {
  181|      0|        pub fn iter_mut(&mut self) -> std::slice::IterMut<'_, T> { self.data.iter_mut() }
  181|     10|        pub fn find_max(&self) -> Option<&T> {
  181|      1|        pub fn get_memoized(&self, i: usize, j: usize) -> Option<usize> {
   18|     18|        pub fn new(hash_fn: H, c1: N, c2: N) -> Self {
  183|      2|        pub fn is_tree_empty(&self) -> bool { self.length() == 0 }
  184|      2|        pub fn get_all_words(&self) -> ArraySeqStPerS<Word> {
  185|      1|        pub fn values_in_order(&self) -> Vec<T>
  185|     26|        pub fn estimate_successful_probe_count(&self, load_factor: f64) -> f64 {
  186|      1|        pub fn is_memoized(&self, i: usize, j: usize) -> bool {
  186|     22|        pub fn delete(&self, key: &K) -> (Self, bool) {
  186|      9|        pub fn resize(&self, new_size: N) -> Self {
  189|      0|        pub fn insert_memo(&mut self, i: usize, j: usize, value: usize) {
  189|      1|        pub fn new(hash1: H1, hash2: H2) -> Self {
  189|      4|        pub fn reduce<F>(&self, mut op: F, base: T) -> T
  189|      4|        pub fn reduce<F>(&self, mut op: F, base: T) -> T
  189|      4|        pub fn reduce<F>(&self, mut op: F, base: T) -> T
  189|      4|        pub fn reduce<F>(&self, mut op: F, base: T) -> T
  189|      5|        pub fn reduce<F>(&self, mut op: F, base: T) -> T
  189|      9|        pub fn reduce<F>(&self, mut op: F, base: T) -> T
  190|      1|        pub fn sizeA(&self) -> N { self.labeled_edges().size() }
  190|      3|        pub fn delete_max(&self) -> (Self, Option<T>) {
  191|      2|        pub fn sizeA(&self) -> N { self.sizeE() }
   19|   238k|        pub fn from_vec(elts: Vec<T>) -> Self {
  193|      1|        pub fn arcs(&self) -> Set<LabEdge<V, L>> { self.labeled_edges().clone() }
  193|      1|    pub fn exercise_47_3_resize_implementation() -> String {
   19|      3|    pub fn all_contiguous_subseqs<T: StT>(a: &ArraySeqStPerS<T>) -> ArraySeqStPerS<ArraySeqStPerS<T>> {
  194|      1|        pub fn get_memoized(&self, i: usize, j: usize) -> Option<usize> {
  194|      1|    pub fn tokenization_demo() -> ArraySeqStPerS<Word> {
  194|      3|        pub fn arcs(&self) -> &Set<Edge<V>> { self.edges() }
   19|  4.88k|        pub fn from_vec(elts: Vec<T>) -> Self {
  196|      1|        pub fn NPlus(&self, v: &V) -> Set<V> { self.neighbors(v) }
  197|      1|        pub fn NPlus(&self, v: &V) -> Set<V> { self.NG(v) }
  197|      4|        pub fn s_length(&self) -> usize { self.seq_s.length() }
  198|      2|    pub fn textbook_example() -> HeapsortComparison<i32> {
  198|      2|        pub fn validate_configuration(&self, key: &K, table_size: N) -> (B, String) {
  198|      8|        pub fn word_count(&self) -> N { self.word_to_docs.size() }
  199|     13|        pub fn iter_in_order(&self) -> ArraySeqStPerS<T> { self.tree.in_order() }
  199|      1|        pub fn NMinus(&self, v: &V) -> Set<V> { self.neighbors(v) }
  199|      3|        pub fn probe_hash(&self, key: &K, probe_index: N, table_size: N) -> N {
  199|      4|        pub fn iter_in_order(&self) -> ArraySeqStPerS<T> { self.tree.in_order() }
  199|      4|        pub fn iter_in_order(&self) -> ArraySeqStPerS<T> { self.tree.in_order() }
  199|      4|        pub fn iter_in_order(&self) -> ArraySeqStPerS<T> { self.tree.in_order() }
  199|      4|        pub fn iter_in_order(&self) -> ArraySeqStPerS<T> { self.tree.in_order() }
  199|      5|        pub fn iter_in_order(&self) -> ArraySeqStPerS<T> { self.tree.in_order() }
  200|      1|    pub fn index_statistics() -> (N, N, N) {
  200|      1|        pub fn NMinus(&self, v: &V) -> Set<V> { self.NG(v) }
  200|      4|        pub fn is_clustering_problematic(&self, load_factor: f64) -> B {
  201|      0|        pub fn insert_all(&self, elements: &ArraySeqStPerS<T>) -> Self {
  201|      1|        pub fn as_tree(&self) -> &BSTAVLMtEph<T> { &self.tree }
  201|      1|        pub fn as_tree(&self) -> &BSTBBAlphaMtEph<T> { &self.tree }
  201|      1|        pub fn as_tree(&self) -> &BSTPlainMtEph<T> { &self.tree }
  201|      1|        pub fn as_tree(&self) -> &BSTRBMtEph<T> { &self.tree }
  201|      1|        pub fn as_tree(&self) -> &BSTSplayMtEph<T> { &self.tree }
  201|      1|        pub fn as_tree(&self) -> &BSTTreapMtEph<T> { &self.tree }
  202|      1|        pub fn InDegree(&self, v: &V) -> N { self.neighbors(v).size() }
   20|     23|        pub fn from_weighted_edges(vertices: Set<V>, edges: Set<(V, V, i32)>) -> Self {
  202|      4|        pub fn s_length(&self) -> usize { self.seq_s.length() }
  202|      4|        pub fn t_length(&self) -> usize { self.seq_t.length() }
   20|     31|    pub fn is_divisible(n: N, i: N) -> B { if n % i == 0 { true } else { false } }
  203|    269|    pub fn tokens(content: &Contents) -> ArraySeqStPerS<Word> {
  203|      2|        pub fn NPlusOfVertices(&self, u_set: &Set<V>) -> Set<V> { self.NGOfVertices(u_set) }
  204|      2|    pub fn reverse_sorted_example() -> HeapsortComparison<i32> {
  205|     12|        pub fn compare_probing_strategies(&self, key: &str, table_size: N) -> Vec<ProbeSequenceVisualization> {
  205|      1|        pub fn OutDegree(&self, v: &V) -> N { self.neighbors(v).size() }
  206|      2|        pub fn NMinusOfVertices(&self, u_set: &Set<V>) -> Set<V> { self.NGOfVertices(u_set) }
   20|     65|        pub fn from_weighted_edges(vertices: Set<V>, edges: Set<(V, V, i32)>) -> Self {
   20|      6|    pub fn dfs(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>, source: N) -> AVLTreeSetStEph<N> {
  207|      1|    pub fn approx_metric_tsp_mt<V: StT + MtT + Hash + Ord + 'static>(
  207|      2|        pub fn is_empty(&self) -> bool { self.seq_s.length() == 0usize && self.seq_t.length() == 0usize }
  207|      4|        pub fn t_length(&self) -> usize { self.seq_t.length() }
   20|      7|    pub fn dfs(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>, source: N) -> AVLTreeSetStPer<N> {
   20|      7|    pub fn has_cycle(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>) -> B {
   20|      7|    pub fn has_cycle(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>) -> B {
   20|      7|    pub fn topological_sort_opt(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>) -> Option<AVLTreeSeqStEphS<N>> {
  209|      1|    pub fn count_components_hof<V: StT + MtT + Hash + Ord + 'static>(graph: &UnDirGraphMtEph<V>, seed: u64) -> N {
  209|      2|        pub fn InDegree(&self, v: &V) -> N { self.Degree(v) }
  210|      1|        pub fn insert_all(&self, elements: &AVLTreeSeqStPerS<T>) -> Self {
  210|      2|    pub fn already_sorted_example() -> HeapsortComparison<i32> {
   21|      0|    pub fn points2d(n: N) -> ArraySeqStPerS<Pair<N, N>> {
  211|      0|        pub fn extract_all_sorted(&self) -> ArraySeqStPerS<T> { self.elements.clone() }
   21|    113|        pub fn empty() -> Self {
  211|     14|        pub fn compare_probing_strategies(&self, table_size: N, load_factor: f64) -> ClusteringComparison {
   21|     16|    pub fn prime_sieve(n: N) -> ArraySeqStPerS<N> {
  212|      1|        pub fn clear_memo(&mut self) {
  212|      2|        pub fn is_empty(&self) -> bool { self.seq_s.length() == 0usize && self.seq_t.length() == 0usize }
  212|      2|        pub fn OutDegree(&self, v: &V) -> N { self.Degree(v) }
  212|     36|        pub fn estimate_probe_count(&self, load_factor: f64, is_successful: B) -> f64 {
   21|    259|        pub fn second_hash<Key: StT>(key: &Key, table_size: N) -> N {
   21|     25|        pub fn empty() -> Self {
   21|      2|        pub fn create_table(initial_size: N) -> Self {
  214|      0|        pub fn find_max(&self) -> Option<&T> {
  215|    153|        pub fn new(max_load: f64, min_load: f64) -> Self {
   21|      5|    pub fn points2d_tab_flat(n: N) -> ArraySeqStPerS<Pair<N, N>> {
  216|      2|    pub fn duplicates_example() -> HeapsortComparison<i32> {
  217|      1|        pub fn clear_memo(self) -> Self {
   21|      7|    pub fn scc(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>) -> AVLTreeSeqStEphS<AVLTreeSetStEph<N>> {
   21|      7|    pub fn scc(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>) -> AVLTreeSeqStPerS<AVLTreeSetStPer<N>> {
   21|      7|    pub fn topological_sort_opt(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>) -> Option<AVLTreeSeqStPerS<N>> {
  219|      2|        pub fn from_vec(vec: Vec<T>) -> Self {
  220|      0|        pub fn set_s(&mut self, s: ArraySeqMtEphS<char>) {
  220|      1|        pub fn extract_all_sorted(&self) -> AVLTreeSeqStPerS<T> { self.elements.clone() }
   22|      0|    pub fn points3d_loops(n: N) -> ArraySeqStPerS<Pair<N, Pair<N, N>>> {
   22|     20|    pub fn create_tweet_index() -> DocumentIndex {
  222|      2|    pub fn single_element_example() -> HeapsortComparison<i32> {
  223|      0|    pub fn connected_components_hof<V: StT + MtT + Hash + Ord + 'static>(
  223|      0|        pub fn delete_max(&self) -> (Self, Option<T>) {
  223|     13|        pub fn contains(&self, element: &T) -> bool {
  223|    706|        pub fn load_factor(&self, num_elements: N, table_size: N) -> f64 {
  223|      8|    pub fn boruvka_mst_with_seed<V: StT + Hash + Ord>(
   22|      5|    pub fn points3d_tab_flat(n: N) -> ArraySeqStPerS<Pair<N, Pair<N, N>>> {
   22|      7|    pub fn run_example43_1() {
  228|      0|        pub fn set_t(&mut self, t: ArraySeqMtEphS<char>) {
  228|     29|    pub fn boruvka_mst_mt<V: StT + Hash + Ord + Send + Sync + 'static>(
  228|      2|    pub fn empty_example() -> HeapsortComparison<i32> {
  228|      3|        pub fn to_vec(&self) -> Vec<T> {
  229|      1|    pub fn exercise_47_6_higher_order() -> String {
  231|      0|    pub fn create_finder(index: &DocumentIndex) -> impl Fn(&Word) -> DocumentSet + '_ {
  232|      1|        pub fn is_configuration_optimal(&self, metrics: &DoubleHashingMetrics, table_size: N) -> B {
  232|    693|        pub fn should_grow(&self, num_elements: N, table_size: N) -> bool {
  233|      1|    pub fn approx_metric_tsp<V: StT + Hash + Ord>(
  234|      4|    pub fn large_example(size: usize) -> Vec<i32> {
   23|      5|    pub fn primes_bf(n: N) -> ArraySeqStPerS<N> {
  236|      7|    pub fn mst_weight<V: StT + Hash>(edges: &Set<LabeledEdge<V>>, mst_labels: &Set<usize>) -> OrderedFloat<f64> {
  237|     21|        pub fn should_shrink(&self, num_elements: N, table_size: N) -> bool {
  237|      3|        pub fn to_sorted_vec(&self) -> Vec<T> {
   23|      7|        pub fn empty() -> Self { LinkedListStEphS { head: None, len: 0 } }
  238|      3|        pub fn remove(&self, element: &T) -> (Self, bool) {
  241|     29|        pub fn get_hash_values(&self, key: &K, table_size: N) -> (N, N) {
   24|     13|        pub fn from_weighted_edges(vertices: Set<V>, edges: Set<(V, V, i32)>) -> Self {
  241|      5|        pub fn to_arrayseq(&self) -> ArraySeqStPerS<T> {
   24|     16|        pub fn from_weighted_edges(vertices: Set<V>, edges: Set<(V, V, OrderedFloat<f64>)>) -> Self {
   24|      1|    pub fn example_42_1() {
  242|     25|        pub fn resize(&self, new_size: N) -> Self {
  243|      1|    pub fn example_primary_clustering_analysis() -> (PrimaryClusteringMetrics, f64, f64) {
  243|     33|        pub fn grow_size(&self, current_size: N) -> N { current_size * 2 }
  243|      4|        pub fn validate_configuration(&self, table_size: N) -> (B, String) {
   24|     38|        pub fn new(length: N, init_value: T) -> Self { Self::from_vec(vec![init_value; length]) }
   24|      5|    pub fn is_even(x: &N) -> B { if *x % 2 == 0 { true } else { false } }
  246|      1|    pub fn efficiency_demonstration() -> Vec<(String, Vec<i32>)> {
  246|      1|        pub fn iter<'a>(&'a self) -> AVLTreeSeqStPerIter<'a, T> {
  246|      3|        pub fn shrink_size(&self, current_size: N) -> N { (current_size / 2).max(8) }
   24|      7|    pub fn bfs(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>, source: N) -> ArraySeqStEphS<N> {
   24|      7|    pub fn bfs(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>, source: N) -> ArraySeqStPerS<N> {
   24|      7|        pub fn from_weighted_edges(vertices: Set<V>, edges: Set<(V, V, i32)>) -> Self {
   24|      7|        pub fn from_weighted_edges(vertices: Set<V>, edges: Set<(V, V, OrderedFloat<f64>)>) -> Self {
  249|      0|        pub fn load_and_size(&self) -> (N, N) { (self.num_elements, self.buckets.length()) }
  249|     29|        pub fn generate_probe_sequence(&self, key: &K, table_size: N, max_probes: N) -> Vec<N> {
  251|     12|        pub fn load_and_size(&self) -> (N, N) { (self.num_elements, self.buckets.length()) }
  251|      2|        pub fn size(&self) -> N { self.num_elements }
   25|      1|        pub fn new(length: N, init_value: T) -> Self
  252|      2|    pub fn example_47_4_linear_probing_clustering() -> TextbookExampleResults {
   25|    254|        pub fn new(length: N, init_value: T) -> Self { Self::from_vec(vec![init_value; length]) }
  253|      0|        pub fn is_empty(&self) -> bool { self.num_elements == 0 }
  253|      3|        pub fn recommend_table_size(&self, capacity: N) -> N {
  253|      9|        pub fn statistics(&self) -> HashTableStats {
   25|  4.59k|        pub fn empty() -> Self { Self::from_vec(Vec::new()) }
  255|      0|        pub fn load_factor(&self) -> f64 {
   25|      7|    pub fn bfs(graph: &ArraySeqMtEphS<ArraySeqMtEphS<N>>, source: N) -> ArraySeqMtEphS<N> {
   25|      7|    pub fn bfs(graph: &ArraySeqMtPerS<ArraySeqMtPerS<N>>, source: N) -> ArraySeqMtPerS<N> {
  258|      2|        pub fn range(&self, min_val: &T, max_val: &T) -> AVLTreeSeqStPerS<T> {
  260|      0|        pub fn statistics(&self) -> HashTableStats {
  261|     16|        pub fn new(num_elements: N, table_size: N) -> Self {
   26|  2.38k|    pub fn fib(n: N) -> N {
   26|     26|        pub fn new() -> Self { ChainList { head: None } }
   26|      2|    pub fn example_41_1_array_set() {
  265|      1|    pub fn complexity_analysis() -> Vec<(String, String, String)> {
   26|  63.2k|        pub fn singleton(item: T) -> Self { Self::from_vec(vec![item]) }
  266|     46|        pub fn estimate_probe_count(&self, load_factor: f64, is_successful: B) -> f64 {
  270|      1|    pub fn exercise_47_7_complete_implementation() -> String {
   27|     13|        pub fn new(f: F) -> Self {
   27|      1|    pub fn example_negative_cycle() {
   27|    348|        pub fn empty() -> Self { Self::from_vec(Vec::new()) }
   27|     36|        pub fn new(length: N, init_value: T) -> Self {
   27|     49|        pub fn new(length: N, init_value: T) -> Self
  275|   117M|    pub(crate) fn insert_at_link<T: StT>(node: Link<T>, index: N, value: T, next_key: &mut N) -> Link<T> {
  275|      1|        pub fn insert_all(&self, elements: &ArraySeqStPerS<T>) -> Self {
   27|   583k|        pub fn length(&self) -> N { self.data.len() }
   27|      5|    pub fn is_vowel(c: &char) -> B {
  277|     16|        pub fn with_collision_stats(mut self, collisions: N, max_chain: N, avg_chain: f64) -> Self {
   28|     13|        pub fn standard(hash_fn: H) -> Self { Self::new(hash_fn, 1, 1) }
  281|      4|    pub fn ArraySeqSetEq<T: PartialEq>(a_len: N, a_nth: fn(N) -> T, b_len: N, b_nth: fn(N) -> T) -> bool {
   28|  3.56M|        pub fn nth(&self, index: N) -> &T { &self.data[index] }
  285|      0|        pub fn from_vec(vec: Vec<T>) -> Self {
  285|      3|        pub fn extract_all_sorted(&self) -> ArraySeqStPerS<T> {
  286|      2|    pub fn example_47_5_quadratic_probing_prime_table() -> TextbookExampleResults {
  286|      3|        pub fn is_secondary_clustering_problematic(&self, metrics: &SecondaryClusteringMetrics) -> B {
  288|      2|        pub fn new(index: &'a DocumentIndex) -> Self { QueryBuilder { index } }
  289|      8|    pub fn from_sorted_elements<T: StT + Ord>(elements: Vec<T>) -> OrderedSetStPer<T> {
  290|     11|        pub fn find(&self, word: &Word) -> DocumentSet { self.index.find(word) }
  290|     24|    pub fn from_sorted_entries<K: StT + Ord, V: StT>(entries: Vec<Pair<K, V>>) -> TableStEph<K, V> {
   29|   100k|        pub fn subseq_copy(&self, start: N, length: N) -> Self {
  292|      2|        pub fn get_coefficients(&self) -> (N, N) { (self.c1, self.c2) }
  292|      3|        pub fn and(&self, docs_a: DocumentSet, docs_b: DocumentSet) -> DocumentSet {
   29|    280|        pub fn singleton(item: T) -> Self { Self::from_vec(vec![item]) }
  293|      5|    pub fn create_example_47_2_table() -> StringSeparateChaining<String> {
  294|      0|        pub fn to_vec(&self) -> Vec<T> {
  296|      1|    pub fn correctness_verification() -> bool {
  296|      2|        pub fn or(&self, docs_a: DocumentSet, docs_b: DocumentSet) -> DocumentSet {
  300|      2|        pub fn and_not(&self, docs_a: DocumentSet, docs_b: DocumentSet) -> DocumentSet {
  301|      2|        pub fn extract_all_sorted(&self) -> Vec<T> {
   30|     18|    pub fn is_prime(n: N) -> B {
   30|      1|    pub fn create_tweet_finder() -> impl Fn(&Word) -> DocumentSet {
   30|      1|    pub fn example_path_weight_int() {
  302|     28|        pub fn is_valid_heap(&self) -> bool { self.is_heap() }
  303|      0|        pub fn to_sorted_vec(&self) -> Vec<T> {
   30|      4|        pub fn new() -> Self {
  305|      2|        pub fn complex_query(&self, word1: &Word, word2: &Word, word3: &Word, word4: &Word) -> DocumentSet {
  305|      3|        pub fn height(&self) -> N {
  305|      4|        pub fn next_prime(n: N) -> N {
  308|      1|    pub fn run_all_examples() -> String {
  309|      0|        pub fn is_sorted(&self) -> bool {
   31|      0|    pub fn cartesian_loops(
   31|  11.7k|        pub fn length(&self) -> N { self.data.len() }
  311|      1|    pub fn example_double_hashing_analysis() -> (DoubleHashingMetrics, f64, f64, (B, String)) {
  311|      1|    pub fn from_sorted_elements<T: StT + Ord>(elements: Vec<T>) -> OrderedSetStEph<T> {
   31|     13|        pub fn new(f: F) -> Self {
  314|      2|        pub fn level_elements(&self, level: N) -> ArraySeqStPerS<T> {
  316|      1|        pub fn from_vec(vec: Vec<T>) -> Self {
  317|      4|        pub fn height(&self) -> N { self.root.height() }
  318|     11|        pub fn is_prime(n: N) -> bool {
  320|      2|        pub fn root_rank(&self) -> N { self.root.rank() }
   32|      0|        pub fn singleton(item: T) -> Self { LinkedListStEphS::from_vec(vec![item]) }
  321|      2|    pub fn example_47_6_double_hashing_optimal() -> TextbookExampleResults {
  322|    460|        pub fn load_and_size(&self) -> (N, N) { (self.num_elements, self.table.length()) }
  323|     27|        pub fn is_valid_leftist_heap(&self) -> bool { self.root.is_leftist() && self.root.is_heap() }
  324|      1|    pub fn vec_to_array_seq<T: StT>(vec: &[T]) -> ArraySeqStPerS<T> {
  324|      5|        pub fn statistics(&self) -> HashTableStats {
  324|      9|    pub fn boruvka_mst_mt_with_seed<V: StT + Hash + Ord + Send + Sync + 'static>(
  325|      2|        pub fn to_vec(&self) -> Vec<T> {
  326|      1|        pub fn from_vec(vec: Vec<T>) -> Self { Self::from_seq(&vec) }
  326|     27|    pub fn from_sorted_entries<K: StT + Ord, V: StT>(entries: Vec<Pair<K, V>>) -> TableStPer<K, V> {
  329|      2|        pub fn to_vec(&self) -> Vec<T> { self.root.to_vec() }
  329|      8|        pub fn probe_statistics(&self) -> (N, N, f64) {
  332|      0|    pub fn create_string_nested_hash_table<V: StT>(initial_size: N) -> StringNestedHashTable<V> {
  332|      1|        pub fn to_sorted_vec(&self) -> Vec<T> { self.extract_all_sorted() }
   33|    285|        pub fn new(value: f64) -> Self {
  334|      1|        pub fn to_sorted_vec(&self) -> Vec<T> {
  334|      1|    pub fn vec_to_avl_seq<T: StT>(vec: &[T]) -> AVLTreeSeqStPerS<T> { AVLTreeSeqStPerS::from_vec(vec.to_vec()) }
  335|      1|    pub fn example_probe_sequence_analysis() -> (Vec<N>, DoubleHashingMetrics, Vec<N>) {
  335|      2|        pub fn meld_multiple(heaps: &[Self]) -> Self {
   33|   580k|        pub fn nth(&self, index: N) -> &T { &self.data[index] }
   33|     66|        pub fn new(hash_fn: H) -> Self {
  337|      0|    pub fn create_integer_nested_hash_table<V: StT>(initial_size: N) -> IntegerNestedHashTable<V> {
  337|      9|    pub fn is_sorted<T: Ord>(vec: &[T]) -> bool { vec.windows(2).all(|w| w[0] <= w[1]) }
   33|      7|        pub fn new(f: F) -> Self {
  338|      1|    pub fn example_secondary_clustering_analysis() -> (SecondaryClusteringMetrics, f64, f64, (B, String)) {
  339|      2|        pub fn good_table_size(desired_size: N, use_prime: bool) -> N {
  339|      8|    pub fn mst_weight<V: StT + Hash>(edges: &Set<LabeledEdge<V>>, mst_labels: &Set<usize>) -> OrderedFloat<f64> {
  340|      1|    pub fn generate_test_sequences(size: usize) -> Vec<(String, Vec<i32>)> {
  340|      2|        pub fn is_sorted(&self) -> bool {
   34|    136|        pub fn from_vec(mut elts: Vec<T>) -> Self {
   34|     22|        pub fn singleton(item: T) -> Self { ArraySeqMtEphS::from_vec(vec![item]) }
   34|     24|        pub fn create_table(eq_fn: E, hash_fn: H, initial_size: N) -> Self {
   34|      5|    pub fn example_47_1_hash_function() -> StringPositionHashFunction { StringPositionHashFunction }
  348|      1|        pub fn split(&self, value: &T) -> (Self, Self) {
  351|     22|    pub fn from_sorted_entries<K: StT + Ord, V: StT>(entries: AVLTreeSeqStPerS<Pair<K, V>>) -> OrderedTableStPer<K, V> {
  352|      4|        pub fn height(&self) -> N {
  355|      2|    pub fn comprehensive_probe_sequence_comparison() -> TextbookExampleResults {
   35|     64|        pub fn singleton(item: T) -> Self { ArraySeqMtPerS::from_vec(vec![item]) }
   36|     14|        pub fn new(s: ArraySeqStEphS<char>, t: ArraySeqStEphS<char>) -> Self { BottomUpDPStEphS { seq_s: s, seq_t: t } }
   36|     17|        pub fn new(s: ArraySeqStPerS<char>, t: ArraySeqStPerS<char>) -> Self { BottomUpDPStPerS { seq_s: s, seq_t: t } }
  362|      1|    pub fn example_prime_vs_composite_table_size() -> (SecondaryClusteringMetrics, SecondaryClusteringMetrics) {
   36|  22.6k|        pub fn from_vec(values: Vec<T>) -> Self {
  367|     21|    pub fn from_sorted_entries<K: StT + Ord, V: StT>(entries: AVLTreeSeqStPerS<Pair<K, V>>) -> OrderedTableStEph<K, V> {
  367|      2|        pub fn split(&self, element: &T) -> (Self, bool, Self) {
   36|     96|        pub fn iter(&self) -> std::slice::Iter<'_, T> { self.data.iter() }
  372|      1|        pub fn from_vec(vec: Vec<T>) -> Self {
   37|      2|        pub fn add_weighted_edge(&mut self, from: V, to: V, weight: i32) { self.add_labeled_arc(from, to, weight); }
   37|      2|    pub fn example_47_1_demonstration() -> Vec<(String, N)> {
   37|  4.08k|        pub fn from_vec(values: Vec<T>) -> Self {
   37|      5|    pub fn fetch_add_cas(target: &AtomicUsize, delta: usize) -> usize { target.fetch_add_cas(delta) }
   37|     60|        pub fn add_weighted_edge(&mut self, v1: V, v2: V, weight: i32) { self.add_labeled_edge(v1, v2, weight); }
   38|      0|    pub fn topo_sort(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>) -> AVLTreeSeqStEphS<N> {
   38|    110|        pub fn subseq(&self, start: N, length: N) -> Self {
   38|     12|        pub fn new(s: ArraySeqMtEphS<char>, t: ArraySeqMtEphS<char>) -> Self { BottomUpDPMtEphS { seq_s: s, seq_t: t } }
   38|     13|        pub fn new(s: ArraySeqMtPerS<char>, t: ArraySeqMtPerS<char>) -> Self { BottomUpDPMtPerS { seq_s: s, seq_t: t } }
   38|     16|        pub fn new(s: ArraySeqStEphS<char>, t: ArraySeqStEphS<char>) -> Self {
   38|     16|        pub fn new(s: ArraySeqStPerS<char>, t: ArraySeqStPerS<char>) -> Self {
  382|      1|        pub fn to_vec(&self) -> Vec<T> {
  387|      1|        pub fn test_distribution<K, H: HashFunction<K>>(hash_fn: &H, keys: &[K], table_size: N) -> HashTableStats {
   38|    741|        pub fn iter(&self) -> std::slice::Iter<'_, T> { self.data.iter() }
  388|      1|        pub fn join(left: &Self, right: &Self) -> Self { left.meld(right) }
  388|      2|    pub fn load_factor_impact_analysis() -> Vec<(f64, Vec<ProbeSequenceVisualization>)> {
  388|     59|    pub(crate) fn insert_at_link<T: Copy + Debug>(node: Link<T>, index: N, value: T, next_key: &mut N) -> Link<T> {
   39|     11|    pub fn create_linear_probing_string_table<V: StT>(
  391|      1|        pub fn to_sorted_vec(&self) -> Vec<T> {
  391|      2|        pub fn filter<F>(&self, predicate: F) -> Self
   39|      1|    pub fn efficiency_note() -> &'static str {
  395|     36|    pub fn from_sorted_entries<K: MtKey, V: MtVal>(entries: AVLTreeSeqStPerS<Pair<K, V>>) -> OrderedTableMtEph<K, V> {
   39|      7|        pub fn new(f: F) -> Self {
   40|     16|        pub fn new(s: ArraySeqMtEphS<char>, t: ArraySeqMtEphS<char>) -> Self {
   40|     16|        pub fn new(s: ArraySeqMtPerS<char>, t: ArraySeqMtPerS<char>) -> Self {
   40|      2|        pub fn insert(&self, key: K, value: V) -> Self
   40|      2|    pub fn pair_even_with_vowels(a: &ArraySeqStPerS<N>, b: &ArraySeqStPerS<char>) -> ArraySeqStPerS<Pair<N, char>> {
   40|     30|    pub fn sequential_star_partition<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> (Set<V>, HashMap<V, V>) {
   40|      3|        pub fn med_bottom_up(&mut self) -> usize {
   40|      4|    pub fn greedy_matching<V: StT + Hash>(graph: &UnDirGraphStEph<V>) -> Set<Edge<V>> {
  406|      2|    pub fn prime_vs_composite_table_comparison() -> (TextbookExampleResults, TextbookExampleResults) {
   40|      6|        pub fn med_bottom_up(&self) -> usize {
  407|      1|        pub fn benchmark_hash_function<K, H: HashFunction<K>>(
  408|      2|        pub fn map<U, F>(&self, f: F) -> BalancedTreePQ<U>
   41|      0|        pub fn add_weighted_edge(&mut self, from: V, to: V, weight: i32) { self.add_labeled_arc(from, to, weight); }
   41|      0|        pub fn add_weighted_edge(&mut self, from: V, to: V, weight: OrderedFloat<f64>) {
   41|      1|        pub fn add_weighted_edge(&mut self, v1: V, v2: V, weight: i32) { self.add_labeled_edge(v1, v2, weight); }
   41|      1|        pub fn add_weighted_edge(&mut self, v1: V, v2: V, weight: OrderedFloat<f64>) {
   41|    436|        pub fn gcd(a: N, b: N) -> N {
   41|  4.51k|        pub fn lock(&self) {
  418|      0|    pub fn efficient_multi_way_merge<T: StT + Ord>(sequences: Vec<Vec<T>>) -> Vec<T> {
   42|     14|        pub fn new() -> Self {
   42|     16|        pub fn get_edge_weight(&self, v1: &V, v2: &V) -> Option<i32> { self.get_edge_label(v1, v2).copied() }
   42|      1|    pub fn spanning_tree_star_contraction_mt<V: StT + MtT + Hash + Ord + 'static>(
   42|  2.62M|        pub fn length(&self) -> N {
   42|      3|        pub fn med_bottom_up_parallel(&mut self) -> usize {
   42|      4|        pub fn med_bottom_up_parallel(&self) -> usize {
   42|     54|        pub fn value(&self) -> f64 { self.0 }
   42|     76|        pub fn is_prime(n: N) -> B {
   42|      8|        pub fn get_edge_weight(&self, from: &V, to: &V) -> Option<i32> { self.get_arc_label(from, to).copied() }
  430|      0|    pub fn parallel_heap_construction<T: StT + Ord>(elements: Vec<T>) -> LeftistHeapPQ<T> {
   43|    149|        pub fn length(&self) -> N { self.len }
   43|      2|        pub fn new_without_clustering(hash_fn: H) -> Self {
   43|     50|    pub fn parallel_star_partition<V: StT + MtT + Hash + Ord + 'static>(
   43|  7.49k|        pub fn length(&self) -> N { self.data.len() }
   44|      0|    pub fn topo_sort(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>) -> AVLTreeSeqStPerS<N> {
   44|     14|    pub fn heapsort_unsorted_list<T: StT + Ord>(sequence: &[T]) -> Vec<T> {
   44|      4|    pub fn parallel_matching_mt<V: StT + MtT + Hash + 'static>(graph: &UnDirGraphMtEph<V>, seed: u64) -> Set<Edge<V>> {
   45|  1.22k|        pub fn set(&mut self, index: N, item: T) -> Result<&mut Self, &'static str> {
   45|  20.1k|        pub fn nth(&self, index: N) -> &T { &self.data[index] }
   45|    240|        pub fn nth(&self, index: N) -> &T {
  453|      1|    pub fn example_comprehensive_clustering_analysis() -> ClusteringComparison {
   46|      1|    pub fn example_path_weight_float() {
   46|      1|        pub fn get_edge_weight(&self, from: &V, to: &V) -> Option<i32> { self.get_arc_label(from, to).copied() }
  463|      1|    pub fn example_load_factor_impact_analysis() -> Vec<(f64, ClusteringComparison)> {
   46|      4|        pub fn get_edge_weight(&self, v1: &V, v2: &V) -> Option<i32> { self.get_edge_label(v1, v2).copied() }
   47|      0|    pub fn example_45_2_textbook_example() -> HeapsortComparison<i32> {
   47|     10|        pub fn new() -> Self { StackStEph { elements: Vec::new() } }
   47|      1|        pub fn weighted_edges(&self) -> Set<(V, V, i32)> {
   47|    203|        pub fn infinity() -> Self { Probability(f64::INFINITY) }
   47|      2|    pub fn create_linear_probing_integer_table<V: StT>(
   47|      3|    pub fn edge_contract<V: StT + Hash + Ord>(
   47|      4|        pub fn weighted_edges(&self) -> Set<(V, V, i32)> {
   47|  5.25M|        pub fn nth_cloned(&self, index: N) -> T {
   47|    885|        pub fn subseq_copy(&self, start: N, length: N) -> Self {
   48|      1|        pub fn get_edge_weight(&self, from: &V, to: &V) -> Option<OrderedFloat<f64>> {
   48|     23|        pub fn from_weighted_edges(vertices: Set<V>, edges: Set<(V, V, OrderedFloat<f64>)>) -> Self {
   48|     25|    pub fn star_contract<V, R, F, G>(graph: &UnDirGraphStEph<V>, base: &F, expand: &G) -> R
   48|      3|        pub fn med_memoized(&mut self) -> usize {
   48|      3|        pub fn med_memoized(&self) -> usize {
   48|      4|        pub fn get_edge_weight(&self, v1: &V, v2: &V) -> Option<OrderedFloat<f64>> {
   48|     56|        pub fn from_weighted_edges(vertices: Set<V>, edges: Set<(V, V, OrderedFloat<f64>)>) -> Self {
   48|      5|    pub fn johnson_apsp(graph: &WeightedDirGraphStEphInt<usize>) -> AllPairsResultStEphInt {
   48|      5|    pub fn spanning_tree_star_contraction<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> Set<Edge<V>> {
   49|      5|    pub fn johnson_apsp(graph: &WeightedDirGraphStEphFloat<usize>) -> AllPairsResultStEphFloat {
   50|      0|    pub fn cartesian_tab_flat(
   50|    126|        pub fn create_table(probe_seq: P, initial_size: N) -> Self {
   50|     20|    pub fn bellman_ford(
   50|     20|    pub fn bellman_ford(graph: &WeightedDirGraphStEphInt<usize>, source: usize) -> Result<SSSPResultStEphInt, String> {
   50|     21|        pub fn new() -> Self {
   50|      2|        pub fn med_memoized_concurrent(&mut self) -> usize {
   50|      2|        pub fn med_memoized_concurrent(&self) -> usize {
   51|     19|        pub fn set(&mut self, index: N, item: T) -> Result<&mut Self, &'static str> {
   51|      1|        pub fn weighted_edges(&self) -> Set<(V, V, i32)> {
   51|      1|        pub fn weighted_edges(&self) -> Set<(V, V, i32)> {
   51|     28|        pub fn push(&mut self, item: T) { self.elements.push(item); }
   51|    478|        pub fn leaf() -> Self { BalBinTree::Leaf }
   51|     47|        pub fn are_relatively_prime(a: N, b: N) -> B { Self::gcd(a, b) == 1 }
   51|      5|        pub fn new(n: usize) -> Self {
   51|      5|        pub fn new(n: usize, source: usize) -> Self {
   51|      7|        pub fn search_fun(&self) -> DocumentSet { (self.fw)(&"fun".to_string()) }
   52|     11|    pub fn create_double_hashing_string_table<V: StT>(
   52|     23|        pub fn new() -> Self {
   52|  4.51k|        pub fn unlock(&self) { self.turn.fetch_add(1, Ordering::Release); }
   52|    531|        pub fn zero() -> Self { Probability(0.0) }
   52|      5|        pub fn new(n: usize) -> Self {
   52|     61|        pub fn new(n: usize, source: usize) -> Self {
   52|     76|        pub fn set(&mut self, index: N, item: T) -> Result<&mut Self, &'static str> {
   53|     22|        pub fn analyze_primary_clustering<V: StT>(&self, table: &FlatHashTable<K, V, Self>) -> PrimaryClusteringMetrics
   53|    242|        pub fn node(left: BalBinTree<T>, value: T, right: BalBinTree<T>) -> Self {
   53|     29|    pub fn star_contract_mt<V, R, F, G>(graph: &UnDirGraphMtEph<V>, seed: u64, base: &F, expand: &G) -> R
   53|      5|        pub fn new(n: usize) -> Self {
   54|      0|    pub fn example_45_2_reverse_sorted() -> HeapsortComparison<i32> {
   54|     10|    pub fn create_quadratic_probing_string_table<V: StT>(
   54|      2|    pub fn path_weight_int(path: &ArraySeqStPerS<usize>, weights: &ArraySeqStPerS<ArraySeqStPerS<i64>>) -> Option<i64> {
   54|      2|        pub fn search_club(&self) -> DocumentSet { (self.fw)(&"club".to_string()) }
   54|      5|        pub fn new(n: usize) -> Self {
   54|      5|        pub fn new(n: usize, source: usize) -> Self {
   54|     71|        pub fn new(n: usize, source: usize) -> Self {
   54|      9|    pub fn count_components<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> N {
   54|      9|        pub fn update(&mut self, Pair(index, item): Pair<N, T>) -> &mut Self {
   55|    122|        pub fn insert(&self, key: K, value: V) -> Self {
   55|     12|    pub fn pq_min<V: StT + Ord, P: StT + Ord, G, PF>(graph: &G, source: V, priority_fn: &PF) -> PQMinResult<V, P>
   55|      1|        pub fn weighted_edges(&self) -> Set<(V, V, OrderedFloat<f64>)> {
   55|      1|        pub fn weighted_edges(&self) -> Set<(V, V, OrderedFloat<f64>)> {
   55|      4|        pub fn FromVec(v: Vec<Pair<A, B>>) -> Relation<A, B> { Relation { pairs: Set::FromVec(v) } }
   55|      5|        pub fn is_empty(&self) -> B { if self.data.is_empty() { true } else { false } }
   55|      7|    pub fn path_weight_int(path: &ArraySeqStPerS<usize>, weights: &ArraySeqStEphS<ArraySeqStEphS<i64>>) -> Option<i64> {
   56|     18|    pub fn count_components_mt<V: StT + MtT + Hash + Ord + 'static>(graph: &UnDirGraphMtEph<V>, seed: u64) -> N {
   56|     20|        pub fn pop(&mut self) -> Option<T> { self.elements.pop() }
   56|     26|        pub fn validate_double_hashing(h2_value: N, table_size: N) -> (B, String) {
   56|      3|    pub fn edge_contract_mt<V: StT + MtT + Hash + Ord + 'static>(
   56|      7|    pub fn kruskal_mst<V: StT + Hash + Ord>(
   57|      2|    pub fn euler_tour_mt<V: StT + MtT + Hash + Ord + 'static>(
   57|      3|        pub fn search_food(&self) -> DocumentSet { (self.fw)(&"food".to_string()) }
   57|      6|        pub fn is_leaf(&self) -> B {
   57|      7|        pub fn is_singleton(&self) -> B { if self.data.len() == 1 { true } else { false } }
   58|    107|        pub fn out_neighbors_weighted(&self, v: &V) -> Set<(V, i32)> {
   58|     10|    pub fn johnson_apsp(graph: &WeightedDirGraphMtEphFloat<usize>) -> AllPairsResultStEphFloat {
   58|      1|    pub fn example_undefined_shortest_path() {
   58|      1|        pub fn with_lock<T>(&self, action: impl FnOnce() -> T) -> T {
   58|      4|        pub fn neighbors_weighted(&self, v: &V) -> Set<(V, i32)> {
   58|      5|    pub fn johnson_apsp(graph: &WeightedDirGraphMtEphInt<usize>) -> AllPairsResultStEphInt {
   59|     59|        pub fn inject(&mut self, updates: &ArraySeqStEphS<Pair<N, T>>) -> &mut Self {
   59|      6|    pub fn graph_search<V: StT + Ord, G, S>(graph: &G, source: V, strategy: &S) -> SearchResult<V>
   60|      2|        pub fn search_chess(&self) -> DocumentSet { (self.fw)(&"chess".to_string()) }
   60|      5|        pub fn iter(&self) -> std::slice::Iter<'_, T> { self.data.iter() }
   61|      0|    pub fn example_45_2_already_sorted() -> HeapsortComparison<i32> {
   61|     25|    pub fn vertex_bridges<V: StT + Hash + Ord>(
   61|      2|        pub fn new_minimal() -> Self {
   61|     56|        pub fn subseq_copy(&self, start: N, length: N) -> Self {
   61|      7|        pub fn peek(&self) -> Option<&T> { self.elements.last() }
   62|     12|    pub fn pq_min<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static, G, PF>(graph: &G, source: V, priority_fn: &PF) -> PQMinResult<V, P>
   62|     14|    pub fn heapsort_sorted_list<T: StT + Ord>(sequence: &[T]) -> Vec<T> {
   62|      1|        pub fn neighbors_weighted(&self, v: &V) -> Set<(V, i32)> {
   62|      2|    pub fn create_quadratic_probing_integer_table<V: StT>(
   62|      2|    pub fn euler_tour<V: StT + Hash + Ord>(
   62|     31|        pub fn out_neighbors_weighted(&self, v: &V) -> Set<(V, i32)> {
   62|      4|    pub fn create_double_hashing_integer_table<V: StT>(
   62|      6|    pub fn pq_min<V: StT + Ord, P: StT + Ord, G, PF>(graph: &G, source: V, priority_fn: &PF) -> PQMinResult<V, P>
   62|      8|        pub fn get_distance(&self, v: usize) -> i64 {
   63|     65|        pub fn empty() -> Self {
   63|     65|        pub fn empty() -> Self {
   63|     71|        pub fn empty() -> Self {
   63|     72|        pub fn empty() -> Self {
   63|     73|        pub fn empty() -> Self {
   63|     78|        pub fn empty() -> Self {
   64|     10|        pub fn next_prime(n: N) -> N {
   64|    418|        pub fn in_order(&self) -> ArraySeqStPerS<T> {
   64|      4|    pub fn example_47_2_separate_chaining() -> StringSeparateChaining<String> { create_example_47_2_table() }
   64|      6|    pub fn graph_search<V: StTInMtT + Ord + 'static, G, S>(graph: &G, source: V, strategy: &S) -> SearchResult<V>
   65|      1|        pub fn add_weighted_edge(&mut self, from: V, to: V, weight: OrderedFloat<f64>) {
   65|      1|        pub fn iter_cloned(&self) -> Vec<T> {
   65|    269|        pub fn get_distance(&self, v: usize) -> i64 {
   65|      5|        pub fn is_empty(&self) -> bool { self.elements.is_empty() }
   65|     61|        pub fn add_weighted_edge(&mut self, v1: V, v2: V, weight: OrderedFloat<f64>) {
   65|      8|        pub fn get_distance(&self, u: usize, v: usize) -> i64 {
   65|      8|        pub fn get_distance(&self, v: usize) -> OrderedF64 {
   66|     13|    pub fn pq_min_multi<V: StT + Ord, P: StT + Ord, G, PF>(graph: &G, sources: AVLTreeSetStEph<V>, priority_fn: &PF) -> PQMinResult<V, P>
   66|    169|        pub fn insert(&mut self, v: V) {
   66|      1|        pub fn neighbors_weighted(&self, v: &V) -> Set<(V, OrderedFloat<f64>)> {
   66|      2|        pub fn complex_query_fun_and_food_or_chess(&self) -> ArraySeqStPerS<DocumentId> {
  663|     39|    pub fn from_sorted_entries<K: MtKey, V: MtVal>(entries: Vec<Pair<K, V>>) -> TableMtEph<K, V> {
   66|     56|        pub fn out_neighbors_weighted(&self, v: &V) -> Set<(V, OrderedFloat<f64>)> {
   66|   578k|        pub fn new_root() -> Self {
   66|      7|        pub fn empty() -> Self { Self { data: Vec::new() } }
   67|    279|        pub fn get_distance(&self, v: usize) -> OrderedF64 {
   67|      2|    pub fn example_47_4_probe_sequence() -> Vec<(String, Vec<N>)> {
   67|      8|        pub fn get_distance(&self, u: usize, v: usize) -> OrderedF64 {
   68|      0|    pub fn example_45_2_duplicates() -> HeapsortComparison<i32> {
   69|     26|        pub fn size(&self) -> N { self.elements.len() }
   69|      2|        pub fn singleton(value: T) -> Self {
   69|      2|        pub fn singleton(value: T) -> Self {
   69|      2|        pub fn singleton(value: T) -> Self {
   69|      2|        pub fn singleton(value: T) -> Self {
   69|      2|        pub fn singleton(value: T) -> Self {
   69|      2|        pub fn singleton(value: T) -> Self {
   69|     37|    pub fn dijkstra(graph: &WeightedDirGraphStEphInt<usize>, source: usize) -> SSSPResultStEphInt {
   69|     47|    pub fn dijkstra(graph: &WeightedDirGraphStEphFloat<usize>, source: usize) -> SSSPResultStEphFloat {
   70|     31|        pub fn analyze_linear_probing(&self, key: &str, table_size: N) -> ProbeSequenceVisualization {
   70|      5|        pub fn set_distance(self, v: usize, dist: i64) -> Self {
   70|      7|    pub fn graph_search_multi<V: StT + Ord, G, S>(graph: &G, sources: AVLTreeSetStEph<V>, strategy: &S) -> SearchResult<V>
   70|  8.14k|        pub fn subseq_copy(&self, start: N, length: N) -> Self {
   71|    122|    pub fn vertex_bridges_mt<V: StT + Hash + Ord + Send + Sync + 'static>(
   71|     13|        pub fn new() -> Self {
   71|    278|        pub fn in_neighbors_weighted(&self, v: &V) -> Set<(V, i32)> {
   71|    295|        pub fn insert(&self, key: K, value: V) -> Self {
   71|     64|        pub fn get_distance(&self, u: usize, v: usize) -> i64 {
   71|      6|        pub fn singleton(value: T) -> Self { Self { data: vec![value] } }
   71|      8|    pub fn graph_search<V: StT + Ord, G, S>(graph: &G, source: V, strategy: &S) -> SearchResult<V>
   72|     11|        pub fn new() -> Self { Self::new_root() }
   72|     16|        pub fn get_edge_weight(&self, v1: &V, v2: &V) -> Option<OrderedFloat<f64>> {
   72|      1|        pub fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
   72|      4|        pub fn get_edge_weight(&self, from: &V, to: &V) -> Option<OrderedFloat<f64>> {
   72|      6|    pub fn pq_min<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static, G, PF>(graph: G, source: V, priority_fn: PF) -> PQMinResult<V, P>
   73|     13|    pub fn pq_min_multi<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static, G, PF>(graph: &G, sources: AVLTreeSetMtPer<V>, priority_fn: &PF) -> PQMinResult<V, P>
   73|    175|        pub fn set_distance(&mut self, v: usize, dist: i64) {
   73|      2|        pub fn total_weight(&self) -> i32 { self.labeled_edges().iter().map(|edge| edge.2).sum() }
   73|      3|        pub fn update(&mut self, (index, item): (N, T)) -> &mut AVLTreeSeqStEphS<T> {
   73|     48|        pub fn get_distance(&self, u: usize, v: usize) -> OrderedF64 {
   73|      5|        pub fn set_distance(self, u: usize, v: usize, dist: i64) -> Self {
   73|      5|        pub fn set_distance(self, v: usize, dist: OrderedF64) -> Self {
   73|      7|    pub fn pq_min_multi<V: StT + Ord, P: StT + Ord, G, PF>(graph: &G, sources: AVLTreeSetStPer<V>, priority_fn: &PF) -> PQMinResult<V, P>
   74|      1|        pub fn height(&self) -> N {
   74|      1|    pub fn path_weight_float(
   75|      0|    pub fn example_45_2_single_element() -> HeapsortComparison<i32> {
   75|    173|        pub fn set_distance(&mut self, v: usize, dist: OrderedF64) {
   75|   233k|        pub fn size(&self) -> N { self.tree.size() }
   75|      2|    pub fn parallel_matching_st<V: StT + Hash>(graph: &UnDirGraphStEph<V>, seed: u64) -> Set<Edge<V>> {
   75|      2|    pub fn path_weight_float(
   75|    428|        pub fn size(&self) -> N { self.tree.size() }
   75|      5|        pub fn set_distance(self, u: usize, v: usize, dist: OrderedF64) -> Self {
   75|     62|        pub fn size(&self) -> N { self.tree.size() }
   75|     63|        pub fn size(&self) -> N { self.tree.size() }
   75|     70|        pub fn size(&self) -> N { self.tree.size() }
   75|     70|        pub fn size(&self) -> N { self.tree.size() }
   75|      7|    pub fn graph_search_multi<V: StTInMtT + Ord + 'static, G, S>(graph: &G, sources: AVLTreeSetMtPer<V>, strategy: &S) -> SearchResult<V>
   75|      7|        pub fn validate_quadratic_params(table_size: N, _c1: N, c2: N) -> (B, String) {
   76|     20|        pub fn vertex_degree(&self, v: &V) -> usize { self.neighbors(v).size() }
   76|      2|    pub fn example_41_1_avl_set() {
   76|     38|        pub fn from_vec(vec: Vec<T>) -> Self { Self { data: vec } }
   77|    107|        pub fn from_box(data: Box<[T]>) -> Self {
   77|  1.25k|        pub fn expose_with_priority(&self) -> Option<(ParamTreap<T>, T, i64, ParamTreap<T>)> {
   77|      4|        pub fn is_empty(&self) -> B { self.tree.is_empty() }
   77|      4|        pub fn is_empty(&self) -> B { self.tree.is_empty() }
   77|      4|        pub fn is_empty(&self) -> B { self.tree.is_empty() }
   77|      4|        pub fn is_empty(&self) -> B { self.tree.is_empty() }
   77|      4|        pub fn is_empty(&self) -> B { self.tree.is_empty() }
   77|   555k|        pub fn from_vec(values: Vec<T>) -> AVLTreeSeqStEphS<T> {
   77|      5|        pub fn is_empty(&self) -> B { self.tree.is_empty() }
   77|     85|        pub fn pre_order(&self) -> ArraySeqStPerS<T> {
   79|      0|    pub fn verify_spanning_tree<V: StT + MtT + Hash + Ord>(graph: &UnDirGraphMtEph<V>, tree_edges: &Set<Edge<V>>) -> B {
   79|  1.07k|        pub fn to_vec(&self) -> Vec<T> {
   79|      1|        pub fn weighted_edges(&self) -> Set<(V, V, OrderedFloat<f64>)> {
   79|      1|        pub fn weighted_edges(&self) -> Set<(V, V, OrderedFloat<f64>)> {
   79|      4|        pub fn find(&self, value: &T) -> Option<T> { self.tree.find(value) }
   79|      4|        pub fn find(&self, value: &T) -> Option<T> { self.tree.find(value) }
   79|      4|        pub fn find(&self, value: &T) -> Option<T> { self.tree.find(value) }
   79|      4|        pub fn find(&self, value: &T) -> Option<T> { self.tree.find(value) }
   79|      4|        pub fn find(&self, value: &T) -> Option<T> { self.tree.find(value) }
   79|      5|        pub fn set_distance(&mut self, u: usize, v: usize, dist: i64) {
   79|      6|        pub fn find(&self, value: &T) -> Option<T> { self.tree.find(value) }
   79|      9|        pub fn is_connected(&self) -> bool {
   80|     14|    pub fn heapsort_balanced_tree<T: StT + Ord>(sequence: &[T]) -> Vec<T> {
   80|      2|        pub fn get_predecessor(&self, v: usize) -> Option<usize> {
   80|      2|        pub fn new_minimal() -> Self {
   80|      8|    pub fn prim_mst<V: StT + Hash + Ord + Display>(
   81|     12|        pub fn into_vec(self) -> Vec<T> { self.data }
   81|   232k|        pub fn contains(&self, value: &T) -> B { self.tree.contains(value) }
   81|      2|        pub fn count_fun_but_not_chess(&self) -> N {
   81|    356|        pub fn contains(&self, value: &T) -> B { self.tree.contains(value) }
   81|     45|        pub fn contains(&self, value: &T) -> B { self.tree.contains(value) }
   81|     46|        pub fn contains(&self, value: &T) -> B { self.tree.contains(value) }
   81|     56|        pub fn contains(&self, value: &T) -> B { self.tree.contains(value) }
   81|      5|        pub fn set_distance(&mut self, u: usize, v: usize, dist: OrderedF64) {
   81|     81|        pub fn contains(&self, value: &T) -> B { self.tree.contains(value) }
   82|      0|    pub fn example_45_2_empty() -> HeapsortComparison<i32> {
   82|      1|    pub fn example_negative_weights() {
   82|      1|    pub fn parallel_increment(iterations: N) -> usize {
   82|      2|        pub fn get_predecessor(&self, v: usize) -> Option<usize> {
   82|      2|        pub fn get_predecessor(&self, v: usize) -> Option<usize> {
   82|      9|    pub fn graph_search_multi<V: StT + Ord, G, S>(graph: &G, sources: AVLTreeSetStPer<V>, strategy: &S) -> SearchResult<V>
   83|     12|        pub fn minimum(&self) -> Option<T> { self.tree.minimum() }
   83|     12|        pub fn minimum(&self) -> Option<T> { self.tree.minimum() }
   83|    417|        pub fn minimum(&self) -> Option<T> { self.tree.minimum() }
   83|     50|        pub fn probe_sequence_period(h2_value: N, table_size: N) -> N {
   83|     72|        pub fn minimum(&self) -> Option<T> { self.tree.minimum() }
   83|      7|    pub fn pq_min_multi<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static, G, PF>(graph: G, sources: AVLTreeSetMtEph<V>, priority_fn: PF) -> PQMinResult<V, P>
   83|      9|        pub fn minimum(&self) -> Option<T> { self.tree.minimum() }
   83|      9|        pub fn minimum(&self) -> Option<T> { self.tree.minimum() }
   84|     12|        pub fn total_weight(&self) -> i32 { self.labeled_arcs().iter().map(|edge| edge.2).sum() }
   84|    232|        pub fn insert(&mut self, value: T) {
   85|  1.17k|        pub fn find(&mut self, v: &V) -> V {
   85|     12|        pub fn maximum(&self) -> Option<T> { self.tree.maximum() }
   85|     12|        pub fn maximum(&self) -> Option<T> { self.tree.maximum() }
   85|      2|        pub fn get_predecessor(&self, v: usize) -> Option<usize> {
   85|    417|        pub fn maximum(&self) -> Option<T> { self.tree.maximum() }
   85|     72|        pub fn maximum(&self) -> Option<T> { self.tree.maximum() }
   85|      9|    pub fn connected_components<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> (Set<V>, HashMap<V, V>) {
   85|      9|        pub fn maximum(&self) -> Option<T> { self.tree.maximum() }
   85|      9|        pub fn maximum(&self) -> Option<T> { self.tree.maximum() }
   86|    106|        pub fn from_vec(data: Vec<T>) -> Self { Self::from_box(data.into_boxed_slice()) }
   86|     10|        pub fn to_arrayseq(&self) -> ArraySeqStEphS<T> {
   86|     23|        pub fn as_slice(&self) -> &[T] { &self.data }
   86|      2|        pub fn get_predecessor(&self, u: usize, v: usize) -> Option<usize> {
   86|     32|        pub fn new(base: N) -> Self { PolynomialHashFunction { base } }
   87|     10|    pub fn connected_components_mt<V: StT + MtT + Hash + Ord + 'static>(
   87|  1.47k|        pub fn insert(&mut self, value: T) { self.tree.insert(value); }
   87|  1.59k|        pub fn insert(&mut self, value: T) { self.tree.insert(value); }
   87|      1|        pub fn edges_above_weight(&self, threshold: i32) -> Set<(V, V, i32)> {
   87|    341|        pub fn insert(&mut self, value: T) { self.tree.insert(value); }
   87|    395|        pub fn insert(&mut self, value: T) { self.tree.insert(value); }
   87|     46|        pub fn new_root() -> Self {
   87|    494|        pub fn insert(&mut self, value: T) { self.tree.insert(value); }
   87|    534|        pub fn insert(&mut self, value: T) { self.tree.insert(value); }
   88|      2|        pub fn get_predecessor(&self, u: usize, v: usize) -> Option<usize> {
   88|      2|        pub fn get_predecessor(&self, u: usize, v: usize) -> Option<usize> {
   89|      0|    pub fn example_45_2_efficiency_demonstration() -> Vec<(String, Vec<i32>)> {
   89|    136|        pub fn set_predecessor(&mut self, v: usize, pred: usize) {
   89|     20|        pub fn analyze_linear_probing<K: StT, H: HashFunClone<K>>(
   89|    280|        pub fn delete(&mut self, target: &T) {
   89|     29|        pub fn to_vec(&self) -> Vec<T> {
   89|      6|        pub fn delete(&mut self, target: &T) {
   89|      6|        pub fn delete(&mut self, target: &T) {
   89|      6|        pub fn delete(&mut self, target: &T) {
   89|      6|        pub fn delete(&mut self, target: &T) {
   89|      7|        pub fn delete(&mut self, target: &T) {
   90|    139|        pub fn height(&self) -> N {
   90|      1|        pub fn search_food_or_fun(&self) -> DocumentSet {
   90|      2|        pub fn get_predecessor(&self, u: usize, v: usize) -> Option<usize> {
   90|      4|        pub fn neighbors_weighted(&self, v: &V) -> Set<(V, OrderedFloat<f64>)> {
   90|     98|        pub fn out_neighbors_weighted(&self, v: &V) -> Set<(V, OrderedFloat<f64>)> {
   91|    120|        pub fn set_predecessor(&mut self, v: usize, pred: usize) {
   91|     29|        pub fn length(&self) -> N { self.data.len() }
   91|      5|        pub fn set_predecessor(self, v: usize, pred: usize) -> Self {
   92|     12|        pub fn find(&self, target: &T) -> Option<&T> { Self::find_link(&self.root, target) }
   92|      2|        pub fn generate_valid_h2_values(table_size: N, max_count: N) -> Vec<N> {
   93|      3|        pub fn new() -> Self { Self::new_root() }
   93|      4|        pub fn memo_size(&self) -> usize { self.memo_table.len() }
   94|      5|        pub fn set_predecessor(self, v: usize, pred: usize) -> Self {
   94|      7|        pub fn contains(&self, target: &T) -> B { if self.find(target).is_some() { true } else { false } }
   95|     18|        pub fn with_exclusive<F: FnOnce(&mut [T]) -> R, R>(&self, f: F) -> R {
   95|      1|        pub fn update(&mut self, (index, item): (N, T)) -> &mut AVLTreeS<T> {
   95|      5|        pub fn empty() -> Self { LinkedListStPerS { head: None, len: 0 } }
   95|      5|        pub fn set_predecessor(self, u: usize, v: usize, pred: usize) -> Self {
   96|      0|    pub fn run_example_45_2() -> String {
   96|      1|    pub fn example_47_5_deleted_entries() -> LinearProbingHashTable<String, String, StringPositionHashFunction> {
   96|      1|        pub fn with_memo_table(self, memo: HashMap<(usize, usize), usize>) -> Self {
   96|      3|        pub fn minimum(&self) -> Option<&T> { Self::min_link(&self.root) }
   96|      6|    pub fn mst_weight<V: StT + Hash>(mst_edges: &Set<LabEdge<V, OrderedFloat<f64>>>) -> OrderedFloat<f64> {
   96|      7|        pub fn expose(&self) -> PrimTreeSeqStTree<T> {
   96|      8|        pub fn is_reachable(&self, v: usize) -> bool { self.get_distance(v) != UNREACHABLE }
   97|      0|        pub fn new(length: N, init_value: T) -> Self
   97|      4|        pub fn union(&self, other: &Self) -> Self {
   97|      4|        pub fn union(&self, other: &Self) -> Self {
   97|      4|        pub fn union(&self, other: &Self) -> Self {
   97|      4|        pub fn union(&self, other: &Self) -> Self {
   97|      5|        pub fn set_predecessor(&mut self, u: usize, v: usize, pred: usize) {
   97|      5|        pub fn set_predecessor(self, u: usize, v: usize, pred: usize) -> Self {
   97|      6|        pub fn union(&self, other: &Self) -> Self {
   97|      9|        pub fn union(&self, other: &Self) -> Self {
   98|     19|    pub fn heapsort_binary_heap<T: StT + Ord>(sequence: &[T]) -> Vec<T> {
   98|      1|        pub fn edges_below_weight(&self, threshold: i32) -> Set<(V, V, i32)> {
   98|      1|        pub fn is_memoized(&self, i: usize, j: usize) -> bool { self.memo_table.contains_key(&(i, j)) }
   98|      1|        pub fn search_party_and_food(&self) -> DocumentSet {
   98|      2|        pub fn maximum(&self) -> Option<&T> { Self::max_link(&self.root) }
   98|      4|        pub fn is_reachable(&self, v: usize) -> bool { self.get_distance(v).is_finite() }
   99|      1|    pub fn validate_subpath_property_int(
   99|      5|        pub fn set_predecessor(&mut self, u: usize, v: usize, pred: usize) {
  235|       |            cmp: fn(&A, &A) -> O,
  359|      2|            cmp: fn(&A, &A) -> O,
  398|      2|            cmp: fn(&A, &A) -> O,
   90|       |            cmp: fn(&A, &A) -> O,
  242|      1|    F: Fn(&Entry<K, V>, usize) -> Option<R>
  125|       |            cmp: fn(&K, &K) -> O,
  133|      3|            F: Fn(&K) -> V + Send + Sync + 'static,
  143|      3|            F: Fn(&K, &V) -> V + Send + Sync + 'static,
  162|      3|            F: Fn(&K, &V) -> B + Send + Sync + 'static,
  164|       |            cmp: fn(&K, &K) -> O,
  222|      3|            cmp: fn(&K, &K) -> O,
  256|      3|            cmp: fn(&K, &K) -> O,
  178|     13|            F: FnMut(&T) -> bool,
  178|      6|            F: FnMut(&T) -> bool,
  178|      6|            F: FnMut(&T) -> bool,
  178|      6|            F: FnMut(&T) -> bool,
  178|      7|            F: FnMut(&T) -> bool,
  178|      7|            F: FnMut(&T) -> bool,
  191|      4|            F: FnMut(T, T) -> T,
  191|      4|            F: FnMut(T, T) -> T,
  191|      4|            F: FnMut(T, T) -> T,
  191|      4|            F: FnMut(T, T) -> T,
  191|      5|            F: FnMut(T, T) -> T,
  191|      9|            F: FnMut(T, T) -> T,
  333|      1|            F: FnMut(&T) -> bool,
  340|      1|            F: FnMut(T, T) -> T,
  181|      6|            F: Fn(R, &K, &V) -> R + Send + Sync + 'static,
   24|       |            F: Fn(&Set<V>) -> R,
   25|       |            G: Fn(&Set<V>, &R) -> R;
   28|       |            F: Fn(&Set<V>) -> R + Send + Sync + 'static,
   29|       |            G: Fn(&Set<V>, &R) -> R + Send + Sync + 'static;
   51|     25|        F: Fn(&Set<V>) -> R,
   52|     25|        G: Fn(&Set<V>, &Set<Edge<V>>, &Set<V>, &HashMap<V, V>, R) -> R,
   56|     29|        F: Fn(&Set<V>) -> R,
   57|     29|        G: Fn(&Set<V>, &Set<Edge<V>>, &Set<V>, &HashMap<V, V>, R) -> R,
  242|     10|            F: Fn(T, T) -> T + Send + Sync + 'static,
  266|      2|            F: Fn(T, T) -> T + Send + Sync + 'static,
  333|       |            F: Fn(T, T) -> T + Send + Sync + 'static;
  393|      2|            F: Fn(&T) -> bool,
  411|      2|            F: Fn(&T) -> U,
  426|      2|            F: Fn(T, T) -> T + Send + Sync + 'static,
  101|     30|                G: Fn(&V) -> AVLTreeSetStPer<V>,
  114|      4|        G: Fn(&V) -> AVLTreeSetStEph<V>,
  123|      4|        G: Fn(&V) -> AVLTreeSetMtPer<V>,
  137|      1|        G: Fn(&V) -> AVLTreeSetStPer<V>,
   17|       |        F: Fn(&V, &V) -> V + Clone,
   17|       |        F: Fn(&V, &V) -> V + Clone,
  197|      3|            F: Fn(&V, &V) -> V + Send + Sync + 'static,
  205|      5|            F: Fn(&V, &V) -> V + Send + Sync + 'static,
   30|       |        F: Fn(&V) -> P + Send + Sync + 'static,
   31|       |        F: Fn(&V, &V) -> V + Clone,
   31|       |        F: Fn(&V, &V) -> V + Clone,
  326|       |        F: Fn(&V, &V) -> V + Clone,
  359|       |        F: Fn(&V, &V) -> V + Clone,
  361|       |        F: Fn(&V, &V) -> V + Clone,
  373|       |        F: Fn(&V, &V) -> V + Clone,
  394|       |        F: Fn(&V, &V) -> V + Clone,
  408|       |        F: Fn(&V, &V) -> V + Clone,
   42|       |            G: Fn(&V) -> AVLTreeSetStEph<V>,
   43|       |            G: Fn(&V) -> AVLTreeSetStEph<V>,
   48|       |            G: Fn(&V) -> AVLTreeSetMtPer<V>,
   48|       |            G: Fn(&V) -> AVLTreeSetStEph<V>,
   49|       |            G: Fn(&V) -> AVLTreeSetStEph<V>,
   50|       |            G: Fn(&V) -> AVLTreeSetStPer<V>,
   51|       |            G: Fn(&V) -> AVLTreeSetMtPer<V>,
   52|       |            G: Fn(&V) -> AVLTreeSetStPer<V>,
   53|       |            G: Fn(&V) -> AVLTreeSetMtPer<V>,
   54|       |            G: Fn(&V) -> AVLTreeSetStEph<V>;
   56|       |            G: Fn(&V) -> AVLTreeSetMtPer<V>,
   56|       |            G: Fn(&V) -> AVLTreeSetStPer<V>,
   57|     12|        G: Fn(&V) -> AVLTreeSetStEph<V>,
   58|       |            G: Fn(&V) -> AVLTreeSetMtPer<V>;
   59|       |            G: Fn(&V) -> AVLTreeSetStPer<V>,
   60|       |            G: Fn(&V) -> AVLTreeSetMtEph<V> + Send + Sync + 'static,
   61|      6|        G: Fn(&V) -> AVLTreeSetStEph<V>,
   64|     12|        G: Fn(&V) -> AVLTreeSetMtPer<V>,
   64|      6|        G: Fn(&V) -> AVLTreeSetStPer<V>,
   66|      6|        G: Fn(&V) -> AVLTreeSetMtPer<V>,
   66|       |            G: Fn(&V) -> AVLTreeSetMtEph<V> + Send + Sync + 'static,
   66|       |            G: Fn(&V) -> AVLTreeSetStPer<V>;
   68|     13|        G: Fn(&V) -> AVLTreeSetStEph<V>,
   72|      7|        G: Fn(&V) -> AVLTreeSetStEph<V>,
   73|      8|        G: Fn(&V) -> AVLTreeSetStPer<V>,
   74|      6|        G: Fn(&V) -> AVLTreeSetMtEph<V> + Send + Sync + 'static,
   75|     13|        G: Fn(&V) -> AVLTreeSetMtPer<V>,
   75|      7|        G: Fn(&V) -> AVLTreeSetStPer<V>,
   77|      7|        G: Fn(&V) -> AVLTreeSetMtPer<V>,
   79|       |        F: Fn(&V, &V) -> V + Clone,
   82|       |        F: Fn(&V, &V) -> V + Clone,
   83|     20|            G: Fn(&V) -> AVLTreeSetStEph<V>,
   84|      9|        G: Fn(&V) -> AVLTreeSetStPer<V>,
   85|      7|        G: Fn(&V) -> AVLTreeSetMtEph<V> + Send + Sync + 'static,
   88|     20|            G: Fn(&V) -> AVLTreeSetMtPer<V>,
   91|     60|                G: Fn(&V) -> AVLTreeSetStEph<V>,
   96|     32|                G: Fn(&V) -> AVLTreeSetStPer<V>,
   98|     60|                G: Fn(&V) -> AVLTreeSetMtPer<V>,
  100|      1|            let food_docs = (self.fw)(&"food".to_string());
  102|      1|            DocumentIndex::query_and(&party_docs, &food_docs)
   68|      2|            let food_docs = (self.fw)(&"food".to_string());
   91|      1|            let food_docs = (self.fw)(&"food".to_string());
   71|      2|            let food_or_chess = DocumentIndex::query_or(&food_docs, &chess_docs);
  117|       |            // For now, assume we can check occupancy through table statistics
  118|       |    /// For each vertex v, find the in-neighbor u that achieves the shortest path
  119|       |            // For undirected graphs, Neighbor checks if u and v are connected
  127|       |    /// For each vertex v, find the in-neighbor u that achieves the shortest path
  127|       |            // For simplicity, recalculate reduction from scratch
  132|       |            // For now, we'll panic to indicate this needs to be fixed
  182|       |            // For now, we'll panic to indicate this needs to be fixed
  188|       |    /// For each (u → v) in P, output (u → C[v])
  195|       |        // For now, compose sequentially since tuples don't implement Display
  198|       |        /// For double hashing: h_i(x) = (h1(x) + i * h2(x)) mod m
  259|      9|            'outer: for i in 0..pairs.length() {
  274|      1|Additional operations for the parametric flat hash table:
   27|       |    /// For each edge, flips a coin in parallel. Selects an edge if:
  286|       |        // For each element in sequence A, check if it exists in sequence B
  301|       |        // For each element in sequence B, check if it exists in sequence A
  302|      1|with support for different probing strategies.
  321|       |            // For simplicity, implement sequentially (full parallel scan is complex)
  354|       |            // For now, return log(n) as expected height
   38|       |            // For each starting position i and ending position j (i ≤ j)
   39|       |            // For even indices: result[2i] = c[i]
   40|       |            // For each starting position
   40|       |            // For odd indices: result[2i+1] = f(c[i], a[2i])
   42|       |            // For prime table sizes, use: step = 1 + (hash % (m-1))
   47|       |            // For each position i > 0, compute all_prefixes[i] - min_prefixes[i-1]
   50|       |    /// For each vertex, find the minimum weight edge incident on it.
   51|       |                // For total == 1 or other small cases
   54|       |        // For each edge in the matching, assign both endpoints to the same representative
   58|       |    /// For each vertex, find the minimum weight edge incident on it.
   62|       |            // For even indices: result[2i] = c[i]
   62|       |        // For unmatched vertices, they are their own representatives
   63|       |            // For odd indices: result[2i+1] = f(c[i], a[2i])
   64|       |            // For each vertex, compute minimum distance through in-neighbors (Line 5)
   73|       |        /// For quadratic probing to work well, m should be prime and c2 should be non-zero
   74|       |            // For each vertex, compute minimum distance through in-neighbors (Line 5)
   74|       |            // For unmatched vertices, they are their own representatives
   75|       |            // For each edge between centers in quotient tree, find original edge that maps to it
   78|       |        // For each edge in the original graph, add a new edge between block representatives
   81|       |                        // For better parallelism, we could spawn threads for each branch
   82|       |                // For linear probing, period is table_size
   86|       |            // For prime table size, c2 should be coprime to m
   88|       |            // For undirected graphs, check both edge orientations
  157|       |            // Fork thread per element to evaluate predicate
  178|       |            // Fork thread per element to evaluate predicate, collect results serially
  190|       |            // Fork thread per element for parallel mapping
  214|       |            // Fork thread per element to evaluate predicate, collect results serially
  203|      0|                    .map(|i| format!("{}", self.elements.nth(i)))
  416|      2|            description: format!("Analysis with prime table size m={}", prime_size),
  430|      2|            description: format!("Analysis with composite table size m={}", composite_size),
  371|      7|            fn format_node<T: StT + Ord>(node: &LeftistHeapNode<T>, f: &mut Formatter<'_>, depth: usize) -> Result {
  131|     32|                strategy_name: format!("Quadratic Probing (c1={}, c2={})", c1, c2),
  164|  1.00k|            table_eph.insert(i, format!("value_{}", i), |_old, new| new.clone());
  173|  1.00k|            table_mt.insert(i, format!("value_{}", i), |_old, new| new.clone());
  115|  3.95k|                        (ll, found, rebuilt)
  120|  1.67k|                        (rebuilt, found, rr)
  128|     41|                        (ll, found, rebuilt)
  133|    484|                        (rebuilt, found, rr)
  140|      7|        println!("  found: {},", found);
  181|      6|                    if found == true {
  183|    156|                    if found == true {
  196|      2|            let found = self.elements.get(pos) == Some(k);
  201|      2|            if found {
  201|      7|                    if found == true {
  204|    156|                    if found == true {
  209|     59|            let found = ArraySeqStPerS::filter(&array_seq, &|elem| elem == k).length() > 0;
  214|      8|            let found = ArraySeqStPerS::filter(&array_seq, &|elem| elem == k).length() > 0;
  215|      9|            (Self::from_seq(left_seq), found, Self::from_seq(right_seq))
  223|      2|            (Self::from_seq(left_seq), found, Self::from_seq(right_seq))
  296|      9|            if !found {
  311|      6|            if !found {
  384|      2|            (left, found, right)
   87|     17|                        (ll, found, rebuilt)
   92|     28|                        (rebuilt, found, rr)
   97|     11|                if !found {
   26|      6|                let (found_cycle, new_visited) = dfs_check_cycle(graph, visited, AVLTreeSetStPer::empty(), start);
   27|      6|                if found_cycle {
   57|     13|            let (found_cycle, new_visited) = dfs_check_cycle(graph, visited, ancestors.clone(), neighbor);
   58|     13|            if found_cycle {
  240|      9|                if !found_group {
  314|      3|                if !found_group {
  369|      8|                if !found_group {
  153|    214|                if f(&pair.0, &pair.1) {
  169|    310|                if f(&pair.0, &pair.1) {
  239|      0|                if !f(&pair.0, &pair.1) {
  265|     29|                if f(&pair.0, &pair.1) {
  113|    217|                let f_right = f;
  137|      0|            let f_right = f;
  298|      6|            let f_right = f.clone();
  109|      4|        fn from_dimensions(dimensions: Vec<MatrixDim>) -> Self {
  136|      1|        fn from_dimensions(dimensions: Vec<MatrixDim>) -> Self {
  146|      1|        fn from_dimensions(dimensions: Vec<MatrixDim>) -> Self {
   30|       |        fn from_dimensions(dimensions: Vec<MatrixDim>) -> Self;
   30|       |        fn from_dimensions(dimensions: Vec<MatrixDim>) -> Self;
   32|       |        fn from_dimensions(dimensions: Vec<MatrixDim>) -> Self;
   32|       |        fn from_dimensions(dimensions: Vec<MatrixDim>) -> Self;
   97|      7|        fn from_dimensions(dimensions: Vec<MatrixDim>) -> Self {
  104|     10|        fn from_dim_pairs(dim_pairs: Vec<Pair<usize, usize>>) -> Self {
  116|     10|        fn from_dim_pairs(dim_pairs: Vec<Pair<usize, usize>>) -> Self {
  143|     17|        fn from_dim_pairs(dim_pairs: Vec<Pair<usize, usize>>) -> Self {
  153|     19|        fn from_dim_pairs(dim_pairs: Vec<Pair<usize, usize>>) -> Self {
   33|       |        fn from_dim_pairs(dim_pairs: Vec<Pair<usize, usize>>) -> Self;
   33|       |        fn from_dim_pairs(dim_pairs: Vec<Pair<usize, usize>>) -> Self;
   35|       |        fn from_dim_pairs(dim_pairs: Vec<Pair<usize, usize>>) -> Self;
   35|       |        fn from_dim_pairs(dim_pairs: Vec<Pair<usize, usize>>) -> Self;
  218|      1|        fn from(e: Edge<V>) -> (V, V) { (e.0, e.1) }
  236|      1|        fn from(e: LabEdge<V, L>) -> (V, V, L) { (e.0, e.1, e.2) }
  104|       |    impl From<f64> for Probability {
  108|      2|        fn from_key_probs(key_probs: Vec<KeyProb<T>>) -> Self {
  120|      2|        fn from_key_probs(key_probs: Vec<KeyProb<T>>) -> Self {
  152|      1|        fn from_key_probs(key_probs: Vec<KeyProb<T>>) -> Self {
  164|      1|        fn from_key_probs(key_probs: Vec<KeyProb<T>>) -> Self {
   35|       |        fn from_key_probs(key_probs: Vec<KeyProb<T>>) -> Self;
   35|       |        fn from_key_probs(key_probs: Vec<KeyProb<T>>) -> Self;
   36|       |        fn from_key_probs(key_probs: Vec<KeyProb<T>>) -> Self;
   36|       |        fn from_key_probs(key_probs: Vec<KeyProb<T>>) -> Self;
  107|     27|        fn from_keys_probs(keys: Vec<T>, probs: Vec<Probability>) -> Self {
  139|     12|        fn from_keys_probs(keys: Vec<T>, probs: Vec<Probability>) -> Self {
  151|     22|        fn from_keys_probs(keys: Vec<T>, probs: Vec<Probability>) -> Self {
   32|       |        fn from_keys_probs(keys: Vec<T>, probs: Vec<Probability>) -> Self;
   32|       |        fn from_keys_probs(keys: Vec<T>, probs: Vec<Probability>) -> Self;
   33|       |        fn from_keys_probs(keys: Vec<T>, probs: Vec<Probability>) -> Self;
   33|       |        fn from_keys_probs(keys: Vec<T>, probs: Vec<Probability>) -> Self;
   95|     18|        fn from_keys_probs(keys: Vec<T>, probs: Vec<Probability>) -> Self {
   19|       |        fn from_matrix(matrix: ArraySeqStEphS<ArraySeqStEphS<bool>>) -> Self;
   20|       |        fn from_matrix(matrix: ArraySeqStPerS<ArraySeqStPerS<bool>>) -> Self;
   49|      0|        fn from_matrix(matrix: ArraySeqStEphS<ArraySeqStEphS<bool>>) -> Self {
   51|      0|        fn from_matrix(matrix: ArraySeqStPerS<ArraySeqStPerS<bool>>) -> Self {
  105|      5|        fn from_multiset(multiset: ArraySeqMtPerS<T>) -> Self {
  115|      7|        fn from_multiset(multiset: ArraySeqMtEphS<T>) -> Self {
   27|       |        fn from_multiset(multiset: ArraySeqStEphS<T>) -> Self;
   27|       |        fn from_multiset(multiset: ArraySeqStPerS<T>) -> Self;
   28|       |        fn from_multiset(multiset: ArraySeqMtPerS<T>) -> Self;
   29|       |        fn from_multiset(multiset: ArraySeqMtEphS<T>) -> Self;
   87|     16|        fn from_multiset(multiset: ArraySeqStPerS<T>) -> Self {
   96|     12|        fn from_multiset(multiset: ArraySeqStEphS<T>) -> Self {
  251|      1|        fn from(p: Pair<A, B>) -> Self { (p.0, p.1) }
  109|      0|        fn from(prob: Probability) -> Self { prob.0 }
  108|       |    impl From<Probability> for f64 {
   31|       |        fn FromRelation(r: &Relation<X, Y>) -> Mapping<X, Y>;
   89|      5|        fn FromRelation(r: &Relation<X, Y>) -> Mapping<X, Y> {
  116|       |        // fromSeq ⟨2, 7, 2, 8, 11, 2⟩ = {8, 2, 11, 7}
   66|       |        // fromSeq ⟨2, 7, 2, 8, 11, 2⟩ = {8, 2, 11, 7}
   18|       |        fn from_seq(adj: ArraySeqStEphS<ArraySeqStEphS<N>>) -> Self;
   19|       |        fn from_seq(adj: ArraySeqStPerS<ArraySeqStPerS<N>>) -> Self;
   47|      0|        fn from_seq(adj: ArraySeqStEphS<ArraySeqStEphS<N>>) -> Self { AdjSeqGraphStEph { adj } }
   49|      0|        fn from_seq(adj: ArraySeqStPerS<ArraySeqStPerS<N>>) -> Self { AdjSeqGraphStPer { adj } }
  130|      0|        fn from_seq(seq: AVLTreeSeqStPerS<T>) -> Self {
  137|      1|        fn from_seq(seq: &ArraySeqStPerS<T>) -> Self { UnsortedListPQ { elements: seq.clone() } }
  140|      9|        fn from_seq(seq: AVLTreeSeqStPerS<T>) -> Self {
  142|     53|        fn from_seq(seq: AVLTreeSeqStPerS<T>) -> Self {
  160|      1|        fn from_seq(seq: &AVLTreeSeqStPerS<T>) -> Self {
  180|      3|        fn from_seq(seq: &ArraySeqStPerS<T>) -> Self {
  256|      2|        fn from_seq(seq: &ArraySeqStPerS<T>) -> Self {
  265|      3|        fn from_seq(seq: &[T]) -> Self {
   26|       |        fn from_seq(seq: ArraySeqStEphS<T>) -> Self;
   26|       |        fn from_seq(seq: AVLTreeSeqStPerS<T>) -> Self;
   28|       |        fn from_seq(seq: AVLTreeSeqStEphS<T>) -> Self;
   33|       |        fn from_seq(seq: AVLTreeSeqMtPerS<T>) -> Self;
   33|       |        fn from_seq(seq: AVLTreeSeqStEphS<T>) -> Self;
   44|       |        fn from_seq(seq: &ArraySeqStPerS<T>) -> Self;
   44|       |        fn from_seq(seq: &ArraySeqStPerS<T>) -> Self;
   44|       |        fn from_seq(seq: &ArraySeqStPerS<T>) -> Self;
   44|       |        fn from_seq(seq: &AVLTreeSeqStPerS<T>) -> Self;
   44|       |        fn from_seq(seq: AVLTreeSeqStPerS<T>) -> Self;
   45|       |        fn from_seq(seq: AVLTreeSeqStPerS<T>) -> Self;
   45|       |        fn from_seq(seq: AVLTreeSeqStPerS<T>) -> Self;
   57|       |        fn from_seq(seq: &[T]) -> Self;
   60|     34|        fn from_seq(seq: ArraySeqStEphS<T>) -> Self {
   67|    216|        fn from_seq(seq: AVLTreeSeqMtPerS<T>) -> Self {
   68|    588|        fn from_seq(seq: AVLTreeSeqStPerS<T>) -> Self {
   70|    135|        fn from_seq(seq: AVLTreeSeqStEphS<T>) -> Self {
   73|    122|        fn from_seq(seq: AVLTreeSeqStEphS<T>) -> Self {
   34|       |        fn from_seq(u: N, seq: ArraySeqMtEphS<N>) -> Self;
   84|      2|        fn from_seq(u: N, seq: ArraySeqMtEphS<N>) -> Self {
  107|     30|        fn from_sequences(source: ArraySeqStEphS<T>, target: ArraySeqStEphS<T>) -> Self {
  112|      6|        fn from_sequences(source: ArraySeqMtPerS<T>, target: ArraySeqMtPerS<T>) -> Self {
  128|     27|        fn from_sequences(source: ArraySeqMtEphS<T>, target: ArraySeqMtEphS<T>) -> Self {
   28|       |        fn from_sequences(source: ArraySeqStEphS<T>, target: ArraySeqStEphS<T>) -> Self;
   28|       |        fn from_sequences(source: ArraySeqStPerS<T>, target: ArraySeqStPerS<T>) -> Self;
   29|       |        fn from_sequences(source: ArraySeqMtPerS<T>, target: ArraySeqMtPerS<T>) -> Self;
   30|       |        fn from_sequences(source: ArraySeqMtEphS<T>, target: ArraySeqMtEphS<T>) -> Self;
   92|     25|        fn from_sequences(source: ArraySeqStPerS<T>, target: ArraySeqStPerS<T>) -> Self {
   26|       |        fn FromSet(pairs: Set<Pair<X, Y>>) -> Relation<X, Y>;
   75|     37|        fn FromSet(pairs: Set<Pair<X, Y>>) -> Relation<X, Y> { Relation { pairs } }
   25|       |        fn FromSets(V: Set<V>, A: Set<Edge<V>>) -> DirGraphStEph<V>;
   25|       |        fn FromSets(V: Set<V>, E: Set<Edge<V>>) -> UnDirGraphStEph<V>;
   28|       |        fn FromSets(V: Set<V>, A: Set<Edge<V>>) -> DirGraphMtEph<V>;
   28|       |        fn FromSets(V: Set<V>, E: Set<Edge<V>>) -> UnDirGraphMtEph<V>;
   62|     83|        fn FromSets(V: Set<V>, E: Set<Edge<V>>) -> UnDirGraphStEph<V> { UnDirGraphStEph { V, E } }
   65|    102|        fn FromSets(V: Set<V>, E: Set<Edge<V>>) -> UnDirGraphMtEph<V> { UnDirGraphMtEph { V, E } }
   80|     19|        fn FromSets(V: Set<V>, A: Set<Edge<V>>) -> DirGraphStEph<V> { DirGraphStEph { V, A } }
   83|     81|        fn FromSets(V: Set<V>, A: Set<Edge<V>>) -> DirGraphMtEph<V> { DirGraphMtEph { V, A } }
  277|      3|            (from_sorted_entries(left_seq), from_sorted_entries(right_seq))
  307|      3|            (from_sorted_entries(left_seq), from_sorted_entries(right_seq))
  338|      3|            (from_sorted_entries(left_seq), from_sorted_entries(right_seq))
  354|      2|            (from_sorted_entries(left_seq), from_sorted_entries(right_seq))
  382|      2|            (from_sorted_entries(left_seq), from_sorted_entries(right_seq))
  213|     34|        fn from_sorted_iter<I>(values: I) -> Self
  213|     41|        fn from_sorted_iter<I>(values: I) -> Self
  213|     41|        fn from_sorted_iter<I>(values: I) -> Self
  213|     44|        fn from_sorted_iter<I>(values: I) -> Self
  213|     48|        fn from_sorted_iter<I>(values: I) -> Self
  213|     48|        fn from_sorted_iter<I>(values: I) -> Self
  214|      1|        fn from(t: (V, V)) -> Self { Edge(t.0, t.1) }
  232|      1|        fn from(t: (V, V, L)) -> Self { LabEdge(t.0, t.1, t.2) }
  247|      1|        fn from(t: (A, B)) -> Self { Pair(t.0, t.1) }
   21|       |        fn from_table(table: OrderedTableStEph<V, AVLTreeSetStEph<V>>) -> Self;
   21|       |        fn from_table(table: OrderedTableStPer<V, AVLTreeSetStPer<V>>) -> Self;
   51|      0|        fn from_table(table: OrderedTableStEph<V, AVLTreeSetStEph<V>>) -> Self { AdjTableGraphStEph { adj: table } }
   51|      1|        fn from_table(table: OrderedTableStPer<V, AVLTreeSetStPer<V>>) -> Self { AdjTableGraphStPer { adj: table } }
  105|      0|        fn from(value: f64) -> Self { Probability(value) }
  257|      0|        fn FromVec(v: Vec<T>) -> Set<T> {
   27|       |        fn FromVec(v: Vec<Pair<X, Y>>) -> Mapping<X, Y>;
   53|       |        fn FromVec(v: Vec<T>) -> Set<T>;
   82|      7|        fn FromVec(v: Vec<Pair<X, Y>>) -> Mapping<X, Y> {
  290|       |          $crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::AVLTreeSeqStPerTrait<_> >::from_vec(__vals)
  295|       |          $crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::AVLTreeSeqStPerTrait<_> >::from_vec(__vals)
  161|       |        fn from_vec(values: Vec<T>) -> Self;
  162|       |        fn from_vec(values: Vec<T>) -> Self;
  196|    648|        fn from_vec(values: Vec<T>) -> Self {
  198|  39.5k|        fn from_vec(values: Vec<T>) -> Self {
  130|      0|        fn from_vec(vec: Vec<T>) -> Self { Self { data: vec } }
   26|       |        fn from_vec(vec: Vec<T>) -> Self;
   20|       |        fn from_vertices_and_edges(v: AVLTreeSetStEph<V>, e: AVLTreeSetStEph<Pair<V, V>>) -> Self;
   21|       |        fn from_vertices_and_edges(v: AVLTreeSetStPer<V>, e: AVLTreeSetStPer<Pair<V, V>>) -> Self;
   23|       |        fn from_vertices_and_edges(v: AVLTreeSetMtPer<V>, e: AVLTreeSetMtPer<Pair<V, V>>) -> Self;
   53|      0|        fn from_vertices_and_edges(v: AVLTreeSetStEph<V>, e: AVLTreeSetStEph<Pair<V, V>>) -> Self {
   54|      0|        fn from_vertices_and_edges(v: AVLTreeSetStPer<V>, e: AVLTreeSetStPer<Pair<V, V>>) -> Self {
   56|      0|        fn from_vertices_and_edges(v: AVLTreeSetMtPer<V>, e: AVLTreeSetMtPer<Pair<V, V>>) -> Self {
   25|       |        fn from_vertices_and_labeled_arcs(vertices: Set<V>, labeled_arcs: Set<LabEdge<V, L>>) -> Self;
   29|       |        fn from_vertices_and_labeled_arcs(vertices: Set<V>, labeled_arcs: Set<LabEdge<V, L>>) -> Self;
   63|    135|        fn from_vertices_and_labeled_arcs(vertices: Set<V>, labeled_arcs: Set<LabEdge<V, L>>) -> Self {
   69|     56|        fn from_vertices_and_labeled_arcs(vertices: Set<V>, labeled_arcs: Set<LabEdge<V, L>>) -> Self {
   25|       |        fn from_vertices_and_labeled_edges(vertices: Set<V>, labeled_edges: Set<LabEdge<V, L>>) -> Self;
   29|       |        fn from_vertices_and_labeled_edges(vertices: Set<V>, labeled_edges: Set<LabEdge<V, L>>) -> Self;
   63|     76|        fn from_vertices_and_labeled_edges(vertices: Set<V>, labeled_edges: Set<LabEdge<V, L>>) -> Self {
   69|     59|        fn from_vertices_and_labeled_edges(vertices: Set<V>, labeled_edges: Set<LabEdge<V, L>>) -> Self {
  101|     13|            let frontier_new = new_neighbors.difference(&visited_new);
  105|     47|                    let frontier_new = frontier.difference(&AVLTreeSetMtPer::singleton(entry));
  109|     23|                    let frontier_new = frontier.difference(&AVLTreeSetStPer::singleton(entry));
  110|     13|            let frontier_new = new_neighbors.difference(&visited_new);
  121|     23|                let frontier_new = new_neighbors.difference(&visited_new);
   97|     47|                    let frontier_new = frontier.difference(&AVLTreeSetStEph::singleton(entry));
  100|     32|                if frontier.size() == 0 {
   28|      2|            if frontier.size() == 0 {
   33|      2|            if frontier.size() == 0 {
   37|      3|            if frontier.size() == 0 {
   74|     60|                if frontier.size() == 0 {
   81|     60|                if frontier.size() == 0 {
   82|     30|                if frontier.size() == 0 {
   86|     20|            if frontier.size() == 0 {
   91|     20|            if frontier.size() == 0 {
   92|     30|                if frontier.size() == 0 {
   56|     22|            let f_solve = Arc::clone(&f);
   58|     15|            let f_solve = Arc::clone(&f);
   73|     13|                Self::reduce_contract_parallel(&b, f_solve, id)
    2|       |//! Ephemeral full binary tree utilities (Chapter 23).
  223|      1|This is fully implemented in our SeparateChaining module.
  137|      2|3. Hash Function: Maps keys to positions [0, m-1] in the outer array
   16|       |    /// Functional form: points2D n = flatten (tabulate (\x. tabulate (\y. (x, y+1)) (n-1)) n)
    9|      0|    println!("No functionality here yet.");
   67|      2|            let fun_docs = (self.fw)(&"fun".to_string());
   82|      2|            let fun_docs = (self.fw)(&"fun".to_string());
   92|      1|            let fun_docs = (self.fw)(&"fun".to_string());
   94|      1|            DocumentIndex::query_or(&food_docs, &fun_docs)
  144|      1|        let fun_results = doc_set_to_sorted_vec(&examples.search_fun());
  146|      1|        if fun_results != expected_fun {
  196|       |        // Future optimization: use custom parallel map composition
   28|       |    /// fw : word → docs = find (makeIndex T)
   45|     28|            let fw = Box::new(move |word: &Word| index_clone.find(word));
  145|     49|            if f(x) == true {
  160|     35|            if f(x) == true {
  162|      1|            if f(x) == true {
  311|      2|            if f(x) == true {
  313|      3|            if f(x) == true {
  148|      1|            f: G,
   44|       |            f: G,
   76|     20|            graph: &G,
   81|     20|            graph: &G,
   83|     60|                graph: &G,
   89|     32|                graph: &G,
   90|     60|                graph: &G,
   93|     30|                graph: &G,
  103|     13|        fn gcd(a: N, b: N) -> N {
  158|       |            // Generate probe sequence to analyze uniqueness
  163|       |            // Generate probe sequence until we revisit a position or reach table_size
   16|       |    /// Generate points (x, y, z) with 0 ≤ x ≤ n−1, 1 ≤ y ≤ n, 2 ≤ z ≤ n+1 in x-major, then y, then z order.
  191|       |        /// Generate large example for performance testing
  197|       |        /// Generate the i-th hash value in the probe sequence
  233|       |    /// Generate a large random-like sequence for performance testing
  235|       |        // Generate pseudo-random sequence for testing
  247|       |        /// Generate probe sequence for visualization
  319|       |        /// Generate test sequences of various patterns
   31|       |        /// Generate i-th hash value in probe sequence
  338|       |        /// Generate good table sizes (powers of 2 or primes)
  339|       |    /// Generate test sequences of various patterns
   33|       |        /// Generate a random hash function from the universal family
  344|       |        // Generate probe sequence
  350|       |        // Generate valid h2 values for comparison
   37|       |            // Generate all contiguous subsequences and their sums
   83|       |        // Generate all random values sequentially (RNG must be sequential)
   90|       |        /// Generate a list of h2 values that are relatively prime to table_size
   18|       |    /// Generates all 2D points (x, y) where 0 ≤ x < n and 1 ≤ y < n.
   19|       |    /// Generates all 3D points (x, y, z) where 0 ≤ x < n, 1 ≤ y ≤ n, 2 ≤ z ≤ n+1.
  170|     14|        fn generate(&self, seed: u64) -> Self::HashFn {
   34|       |        fn generate(&self, seed: u64) -> Self::HashFn;
  320|       |        fn generate_test_sequences(size: usize) -> Vec<(String, Vec<i32>)>;
   49|       |        /// Generic graph search starting from single source.
   57|       |    /// Generic graph search starting from single source.
   61|       |    /// Generic graph search starting from single source.
   68|       |    /// Generic graph search starting from multiple sources.
   69|       |    /// Generic graph search starting from single source.
   73|       |    /// Generic graph search starting from multiple sources.
   80|       |    /// Generic graph search starting from multiple sources.
  100|       |        /// Get incoming neighbors with weights
  100|       |        /// Get memoized result if available
  101|       |            // Get all vertices before deleting
  102|       |        /// Get the total weight of all edges
  104|       |        /// Get current memoization table size
  105|       |        /// Get all unique words in the tweet collection
  106|       |                // Get all documents for this word by collecting from all_pairs
  108|       |        /// Get word count statistics
  110|       |        /// Get the length of sequence S
  111|       |        /// Get incoming neighbors with weights
  112|       |        /// Get the degree of a vertex (number of incident edges)
  113|       |        /// Get the length of sequence S
  113|       |        /// Get the total weight of all edges
  114|       |        /// Get memoized result if available
  114|       |                    // Get neighbors and add unvisited ones to frontier
  115|       |        /// Get the length of sequence S
  115|       |        /// Get the length of sequence T
  116|       |        /// Get the total weight of all edges
  118|       |        /// Get incoming neighbors with weights
  118|       |        /// Get the length of sequence T
  119|       |        /// Get the length of sequence S
  120|       |        /// Get the length of sequence T
  121|       |        /// Get the degree of a vertex (number of incident edges)
  122|       |                // Get neighbors and add unvisited ones to frontier
  123|       |        /// Get edges with weight greater than threshold
  123|       |        /// Get the total weight of all edges
  124|       |            // Get sorted values from both trees
  124|       |        /// Get the length of sequence T
  133|       |        /// Get the degree of a vertex (number of incident edges)
  134|       |        /// Get edges with weight less than threshold
  143|       |        /// Get the minimum weight edge
  145|       |        /// Get the minimum weight edge
  147|       |        /// Get the number of distinct sets
  148|       |        /// Get the length of sequence S
  149|       |        /// Get the length of sequence S
  151|       |        /// Get the maximum weight edge
  153|       |        /// Get the length of sequence T
  153|       |        /// Get the maximum weight edge
  154|       |        /// Get height of the heap
  154|       |        /// Get the length of sequence T
  162|       |        /// Get current memoization table size
  163|       |        /// Get the total weight of all edges
   16|       |        /// Get a description of this hash function
  173|       |        /// Get the total weight of all edges
  175|       |        /// Get current memoization table size
  178|       |        /// Get memoized result if available
  180|       |        /// Get the maximum element (rightmost in balanced tree)
  183|       |        /// Get all words in the index
  191|       |        /// Get memoized result if available
  194|       |        /// Get the length of sequence S
  197|       |        /// Get the total number of unique words in the index
  199|       |        /// Get the length of sequence S
  199|       |        /// Get the length of sequence T
  204|       |        /// Get the length of sequence T
  213|       |        /// Get the maximum element (last in sorted list)
   21|       |        /// Get the underlying f64 value
  236|       |        /// Get elements in sorted order as vector (for testing)
  239|       |        /// Get hash function values for debugging
  257|       |        /// Get elements in a range [min_val, max_val]
  290|       |        /// Get coefficients for debugging
   29|       |        /// Get distance between vertices
   29|       |        /// Get distance to vertex
  302|       |        /// Get elements in sorted order as vector (for testing)
  304|       |        /// Get the height of the heap (for testing)
   30|       |        /// Get distance between vertices
   30|       |        /// Get distance to vertex
  313|       |        /// Get elements at a specific level (for testing)
  316|       |        /// Get the height of the heap (for analysis)
  319|       |        /// Get the rank of the root (for analysis)
   31|       |        /// Get distance between vertices
   32|       |        /// Get distance between vertices
   32|       |        /// Get distance to vertex
   32|       |        /// Get distance to vertex
  331|       |        /// Get elements in sorted order as vector (for testing)
  333|       |        /// Get elements in sorted order as vector (for testing)
   34|       |        /// Get description of probing strategy
   34|       |        /// Get the source sequence
   34|       |        /// Get the source sequence
  351|       |        /// Get height of the underlying AVL tree (for testing)
   35|       |        /// Get the multiset
   35|       |        /// Get the multiset
   35|       |        /// Get the number of distinct sets
   36|       |        /// Get the family description
   36|       |        /// Get the multiset
   37|       |        /// Get the multiset
   37|       |        /// Get the source sequence
   37|       |        /// Get the target sequence
   37|       |        /// Get the target sequence
   38|       |        /// Get memoization table size
   38|       |        /// Get mutable multiset (ephemeral allows mutation)
   38|       |        /// Get the source sequence
  390|       |        /// Get elements in sorted order as vector (for testing)
   39|       |        /// Get memoization table size
   39|       |        /// Get the inner f64 value
   39|       |        /// Get the matrix dimensions
   39|       |        /// Get the matrix dimensions
   39|       |        /// Get the weight of an edge, if it exists
   39|       |        /// Get the weight of an edge, if it exists
   40|       |        /// Get memoization table size
   40|       |        /// Get mutable multiset (ephemeral allows mutation)
   40|       |        /// Get mutable source sequence (ephemeral allows mutation)
   40|       |        /// Get the target sequence
   41|       |        /// Get a copy of the matrix dimensions (thread-safe)
   41|       |        /// Get the keys with probabilities
   41|       |        /// Get the keys with probabilities
   41|       |        /// Get the matrix dimensions
   41|       |        /// Get the target sequence
   42|       |        /// Get mutable dimensions (ephemeral allows mutation)
   42|       |        /// Get number of matrices
   43|       |        /// Get memoization table size
   43|       |        /// Get mutable target sequence (ephemeral allows mutation)
   43|       |        /// Get the weight of an edge, if it exists
   43|       |        /// Get the weight of an edge, if it exists
   44|       |        /// Get a copy of the keys with probabilities (thread-safe)
   44|       |        /// Get all weighted edges as (from, to, weight) tuples
   44|       |        /// Get all weighted edges as (v1, v2, weight) tuples
   44|       |        /// Get mutable keys (ephemeral allows mutation)
   44|       |        /// Get mutable source sequence (ephemeral allows mutation)
   44|       |        /// Get number of keys
   44|       |        /// Get number of matrices
   44|       |        /// Get the keys with probabilities
   45|       |        /// Get memoization table size
   45|       |        /// Get the weight of an edge, if it exists
   45|       |        /// Get the weight of an edge, if it exists
   47|       |        /// Get memoization table size
   47|       |        /// Get memoization table size
   47|       |        /// Get memoization table size
   47|       |        /// Get mutable target sequence (ephemeral allows mutation)
   47|       |        /// Get number of keys
   48|       |        /// Get all weighted edges as (from, to, weight) tuples
   48|       |        /// Get all weighted edges as (v1, v2, weight) tuples
   49|       |        /// Get memoization table size
   50|       |        /// Get memoization table size
   50|       |        /// Get number of matrices
   51|       |        /// Get number of matrices
   52|       |        /// Get all weighted edges as (from, to, weight) tuples
   52|       |        /// Get all weighted edges as (v1, v2, weight) tuples
   53|       |        /// Get number of keys
   53|       |        /// Get number of keys
   55|       |        /// Get memoization table size
   55|       |        /// Get neighbors with weights
   55|       |        /// Get outgoing neighbors with weights
   56|       |        /// Get memoization table size
   57|       |        /// Get memoization table size
   59|       |        /// Get memoization table size
   59|       |        /// Get memoization table size
   59|       |        /// Get memoization table size
   59|       |        /// Get neighbors with weights
   59|       |        /// Get outgoing neighbors with weights
   59|       |                // Get vertex from domain via to_seq
   61|       |                    // Get the element at position i
   63|       |        /// Get neighbors with weights
   63|       |        /// Get outgoing neighbors with weights
   65|       |        /// Get the rank (distance to nearest leaf) of a node
   68|       |        /// Get incoming neighbors with weights
   69|       |        /// Get the weight of an edge, if it exists
   69|       |        /// Get the weight of an edge, if it exists
   70|       |        /// Get the total weight of all edges
   75|       |        /// Get the degree of a vertex (number of incident edges)
   76|       |        /// Get all weighted edges as (from, to, weight) tuples
   76|       |        /// Get all weighted edges as (v1, v2, weight) tuples
   81|       |        /// Get the total weight of all edges
   86|       |        /// Get edges with weight greater than threshold
   87|       |        /// Get neighbors with weights
   87|       |        /// Get outgoing neighbors with weights
   90|       |        /// Get current memoization table size
   97|       |        /// Get edges with weight less than threshold
   43|       |        fn get_arc_label(&self, from: &V, to: &V) -> Option<&L>;
   47|       |        fn get_arc_label(&self, from: &V, to: &V) -> Option<&L>;
   87|     38|        fn get_arc_label(&self, from: &V, to: &V) -> Option<&L> {
   93|     15|        fn get_arc_label(&self, from: &V, to: &V) -> Option<&L> {
   12|       |//! - `get_distance`: Work O(1), Span O(1)
   12|       |//! - `get_distance`: Work O(1), Span O(1)
   12|       |//! - `get_distance`: Work O(1), Span O(1)
   12|       |//! - `get_distance`: Work O(1), Span O(1)
   13|       |//! - `get_distance`: Work O(1), Span O(1)
   13|       |//! - `get_distance`: Work O(1), Span O(1)
   13|       |//! - `get_distance`: Work O(1), Span O(1)
   13|       |//! - `get_distance`: Work O(1), Span O(1)
  101|     13|        fn get_edge_label(&self, v1: &V, v2: &V) -> Option<&L> {
   43|       |        fn get_edge_label(&self, v1: &V, v2: &V) -> Option<&L>;
   47|       |        fn get_edge_label(&self, v1: &V, v2: &V) -> Option<&L>;
   95|     46|        fn get_edge_label(&self, v1: &V, v2: &V) -> Option<&L> {
  150|     43|    fn get_edge_weight<V: StT + Hash + Ord>(
  181|      3|    fn get_edge_weight<V: StT + MtT + Hash + Ord>(
  201|      6|    fn get_edge_weight<V: StT + Hash + Ord>(
  270|      8|        fn get_key_range(&self, k1: &K, k2: &K) -> Self {
  273|      9|        fn get_key_range(&self, k1: &K, k2: &K) -> Self {
  283|     23|        fn get_key_range(&self, k1: &K, k2: &K) -> Self {
  284|     10|        fn get_key_range(&self, k1: &K, k2: &K) -> Self {
  305|      7|        fn get_key_range(&self, k1: &K, k2: &K) -> Self {
  314|     25|        fn get_key_range(&self, k1: &K, k2: &K) -> Self {
   60|       |        fn get_key_range(&self, k1: &K, k2: &K) -> Self;
   63|       |        fn get_key_range(&self, k1: &K, k2: &K) -> Self;
   68|       |        fn get_key_range(&self, k1: &K, k2: &K) -> Self;
   71|       |        fn get_key_range(&self, k1: &K, k2: &K) -> Self;
   76|       |        fn get_key_range(&self, k1: &K, k2: &K) -> Self;
   78|       |        fn get_key_range(&self, k1: &K, k2: &K) -> Self;
  136|     25|    fn get_neighbors<V: StT + Hash + Ord>(graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>, v: &V) -> Set<V> {
  167|      6|    fn get_neighbors<V: StT + MtT + Hash + Ord>(graph: &LabUnDirGraphMtEph<V, OrderedFloat<f64>>, v: &V) -> Set<V> {
  187|      6|    fn get_neighbors<V: StT + Hash + Ord>(graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>, v: &V) -> Set<V> {
   64|       |        // getRange A ('burt', 'mike') → {'burt', 'finn', 'mike'}
  221|      2|        fn get_range(&self, k1: &T, k2: &T) -> Self {
  222|      9|        fn get_range(&self, k1: &T, k2: &T) -> Self {
  230|      2|        fn get_range(&self, k1: &T, k2: &T) -> Self {
   62|       |        fn get_range(&self, k1: &T, k2: &T) -> Self;
   63|       |        fn get_range(&self, k1: &T, k2: &T) -> Self;
   63|       |        fn get_range(&self, k1: &T, k2: &T) -> Self;
  207|      1|        fn get(&self, key: &K) -> Option<&V> { self.find(key) }
  310|     60|        fn get(&self, key: &K) -> Option<&V> { self.find(key) }
   57|       |        fn get(&self, key: &K) -> Option<&V>;
   97|       |        fn get(&self, key: &K) -> Option<&V>;
   97|       |    /// Given a path and distances for all vertices from source, check if all sub-paths are optimal.
   98|       |    /// Given a path and distances for all vertices from source, check if all sub-paths are optimal.
  107|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  108|       |        // gpt-5-codex-medium: work O(1), span O(1)
  120|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  128|       |        // gpt-5-codex-medium: work O(1), span O(1)
  132|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  141|       |        // gpt-5-codex-medium: work O(m · lg (n / m)), span O(lg n)
  144|       |        // gpt-5-codex-medium: work O(lg (|left| + |right|)), span O(lg (|left| + |right|))
  155|       |        // gpt-5-codex-medium: work O(m · lg (n / m)), span O(lg n)
  157|       |        // gpt-5-codex-medium: work O(m · lg (n / m)), span O(lg n)
  171|       |        // gpt-5-codex-medium: work O(m · lg (n / m)), span O(lg n)
  173|       |        // gpt-5-codex-medium: work O(m · lg (n / m)), span O(lg n)
  191|       |        // gpt-5-codex-medium: work O(m · lg (n / m)), span O(lg n)
  193|       |        // gpt-5-codex-medium: work O(m · lg (n / m)), span O(lg n)
  211|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  214|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  232|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  235|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  239|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  242|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  263|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  263|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  270|       |        // gpt-5-codex-medium: work O(|t|), span O(|t|)
  273|       |        // gpt-5-codex-medium: work O(|t|), span O(|t|)
  285|       |        // gpt-5-codex-medium: work O(1), span O(1)
  293|       |        // gpt-5-codex-medium: work O(1), span O(1)
  297|       |        // gpt-5-codex-medium: work O(1), span O(1)
  301|       |        // gpt-5-codex-medium: work O(1), span O(1)
  303|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  306|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  308|       |        // gpt-5-codex-medium: work O(1), span O(1)
  309|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  312|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  312|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  315|       |        // gpt-5-codex-medium: work O(lg (|t_1| + |t_2|)), span O(lg (|t_1| + |t_2|))
  318|       |        // gpt-5-codex-medium: work O(m · lg (n / m)), span O(lg n)
  321|       |        // gpt-5-codex-medium: work O(m · lg (n / m)), span O(lg n)
  322|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  324|       |        // gpt-5-codex-medium: work O(m · lg (n / m)), span O(lg n)
  327|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  330|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  332|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  335|       |        // gpt-5-codex-medium: work O(|t|), span O(|t|)
  341|       |        // gpt-5-codex-medium: work O(1), span O(1)
  345|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  349|       |        // gpt-5-codex-medium: work O(1), span O(1)
  349|       |        // gpt-5-codex-medium: work O(lg (|t_1| + |t_2|)), span O(lg (|t_1| + |t_2|))
  353|       |        // gpt-5-codex-medium: work O(1), span O(1)
  353|       |        // gpt-5-codex-medium: work O(m · lg (n / m)), span O(lg n)
  357|       |        // gpt-5-codex-medium: work O(1), span O(1)
  357|       |        // gpt-5-codex-medium: work O(m · lg (n / m)), span O(lg n)
  361|       |        // gpt-5-codex-medium: work O(1), span O(1)
  361|       |        // gpt-5-codex-medium: work O(m · lg (n / m)), span O(lg n)
  365|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  365|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  371|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  376|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  377|       |        // gpt-5-codex-medium: work O(|t|), span O(|t|)
  386|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  399|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
  403|       |        // gpt-5-codex-medium: work O(lg (|t_1| + |t_2|)), span O(lg (|t_1| + |t_2|))
  407|       |        // gpt-5-codex-medium: work O(m · lg (n / m)), span O(lg n)
  411|       |        // gpt-5-codex-medium: work O(m · lg (n / m)), span O(lg n)
  415|       |        // gpt-5-codex-medium: work O(m · lg (n / m)), span O(lg n)
  419|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  423|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
  432|       |        // gpt-5-codex-medium: work O(|t|), span O(|t|)
   53|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
   56|       |        // gpt-5-codex-medium: work O(lg |t|), span O(lg |t|)
   59|       |        // gpt-5-codex-medium: work O(lg (|t_1| + |t_2|)), span O(lg (|t_1| + |t_2|))
   62|       |        // gpt-5-codex-medium: work O(m · lg (n / m)), span O(lg n)
   65|       |        // gpt-5-codex-medium: work O(m · lg (n / m)), span O(lg n)
   66|       |        // gpt-5-codex-medium: work O(1), span O(1)
   68|       |        // gpt-5-codex-medium: work O(m · lg (n / m)), span O(lg n)
   71|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
   74|       |        // gpt-5-codex-medium: work O(|t|), span O(lg |t|)
   76|       |        // gpt-5-codex-medium: work O(1), span O(1)
   77|       |        // gpt-5-codex-medium: work O(|t|), span O(|t|)
   83|       |        // gpt-5-codex-medium: work O(1), span O(1)
   85|       |        // gpt-5-codex-medium: work O(lg (|left| + |right|)), span O(lg (|left| + |right|))
   93|       |        // gpt-5-codex-medium: work O(1), span O(1)
   17|       |    /// gpt-5-hard: Work: Θ(n²), Span: Θ(lg n)
   19|       |    /// gpt-5-hard: Work: Θ(n²), Span: Θ(lg n)
   19|       |    /// gpt-5-hard: Work: Θ(n lg n), Span: Θ(lg n)
   20|       |    /// gpt-5-hard: Work: Θ(n³), Span: Θ(lg n)
   20|       |    /// gpt-5-hard: Work: Θ(n³), Span: Θ(n³) (sequential due to imperative loops)
   22|       |    /// gpt-5-hard: Work: Θ(n^{3/2}), Span: Θ(lg n)
   28|       |    /// gpt-5-hard: Work: Θ(√n), Span: Θ(lg n)
   29|       |    /// gpt-5-hard: Work: Θ(|a|·|b|), Span: Θ(|a|·|b|) (sequential due to imperative loops)
   38|       |    /// gpt-5-hard: Work: Θ(|a|·|b|), Span: Θ(lg |a|)
   48|       |    /// gpt-5-hard: Work: Θ(|a|·|b|), Span: Θ(lg |a|)
  158|     34|        let graph1 = graph.clone();
  161|     34|        let graph2 = graph;
   22|       |    /// Graph is represented as sequence of sequences (adjacency list).
   22|       |    /// Graph is represented as sequence of sequences (adjacency list).
   23|       |    /// Graph is represented as sequence of sequences (adjacency list).
   23|       |    /// Graph is represented as sequence of sequences (adjacency list).
   26|       |    /// Graph: 0 -> 1 -> 2 -> 1 (cycle with negative total weight).
   45|       |        /// Graph search using thread-safe persistent sets with parallel set operations.
    4|       |//! Implements graph connectivity algorithms using star contraction.
   63|       |    /// Graph search using thread-safe persistent sets with parallel set operations.
  113|      4|        let graph_arc = Arc::new(graph.clone());
   70|     14|        expand(graph.vertices(), graph.edges(), &centers, &partition_map, r)
   75|     22|        expand(graph.vertices(), graph.edges(), &centers, &partition_map, r)
   90|      0|            if !graph.edges().mem(edge) && !graph.edges().mem(&Edge(v.clone(), u.clone())) {
  107|     27|                if graph.Incident(adj_edge, u) || graph.Incident(adj_edge, v) {
  199|    131|            if graph.Incident(adj_edge, u) || graph.Incident(adj_edge, v) {
  131|      0|                let graph_left = graph.clone();
  135|     10|        let graph_left = graph.clone();
  135|     18|        let graph_left = graph.clone();
  169|      0|                let graph_left = graph.clone();
  276|      0|                let graph_left = graph.clone();
  321|      0|                let graph_left = graph.clone();
   21|       |//! let graph_macro = WeightedDirGraphStEphFloatLit!(
   21|       |//! let graph_macro = WeightedUnDirGraphStEphFloatLit!(
  120|     14|            if !graph.Neighbor(u, v) {
  124|      0|                    return graph.NG(&vertices[0]);
  162|      0|                    return graph.NG(&vertices[0]);
  314|      0|                    return graph.NMinus(&vertices[0]);
  269|      0|                    return graph.NPlus(&vertices[0]);
  132|      0|                let graph_right = graph;
  136|      0|                        parallel_ng_of_vertices(right_verts, graph_right)
  136|     10|        let graph_right = graph.clone();
  136|     18|        let graph_right = graph.clone();
  170|      0|                let graph_right = graph;
  174|      0|                        parallel_ng_of_vertices(right_verts, graph_right)
  277|      0|                let graph_right = graph;
  281|      0|                        parallel_nplus_of_vertices(right_verts, graph_right)
  322|      0|                let graph_right = graph;
  326|      0|                        parallel_nminus_of_vertices(right_verts, graph_right)
   40|       |        fn graph_search<G, S>(graph: &G, source: V, strategy: &S) -> SearchResult<V>
   46|       |        fn graph_search<G, S>(graph: &G, source: V, strategy: &S) -> SearchResult<V>
   50|       |        fn graph_search<G, S>(graph: &G, source: V, strategy: &S) -> SearchResult<V>
    9|       |pub mod GraphSearchMtPer {
   46|       |        fn graph_search_multi<G, S>(graph: &G, sources: AVLTreeSetStEph<V>, strategy: &S) -> SearchResult<V>
   51|       |        fn graph_search_multi<G, S>(graph: &G, sources: AVLTreeSetMtPer<V>, strategy: &S) -> SearchResult<V>
   57|       |        fn graph_search_multi<G, S>(graph: &G, sources: AVLTreeSetStPer<V>, strategy: &S) -> SearchResult<V>
    4|       |pub mod GraphSearchStEph {
    6|       |pub mod GraphSearchStPer {
   55|     25|        if graph.sizeE() == 0 {
   56|      9|        if graph.sizeE() == 0 {
   58|     18|        if graph.sizeE() == 0 {
   60|     29|        if graph.sizeE() == 0 {
   87|      9|        if graph.sizeE() == 0 {
   92|     10|        if graph.sizeE() == 0 {
   57|      4|            return graph.sizeV();
   59|      3|            return graph.sizeV();
   92|      3|            return (graph.vertices().clone(), component_map);
   97|      2|            return (graph.vertices().clone(), component_map);
   51|      5|        let (graph_with_dummy, dummy_idx) = add_dummy_source(graph, n);
   52|      5|        let (graph_with_dummy, dummy_idx) = add_dummy_source(graph, n);
   62|     10|        let (graph_with_dummy, dummy_idx) = add_dummy_source(graph, n);
   62|      5|        let (graph_with_dummy, dummy_idx) = add_dummy_source(graph, n);
   75|       |        // Greedily add edges that don't form cycles
   18|       |        /// Greedy vertex matching algorithm
   20|       |        fn greedy_matching<V: StT + Hash>(graph: &UnDirGraphStEph<V>) -> Set<Edge<V>>;
  231|     12|                for group in &mut groups {
  261|      9|                for group in groups.iter_mut() {
  302|      4|                for group in &mut groups {
  360|     11|                for group in &mut groups {
  292|      1|            let grouped: Vec<Pair<K, ArraySeqS<V>>> = groups
  185|      2|- Example: grow at α > 0.75, shrink at α < 0.25
  126|  3.16k|                        data.swap(i, gt);
  128|   381k|                            data.swap(i, gt);
  129|      6|                sort(a, gt, hi);
  166|      6|                sort(a, gt, hi);
  167|  3.49k|                        data.swap(i, gt);
  168|    998|                            data.swap(i, gt);
   75|    771|                        data.swap(i, gt);
   77|     22|                            data.swap(i, gt);
   81|     10|                sort(a, gt, hi);
  116|    850|                let guard = link.read().unwrap();
  125|    308|            let guard = self.inner.data.lock().unwrap();
  137|    102|            let guard = self.root.read().unwrap();
  144|     11|            let guard = self.root.read().unwrap();
  150|     38|                let guard = link.read().unwrap();
  159|    629|            Self::insert_link(&mut *guard, value);
  163|     10|            let guard = self.inner.data.lock().unwrap();
  163|    178|            let guard = self.root.read().unwrap();
  169|      1|            let guard = self.data.lock().unwrap();
  170|     92|            let guard = self.root.read().unwrap();
  172|    194|                let guard = link.read().unwrap();
  183|      8|            let guard = self.root.read().unwrap();
  188|     17|            let guard = self.root.read().unwrap();
  191|  1.03k|            Self::insert_link(&mut *guard, value, &mut rng);
  193|     17|            let guard = self.root.read().unwrap();
  194|    572|                let guard = link.read().unwrap();
  195|    154|            let guard = self.root.read().unwrap();
  197|    907|                Self::rebalance_if_needed(&mut *guard, total);
  198|     75|            let guard = self.root.read().unwrap();
  202|    103|            let guard = self.root.read().unwrap();
  202|    134|            let guard = self.root.read().unwrap();
  205|      1|            let guard = self.root.read().unwrap();
  209|     95|            let guard = self.root.read().unwrap();
  214|  1.91k|            Self::insert_link(&mut *guard, value);
  216|     12|            let guard = self.root.read().unwrap();
  218|   232k|            let guard = self.root.read().unwrap();
  221|     25|            let guard = self.root.read().unwrap();
  223|     13|            let guard = self.root.read().unwrap();
  225|   233k|            let guard = self.root.read().unwrap();
  226|     25|            let guard = self.root.read().unwrap();
  228|     19|            let guard = self.root.read().unwrap();
  231|    100|            let guard = self.root.read().unwrap();
  232|     16|            let guard = self.root.read().unwrap();
  233|     19|            let guard = self.root.read().unwrap();
  237|    431|            let guard = self.root.read().unwrap();
  238|      0|            let guard = self.root.read().unwrap();
  238|     75|            let guard = self.root.read().unwrap();
  242|    431|            let guard = self.root.read().unwrap();
  245|      2|            let guard = self.root.read().unwrap();
  247|     78|            let guard = self.root.read().unwrap();
  250|  24.9k|            Self::insert_link(&mut *guard, value);
  254|      1|            let guard = self.root.read().unwrap();
  257|    445|            let guard = self.root.read().unwrap();
   26|      0|            let guard = self.data.lock().unwrap();
  264|    465|            let guard = self.root.read().unwrap();
  277|     18|            let guard = self.root.read().unwrap();
  282|     80|            let guard = self.root.read().unwrap();
  287|     80|            let guard = self.root.read().unwrap();
  292|    358|            let guard = self.root.read().unwrap();
  299|      1|            let guard = self.root.read().unwrap();
  303|  15.7k|            let guard = self.root.read().unwrap();
  395|      1|            let guard = self.inner.data.lock().unwrap();
  404|      1|            let guard = self.inner.data.lock().unwrap();
   42|  2.22k|        let guard = tree.root.read().unwrap();
   43|  2.62M|            let guard = self.data.lock().unwrap();
   47|  2.26k|        let guard = tree.root.read().unwrap();
   48|  5.25M|            let guard = self.data.lock().unwrap();
   61|    196|            let guard = self.root.borrow();
   62|    196|            match &*guard {
   66|      1|            let guard = self.data.lock().unwrap();
   68|    802|            let guard = self.root.read().unwrap();
   69|    802|            match &*guard {
   71|  8.14k|            let guard = self.data.lock().unwrap();
   78|  1.25k|            let guard = self.root.read().unwrap();
   80|  1.07k|            let guard = self.data.lock().unwrap();
   85|  18.9k|            let guard = self.root.read().unwrap();
   86|  18.9k|            match &*guard {
   90|     29|            let guard = self.inner.data.lock().unwrap();
   82|  7.58k|                match guard.as_mut() {
  117|    850|                match guard.as_ref() {
   99|     18|            f(&mut guard[start..end])
  101|    463|                    Self::update(&mut h);
  105|     11|                    Self::update(&mut h);
   11|       |        hash1: H1,
   14|       |        hash1: H1,
  183|       |        hash1: H1,
  188|       |    impl<K, H1: HashFunction<K>, H2: HashFunction<K>> ProbeSequenceGenerator<K, H1, H2> {
   11|       |        base_hash: H,
   11|       |        base_hash: H,
  200|      3|            let h1 = self.hash1.hash(key, table_size);
   29|    390|            let h1 = self.hash1.hash(key, table_size);
  137|     16|            AdvancedQuadraticProbingStrategy<K, H>: ProbeSequence<K> + Clone,
   14|       |        base_hash: H,
   14|       |        base_hash: H,
  146|     20|            let h1_value = self.hash1.hash(key, table_size);
  152|     27|            let (_h1_value, h2_value) = strategy.get_hash_values(&key.to_string(), table_size);
  242|     29|            let h1_value = self.hash1.hash(key, table_size);
  250|     29|            let h1_value = self.hash1.hash(key, table_size);
  270|     82|            let h1_value = self.hash1.hash(key, table_size);
   20|       |        hash_function: H,
   12|       |        hash2: H2,
   15|       |        hash2: H2,
  184|       |        hash2: H2,
  201|      3|            let h2 = self.hash2.hash(key, table_size);
   30|    390|            let h2 = self.hash2.hash(key, table_size);
   33|    390|            let h2_safe = if h2 == 0 { 1 } else { h2 };
  147|     20|            let h2_value = self.hash2.hash(key, table_size);
  150|     20|            let h2_value = if h2_value == 0 { 1 } else { h2_value };
  153|     27|            let h2_value = if h2_value == 0 { 1 } else { h2_value };
  203|      2|            let h2_value = self.hash2.hash(key, table_size);
  204|      2|            let h2_value = if h2_value == 0 { 1 } else { h2_value };
  243|     29|            let h2_value = self.hash2.hash(key, table_size);
  244|     29|            (h1_value, h2_value)
  251|     29|            let h2_value = self.hash2.hash(key, table_size);
  252|     29|            let h2_value = if h2_value == 0 { 1 } else { h2_value };
  271|     82|            let h2_value = self.hash2.hash(key, table_size);
  273|     82|            let h2_value = if h2_value == 0 { 1 } else { h2_value };
   57|     26|            if h2_value == 0 {
   84|     50|            if h2_value == 0 || table_size == 0 {
  408|      1|            hash_fn: &H,
   82|  22.9k|                    Self::update(&mut h);
   88|    107|                    Self::update(&mut h);
   91|     15|                e.hash(&mut h);
   95|     20|            AdvancedLinearProbingStrategy<K, H>: ProbeSequence<K> + Clone,
   96|     21|            for h in element_hashes {
  107|       |    /// h_a,b(x) = ((ax + b) mod p) mod m
   30|     22|            let half = n / 2;
   32|     15|            let half = n / 2;
   42|     22|            let half = n / 2;
   44|     15|            let half = n / 2;
  102|       |            // Handle wrap-around cluster
  104|      6|                    let handle = thread::spawn(move || (i, f_clone(i)));
  138|     29|                        let handle1 = thread::spawn(move || 1 + self_clone1.med_recursive_parallel(i, j - 1));
  140|     22|                        let handle1 = thread::spawn(move || 1 + self_clone1.med_recursive_parallel(i, j - 1));
  136|    105|            let handle = std::thread::spawn(move || <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::map(&left, f_clone));
  136|      5|            let handle = thread::spawn(move || {
  162|    112|                let handle = std::thread::spawn(move || if pred_clone(&value) == true { Some(value) } else { None });
  168|    115|            for handle in handles {
   72|    103|                        let handle1 = thread::spawn(move || self_clone1.subset_sum_rec(i - 1, j - element_value));
   73|     54|            let handle1 = thread::spawn(move || self_clone1.parallel_min_reduction(left_costs));
   78|     77|                        let handle1 = thread::spawn(move || self_clone1.min_edit_distance_rec(i - 1, j));
   79|     29|            let handle1 = thread::spawn(move || self_clone1.parallel_min_reduction(left_costs));
   82|    108|            let handle1 = thread::spawn(move || self_clone1.parallel_min_reduction(left_costs));
   82|     45|                        let handle1 = thread::spawn(move || self_clone1.subset_sum_rec(i - 1, j - element_value));
  183|     11|                let handle = std::thread::spawn(move || pred_clone(&value));
   89|     28|            let handle1 = thread::spawn(move || self_clone1.parallel_min_reduction(left_costs));
  194|      4|            let handle = thread::spawn(move || {
   94|     96|                        let handle1 = thread::spawn(move || self_clone1.min_edit_distance_rec(i - 1, j));
  195|      8|                let handle = std::thread::spawn(move || f_clone(&value));
  201|     10|            for handle in handles {
  140|     29|                        let handle2 = thread::spawn(move || 1 + self_clone2.med_recursive_parallel(i - 1, j));
  142|     22|                        let handle2 = thread::spawn(move || 1 + self_clone2.med_recursive_parallel(i - 1, j));
  220|     12|                let handle = std::thread::spawn(move || pred_clone(&value));
  234|    106|                let handle = std::thread::spawn(move || {
  248|      6|                let handle = thread::spawn(move || {
  251|      3|            let handle = thread::spawn(move || {
  255|      1|    // Handle not found case
   74|    103|                        let handle2 = thread::spawn(move || self_clone2.subset_sum_rec(i - 1, j));
   75|     54|            let handle2 = thread::spawn(move || self_clone2.parallel_min_reduction(right_costs));
   80|     77|                        let handle2 = thread::spawn(move || self_clone2.min_edit_distance_rec(i, j - 1));
   81|     29|            let handle2 = thread::spawn(move || self_clone2.parallel_min_reduction(right_costs));
   84|    108|            let handle2 = thread::spawn(move || self_clone2.parallel_min_reduction(right_costs));
   84|     45|                        let handle2 = thread::spawn(move || self_clone2.subset_sum_rec(i - 1, j));
   91|     28|            let handle2 = thread::spawn(move || self_clone2.parallel_min_reduction(right_costs));
  293|      1|   - Handle edge cases (h2 = 0 in double hashing)
   96|     96|                        let handle2 = thread::spawn(move || self_clone2.min_edit_distance_rec(i, j - 1));
  142|     29|                        let handle3 = thread::spawn(move || 1 + self_clone3.med_recursive_parallel(i - 1, j - 1));
  144|     22|                        let handle3 = thread::spawn(move || 1 + self_clone3.med_recursive_parallel(i - 1, j - 1));
   40|       |            // Handle odd-length sequences: last element unpaired
  433|      9|            let handle = thread::spawn(move || {
  487|      2|                let handle = thread::spawn(move || {
   54|       |            // Handle last element if odd length
   55|       |            // Handle odd-length sequences: last element unpaired
  569|      4|            let handle = thread::spawn(move || {
  625|      4|            let handle = thread::spawn(move || {
   74|       |            // Handle NaN and infinity cases properly
   83|       |            // Handle last element if odd length
   96|      4|            let handle = thread::spawn(move || {
   99|      5|        for handle in handles {
  113|     21|                handles.into_iter().map(|handle| handle.join().unwrap()).collect();
  113|     21|                handles.into_iter().map(|handle| handle.join().unwrap()).collect();
  142|     30|                    let handle_left = s.spawn(move || Self::merge_parallel(&*ll, &*rl));
   96|     26|                    let handle_left = s.spawn(move || Self::merge_parallel(&*ll, &*rl));
   97|     13|            let handles: Vec<_> = positions
   97|     16|            let handles: Vec<_> = positions
  102|     51|        fn has_arc(&self, from: &V, to: &V) -> bool {
   46|       |        fn has_arc(&self, from: &V, to: &V) -> bool;
   50|       |        fn has_arc(&self, from: &V, to: &V) -> bool;
   96|     23|        fn has_arc(&self, from: &V, to: &V) -> bool {
   15|       |        fn has_cycle(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>) -> B;
   15|       |        fn has_cycle(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>) -> B;
  106|     14|        fn has_edge(&self, v1: &V, v2: &V) -> bool {
  112|     93|        fn has_edge(&self, v1: &V, v2: &V) -> bool {
   24|       |        fn has_edge(&self, u: N, v: N) -> B;
   25|       |        fn has_edge(&self, u: N, v: N) -> B;
   25|       |        fn has_edge(&self, u: N, v: N) -> B;
   25|       |        fn has_edge(&self, u: &V, v: &V) -> B;
   26|       |        fn has_edge(&self, u: N, v: N) -> B;
   29|       |        fn has_edge(&self, u: &V, v: &V) -> B;
   29|       |        fn has_edge(&self, u: &V, v: &V) -> B;
   30|       |        fn has_edge(&self, u: &V, v: &V) -> B;
   31|       |        fn has_edge(&self, u: &V, v: &V) -> B;
   33|       |        fn has_edge(&self, u: &V, v: &V) -> B;
   46|       |        fn has_edge(&self, v1: &V, v2: &V) -> bool;
   50|       |        fn has_edge(&self, v1: &V, v2: &V) -> bool;
   60|      7|        fn has_edge(&self, u: N, v: N) -> B {
   62|     16|        fn has_edge(&self, u: &V, v: &V) -> B { self.adj.find(u).map_or(false, |neighbors| neighbors.find(v)) }
   65|      3|        fn has_edge(&self, u: &V, v: &V) -> B { self.edges.find(&Pair(u.clone(), v.clone())) }
   65|      8|        fn has_edge(&self, u: N, v: N) -> B {
   67|      7|        fn has_edge(&self, u: &V, v: &V) -> B { self.edges.find(&Pair(u.clone(), v.clone())) }
   69|      3|        fn has_edge(&self, u: &V, v: &V) -> B { self.edges.find(&Pair(u.clone(), v.clone())) }
   69|      6|        fn has_edge(&self, u: N, v: N) -> B {
   74|      7|        fn has_edge(&self, u: N, v: N) -> B {
   81|     14|        fn has_edge(&self, u: &V, v: &V) -> B {
   81|      9|        fn has_edge(&self, u: &V, v: &V) -> B {
  117|     56|            let hash1 = (table.hash_fn)(key);
  312|      1|        let hash1 = DefaultHashFunction;
  133|      2|The nested hash table can be implemented using the Table ADT as follows:
  336|      1|        let hash1 = DefaultHashFunction;
   55|     11|        let hash1 = StringPositionHashFunction;
  158|      2|Exercise 47.2: Hash Table Size Reduction
   68|      4|        let hash1 = hash_family.generate(seed1);
  180|       |    /// Hash function combiner for creating probe sequences
  313|      1|        let hash2 = DefaultHashFunction; // In practice, would use different hash functions
  315|      1|            AdvancedDoubleHashingStrategy::new(hash1, hash2);
  337|      1|        let hash2 = DefaultHashFunction;
  339|      1|            AdvancedDoubleHashingStrategy::new(hash1, hash2);
  249|       |    /// Hash table statistics for analysis
   56|     11|        let hash2 = PolynomialHashFunction::new(31); // Common polynomial base
   69|      4|        let hash2 = hash_family.generate(seed2);
    2|       |//! Chained Hash Table - Sequential Ephemeral (Chapter 47).
    2|       |//! Flat Hash Table - Sequential Ephemeral (Chapter 47).
  300|      0|                "  Hash function independence: {:.3}",
  317|     10|            output.push_str(&format!("  hash('{}') = {}\n", key, hash_val));
  332|      2|             independent hash functions. When gcd(h₂(k), m) = 1, the probe sequence visits \
   44|       |    impl<K: Hash> HashFunction<K> for DefaultHashFunction {
   92|       |    impl Hash for Probability {
  109|      0|            let hash_code = hash_fn.hash(key, table_size);
  118|     99|            let hash_code = self.hash_function.hash(key, table_size);
  129|      0|            let hash_code = hash_fn.hash(key, table_size);
  134|      3|            let hash_code = self.hash_function.hash(key, table_size);
  204|      0|            let hash_code = hash_fn.hash(&key, table_size);
  205|    129|            let hash_code = self.hash_function.hash(&key, table_size);
   46|      2|            let hash_code = hash_fn.hash(&key, table_size);
   57|    122|            let hash_code = self.hash_function.hash(&key, table_size);
  315|      1|        let hash_demo = example_47_1_demonstration();
   47|  1.38k|            key.hash(&mut hasher);
    8|       |use std::hash::{Hash, Hasher};
    4|       |pub mod HashExamples {
   51|      2|        let hash_family = UniversalIntegerHashFamily::new();
   66|      2|        let hash_family = UniversalIntegerHashFamily::new();
   67|      4|        let hash_family = UniversalIntegerHashFamily::new();
  107|      0|            let hash_fn = DefaultHashFunction;
  118|     25|                base_hash: hash_fn,
  127|      0|            let hash_fn = DefaultHashFunction;
  131|     42|                base_hash: hash_fn,
  144|      4|                base_hash: hash_fn,
  168|       |        type HashFn = UniversalIntegerHashFunction;
   18|     38|                base_hash: hash_fn,
   20|     18|                base_hash: hash_fn,
  202|      0|            let hash_fn = DefaultHashFunction;
  244|      1|        let hash_fn = DefaultHashFunction;
   25|       |        pub hash_fn: HashFun<Key>,
   31|       |        type HashFn: HashFunction<K>;
  339|      1|        let hash_fn = DefaultHashFunction;
   35|     66|                base_hash: hash_fn,
  363|      1|        let hash_fn = DefaultHashFunction;
   38|      2|        let hash_fn = example_47_1_hash_function();
   44|      2|            let hash_fn = DefaultHashFunction;
   45|      2|                base_hash: hash_fn,
   46|     24|                hash_function: hash_fn,
   52|      2|        let hash_fn = hash_family.generate(seed);
   67|      2|        let hash_fn = hash_family.generate(seed);
   68|      2|        let hash_fn = StringPositionHashFunction;
   71|       |    // HashFunClone: Combines HashFunction and Clone for Chapter 47 hash tables
  363|       |            impl HashFunction<$key_type> for $name {
  123|       |    impl HashFunction<i32> for UniversalIntegerHashFunction {
   28|       |        pub hash_function_independence: f64,
   16|       |        H: HashFunction<K> + Clone,
   30|       |        H: HashFunction<K> + Clone,
   59|       |    impl HashFunction<String> for StringPositionHashFunction {
   89|       |    impl HashFunction<String> for PolynomialHashFunction {
  385|       |    impl HashFunctionTester {
    4|       |pub mod HashFunctionTraits {
  140|      2|- createTable(eq_fn, hash_gen, size): Initialize array with empty Table instances
   86|      6|        fn hash<H: Hasher>(&self, state: &mut H) {
   93|      0|        fn hash<H: Hasher>(&self, state: &mut H) { self.0.to_bits().hash(state); }
  103|      7|        fn hash_index(table: &HashTable<Key, Value, ChainList<Key, Value>, Metrics>, _key: &Key) -> N {
   26|       |        fn hash_index(table: &HashTable<Key, Value, Entry, Metrics>, key: &Key) -> N;
   68|      7|        fn hash_index(table: &HashTable<Key, Value, Vec<(Key, Value)>, Metrics>, _key: &Key) -> N {
   78|      7|        fn hash_index(table: &HashTable<Key, Value, LinkedList<(Key, Value)>, Metrics>, _key: &Key) -> N {
    2|       |//! Double Hashing Flat Hash Table - Sequential Ephemeral (Chapter 47).
  370|      2|             Double hashing maintains good performance even at high load factors, while linear \
    5|       |//! using HashMap for efficient subproblem caching.
    5|       |//! using HashMap with in-place mutations for efficient subproblem caching.
  100|      7|                memo: HashMap::new(),
  103|      1|                memo: HashMap::new(),
  103|      4|                memo: HashMap::new(),
  104|     18|                memo: HashMap::new(),
  105|      2|                memo: HashMap::new(),
  111|      2|                memo: HashMap::new(),
  111|     30|                memo: HashMap::new(),
  112|      4|                memo: HashMap::new(),
  115|     10|                memo: HashMap::new(),
  116|     27|                memo: HashMap::new(),
  123|      2|                memo: HashMap::new(),
  127|     10|                memo: HashMap::new(),
  141|      1|                memo_table: HashMap::new(),
  168|      0|                parent: HashMap::new(),
  169|      0|                rank: HashMap::new(),
  173|      0|            return HashMap::new();
  189|     42|            return HashMap::new();
   42|     16|                memo_table: HashMap::new(),
   42|     16|                memo_table: HashMap::new(),
   52|     21|                parent: HashMap::new(),
   53|     21|                rank: HashMap::new(),
   78|      0|            return HashMap::new();
   83|      1|                memo: HashMap::new(),
   88|      1|                memo: HashMap::new(),
   90|     16|                memo: HashMap::new(),
   91|      3|                memo: HashMap::new(),
   92|      1|                memo: HashMap::new(),
   93|      3|                memo: HashMap::new(),
   96|     25|                memo: HashMap::new(),
   99|     12|                memo: HashMap::new(),
  121|     19|        distances: &HashMap<usize, i64>,
  130|     19|        distances: &HashMap<usize, OrderedF64>,
   16|       |        memo: HashMap<(usize, i32), bool>,
   16|       |        memo: HashMap<(usize, i32), bool>,
   17|       |        memo: HashMap<(usize, usize), usize>,
   17|       |        memo: HashMap<(usize, usize), usize>,
   21|       |        memo: HashMap<(usize, usize), usize>,
   21|       |        memo: HashMap<(usize, usize), usize>,
   23|       |        memo: HashMap<(usize, usize), Probability>,
   23|       |        memo: HashMap<(usize, usize), Probability>,
   33|       |        memo_table: HashMap<(usize, usize), usize>,
   33|       |        memo_table: HashMap<(usize, usize), usize>,
  114|     25|        bridges: &HashMap<V, (V, OrderedFloat<f64>, usize)>,
  121|     23|        partition_map: &HashMap<V, V>,
  122|     11|        partition_map: &HashMap<V, V>,
  136|     20|        bridges: HashMap<V, (V, OrderedFloat<f64>, usize)>,
  181|       |                      partition_map: &HashMap<V, V>,
  192|      8|        partition_map: &HashMap<V, V>,
  193|      8|        component_map: &HashMap<V, V>,
  240|       |                      partition_map: &HashMap<V, V>,
   34|       |            distances: &HashMap<(V, V), OrderedFloat<f64>>,
   36|       |            distances: &HashMap<(V, V), OrderedFloat<f64>>,
   40|       |            distances: &HashMap<(V, V), OrderedFloat<f64>>,
   41|       |        parent: HashMap<V, V>,
   42|       |            distances: &HashMap<(V, V), OrderedFloat<f64>>,
   42|       |        rank: HashMap<V, usize>,
   53|       |                      partition_map: &HashMap<V, V>,
   56|       |                      partition_map: &HashMap<V, V>,
   82|     14|        partition_map: &HashMap<V, V>,
   87|     22|        partition_map: &HashMap<V, V>,
  114|       |    // HashOrd: Type that can be hashed and ordered (for graph vertices)
  117|       |    impl<T> HashOrd for T where T: StT + Hash + Ord {}
  138|       |    impl<V: HashOrd, L: StT + Hash> LabUnDirGraphStEph<V, L> {
  158|       |    impl<V: HashOrd, L: StT + Hash> Display for LabUnDirGraphStEph<V, L> {
  164|       |    impl<V: HashOrd, L: StT + Hash> Debug for LabUnDirGraphStEph<V, L> {
  188|       |    impl<V: HashOrd + MtT, L: StTInMtT + Hash> LabUnDirGraphMtEph<V, L> {
  208|       |    impl<V: HashOrd + MtT, L: StTInMtT + Hash> Display for LabUnDirGraphMtEph<V, L> {
   20|       |    impl<V: HashOrd + MtT + 'static> WeightedUnDirGraphMtEphFloat<V> {
   20|       |    impl<V: HashOrd + MtT + 'static> WeightedUnDirGraphMtEphInt<V> {
  214|       |    impl<V: HashOrd + MtT, L: StTInMtT + Hash> Debug for LabUnDirGraphMtEph<V, L> {
   55|       |    impl<V: HashOrd, L: StT + Hash> LabUnDirGraphStEphTrait<V, L> for LabUnDirGraphStEph<V, L> {
   59|       |    impl<V: HashOrd + MtT + 'static, L: StTInMtT + Hash + 'static> LabUnDirGraphMtEphTrait<V, L>
  164|    827|                let hash_pos = self.probe_sequence.probe_hash(key, probe_index, table_size);
  192|     22|                let hash_pos = self.probe_sequence.probe_hash(key, probe_index, table_size);
  263|    523|                let hash_pos = self.probe_sequence.probe_hash(&key, probe_index, table_size);
   86|     80|                    let hash_pos = linear_probe.probe_hash(&key, i, table_size);
   86|    870|                let hash_pos = self.probe_sequence.probe_hash(&key, probe_index, table_size);
  125|     48|        fn hash(&self, key: &i32, table_size: N) -> N {
   14|       |        fn hash(&self, key: &K, table_size: N) -> N;
  364|     60|                fn hash(&self, key: &$key_type, table_size: N) -> N {
   45|  1.38k|        fn hash(&self, key: &K, table_size: N) -> N {
   62|  2.40k|        fn hash(&self, key: &String, table_size: N) -> N {
   91|    396|        fn hash(&self, key: &String, table_size: N) -> N {
   14|       |        data: HashSet<T>,
  260|       |    impl HashTableStats {
  303|       |    impl HashTableUtils {
  105|      7|            let hash_val = 0; // Placeholder: would use actual hash function
   70|      7|            let hash_val = 0; // Placeholder: would use actual hash function
   80|    103|            let hash_val = (table.hash_fn)(key);
   80|      7|            let hash_val = 0; // Placeholder: would use actual hash function
   81|     13|            let hash_val = (table.hash_fn)(key);
  127|     48|            let hash_value = ((self.a * x + self.b) % self.p) as N;
  365|     60|                    let hash_value = $hash_expr(key);
  393|      5|                let hash_value = hash_fn.hash(key, table_size);
   57|     20|                let hash_value = hash_fn.hash(&s, table_size);
   58|     20|                (s, hash_value)
   35|       |        fn has_path(&self, u: N, v: N) -> B;
   36|       |        fn has_path(&self, u: N, v: N) -> B;
   37|       |        fn has_path(&self, u: N, v: N) -> B;
   38|       |        fn has_path(&self, u: N, v: N) -> B;
   22|       |        pub head: Option<Box<Node<Key, Value>>>,
   44|  8.12k|                let head = self.head.load(Ordering::Acquire);
   77|  7.89k|                let head = self.head.load(Ordering::Acquire);
   45|  8.12k|                if head.is_null() {
  107|      0|        output.push_str(&format!("Binary heap result: {:?}\n\n", textbook.binary_heap_result));
  114|      0|        output.push_str(&format!("Binary heap result: {:?}\n\n", reverse.binary_heap_result));
  121|      0|        output.push_str(&format!("Binary heap result: {:?}\n\n", sorted.binary_heap_result));
  128|      0|        output.push_str(&format!("Binary heap result: {:?}\n\n", duplicates.binary_heap_result));
  257|      2|            let heap = Self::empty();
  341|      2|            for heap in &heaps[1..] {
  209|    487|            let heapified = temp_pq.bubble_up(last_index);
  238|    214|            let heapified = self.bubble_down(0, &new_elements);
  249|      5|            let heapified = self.heapify(&merged);
  258|      2|            let heapified = heap.heapify(seq);
  156|      7|        fn heapify(&self, seq: &ArraySeqStPerS<T>) -> ArraySeqStPerS<T> {
  420|      0|        let heaps: Vec<LeftistHeapPQ<T>> = sequences.into_iter().map(|seq| LeftistHeapPQ::from_seq(&seq)).collect();
  336|      2|            if heaps.is_empty() {
  274|     12|            while heaps.len() > 1 {
  114|       |    /// Heapsort using LeftistHeapPQ
  163|      0|        output.push_str("- Heapsort is stable across different input patterns\n");
   17|       |        /// Heapsort using UnsortedListPQ
   21|       |        /// Heapsort using SortedListPQ  
   25|       |        /// Heapsort using BalancedTreePQ
   29|       |        /// Heapsort using BinaryHeapPQ
   33|       |        /// Heapsort using LeftistHeapPQ
   42|       |    /// Heapsort using UnsortedListPQ
   60|       |    /// Heapsort using SortedListPQ  
   78|       |    /// Heapsort using BalancedTreePQ
   96|       |    /// Heapsort using BinaryHeapPQ
  138|     13|            balanced_tree_result: heapsort_balanced_tree(sequence),
   27|       |        fn heapsort_balanced_tree<T: StT + Ord>(sequence: &[T]) -> Vec<T>;
  139|     13|            binary_heap_result: heapsort_binary_heap(sequence),
   31|       |        fn heapsort_binary_heap<T: StT + Ord>(sequence: &[T]) -> Vec<T>;
    4|       |pub mod HeapsortExample {
  140|     13|            leftist_heap_result: heapsort_leftist_heap(sequence),
   35|       |        fn heapsort_leftist_heap<T: StT + Ord>(sequence: &[T]) -> Vec<T>;
  137|     13|            sorted_list_result: heapsort_sorted_list(sequence),
   23|       |        fn heapsort_sorted_list<T: StT + Ord>(sequence: &[T]) -> Vec<T>;
  136|     13|            unsorted_list_result: heapsort_unsorted_list(sequence),
   19|       |        fn heapsort_unsorted_list<T: StT + Ord>(sequence: &[T]) -> Vec<T>;
   29|       |//! let heavy_edges = graph.edges_above_weight(OrderedFloat(3.0));
   16|       |        pub height: N,
   21|       |        pub height: N,
   57|      0|            if height(&left.right) > height(&left.left) {
   57|      0|            if height(&left.right) > height(&left.left) {
   72|  5.59k|        fn height_link(link: &Link<T>) -> i32 { link.as_ref().map_or(0, |n| n.height) }
   72|  74.9k|        fn height_link(link: &Link<T>) -> i32 { link.as_ref().map_or(0, |n| n.height) }
   68|  13.9k|    fn height_of<T: StTInMtT + Ord>(link: &Option<Node<T>>) -> i32 { link.as_ref().map_or(0, |n| n.height) }
  186|    201|            fn height_rec<K: StT + Ord, V: StT>(link: &Link<K, V>) -> N {
  292|    205|            fn height_rec<K: StT + Ord, V: StT, R: StT>(link: &Link<K, V, R>) -> N {
  156|    129|            fn height_rec<T: StT + Ord>(link: &Link<T>) -> N {
  177|    180|            fn height_rec<T: StTInMtT + Ord>(link: &Link<T>) -> N {
  188|    144|            fn height_rec<T: StT + Ord>(link: &Link<T>) -> N {
  209|    698|            fn height_rec<T: StTInMtT + Ord>(link: &Link<T>) -> N {
  213|    359|            fn height_rec<T: StT + Ord>(link: &Link<T>) -> N {
  216|    645|            fn height_rec<T: StTInMtT + Ord>(link: &Link<T>) -> N {
  232|    308|            fn height_rec<T: StT + Ord>(link: &Link<T>) -> N {
  235|      0|            fn height_rec<T: StT + Ord>(link: &Link<T>) -> N {
  243|  2.00k|            fn height_rec<T: StT + Ord>(link: &Link<T>) -> N {
  271|  11.8k|            fn height_rec<T: StTInMtT + Ord>(link: &Link<T>) -> N {
   75|    129|            fn height_rec<T: StT + Ord>(link: &Link<T>) -> N {
   65|      0|            if height(&right.left) > height(&right.right) {
   65|      0|            if height(&right.left) > height(&right.right) {
  120|      0|        fn height(&self) -> N { BalBinTree::height(self) }
  143|     11|        fn height(&self) -> N {
  155|     14|        fn height(&self) -> N {
  155|      1|        fn height(&self) -> N {
  176|      8|        fn height(&self) -> N {
  185|      1|        fn height(&self) -> N {
  187|      6|        fn height(&self) -> N {
  208|     12|        fn height(&self) -> N {
  212|     13|        fn height(&self) -> N {
  215|     13|        fn height(&self) -> N {
  231|     10|        fn height(&self) -> N {
  231|     16|        fn height(&self) -> N {
  234|      0|        fn height(&self) -> N {
  242|      1|        fn height(&self) -> N {
   25|       |        fn height(&self) -> N;
  270|     18|        fn height(&self) -> N {
  291|      3|        fn height(&self) -> N {
   44|       |        fn height(&self) -> N;
   46|       |        fn height(&self) -> N;
   48|       |        fn height(&self) -> N;
   48|       |        fn height(&self) -> N;
   48|       |        fn height(&self) -> N;
   48|       |        fn height(&self) -> N;
   49|       |        fn height(&self) -> N;
   54|       |        fn height(&self) -> N;
   54|       |        fn height(&self) -> N;
   56|       |        fn height(&self) -> N;
   56|       |        fn height(&self) -> N;
   56|       |        fn height(&self) -> N;
   57|      8|        fn height(&self) -> N { self.root.height() }
   58|       |        fn height(&self) -> N;
   58|       |        fn height(&self) -> N;
   89|       |        fn height(&self) -> N;
   22|  22.7k|    fn height<T: StTInMtT>(n: &Link<T>) -> N { n.as_ref().map_or(0, |r| r.height) }
   22|  2.47M|    fn height<T: StT>(n: &Link<T>) -> N { n.as_ref().map_or(0, |r| r.height) }
   10|       |        /// Helper function to check divisibility
  115|       |    /// Helper: Build quotient graph edges by routing through partition map
  116|       |    /// Helper: Build quotient graph edges in parallel
  125|       |    /// Helper function to convert document set to sorted vector for testing
  135|       |    /// Helper: Get neighbors of a vertex
  144|       |            // Helper for filter: deflate f x = if f(x) then [x] else []
  149|       |    /// Helper: Get edge weight between two vertices
  159|       |            // Helper for filter: deflate f x = if f(x) then [x] else []
  161|       |            // Helper for filter: deflate f x = if f(x) then [x] else []
  166|       |    /// Helper to get neighbors of a vertex
  176|       |        /// Helper function to create an empty index
  180|       |    /// Helper to get edge weight
  186|       |    /// Helper: Compose maps in parallel (P ∘ C)
  186|       |    /// Helper to get neighbors of a vertex
   19|       |    /// Helper function to check divisibility
  200|       |    /// Helper to get edge weight between two vertices
  211|       |    /// Helper: Create Borůvka MST with a specific seed
  216|       |        /// Helper for filter: deflate f x = if f(x) then [x] else []
   23|       |    /// Helper to find max suffix sum (MCSSE problem).
   26|       |    /// Helper to find max suffix sum using inclusive prefix sums.
  288|       |    /// Helper function for macro construction
  289|       |    /// Helper function for creating tables from sorted entries
  310|       |            // Helper for filter: deflate f x = if f(x) then [x] else []
  310|       |    /// Helper function for macro construction
  312|       |    /// Helper: Create Borůvka MST with a specific seed
  312|       |            // Helper for filter: deflate f x = if f(x) then [x] else []
  325|       |    /// Helper function for creating tables from sorted entries
  328|       |        /// Helper to recalculate reduction from current base table
  333|       |        /// Helper to calculate reduction from any base table
  350|       |    /// Helper function for macro construction
  363|       |        /// Helper to recalculate reduction from base table
  366|       |    /// Helper function for macro construction
  367|       |        /// Helper to recalculate reduction from current base table
  368|       |        /// Helper to calculate reduction from any base table
  372|       |        /// Helper to calculate reduction from any base table
  394|       |    /// Helper function for macro construction
   41|       |    /// Helper to find max prefix sum (MCSSS problem).
   43|       |    /// Helper to find max prefix sum using inclusive prefix sums.
   46|       |        /// Helper methods
   46|       |        /// Helper methods
   46|       |        /// Helper methods
   46|       |        /// Helper methods
   53|       |        /// Helper functions for heap navigation
   59|       |        /// Helper methods
  662|       |    /// Helper function for creating tables from sorted entries
   78|       |            // Helper: find minimum priority vertex in frontier
   88|       |            // Helper: find minimum priority vertex in frontier
  102|     16|                if hi <= lo + 1 {
  137|     14|                if hi <= lo + 1 {
   54|     24|                if hi <= lo + 1 {
  274|       |                // Higher clustering coefficient and variance indicate worse clustering
  231|      1|Exercise 47.6: Higher-Order Function for Flat Hash Tables
   34|       |    /// Higher-order recursive star contraction:
   38|       |    /// Higher-order recursive star contraction with parallelism:
    5|       |//! A higher-order function that recursively contracts a graph using star partitions.
  227|   150M|        let hl = h(&n.left);
  256|  97.2M|        let hl = h(&n.left);
  258|  97.2M|        if hl > hr.saturating_add(1) {
   26|  11.3k|        let hl = height(&left);
   26|  1.23M|        let hl = height(&left);
  333|     38|        let hl = h(&n.left);
  366|     20|        let hl = h(&n.left);
  368|     20|        if hl > hr.saturating_add(1) {
   53|     37|        let hl = height(&n.left);
   53|      6|        let hl = height(&n.left);
   55|     37|        if hl > hr.saturating_add(1) {
   55|      6|        if hl > hr.saturating_add(1) {
  259|      0|            if h(&n.left.as_ref().unwrap().right) > h(&n.left.as_ref().unwrap().left) {
  370|      0|            if h(&n.left.as_ref().unwrap().right) > h(&n.left.as_ref().unwrap().left) {
  266|  17.6M|            if h(&n.right.as_ref().unwrap().left) > h(&n.right.as_ref().unwrap().right) {
  378|      6|            if h(&n.right.as_ref().unwrap().left) > h(&n.right.as_ref().unwrap().right) {
    5|       |//! Demonstrates how negative weight cycles affect shortest path calculations.
  228|   150M|        let hr = h(&n.right);
  257|  97.2M|        let hr = h(&n.right);
  265|  97.2M|        if hr > hl.saturating_add(1) {
   27|  11.3k|        let hr = height(&right);
   27|  1.23M|        let hr = height(&right);
  334|     38|        let hr = h(&n.right);
  367|     20|        let hr = h(&n.right);
  376|     20|        if hr > hl.saturating_add(1) {
   54|     37|        let hr = height(&n.right);
   54|      6|        let hr = height(&n.right);
   63|     37|        if hr > hl.saturating_add(1) {
   63|      6|        if hr > hl.saturating_add(1) {
  214|   530M|    fn h<T: StT>(n: &Link<T>) -> N { n.as_ref().map_or(0, |b| b.height) }
  321|    128|    fn h<T: Copy + Debug>(n: &Link<T>) -> N { n.as_ref().map_or(0, |b| b.height) }
   55|       |    /// h(x) = (Σ pos(x[i])) mod m
   79|       |    /// h(x) = (Σ x[i] * base^i) mod m
  184|      2|- Use hysteresis (different thresholds for grow/shrink)
  100|    222|        for (i, vertex) in vertices_vec.iter().enumerate() {
  101|      0|            for (i, item) in self.data.iter().enumerate() {
  101|     10|            for i in 0..self.universe_size {
  101|  1.52k|            for i in 0..n {
  101|     20|        for i in 0..=n {
  101|    533|            for i in 0..word_entries.length() {
  102|      0|                if i > 0 {
  102|     14|            for i in 0..selected_seq.length() {
  103|    128|            for i in 0..other_len {
  103|      6|            for (i, item) in self.data.iter().enumerate() {
  104|    111|            for i in 1..n {
  104|     28|        for i in 0..seq.length() {
  104|     38|            for i in 0..self.elements.length() {
  104|  5.50k|            for i in 1..self.elements.length() {
  104|      6|                if i > 0 {
  105|     28|            if i > 0 {
  105|     47|                    for i in 0..neighbors_seq.length() {
  105|  5.17k|            for i in insert_pos..self.elements.length() {
  105|      8|            for i in 0..sources_seq.length() {
  105|      9|            for i in 0..left_keys.length() {
  106|     23|            for (i, v) in values.into_iter().enumerate() {
  106|     41|            for i in 0..self.adj.length() {
  106|      7|            for i in 0..self.elements.length() {
  107|     41|                if i == u {
  108|     11|            for i in 0..right_keys.length() {
  108|     15|        for i in 0..n {
  108|      1|                for i in 0..old_neighbors.length() {
  109|     15|            edges.insert((dummy_idx, i, OrderedFloat(0.0)));
  109|      2|        for i in 0..k - 1 {
  109|     30|                while i < gt {
  110|      0|        for i in 0..neighbors.length() {
  110|     20|        for i in 0..=n {
  110|     20|        for i in 0..neighbors.length() {
  110|      2|        for i in 0..k - 1 {
  111|      7|            for i in 0..a.length() {
  112|      0|            for i in 0..chain.length() {
  112|  1.53k|            for i in 0..n {
  112|     20|        for i in 0..neighbors.length() {
  113|      2|            for i in 0..seq.length() {
  113|    420|            for i in 0..self.max_probes.min(table_size) {
  114|     28|                for i in 0..selected_seq.length() {
  114|     43|                if i == index {
  114|     47|                    for i in 0..neighbors_seq.length() {
  114|  5.73k|            for i in 0..self.elements.length() {
  114|      7|            if i < len_a {
  115|      3|            for i in 0..self.n {
  115|  5.73k|                if i != min_index {
  115|     77|            for i in 0..self.elements.length() {
  116|    117|                for i in 0..n {
  117|  1.71k|            for i in 0..self.elements.length() {
  117|     34|            for (i, j, new_value) in results {
  117|     37|            for (i, j, new_value) in results {
  117|  4.94k|            for i in 0..table_size {
  117|     89|            for i in 0..self.elements.length() {
  118|     47|                    for i in 0..visited_seq.length() {
  119|  13.4k|                while i < gt {
  119|     23|                    for i in 0..neighbors_seq.length() {
  119|      9|                    if i == j {
  120|     16|            for i in 0..len {
  121|     10|            for i in 0..self.universe_size {
  121|    113|            for i in 0..chain.length() {
  121|     15|        for i in 0..n {
  121|   430k|                    while i < gt {
  121|  9.14k|                        data.swap(lt, i);
  122|     15|            edges.insert((dummy_idx, i, 0));
  123|     15|        for i in 0..n {
  123|  37.8k|                            data.swap(lt, i);
  124|      3|                | (i, 0) => i, // Delete all remaining characters from S
  125|      1|            for i in 0..old_neighbors.length() {
  125|     29|                | (i, j) => {
  125|  6.51k|            for i in 1..self.elements.length() {
  126|    108|                for i in 0..a.length() {
  126|     15|            while i < self.entries.length() && j < other.entries.length() {
  126|     23|                for i in 0..neighbors_seq.length() {
  126|      3|                | (i, 0) => i, // Delete all remaining characters from S
  127|     22|                | (i, j) => {
  127|  35.4k|            for i in 0..self.elements.length() {
  128|     39|            for i in 0..self.n {
  128|     47|                    for i in 0..visited_seq.length() {
  128|      8|                for i in 0..idx {
  129|     14|            for i in 0..sources_seq.length() {
  129|     39|                if i == u {
  129|   543k|            for i in 0..self.elements.length() {
  130|     22|        for i in 0..seq.length() {
  131|     37|                for i in (idx + 1)..len {
  132|  1.85k|            for i in 0..other.elements.length() {
  133|      0|            for i in 0..len {
  133|     10|            for i in 0..self.universe_size {
  133|    172|            for i in 0..len {
  133|     21|        for i in 0..seq.length() {
  133|     21|            while i < values1.len() && j < values2.len() {
  133|     23|                    for i in 0..visited_seq.length() {
  134|  10.8k|            for i in 0..other.elements.length() {
  134|     21|            if i > 0 {
  134|      3|            for i in 0..self.adj.length() {
  135|      0|            for i in 0..chain.length() {
  135|      3|                if i == u {
  135|    599|                for i in 0..self.elements.length() {
  137|    205|            for i in 0..entries.length() {
  138|     15|        for i in 0..n {
  138|      2|        for i in 0..k - 1 {
  139|     23|            for i in 0..visited_seq.length() {
  139|      2|        for i in 0..k - 1 {
  140|  1.16M|            for i in 0..self.elements.length() {
  140|     14|            for i in 0..sources_seq.length() {
  140|      3|            for i in 0..chain.length() {
  141|    110|                for i in 0..self_seq.length() {
  141|     15|            for i in 1..a.length() {
  142|  20.0M|            for i in 0..self.elements.length() {
  142|     38|            while i < self.entries.length() && j < other.entries.length() {
  143|     21|        for i in 0..seq.length() {
  143|      3|            for i in 1..a.length() {
  144|     19|            for i in 0..b.length() {
  144|     19|            for i in 0..len {
  144|     21|            if i > 0 {
  144|      3|            for i in 0..self.n {
  144|     61|            while i < self.elements.length() && j < other.elements.length() {
  144|      9|            while i < values1.len() {
  145|     10|            for i in 0..self.universe_size {
  145|      8|            for i in 0..sources_seq.length() {
  146|    112|                for i in 0..other_seq.length() {
  146|     29|                while i < gt {
  146|      5|            for i in 0..b.length() {
  149|    303|            for i in 0..entries.length() {
  149|   529k|            for i in 0..length {
  149|      9|                    if i == j {
  150|      0|            for i in 0..table_size {
  150|     41|            for i in 0..self.elements.length() {
  151|     16|            while i < self.entries.length() && j < other.entries.length() {
  151|    214|            for i in 0..entries.length() {
  153|      5|            for i in 0..elements.length() {
  153|     80|            for i in 0..size {
  154|  1.00k|        for i in 0..size {
  154|      3|        for i in 0..tour.len() - 1 {
  155|      8|            for i in 0..table_size {
  156|     15|        for i in 0..n {
  156|     42|        for i in 0..seq.length() {
  157|     42|            if i > 0 {
  157|  50.0k|            for i in 0..a.length() {
  157|      8|                for i in 0..n {
  159|    112|            for i in 0..a.length() {
  159|     28|        for i in 0..n {
  160|      2|        for i in 0..complex_results.length() {
  160|      7|            while i < self.elements.length() {
  160|  9.13k|                while i < gt {
  161|     15|            for i in 0..left_entries.length() {
  161|  2.35k|                    while i < gt {
  161|      2|            for i in 0..len {
  161|    447|                if i == index {
  162|  4.27k|                        data.swap(lt, i);
  162|      6|            for i in 0..seq.length() {
  163|  1.00k|        for i in 0..size {
  163|    995|                            data.swap(lt, i);
  163|      9|            for i in 0..a.length() {
  164|     19|            for i in 0..right_entries.length() {
  164|     65|                for i in 0..size {
  165|     49|            for i in 0..avl_seq.length() {
  166|     15|            for i in 0..entries.length() {
  166|     17|            for i in (0..=last_non_leaf).rev() {
  167|  20.0M|                for i in 0..size {
  167|  2.06M|            for i in 0..a.length() {
  167|    310|            for i in 0..entries.length() {
  170|      1|                for i in 0..idx {
  170|      3|            for (i, item) in guard.iter().enumerate() {
  171|      3|                if i > 0 {
  172|  1.00k|        for i in 0..size {
  172|      6|            for i in 0..intersection.entries.length() {
  173|  1.16M|                for i in 0..size {
  173|      1|                for i in (idx + 1)..len {
  173|      6|        for i in 0..tour.len() - 1 {
  174|     12|            for i in s..e {
  174|      7|            while i < self.entries.length() {
  176|      0|        for i in 0..seq.length() {
  176|     53|            for i in (0..size).rev() {
  177|      0|            if i > 0 {
  177|      9|            for i in 0..left_diff.entries.length() {
  178|  1.06k|            for i in 0..n {
  178|     12|            for i in 0..a.length() {
  178|  59.3k|            for i in 0..a.length() {
  179|     11|            for i in 0..a.length() {
  181|  1.20k|            for i in 1..sequence.len() {
  181|     25|            for i in (0..size).rev() {
  182|     10|            for i in 0..seq.length() {
  182|      9|            for i in 0..right_diff.entries.length() {
  183|    929|            for i in 0..len {
  185|      3|            for i in 0..self.elements.length() {
  186|      3|                if i > 0 {
  187|      0|            for i in 0..self.buckets.length() {
  187|    112|            for i in 0..entries.length() {
  188|     15|        for i in 0..n {
  188|     30|            for i in 0..entries.length() {
  189|    529|            for i in 0..a.length() {
  189|      9|            for i in 0..a.length() {
  190|     96|            for i in 0..size {
  191|     11|            for i in 0..keep_results.length() {
  191|     28|        for i in 0..n {
  191|      3|            for i in s..e {
  192|      0|            for i in 0..self.elements.length() {
  192|    160|            for i in 0..self.buckets.length() {
  192|    301|            for i in 0..size.min(100) {
  192|      8|            for i in 0..a.length() {
  193|      0|                if i > 0 {
  193|     72|            for i in s..e {
  194|     13|            while i < self.entries.length() && j < other.entries.length() {
  194|  4.47k|            for i in 0..length {
  195|      0|        for i in 0..seq.length() {
  195|     26|            for i in 0..size {
  196|      0|            if i > 0 {
  196|  1.88k|            for i in 0..len {
  197|  2.59M|            for i in 0..n {
  197|      8|            for i in 0..a.length() {
  199|     56|            while i < self.entries.length() && j < other.entries.length() {
  201|     26|            for i in 0..updates.length() {
  201|      5|            for i in 0..length {
  202|     15|            for i in 0..a.length() {
  203|      0|            for i in 0..elements.length() {
  203|      4|            for i in 0..a.length() {
  204|    161|                            for i in 0..table_size {
  205|      0|            for i in 0..self.elements.length() {
  206|      0|        for i in 0..seq.length() {
  206|      0|                if i > 0 {
  207|      0|            if i > 0 {
  208|  12.3k|            for i in 0..n {
  208|      7|            for i in 1..a.length() {
  209|      5|        for i in 0..tweets.length() {
  210|      0|            for i in 0..chain.length() {
  210|    159|                for i in 0..self_seq.length() {
  210|      5|            for i in 0..len {
  211|    129|            for i in 0..chain.length() {
  212|      0|            for i in 0..a.length() {
  212|      4|            for i in 0..elements.length() {
  213|    197|            for i in 0..a.length() {
  214|      0|        for i in 0..seq.length() {
  214|     11|            for i in 0..a.length() {
  214|      5|            while i < self.entries.length() {
  215|      0|            if i > 0 {
  215|    160|                for i in 0..other_seq.length() {
  215|     25|            for i in 0..self.length() {
  216|     12|            for i in 0..a.length() {
  217|     25|            while i < self.entries.length() {
  217|     29|            for i in (0..size).rev() {
  218|    528|            for i in 0..left_mapped.length() {
  221|    528|            for i in 0..right_mapped.length() {
  224|     26|            for i in 0..self.elements.length() {
  224|    311|            for i in 0..a.length() {
  224|      5|            for i in 0..a.length() {
  225|      0|            for i in 0..table_size {
  225|  14.5k|            for i in 0..len {
  226|  8.96k|            for i in 0..table_size {
  227|      7|            for i in 0..a.length() {
  228|     12|            for i in 0..a.length() {
  228|      9|            for i in 0..a.length() {
  230|     37|            for i in (0..size).rev() {
  230|      9|            for i in 0..self.elements.length() {
   23|  10.0k|            for i in 1..slice.len() {
  231|  1.29k|            for i in 1..(self.elements.length() - 1) {
  231|     30|            for i in 0..size {
  232|      0|            for i in 0..(self.elements.length() - 1) {
  235|     50|            for i in 0..a.length() {
  235|      7|            for i in 0..a.length() {
  238|      2|            for i in s..e {
  240|     14|            for i in 0..sorted_seq.length() {
  241|  10.9k|            for i in 0..na {
  241|      7|            for (i, current) in values.iter().enumerate() {
  242|    424|            for i in 0..a.length() {
  242|     86|            for i in 0..size {
  244|     36|            for i in 0..size {
  245|     19|            for i in 0..n {
  246|      3|            for i in 0..a.length() {
  247|    342|            for i in 0..self.table.length() {
  247|      8|            for i in 0..a.length() {
  248|     14|            for i in 0..size {
  249|     15|            for i in 0..a.length() {
  250|      0|            for i in 0..self.length() {
  250|     16|            for i in 0..size {
  251|      0|            for i in 0..self.elements.length() {
  252|      0|                if i > 0 {
  252|      4|                    if i < a.length() {
  253|     10|            for i in 0..n {
  253|     11|            for i in 0..a.length() {
  253|     14|            for i in 0..a.length() {
  253|     29|                for i in 0..left_entries.length() {
  256|     13|            if i >= seq.length() {
  256|     32|                for i in 0..filtered.length() {
  257|      6|            for i in 0..self.length() {
  259|    112|            for i in 0..self.buckets.length() {
  259|     37|            for i in (0..size).rev() {
  259|  4.74k|                for i in 0..updated.entries.length() {
  261|     13|            for i in 0..a.length() {
  261|      8|            for i in 0..size {
  263|     29|            for i in 0..right_entries.length() {
  264|      6|            if i >= seq.length() {
  265|      0|            for i in 0..seq.length() {
  265|   551k|                for i in 0..self.entries.length() {
  266|      0|            for i in 0..self.buckets.length() {
  266|      0|                if i > 0 {
  266|      3|            for i in 0..updates.length() {
  266|      6|            for i in 1..a.length() {
  268|     10|            if i >= size {
  270|      3|            for i in 0..updates.length() {
  270|  8.29k|                        if i < insert_pos {
  271|      0|            for i in 0..self.length() {
  272|      0|                if i > 0 {
  273|     13|            for i in 0..n {
  273|     36|            for i in 0..size {
  274|     16|            for i in 0..left_filtered.len() {
  274|     22|            for i in 0..a.length() {
  274|      8|            for i in 0..updates.length() {
  276|     10|                for i in 0..seq.length() {
  276|      1|            if i >= size {
  277|     13|            for i in 0..right_filtered.len() {
  277|     22|                if i < a.length() - 1 {
  277|      4|            for i in 0..elements.length() {
  278|    186|            for i in 0..size {
  278|     18|            for i in 0..a.length() {
  279|      0|            for i in 0..seq.length() {
  280|      0|                if i > 0 {
  281|     12|            for i in 0..a.length() {
   28|     20|        for i in 0..finish_order.length() {
  282|      0|            for i in 0..self.size() {
  282|      3|            for i in 0..self.elements.length() {
  283|      0|                if i > 0 {
  283|      3|                if i > 0 {
  284|      3|            for i in 0..pairs.length() {
  285|      5|            for i in 0..ss.length() {
  285|      9|            for i in 0..a.length() {
  286|     10|            for i in 0..a.length() {
  286|     17|            for i in 0..a.length() {
  286|     38|            for i in 0..updates.length() {
  286|   513k|                for i in 0..self.entries.length() {
  287|      9|        for i in 0..a_len {
  289|    289|            for i in 0..size {
  290|      8|            for i in 0..size {
  291|  5.74k|            for i in 0..table_size {
  291|      8|            for i in 0..a.length() {
   29|     20|        for i in 0..finish_order.length() {
  292|     15|            while i < self.entries.length() && j < other.entries.length() {
  295|      0|            for i in 0..self.size() {
  295|     70|            for i in 0..size {
  296|      0|            for i in 0..self.elements.length() {
  296|      0|                if i > 0 {
  296|     18|            for i in 0..a.length() {
  297|   518k|                        if i < insert_pos {
  297|      8|            for i in 0..a.length() {
  298|     18|                if i < a.length() - 1 {
  298|      5|            for i in 0..a.length() {
  299|      3|            for i in 0..a.length() {
  299|      8|                if i == index {
  301|     13|            if i < len_a {
  301|      4|            for i in 0..a.length() {
  302|     13|            for i in 0..a.length() {
  305|     12|            for i in 0..a_len {
   30|     54|                    let i = i0 + 2; // i in [2..=root]
  306|      0|            for i in 0..self.buckets.length() {
  306|    127|            for i in 0..size {
  309|      4|            for i in 0..a.length() {
  309|      9|            if i >= entries.length() {
  310|      0|            for i in 1..self.elements.length() {
  319|     16|            while i < self.entries.length() && j < other.entries.length() {
  319|      3|            for i in start_idx..end_idx {
  319|      4|            for i in 0..len {
  319|  7.97k|            for i in 0..size {
  320|     13|            if i >= entries.length() {
  320|      3|                if i < self.elements.length() {
  321|      4|            if i >= size {
   15|       |        height: i32,
   16|       |        height: i32,
   17|       |        height: i32,
   32|     24|        for i in 0..a.length() {
   32|     26|            for i in 0..n {
  322|      7|            for i in 0..ss.length() {
  323|      5|            for i in 0..a.length() {
  378|     58|        |key: &i32| (*key as N).wrapping_mul(2654435761), // Knuth's multiplicative hash
  325|      4|            for i in 0..a.length() {
  327|      8|            for i in 0..self.elements.length() {
   26|      0|            return i32::MIN / 2; // treat as -∞
   29|      0|            return i32::MIN / 2; // treat as -∞
   44|      0|            return i32::MIN / 2; // treat as -∞
   46|      0|            return i32::MIN / 2; // treat as -∞
  330|      8|            for i in (3..=sqrt_n).step_by(2) {
  332|      2|            if i >= size {
   33|    332|            for i in 0..n {
   33|    353|            for i in 0..n {
   33|    375|            for i in 0..n {
  334|     12|            for i in 0..a.length() {
  334|      5|            for i in 0..a.length() {
  336|    127|            for i in 0..size {
  338|      3|            for i in 0..self.elements.length() {
  338|      8|            for i in 0..a.length() {
  339|      3|                if i > 0 {
  339|      8|            for i in 0..updates.length() {
  340|      0|            for (i, item) in self.data.iter().enumerate() {
  341|      0|                if i > 0 {
  341|      4|            for i in 1..self.elements.length() {
   34|     24|        for i in 0..a.length() {
  342|      7|            while i < self.entries.length() {
  343|    131|            for i in 0..pairs.length() {
  343|    222|            for i in 0..ss.length() {
  344|     10|            for i in 0..self.length() {
  347|      3|            for i in 0..a.length() {
  347|      8|            for i in 0..self.table.length() {
  350|     14|            if i >= entries.length() {
  350|      6|            for i in 0..updates.length() {
   35|  1.03k|                for i in 0..key_size {
   35|     26|            for i in 0..n {
   35|    330|            for i in 0..n {
  355|    111|        for i in 0..len {
  357|      8|            for i in 0..a.length() {
  359|      5|            for i in 0..a.length() {
   36|      0|        for i in 0..a.length() {
   36|     12|                    for i in 0..components.length() {
  362|      2|            if i >= size {
  362|      7|            for i in 0..a.length() {
  363|     14|            while i < self.entries.length() && j < other.entries.length() {
  369|      2|            for i in 0..updates.length() {
  371|    109|        for i in 0..len {
  372|     10|            for i in 0..self.elements.length() {
  376|     11|            for i in 0..len {
  378|    120|            for i in 0..pairs.length() {
  379|    431|            for i in 0..updates.length() {
  379|      7|            for i in 0..a.length() {
  382|  3.81k|            for i in 0..pairs.length() {
  383|      5|            while i < self.entries.length() {
  384|      3|            for i in 0..self.elements.length() {
   38|     49|        for i in 0..seq.length() {
  387|      8|            for i in 0..ss.length() {
  388|      3|            for i in 0..a.length() {
  394|      5|            for i in 0..sorted_seq.length() {
   39|     49|            if i > 0 {
  397|     10|            for i in 0..self.elements.length() {
  399|  3.79k|        for i in 0..len {
  401|      7|            for i in 0..a.length() {
   40|     18|                for i in 0..neighbors.length() {
   40|     18|                for i in 0..neighbors.length() {
   41|     13|        for i in 0..neighbors.length() {
   41|     17|            for i in 0..n {
   41|     27|            for i in 0..n {
   41|     31|            for i in 0..=n {
  415|      7|            for i in 0..self.elements.length() {
  417|     10|            for i in 0..len {
   43|    228|                    if i % 2 == 0 {
  435|      0|            for (i, (strategy, score)) in self.performance_ranking.iter().enumerate() {
  435|      9|                for i in 0..left_entries.length() {
   44|     31|            for i in 0..=n {
  446|     13|            for i in 0..right_entries.length() {
   45|     18|                    for i in 0..neighbors.length() {
   45|     18|                    for i in 0..neighbors.length() {
  457|      9|            for i in 0..left_filtered.len() {
  460|     10|            for i in 0..right_filtered.len() {
   46|     13|        for i in 0..neighbors.length() {
   46|  48.7k|            for i in 0..composites.length() {
   50|  1.09k|            for i in 0..size {
   50|     26|            for i in 1..=n {
   51|     16|        for i in 1..a.length() {
  517|      2|                for i in 0..left_updated.length() {
  520|      4|                for i in 0..right_updated.length() {
   52|  1.25k|            for i in 0..size {
   52|     16|        for i in 1..a.length() {
   52|     26|            for i in 1..=n {
  530|  2.58M|                        if i < self.entries.length() {
   53|     15|        for i in 0..neighbors.length() {
   53|     19|            for i in 0..domain.size() {
   53|      2|            for i in 0..chain.length() {
  539|  2.58M|                for i in 0..new_entries.length() {
   54|      0|                        if i < n_left {
   54|     16|            for i in 0..n {
   54|    222|        for (i, v) in vertices_vec.iter().enumerate() {
   54|     48|            for i in (3..=sqrt_n).step_by(2) {
   54|      9|            for i in 0..n {
   55|     15|        for i in 0..neighbors.length() {
   55|     38|                | (i, 0) => i, // Base case: need i deletions
   56|     16|            for i in 0..n {
  571|     10|                for i in 0..left_entries.length() {
   57|    173|                | (i, j) => {
   58|    114|                | (i, j) => {
   58|     13|            for i in 0..domain.size() {
   58|     13|            for i in 0..self.n {
  582|     10|            for i in 0..right_entries.length() {
   58|      9|            for i in 0..n {
  593|      4|            for i in 0..left_filtered.len() {
  596|      4|            for i in 0..right_filtered.len() {
   61|    108|            for i in 0..updates.length() {
   61|     13|                if i < seq.length() {
   61|     14|            for i in 0..seq.length() {
   61|     47|                while i < gt {
   61|      4|        for i in 0..k - 1 {
   62|    119|                | (i, j) => {
   62|     18|        for i in 0..k - 1 {
   62|      4|            for i in 0..self.n {
  627|     10|                for i in 0..left_entries.length() {
  638|     10|            for i in 0..right_entries.length() {
   64|     10|                | (i, 0) => i, // Base case: need i deletions
   64|    122|            for i in 0..chain.length() {
   22|       |        priority: i64,
   32|       |        dist: i64,
  649|      6|            for i in 0..left_filtered.len() {
   34|      1|            ArraySeqStEphS::from_vec(vec![i64::MAX, i64::MAX, 0, 1]),
   35|      1|            ArraySeqStEphS::from_vec(vec![i64::MAX, i64::MAX, i64::MAX, 0]),
   63|      1|            ArraySeqStEphS::from_vec(vec![i64::MAX, i64::MAX, i64::MAX, 0]),
   86|      1|            ArraySeqStEphS::from_vec(vec![i64::MAX, i64::MAX, 0]),
   65|  1.12k|            for i in 0..self.elements.length() {
  652|      7|            for i in 0..right_filtered.len() {
   65|      7|            for i in 0..neighbors.length() {
   66|     10|            for (i, bit) in self.bits.iter().enumerate() {
   66|     10|            for i in 0..=s_len {
   66|     18|            for i in 0..=s_len {
   66|      2|                | (i, 0) => i, // Delete all remaining characters from S
   66|     93|                | (i, j) => {
   67|     13|                | (i, j) => {
   67|    258|            for i in 0..docs.length() {
   67|     86|                | (i, j) => {
   68|     21|        for i in 0..seq.length() {
   68|  46.4k|                while i < gt {
   68|      7|            for (i, item) in self.data.iter().enumerate() {
   69|    103|            for i in 0..seq.length() {
   69|     10|            for i in 0..=s_len {
   69|     14|            for i in 0..=s_len {
   69|     16|        for i in 0..neighbors.length() {
   69|     21|            if i > 0 {
   69|      2|                | (i, 0) => i, // Delete all remaining characters from S
   69|      7|                if i > 0 {
   70|     13|                | (i, j) => {
   70|     20|            for i in 0..table_size {
   70|    228|                    if i % 2 == 0 {
   70|  26.9k|                    while i < gt {
   70|  43.0k|                        data.swap(lt, i);
   70|     67|                | (i, 0) => i, // Base case: need i deletions
   70|      8|            for i in 0..neighbors.length() {
   71|      2|                | (i, 0) => i, // Delete all remaining characters from S
   71|      2|                | (i, 0) => i, // Delete all remaining characters from S
   72|     10|                | (i, j) => {
   72|     10|                | (i, j) => {
   72|     20|        for i in 0..neighbors.length() {
   72|  26.3k|                            data.swap(lt, i);
   72|      4|            for i in 0..seq.length() {
   72|    550|                | (i, j) => {
   72|     59|                | (i, j) => {
   73|     20|        for i in 0..neighbors.length() {
   74|      8|            for i in 0..seq.length() {
   75|     29|            for i in 0..self.data.len() {
   75|    319|            for i in 1..self.elements.length() {
   75|      3|            for i in 0..seq.length() {
   75|      4|            for i in 0..seq.length() {
   77|    337|            for i in 0..self.max_probes.min(table_size) {
   77|      4|            for i in 0..seq.length() {
   78|  1.66k|            for i in 0..seq_len {
   78|     39|            for i in 0..self.entries.length() {
   79|     16|        for i in 0..neighbors.length() {
   80|  10.6k|            for i in 0..seq_len {
   80|  20.5M|            for (i, v) in values.into_iter().enumerate() {
   80|     27|                | (i, 0) => i, // Base case: need i deletions
   81|  2.95k|            for i in 0..table_size {
   82|    118|                | (i, j) => {
   82|    974|            for i in 0..self.elements.length() {
   83|    308|            for i in 0..size {
   83|    337|                if i > 0 && pos == probe_sequence[0] {
   84|      2|        for i in 0..k - 1 {
   85|  1.46k|            for i in 0..all_pairs.length() {
   85|      5|        for i in 0..k - 1 {
   85|     80|                for i in 0..table_size {
   86|     11|            for i in 0..seq.length() {
   86|     28|            for i in start..=end {
   86|  3.20k|            for (i, current) in values.iter().enumerate() {
   86|     35|            for i in start..=end {
   87|     20|            for i in 0..neighbors.length() {
   87|    220|                for i in 0..seq.length() {
   88|  19.3k|                while i < left_sorted.len() && j < right_sorted.len() {
   88|    753|            while i > 0 {
   89|     14|            for i in 0..key_seq.length() {
   89|      1|                for i in 0..seq.length() {
   89|     20|            for i in 0..neighbors.length() {
   91|     11|                for i in 0..old_neighbors.length() {
   91|     11|            for i in 0..old_neighbors.length() {
   93|     24|            for i in 0..self.elements.length() {
   94|      0|        for i in 0..neighbors.length() {
   94|    796|            for i in 0..insert_pos {
   95|     14|            for i in 0..selected_seq.length() {
   95|     21|        for i in 0..seq.length() {
   95|     25|            for i in 0..self.elements.length() {
   96|     21|            if i > 0 {
   97|     13|            for i in 1..n {
   98|     11|            for i in 0..old_neighbors.length() {
   98|    218|            for i in 0..self_len {
   98|    490|                if i == index {
   99|     11|                    for i in 0..old_neighbors.length() {
   22|      1|                return id;
  257|      4|                return id;
  287|      0|                return id;
  310|      1|                return id;
  335|      0|                return id;
   34|      1|                return id;
  357|      4|                return id;
  398|      4|                return id;
  231|    106|                let id_clone = id.clone();
  245|      6|                let id_clone = id.clone();
  322|     73|            let id_clone = id.clone();
  347|  1.99k|            let id_clone = id.clone();
   62|      9|                let id_clone = id.clone();
   41|       |        /// Identity element for the reduction operation
   42|       |        fn identity() -> R;
   54|    876|        fn identity() -> T { T::default() }
   68|     32|        fn identity() -> N { 0 }
  336|      0|                return identity.clone();
  371|      0|                return identity.clone();
  375|      0|                return identity.clone();
   88|     27|                cached_reduction: identity.clone(),
   91|     31|                cached_reduction: identity.clone(),
   97|     32|                cached_reduction: identity.clone(),
  299|      6|            let id_left = id.clone();
  300|      6|            let id_right = id.clone();
  126|    308|            let idx = self.range.start + index;
  141|     20|                let idx = self.range.start + index;
  141|      6|                let idx = r.random_range(lo..hi);
  155|    208|                let idx = rng_local.random_range(0..len);
  156|    178|                    let idx = r.random_range(0..len);
  268|      3|                if idx < values.len() && seen.insert(idx) {
  313|      6|                if idx < values.len() && !seen.contains(&idx) {
  325|      5|                if idx < values.len() {
   37|      2|            for (idx, (k, _)) in self.iter().enumerate() {
   48|      1|            let idx = r.random_range(lo..hi);
   49|    192|                                if idx == i {
   49|    227|                                if idx == i {
   49|    255|                                if idx == i {
   50|      4|            let idx = r.random_range(lo..hi);
   51|    122|                                if idx == i {
   52|     19|            let idx = r.random_range(lo..hi);
   69|    101|                                if idx == i {
   69|    124|                                if idx == i {
   69|    189|                                if idx == i {
   71|    159|                                if idx == i {
  104|    220|                    return if f(&vals[0]) { vals } else { Vec::new() };
  125|    360|                &|i| if i == 0 { a.clone() } else { b.clone() },
  136|      0|                    return if arcs[0].0 == v {
  136|      0|                    return if arcs[0].1 == v {
  145|    214|                &|i| if i == 0 { a.clone() } else { b.clone() },
  146|      0|                    return if arcs[0].1 == v {
  147|       |        /// If out of bounds, returns only the in-bounds part. <br/>
  162|    110|                    return if other_set.find(&self_vals[0]) {
  168|      0|                    return if x == &v {
  184|     17|                .filter_map(|v| if predicate(v) { Some(v.clone()) } else { None })
  184|     19|                .filter_map(|v| if predicate(v) { Some(v.clone()) } else { None })
  184|     19|                .filter_map(|v| if predicate(v) { Some(v.clone()) } else { None })
  184|     19|                .filter_map(|v| if predicate(v) { Some(v.clone()) } else { None })
  184|     39|                .filter_map(|v| if predicate(v) { Some(v.clone()) } else { None })
  184|      4|                &|j| if j == index { item.clone() } else { a.nth(j).clone() },
  184|     94|                .filter_map(|v| if predicate(v) { Some(v.clone()) } else { None })
  188|      0|                    return if arcs[0].1 == v {
  218|      0|                    return if y == &v {
  226|    341|                &|j| if j == index { item.clone() } else { a.nth(j).clone() },
  233|      3|                &|j| if j == index { item.clone() } else { a.nth(j).clone() },
  292|      3|                &|j| if j == index { item.clone() } else { a.nth_cloned(j) },
   30|       |    /// if neither endpoint is already matched.
   43|       |            // If odd length, combine result with last element
   56|     75|            distances.insert(v, if v == source { 0 } else { i64::MAX });
   64|       |        /// If multiple updates target the same index, the last update wins.
   67|      4|                    Some(node) if &node.key == key => {
   84|      0|                    return if arcs[0].0 == v {
   91|      0|                    return if arcs[0].0 == v {
    2|       |//! MtPer (immutable, thread-safe, structurally shared) AVL tree sequence using Arc path-copying.
    2|       |//! StPer (immutable, structurally shared) AVL tree sequence using Rc path-copying.
  281|      1|            cmp: impl Fn(&K, &K) -> O,
   90|       |            cmp: impl Fn(&K, &K) -> O,
  110|       |            // Implement directly to handle closures (can't delegate to Chap18 fn pointers)
  124|       |                // Implement directly since we can't capture with &F
  149|       |            // Implement directly since we can't capture with &F
   15|       |        /// Implement fetch_add using compare-and-swap retry loop.
  193|       |            // Implement directly since we can't capture with &F
  208|       |            // Implement directly since we can't delegate impl Fn to fn pointer
  251|       |            // Implement directly since we can't capture with &F
   99|       |            // Implement directly to handle closures (can't delegate to Chap18 fn pointers)
    5|       |//! This implementation uses thread-safe sets (AVLTreeSetMtPer) which support
  156|      0|        output.push_str(&format!("All implementations correct: {}\n", all_correct));
   17|       |    /// Implemented as: flatten ∘ (tabulate_x (flatten ∘ (tabulate_y (tabulate_z))))
  187|      2|This is implemented in our LoadFactorManager.
  358|       |    macro_rules! impl_hash_function {
  148|      0|        for (impl_name, complexity_str, notes) in complexity {
  239|       |    // Import OrderedFloat from the ordered-float crate
  128|       |            // In practice, would maintain augmented tree structure
    5|       |//! Used in Kruskal's MST algorithm for efficient cycle detection.
  144|      6|        fn Incident(&self, e: &Edge<V>, v: &V) -> B { if &e.0 == v || &e.1 == v { true } else { false } }
  183|    250|        fn Incident(&self, e: &Edge<V>, v: &V) -> B { if &e.0 == v || &e.1 == v { true } else { false } }
  335|  5.71k|        fn Incident(&self, e: &Edge<V>, v: &V) -> B { if &e.0 == v || &e.1 == v { true } else { false } }
   49|       |        fn Incident(&self, e: &Edge<V>, v: &V) -> B;
   52|       |        fn Incident(&self, e: &Edge<V>, v: &V) -> B;
   61|       |        fn Incident(&self, e: &Edge<V>, v: &V) -> B;
   64|       |        fn Incident(&self, e: &Edge<V>, v: &V) -> B;
   98|     50|        fn Incident(&self, e: &Edge<V>, v: &V) -> B { if &e.0 == v || &e.1 == v { true } else { false } }
  256|       |                    // Include left subtree if it might contain keys >= low
  261|       |                    // Include current node if it's in range
  266|       |                    // Include right subtree if it might contain keys <= high
  103|     21|            if in_cluster {
   87|     22|                    if !in_cluster {
   94|    286|                    if in_cluster {
  147|     22|        fn InDegree(&self, v: &V) -> N { self.NMinus(v).size() }
  338|  2.69k|        fn InDegree(&self, v: &V) -> N { self.NMinus(v).size() }
   67|       |        fn InDegree(&self, v: &V) -> N;
   70|       |        fn InDegree(&self, v: &V) -> N;
  375|      3|                        let indent = "  ".repeat(depth);
  307|     16|                let independence_bonus = m.hash_function_independence * -20.0;
  172|     20|            let independence_score = if h1_value != h2_value {
  190|     20|                hash_function_independence: independence_score,
  100|     14|                if index < ls {
  101|     66|                if index < ls {
  108|     19|            if index >= self.len {
  117|     11|            if index < len_a {
  117|      2|            if index < self.data.len() {
  119|      5|            if index < len_a {
  136|     22|            if index >= self.len() {
  144|      1|            if index < self.keys.len() {
  148|      2|            if index < self.dimensions.len() {
  152|      3|            if index < self.keys.len() {
  155|    226|            if index >= self.len {
  157|      1|            if index < self.dimensions.len() {
  163|      0|            if index < self.data.len() {
  165|      6|            if index < self.data.len() {
  181|      1|            ArraySeqStEphS::set(self, index, item)
  182|      1|        let _index = create_tweet_index();
  184|      0|            ArraySeqMtEphS::set(self, index, item)
  188|      2|            ArraySeqS::set(self, index, item)
  198|    437|            if index >= self.data.len() {
  202|      1|        let index = create_tweet_index();
  203|     26|                if *index >= result.length() {
   21|       |        pub index: N,
  243|      2|            for (index, value) in updates.iter() {
  244|      2|                if *index < result.length() {
  257|      1|            if index < values.len() {
  260|      0|            LinkedListStEphS::set(self, index, item)
  264|     19|            if index >= a.length() {
   26|       |        pub index: N,
  272|      8|            if index < a.length() {
  276|      8|                if *index < result.length() {
  285|  97.2M|                if index <= left_size {
  288|     38|                if *index < result.length() {
  298|   197M|        if index < left_size {
  301|   121M|        if index == left_size {
  304|  80.9M|        nth_link(&n.right, index - left_size - 1)
   31|      1|        let index = create_tweet_index();
  312|     33|                if index < left_size {
   31|      9|            let index = Self::hash_index(table, &key);
   32|      9|            if index < table.table.len() {
  348|      3|            for &(index, ref value) in updates {
  349|      2|                if index < result.length() {
  359|      3|            for &(index, ref value) in updates.iter().rev() {
  360|      3|                if index < result.length() {
  381|    431|                if *index < result.length() && updated.insert(*index) {
  398|     20|                if index <= left_size {
   40|      9|            let index = Self::hash_index(table, &key);
  411|     30|        if index < left_size {
  414|     27|        if index == left_size {
  417|      6|        nth_link(&n.right, index - left_size - 1)
   41|      9|            if index < table.table.len() {
  425|      5|                if index < left_size {
   43|     14|            let index = create_tweet_index();
   46|  1.22k|            if index < self.data.len() {
   51|      3|            let index = Self::hash_index(table, &key);
   52|      3|            if index < table.table.len() {
   55|     76|                if index < guard.len() {
   63|    108|                if index < self.data.len() {
   67|    143|            for (index, value) in last_values {
   78|  11.2M|            if index < ls {
   78|  2.66k|            if index < ls {
   92|      0|                if index == 0 {
   92|    240|            if index >= self.len {
   93|      1|                if index == 0 {
   44|     14|            let index_clone = index.clone();
  184|       |        // Indexed search work: O(log n) for find
  185|      1|        let indexed_work = 1; // Represents O(log n) complexity
   44|       |    /// Inductive case: Partition, build quotient graph, recurse.
  102|       |            // Initialize frontier with sources
  142|       |            // Initialize frontier with sources
   53|       |        // Initialize distances: source = 0, others = infinity
   56|       |        /// Initialize base cases for DP table
   56|       |        /// Initialize base cases for DP table
   56|       |        // Initialize distances: source = 0, others = infinity
   59|       |        /// Initialize base cases for DP table
   59|       |        /// Initialize base cases for DP table
   61|       |        // Initialize Union-Find with all vertices
   62|       |            // Initialize with zeros - using Vec for 2D table as sequences lack nested indexing
   62|       |            // Initialize with zeros - using Vec for 2D table as sequences lack nested mutation
   65|       |            // Initialize with zeros - using Vec for 2D table as Mt sequences lack method-call API
   65|       |            // Initialize with zeros - using Vec for 2D table as Mt sequences lack nested mutation
   72|       |        // Initialize result with all distances = infinity except source = 0
   72|       |        // Initialize result with all distances = infinity except source = 0
   58|      3|        fn initialize_base_cases(&self) -> Vec<Vec<usize>> {
   58|      6|        fn initialize_base_cases(&self) -> Vec<Vec<usize>> {
   61|      3|        fn initialize_base_cases(&self) -> Vec<Vec<usize>> {
   61|      4|        fn initialize_base_cases(&self) -> Vec<Vec<usize>> {
   59|       |        /// Initially, each element is in its own set (parent is itself).
   26|       |        pub initial_size: N,
   43|     11|        FlatHashTable::create_table(probe_strategy, initial_size)
   52|     29|                current_size: initial_size,
   54|      2|        FlatHashTable::create_table(probe_strategy, initial_size)
   58|     10|        FlatHashTable::create_table(probe_strategy, initial_size)
   58|     11|        FlatHashTable::create_table(probe_strategy, initial_size)
   69|      2|        FlatHashTable::create_table(probe_strategy, initial_size)
   71|      4|        FlatHashTable::create_table(probe_strategy, initial_size)
  112|      1|            data.resize(length, init_value);
  232|      0|            LinkedListStPerS::new(length, init_value)
  256|      1|            LinkedListStEphS::new(length, init_value)
   63|       |        /// Inject updates into base sequence. Updates is a vector of (index, value) pairs.
  114|       |        fn inject(a: &ArraySeqStPerS<T>, updates: &ArraySeqStPerS<Pair<N, T>>) -> ArraySeqStPerS<T>;
  139|       |        fn inject(a: &ArraySeqMtEphS<T>, updates: &ArraySeqMtEphS<Pair<N, T>>) -> ArraySeqMtEphS<T>;
  182|       |        fn inject(a: &ArraySeqMtPerS<T>, updates: &ArraySeqMtPerS<Pair<N, T>>) -> ArraySeqMtPerS<T>;
  198|     13|        fn inject(a: &ArraySeqStPerS<T>, updates: &ArraySeqStPerS<Pair<N, T>>) -> ArraySeqStPerS<T> {
  203|      2|        fn inject(a: &ArraySeqStPerS<T>, updates: &ArraySeqStPerS<Pair<N, T>>) -> ArraySeqStPerS<T> {
  227|       |        fn inject(a: &Self, updates: &LinkedListStEphS<Pair<N, T>>) -> Self;
  263|      1|        fn inject(a: &ArraySeqS<T>, updates: &ArraySeqS<Pair<N, T>>) -> ArraySeqS<T> {
  267|      1|        fn inject(a: &ArraySeqMtEphS<T>, updates: &ArraySeqMtEphS<Pair<N, T>>) -> ArraySeqMtEphS<T> {
  308|      3|        fn inject(a: &LinkedListStPerS<T>, updates: &LinkedListStPerS<Pair<N, T>>) -> LinkedListStPerS<T> {
  336|      3|        fn inject(a: &Self, updates: &LinkedListStEphS<Pair<N, T>>) -> Self {
  345|      1|        fn inject(a: &Self, updates: &[(N, T)]) -> Self {
  376|    423|        fn inject(a: &ArraySeqMtPerS<T>, updates: &ArraySeqMtPerS<Pair<N, T>>) -> ArraySeqMtPerS<T> {
   58|       |        fn inject(a: &ArraySeqStPerS<T>, updates: &ArraySeqStPerS<Pair<N, T>>) -> ArraySeqStPerS<T>;
   63|       |        fn inject(a: &LinkedListStPerS<T>, updates: &LinkedListStPerS<Pair<N, T>>) -> LinkedListStPerS<T>;
   71|       |        fn inject(a: &Self, updates: &[(N, T)]) -> Self;
   76|       |        fn inject(a: &ArraySeqS<T>, updates: &ArraySeqS<Pair<N, T>>) -> ArraySeqS<T>;
  238|      1|        fn inject(base: &ArraySeqStEphS<T>, updates: &[(N, T)]) -> ArraySeqStEphS<T> {
   67|       |        fn inject(base: &ArraySeqStEphS<T>, updates: &[(N, T)]) -> ArraySeqStEphS<T>;
  153|       |        fn inject(&mut self, updates: &ArraySeqStEphS<Pair<N, T>>) -> &mut ArraySeqStEphS<T>;
  246|      9|        fn inject(&mut self, updates: &ArraySeqStEphS<Pair<N, T>>) -> &mut ArraySeqStEphS<T> {
  265|    422|        fn inject(values: &ArraySeqMtPerS<T>, changes: &ArraySeqMtPerS<Pair<N, T>>) -> ArraySeqMtPerS<T> {
   66|       |        fn inject(values: &ArraySeqMtPerS<T>, changes: &ArraySeqMtPerS<Pair<N, T>>) -> ArraySeqMtPerS<T>;
  207|  31.7k|                return inn;
  137|     51|            let in_neighbors = graph.in_neighbors_weighted(&v);
  146|     51|            let in_neighbors = graph.in_neighbors_weighted(&v);
   70|    224|                let in_neighbors = graph.in_neighbors_weighted(&v);
   80|    183|                let in_neighbors = graph.in_neighbors_weighted(&v);
  115|     10|        fn in_neighbors(&self, v: &V) -> Set<V> {
  163|     68|        fn in_neighbors(&self, v: &V) -> Set<V> {
   52|       |        fn in_neighbors(&self, v: &V) -> Set<V>;
   56|       |        fn in_neighbors(&self, v: &V) -> Set<V>;
  125|       |        type Inner = T;
  127|      1|            let inner = self.lock().unwrap().clone();
  134|       |        type Inner = Pair<A, B>;
  141|       |        type Inner = usize;
  147|       |        type Inner = isize;
  151|      5|            let inner = Arc::new(Inner {
  153|       |        type Inner = i32;
  159|       |        type Inner = u32;
  165|       |        type Inner = i64;
  171|       |        type Inner = u64;
  177|       |        type Inner = bool;
  183|       |        type Inner = char;
  190|       |        type Inner = String;
  197|       |        type Inner = &'a str;
  233|    605|            let inner = self.inner.lock().unwrap();
  236|     50|                let inner = a.nth(i);
  247|      3|                let inner = a.nth(i);
  254|     11|            let inner = self.inner.lock().unwrap();
   25|      5|        let inner: ArraySeqStPerS<ArraySeqStPerS<Pair<N, N>>> =
  286|      5|                let inner = ss.nth_cloned(i);
  323|      7|                let inner = ss.nth(i);
  388|      8|                let inner = ss.nth(i);
   52|     53|            let inner = self.inner.lock().unwrap();
   57|     60|            let inner = self.inner.lock().unwrap();
   66|       |        type Inner: StT;
   84|      3|                let inner = self.inner.lock().unwrap();
   81|     66|                    insert_node(&mut inner.left, value);
   83|  5.01k|                    insert_node(&mut inner.right, value);
  190|    529|                let inner_seq = a.nth(i);
  344|    222|                let inner_seq = ss.nth(i);
   18|       |    struct Inner<T: StT + Send + Sync> {
  131|     15|        fn in_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  133|    483|        fn in_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  163|     27|        fn in_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  164|  1.56k|        fn in_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  168|    683|        fn in_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  176|     31|        fn in_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  188|    338|        fn in_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  188|    688|        fn in_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  207|     96|        fn in_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  210|    129|        fn in_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  224|  58.8k|        fn in_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  113|  22.0k|    fn inorder_collect<T: StTInMtT>(cur: &Link<T>, out: &mut Vec<T>) {
  114|  15.4k|    fn inorder_collect<T: StT>(cur: &Link<T>, out: &mut Vec<T>) {
  116|      0|        fn in_order(&self) -> ArraySeqStPerS<T> { BalBinTree::in_order(self) }
  175|      1|        fn in_order(&self) -> ArraySeqStPerS<T> {
  192|      6|        fn in_order(&self) -> ArraySeqStPerS<T> {
  192|     90|        fn in_order(&self) -> ArraySeqStPerS<T> {
  197|     75|        fn in_order(&self) -> ArraySeqStPerS<T> {
  210|      5|        fn in_order(&self) -> ArraySeqStPerS<T> {
  230|    100|        fn in_order(&self) -> ArraySeqStPerS<T> {
  232|      8|        fn in_order(&self) -> ArraySeqStPerS<T> {
  237|     75|        fn in_order(&self) -> ArraySeqStPerS<T> {
  246|     78|        fn in_order(&self) -> ArraySeqStPerS<T> {
  254|      0|        fn in_order(&self) -> ArraySeqStPerS<T> {
  256|      6|        fn in_order(&self) -> ArraySeqStPerS<T> {
  265|      1|        fn in_order(&self) -> ArraySeqStPerS<T> {
  291|    358|        fn in_order(&self) -> ArraySeqStPerS<T> {
  336|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
  378|     14|        fn in_order(&self) -> ArraySeqStPerS<T> {
   37|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   38|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
  433|      0|        fn in_order(&self) -> ArraySeqStPerS<T> {
   56|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   58|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   60|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   60|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   60|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   60|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   60|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   61|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   61|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   61|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   61|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   61|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   66|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
   69|     12|        fn in_order(&self) -> ArraySeqStPerS<T> { self.root.in_order() }
   78|       |        fn in_order(&self) -> ArraySeqStPerS<T>;
  135|      0|        output.push_str(&format!("Empty input - All match: {}\n\n", empty.all_results_match()));
  147|       |        pub input: Vec<T>,
  199|      2|        let input = vec![64, 34, 25, 12, 22, 11, 90];
  205|      2|        let input = vec![10, 9, 8, 7, 6, 5, 4, 3, 2, 1];
  211|      2|        let input = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  217|      2|        let input = vec![5, 2, 8, 2, 9, 1, 5, 5];
  223|      2|        let input = vec![42];
  229|      2|        let input = vec![];
   28|       |        /// Input sequence S
   28|       |        /// Input sequence S
   28|       |        /// Input sequence S
   28|       |        /// Input sequence S
   30|       |        /// Input sequence S
   30|       |        /// Input sequence S
   30|       |        /// Input sequence S
   30|       |        /// Input sequence S
   30|       |        /// Input sequence T  
   30|       |        /// Input sequence T  
   30|       |        /// Input sequence T  
   30|       |        /// Input sequence T  
   32|       |        /// Input sequence T  
   32|       |        /// Input sequence T  
   32|       |        /// Input sequence T  
   32|       |        /// Input sequence T  
  247|      1|        let inputs = vec![
  104|       |            // Insert all keys sequentially (ArraySetStEph is single-threaded)
  105|       |        /// Insert memoized result
  116|       |        // Insert entries that will cause collisions
  122|       |        // Insert D which will probe through occupied slots
  150|       |        /// Insert multiple elements from an iterator
  186|       |        /// Insert memoized result
   19|       |        /// Insert a new element into the Union-Find structure
  200|       |        /// Insert multiple elements from a sequence
  204|       |        // Insert operation
  209|       |        /// Insert multiple elements from a sequence
  210|       |        // Insert duplicate (should not change size)
   26|      3|                    // Insert new
   27|     28|                    // Insert new
  274|       |        /// Insert multiple elements from a sequence
  275|      1|                "O(n) insert dominates".to_string(),
   39|       |        /// Insert key-value pair using default hash function
   43|      1|        println!("\n--- Insert Operations ---");
    4|       |//! Work: insert O(1), lookup O(1), delete O(1) expected with constant load factor.
   54|       |        /// Insert at head of chain - constant time
   57|       |        /// Insert a new element into the Union-Find structure
   79|       |        /// Insert element maintaining balanced tree structure
   90|       |                // Insert or update the word entry
   93|       |            // Insert element at correct position
   99|       |        // Insert initial entries
   30|      9|        fn insert_chained(table: &mut HashTable<Key, Value, Entry, Metrics>, key: Key, value: Value) {
  108|     14|                let insert_cost = table[i][j - 1];
  110|     15|                let insert_cost = table[i][j - 1];
  143|     14|                let insert_cost = table_guard[i][j - 1];
  144|     14|                let insert_cost = table_guard[i][j - 1];
  144|     29|                        let insert_cost = handle1.join().unwrap();
  146|     22|                        let insert_cost = handle1.join().unwrap();
   67|    134|                        let insert_cost = self.min_edit_distance_rec(i, j - 1);
   76|      6|                        let insert_cost = 1 + self.med_recursive(i, j - 1);
   79|      6|                        let insert_cost = 1 + self.med_recursive(i, j - 1, memo);
   81|      6|                        let insert_cost = 1 + self.med_recursive_concurrent(i, j - 1);
   82|    494|                        let insert_cost = self.min_edit_distance_rec(i, j - 1);
   83|      6|                        let insert_cost = 1 + self.med_recursive_concurrent(i, j - 1);
   83|     77|                        let insert_cost = handle2.join().unwrap();
   99|     96|                        let insert_cost = handle2.join().unwrap();
  100|      9|                    let inserted = Self::insert_link(&mut node.left, key, value, rng);
  106|    360|                    let inserted = Self::insert_link(&mut node.right, key, value, rng);
  119|  3.22k|                    let inserted = if value < node.key {
  126|  3.22k|                    if inserted {
  194|    912|            let inserted = Self::insert_link(&mut *guard, value);
  195|    912|            if inserted {
  197|    118|            let inserted = Self::insert_link(&mut self.root, key, value, &mut r);
  198|    118|            if inserted {
   77|  8.10k|                    let inserted = if value < node.key {
   77|  8.21k|                    let inserted = if value < node.key {
   79|  11.0k|                    let inserted = if value < node.key {
   84|  8.10k|                    if inserted {
   84|  8.21k|                    if inserted {
   85|    232|            let inserted = Self::insert_link(&mut self.root, value);
   86|  11.0k|                    if inserted {
   86|    232|            if inserted {
   95|  6.97k|                        let inserted = descend(&branch, value);
   96|  6.97k|                        if inserted {
  103|      7|        fn insert_edge(&mut self, u: V, v: V) {
  117|     21|        fn insert_edge(&mut self, u: V, v: V) {
   39|       |        fn insert_edge(&mut self, u: V, v: V);
   40|       |        fn insert_edge(&mut self, u: V, v: V);
  108|     11|        fn insert_edge(&self, u: V, v: V) -> Self {
  111|      7|        fn insert_edge(&self, u: V, v: V) -> Self {
  124|     19|        fn insert_edge(&self, u: V, v: V) -> Self {
   31|       |        fn insert_edge(&self, u: N, v: N) -> Self;
   35|       |        fn insert_edge(&self, u: V, v: V) -> Self;
   39|       |        fn insert_edge(&self, u: V, v: V) -> Self;
   41|       |        fn insert_edge(&self, u: V, v: V) -> Self;
   43|       |        fn insert_edge(&self, u: V, v: V) -> Self;
   85|     11|        fn insert_edge(&self, u: N, v: N) -> Self {
   87|     24|        fn insert_edge(&self, u: V, v: V) -> Self {
  114|    545|        fn insert<F: Fn(&V, &V) -> V>(&mut self, k: K, v: V, combine: F) { self.base_table.insert(k, v, combine); }
  116|  2.90k|        fn insert<F: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, k: K, v: V, combine: F) {
  249|  2.00k|        fn insert<F: Fn(&V, &V) -> V>(&mut self, key: K, value: V, combine: F) {
  252|  3.56k|        fn insert<F: Fn(&V, &V) -> V>(&self, key: K, value: V, combine: F) -> Self {
   35|       |        fn insert<F: Fn(&V, &V) -> V>(&mut self, k: K, v: V, combine: F);
   38|       |        fn insert<F: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, k: K, v: V, combine: F);
  468|  4.45k|        fn insert<F: Fn(&V, &V) -> V + Send + Sync>(&mut self, key: K, value: V, combine: F) {
   46|       |        fn insert<F: Fn(&V, &V) -> V>(&mut self, key: K, value: V, combine: F);
   49|       |        fn insert<F: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, key: K, value: V, combine: F);
   69|       |        fn insert<F: Fn(&V, &V) -> V>(&self, key: K, value: V, combine: F) -> Self;
  117|    203|        fn insert<G: Fn(&V, &V) -> V>(&mut self, k: K, v: V, combine: G) {
  123|  2.51k|        fn insert<G: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, k: K, v: V, combine: G) {
   40|       |        fn insert<G: Fn(&V, &V) -> V>(&mut self, k: K, v: V, combine: G);
   40|       |        fn insert<G: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, k: K, v: V, combine: G);
  272|      0|                        if insertion_pos.is_none() {
   95|      2|                        if insertion_pos.is_none() {
    4|       |pub mod InsertionSortSt {
  103|  1.50k|        fn insert_link(link: &mut Link<T>, value: T, rng: &mut impl Rng) {
  104|  3.99k|        fn insert_link(link: &mut Link<T>, value: T, rng: &mut impl Rng) {
  116|  3.45k|        fn insert_link(link: &mut Link<T>, value: T) -> bool {
  116|  6.54k|        fn insert_link(link: &mut Link<T>, value: T, rng: &mut impl Rng) {
  134|  1.01k|        fn insert_link(link: &mut Link<T>, value: T) {
  134|  12.9k|        fn insert_link(link: &mut Link<T>, value: T) {
  156|    794|        fn insert_link(link: &mut Link<T>, value: T) {
  170|    980|        fn insert_link(link: &mut Link<K, V, R>, key: K, value: V, rng: &mut impl Rng) {
  173|   140k|        fn insert_link(link: &mut Link<T>, value: T) {
   74|  8.44k|        fn insert_link(link: &mut Link<T>, value: T) -> bool {
   74|  9.01k|        fn insert_link(link: &mut Link<T>, value: T) -> bool {
   76|  11.7k|        fn insert_link(link: &mut Link<T>, value: T) -> bool {
   97|    487|        fn insert_link(link: &mut Link<K, V>, key: K, value: V, rng: &mut impl Rng) -> bool {
  130|    275|        fn insert(&mut self, x: T) {
   14|      8|        fn insert(&mut self, key: Key, value: Value) {
   15|      8|        fn insert(&mut self, key: Key, value: Value) {
  162|     36|        fn insert(&mut self, x: N) {
  162|   555k|        fn insert(&mut self, x: T) {
  165|    235|        fn insert(&mut self, value: T) { Self::insert_link(&mut self.root, value); }
  173|      0|        fn insert(&mut self, v: V) {
  195|    118|        fn insert(&mut self, key: K, value: V) {
  197|    328|        fn insert(&mut self, value: T) {
   21|       |        fn insert(&mut self, v: V);
  222|    208|        fn insert(&mut self, value: T) { Self::insert_link(&mut self.root, value); }
   24|      0|        fn insert(&mut self, key: Key, value: Value) { *self = FlatEntry::Occupied(key, value); }
  241|    175|        fn insert(&mut self, value: T) {
  242|      1|        fn insert(&mut self, value: T) { self.tree.insert(value); }
  242|      1|        fn insert(&mut self, value: T) { self.tree.insert(value); }
  242|      1|        fn insert(&mut self, value: T) { self.tree.insert(value); }
  242|      1|        fn insert(&mut self, value: T) { self.tree.insert(value); }
  242|      1|        fn insert(&mut self, value: T) { self.tree.insert(value); }
  242|      1|        fn insert(&mut self, value: T) { self.tree.insert(value); }
  242|    845|        fn insert(&mut self, x: T) {
  244|      0|        fn insert(&mut self, value: T) { Self::insert_link(&mut self.root, value); }
  250|      0|        fn insert(&mut self, x: T) -> &mut Self {
  252|  1.05k|        fn insert(&mut self, value: T) {
   27|       |        fn insert(&mut self, value: T);
  301|    202|        fn insert(&mut self, key: K, value: V) {
   31|       |        fn insert(&mut self, x: T);
   31|       |        fn insert(&mut self, x: T);
   32|     12|        fn insert(&mut self, key: Key, value: Value) {
   37|       |        fn insert(&mut self, key: Key, value: Value);
   37|       |        fn insert(&mut self, value: T);
   37|       |        fn insert(&mut self, value: T);
   37|       |        fn insert(&mut self, value: T);
   37|       |        fn insert(&mut self, value: T);
   37|       |        fn insert(&mut self, value: T);
   37|       |        fn insert(&mut self, value: T);
   40|       |        fn insert(&mut self, x: T);
   42|       |        fn insert(&mut self, x: T);
   46|       |        fn insert(&mut self, x: T) -> &mut Self;
   47|       |        fn insert(&mut self, x: T);
   48|       |        fn insert(&mut self, value: T);
   48|       |        fn insert(&mut self, x: N);
   50|       |        fn insert(&mut self, value: T);
   50|       |        fn insert(&mut self, value: T);
   50|       |        fn insert(&mut self, value: T);
   50|       |        fn insert(&mut self, value: T);
   51|       |        fn insert(&mut self, key: K, value: V);
   56|       |        fn insert(&mut self, value: T);
   59|    195|        fn insert(&mut self, value: T) { insert_node(&mut self.root, value); }
   88|    266|        fn insert(&mut self, x: T) {
   91|       |        fn insert(&mut self, key: K, value: V);
   98|     87|        fn insert(&mut self, x: T) { self.base_set.insert(x); }
   74|  5.27k|    fn insert_node<T: StT + Ord>(node: &mut BalBinTree<T>, value: T) {
   28|       |        /// Inserts into the chain at the hashed bucket.
   29|       |        /// Inserts element and bubbles up to maintain heap property
   29|       |        /// Inserts element in correct sorted position
   29|       |        /// Inserts element into balanced tree maintaining order
   29|       |        /// Inserts element into unsorted list
   41|       |        /// Inserts element by creating singleton and melding
   58|       |        /// Inserts using linear probing as default.
   59|       |        /// Inserts a key-value pair into the hash table.
  105|    520|        fn insert(&self, k: K, v: V) -> Self {
  108|    172|        fn insert(&self, k: K, v: V) -> Self {
  157|    629|        fn insert(&self, value: T) {
  159|  37.6k|        fn insert(&self, x: T) -> Self {
  161|     25|        fn insert(&self, key: T) {
  188|  1.03k|        fn insert(&self, value: T) {
  192|    912|        fn insert(&self, value: T) {
  201|    487|        fn insert(&self, element: T) -> Self {
  212|  1.91k|        fn insert(&self, value: T) {
  235|    284|        fn insert(&self, element: T) -> Self {
  248|  24.9k|        fn insert(&self, value: T) {
  255|    232|        fn insert(&self, x: T) -> Self {
  304|       |        fn insert(&self, key: T);
   30|       |        fn insert(&self, element: T) -> Self;
   30|       |        fn insert(&self, element: T) -> Self;
   30|       |        fn insert(&self, element: T) -> Self;
   30|       |        fn insert(&self, element: T) -> Self;
   30|       |        fn insert(&self, k: K, v: V) -> Self;
   30|       |        fn insert(&self, x: T) -> Self;
  313|  1.62k|        fn insert(&self, key: T) {
   31|       |        fn insert(&self, k: K, v: V) -> Self;
  366|    206|        fn insert(&self, key: T) {
   38|       |        fn insert(&self, k: K, v: V) -> Self;
   40|       |        fn insert(&self, x: T) -> Self;
   42|       |        fn insert(&self, element: T) -> Self;
   44|       |        fn insert(&self, key: T);
   44|       |        fn insert(&self, value: T);
   46|       |        fn insert(&self, value: T);
   46|       |        fn insert(&self, value: T);
   46|       |        fn insert(&self, value: T);
   47|       |        fn insert(&self, x: T) -> Self;
   48|       |        fn insert(&self, key: T);
   52|       |        fn insert(&self, value: T);
   52|       |        fn insert(&self, value: T);
   58|     91|        fn insert(&self, k: K, v: V) -> Self {
   79|    307|        fn insert(&self, element: T) -> Self {
   79|    613|        fn insert(&self, value: T) {
   80|    376|        fn insert(&self, element: T) -> Self {
   86|    437|        fn insert(&self, element: T) -> Self {
   97|     84|        fn insert(&self, x: T) -> Self {
   18|      3|        fn insert(table: &mut HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: Key, value: Value) {
   19|     30|        fn insert(table: &mut HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: Key, value: Value) {
   51|      3|        fn insert(table: &mut HashTable<Key, Value, Vec<(Key, Value)>, Metrics>, key: Key, value: Value) {
   60|     18|        fn insert(table: &mut HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: Key, value: Value) {
   61|      3|        fn insert(table: &mut HashTable<Key, Value, LinkedList<(Key, Value)>, Metrics>, key: Key, value: Value) {
   61|       |        fn insert(table: &mut HashTable<Key, Value, Entry, Metrics>, key: Key, value: Value);
   86|      3|        fn insert(table: &mut HashTable<Key, Value, ChainList<Key, Value>, Metrics>, key: Key, value: Value) {
   35|       |        fn insert_vertex(&mut self, v: V);
   36|       |        fn insert_vertex(&mut self, v: V);
   81|     14|        fn insert_vertex(&mut self, v: V) { self.vertices.insert(v); }
   97|      6|        fn insert_vertex(&mut self, v: V) { self.adj.insert(v, AVLTreeSetStEph::empty(), |_, new| new.clone()); }
  100|      8|        fn insert_vertex(&self, v: V) -> Self {
   31|       |        fn insert_vertex(&self, v: V) -> Self;
   35|       |        fn insert_vertex(&self, v: V) -> Self;
   37|       |        fn insert_vertex(&self, v: V) -> Self;
   39|       |        fn insert_vertex(&self, v: V) -> Self;
   70|      3|        fn insert_vertex(&self, v: V) -> Self {
   86|      2|        fn insert_vertex(&self, v: V) -> Self {
   88|     14|        fn insert_vertex(&self, v: V) -> Self {
  218|      1|- Use insert_without_resize to avoid recursive resizing
  198|      0|        fn insert_without_resize(&self, key: K, value: V) -> Self
  203|    129|        fn insert_without_resize(&self, key: K, value: V) -> Self {
  257|    157|        fn insert_without_resize(&self, key: K, value: V) -> Self {
   60|      0|        fn insert_with_probe(table: &mut HashTable<Key, Value, Entry, Metrics>, key: Key, value: Value) {
   17|       |        /// insSort has n × O(n) = O(n²) work and n × O(log n) = O(n log n) span.
   18|       |        fn insSort(&self, slice: &mut [T]);
   22|      7|        fn insSort(&self, slice: &mut [T]) {
  169|      0|        println!("\n=== Integer Ordered Set Example ===");
  222|      0|        println!("=== Integer Example Complete ===");
    6|       |//! with integer edge weights. Stores distance and predecessor arrays for path reconstruction.
    6|       |//! with integer edge weights. Stores distance and predecessor arrays for path reconstruction.
    6|       |//! with integer edge weights. Stores distance matrix and predecessor matrix for path reconstruction.
    6|       |//! with integer edge weights. Stores distance matrix and predecessor matrix for path reconstruction.
    2|       |//! Set interface built atop the AVL multi-threaded BST implementation.
    2|       |//! Set interface built atop the BB-Alpha multi-threaded BST implementation.
    2|       |//! Set interface built atop the Plain multi-threaded BST implementation.
    2|       |//! Set interface built atop the Red-Black multi-threaded BST implementation.
    2|       |//! Set interface built atop the Splay multi-threaded BST implementation.
    2|       |//! Set interface built atop the Treap multi-threaded BST implementation.
   43|       |        /// Internal recursive subset sum with memoization
   44|       |        /// Internal parallel recursive subset sum with shared memoization
   45|       |        /// Internal recursive minimum edit distance with memoization
   48|       |        /// Internal parallel recursive minimum edit distance with shared memoization
   52|       |        /// Internal recursive optimal BST with memoization
   52|       |        /// Internal recursive subset sum with memoization
   54|       |        /// Internal parallel recursive subset sum with shared memoization
   59|       |        /// Internal recursive matrix chain with memoization
   60|       |        /// Internal recursive minimum edit distance with memoization
   64|       |        /// Internal parallel recursive minimum edit distance with shared memoization
   64|       |        /// Internal recursive optimal BST with memoization
   71|       |        /// Internal recursive matrix chain with memoization
   83|       |        /// Internal recursive optimal BST with memoization and parallel reduction
   89|       |        /// Internal recursive matrix chain with memoization and parallel reduction
   92|       |        /// Internal recursive optimal BST with memoization and parallel reduction
   99|       |        /// Internal recursive matrix chain with memoization and parallel reduction
  187|      2|            let intersect = parallel_intersect(self_vals, other_vals);
  172|     14|        fn intersect_inner(a: &Self, b: &Self) -> Self {
  174|    315|        fn intersect_inner(a: &Self, b: &Self) -> Self {
  129|      1|        let intersection = table1.intersection(&table2, |v1, v2| format!("{}+{}", v1, v2));
  164|      6|            let intersection = self.intersection(other, &combine);
  177|       |        // Intersection: {1, 2, 3, 4, 5} ∩ {4, 5, 6, 7, 8} = {4, 5}
  178|      2|        let intersection = set1.intersection(&set2);
    6|       |//! - intersection: Work Θ(n+m), Span Θ(log(n+m)) via PARALLEL divide-and-conquer
    6|       |//! - intersection: Work Θ(n+m), Span Θ(log(n+m)) via PARALLEL divide-and-conquer
  121|      4|        fn intersection<F: Fn(&V, &V) -> V>(&mut self, other: &Self, combine: F) {
  137|     10|        fn intersection<F: Fn(&V, &V) -> V>(&self, other: &Self, combine: F) -> Self {
  143|      2|        fn intersection<F: Fn(&V, &V) -> V>(&self, other: &Self, f: F) -> Self {
  174|      3|        fn intersection<F: Fn(&V, &V) -> V>(&mut self, other: &Self, f: F) {
  285|      4|        fn intersection<F: Fn(&V, &V) -> V + Send + Sync>(&mut self, other: &Self, combine: F) {
   36|       |        fn intersection<F: Fn(&V, &V) -> V>(&mut self, other: &Self, combine: F);
   39|       |        fn intersection<F: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, combine: F);
   43|       |        fn intersection<F: Fn(&V, &V) -> V>(&self, other: &Self, f: F) -> Self;
   49|       |        fn intersection<F: Fn(&V, &V) -> V>(&mut self, other: &Self, f: F);
   50|       |        fn intersection<F: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, f: F);
   51|       |        fn intersection<F: Fn(&V, &V) -> V>(&self, other: &Self, combine: F) -> Self;
  195|      3|        fn intersection<F>(&mut self, other: &Self, f: F)
  182|      1|        fn intersection<G: Fn(&V, &V) -> V>(&self, other: &Self, f: G) -> Self {
  183|      1|        fn intersection<G: Fn(&V, &V) -> V>(&mut self, other: &Self, f: G) {
  191|      1|        fn intersection<G: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, f: G) {
   44|       |        fn intersection<G: Fn(&V, &V) -> V>(&self, other: &Self, f: G) -> Self;
   47|       |        fn intersection<G: Fn(&V, &V) -> V>(&mut self, other: &Self, f: G);
   51|       |        fn intersection<G: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, f: G);
  108|      4|        fn intersection(&mut self, other: &Self) { self.elements.retain(|elem| other.find(elem)); }
  110|      1|        fn intersection(&mut self, other: &Self) {
   37|       |        fn intersection(&mut self, other: &Self);
   37|       |        fn intersection(&mut self, other: &Self);
  102|     16|        fn intersection(&self, other: &Self) -> Self {
  104|      2|        fn intersection(&self, other: &Self) -> Self {
  118|      1|        fn intersection(&self, other: &Self) -> Self {
  118|      1|        fn intersection(&self, other: &Self) -> Self {
  131|      2|        fn intersection(&self, other: &Self) -> Self {
  147|      3|        fn intersection(&self, other: &Self) -> Self {
  208|      0|        fn intersection(&self, other: &Set<T>) -> Set<T>
  248|      1|        fn intersection(&self, other: &Self) -> Self { BSTSetAVLMtEph::intersection(self, other) }
  248|      1|        fn intersection(&self, other: &Self) -> Self { BSTSetBBAlphaMtEph::intersection(self, other) }
  248|      1|        fn intersection(&self, other: &Self) -> Self { BSTSetRBMtEph::intersection(self, other) }
  248|      1|        fn intersection(&self, other: &Self) -> Self { BSTSetSplayMtEph::intersection(self, other) }
  248|      1|        fn intersection(&self, other: &Self) -> Self { BSTSetTreapMtEph::intersection(self, other) }
  260|      1|        fn intersection(&self, other: &Self) -> Self {
   30|       |        fn intersection(&self, other: &Self) -> Self;
   30|       |        fn intersection(&self, other: &Self) -> Self;
   32|       |        fn intersection(&self, other: &Self) -> Self;
   35|       |        fn intersection(&self, other: &Set<T>) -> Set<T>;
   36|       |        fn intersection(&self, other: &Self) -> Self;
   37|       |        fn intersection(&self, other: &Self) -> Self;
   37|       |        fn intersection(&self, other: &Self) -> Self;
   38|       |        fn intersection(&self, other: &Self) -> Self;
   43|       |        fn intersection(&self, other: &Self) -> Self;
   43|       |        fn intersection(&self, other: &Self) -> Self;
   43|       |        fn intersection(&self, other: &Self) -> Self;
   43|       |        fn intersection(&self, other: &Self) -> Self;
   43|       |        fn intersection(&self, other: &Self) -> Self;
   43|       |        fn intersection(&self, other: &Self) -> Self;
   82|      3|        fn intersection(&self, other: &Self) -> Self {
  322|       |        fn intersect(&self, other: &Self) -> Self;
  358|      3|        fn intersect(&self, other: &Self) -> Self { ParamBST::intersect_inner(self, other) }
  412|      2|        fn intersect(&self, other: &Self) -> Self { ParamTreap::intersect_inner(self, other) }
   66|       |        fn intersect(&self, other: &Self) -> Self;
  105|     21|            T: Into<i32> + Copy,
  114|     12|            T: Into<i32> + Copy + Send + Sync + 'static,
  124|     10|            T: Into<i32> + Copy + Send + Sync + 'static,
   33|       |            T: Into<i32> + Copy;
   33|       |            T: Into<i32> + Copy;
   34|       |            T: Into<i32> + Copy + Send + Sync + 'static;
   35|       |            T: Into<i32> + Copy + Send + Sync + 'static;
   48|    199|            T: Into<i32> + Copy,
   49|    234|            T: Into<i32> + Copy + Send + Sync + 'static,
   57|    131|            T: Into<i32> + Copy,
   59|    114|            T: Into<i32> + Copy + Send + Sync + 'static,
   96|     27|            T: Into<i32> + Copy,
  128|       |        type IntoIter = <ArraySeqStPerS<T> as IntoIterator>::IntoIter;
  132|       |        type IntoIter = std::iter::Map<
  135|       |        type IntoIter = <ArraySeqStPerS<T> as IntoIterator>::IntoIter;
  141|       |        type IntoIter = std::slice::Iter<'a, T>;
  146|       |        type IntoIter = <ArraySeqStEphS<T> as IntoIterator>::IntoIter;
  147|       |        type IntoIter = std::slice::IterMut<'a, T>;
  148|       |        type IntoIter = std::vec::IntoIter<KeyProb<T>>;
  150|       |        type IntoIter = std::iter::Map<
  152|       |        type IntoIter = std::vec::IntoIter<MatrixDim>;
  153|       |        type IntoIter = <ArraySeqStEphS<T> as IntoIterator>::IntoIter;
  153|       |        type IntoIter = std::vec::IntoIter<T>;
  155|       |        type IntoIter = std::iter::Cloned<std::slice::Iter<'a, KeyProb<T>>>;
  159|       |        type IntoIter = std::iter::Cloned<std::slice::Iter<'a, MatrixDim>>;
  160|       |        type IntoIter = <ArraySeqStEphS<T> as IntoIterator>::IntoIter;
  164|       |        type IntoIter = std::iter::Map<
  179|       |        type IntoIter = std::vec::IntoIter<KeyProb<T>>;
  182|       |        type IntoIter = std::iter::Map<
  184|       |        type IntoIter = std::vec::IntoIter<MatrixDim>;
  186|       |        type IntoIter = std::iter::Cloned<std::slice::Iter<'a, KeyProb<T>>>;
  191|       |        type IntoIter = std::iter::Cloned<std::slice::Iter<'a, MatrixDim>>;
  193|       |        type IntoIter = std::iter::Cloned<std::slice::Iter<'a, KeyProb<T>>>;
  198|       |        type IntoIter = std::iter::Cloned<std::slice::Iter<'a, MatrixDim>>;
  201|       |        type IntoIter = std::iter::Map<
  205|       |        type IntoIter = std::vec::IntoIter<KeyProb<T>>;
  206|       |        type IntoIter = std::vec::IntoIter<MatrixDim>;
  218|       |        type IntoIter = std::iter::Cloned<std::slice::Iter<'a, KeyProb<T>>>;
  219|       |        type IntoIter = std::iter::Cloned<std::slice::Iter<'a, MatrixDim>>;
  242|       |        type IntoIter = AVLTreeSeqMtPerIter<T>;
  260|       |        type IntoIter = std::vec::IntoIter<MatrixDim>;
  261|       |        type IntoIter = std::vec::IntoIter<KeyProb<T>>;
  276|       |        type IntoIter = std::vec::IntoIter<MatrixDim>;
  277|       |        type IntoIter = std::vec::IntoIter<KeyProb<T>>;
  286|       |        type IntoIter = std::vec::IntoIter<MatrixDim>;
  287|       |        type IntoIter = std::vec::IntoIter<KeyProb<T>>;
  352|       |        type IntoIter = std::slice::Iter<'a, T>;
  359|       |        type IntoIter = std::slice::IterMut<'a, T>;
  366|       |        type IntoIter = std::vec::IntoIter<T>;
   53|       |        type IntoIter = std::slice::Iter<'a, T>;
   60|       |        type IntoIter = std::vec::IntoIter<T>;
   86|       |        type IntoIter = std::slice::Iter<'a, T>;
   88|       |        type IntoIter = std::slice::Iter<'a, T>;
   93|       |        type IntoIter = std::vec::IntoIter<T>;
   95|       |        type IntoIter = std::vec::IntoIter<T>;
  150|       |    impl IntoIterator for MatrixChainStPerS {
  157|       |    impl<'a> IntoIterator for &'a MatrixChainStPerS {
  182|       |    impl IntoIterator for MatrixChainStEphS {
  189|       |    impl<'a> IntoIterator for &'a MatrixChainStEphS {
  196|       |    impl<'a> IntoIterator for &'a mut MatrixChainStEphS {
  204|       |    impl IntoIterator for MatrixChainMtPerS {
  217|       |    impl<'a> IntoIterator for &'a MatrixChainMtPerS {
  258|       |    impl IntoIterator for MatrixChainMtEphS {
  274|       |    impl<'a> IntoIterator for &'a MatrixChainMtEphS {
  284|       |    impl<'a> IntoIterator for &'a mut MatrixChainMtEphS {
  364|       |    impl<T> IntoIterator for ArraySeqS<T> {
  215|     34|            I: IntoIterator<Item = T>,
  215|     41|            I: IntoIterator<Item = T>,
  215|     41|            I: IntoIterator<Item = T>,
  215|     44|            I: IntoIterator<Item = T>,
  215|     48|            I: IntoIterator<Item = T>,
  215|     48|            I: IntoIterator<Item = T>,
  130|      1|        fn into_iter(self) -> Self::IntoIter { self.multiset.into_iter() }
  137|      0|        fn into_iter(self) -> Self::IntoIter { self.multiset.clone().into_iter() }
  140|      1|        fn into_iter(self) -> Self::IntoIter {
  142|      0|        fn into_iter(self) -> Self::IntoIter { self.data.iter() }
  148|      0|        fn into_iter(self) -> Self::IntoIter { self.data.iter_mut() }
  148|      0|        fn into_iter(self) -> Self::IntoIter { self.multiset.into_iter() }
  150|      1|        fn into_iter(self) -> Self::IntoIter { self.keys.into_iter() }
  154|      1|        fn into_iter(self) -> Self::IntoIter { self.dimensions.into_iter() }
  154|      5|        fn into_iter(self) -> Self::IntoIter { self.data.into_iter() }
  155|      0|        fn into_iter(self) -> Self::IntoIter { self.multiset.clone().into_iter() }
  157|      0|        fn into_iter(self) -> Self::IntoIter { self.keys.iter().cloned() }
  158|      0|        fn into_iter(self) -> Self::IntoIter {
  161|      0|        fn into_iter(self) -> Self::IntoIter { self.dimensions.iter().cloned() }
  162|      0|        fn into_iter(self) -> Self::IntoIter { self.multiset.clone().into_iter() }
  172|      0|        fn into_iter(self) -> Self::IntoIter {
  181|      0|        fn into_iter(self) -> Self::IntoIter { self.keys.into_iter() }
  186|      1|        fn into_iter(self) -> Self::IntoIter { self.dimensions.into_iter() }
  188|      0|        fn into_iter(self) -> Self::IntoIter { self.keys.iter().cloned() }
  190|      0|        fn into_iter(self) -> Self::IntoIter {
  193|      0|        fn into_iter(self) -> Self::IntoIter { self.dimensions.iter().cloned() }
  195|      0|        fn into_iter(self) -> Self::IntoIter { self.keys.iter().cloned() }
  200|      0|        fn into_iter(self) -> Self::IntoIter { self.dimensions.iter().cloned() }
  207|      0|        fn into_iter(self) -> Self::IntoIter {
  208|      0|        fn into_iter(self) -> Self::IntoIter {
  209|      0|        fn into_iter(self) -> Self::IntoIter {
  220|      1|        fn into_iter(self) -> Self::IntoIter { self.keys.iter().cloned() }
  221|      0|        fn into_iter(self) -> Self::IntoIter { self.dimensions.iter().cloned() }
  244|      1|        fn into_iter(self) -> Self::IntoIter {
  262|      0|        fn into_iter(self) -> Self::IntoIter {
  263|      1|        fn into_iter(self) -> Self::IntoIter {
  278|      0|        fn into_iter(self) -> Self::IntoIter {
  279|      1|        fn into_iter(self) -> Self::IntoIter {
  288|      0|        fn into_iter(self) -> Self::IntoIter {
  289|      0|        fn into_iter(self) -> Self::IntoIter {
  354|      0|        fn into_iter(self) -> Self::IntoIter { self.data.iter() }
  361|      0|        fn into_iter(self) -> Self::IntoIter { self.data.iter_mut() }
  368|      0|        fn into_iter(self) -> Self::IntoIter { Vec::from(self.data).into_iter() }
   55|      0|        fn into_iter(self) -> Self::IntoIter { self.data.iter() }
   62|     36|        fn into_iter(self) -> Self::IntoIter { self.data.into_vec().into_iter() }
   88|      0|        fn into_iter(self) -> Self::IntoIter { self.data.iter() }
   90|      1|        fn into_iter(self) -> Self::IntoIter { self.data.iter() }
   95|      0|        fn into_iter(self) -> Self::IntoIter { self.data.into_vec().into_iter() }
   97|      1|        fn into_iter(self) -> Self::IntoIter { self.data.into_vec().into_iter() }
  132|      0|        fn into_vec(self) -> Vec<T> { self.data }
   30|       |        fn into_vec(self) -> Vec<T>;
  172|      0|        let int_set: OrderedSetStPer<i32> = OrderedSetStPerLit![1, 3, 5, 7, 9, 11, 13];
   94|       |        /// Invokes the closure with a mutable slice under the single mutex.
  150|      2|This implementation is demonstrated in our NestedHashTable module.
  338|      2|             This is optimal among open addressing schemes."
   52|    525|            if is_composite { false } else { true }
   12|       |        fn is_divisible(n: N, i: N) -> B;
   12|       |//! - `is_empty`: Work O(1), Span O(1)
  213|      2|        fn isEmpty(a: &ArraySeqStPerS<T>) -> bool {
  220|      4|        fn isEmpty(a: &ArraySeqStEphS<T>) -> bool {
  277|    803|        fn isEmpty(a: &ArraySeqMtPerS<T>) -> bool {
  279|      3|        fn isEmpty(a: &ArraySeqMtEphS<T>) -> bool {
   56|       |        fn isEmpty(a: &ArraySeqMtEphS<T>) -> bool;
   58|       |        fn isEmpty(a: &ArraySeqStEphS<T>) -> bool;
   62|       |        fn isEmpty(a: &ArraySeqStPerS<T>) -> bool;
   74|       |        fn isEmpty(a: &ArraySeqMtPerS<T>) -> bool;
  106|      1|        fn is_empty(&self) -> bool { self.head.load(Ordering::Acquire).is_null() }
  111|      7|        fn is_empty(&self) -> B { self.size() == 0 }
  113|     17|        fn is_empty(&self) -> B { self.size() == 0 }
  114|      2|        fn is_empty(&self) -> B { self.base_table.is_empty() }
  117|       |        fn isEmpty(&self) -> B;
  120|      2|        fn is_empty(&self) -> B { self.base_table.is_empty() }
  133|      1|        fn isEmpty(&self) -> B { if self.data.is_empty() { true } else { false } }
  141|     12|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
  142|       |        fn isEmpty(&self) -> B;
  143|    153|        fn is_empty(&self) -> bool { self.elements.length() == 0 }
  153|      1|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
  155|       |        fn isEmpty(&self) -> B;
  156|       |        fn isEmpty(&self) -> B;
  156|       |        fn isEmpty(&self) -> B;
  157|     17|        fn isEmpty(&self) -> B { if self.len() == 0 { true } else { false } }
  159|      1|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
  162|      6|        fn isEmpty(&self) -> B { if self.length() == 0 { true } else { false } }
  173|    123|        fn is_empty(&self) -> bool { self.elements.length() == 0 }
  174|     10|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
  181|      3|        fn isEmpty(&self) -> B { self.length() == 0 }
  182|      4|        fn isEmpty(&self) -> B { if self.length() == 0 { true } else { false } }
  183|      3|        fn is_empty(&self) -> B { self.size == 0 }
  183|       |        fn isEmpty(&self) -> B;
  185|      4|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
  193|    111|        fn is_empty(&self) -> bool { self.elements.length() == 0 }
  206|      9|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
  207|      5|        fn isEmpty(&self) -> B { if self.data.is_empty() { true } else { false } }
  210|      7|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
  213|     10|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
  216|     11|        fn isEmpty(&self) -> B { if self.data.is_empty() { true } else { false } }
  222|     17|        fn isEmpty(&self) -> B { if self.length() == 0 { true } else { false } }
  229|     10|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
  229|      5|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
  232|      0|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
  232|      0|        fn is_empty(&self) -> B { self.tree.is_empty() }
  232|      0|        fn is_empty(&self) -> B { self.tree.is_empty() }
  232|      0|        fn is_empty(&self) -> B { self.tree.is_empty() }
  232|      0|        fn is_empty(&self) -> B { self.tree.is_empty() }
  232|      0|        fn is_empty(&self) -> B { self.tree.is_empty() }
  232|      0|        fn is_empty(&self) -> B { self.tree.is_empty() }
   23|       |        fn is_empty(&self) -> B;
  240|      3|        fn is_empty(&self) -> B { self.size() == 0 }
  250|      0|        fn isEmpty(&self) -> B { if self.length() == 0 { true } else { false } }
  267|    509|        fn is_empty(&self) -> bool { self.elements.length() == 0 }
  268|     10|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
  275|      1|        fn isEmpty(&self) -> B { ArraySeqS::isEmpty(self) }
  279|      0|        fn isEmpty(&self) -> B { if self.length() == 0 { true } else { false } }
   27|       |        fn is_empty(&self) -> B;
   27|       |        fn is_empty(&self) -> B;
   27|       |        fn is_empty(&self) -> B;
   27|       |        fn is_empty(&self) -> B;
   27|       |        fn is_empty(&self) -> B;
   27|       |        fn is_empty(&self) -> B;
  289|      5|        fn is_empty(&self) -> B { self.size() == 0 }
  296|    123|        fn is_empty(&self) -> bool { matches!(self.root, LeftistHeapNode::Leaf) }
  301|       |        fn is_empty(&self) -> B;
  309|      7|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
   33|       |        fn is_empty(&self) -> B;
   34|       |        fn is_empty(&self) -> bool;
   35|       |        fn is_empty(&self) -> B;
  362|      2|        fn is_empty(&self) -> B { if self.size() == 0 { true } else { false } }
   36|       |        fn is_empty(&self) -> B;
  388|      2|        fn isEmpty(&self) -> B { ArraySeqMtPerS::is_empty(self) }
   39|       |        fn is_empty(&self) -> B;
   39|       |        fn is_empty(&self) -> B;
   42|       |        fn is_empty(&self) -> B;
   44|       |        fn is_empty(&self) -> B;
   45|       |        fn is_empty(&self) -> B;
   46|       |        fn is_empty(&self) -> B;
   46|       |        fn is_empty(&self) -> B;
   46|       |        fn is_empty(&self) -> B;
   46|       |        fn is_empty(&self) -> B;
   47|       |        fn is_empty(&self) -> B;
   48|       |        fn is_empty(&self) -> bool;
   48|       |        fn is_empty(&self) -> bool;
   48|       |        fn is_empty(&self) -> bool;
   48|       |        fn is_empty(&self) -> bool;
   52|       |        fn is_empty(&self) -> B;
   52|       |        fn is_empty(&self) -> B;
   52|       |        fn isEmpty(&self) -> B;
   54|       |        fn is_empty(&self) -> B;
   54|       |        fn is_empty(&self) -> B;
   54|       |        fn is_empty(&self) -> B;
   55|      3|        fn is_empty(&self) -> B { self.root.is_leaf() }
   57|       |        fn is_empty(&self) -> B;
   57|       |        fn is_empty(&self) -> B;
   58|       |        fn isEmpty(&self) -> B;
   61|       |        fn is_empty(&self) -> bool;
   66|       |        fn isEmpty(&self) -> B;
   76|       |        fn isEmpty(&self) -> B;
   80|       |        fn isEmpty(&self) -> B;
   87|       |        fn is_empty(&self) -> B;
   12|       |        fn is_even(x: &N) -> B;
  120|     79|            let is_heads = rng.random::<bool>();
  173|  2.27k|        fn is_heap(&self) -> bool {
   64|     28|        fn is_heap(&self) -> bool {
  114|      0|        fn is_leaf(&self) -> B { BalBinTree::is_leaf(self) }
   35|       |        fn is_leaf(&self) -> B;
  163|  2.27k|        fn is_leftist(&self) -> bool {
   84|    308|                let is_occupied = self.is_position_occupied(table, i);
   86|    308|                if is_occupied {
  112|    308|        fn is_position_occupied<V: StT>(&self, table: &FlatHashTable<K, V, Self>, position: N) -> B
   23|       |    /// isPrime n = |{ x in 1..=floor(sqrt(n)) : n mod i == 0 }| == 1
   16|       |        fn is_prime(n: N) -> B;
   35|       |        fn is_reachable(&self, v: N) -> B;
   36|       |        fn is_reachable(&self, v: N) -> B;
   38|       |        fn is_reachable(&self, v: N) -> B;
   38|       |        fn is_reachable(&self, v: N) -> B;
   72|   544k|        fn is_red(link: &Link<T>) -> bool { matches!(link, Some(node) if node.color == Color::Red) }
   78|  2.93k|        fn is_red(link: &Link<T>) -> bool { matches!(link, Some(node) if node.color == Color::Red) }
  218|      1|        fn isSingleton(a: &ArraySeqStPerS<T>) -> bool {
  225|      4|        fn isSingleton(a: &ArraySeqStEphS<T>) -> bool {
  282|    804|        fn isSingleton(a: &ArraySeqMtPerS<T>) -> bool {
  284|      3|        fn isSingleton(a: &ArraySeqMtEphS<T>) -> bool {
   58|       |        fn isSingleton(a: &ArraySeqMtEphS<T>) -> bool;
   60|       |        fn isSingleton(a: &ArraySeqStEphS<T>) -> bool;
   64|       |        fn isSingleton(a: &ArraySeqStPerS<T>) -> bool;
   75|       |        fn isSingleton(a: &ArraySeqMtPerS<T>) -> bool;
  120|       |        fn isSingleton(&self) -> B;
  135|      1|        fn isSingleton(&self) -> B { if self.data.len() == 1 { true } else { false } }
  145|       |        fn isSingleton(&self) -> B;
  157|       |        fn isSingleton(&self) -> B;
  158|       |        fn isSingleton(&self) -> B;
  159|     10|        fn isSingleton(&self) -> B { if self.len() == 1 { true } else { false } }
  159|       |        fn isSingleton(&self) -> B;
  164|      3|        fn isSingleton(&self) -> B { if self.length() == 1 { true } else { false } }
  182|      3|        fn isSingleton(&self) -> B { self.length() == 1 }
  183|      2|        fn isSingleton(&self) -> B { if self.length() == 1 { true } else { false } }
  184|       |        fn isSingleton(&self) -> B;
  209|      6|        fn isSingleton(&self) -> B { if self.data.len() == 1 { true } else { false } }
  218|      4|        fn isSingleton(&self) -> B { if self.data.len() == 1 { true } else { false } }
  224|      7|        fn isSingleton(&self) -> B { if self.length() == 1 { true } else { false } }
  252|      0|        fn isSingleton(&self) -> B { if self.length() == 1 { true } else { false } }
  277|      1|        fn isSingleton(&self) -> B { ArraySeqS::isSingleton(self) }
  281|      0|        fn isSingleton(&self) -> B { if self.length() == 1 { true } else { false } }
  390|      3|        fn isSingleton(&self) -> B { ArraySeqMtPerS::is_singleton(self) }
   54|       |        fn isSingleton(&self) -> B;
   60|       |        fn isSingleton(&self) -> B;
   70|       |        fn isSingleton(&self) -> B;
   77|       |        fn isSingleton(&self) -> B;
   84|       |        fn isSingleton(&self) -> B;
  171|     13|                && is_sorted(&self.balanced_tree_result)
  172|     13|                && is_sorted(&self.binary_heap_result)
  173|     13|                && is_sorted(&self.leftist_heap_result)
  170|     13|                && is_sorted(&self.sorted_list_result)
  167|    340|            fn is_sorted<T: Ord>(vec: &[T]) -> bool { vec.windows(2).all(|w| w[0] <= w[1]) }
  318|       |        fn is_sorted<T: Ord>(vec: &[T]) -> bool;
  217|     36|            if is_successful {
  271|     44|            if is_successful {
   65|     26|            let is_valid = Self::are_relatively_prime(h2_value, table_size);
   91|      7|            let is_valid = issues.is_empty();
   16|       |        fn is_vowel(c: &char) -> B;
  127|       |        type Item = T;
  131|       |        type Item = Pair<T, T>;
  134|       |        type Item = T;
  140|       |        type Item = &'a T;
  145|       |        type Item = T;
  146|       |        type Item = &'a mut T;
  147|       |        type Item = KeyProb<T>;
  149|       |        type Item = Pair<T, T>;
  151|       |        type Item = MatrixDim;
  152|       |        type Item = T;
  152|       |        type Item = T;
  154|       |        type Item = KeyProb<T>;
  158|       |        type Item = MatrixDim;
  159|       |        type Item = T;
  163|       |        type Item = Pair<T, T>;
  178|       |        type Item = KeyProb<T>;
  179|  59.3k|                let item = a.nth(i);
  181|       |        type Item = Pair<T, T>;
  183|       |        type Item = MatrixDim;
  185|       |        type Item = KeyProb<T>;
  190|       |        type Item = MatrixDim;
  192|       |        type Item = KeyProb<T>;
  197|       |        type Item = MatrixDim;
  200|       |        type Item = Pair<T, T>;
  204|       |        type Item = KeyProb<T>;
  205|       |        type Item = &'a T;
  205|       |        type Item = MatrixDim;
  217|       |        type Item = KeyProb<T>;
  218|       |        type Item = MatrixDim;
  227|       |        type Item = T;
  228|      7|                let item = a.nth_cloned(i);
  241|       |        type Item = T;
  254|     14|                let item = a.nth(i);
  259|       |        type Item = MatrixDim;
  260|       |        type Item = KeyProb<T>;
  263|      2|            let item = a.nth_cloned(0);
  267|      6|                let item = a.nth_cloned(i);
  269|       |        type Item = &'a T;
  275|     22|                let item = a.nth(i);
  275|       |        type Item = MatrixDim;
  276|       |        type Item = KeyProb<T>;
  285|       |        type Item = MatrixDim;
  286|       |        type Item = KeyProb<T>;
  310|       |        type Item = &'a T;
  324|      5|                let item = a.nth_cloned(i);
  351|       |        type Item = &'a T;
  358|       |        type Item = &'a mut T;
  360|      5|                let item = a.nth_cloned(i);
  365|       |        type Item = T;
  407|      3|            for item in &guard[self.range.start..self.range.end] {
   52|       |        type Item = &'a T;
   59|       |        type Item = T;
   85|       |        type Item = &'a T;
   87|       |        type Item = &'a T;
   92|       |        type Item = T;
   94|       |        type Item = T;
   44|       |        // Iterate over all edges
   45|       |        // Iterate through all vertices
   59|       |        // Iterate up to |V| rounds
   69|       |        // Iterate up to |V| rounds
  129|       |        fn iterate<A, F: Fn(&A, &T) -> A>(a: &ArraySeqStPerS<T>, f: &F, seed: A) -> A;
  154|       |        fn iterate<A: StT, F: Fn(&A, &T) -> A + Send + Sync>(a: &ArraySeqMtEphS<T>, f: &F, x: A) -> A;
  160|      2|        fn iterate<A: StT, F: Fn(&A, &T) -> A>(a: &ArraySeqStPerS<T>, f: &F, x: A) -> A {
  160|       |        fn iterate<A: StTInMtT, F: Fn(&A, &T) -> A + Send + Sync>(a: &ArraySeqMtPerS<T>, f: &F, x: A) -> A;
  168|       |        fn iterate<A, F: Fn(&A, &T) -> A>(a: &ArraySeqStEphS<T>, f: &F, seed: A) -> A;
  175|      3|        fn iterate<A: StT, F: Fn(&A, &T) -> A>(a: &ArraySeqStEphS<T>, f: &F, x: A) -> A {
  194|      2|        fn iterate<A: StTInMtT, F: Fn(&A, &T) -> A + Send + Sync>(a: &ArraySeqMtPerS<T>, f: &F, x: A) -> A {
  224|      2|        fn iterate<A: StTInMtT, F: Fn(&A, &T) -> A + Send + Sync>(a: &ArraySeqMtEphS<T>, f: &F, x: A) -> A {
  239|       |        fn iterate<A: StT, F: Fn(&A, &T) -> A>(a: &Self, f: &F, x: A) -> A;
  247|      3|        fn iterate<A, F: Fn(&A, &T) -> A>(a: &ArraySeqStPerS<T>, f: &F, seed: A) -> A {
  276|      4|        fn iterate<A, F: Fn(&A, &T) -> A>(a: &ArraySeqStEphS<T>, f: &F, seed: A) -> A {
  283|      2|        fn iterate<A: StTInMtT, F: Fn(&A, &T) -> A + Send + Sync>(a: &ArraySeqMtPerS<T>, f: &F, x: A) -> A {
  299|      1|        fn iterate<A, F: Fn(&A, &T) -> A>(a: &ArraySeqS<T>, f: &F, seed: A) -> A {
  321|      1|        fn iterate<A: StT, F: Fn(&A, &T) -> A + Send + Sync>(a: &ArraySeqMtEphS<T>, f: &F, x: A) -> A {
  332|      3|        fn iterate<A: StT, F: Fn(&A, &T) -> A>(a: &LinkedListStPerS<T>, f: &F, x: A) -> A {
  335|      2|        fn iterate<A: StT + Send, F: Fn(&A, &T) -> A + Send + Sync>(a: &Self, f: &F, seed: A) -> A {
  377|      2|        fn iterate<A: StT, F: Fn(&A, &T) -> A>(a: &Self, f: &F, x: A) -> A {
   46|       |        fn iterate<A: StTInMtT, F: Fn(&A, &T) -> A + Send + Sync>(a: &ArraySeqMtPerS<T>, f: &F, x: A) -> A;
   48|       |        fn iterate<A: StTInMtT, F: Fn(&A, &T) -> A + Send + Sync>(a: &ArraySeqMtEphS<T>, f: &F, x: A) -> A;
   50|       |        fn iterate<A: StT, F: Fn(&A, &T) -> A>(a: &ArraySeqStEphS<T>, f: &F, x: A) -> A;
   50|       |        fn iterate<A: StT, F: Fn(&A, &T) -> A>(a: &ArraySeqStPerS<T>, f: &F, x: A) -> A;
   69|       |        fn iterate<A: StT, F: Fn(&A, &T) -> A>(a: &LinkedListStPerS<T>, f: &F, x: A) -> A;
   70|       |        fn iterate<A: StT + Send, F: Fn(&A, &T) -> A + Send + Sync>(a: &Self, f: &F, seed: A) -> A;
   94|       |        fn iterate<A, F: Fn(&A, &T) -> A>(a: &ArraySeqS<T>, f: &F, seed: A) -> A;
  163|       |        fn iteratePrefixes<A: StTInMtT + 'static, F: Fn(&A, &T) -> A + Send + Sync>(
  203|      0|        fn iteratePrefixes<A: StTInMtT + 'static, F: Fn(&A, &T) -> A + Send + Sync>(
  242|       |        fn iteratePrefixes<A: StT, F: Fn(&A, &T) -> A>(a: &Self, f: &F, x: A) -> (LinkedListStEphS<A>, A);
  291|      1|        fn iteratePrefixes<A: StTInMtT + 'static, F: Fn(&A, &T) -> A + Send + Sync>(
  340|      1|        fn iteratePrefixes<A: StT, F: Fn(&A, &T) -> A>(
  385|      1|        fn iteratePrefixes<A: StT, F: Fn(&A, &T) -> A>(a: &Self, f: &F, x: A) -> (LinkedListStEphS<A>, A) {
   48|       |        fn iteratePrefixes<A: StTInMtT + 'static, F: Fn(&A, &T) -> A + Send + Sync>(
   72|       |        fn iteratePrefixes<A: StT, F: Fn(&A, &T) -> A>(
   29|       |    /// Iterates over edges sequentially, adding each edge to the matching
  220|       |    // Iterator implementation
   35|       |        /// Iterator over references to elements
   37|       |        /// Iterator over references to elements
   59|       |        /// Iterator over references to elements
   64|       |        /// Iterator over cloned elements (due to Mutex)
  262|      1|        fn iter_in_order(&self) -> ArraySeqStPerS<T> { self.tree.in_order() }
  262|      1|        fn iter_in_order(&self) -> ArraySeqStPerS<T> { self.tree.in_order() }
  262|      1|        fn iter_in_order(&self) -> ArraySeqStPerS<T> { self.tree.in_order() }
  262|      1|        fn iter_in_order(&self) -> ArraySeqStPerS<T> { self.tree.in_order() }
  262|      1|        fn iter_in_order(&self) -> ArraySeqStPerS<T> { self.tree.in_order() }
  345|      1|        fn iter_in_order(&self) -> ArraySeqStPerS<T> { self.tree.in_order() }
   57|       |        fn iter_in_order(&self) -> ArraySeqStPerS<T>;
   57|       |        fn iter_in_order(&self) -> ArraySeqStPerS<T>;
   57|       |        fn iter_in_order(&self) -> ArraySeqStPerS<T>;
   57|       |        fn iter_in_order(&self) -> ArraySeqStPerS<T>;
   57|       |        fn iter_in_order(&self) -> ArraySeqStPerS<T>;
   57|       |        fn iter_in_order(&self) -> ArraySeqStPerS<T>;
  104|      3|        fn iter(&self) -> std::collections::hash_set::Iter<'_, Pair<X, Y>> { self.rel.iter() }
  113|     23|        fn iter(&self) -> Iter<'_, Pair<X, Y>> { self.pairs.iter() }
  255|      0|        fn iter(&self) -> std::collections::hash_set::Iter<'_, T> { self.data.iter() }
   49|       |        fn iter(&self) -> std::collections::hash_set::Iter<'_, Pair<X, Y>>;
   50|       |        fn iter(&self) -> std::collections::hash_set::Iter<'_, T>;
   51|       |        fn iter(&self) -> Iter<'_, Pair<X, Y>>;
  106|     21|                        (i, j, new_value)
  106|     21|                        (i, j, new_value)
  108|  18.6k|                for j in 0..all_pairs.length() {
  109|    167|                memo_guard.insert((i, j), result);
  118|     39|            for j in 0..self.n {
  118|      9|                for j in 0..self.n {
  119|     39|                if j == v {
  121|     70|                memo_guard.insert((i, j), result);
  131|     61|                memo_guard.insert((i, j), result);
  147|      9|                for j in 0..self.n {
  148|      9|            while j < values2.len() {
  156|     36|                memo_guard.insert((i, j), result);
  158|     29|                memo_guard.insert((i, j), result);
  168|     10|            while j < other.elements.length() {
  170|   117k|            for j in 0..b.length() {
  175|      1|            memo_guard.contains_key(&(i, j))
  180|     13|            while j < other.entries.length() {
  188|      1|            memo_guard.contains_key(&(i, j))
  189|      0|                for j in 0..chain.length() {
  191|      0|            memo_guard.insert((i, j), value);
  191|  6.36k|                for j in 0..inner_seq.length() {
  194|    160|                for j in 0..chain.length() {
  216|    160|            for j in 0..b.length() {
  227|      2|            for j in 0..b.length() {
  237|     50|                for j in 0..inner.length() {
  244|  11.0k|            for j in 0..nb {
  245|    223|            for j in 0..b.length() {
  248|      5|                for j in 0..inner.length() {
  264|     11|            for j in 0..b.length() {
   26|  50.0M|                while j > 0 && slice[j - 1] > key {
  285|      2|            for j in 0..i {
  287|     11|                for j in 0..inner.length() {
  288|      3|            for j in i..size {
  290|     18|            for j in 0..b_len {
  294|      8|            for j in 0..b.length() {
  302|      6|        for j in 0..b_len {
  305|      1|                        for j in 0..group.1.length() {
  311|      0|                    for j in 0..chain.length() {
  313|      0|                        if j > 0 {
  324|     11|                for j in 0..inner.length() {
  328|      4|            for j in 0..i {
  331|     11|            for j in i..size {
  341|      4|            for j in 0..i {
  344|      5|            for j in i..size {
  345|    715|                for j in 0..inner_seq.length() {
  348|     13|            while j < other.entries.length() {
   37|      0|            for j in 0..b.length() {
  371|      4|            for j in 0..i {
  374|      5|            for j in i..size {
  389|     13|                for j in 0..inner.length() {
   42|     76|                for j in i..n {
   46|    254|                        for j in 0..n {
   46|    293|                        for j in 0..n {
   46|    312|                        for j in 0..n {
   46|     57|                for j in i..n {
   48|    173|                        for j in 0..n {
   60|     57|                for j in 0..self.n {
   64|     16|                for j in 0..self.n {
   66|    177|                        for j in 0..n {
   66|    186|                        for j in 0..n {
   66|    308|                        for j in 0..n {
   68|    249|                        for j in 0..n {
   69|     14|            for j in 0..=t_len {
   69|      9|            for j in 0..=t_len {
   71|    183|            self.memo.insert((i, j), result);
   72|     10|            for j in 0..=t_len {
   72|      9|            for j in 0..=t_len {
   74|  1.46k|                for j in 0..word_tokens.length() {
   75|    239|            self.memo.insert((i, j), result);
   80|    131|            self.memo.insert((i, j), result);
   84|     61|            self.memo.insert((i, j), result);
   86|     19|            self.memo_table.insert((i, j), result);
   87|    183|                memo_guard.insert((i, j), result);
   87|     28|                let j = k - i;
   87|     35|                let j = k - i;
   88|     28|                if j > 0 && j <= t_len {
   88|     35|                if j > 0 && j <= t_len {
   89|     19|            memo.insert((i, j), result);
   90|    682|            self.memo.insert((i, j), result);
   91|     28|                    let j = k - i;
   91|     31|                    let j = k - i;
   92|     28|                    if j > 0 && j <= t_len { Some((i, j)) } else { None }
   92|     31|                    if j > 0 && j <= t_len { Some((i, j)) } else { None }
   93|    111|                memo_guard.insert((i, j), result);
   93|     15|                memo_guard.insert((i, j), result);
   95|     15|                memo_guard.insert((i, j), result);
   96|     12|            self.memo.insert((i, j), result);
   97|    114|                memo_guard.insert((i, j), result);
   99|     21|                .map(|(i, j)| {
   99|     21|                .map(|(i, j)| {
  183|      1|            memo_guard.get(&(i, j)).copied()
  196|      1|            memo_guard.get(&(i, j)).copied()
    8|       |//! - Johnson APSP: Work O(mn log n), Span O(m log n), Parallelism Θ(n) where n = |V|, m = |E|
    8|       |//! - Johnson APSP: Work O(mn log n), Span O(m log n), Parallelism Θ(n) where n = |V|, m = |E|
    8|       |//! - Johnson APSP: Work O(mn log n), Span O(mn log n) where n = |V|, m = |E|
    8|       |//! - Johnson APSP: Work O(mn log n), Span O(mn log n) where n = |V|, m = |E|
   27|       |        fn johnson_apsp(graph: &WeightedDirGraphStEphInt<usize>) -> AllPairsResultStEphInt;
   28|       |        fn johnson_apsp(graph: &WeightedDirGraphStEphFloat<usize>) -> AllPairsResultStEphFloat;
   32|       |        fn johnson_apsp(graph: &WeightedDirGraphMtEphFloat<usize>) -> AllPairsResultStEphFloat;
   32|       |        fn johnson_apsp(graph: &WeightedDirGraphMtEphInt<usize>) -> AllPairsResultStEphInt;
   14|       |pub mod JohnsonMtEphFloat {
   14|       |pub mod JohnsonMtEphInt {
   25|       |        /// Johnson's all-pairs shortest path algorithm
   26|       |        /// Johnson's all-pairs shortest path algorithm
   13|       |pub mod JohnsonStEphFloat {
   13|       |pub mod JohnsonStEphInt {
  387|       |        /// Join two priority queues where all elements in left <= all elements in right
    6|       |//! corresponding `join` operation reassembles a sequence while keeping it roughly
  153|      7|        let joined_set = OrderedSetStPer::join(&left_split, &right_split);
  270|      2|        fn join_key(left: &Self, right: &Self) -> Self { left.union(right, |v1, _v2| v1.clone()) }
  286|      1|        fn join_key(left: &Self, right: &Self) -> Self {
   59|       |        fn join_key(left: &Self, right: &Self) -> Self;
   69|       |        fn join_key(left: &Self, right: &Self) -> Self;
  252|      1|        fn join_key(&mut self, other: Self) {
  265|      1|        fn join_key(&mut self, other: Self) {
  281|      2|        fn join_key(&mut self, other: Self) { self.union(&other, |v1, _v2| v1.clone()); }
  311|      2|        fn join_key(&mut self, other: Self) { self.union(&other, |v1, _v2| v1.clone()); }
   62|       |        fn join_key(&mut self, other: Self);
   67|       |        fn join_key(&mut self, other: Self);
   75|       |        fn join_key(&mut self, other: Self);
   77|       |        fn join_key(&mut self, other: Self);
  219|      8|        fn join(left: &Self, right: &Self) -> Self { left.union(right) }
   60|       |        fn join(left: &Self, right: &Self) -> Self;
  109|      1|        fn join_mid(exposed: Exposed<T>) -> Self {
  155|      4|        fn join_mid(exposed: Exposed<T>) -> Self { ParamBST::join_mid(exposed) }
  295|       |        fn join_mid(exposed: Exposed<T>) -> Self;
  298|      8|        fn join_mid(exposed: Exposed<T>) -> Self { ParamBST::join_mid(exposed) }
  354|      1|        fn join_mid(exposed: Exposed<T>) -> Self { ParamTreap::join_mid(exposed) }
   38|       |        fn join_mid(exposed: Exposed<T>) -> Self;
   39|       |        fn join_mid(exposed: Exposed<T>) -> Self;
   68|     81|        fn join_mid(exposed: Exposed<T>) -> Self {
   94|  7.83k|        fn join_mid(exposed: Exposed<T>) -> Self {
  129|  2.19k|        fn join_m(left: Self, key: T, right: Self) -> Self { ParamBST::join_mid(Exposed::Node(left, key, right)) }
  256|      1|        fn join_m(left: Self, pivot: T, right: Self) -> Self { BSTSetAVLMtEph::join_m(left, pivot, right) }
  256|      1|        fn join_m(left: Self, pivot: T, right: Self) -> Self { BSTSetBBAlphaMtEph::join_m(left, pivot, right) }
  256|      1|        fn join_m(left: Self, pivot: T, right: Self) -> Self { BSTSetRBMtEph::join_m(left, pivot, right) }
  256|      1|        fn join_m(left: Self, pivot: T, right: Self) -> Self { BSTSetSplayMtEph::join_m(left, pivot, right) }
  256|      1|        fn join_m(left: Self, pivot: T, right: Self) -> Self { BSTSetTreapMtEph::join_m(left, pivot, right) }
  322|      1|        fn join_m(left: Self, pivot: T, right: Self) -> Self {
   51|       |        fn join_m(left: Self, pivot: T, right: Self) -> Self;
   51|       |        fn join_m(left: Self, pivot: T, right: Self) -> Self;
   51|       |        fn join_m(left: Self, pivot: T, right: Self) -> Self;
   51|       |        fn join_m(left: Self, pivot: T, right: Self) -> Self;
   51|       |        fn join_m(left: Self, pivot: T, right: Self) -> Self;
   51|       |        fn join_m(left: Self, pivot: T, right: Self) -> Self;
   99|     32|        fn join_m(left: Self, key: T, right: Self) -> Self { ParamBST::join_mid(Exposed::Node(left, key, right)) }
  218|      1|        fn join(&mut self, other: Self) { self.union(&other); }
  227|      1|        fn join(&mut self, other: Self) { self.union(&other); }
   61|       |        fn join(&mut self, other: Self);
   61|       |        fn join(&mut self, other: Self);
  111|      3|        fn join_pair_inner(left: Self, right: Self) -> Self {
  142|     53|        fn join_pair_inner(left: Self, right: Self) -> Self {
  145|    319|        fn join_pair_inner(left: Self, right: Self) -> Self {
  254|      1|        fn join_pair(left: Self, right: Self) -> Self { BSTSetAVLMtEph::join_pair(left, right) }
  254|      1|        fn join_pair(left: Self, right: Self) -> Self { BSTSetBBAlphaMtEph::join_pair(left, right) }
  254|      1|        fn join_pair(left: Self, right: Self) -> Self { BSTSetRBMtEph::join_pair(left, right) }
  254|      1|        fn join_pair(left: Self, right: Self) -> Self { BSTSetSplayMtEph::join_pair(left, right) }
  254|      1|        fn join_pair(left: Self, right: Self) -> Self { BSTSetTreapMtEph::join_pair(left, right) }
  314|      1|        fn join_pair(left: Self, right: Self) -> Self {
   49|       |        fn join_pair(left: Self, right: Self) -> Self;
   49|       |        fn join_pair(left: Self, right: Self) -> Self;
   49|       |        fn join_pair(left: Self, right: Self) -> Self;
   49|       |        fn join_pair(left: Self, right: Self) -> Self;
   49|       |        fn join_pair(left: Self, right: Self) -> Self;
   49|       |        fn join_pair(left: Self, right: Self) -> Self;
  188|      1|        fn join_pair(&self, other: Self) -> Self { ParamBST::join_pair_inner(self.clone(), other) }
  316|       |        fn join_pair(&self, other: Self) -> Self;
  350|      1|        fn join_pair(&self, other: Self) -> Self { ParamBST::join_pair_inner(self.clone(), other) }
  404|      1|        fn join_pair(&self, other: Self) -> Self { ParamTreap::join_pair_inner(self.clone(), other) }
   52|       |        fn join_pair(&self, other: Self) -> Self;
   60|       |        fn join_pair(&self, other: Self) -> Self;
  151|      0|        fn join(tree: PrimTreeSeqStTree<T>) -> Self {
   46|       |        fn join(tree: PrimTreeSeqStTree<T>) -> Self;
   86|  1.11k|        fn join_with_priority(left: ParamTreap<T>, key: T, priority: i64, right: ParamTreap<T>) -> ParamTreap<T> {
  104|      1|        let k = path.length();
  105|      1|        if k < 2 {
  105|      1|        let k = path.length();
  106|      1|        if k < 2 {
  118|  1.46k|                for k in 0..doc_ids.length() {
  132|      1|        let k = path.length();
  133|      1|        if k < 2 {
  133|      1|        let k = path.length();
  134|      1|        if k < 2 {
  139|  11.7k|            for k in 0..seq.length() {
   14|       |        key: K,
   16|      8|            for (k, v) in self.iter_mut() {
   16|       |        key: K,
   17|      3|                if k == &key {
  176|     16|            key: &K,
   17|      8|            for (k, v) in self.iter_mut() {
   18|      3|                if k == &key {
   20|    100|            if k >= n || n == 0 {
   20|     84|            if k >= n || n == 0 {
   20|     85|            if k >= n || n == 0 {
   22|     88|            if k >= n || n == 0 {
  238|      1|    key: &K,
   26|      7|            for (k, v) in self.iter() {
   27|      7|            for (k, v) in self.iter() {
   27|      7|                if k == key {
   28|      7|                if k == key {
  311|      6|            for k in 0..updates.length() {
  323|      5|            for k in 0..updates.length() {
   34|     16|        let k: N = (n as f64).sqrt().floor() as N;
   38|      2|                if k == key {
  409|      1|            keys: &[K],
   42|     72|            if k < left_count {
   42|     72|            if k < left_count {
   42|     83|            if k < left_count {
   44|     71|            if k < left_count {
   45|    192|                    for k in i..=j {
   48|     13|            for k in 1..=(s_len + t_len) {
   48|     20|            for k in 1..=(s_len + t_len) {
   50|     13|            for k in 1..=(s_len + t_len) {
   50|     16|            for k in 1..=(s_len + t_len) {
   51|     13|                self.compute_diagonal_parallel(Arc::clone(&table), k);
   51|     16|                self.compute_diagonal_parallel(Arc::clone(&table), k);
   55|      2|        let k = path.length();
   56|      2|        if k < 2 {
   56|      7|        let k = path.length();
   57|      7|        if k < 2 {
   78|      1|        let k = path.length();
   79|      1|        if k < 2 {
   79|      2|        let k = path.length();
   80|      2|        if k < 2 {
  103|    724|                        key: ka,
  115|    724|                    if ka <= kb {
  116|       |                        // ka is smaller, so it becomes the root
  133|    170|                                key: ka,
  109|    724|                        key: kb,
  121|    554|                                key: kb,
  129|       |                        // kb is smaller, so it becomes the root
  106|      6|                    if keep {
  109|       |            // Keep as primitive - tabulate is one of the 7 APAS primitives
  185|     11|                let keep = handle.join().unwrap();
  190|       |            // Keep as primitive - ninject is one of the 7 APAS primitives
  199|       |            // Keep as primitive - flatten is one of the 7 APAS primitives
  204|       |            // Keep as primitive - inject is one of the 7 APAS primitives
  209|       |            // Keep as primitive - ninject is one of the 7 APAS primitives
  216|       |            // Keep as primitive - flatten is one of the 7 APAS primitives
  222|     12|                let keep = handle.join().unwrap();
  257|       |            // Keep as primitive - flatten is one of the 7 APAS primitives
  275|       |            // Keep as primitive - flatten is one of the 7 APAS primitives
   64|       |    // Keep only thread-safety and size requirements.
   65|       |            // Keep as primitive - delegates to tabulate
   71|       |            // Keep as primitive - delegates to tabulate
   72|       |            // Keep as primitive - delegates to tabulate
   83|       |            // Keep as primitive - delegates to tabulate
   87|       |            // Keep as primitive - subseq is one of the 7 APAS primitives
   92|       |            // Keep as primitive - tabulate is one of the 7 APAS primitives
   93|       |            // Keep as primitive - subseq is one of the 7 APAS primitives
   94|       |            // Keep as primitive - subseq is one of the 7 APAS primitives
   98|       |            // Keep as primitive - tabulate is one of the 7 APAS primitives
   99|       |            // Keep as primitive - tabulate is one of the 7 APAS primitives
  229|     12|                if keep_results[i] == true {
  192|     11|                if keep_results.nth_cloned(i) == true {
  204|      4|                if keep_results.nth_cloned(i) == true {
  215|     11|                if keep_results.nth_cloned(i) == true && result_idx < kept_count {
  186|     11|                keep_results.set(i, keep).unwrap();
  197|      2|            if kept_count == 0 {
  174|      3|            if kept.is_empty() {
  234|      2|            if kept_values.is_empty() {
  103|      0|                make_node(left, key, priority, right)
  109|     14|                    let key = key_seq.nth(i);
  114|      1|                    ParamTreap::join_with_priority(left, key, priority, right)
  116|       |                    // Key exists, update value
  117|       |                let key = &pair.0;
  125|      0|                let key = key_seq.nth(0);
  130|    775|                    if key == &node.key {
  133|    404|                        Self::find_link(&node.left, key)
  134|      0|            Self::probe(table, key, 0)
  135|    261|                        Self::find_link(&node.right, key)
  139|     15|                        let key = left_seq.nth(i);
  141|      2|- insert(table, key, value): Hash key to find inner table, insert into that table
  142|      2|- lookup(table, key): Hash key to find inner table, lookup in that table
  149|     19|                    let key = right_seq.nth(i);
   14|       |        pub key: Key,
  153|     34|                    let key = node.key.clone();
   15|       |        pub key: T,
   15|       |        pub key: T,
   16|       |        pub key: T,
   16|       |        pub key: T,
  172|    781|                if key < node.key {
  175|    190|                    let key = node.key.clone();
  187|      3|                    // Key exists, update value
  189|    177|                    if key < &node.key {
  189|       |        // Key ordering operations (ADT 43.1 adapted for tables)
  190|     71|                        Self::rank_link(&node.left, key)
  198|    241|                    let key = node.key.clone();
   19|       |        pub key: String,
  146|     28|                match key1.cmp(key2) {
  203|     40|                match key1.cmp(key2) {
  202|       |        // Key ordering operations (ADT 43.1 adapted for tables)
  203|  1.90k|                    if key == &node.key {
  206|    660|                        Self::find_link(&node.left, key)
  208|    976|                        Self::find_link(&node.right, key)
  217|      0|            writeln!(f, "Key: '{}', Table size: {}", self.key, self.table_size)?;
  223|      6|                        ParamTreap::join_with_priority(left_filtered, key, priority, right_filtered)
  226|    136|                        ParamBST::join_m(left_filtered, key, right_filtered)
  231|       |        // Key ordering operations (ADT 43.1 adapted for tables) - Sequential implementation
   24|  10.0k|                let key = slice[i].clone();
  252|       |                // Key exists, combine values and replace
  254|       |                // Key exists, combine values
  258|      8|        for key in &keys {
  261|  4.74k|                    if key < *k {
  263|       |                // Key doesn't exist, add new entry
  279|  20.5M|                let key = *next_key;
  281|  20.5M|                Some(Box::new(AVLTreeNode::new(value, key)))
  283|       |                // Key doesn't exist, insert new entry
  288|   513k|                    if key < *k {
  292|      8|        for key in &keys {
  316|     11|        for (key, hash_val) in hash_demo {
  327|      8|        for key in &keys {
  330|      6|        for (key, sequence) in probe_demo {
   39|      1|        println!("Find key 2 in persistent table: {:?}", table_per.find(&2));
  392|     39|                let key = *next_key;
  392|      6|            for key in keys {
  394|     39|                Some(Box::new(AVLTreeNode::new(value, key)))
   40|      1|        println!("Find key 4 in persistent table: {:?}", table_per.find(&4));
  413|      6|            for key in keys {
   42|       |            // Key not found, insert at head
   44|       |        pub key: K,
  471|       |                // Key exists, combine values and replace
   50|      1|            write!(f, "{{key: {}, val: {}}}", self.key, self.val)
   51|       |        /// KEY ADVANTAGE: Efficient meld following right spines
   51|       |        // Key ordering operations (ADT 43.1 adapted for tables)
   52|      3|            Self::insert_chained(table, key, value);
  526|       |                // Key doesn't exist, add new entry
   54|       |        // Key ordering operations (ADT 43.1 adapted for tables) - ephemeral semantics
   55|       |        // Key ordering operations (ADT 43.1 adapted for tables)
   56|      3|            Self::lookup_chained(table, key)
   59|       |        // Key ordering operations (ADT 43.1 adapted for tables) - sequential (inherently sequential on trees)
   60|      1|            Self::delete_chained(table, key)
   61|       |        // Key ordering operations (ADT 43.1 adapted for tables)
   62|      3|            Self::insert_chained(table, key, value);
   64|       |        // Key ordering operations (ADT 43.1 adapted for tables) - sequential (inherently sequential on trees)
   66|      3|            Self::lookup_chained(table, key)
   70|      1|            Self::delete_chained(table, key)
   87|      3|            Self::insert_chained(table, key, value);
   90|     14|                let key = key_seq.nth(i);
   91|      3|            Self::lookup_chained(table, key)
   95|      1|            Self::delete_chained(table, key)
   97|      0|                make_node(left, key, priority, right)
   97|      1|            Self::probe(table, key, 0)
   99|      0|            Self::probe(table, key, 0)
   99|    370|                if key < node.key {
  444|      9|            let key_clone2 = key.clone();
  431|      9|            let key_clone = key.clone();
  484|      2|                let key_clone = key.clone();
  237|  15.3k|                match key.cmp(mid_key) {
  232|  13.3k|                match key.cmp(&pair.0) {
  401|  33.1k|                match key.cmp(&pair.0) {
   17|       |        E: KeyEquality<K> + Clone,
   31|       |        E: KeyEquality<K> + Clone,
  151|       |    impl KeyEquality<String> for CaseInsensitiveStringEquality {
  112|    272|            let key_existed = matches!(self.table.nth(pos), Entry::Live(existing_key, _) if existing_key == &key);
  287|    157|            let key_existed = matches!(self.table.nth(pos), Entry::Live(existing_key, _) if existing_key == &key);
  103|     18|                keys: key_probs,
  108|     27|            let key_probs = keys
  110|      2|                keys: key_probs,
  115|     27|                keys: key_probs,
  122|      2|                keys: key_probs,
  140|     12|            let key_probs: Vec<KeyProb<T>> = keys
  152|     22|            let key_probs: Vec<KeyProb<T>> = keys
   96|     18|            let key_probs = keys
   30|    259|            let key_ptr = key as *const Key as *const u8;
  156|     17|            let keys: Vec<V> = self.parent.keys().cloned().collect();
  217|      0|            let keys: Vec<V> = self.parent.keys().cloned().collect();
  255|      2|        let keys = vec!["key1".to_string(), "key2".to_string(), "key3".to_string()];
  266|      4|                    // Keys >= k go to the right side
  289|      2|        let keys = vec!["alpha".to_string(), "beta".to_string(), "gamma".to_string()];
  295|       |                    // Keys >= k go to the right side
  324|      2|        let keys = vec!["hash1".to_string(), "hash2".to_string(), "hash3".to_string()];
   35|       |        pub keys: Vec<String>,
   72|      2|        let keys = vec![
   88|      1|                return keys;
   97|     28|            let keys: Vec<K> = (0..self.entries.length())
  580|      4|            let keys_clone2 = keys.clone();
  636|      4|            let keys_clone2 = keys.clone();
  584|     10|                if keys_clone2.find(&pair.0) {
  640|     10|                if !keys_clone2.find(&pair.0) {
  567|      4|            let keys_clone = keys.clone();
  623|      4|            let keys_clone = keys.clone();
  573|     10|                    if keys_clone.find(&pair.0) {
  629|     10|                    if !keys_clone.find(&pair.0) {
  106|      4|            let key_seq = keys.to_seq();
  116|      6|            let key_seq = keys.to_seq();
   87|      5|            let key_seq = keys.to_seq();
  557|      0|                if !keys.find(&pair.0) {
  613|      0|                if keys.find(&pair.0) {
  112|     71|                    let keys_guard = self.keys.lock().unwrap();
  176|      9|                let keys_guard = self.keys.lock().unwrap();
  194|      9|            let keys_guard = self.keys.lock().unwrap();
  219|      6|            let keys_guard = self.keys.lock().unwrap();
  252|      1|                let keys_guard = self.keys.lock().unwrap();
  268|      0|                    let keys_guard = arc.lock().unwrap();
  280|      1|            let keys_guard = self.keys.lock().unwrap();
  290|      0|            let keys_guard = self.keys.lock().unwrap();
  114|    179|                        .map(|k| keys_guard[i + k].prob)
   31|    259|            let key_size = std::mem::size_of::<Key>();
  175|      9|            let keys_len = {
  180|      9|            if keys_len == 0 {
  190|      8|            self.obst_rec(0, keys_len)
  251|      1|            let keys_len = {
  141|      1|        fn keys_mut(&mut self) -> &mut Vec<KeyProb<T>> { &mut self.keys }
   45|       |        fn keys_mut(&mut self) -> &mut Vec<KeyProb<T>>;
  128|      5|        fn keys(&self) -> &Vec<KeyProb<T>> { &self.keys }
  139|     13|        fn keys(&self) -> &Vec<KeyProb<T>> { &self.keys }
  177|      0|        fn keys(&self) -> &Arc<Vec<KeyProb<T>>> { &self.keys }
  193|      9|        fn keys(&self) -> Vec<KeyProb<T>> {
  209|      2|        fn keys(&self) -> ArraySeqStPerS<K> {
  312|      4|        fn keys(&self) -> ArraySeqStPerS<K> {
   42|       |        fn keys(&self) -> &Vec<KeyProb<T>>;
   42|       |        fn keys(&self) -> &Vec<KeyProb<T>>;
   45|       |        fn keys(&self) -> &Arc<Vec<KeyProb<T>>>;
   45|       |        fn keys(&self) -> Vec<KeyProb<T>>;
   59|       |        fn keys(&self) -> ArraySeqStPerS<K>;
   99|       |        fn keys(&self) -> ArraySeqStPerS<K>;
  132|     32|                key: key.to_string(),
  161|     27|                key: key.to_string(),
   93|     31|                key: key.to_string(),
   41|       |    // Key-value struct with named fields
  379|       |        "SimpleIntegerHash (Knuth multiplicative)"
   21|       |        fn kruskal_mst<V: StT + Hash + Ord>(
   19|       |        /// Kruskal's MST algorithm
    7|       |pub mod KruskalStEph {
  124|     96|                memo_guard.insert((i, l), result);
  136|    105|                memo_guard.insert((i, l), result);
  178|     38|                    let l = left_arc.clone();
  265|  50.0k|            let l = ArraySeqStPerS::reduce(&left, f, id.clone());
  365|     25|            let l = <LinkedListStPerS<T> as LinkedListStPerTrait<T>>::reduce(&left, f, id.clone());
  406|     20|            let l = <LinkedListStEphS<T> as LinkedListStEphTrait<T>>::reduce(&left, f, id.clone());
   82|     87|            self.memo.insert((i, l), result);
   94|    232|            self.memo.insert((i, l), result);
  104|    724|                        left: la,
  127|    554|                        Self::make_node(ka, *la, melded_right)
  134|    170|                                left: la,
    7|       |pub mod LabDirGraphMtEph {
  233|       |    macro_rules! LabDirGraphMtEphLit {
   60|       |        for LabDirGraphMtEph<V, L>
    4|       |pub mod LabDirGraphStEph {
  143|       |    macro_rules! LabDirGraphStEphLit {
  128|      2|            write!(f, "LabDirGraph(V: {}, A: {})", self.vertices, self.labeled_arcs)
  218|      0|            write!(f, "LabDirGraph(V: {}, A: {})", self.vertices, self.labeled_arcs)
  139|     92|            let LabEdge(a, b, _) = edge;
  156|    107|            let LabEdge(a, b, w) = edge;
  170|     18|            let LabEdge(a, b, _) = edge;
  187|      6|            let LabEdge(a, b, w) = edge;
  190|     18|            let LabEdge(a, b, _) = edge;
  207|     12|            let LabEdge(a, b, w) = edge;
  105|     13|        for LabEdge(from, to, weight) in graph.labeled_arcs().iter() {
  116|     15|        for LabEdge(from, to, weight) in graph.labeled_arcs().iter() {
  127|     13|        for LabEdge(from, to, weight) in graph.labeled_arcs().iter() {
  143|     15|        for LabEdge(from, to, weight) in graph.labeled_arcs().iter() {
  101|     14|                let LabEdge(u, v, _) = edge;
  110|     14|                let LabEdge(u, v, _) = edge;
   70|     27|            let LabEdge(_u1, _v1, w1) = e1;
  171|     19|            let LabEdge(_u, _v, w) = edge;
   71|     27|            let LabEdge(_u2, _v2, w2) = e2;
   77|     24|            let LabEdge(u, v, _w) = edge;
   99|     14|            let LabEdge(_u, _v, w) = edge;
  221|       |    /// Labeled Edge wrapper to enable edges with labels.
  104|    116|                if labeled_arc.0 == *from && labeled_arc.1 == *to {
  108|     25|                if labeled_arc.0 == *v {
  119|    476|                    if labeled_arc.0 == *v {
   89|     67|                if labeled_arc.0 == *from && labeled_arc.1 == *to {
   95|     26|                if labeled_arc.0 == *from && labeled_arc.1 == *to {
   98|     43|                if labeled_arc.0 == *from && labeled_arc.1 == *to {
  103|    116|            for labeled_arc in self.labeled_arcs.iter() {
  107|     25|            for labeled_arc in self.labeled_arcs.iter() {
  118|     20|                if labeled_arc.1 == *v {
  171|    251|                    if labeled_arc.1 == *v {
  117|     20|            for labeled_arc in self.labeled_arcs.iter() {
  118|    611|                for labeled_arc in arcs {
  170|    319|                for labeled_arc in arcs {
   74|      9|                arcs.insert(Edge(labeled_arc.0.clone(), labeled_arc.1.clone()));
   80|      8|                arcs.insert(Edge(labeled_arc.0.clone_mt(), labeled_arc.1.clone_mt()));
   73|      9|            for labeled_arc in self.labeled_arcs.iter() {
   79|      8|            for labeled_arc in self.labeled_arcs.iter() {
   88|     67|            for labeled_arc in self.labeled_arcs.iter() {
   94|     26|            for labeled_arc in self.labeled_arcs.iter() {
   97|     43|            for labeled_arc in self.labeled_arcs.iter() {
  149|       |            let labeled_arcs = $crate::SetLit![ $( $crate::Types::Types::LabEdge($from, $to, $label) ),* ];
  239|       |            let labeled_arcs = $crate::SetLit![ $( $crate::Types::Types::LabEdge($from, $to, $label) ),* ];
   31|       |        fn labeled_arcs(&self) -> &Set<LabEdge<V, L>>;
   35|       |        fn labeled_arcs(&self) -> &Set<LabEdge<V, L>>;
   69|    781|        fn labeled_arcs(&self) -> &Set<LabEdge<V, L>> { &self.labeled_arcs }
   75|    124|        fn labeled_arcs(&self) -> &Set<LabEdge<V, L>> { &self.labeled_arcs }
  104|     20|                if (labeled_edge.0 == *v1 && labeled_edge.1 == *v2) || (labeled_edge.0 == *v2 && labeled_edge.1 == *v1)
  109|     19|                if (labeled_edge.0 == *v1 && labeled_edge.1 == *v2) || (labeled_edge.0 == *v2 && labeled_edge.1 == *v1)
  114|    238|                if (labeled_edge.0 == *v1 && labeled_edge.1 == *v2) || (labeled_edge.0 == *v2 && labeled_edge.1 == *v1)
  120|  5.20k|                if labeled_edge.0 == *v {
  130|  1.07k|                    if labeled_edge.0 == *v {
   61|    525|                if labeled_edge.0 == *v {
   61|      9|                if labeled_edge.0 == *v {
   70|    109|                    if labeled_edge.0 == *v {
   70|      2|                    if labeled_edge.0 == *v {
   74|    150|                    if labeled_edge.0 == *v {
   74|      2|                    if labeled_edge.0 == *v {
   93|    311|                if labeled_edge.0 == *v {
   93|      9|                if labeled_edge.0 == *v {
   98|     57|                if (labeled_edge.0 == *v1 && labeled_edge.1 == *v2) || (labeled_edge.0 == *v2 && labeled_edge.1 == *v1)
  100|      4|            for labeled_edge in self.labeled_arcs().iter() {
  103|     20|            for labeled_edge in self.labeled_edges.iter() {
  105|  1.22k|            for labeled_edge in self.labeled_arcs().iter() {
  108|     19|            for labeled_edge in self.labeled_edges.iter() {
  106|  1.22k|                if labeled_edge.1 == *v {
  122|      3|                    if labeled_edge.1 == *v {
  129|      2|                    if labeled_edge.1 == *v {
  113|    238|            for labeled_edge in self.labeled_edges.iter() {
  119|  5.20k|            for labeled_edge in self.labeled_edges.iter() {
  121|      5|                for labeled_edge in arcs {
  126|      3|            for labeled_edge in self.labeled_arcs().iter() {
  128|      3|                for labeled_edge in arcs {
  129|  1.34k|                for labeled_edge in edges {
  137|      3|            for labeled_edge in self.labeled_arcs().iter() {
   74|  1.65k|                if labeled_edge.1 == *v {
  102|      2|                    edges.insert((labeled_edge.0.clone(), labeled_edge.1.clone(), labeled_edge.2));
  128|      2|                    edges.insert((labeled_edge.0.clone(), labeled_edge.1.clone(), labeled_edge.2));
  139|      2|                    edges.insert((labeled_edge.0.clone(), labeled_edge.1.clone(), labeled_edge.2));
   50|      2|                edges.insert((labeled_edge.0.clone(), labeled_edge.1.clone(), labeled_edge.2));
   50|      8|                edges.insert((labeled_edge.0.clone(), labeled_edge.1.clone(), labeled_edge.2));
   77|    144|                edges.insert(Edge(labeled_edge.0.clone(), labeled_edge.1.clone()));
   82|      2|                edges.insert((labeled_edge.0.clone(), labeled_edge.1.clone(), labeled_edge.2));
   82|      2|                edges.insert((labeled_edge.0.clone(), labeled_edge.1.clone(), labeled_edge.2));
   91|      2|                    edges.insert((labeled_edge.0.clone(), labeled_edge.1.clone(), labeled_edge.2));
   54|      0|                edges.insert((labeled_edge.0.clone_mt(), labeled_edge.1.clone_mt(), labeled_edge.2));
   54|      1|                edges.insert((labeled_edge.0.clone_mt(), labeled_edge.1.clone_mt(), labeled_edge.2));
   58|      0|                edges.insert((labeled_edge.0.clone_mt(), labeled_edge.1.clone_mt(), labeled_edge.2));
   58|      1|                edges.insert((labeled_edge.0.clone_mt(), labeled_edge.1.clone_mt(), labeled_edge.2));
   83|      2|                edges.insert(Edge(labeled_edge.0.clone_mt(), labeled_edge.1.clone_mt()));
  101|      4|                if labeled_edge.2 < threshold {
  107|    319|                    neighbors.insert((labeled_edge.0.clone(), labeled_edge.2));
  123|      2|                        neighbors.insert((labeled_edge.0.clone_mt(), labeled_edge.2));
  127|      3|                if labeled_edge.2 > threshold {
  130|      2|                        neighbors.insert((labeled_edge.0.clone_mt(), labeled_edge.2));
  138|      3|                if labeled_edge.2 < threshold {
   62|    117|                    neighbors.insert((labeled_edge.1.clone(), labeled_edge.2));
   62|      3|                    neighbors.insert((labeled_edge.1.clone(), labeled_edge.2));
   64|      2|                    neighbors.insert((labeled_edge.0.clone(), labeled_edge.2));
   71|      2|                        neighbors.insert((labeled_edge.1.clone_mt(), labeled_edge.2));
   71|     30|                        neighbors.insert((labeled_edge.1.clone_mt(), labeled_edge.2));
   73|      0|                        neighbors.insert((labeled_edge.0.clone_mt(), labeled_edge.2));
   75|      2|                        neighbors.insert((labeled_edge.1.clone_mt(), labeled_edge.2));
   75|    395|                    neighbors.insert((labeled_edge.0.clone(), labeled_edge.2));
   75|     48|                        neighbors.insert((labeled_edge.1.clone_mt(), labeled_edge.2));
   77|      0|                        neighbors.insert((labeled_edge.0.clone_mt(), labeled_edge.2));
   90|      4|                if labeled_edge.2 > threshold {
   94|      3|                    neighbors.insert((labeled_edge.1.clone(), labeled_edge.2));
   94|     72|                    neighbors.insert((labeled_edge.1.clone(), labeled_edge.2));
   96|      2|                    neighbors.insert((labeled_edge.0.clone(), labeled_edge.2));
   49|      2|            for labeled_edge in self.labeled_arcs().iter() {
   49|      8|            for labeled_edge in self.labeled_edges().iter() {
   53|      1|            for labeled_edge in self.labeled_arcs().iter() {
   53|      1|            for labeled_edge in self.labeled_edges().iter() {
   57|      1|            for labeled_edge in self.labeled_arcs().iter() {
   57|      1|            for labeled_edge in self.labeled_edges().iter() {
   60|    525|            for labeled_edge in self.labeled_arcs().iter() {
   60|      9|            for labeled_edge in self.labeled_edges().iter() {
   69|    140|                for labeled_edge in arcs {
   69|      3|                for labeled_edge in edges {
   73|  1.65k|            for labeled_edge in self.labeled_arcs().iter() {
   73|    206|                for labeled_edge in arcs {
   73|      3|                for labeled_edge in edges {
   76|    144|            for labeled_edge in self.labeled_edges.iter() {
   81|      2|            for labeled_edge in self.labeled_arcs().iter() {
   81|      2|            for labeled_edge in self.labeled_edges().iter() {
   82|      2|            for labeled_edge in self.labeled_edges.iter() {
   89|      4|            for labeled_edge in self.labeled_arcs().iter() {
   92|    311|            for labeled_edge in self.labeled_arcs().iter() {
   92|      9|            for labeled_edge in self.labeled_edges().iter() {
   97|     57|            for labeled_edge in self.labeled_edges.iter() {
  181|       |            let labeled_edges = {
   21|     23|            let labeled_edges = edges
   21|     65|            let labeled_edges = edges
  231|       |            let labeled_edges = {
   25|     13|            let labeled_edges = edges
   25|     16|            let labeled_edges = edges
   25|      7|            let labeled_edges = edges
   25|      7|            let labeled_edges = edges
   49|     23|            let labeled_edges = edges
   49|     56|            let labeled_edges = edges
   31|       |        fn labeled_edges(&self) -> &Set<LabEdge<V, L>>;
   35|       |        fn labeled_edges(&self) -> &Set<LabEdge<V, L>>;
   72|    121|        fn labeled_edges(&self) -> &Set<LabEdge<V, L>> { &self.labeled_edges }
   78|     60|        fn labeled_edges(&self) -> &Set<LabEdge<V, L>> { &self.labeled_edges }
    7|       |pub mod LabUnDirGraphMtEph {
  225|       |    macro_rules! LabUnDirGraphMtEphLit {
  149|      1|        graph: &LabUnDirGraphMtEph<V, OrderedFloat<f64>>,
  182|      3|        graph: &LabUnDirGraphMtEph<V, OrderedFloat<f64>>,
  208|      1|        graph: &LabUnDirGraphMtEph<V, OrderedFloat<f64>>,
   22|       |            tree: &LabUnDirGraphMtEph<V, OrderedFloat<f64>>,
   58|      2|        graph: &LabUnDirGraphMtEph<V, OrderedFloat<f64>>,
   60|       |        for LabUnDirGraphMtEph<V, L>
   72|      6|        graph: &LabUnDirGraphMtEph<V, OrderedFloat<f64>>,
    4|       |pub mod LabUnDirGraphStEph {
  175|       |    macro_rules! LabUnDirGraphStEphLit {
  151|     43|        graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>,
  168|      2|        graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>,
  202|      6|        graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>,
   22|       |            graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>,
  234|      1|        graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>,
   24|       |            tree: &LabUnDirGraphStEph<V, OrderedFloat<f64>>,
   25|       |            graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>,
   32|       |            graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>,
   57|      7|        graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>,
   63|      2|        graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>,
   77|      6|        graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>,
   81|      8|        graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>,
  160|      4|            write!(f, "LabUnDirGraph(V: {}, E: {})", self.vertices, self.labeled_edges)
  210|      1|            write!(f, "LabUnDirGraph(V: {}, E: {})", self.vertices, self.labeled_edges)
  192|       |        fn large_example(size: usize) -> Vec<i32>;
  342|      1|            ("Random".to_string(), large_example(size)),
  118|       |            const LARGE_PRIME: u64 = 1000000007; // 10^9 + 7
  162|       |            const LARGE_PRIME: u64 = 1000000007;
  105|    111|                let last = len - 1;
  106|  5.81k|                        let last = len - 1;
  116|       |        // last A → 'tina'
   56|       |                // Last element: f(result[n-2], a[n-2])
   60|      9|                let last = a.nth_cloned(n - 1);
   85|       |                // Last element: f(result[n-2], a[n-2])
  227|    214|            let last_element = self.elements.nth(self.elements.length() - 1).clone();
   57|      5|                let last_elem_of_main = main_result.nth(n - 2).clone();
   86|      5|                let last_elem_of_main = main_result.nth_cloned(n - 2);
   61|      9|                let last_for_combine = last.clone();
   70|      9|                f_combine(&result, &last_for_combine)
  207|    487|            let last_index = new_elements.length() - 1;
  202|     10|        fn last_key(&self) -> Option<K> {
  215|      8|        fn last_key(&self) -> Option<K> {
  219|      3|        fn last_key(&self) -> Option<K> { self.base_table.last_key() }
  232|      3|        fn last_key(&self) -> Option<K> { self.base_table.last_key() }
  244|      8|        fn last_key(&self) -> Option<K> {
  253|      3|        fn last_key(&self) -> Option<K> { self.base_table.last_key() }
   53|       |        fn last_key(&self) -> Option<K>;
   56|       |        fn last_key(&self) -> Option<K>;
   59|       |        fn last_key(&self) -> Option<K>;
   61|       |        fn last_key(&self) -> Option<K>;
   65|       |        fn last_key(&self) -> Option<K>;
   68|       |        fn last_key(&self) -> Option<K>;
  164|      7|            let last_non_leaf = if seq.length() >= 2 { (seq.length() - 2) / 2 } else { 0 };
   58|      5|                let last_part = ArraySeqStEphS::singleton(f(&last_elem_of_main, a.nth(n - 2)));
   59|      5|                ArraySeqStEphS::append(&main_result, &last_part)
   88|      5|                let last_part = ArraySeqMtEphS::singleton(last_val);
   89|      5|                ArraySeqMtEphS::append(&main_result, &last_part)
  147|      6|        fn last(&self) -> Option<T> { self.elements.last().cloned() }
  161|     12|        fn last(&self) -> Option<T> {
  166|      5|        fn last(&self) -> Option<T> {
   50|       |        fn last(&self) -> Option<T>;
   51|       |        fn last(&self) -> Option<T>;
   51|       |        fn last(&self) -> Option<T>;
   87|      5|                let last_val = f(&last_elem_of_main, &a.nth_cloned(n - 2));
   39|     14|            let layer_size = current_layer.len();
   39|     14|            let layer_size = current_layer.len();
  110|    724|                        left: lb,
  122|    554|                                left: lb,
  140|    170|                        Self::make_node(kb, *lb, melded_right)
  299|      2|             positions lead to different probe patterns."
  110|      0|        fn leaf() -> Self { BalBinTree::leaf() }
   29|       |        fn leaf() -> Self;
  102|      5|                    let left = self.data[..mid].to_vec();
  110|    431|                let left = Self::left_child(i);
  115|    431|                if left < result.length() && result.nth(left) < result.nth(smallest) {
  127|  11.0k|            let left = rec(&a[..mid]);
  127|       |        ({ left: $left:expr, value: $value:expr, right: $right:expr }) => {
  128|  1.23M|            let left = rec(&a[..mid]);
  129|  11.0k|            Some(mk(a[mid].clone(), left, right))
  130|  1.23M|            Some(mk(a[mid].clone(), left, right))
  131|    111|                let (left, mid_and_right) = data.split_at_mut(lt);
  131|      7|        print!("  left: [");
  133|    105|            let left = a.subseq_copy(0, mid);
  133|  5.81k|                    let (left, mid_and_right) = data.split_at_mut(lt);
  140|    231|            let left = Self::size_link(&node.left) as f64;
  144|      0|                    let left = self.data[..mid].to_vec();
  162|     25|            let (left, _, right) = ParamBST::split_inner(self, &key);
  169|      2|            let (left, _, right) = ParamBST::split_inner(self, key);
  169|     38|            let left = a.subseq_copy(0, mid);
  172|    208|                let (left, mid_and_right) = data.split_at_mut(lt);
  173|    178|                    let (left, mid_and_right) = data.split_at_mut(lt);
  177|      7|                let left = a.subseq_copy(0, mid);
   17|       |        pub(crate) left: BalBinTree<T>,
  192|      7|                let left = a.subseq_copy(0, mid);
  196|    241|                    let left = node.left.clone();
   19|       |        pub left: Link<T>,
  203|      0|        let (left, right) = int_set.split_rank(4);
  221|  1.99k|            let left = a.subseq_copy(0, mid);
  228|  15.4k|            while left < right {
  229|    106|                let left = a.subseq_copy(0, mid);
  231|      4|            let left = a.subseq_copy(0, mid);
  233|  18.0k|            while left < right {
  234|      1|            let left = Self {
  237|  1.25k|            while left < right {
  243|      6|                let left = a.subseq_copy(0, mid);
  247|      1|            let left = Self {
   24|       |        pub left: Link<T>,
  260|      0|                let left = n.left.take().unwrap();
  263|  50.0k|            let left = a.subseq_copy(0, mid);
  268|      1|            let left = Self {
  295|      1|            let left = Self {
  308|      1|            let left = Self {
  314|  1.62k|            let (left, _, right) = ParamBST::split_inner(self, &key);
  318|     73|            let left = a.subseq_copy(0, mid);
  324|     27|            let (left, _, right) = ParamBST::split_inner(self, key);
  330|      1|            let left = Self {
   33|  1.02k|                    let left = a.nth(2 * i);
  343|  1.99k|            let left = a.subseq_copy(0, mid);
   34|  6.96k|            let left = self.left.read().unwrap();
  363|     25|            let left = a.subseq_copy(0, mid);
  367|    206|            let (left, _, right) = ParamTreap::split_inner(self, &key);
  369|       |            // Left heavy: check for Left-Right case
  371|      0|                let left = n.left.take().unwrap();
  378|      4|            let (left, _, right) = ParamTreap::split_inner(self, key);
  385|      2|            let left = self.to_vec();
  397|  37.7k|            while left < right {
  404|     20|            let left = a.subseq_copy(0, mid);
   43|     21|        let left = a.subseq(0, mid);
   43|     21|        let left = a.subseq_copy(0, mid);
   43|     25|                let left = ArraySeqMtPerS::tabulate(
   43|     28|                let left = ArraySeqStPerS::tabulate(
   43|     32|                let left = ArraySeqStEphS::tabulate(
   45|     24|                let left = ArraySeqMtEphS::tabulate(
   48|  1.02k|                    let left = a_arc.nth_cloned(2 * i);
   50|    114|                    let left = a_arc.nth_cloned(2 * i);
   54|       |        /// left child of node at index i
   56|      0|            let left = n.left.as_ref().unwrap().clone();
   56|      0|            let left = n.left.as_ref().unwrap().clone();
   66|  1.12k|                let left = Self::left_child(i);
   68|    198|                    let left = node.left.in_order();
   69|  1.12k|                if left < self.elements.length() {
   80|    346|                let (left, mid_and_right) = data.split_at_mut(lt);
   82|    155|                (right, left)
   82|    253|                    let (left, mid_and_right) = data.split_at_mut(lt);
   82|     37|                    let left = node.left.pre_order();
   83|     16|            let left = a.subseq(0, mid);
   84|     16|            let left = a.subseq_copy(0, mid);
   88|     29|            let left = a.subseq_copy(0, mid);
   93|      7|        print!("  left: [");
   98|    907|            let left = Self::size_link(&node.left) as f64;
  173|     38|            let left_arc = Arc::new(left);
  102|      0|                let left_arcs = right_arcs.split_off(mid);
  147|      0|                let left_arcs = right_arcs.split_off(mid);
  147|      0|                let left_arcs = right_arcs.split_off(mid);
  157|      0|                let left_arcs = right_arcs.split_off(mid);
  179|      0|                let left_arcs = right_arcs.split_off(mid);
  199|      0|                let left_arcs = right_arcs.split_off(mid);
  229|      0|                let left_arcs = right_arcs.split_off(mid);
   95|      0|                let left_arcs = right_arcs.split_off(mid);
  207|     59|            let left_array = ArraySeqStPerS::filter(&array_seq, &|elem| elem < k);
  212|      8|            let left_array = ArraySeqStPerS::filter(&array_seq, &|elem| elem < k);
  229|      1|            let (left_base, right_base) = self.base_table.split_key(k);
  235|      1|                base_table: left_base,
  242|      1|            let (left_base, right_base) = self.base_table.split_key(k);
  248|      1|                base_table: left_base,
  249|    271|                    let left_base = identity.clone();
  249|      4|                    let left_base = identity.clone();
  263|      1|            let (left_base, middle, right_base) = self.base_table.split_key(k);
  269|      1|                base_table: left_base,
  290|      1|            let (left_base, right_base) = self.base_table.split_rank_key(i);
  296|      1|                base_table: left_base,
  303|      1|            let (left_base, right_base) = self.base_table.split_rank_key(i);
  309|      1|                base_table: left_base,
  325|      1|            let (left_base, right_base) = self.base_table.split_rank_key(i);
  331|      1|                base_table: left_base,
   55|  1.55k|        fn left_child(i: N) -> N { 2 * i + 1 }
   34|      1|                return left.clone();
   39|     20|                return left.clone();
   47|     21|        let left_clone = left.clone();
   88|     16|            let left_clone = left.clone();
  107|     68|                        let left_cost = self.matrix_chain_rec(i, k);
  109|    114|                        let left_cost = self.obst_rec(i, k);
  117|     63|                        let left_cost = self.matrix_chain_rec(i, k);
  121|    179|                        let left_cost = self.obst_rec(i, k);
   72|     87|                        let left_cost = self.obst_rec(i, k);
   74|     50|                        let left_cost = self.matrix_chain_rec(i, k);
   84|    381|                        let left_cost = self.obst_rec(i, k);
   86|      6|                        let left_cost = self.matrix_chain_rec(i, k);
   67|     54|            let left_costs = costs[..mid].to_vec();
   73|     29|            let left_costs = costs[..mid].to_vec();
   76|    108|            let left_costs = costs[..mid].to_vec();
   83|     28|            let left_costs = costs[..mid].to_vec();
  165|      6|            let left_diff = self.difference(other);
  100|      0|                let left_edges = right_edges.split_off(mid);
  107|      0|                let left_edges = right_edges.split_off(mid);
  121|    108|                let left_edges = right_edges.split_off(mid);
  163|      0|                let left_edges = right_edges.split_off(mid);
  198|      2|            let left_elements = std::mem::take(&mut self.elements);
  208|      2|                    elements: left_elements,
  251|      1|            let left_elements = std::mem::take(&mut self.elements);
  256|      1|                    elements: left_elements,
  156|      5|            let left_entries = handle.join().unwrap();
  190|      4|            let left_entries = self.entries.subseq_copy(0, mid);
  247|      3|            let left_entries = self.entries.subseq_copy(0, mid);
  429|      9|            let left_entries = self.entries.subseq_copy(0, mid);
  482|      2|                let left_entries = self.entries.subseq_copy(0, mid);
  565|      4|            let left_entries = self.entries.subseq_copy(0, mid);
  621|      4|            let left_entries = self.entries.subseq_copy(0, mid);
   93|      4|            let left_entries = self.entries.subseq_copy(0, mid);
   97|      9|                ArraySeqMtEphS::tabulate(&|i| left_entries.nth_cloned(i).0, left_entries.length())
  270|      3|            let left_filtered = handle.join().unwrap();
  453|      9|            let left_filtered = handle.join().unwrap();
  589|      4|            let left_filtered = handle.join().unwrap();
  645|      4|            let left_filtered = handle.join().unwrap();
   98|     16|            let left_for_suffix = left.clone();
  155|     34|                    let left_guard = child.read().unwrap();
  156|     34|                    if left_guard.is_none() {
   94|     59|                    let left_h = node.left.height();
  234|      4|            let left_handle = thread::spawn(move || ArraySeqMtPerS::map(&left, f_clone));
  257|       |            let left_handle = std::thread::Builder::new()
  302|      6|            let left_handle = std::thread::spawn(move || Self::reduce(&left_slice, f_left, id_left));
  300|      1|                identity: left.identity.clone(),
  149|    190|                | LeftistHeapNode::Leaf => 0,
  157|      9|                | LeftistHeapNode::Leaf => 0,
  165|  1.15k|                | LeftistHeapNode::Leaf => true,
  175|  1.15k|                | LeftistHeapNode::Leaf => true,
  178|    714|                        | LeftistHeapNode::Leaf => true,
  182|    437|                        | LeftistHeapNode::Leaf => true,
  193|     12|                | LeftistHeapNode::Leaf => Vec::new(),
  208|     48|                root: LeftistHeapNode::Leaf,
  228|      2|                | LeftistHeapNode::Leaf => None,
  244|      1|                | LeftistHeapNode::Leaf => (self.clone(), None),
  373|      4|                    | LeftistHeapNode::Leaf => Ok(()),
   68|  1.63k|                | LeftistHeapNode::Leaf => 0,
   99|    264|                | (LeftistHeapNode::Leaf, other) => other,
  259|    312|                root: LeftistHeapNode::meld_nodes(self.root.clone(), other.root.clone()),
  150|    169|                | LeftistHeapNode::Node { left, right, .. } => 1 + left.size() + right.size(),
  158|      5|                | LeftistHeapNode::Node { left, right, .. } => 1 + left.height().max(right.height()),
  166|  1.12k|                | LeftistHeapNode::Node { left, right, .. } => {
  176|  1.12k|                | LeftistHeapNode::Node { key, left, right, .. } => {
  179|    411|                        | LeftistHeapNode::Node { key: left_key, .. } => key <= left_key,
  183|    688|                        | LeftistHeapNode::Node { key: right_key, .. } => key <= right_key,
  194|     10|                | LeftistHeapNode::Node { key, left, right, .. } => {
  215|    313|                root: LeftistHeapNode::Node {
  229|     20|                | LeftistHeapNode::Node { key, .. } => Some(key),
  245|    114|                | LeftistHeapNode::Node { key, left, right, .. } => {
  374|      3|                    | LeftistHeapNode::Node { key, left, right, rank } => {
   69|  2.79k|                | LeftistHeapNode::Node { rank, .. } => *rank,
   25|       |        root: LeftistHeapNode<T>,
  384|      1|            writeln!(f, "LeftistHeapPQ:")?;
    4|       |pub mod LeftistHeapPQ {
  391|       |    macro_rules! LeftistHeapPQLit {
  402|      0|    fn _leftist_heap_pq_lit_type_checks() {
  152|       |        pub leftist_heap_result: Vec<T>,
  102|      4|            let left_keys = handle.join().unwrap();
  129|     30|                let left_left = left.subseq_copy(0, mid_left);
   83|     26|                let left_left = left.subseq_copy(0, mid_left);
  134|     30|                let left_left_arc = Arc::new(left_left);
   88|     26|                let left_left_arc = Arc::new(left_left);
  214|      4|            let left_mapped = handle.join().unwrap();
   71|    198|                    let left_mid = <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::append(&left, &middle);
   77|     54|            let left_min = handle1.join().unwrap();
   83|     29|            let left_min = handle1.join().unwrap();
   86|    108|            let left_min = handle1.join().unwrap();
   93|     28|            let left_min = handle1.join().unwrap();
  149|     38|            fn leftmost<T: StTInMtT + Ord>(link: &Link<T>) -> Option<T> {
   45|     31|                    if left.nth(0) <= right.nth(0) {
   48|    272|                            if left.nth(l_idx) <= right.nth(r_idx) {
   63|     71|                        if left.nth(l_idx) <= right.nth(r_idx) {
  120|     43|                    if left.nth(mid) <= pivot {
  177|  1.12k|                    let left_ok = match left.as_ref() {
   87|  1.11k|            let left_priority = tree_priority(&left);
   92|    349|            if left_priority > right_priority {
   75|    724|            let left_rank = left.rank();
  126|  1.10k|            let left_reduced = Self::reduced_value_link(&node.left);
  299|      1|                reducer: left.reducer.clone(),
  231|      1|            let left_reduction = Self::calculate_reduction(&left_base, &self.reducer, &self.identity);
  236|      1|                cached_reduction: left_reduction,
  244|      1|            let left_reduction = Self::calculate_reduction(&left_base, &self.reducer, &self.identity);
  249|      1|                cached_reduction: left_reduction,
  265|      1|            let left_reduction = self.recalculate_reduction(&left_base);
  270|      1|                cached_reduction: left_reduction,
  292|      1|            let left_reduction = Self::calculate_reduction(&left_base, &self.reducer, &self.identity);
  297|      1|                cached_reduction: left_reduction,
  305|      1|            let left_reduction = Self::calculate_reduction(&left_base, &self.reducer, &self.identity);
  310|      1|                cached_reduction: left_reduction,
  327|      1|            let left_reduction = self.recalculate_reduction(&left_base);
  332|      1|                cached_reduction: left_reduction,
  138|    105|            let left_result = handle.join().unwrap();
  179|      7|                let left_result = <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::reduce(&left, f, id.clone());
  194|      7|                let left_result = <ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::reduce(&left, f, id.clone());
  236|      4|            let left_result = left_handle.join().unwrap();
  238|    106|                let left_result = handle.join().unwrap();
  252|      6|                let left_result = handle.join().unwrap();
  265|       |            let left_result = left_handle.join().expect("left ParaPair task panicked");
  305|      6|            let left_result = left_handle.join().unwrap();
  130|     30|                let left_right = left.subseq_copy(mid_left, n_left - mid_left);
   84|     26|                let left_right = left.subseq_copy(mid_left + 1, n_left - mid_left - 1);
  136|     30|                let left_right_arc = Arc::new(left_right);
   90|     26|                let left_right_arc = Arc::new(left_right);
  287|      2|                let (left_root, right_root) = Self::split_rank_link(&self.root, rank);
   53|     50|            let left_rows = self.dimensions[i].rows;
   55|     68|            let left_rows = self.dimensions[i].rows;
   65|     63|            let left_rows = dimensions_guard[i].rows;
   65|      6|            let left_rows = self.dimensions[i].rows;
  171|    108|                let left_self = right_self.split_off(mid);
  132|      5|            let left_seq = key_seq.subseq(0, mid);
  212|      9|            let left_seq = AVLTreeSeqStPerS::from_vec(left_array.into_iter().collect());
  217|      2|            let left_seq = AVLTreeSeqStPerS::from_vec(left_array.into_iter().collect());
  259|      3|            let left_seq = AVLTreeSeqStPerS::from_vec(left_entries);
  271|      3|            let left_seq = AVLTreeSeqStPerS::from_vec(left_entries);
  273|      9|            let left_seq = seq.subseq_copy(0, i);
  292|      1|            let left_seq = AVLTreeSeqStPerS::from_vec(left_elements);
  303|      3|            let left_seq = AVLTreeSeqStPerS::from_vec(left_entries);
  335|      3|            let left_seq = AVLTreeSeqStPerS::from_vec(left_entries);
  348|      2|            let left_seq = AVLTreeSeqStPerS::from_vec(left_entries);
  378|      2|            let left_seq = AVLTreeSeqStPerS::from_vec(left_entries);
  133|      0|            let left_set = Self::from_seq(AVLTreeSeqMtPerS::from_vec(left_vals));
  174|      0|            let left_set = Self::from_seq(AVLTreeSeqMtPerS::from_vec(left_vals));
  220|      0|            let left_set = Self::from_seq(AVLTreeSeqMtPerS::from_vec(left_vals));
   91|      7|        let (left_set, right_set) = set_a.split_rank(3);
  311|      2|            let left_side = self.and(set1, set2);
   17|       |        pub left_size: N,
  188|    177|                    let left_size = Self::size_link(&node.left);
  204|    174|                    let left_size = Self::size_link(&node.left);
  220|     17|                    let left_size = Self::size_link(&node.left);
   22|       |        pub left_size: N,
  284|  97.2M|                let left_size = n.left_size;
  297|   197M|        let left_size = n.left_size;
  311|     33|                let left_size = n.left_size;
  397|     20|                let left_size = n.left_size;
  410|     30|        let left_size = n.left_size;
  424|      5|                let left_size = n.left_size;
  294|      6|            let left_slice = a.slice(0, mid);
   89|  14.3k|                    if left_sorted[i] <= right_sorted[j] {
  129|      7|        let (left_split, found, right_split) = set_a.split(&"mike".to_string());
  352|      1|                let left_table = range_table.get_key_range(k1, &mid_key);
  227|      9|                        let left_tree = Self::make_node(node.key.clone(), node.priority, node.left.clone(), rl);
  127|      4|                    let left_union = ParamBST::union_inner(&al, &bl);
  513|      2|                let left_updated = handle.join().unwrap();
  109|    217|                let left_vals = right_vals.split_off(mid);
  130|      0|            let left_vals: Vec<T> = (0..mid).map(|i| self.elements.nth(i).clone()).collect();
  171|      0|            let left_vals: Vec<T> = (0..mid).map(|i| self.elements.nth(i).clone()).collect();
  217|      0|            let left_vals: Vec<T> = (0..mid).map(|i| self.elements.nth(i).clone()).collect();
   79|  5.04k|                let left_vals = vals;
  129|      0|                let left_verts = right_verts.split_off(mid);
  167|      0|                let left_verts = right_verts.split_off(mid);
  274|      0|                let left_verts = right_verts.split_off(mid);
  319|      0|                let left_verts = right_verts.split_off(mid);
  108|     26|                let left_with_pivot = ArraySeqMtPerS::append(&merged_left, &pivot_seq);
  154|     30|                let left_with_pivot = ArraySeqMtPerS::append(&merged_left, &pivot_seq);
  100|  11.6k|                    let len = data.len();
  100|    227|                if len <= 1 {
  101|  11.6k|                    if len <= 1 {
  103|    111|                let len = data.len();
  104|     89|            let len = self.length();
  117|      1|            let len = self.length();
  118|      1|            if len == 0 {
  118|      6|            let len = key_seq.length();
  118|      8|            let len = self.length();
  120|      6|            if len == 0 {
  124|      5|            if len == 1 {
  131|      0|            let len = seq.length();
  131|     38|            let len = eph_seq.length();
  135|      3|            let len = self.length();
  142|      9|            let len = seq.length();
  150|    421|                let len = data.len();
  151|    361|                    let len = data.len();
  151|    421|                if len <= 1 {
  152|    361|                    if len <= 1 {
  159|      1|            let len = self.length();
  177|      4|            let len = self.entries.length();
  179|      4|            if len <= 1 {
  180|      0|                if len == 1 {
  181|     96|            let len = array_seq.length();
  194|    116|            let len = array_seq.length();
  208|      1|            let len = a.length();
  223|    149|            let len = array_seq.length();
  231|      3|            let len = self.entries.length();
  233|      3|            if len == 0 {
  237|      3|            if len == 1 {
   25|      0|        let len = n * (n - 1);
   26|      0|        let len = n * n * n;
  316|      1|            let len = a.length();
   32|     54|                    let len = if limit >= 2 { limit - 1 } else { 0 }; // j in [2..=limit] => length max(limit-1,0)
   35|    136|            let len = elts.len();
  353|     22|        let len = entries.length();
  355|     69|            let len = a.length();
  356|     69|            if len == 0 {
  359|     65|            if len == 1 {
  369|     21|        let len = entries.length();
  371|      3|            let len = a.length();
  372|      3|            if len == 0 {
  396|     58|            let len = a.length();
  397|     36|        let len = entries.length();
  397|     58|            if len == 0 {
  400|     54|            if len == 1 {
  412|      3|            let len = a.length();
  413|     11|            let len = self.entries.length();
  413|      3|            if len == 0 {
  415|     11|            if len == 0 {
  419|     11|            if len == 1 {
  473|      3|                let len = self.entries.length();
  475|      3|                if len == 1 {
  549|      4|            let len = self.entries.length();
  551|      4|            if len == 0 {
  555|      4|            if len == 1 {
  605|      4|            let len = self.entries.length();
   60|    699|                let len = data.len();
  607|      4|            if len == 0 {
  611|      4|            if len == 1 {
   61|    699|                if len <= 1 {
   62|    512|                    let len = data.len();
   63|    512|                    if len <= 1 {
   78|    107|            let len = data.len();
   81|      5|            let len = self.entries.length();
   83|      5|            if len <= 1 {
   85|      1|                if len == 1 {
   87|     10|            let len = self.length();
   88|     10|            if len == 0 {
   99|    227|                let len = data.len();
  113|      7|            let len_a = a.length();
  116|     11|            let len_a = a.length();
  118|      5|            let len_a = a.length();
  300|     13|            let len_a = a.length();
  118|      3|            let len_b = b.length();
  121|      6|            let len_b = b.length();
  123|      2|            let len_b = b.length();
  305|      6|            let len_b = b.length();
  101|      0|            LinkedListStPerS::from_vec(vec![init_value; length])
  104|     10|            let length = values.len();
  125|     65|            if length == 0 || start >= self.len {
  221|      0|                "Sequence length: {}, Unique positions: {}, Period: {}",
   29|      1|            LinkedListStEphS::from_vec(vec![init_value; length])
   31|     49|            ArraySeqMtEphS::from_vec(vec![init_value; length])
   62|     56|            if length == 0 || start >= self.len {
   78|   555k|            let length = values.len();
  100|      1|        fn length(&self) -> N { ArraySeqMtPerTraitChap18::length(self) }
  104|       |        fn length(&self) -> N;
  120|       |        fn length(&self) -> N;
  122|    179|        fn length(&self) -> N { self.len() }
  125|     28|        fn length(&self) -> N { self.data.len() }
  125|       |        fn length(&self) -> N;
  136|      0|        fn length(&self) -> N { self.data.len() }
  142|      9|        fn length(&self) -> N { ArraySeqStPerS::length(self) }
  145|       |        fn length(&self) -> N;
  146|       |        fn length(&self) -> N;
  147|  1.69M|        fn length(&self) -> N { size_link(&self.root) }
  169|  1.25k|        fn length(&self) -> N { size(&self.root) }
  170|  83.0k|        fn length(&self) -> N { size(&self.root) }
  173|     19|        fn length(&self) -> N { self.data.len() }
  184|      4|        fn length(&self) -> N { ArraySeqStEphS::length(self) }
  187|      1|        fn length(&self) -> N { ArraySeqMtEphS::length(self) }
  191|     11|        fn length(&self) -> N { ArraySeqS::length(self) }
  191|      1|        fn length(&self) -> N { ArraySeqMtPerS::length(self) }
  191|       |        fn length(&self) -> N;
  203|     91|        fn length(&self) -> N { size_link(&self.root) }
   22|       |        fn length(&self) -> N;
   22|       |        fn length(&self) -> N;
   22|       |        fn length(&self) -> N;
  237|      0|        fn length(&self) -> N { LinkedListStPerS::length(self) }
   24|       |        fn length(&self) -> N;
  263|      1|        fn length(&self) -> N { LinkedListStEphS::length(self) }
   30|       |        fn length(&self) -> N;
   34|       |        fn length(&self) -> N;
   36|       |        fn length(&self) -> N;
   38|       |        fn length(&self) -> N;
   42|       |        fn length(&self) -> N;
   50|       |        fn length(&self) -> N;
   60|       |        fn length(&self) -> N;
   82|      1|        fn length(&self) -> N { ArraySeqMtEphTraitChap18::length(self) }
   84|       |        fn length(&self) -> N;
   88|      1|        fn length(&self) -> N { ArraySeqStPerTraitChap18::length(self) }
   89|      1|        fn length(&self) -> N { ArraySeqStEphTraitChap18::length(self) }
  105|    259|        fn len(&self) -> N { self.range.end - self.range.start }
   25|      0|        fn len(&self) -> N {
  101|     60|                if let Some(v) = find_min_priority(&frontier) {
  102|     11|            if let Some(mut h) = link.take() {
  102|    366|                if let Some(&result) = memo_guard.get(&(i, l)) {
  103|     11|                if let Some(mut x) = h.left.take() {
  103|     23|            if let Some(mut x) = link.take() {
  104|  1.50k|            if let Some(node) = link.as_mut() {
  104|     23|                if let Some(mut y) = x.left.take() {
  104|    907|            if let Some(node) = link.as_ref() {
  105|      1|            if let Some(u_neighbors) = self.adj.find(u) {
  105|     30|                if let Some(v) = find_min_priority(&frontier) {
  105|  3.99k|            if let Some(node) = link.as_mut() {
  105|    463|                    if let Some(right) = x.right.as_mut() {
  106|    104|            if let Some(element) = min_element {
  106|    134|                if let Some(&result) = memo_guard.get(&(i, j)) {
  109|      3|                if let Some(neighbors) = self.adj.find(&u) {
  110|  11.0k|            if let Some(node) = link.as_mut() {
  110|     25|            if let Some(parent_v) = parent_u {
  110|    807|            if let Some(node) = link.as_mut() {
  111|     17|                if let Some(weight) = get_edge_weight(graph, &parent_v, &u) {
  113|     30|            while let Some(v) = find_min_priority(&frontier) {
  113|     43|            while let Some(node) = current {
  114|    104|                    if let Some(left) = node.left.as_mut() {
  114|  1.39k|            if let Some(node) = link {
  114|     16|                    if let Some(left) = node.left.as_mut() {
  114|  22.0k|        if let Some(n) = cur {
  115|  15.4k|        if let Some(n) = cur {
  115|      2|                if let Some(neighbors) = result_adj.find(u) {
  116|     88|                if let Some(&cached_result) = memo_guard.get(&(i, j)) {
  117|  22.1k|            if let Some(node) = link.as_mut() {
  117|  6.54k|            if let Some(node) = link.as_mut() {
  118|     67|                if let Some(&cached_result) = memo_guard.get(&(i, j)) {
  119|    132|            if let Some(node) = link.as_mut() {
  120|  1.18k|                if let Some(node) = link.as_mut() {
  121|    110|                    if let Some(right) = node.right.as_mut() {
  121|  1.22k|                    if let Some(right) = node.right.as_mut() {
  121|  2.97k|                if let Some(node) = link.as_mut() {
  122|  22.1k|                if let Some(left) = node.left.as_mut() {
  124|    132|                if let Some(left) = node.left.as_mut() {
  124|     85|            if let Some(element) = min_element {
  125|       |                $( let _ = __s.insert($crate::Types::Types::Pair($a, $b)); )*
  125|     26|                    if let Some(weight) = get_edge_weight(graph, &u, v) {
  125|      8|            if let Some(start) = self.vertices().iter().next() {
  126|      8|            if let Some(idx) = found_index {
  128|  22.1k|                if let Some(right) = node.right.as_mut() {
  128|     80|                while let Some(current) = stack.pop() {
  129|  11.0k|            if let Some(node) = link.as_mut() {
  129|    807|            if let Some(node) = link.as_mut() {
  129|      8|            while let Some(node) = current {
  130|    132|                if let Some(right) = node.right.as_mut() {
  132|     15|            if let Some(node) = link {
  133|  4.00k|            while let Some(value) = self.pop() {
  133|  5.48k|                if let Some(node) = link.as_mut() {
  134|      1|            if let Some(neighbors) = self.adj.find(u) {
  134|    483|            if let Some(node) = link {
  137|      2|        if let Some(start) = shortcut.first() {
  140|      7|            if let Some(node) = link {
  142|      7|            if let Some(node) = link {
  143|    158|            if let Some(mut x) = link.take() {
  144|    158|                if let Some(mut y) = x.right.take() {
  146|    231|            if let Some(node) = link.as_ref() {
  147|      8|            while let Some(node) = current {
  148|   116k|                    if let Some(left) = node.left.as_ref() {
  151|     38|                if let Some(node) = guard.as_ref() {
  151|    619|            if let Some(node) = link.as_mut() {
  154|      2|        if let Some(start) = shortcut.first() {
  156|    537|            if let Some(node) = link {
  157|      5|            if let Some(mut x) = link.take() {
  157|    794|            if let Some(node) = link.as_mut() {
  158|      3|            if let Some(weight) = get_edge_weight(graph, u, v) {
  158|      5|                if let Some(mut y) = x.left.take() {
  159|       |                $( let _ = __s.insert($crate::Types::Types::Edge($u, $w)); )*
  160|    447|            while let Some(node) = current {
  162|     18|            if let Some(node) = link {
  164|     27|            if let Some(node) = link {
  165|  1.56k|            if let Some(node) = link {
  167|      1|            if let Some(idx) = found_index {
  167|     34|                if let Some(element) = min_element {
  167|      7|            while let (Some(a), Some(b)) = (left, right) {
  168|   116k|            if let Some(node) = link.as_mut() {
  169|    112|                if let Some(value) = handle.join().unwrap() {
  169|    683|            if let Some(node) = link {
  170|     11|            if let Some(node) = link {
  171|    980|            if let Some(node) = link.as_mut() {
  172|     18|            if let Some(node) = link {
  173|      0|            if let Some(node) = link {
  173|    194|                if let Some(node) = guard.as_ref() {
  174|   140k|            if let Some(node) = link.as_mut() {
  176|      4|            while let Some(node) = current {
  177|     31|            if let Some(node) = link {
  177|     68|            if let Some(node) = link {
  178|      6|            if let Some(weight) = get_edge_weight(graph, u, v) {
  179|     70|            if let Some((v, w, label)) = bridges.get(u) {
  180|       |                $( let _ = __s.insert($crate::Types::Types::Edge($u, $w)); )*
  189|    338|            if let Some(node) = link {
  189|    688|            if let Some(node) = link {
  190|    781|                if let Some(node) = link.as_mut() {
  194|      4|            while let Some(node) = current {
  195|    572|                if let Some(node) = guard.as_ref() {
  197|     19|            if let Some(node) = link {
  197|    356|            while let Some(ref node) = cursor.as_ref() {
  197|      7|            if let Some(node) = link {
  208|     96|            if let Some(node) = link {
  211|    129|            if let Some(node) = link {
  214|     80|            while let (Some(a), Some(b)) = (left, right) {
  216|     16|            if let Some(node) = link {
  217|   302M|        if let Some(b) = n {
  219|      0|            if let Some(node) = link {
  225|  58.8k|            if let Some(node) = link {
  233|      7|            if let Some(node) = link {
  235|    116|            if let Some(node) = link {
  243|    116|            if let Some(node) = link {
  243|    175|            if let Some(node) = self.root.as_mut() {
  244|       |                $( let _ = __s.insert($crate::Types::Types::Edge($u, $w)); )*
  246|      1|            if let Some(pos) = values.iter().position(|x| x == target) {
  249|      1|        if let Some(result) = operation(entry, pos) {
  249|    342|                if let Entry::Live(key, value) = entry {
  251|  2.00k|            if let Some(existing_value) = self.find(&key) {
  251|  24.9k|            if let Some(node) = guard.as_mut() {
  253|  3.56k|            if let Some(existing_value) = self.find(&key) {
  261|     11|            while let Some(n) = cur {
  273|       |            $( let _ = __s.insert($x); )*
  273|     19|            if let Some(m) = metrics {
  286|      3|                if let Some(group) = groups.iter_mut().find(|existing| cmp(&existing.0, &key) == O::Equal) {
  291|     16|            if let Some(m) = metrics {
  291|     18|                if let Some(element) = min_element {
  302|     23|            while let Some(ref node) = cursor.as_ref() {
  305|     16|            if let Some(m) = metrics {
  307|     10|                if let Some(element) = min_element {
  323|    167|        if let Some(b) = n {
  351|      1|            if let Some(mid_key) = range_table.select_key(mid_rank) {
   35|     17|            while let Some(node) = current {
   35|      2|            if let Some(pos) = self.iter().position(|(k, _)| k == key) {
   36|     22|        while let Some(u) = queue.pop_front() {
   36|     22|        while let Some(u) = queue.pop_front() {
  364|      7|                if let Some(Pair(_, existing)) = groups.iter_mut().find(|Pair(gk, _)| cmp(&k, gk) == O::Equal) {
  371|       |                $( let _ = __s.insert($crate::Types::Types::Edge($u, $w)); )*
   37|    447|            while let Some(value) = elts.pop() {
  391|      0|            if let Some(ref primary) = self.primary_clustering {
  396|      0|            if let Some(ref secondary) = self.secondary_clustering {
  401|      0|            if let Some(ref double) = self.double_hashing_quality {
  403|      7|                if let Some(Pair(_, existing)) = groups.iter_mut().find(|Pair(gk, _)| cmp(&k, gk) == O::Equal) {
   43|     17|                if let Some(u) = current_layer.pop_front() {
   43|     17|                if let Some(u) = current_layer.pop_front() {
   43|      2|            if let Some(idx) = found_idx {
  438|      7|        if let Some(n) = link {
  470|  4.45k|            if let Some(existing_value) = self.find(&key) {
   50|    326|            if let Some(&result) = self.memo.get(&(i, j)) {
   51|    199|            if let Some(&result) = self.memo.get(&(i, j)) {
   52|     85|            if let Some(element) = min_element {
   53|     15|            while let Some(node) = current {
   54|    234|                if let Some(&result) = memo_guard.get(&(i, j)) {
   55|     19|                if let Some(neighbors) = self.adj.find(v) {
   57|    185|            if let Some(&result) = self.memo.get(&(i, l)) {
   58|    179|                if let Some(&result) = memo_guard.get(&(i, j)) {
   59|     28|            if let Some(&cached_result) = self.memo_table.get(&(i, j)) {
   60|    131|            if let Some(&result) = self.memo.get(&(i, j)) {
   62|     28|            if let Some(&cached_result) = memo.get(&(i, j)) {
   63|     13|                    if let Some(neighbors) = self.adj.find(v) {
   63|     14|                if let Some(neighbors) = self.adj.find(v) {
   63|     24|                if let Some(&cached_result) = memo_guard.get(&(i, j)) {
   63|     24|                if let Some(&cached_result) = memo_guard.get(&(i, j)) {
   64|    110|            if let Some(&result) = self.memo.get(&(i, j)) {
   64|    114|                if let Some(&result) = memo_guard.get(&(i, j)) {
   65|  1.07k|            if let Some(&result) = self.memo.get(&(i, j)) {
   69|    783|            if let Some(&result) = self.memo.get(&(i, l)) {
   70|     85|            if let Some(element) = min_element {
   73|      0|                    if let Some(val) = table.table[slot].lookup(key) {
   73|     41|                if let Some(&u_idx) = vertex_to_index.get(u) {
   74|    106|            if let Some(mut x) = link.take() {
   74|    230|                if let Some(&result) = memo_guard.get(&(i, j)) {
   75|    106|                if let Some(mut y) = x.right.take() {
   76|     15|            if let Some(&result) = self.memo.get(&(i, j)) {
   76|    244|            if let Some(mut x) = link.take() {
   77|    244|                if let Some(mut y) = x.right.take() {
   77|    730|            if let Some(mut x) = link.take() {
   78|    730|                if let Some(mut y) = x.right.take() {
   79|  22.9k|            if let Some(mut h) = link.take() {
   79|     40|                if let Some(&v_idx) = vertex_to_index.get(v) {
   80|  22.9k|                if let Some(mut x) = h.right.take() {
   82|    112|            if let Some(mut y) = link.take() {
   82|     16|            if let Some(mut y) = link.take() {
   83|    112|                if let Some(mut x) = y.left.take() {
   83|     12|            if let Some(p) = parent {
   83|     16|                if let Some(mut x) = y.left.take() {
   85|    107|            if let Some(mut h) = link.take() {
   86|    107|                if let Some(mut x) = h.right.take() {
   86|  22.9k|                    if let Some(left) = x.left.as_mut() {
   86|      4|            if let Some(mut x) = link.take() {
   87|      4|                if let Some(mut y) = x.left.take() {
   88|    111|            if let Some(entry) = min_elem {
   88|    117|            if let Some(entry) = min_elem {
   88|     85|            if let Some(element) = min_element {
   88|      8|            if let Some(start) = self.vertices().iter().next() {
   89|  1.02k|            if let Some(mut x) = link.take() {
   90|  1.02k|                if let Some(mut y) = x.right.take() {
   90|     12|            if let Some(p) = parent {
   90|     21|            if let Some(mut x) = link.take() {
   91|     21|                if let Some(mut y) = x.left.take() {
   91|     21|            if let Some(pos) = values.iter().position(|x| x == target) {
   91|     21|            if let Some(pos) = values.iter().position(|x| x == target) {
   91|     21|            if let Some(pos) = values.iter().position(|x| x == target) {
   91|     21|            if let Some(pos) = values.iter().position(|x| x == target) {
   91|     25|            if let Some(pos) = values.iter().position(|x| x == target) {
   91|     76|            if let Some(mut x) = link.take() {
   91|     80|                while let Some(current) = stack.pop() {
   91|  9.28k|            if let Some(pos) = values.iter().position(|x| x == target) {
   92|     76|                if let Some(mut y) = x.left.take() {
   93|    237|                if let Some(&result) = memo_guard.get(&(i, l)) {
   93|    334|                if let Some((ll, lk, lp, lr)) = left.expose_with_priority() {
   94|     60|                if let Some(v) = find_min_priority(&frontier) {
   96|    110|            if let Some(mut x) = link.take() {
   96|  1.32k|            if let Some(mut x) = link.take() {
   96|    146|                if let Some(&result) = memo_guard.get(&(i, j)) {
   97|    110|                if let Some(mut y) = x.right.take() {
   97|  1.32k|                if let Some(mut y) = x.right.take() {
   97|    490|            while let Some(node) = current {
   98|    463|            if let Some(mut h) = link.take() {
   98|    487|            if let Some(node) = link.as_mut() {
   98|  6.96k|                            if let Some(node) = guard.as_mut() {
   99|     15|                if let Some((rl, rk, rp, rr)) = right.expose_with_priority() {
   99|      2|            if let Ok(pos) = self.elements.binary_search(x) {
   99|    463|                if let Some(mut x) = h.left.take() {
  470|      4|            .map(|lf| (lf, analyzer.compare_probing_strategies(table_size, lf)))
   47|    307|                        if l_idx < n_left && r_idx < n_right {
   62|    122|                    if l_idx < n_left && r_idx < n_right {
   46|       |        fn lift(value: &V) -> R;
   56|  1.35k|        fn lift(value: &T) -> T { *value }
   70|     27|        fn lift(_value: &T) -> N { 1 }
  199|       |                        // Limit sequence length for analysis
   31|     54|                    let limit = if i == 0 { 0 } else { n / i };
  104|       |                // Line 7: choose U ⊆ F such that |U| ≥ 1
  107|       |                // Line 9: X' = X ∪ U
  110|       |                // Line 10: F' = N+(X') \ X'
  123|       |                // Line 11: explore X' F'
  127|       |            // Line 13: explore {} {s}
   99|       |                // Line 4: if |F| = 0 then X
  115|       |        /// Linear search through chain
   11|       |    /// Linear Probing Flat Hash Table implementation.
  201|       |            // Linear probing becomes problematic when load factor > 0.7
  207|       |        /// Linear probing: h_i(k) = (h(k) + i) mod m
    3|       |//! Uses linear probing for open addressing collision resolution.
   68|       |        /// Linear scan to find minimum element
   83|       |            // Linear probing: (hash(key) + attempt) mod size
   92|     31|                strategy_name: "Linear Probing".to_string(),
  223|     14|            let linear_analysis = self.analyze_linear_probing(&linear_strategy, &linear_table);
  257|     14|                linear_probing: linear_analysis,
  242|     14|                ("LinearProbing".to_string(), linear_analysis.overall_clustering_score),
   83|     10|                let linear_probe = LinearProbingStrategy::new(hash_fn.clone());
    4|       |pub mod LinearProbing {
   52|       |        pub linear_probing: ComprehensiveClusteringAnalysis,
  216|     14|            let linear_strategy: AdvancedLinearProbingStrategy<String, DefaultHashFunction> =
  218|     14|            let linear_table: FlatHashTable<
  112|     55|            match link {
  114|     32|            match link {
  117|  3.45k|            match link {
  122|      5|            match link {
  124|    178|            match link {
  127|    777|            match link {
  129|    614|            match link {
  130|    449|            match link {
  134|    397|            match link {
  135|  1.01k|            match link {
  135|  12.9k|            match link {
  142|      1|            match link {
  142|     40|            match link {
  144|     27|            match link {
  145|     72|            match link {
  149|     81|            match link {
  152|      2|            match link {
  154|    213|            match link {
  154|  2.24M|            match link {
  154|     29|            match link {
  155|     56|            match link {
  157|    129|                match link {
  157|      1|            match link {
  159|    136|            match link {
  167|      3|            match link {
  169|     26|            match link {
  169|  2.84k|            match link {
  173|  1.19k|            match link {
  176|     32|            match link {
  178|    180|                match link {
  179|     26|            match link {
  179|  2.88k|            match link {
  185|    179|            match link {
  187|    201|                match link {
  188|     19|            match link {
  189|    144|                match link {
  190|  1.92k|            match link {
  191|     34|            match link {
  198|     17|            match link {
  200|  1.91k|            match link {
  201|     11|            match link {
  201|    174|            match link {
  205|    355|            match link {
  210|    698|                match link {
  214|    359|                match link {
  215|     20|            match link {
  215|    299|            match link {
  217|     19|            match link {
  217|    645|                match link {
  225|     17|            match link {
  233|    308|                match link {
  236|      0|                match link {
  244|  2.00k|                match link {
  251|    170|            match link {
  272|  11.8k|                match link {
  293|    205|                match link {
   75|  8.44k|            match link {
   75|  9.01k|            match link {
   76|    129|                match link {
   77|  11.7k|            match link {
   97|     70|            match link {
   99|  1.00k|            match link {
    3|       |//! Uses LinkedList for separate chaining collision resolution.
   54|       |    /// LinkedList Chained Hash Table implementation.
    5|       |pub mod LinkedListChainedHashTable {
   59|       |        for LinkedListChainedHashTableStEph
   76|       |        for LinkedListChainedHashTableStEph
    4|       |pub mod LinkedListStEph {
  414|      0|                return (LinkedListStEphS::empty(), id);
   63|      5|                return LinkedListStEphS::empty();
  428|       |    macro_rules! LinkedListStEphSLit {
  234|       |            a: &LinkedListStEphS<Pair<A, Bv>>,
  358|      2|            a: &LinkedListStEphS<Pair<A, Bv>>,
    4|       |pub mod LinkedListStPer {
  126|      5|                return LinkedListStPerS::empty();
  373|      0|                return (LinkedListStPerS::empty(), id);
  418|       |    macro_rules! LinkedListStPerSLit {
  397|      2|            a: &LinkedListStPerS<Pair<A, Bv>>,
   89|       |            a: &LinkedListStPerS<Pair<A, Bv>>,
  341|      1|            a: &LinkedListStPerS<T>,
   73|       |            a: &LinkedListStPerS<T>,
   10|       |    type Link<K, V> = Option<Box<Node<K, V>>>;
   12|       |    type Link<K, V, R> = Option<Box<Node<K, V, R>>>;
   17|       |        left: Link<K, V>,
   18|       |        right: Link<K, V>,
   21|       |        left: Link<K, V, R>,
   22|       |        right: Link<K, V, R>,
   35|       |        root: Link<K, V>,
   75|       |        root: Link<K, V, R>,
   10|       |    type Link<T> = Option<Box<Node<T>>>;
   10|       |    type Link<T> = Option<Box<Node<T>>>;
   10|       |    type Link<T> = Option<Box<Node<T>>>;
   10|       |    type Link<T> = Option<Box<Node<T>>>;
   11|       |    type Link<T> = Arc<RwLock<Option<Node<T>>>>;
   11|       |    type Link<T> = Option<Box<AVLTreeNode<T>>>;
   12|       |    type Link<T> = Option<Arc<Node<T>>>;
   12|       |    type Link<T> = Option<Box<Node<T>>>;
   12|       |    type Link<T> = Option<Box<Node<T>>>;
   12|       |    type Link<T> = Option<Box<Node<T>>>;
   12|       |    type Link<T> = Option<Box<Node<T>>>;
   12|       |    type Link<T> = Option<Rc<Node<T>>>;
  135|       |        root: Link<T>,
  136|       |        root: Link<T>,
   14|       |    type Link<T> = Option<Box<Node<T>>>;
   16|       |        left: Link<T>,
   16|       |    type Link<T> = Option<Box<Node<T>>>;
   17|       |        left: Link<T>,
   17|       |        left: Link<T>,
   17|       |        left: Link<T>,
   17|       |        right: Link<T>,
   17|       |    type Link<T> = Option<Box<AVLTreeNode<T>>>;
   18|       |        left: Link<T>,
   18|       |        left: Link<T>,
   18|       |        left: Link<T>,
   18|       |        left: Link<T>,
   18|       |        left: Link<T>,
   18|       |        right: Link<T>,
   18|       |        right: Link<T>,
   18|       |        right: Link<T>,
   18|       |    type Link<T> = Option<Box<Node<T>>>;
   19|       |        left: Link<T>,
   19|       |        left: Link<T>,
   19|       |        right: Link<T>,
   19|       |        right: Link<T>,
   19|       |        right: Link<T>,
   19|       |        right: Link<T>,
   19|       |        right: Link<T>,
   20|       |        left: Link<T>,
   20|       |        right: Link<T>,
   20|       |        right: Link<T>,
   21|       |        right: Link<T>,
   23|       |        left: Link<T>,
   24|       |        right: Link<T>,
   25|       |        left: Link<T>,
   26|       |        right: Link<T>,
   33|       |        root: Link<T>,
   35|       |        root: Link<T>,
   35|       |        root: Link<T>,
   35|       |        root: Link<T>,
   35|       |        root: Link<T>,
   41|       |        root: Link<T>,
   43|       |        root: Link<T>,
    5|       |pub mod LinProbFlatHashTable {
   16|       |        for LinProbFlatHashTableStEph
   78|       |        for LinProbFlatHashTableStEph
  330|       |            // (live_entries, dead_entries, load_factor)
  113|  3.95k|                        let (ll, found, lr) = ParamBST::split_inner(&left, key);
  126|     41|                        let (ll, found, lr) = ParamTreap::split_inner(&left, key);
  140|     30|                    let ll = left_left_arc.clone();
  222|      8|                        let (ll, lr) = Self::split_rank_link(&node.left, rank);
   85|     17|                        let (ll, found, lr) = ParamBST::split_inner(&left, key);
   94|     26|                    let ll = left_left_arc.clone();
  118|     73|                while lo < hi {
  128|      6|                sort(a, lo, lt);
  165|      6|                sort(a, lo, lt);
   72|     72|                while lo < hi {
   80|     10|                sort(a, lo, lt);
  101|     19|            let (load, size) = table.load_and_size();
  107|     21|            self.compute_clustering_metrics(clusters, load, size)
  118|    308|            let (load, size) = table.load_and_size();
  143|     16|            let (load, size) = table.load_and_size();
  173|     20|            let (load, size) = table.load_and_size();
  183|      2|- Monitor load factor after deletions
   18|       |        pub load: f64,
  206|       |    /// Load factor calculation and management
  385|       |    /// Load Factor Impact Analysis
   67|     21|            let (load, size) = table.load_and_size();
   76|       |        /// Load factor α = load/size = num_elements/size
   77|      2|        fn loadAndSize(table: &HashTable<Key, Value, Entry, Metrics>) -> LoadAndSize {
  102|     19|            let load_factor = if size > 0 { load as f64 / size as f64 } else { 0.0 };
  144|     16|            let load_factor = if size > 0 { load as f64 / size as f64 } else { 0.0 };
  175|     26|            if load_factor >= 1.0 {
  186|     26|            if load_factor >= 1.0 {
  191|     25|            if load_factor > 0.0 {
   20|       |        pub load_factor: f64,
  213|     36|            if load_factor >= 1.0 {
  219|     18|                if load_factor > 0.0 {
  254|       |        pub load_factor: f64,
  262|     16|            let load_factor = if table_size == 0 {
  267|     46|            if load_factor >= 1.0 {
  273|     22|                if load_factor > 0.0 {
  331|      8|            let load_factor = (self.num_elements + self.num_deleted) as f64 / self.table.length() as f64;
   78|      2|            let load_factor = if table.current_size == 0 {
   84|      2|                load: load_factor,
   15|       |        load_factor_manager: LoadFactorManager,
  214|       |    impl LoadFactorManager {
   23|       |        load_factor_manager: LoadFactorManager,
   45|       |        load_factor_manager: LoadFactorManager,
   65|    126|                load_factor_manager: LoadFactorManager::new(0.5, 0.125), // Lower load factor for open addressing
   34|      2|                load_factor_manager: LoadFactorManager::new(0.75, 0.25),
   49|     24|                load_factor_manager: LoadFactorManager::new(0.75, 0.25),
  390|      2|        let load_factors = vec![0.25, 0.5, 0.75, 0.9];
  465|      1|        let load_factors = vec![0.25, 0.5, 0.75, 0.9];
  108|     27|            let local_len = self.len();
   83|      1|        let lock = Arc::new(SpinLock::new());
   92|       |            // Lock released here
   88|      4|            let lock_clone = Arc::clone(&lock);
  152|       |            // Locks released here
  221|       |            // Locks released here
   23|       |        fn lock(&self);
   69|      0|        fn lock(&self) { SpinLock::lock(self) }
  279|      1|                "Θ(n log n)".to_string(),
  284|      1|                "Θ(n log n)".to_string(),
  289|      1|                "Θ(n log n)".to_string(),
   28|       |        /// Logical OR of all elements via reduce.
   29|       |        /// Logical OR of all elements via parallel reduce.
   34|       |        /// Logical AND of all elements via reduce.
   35|       |        /// Logical AND of all elements via parallel reduce.
   39|       |        /// Logical AND: documents in both sets
   43|       |        /// Logical OR: documents in either set
   47|       |        /// Logical AND NOT: documents in first set but not second
  102|       |        /// Look up value for given key
   37|       |        /// Looks up in the chain at the hashed bucket.
   63|       |        /// Looks up a key in the hash table, returning its value if found.
   67|       |        /// Looks up using probe sequence.
   39|      9|        fn lookup_chained(table: &HashTable<Key, Value, Entry, Metrics>, key: &Key) -> Option<Value> {
  108|     63|        fn lookup(&self, k: &K) -> Option<V> { self.find(k) }
  110|     67|        fn lookup(&self, k: &K) -> Option<V> { self.find(k) }
  111|      1|        fn lookup(&self, k: &K) -> Option<V> { self.base_table.lookup(k) }
  117|      1|        fn lookup(&self, k: &K) -> Option<V> { self.base_table.lookup(k) }
   25|      7|        fn lookup(&self, key: &Key) -> Option<Value> {
   26|      0|        fn lookup(&self, key: &Key) -> Option<Value> {
   26|      7|        fn lookup(&self, key: &Key) -> Option<Value> {
   31|       |        fn lookup(&self, k: &K) -> Option<V>; // Alias for find
   34|       |        fn lookup(&self, k: &K) -> Option<V>; // Alias for find
   38|       |        fn lookup(&self, key: &Key) -> Option<Value>;
   38|       |        fn lookup(&self, k: &K) -> Option<V>;
   38|       |        fn lookup(&self, k: &K) -> Option<V>;
   51|     10|        fn lookup(&self, key: &Key) -> Option<Value> {
   38|     19|        fn lookup(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> Option<Value> {
   38|      3|        fn lookup(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> Option<Value> {
   55|      3|        fn lookup(table: &HashTable<Key, Value, Vec<(Key, Value)>, Metrics>, key: &Key) -> Option<Value> {
   65|      3|        fn lookup(table: &HashTable<Key, Value, LinkedList<(Key, Value)>, Metrics>, key: &Key) -> Option<Value> {
   65|       |        fn lookup(table: &HashTable<Key, Value, Entry, Metrics>, key: &Key) -> Option<Value>;
   77|     17|        fn lookup(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> Option<Value> {
   90|      3|        fn lookup(table: &HashTable<Key, Value, ChainList<Key, Value>, Metrics>, key: &Key) -> Option<Value> {
   69|      0|        fn lookup_with_probe(table: &HashTable<Key, Value, Entry, Metrics>, key: &Key) -> Option<Value> {
   21|       |    /// Lower priority values = higher priority (visited first).
   21|       |    /// Lower priority values = higher priority (visited first).
  144|     30|                    let lr = left_right_arc.clone();
   98|     26|                    let lr = left_right_arc.clone();
  100|     66|                let ls = size(&n.left);
   77|  11.2M|            let ls = size(&node.left);
   77|  2.66k|            let ls = size(&node.left);
   99|     14|                let ls = size(&n.left);
  112|     10|                        if lt != i {
  149|      7|                        if lt != i {
   64|     21|                        if lt != i {
  149|      3|            let m = other.size();
  195|    197|            let m = other.size();
  200|    123|            if m == 0 {
  169|       |    // Macro for creating ArraySetEnumMtEph literals
  195|       |    // Macro for creating unsorted list priority queues
  255|       |    // Macro for creating document collections
  261|       |    // Macro for creating sorted list priority queues
  265|       |    /// Macro for creating ordered sets from literals
  292|       |    // Macro for creating balanced tree priority queues
  294|       |    /// Macro for creating ordered sets from sorted element lists
  296|       |    /// Macro for creating ephemeral table literals
  316|       |    /// Macro for creating ephemeral ordered sets from sorted element lists
  332|       |    /// Macro for creating table literals
  341|       |    /// Macro for creating nested hash tables with initial data
  348|       |    // Macro for creating binary heap priority queues
  356|       |    /// Macro for creating hash function implementations
  363|       |    /// Macro for creating ordered tables from sorted key-value pairs
  379|       |    /// Macro for creating ephemeral ordered tables from sorted key-value pairs
  383|       |    // Macro for creating augmented ordered table literals
  389|       |    // Macro for creating leftist heap priority queues
  407|       |    /// Macro for creating multi-threaded ephemeral ordered tables from sorted key-value pairs
  416|       |    // Macro for creating augmented ordered table literals
  418|       |    // Macro for creating augmented ordered table literals
  669|       |    /// Macro for creating multi-threaded ephemeral table literals
  112|       |            // Main search loop
   82|       |        // Main loop: deleteMin until queue is empty
   82|       |        // Main loop: deleteMin until queue is empty
   41|     15|            let main_result = ArraySeqStEphS::tabulate(
   68|     15|            let main_result = ArraySeqMtEphS::tabulate(
    5|       |//! while maintaining compatibility with APAS MtVal trait requirements.
   52|       |            // Make this vertex a center
   32|       |        fn make_index(docs: &DocumentCollection) -> Self;
   63|     36|        fn make_index(docs: &DocumentCollection) -> Self {
  133|      0|        fn make_node(key: K, value: V, priority: u64, left: Link<K, V, R>, right: Link<K, V, R>) -> Link<K, V, R> {
   74|    724|        fn make_node(key: T, left: LeftistHeapNode<T>, right: LeftistHeapNode<T>) -> Self {
   80|     17|        fn make_node(key: T, priority: u64, left: Link<T>, right: Link<T>) -> Link<T> {
   90|    765|                return make_node(left, key, priority, right);
   95|    334|                    return make_node(ll, lk, lp, merged_right);
  101|     15|                    return make_node(merged_left, rk, rp, rr);
   51|  1.11k|    fn make_node<T: MtKey>(left: ParamTreap<T>, key: T, priority: i64, right: ParamTreap<T>) -> ParamTreap<T> {
  160|      2|Yes, it makes sense to reduce hash table size under certain conditions:
  296|      1|5. Memory Management:
  154|      2|        let manual_union = singleton1
  169|      2|        assert_eq!(set_result.size(), manual_union.size());
  141|     45|        let map1 = partition_map.clone();
  142|     20|        let map1 = vertex_map.clone();
  170|     38|        let map1 = partition_map.clone();
  174|      1|            (vertices.clone(), map)
  184|      1|        println!("Persistent map: {:?}", per_map_time);
  189|      1|        println!("Ephemeral map: {:?}", eph_map_time);
  194|      1|        println!("Multi-threaded map: {:?}", mt_map_time);
  143|     45|        let map2 = partition_map;
  144|     20|        let map2 = vertex_map;
  146|     45|            route_edges_parallel(&edges2, map2, mid, end)
  147|     20|            build_edges_parallel(edges2, map2, mid, end)
  172|     38|        let map2 = partition_map;
  175|     38|            route_edges_parallel(&edges2, map2, mid, end)
  233|      0|            (vertices.clone(), map)
  407|       |        /// Map elements to a new type (maintaining order)
   68|      1|        println!("\n--- Map Operations ---");
   74|       |            // Map quotient tree edges back to original edges
   89|       |            // Map endpoints to their centers
  115|      4|        let map_arc = Arc::new(edge_coin_map);
   76|     24|                if !map.contains_key(vertex) {
  102|      3|        fn map<F: Fn(&V) -> V>(&mut self, f: F) {
  119|      8|        fn map<F: Fn(&V) -> V>(&self, f: F) -> Self {
  129|      4|        fn map<F: Fn(&V) -> V>(&self, f: F) -> Self {
  134|      3|        fn map<F: Fn(&K, &V) -> V>(&self, f: F) -> Self {
  175|      4|        fn map<F: Fn(&V) -> V + Send + Sync + 'static>(&mut self, f: F) {
   32|       |        fn map<F: Fn(&V) -> V>(&mut self, f: F);
   35|       |        fn map<F: Fn(&V) -> V + Send + Sync + 'static>(&mut self, f: F);
   36|       |        fn map<F: Fn(&V) -> V>(&self, f: F) -> Self;
   39|       |        fn map<F: Fn(&V) -> V>(&self, f: F) -> Self;
   43|       |        fn map<F: Fn(&K, &V) -> V>(&self, f: F) -> Self;
   43|       |        fn map<F: Fn(&V) -> V>(&self, f: F) -> Self;
   46|       |        fn map<F: Fn(&K, &V) -> V + Send + Sync + 'static>(&self, f: F) -> Self;
   72|      2|        fn map<F: Fn(&V) -> V>(&self, f: F) -> Self {
  141|      3|        fn map<F>(&self, f: F) -> Self
  154|      1|        fn map<G: Fn(&K, &V) -> V>(&self, f: G) -> Self {
  156|      1|        fn map<G: Fn(&V) -> V>(&self, f: G) -> Self {
  165|      1|        fn map<G: Fn(&K, &V) -> V + Send + Sync + 'static>(&self, f: G) -> Self {
   42|       |        fn map<G: Fn(&V) -> V>(&self, f: G) -> Self;
   44|       |        fn map<G: Fn(&K, &V) -> V>(&self, f: G) -> Self;
   49|       |        fn map<G: Fn(&K, &V) -> V + Send + Sync + 'static>(&self, f: G) -> Self;
  417|      7|                let mapped = f(current);
  103|      3|            let mapped_entries = ArraySeqStEphS::tabulate(
  182|  1.00k|        let _mapped_per = table_per.map(|s| s.to_uppercase());
   84|       |    ///   mapping from each vertex to its component representative
   86|       |    ///   mapping from each vertex to its component representative
  108|       |    macro_rules! MappingLit {
    4|       |pub mod MappingStEph {
   13|       |        /// Maps a key to a hash code in range [0, table_size)
  103|      2|        fn map<U: MtVal, F: Fn(&T) -> U + Send + Sync + Clone + 'static>(
  107|      6|        fn map<U: StT, F: Fn(&T) -> U>(a: &ArraySeqStPerS<T>, f: &F) -> ArraySeqStPerS<U> {
  110|      9|        fn map<U: StT, F: Fn(&T) -> U>(a: &ArraySeqStEphS<T>, f: &F) -> ArraySeqStEphS<U> {
  119|       |        fn map<U: StTInMtT + 'static, F: Fn(&T) -> U + Send + Sync + Clone + 'static>(
  135|       |        fn map<U: StT, F: Fn(&T) -> U>(a: &ArraySeqStEphS<T>, f: &F) -> ArraySeqStEphS<U>;
  155|      7|        fn map<U: StT, F: Fn(&T) -> U>(a: &ArraySeqStPerS<T>, f: &F) -> ArraySeqStPerS<U> {
  184|      3|        fn map<U: MtVal, F: Fn(&T) -> U + Send + Sync + Clone + 'static>(a: &Self, f: F) -> ArraySeqMtEphSliceS<U> {
  200|      3|        fn map<U: StT, F: Fn(&T) -> U>(a: &ArraySeqStEphS<T>, f: &F) -> ArraySeqStEphS<U> {
  203|  3.99k|        fn map<U: StTInMtT + 'static, F: Fn(&T) -> U + Send + Sync + Clone + 'static>(
  206|       |        fn map<U: StT, F: Fn(&T) -> U>(a: &Self, f: &F) -> LinkedListStEphS<U>;
  207|      1|        fn map<U: Clone, F: Fn(&T) -> U>(a: &ArraySeqS<T>, f: &F) -> ArraySeqS<U> {
  251|      3|        fn map<U: StT, F: Fn(&T) -> U>(a: &LinkedListStPerS<T>, f: &F) -> LinkedListStPerS<U> {
  279|      3|        fn map<U: StT, F: Fn(&T) -> U>(a: &Self, f: &F) -> LinkedListStEphS<U> {
   33|       |        fn map<U: MtVal, F: Fn(&T) -> U + Send + Sync + Clone + 'static>(
   33|       |        fn map<U: StT, F: Fn(&T) -> U>(a: &ArraySeqStEphS<T>, f: &F) -> ArraySeqStEphS<U>;
   33|       |        fn map<U: StT, F: Fn(&T) -> U>(a: &ArraySeqStPerS<T>, f: &F) -> ArraySeqStPerS<U>;
   48|       |        fn map<U: StT, F: Fn(&T) -> U>(a: &LinkedListStPerS<T>, f: &F) -> LinkedListStPerS<U>;
   50|       |        fn map<U: Clone, F: Fn(&T) -> U>(a: &ArraySeqS<T>, f: &F) -> ArraySeqS<U>;
   62|       |        fn map<U: MtVal, F: Fn(&T) -> U + Send + Sync + Clone + 'static>(a: &Self, f: F) -> ArraySeqMtEphSliceS<U>;
   99|       |        fn map<U: StT, F: Fn(&T) -> U>(a: &ArraySeqStPerS<T>, f: &F) -> ArraySeqStPerS<U>;
  118|    213|        fn map<W: MtVal, F: Fn(&T) -> W + Send + Sync + Clone + 'static>(
  140|       |        fn map<W: StTInMtT + 'static, F: Fn(&T) -> W + Send + Sync + Clone + 'static>(
  214|     10|        fn map<W: StTInMtT + 'static, F: Fn(&T) -> W + Send + Sync + Clone + 'static>(
   31|       |        fn map<W: StTInMtT + 'static, F: Fn(&T) -> W + Send + Sync + Clone + 'static>(
  202|       |                            // Mark as dead
   60|       |                        // Mark as Deleted (tombstone) to maintain probe chain integrity
   97|       |                // Mark v as visited with distance dist
   97|       |                // Mark v as visited with distance dist
   49|     29|            if !matched_vertices.mem(u) && !matched_vertices.mem(v) {
  111|      1|        let matching = greedy_matching(graph);
  112|      1|        edge_contract(graph, &matching)
  174|      1|        let matching = parallel_matching_mt(graph, seed);
  175|      1|        edge_contract_mt(graph, &matching)
   64|      4|        let matching = select_edges_parallel(graph, &edges_seq, &coins);
   88|       |        /// Materializes the current slice into a Vec for diagnostics or copies.
    8|       |pub mod MathSeq {
  193|      1|                return MathSeqS { data: Vec::new() };
  243|       |    macro_rules! MathSeqSLit {
    4|       |pub mod MatrixChainMtEph {
  299|       |    macro_rules! MatrixChainMtEphLit {
   60|       |    impl MatrixChainMtEphS {
  138|       |    impl MatrixChainMtEphTrait for MatrixChainMtEphS {
    4|       |pub mod MatrixChainMtPer {
  229|       |    macro_rules! MatrixChainMtPerLit {
   51|       |    impl MatrixChainMtPerS {
  128|       |    impl MatrixChainMtPerTrait for MatrixChainMtPerS {
   62|    110|        fn matrix_chain_rec(&mut self, i: usize, j: usize) -> usize {
   74|     15|        fn matrix_chain_rec(&mut self, i: usize, j: usize) -> usize {
  102|    134|        fn matrix_chain_rec(&self, i: usize, j: usize) -> usize {
   92|    146|        fn matrix_chain_rec(&self, i: usize, j: usize) -> usize {
    4|       |pub mod MatrixChainStEph {
  208|       |    macro_rules! MatrixChainStEphLit {
   61|       |    impl MatrixChainStEphS {
  101|       |    impl MatrixChainStEphTrait for MatrixChainStEphS {
    4|       |pub mod MatrixChainStPer {
   49|       |    impl MatrixChainStPerS {
   89|       |    impl MatrixChainStPerTrait for MatrixChainStPerS {
  107|     10|                .map(|pair| MatrixDim {
  119|     10|                .map(|pair| MatrixDim {
  146|     17|                .map(|pair| MatrixDim {
  156|     19|                .map(|pair| MatrixDim {
   40|     19|            let max_attempts = (table.current_size + 1) / 2; // APAS Lemma 47.1: first ⌈m/2⌉ probes are distinct
   56|      3|            let max_attempts = (table.current_size + 1) / 2; // APAS Lemma 47.1: first ⌈m/2⌉ probes are distinct
   88|     31|            let max_attempts = (table.current_size + 1) / 2; // APAS Lemma 47.1: first ⌈m/2⌉ probes are distinct
  208|     20|            let max_chain_length = if collision_chains > 0 {
  256|       |        pub max_chain_length: N,
   27|       |        pub max_chain_length: N,
  137|      4|            let max_cluster_size = *clusters.iter().max().unwrap_or(&0);
   24|       |        pub max_cluster_size: N,
   27|     48|    fn max_contig_sub_sum_aux(a: &ArraySeqStEphS<i32>) -> StrengthResult {
   27|     48|    fn max_contig_sub_sum_aux_mt(a: &ArraySeqMtEphS<i32>) -> StrengthResult {
   25|       |        fn max_contig_sub_sum_brute(a: &ArraySeqStEphS<i32>) -> Option<i32>;
   29|      9|        fn max_contig_sub_sum_brute(a: &ArraySeqStEphS<i32>) -> Option<i32> {
    4|       |pub mod MaxContigSubSumBruteStEph {
   28|       |    impl MaxContigSubSumBruteTrait for ArraySeqStEphS<i32> {
   66|       |        fn max_contig_sub_sum_divcon(a: &ArraySeqStEphS<i32>) -> Option<i32>;
   70|     38|        fn max_contig_sub_sum_divcon(a: &ArraySeqStEphS<i32>) -> Option<i32> {
   67|       |        fn max_contig_sub_sum_divcon_mt(a: &ArraySeqMtEphS<i32>) -> Option<i32>;
   71|     38|        fn max_contig_sub_sum_divcon_mt(a: &ArraySeqMtEphS<i32>) -> Option<i32> {
    8|       |pub mod MaxContigSubSumDivConMtEph {
   70|       |    impl MaxContigSubSumDivConMtTrait for ArraySeqMtEphS<i32> {
   74|       |        fn max_contig_sub_sum_divcon_opt(a: &ArraySeqStEphS<i32>) -> Option<i32>;
   78|      6|        fn max_contig_sub_sum_divcon_opt(a: &ArraySeqStEphS<i32>) -> Option<i32> {
   73|       |        fn max_contig_sub_sum_divcon_opt_mt(a: &ArraySeqMtEphS<i32>) -> Option<i32>;
   77|      6|        fn max_contig_sub_sum_divcon_opt_mt(a: &ArraySeqMtEphS<i32>) -> Option<i32> {
    8|       |pub mod MaxContigSubSumDivConOptMtEph {
   76|       |    impl MaxContigSubSumDivConOptMtTrait for ArraySeqMtEphS<i32> {
    8|       |pub mod MaxContigSubSumDivConOptStEph {
   77|       |    impl MaxContigSubSumDivConOptTrait for ArraySeqStEphS<i32> {
    8|       |pub mod MaxContigSubSumDivConStEph {
   69|       |    impl MaxContigSubSumDivConTrait for ArraySeqStEphS<i32> {
   16|       |        fn max_contig_sub_sum_opt(a: &ArraySeqStEphS<i32>) -> Option<i32>;
   20|      6|        fn max_contig_sub_sum_opt(a: &ArraySeqStEphS<i32>) -> Option<i32> {
   19|       |        fn max_contig_sub_sum_opt_mt(a: &ArraySeqMtEphS<i32>) -> Option<i32>;
   23|      6|        fn max_contig_sub_sum_opt_mt(a: &ArraySeqMtEphS<i32>) -> Option<i32> {
    4|       |pub mod MaxContigSubSumOptMtEph {
   22|       |    impl MaxContigSubSumOptMtTrait for ArraySeqMtEphS<i32> {
    4|       |pub mod MaxContigSubSumOptStEph {
   19|       |    impl MaxContigSubSumOptTrait for ArraySeqStEphS<i32> {
   26|       |        fn max_contig_sub_sum_reduced(a: &ArraySeqStEphS<i32>) -> Option<i32>;
   30|      5|        fn max_contig_sub_sum_reduced(a: &ArraySeqStEphS<i32>) -> Option<i32> {
    4|       |pub mod MaxContigSubSumReducedStEph {
   29|       |    impl MaxContigSubSumReducedTrait for ArraySeqStEphS<i32> {
  107|     16|            let max_crossing = max_suffix_left + max_prefix_right;
   52|     21|        let max_crossing = s_left + p_right;
   57|     21|        let max_crossing = s_left + p_right;
   93|     16|            let max_crossing = max_suffix_left + max_prefix_right;
  196|      2|            let max_element = self.elements.nth(max_index).clone();
  228|      0|            let max_element = self.elements.nth(self.elements.length() - 1).clone();
   14|       |        fn max_element(a: &ArraySeqStPerS<N>) -> Option<N>;
   42|      2|        fn max_element(a: &ArraySeqStPerS<N>) -> Option<N> {
   15|       |        fn max_element_parallel(a: &ArraySeqMtPerS<N>) -> Option<N>;
   43|      2|        fn max_element_parallel(a: &ArraySeqMtPerS<N>) -> Option<N> {
  103|       |        fn maximum_key(&self) -> Option<&K>;
  223|      1|        fn maximum_key(&self) -> Option<&K> { Self::max_key_link(&self.root) }
  326|     10|        fn maximum_key(&self) -> Option<&K> { Self::max_key_link(&self.root) }
   63|       |        fn maximum_key(&self) -> Option<&K>;
  170|     22|        fn maximum(&self) -> Option<T> {
  173|      2|        fn maximum(&self) -> Option<&T> { Self::max_link(&self.root) }
  192|     17|        fn maximum(&self) -> Option<T> {
  208|     12|        fn maximum(&self) -> Option<&T> { Self::max_link(&self.root) }
  225|     25|        fn maximum(&self) -> Option<T> {
  230|     10|        fn maximum(&self) -> Option<&T> { Self::max_link(&self.root) }
  232|     19|        fn maximum(&self) -> Option<T> {
  240|      1|        fn maximum(&self) -> Option<T> { self.tree.maximum() }
  240|      1|        fn maximum(&self) -> Option<T> { self.tree.maximum() }
  240|      1|        fn maximum(&self) -> Option<T> { self.tree.maximum() }
  240|      1|        fn maximum(&self) -> Option<T> { self.tree.maximum() }
  240|      1|        fn maximum(&self) -> Option<T> { self.tree.maximum() }
  240|      1|        fn maximum(&self) -> Option<T> { self.tree.maximum() }
  241|    431|        fn maximum(&self) -> Option<T> {
  252|      0|        fn maximum(&self) -> Option<&T> { Self::max_link(&self.root) }
  254|      8|        fn maximum(&self) -> Option<&T> { Self::max_link(&self.root) }
  263|      1|        fn maximum(&self) -> Option<&T> { Self::max_link(&self.root) }
  286|     80|        fn maximum(&self) -> Option<T> {
   35|       |        fn maximum(&self) -> Option<&T>;
   35|       |        fn maximum(&self) -> Option<T>;
   35|       |        fn maximum(&self) -> Option<T>;
   35|       |        fn maximum(&self) -> Option<T>;
   35|       |        fn maximum(&self) -> Option<T>;
   35|       |        fn maximum(&self) -> Option<T>;
   35|       |        fn maximum(&self) -> Option<T>;
   56|       |        fn maximum(&self) -> Option<&T>;
   58|       |        fn maximum(&self) -> Option<&T>;
   58|       |        fn maximum(&self) -> Option<&T>;
   58|       |        fn maximum(&self) -> Option<&T>;
   58|       |        fn maximum(&self) -> Option<&T>;
   58|       |        fn maximum(&self) -> Option<T>;
   60|       |        fn maximum(&self) -> Option<T>;
   60|       |        fn maximum(&self) -> Option<T>;
   60|       |        fn maximum(&self) -> Option<T>;
   60|       |        fn maximum(&self) -> Option<T>;
   60|       |        fn maximum(&self) -> Option<T>;
   64|       |        fn maximum(&self) -> Option<&T>;
   67|     11|        fn maximum(&self) -> Option<&T> { max_node(&self.root) }
  195|      2|            let max_index = self.elements.length() - 1;
  151|      2|        fn max_key_link<'a>(link: &'a Link<K, V>) -> Option<&'a K> {
  224|     17|        fn max_key_link<'a>(link: &'a Link<K, V, R>) -> Option<&'a K> {
   87|     16|            let max_left = Self::max_contig_sub_sum_divcon(&left);
   94|     16|            let max_left = result_pair.0;
  121|      5|        fn max_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  123|    178|        fn max_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  153|     29|        fn max_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  154|     56|        fn max_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  158|    136|        fn max_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  166|      3|        fn max_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  178|     26|        fn max_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  178|  2.88k|        fn max_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  197|     17|        fn max_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  200|     11|        fn max_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  214|    299|        fn max_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  217|    153|                max_load_factor: max_load,
  129|    127|    fn max_node<'a, T: StT + Ord>(node: &'a BalBinTree<T>) -> Option<&'a T> {
   55|       |        // max_prefix = max(p_left, t_left + p_right)
   56|     21|        let max_prefix = p_left.max(t_left + p_right);
   59|     21|        let max_prefix = p_left.max(t_left + p_right);
   63|     21|        (max_sum, max_prefix, max_suffix, total)
   64|     21|        (max_sum, max_prefix, max_suffix, total)
  105|     16|            let max_prefix_right = crossing_pair.1;
   92|     16|            let max_prefix_right = max_prefix_sum(&right);
   42|     16|    fn max_prefix_sum(a: &ArraySeqStEphS<i32>) -> i32 {
   44|     16|    fn max_prefix_sum(a: &ArraySeqMtEphS<i32>) -> i32 {
   45|       |        pub max_probes: N,
   88|     16|            let max_right = Self::max_contig_sub_sum_divcon(&right);
   95|     16|            let max_right = result_pair.1;
   58|       |        // max_suffix = max(s_right, s_left + t_right)
   59|     21|        let max_suffix = s_right.max(s_left + t_right);
   60|     21|        let max_suffix = s_right.max(s_left + t_right);
  104|     16|            let max_suffix_left = crossing_pair.0;
   91|     16|            let max_suffix_left = max_suffix_sum(&left);
   24|     16|    fn max_suffix_sum(a: &ArraySeqStEphS<i32>) -> i32 {
   27|     16|    fn max_suffix_sum(a: &ArraySeqMtEphS<i32>) -> i32 {
   51|       |        // max_sum = max(m_left, m_right, s_left + p_right)
   53|     21|        let max_sum = max_with_neginf(max_with_neginf(m_left, m_right), Some(max_crossing));
   58|     21|        let max_sum = max_with_neginf(max_with_neginf(m_left, m_right), Some(max_crossing));
   78|      6|            let (max_sum, _, _, _) = max_contig_sub_sum_aux_mt(a);
   79|      6|            let (max_sum, _, _, _) = max_contig_sub_sum_aux(a);
   10|     57|    fn max_with_neginf(a: Option<i32>, b: Option<i32>) -> Option<i32> {
   13|     42|    fn max_with_neginf(a: Option<i32>, b: Option<i32>) -> Option<i32> {
   14|     32|    fn max_with_neginf(a: Option<i32>, b: Option<i32>) -> Option<i32> {
   14|     42|    fn max_with_neginf(a: Option<i32>, b: Option<i32>) -> Option<i32> {
   17|     32|    fn max_with_neginf(a: Option<i32>, b: Option<i32>) -> Option<i32> {
    9|     76|    fn max_with_neginf(a: Option<i32>, b: Option<i32>) -> Option<i32> {
  155|      0|                let mean = avg_cluster_size;
  171|       |            // Measure hash function independence (simplified heuristic)
  289|      1|   - Measure actual vs. theoretical performance
  406|       |        /// Measure hash function performance
   88|      6|            fn median3<T: StT + Ord>(a: &ArraySeqStEphS<T>, lo: N, hi: N) -> T {
   59|     24|        fn med_recursive_concurrent(&self, i: usize, j: usize) -> usize {
   59|     24|        fn med_recursive_concurrent(&self, i: usize, j: usize) -> usize {
   57|     28|        fn med_recursive(&mut self, i: usize, j: usize) -> usize {
  112|     88|        fn med_recursive_parallel(&self, i: usize, j: usize) -> usize {
  114|     67|        fn med_recursive_parallel(&self, i: usize, j: usize) -> usize {
   60|     28|        fn med_recursive(&self, i: usize, j: usize, memo: &mut HashMap<(usize, usize), usize>) -> usize {
  117|       |                        // Meld ra (right subtree of a) with entire b
  122|       |        /// Meld two balanced trees by merging sorted sequences
  130|       |                        // Meld entire a with rb (right subtree of b)
  422|       |        // Meld all heaps together efficiently
  118|    554|                        let melded_right = Self::meld_nodes(
  131|    170|                        let melded_right = Self::meld_nodes(
  247|    114|                    let melded_root = LeftistHeapNode::meld_nodes(left.as_ref().clone(), right.as_ref().clone());
   97|  1.15k|        fn meld_nodes(a: LeftistHeapNode<T>, b: LeftistHeapNode<T>) -> LeftistHeapNode<T> {
   39|       |        /// Melds two balanced trees using union operation
   39|       |        /// Melds two heaps by concatenating and re-heapifying
   39|       |        /// Melds two priority queues by concatenating lists
   39|       |        /// Melds two sorted priority queues by merging sorted lists
  123|      5|        fn meld(&self, other: &Self) -> Self {
  129|      8|        fn meld(&self, other: &Self) -> Self {
  138|      5|        fn meld(&self, other: &Self) -> Self {
  247|      5|        fn meld(&self, other: &Self) -> Self {
  257|    312|        fn meld(&self, other: &Self) -> Self {
   40|       |        fn meld(&self, other: &Self) -> Self;
   40|       |        fn meld(&self, other: &Self) -> Self;
   40|       |        fn meld(&self, other: &Self) -> Self;
   40|       |        fn meld(&self, other: &Self) -> Self;
   52|       |        fn meld(&self, other: &Self) -> Self;
  100|      1|                memo_table: memo,
  101|    366|                let memo_guard = self.memo.lock().unwrap();
  105|    134|                let memo_guard = self.memo.lock().unwrap();
  115|     88|                let memo_guard = self.memo_table.lock().unwrap();
  117|     67|                let memo_guard = self.memo_table.lock().unwrap();
  133|      0|            let memo_guard = self.memo.lock().unwrap();
  141|      0|            let memo_guard = self.memo.lock().unwrap();
  147|      0|                let memo_guard = self.memo.lock().unwrap();
  155|      0|                let memo_guard = self.memo.lock().unwrap();
  157|      2|            let memo_guard = self.memo.lock().unwrap();
  166|      4|            let memo_guard = self.memo_table.lock().unwrap();
  171|      0|                let memo_guard = self.memo.lock().unwrap();
  174|      1|            let memo_guard = self.memo_table.lock().unwrap();
  178|      0|            let memo_guard = self.memo.lock().unwrap();
  179|      4|            let memo_guard = self.memo_table.lock().unwrap();
  180|      3|            let memo_guard = self.memo.lock().unwrap();
  182|      1|            let memo_guard = self.memo.lock().unwrap();
  182|      1|            let memo_guard = self.memo_table.lock().unwrap();
  187|      1|            let memo_guard = self.memo_table.lock().unwrap();
  192|      1|                let memo_guard = self.memo.lock().unwrap();
  194|      0|                let memo_guard = self.memo.lock().unwrap();
  195|      1|            let memo_guard = self.memo_table.lock().unwrap();
  196|      1|                let memo_guard = self.memo.lock().unwrap();
  224|      6|            let memo_guard = self.memo.lock().unwrap();
  229|      4|            let memo_guard = self.memo.lock().unwrap();
  243|      1|                let memo_guard = self.memo.lock().unwrap();
  248|      1|                let memo_guard = self.memo.lock().unwrap();
   53|    234|                let memo_guard = self.memo.lock().unwrap();
   57|    179|                let memo_guard = self.memo.lock().unwrap();
   62|     24|                let memo_guard = self.memo_table.lock().unwrap();
   62|     24|                let memo_guard = self.memo_table.lock().unwrap();
   63|    114|                let memo_guard = self.memo.lock().unwrap();
   73|    230|                let memo_guard = self.memo.lock().unwrap();
   92|    237|                let memo_guard = self.memo.lock().unwrap();
   95|    146|                let memo_guard = self.memo.lock().unwrap();
   32|       |        /// Memoization table for subproblem results
   32|       |        /// Memoization table for subproblem results
  106|       |            // Memoize result (thread-safe)
  118|       |            // Memoize result (thread-safe)
  121|       |            // Memoize result (thread-safe)
  128|       |            // Memoize result (thread-safe)
  133|       |            // Memoize result (thread-safe)
   70|       |            // Memoize result
   74|       |            // Memoize result
   79|       |            // Memoize result
   81|       |            // Memoize result
   83|       |            // Memoize result
   84|       |            // Memoize result (thread-safe)
   89|       |            // Memoize result
   90|       |            // Memoize result (thread-safe)
   93|       |            // Memoize result
   94|       |            // Memoize result (thread-safe)
   95|       |            // Memoize result
  173|      2|- Reduced memory usage
  179|      2|- Temporary memory overhead during resize
  146|      0|            let memo_size = {
  153|       |                self.multiset, memo_size
  154|      0|            let memo_size = {
  170|      0|            let memo_size = {
  177|       |                self.multiset, memo_size
  191|      1|            let memo_size = {
  193|      0|            let memo_size = {
  195|      1|            let memo_size = {
  242|      1|            let memo_size = {
  247|      1|            let memo_size = {
  253|       |                dimensions_len, memo_size
  112|      1|        fn memo_size(&self) -> usize { self.memo.len() }
  115|      1|        fn memo_size(&self) -> usize { self.memo.len() }
  130|      3|        fn memo_size(&self) -> usize { self.memo.len() }
  132|      0|        fn memo_size(&self) -> usize {
  132|      1|        fn memo_size(&self) -> usize { self.memo.len() }
  136|      0|        fn memo_size(&self) -> usize { self.memo.len() }
  140|      0|        fn memo_size(&self) -> usize {
  147|      8|        fn memo_size(&self) -> usize { self.memo.len() }
  156|      2|        fn memo_size(&self) -> usize {
  163|      8|        fn memo_size(&self) -> usize { self.memo.len() }
  168|      4|        fn memo_size(&self) -> usize { self.memo.len() }
  177|      0|        fn memo_size(&self) -> usize {
  179|      3|        fn memo_size(&self) -> usize {
  181|      1|        fn memo_size(&self) -> usize {
  223|      6|        fn memo_size(&self) -> usize {
  228|      4|        fn memo_size(&self) -> usize {
   39|       |        fn memo_size(&self) -> usize;
   40|       |        fn memo_size(&self) -> usize;
   41|       |        fn memo_size(&self) -> usize;
   44|       |        fn memo_size(&self) -> usize;
   46|       |        fn memo_size(&self) -> usize;
   48|       |        fn memo_size(&self) -> usize;
   48|       |        fn memo_size(&self) -> usize;
   48|       |        fn memo_size(&self) -> usize;
   50|       |        fn memo_size(&self) -> usize;
   51|       |        fn memo_size(&self) -> usize;
   56|       |        fn memo_size(&self) -> usize;
   57|       |        fn memo_size(&self) -> usize;
   58|       |        fn memo_size(&self) -> usize;
   60|       |        fn memo_size(&self) -> usize;
   60|       |        fn memo_size(&self) -> usize;
   60|       |        fn memo_size(&self) -> usize;
  101|     82|        fn mem(&self, a: &X, b: &Y) -> B
  102|     23|        fn mem(&self, a: &X, b: &Y) -> B { self.rel.mem(a, b) }
  195|      0|        fn mem(&self, x: &T) -> B { if self.data.contains(x) { true } else { false } }
   29|       |        fn mem(&self, x: &T) -> B;
   46|       |        fn mem(&self, a: &X, b: &Y) -> B
   47|       |        fn mem(&self, a: &X, b: &Y) -> B;
  100|       |        // Merge: for each vertex, keep the minimum weight edge
   10|       |        /// Merge two sorted sequences into one sorted sequence.
  128|       |            // Merge the two sorted vectors
  137|       |        /// Merge two sorted lists maintaining sorted order
  143|       |            // Merge the two sorted sequences
  158|       |            // Merge and sort entries - combine both sequences
   15|       |        /// Merge two sorted sequences in parallel using binary search.
  206|       |        // Merge
  216|       |            // Merge results - combine both sequences
  272|       |            // Merge results - combine both filtered sequences
    2|       |//! Parallel merge sort implementation (Chapter 26).
    2|       |//! Sequential merge sort implementation (Chapter 26).
  305|       |        // Merge
  455|       |            // Merge results - combine both filtered sequences
  515|       |                // Merge results - combine both sequences
  591|       |            // Merge results - combine both filtered sequences
  647|       |            // Merge results - combine both filtered sequences
   84|       |                // Merge sorted halves
  170|      2|            let merged = ParamBST::join_pair_inner(left, right);
  248|      5|            let merged = ArraySeqStPerS::append(&self.elements, &other.elements);
  325|     27|            let merged = ParamBST::join_pair_inner(left, right);
  379|      4|            let merged = ParamTreap::join_pair_inner(left, right);
  104|    139|            match merged.get(&v) {
  423|      0|        let merged_heap = LeftistHeapPQ::meld_multiple(&heaps);
  100|     15|                    let merged_left = ParamTreap::join_with_priority(left, key, priority, rl);
  102|     26|                    let merged_left = handle_left.join().unwrap();
  139|     30|                let (merged_left, merged_right) = thread::scope(|s| {
  148|     30|                    let merged_left = handle_left.join().unwrap();
   93|     26|                let (merged_left, merged_right) = thread::scope(|s| {
  100|     26|                    let merged_right = Self::merge_parallel(&*lr, &*rr);
  103|     26|                    (merged_left, merged_right)
  109|     26|                ArraySeqMtPerS::append(&left_with_pivot, &merged_right)
  146|     30|                    let merged_right = Self::merge_parallel(&*lr, &*rr);
  149|     30|                    (merged_left, merged_right)
  155|     30|                ArraySeqMtPerS::append(&left_with_pivot, &merged_right)
   94|    334|                    let merged_right = ParamTreap::join_with_priority(lr, key, priority, right);
   13|       |        fn merge(left: &ArraySeqStPerS<T>, right: &ArraySeqStPerS<T>) -> ArraySeqStPerS<T>;
   22|     32|        fn merge(left: &ArraySeqStPerS<T>, right: &ArraySeqStPerS<T>) -> ArraySeqStPerS<T> {
   18|       |        fn merge_parallel(left: &ArraySeqMtPerS<T>, right: &ArraySeqMtPerS<T>) -> ArraySeqMtPerS<T>;
   27|    151|        fn merge_parallel(left: &ArraySeqMtPerS<T>, right: &ArraySeqMtPerS<T>) -> ArraySeqMtPerS<T> {
   18|       |        fn merge_sort(a: &ArraySeqStPerS<T>) -> ArraySeqStPerS<T>;
   78|     63|        fn merge_sort(a: &ArraySeqStPerS<T>) -> ArraySeqStPerS<T> {
    5|       |pub mod MergeSortMt {
  159|     80|        fn merge_sort_parallel(a: &ArraySeqMtPerS<T>) -> ArraySeqMtPerS<T> {
   23|       |        fn merge_sort_parallel(a: &ArraySeqMtPerS<T>) -> ArraySeqMtPerS<T>;
    4|       |pub mod MergeSortSt {
   66|     26|            let message = if is_valid {
   77|     26|            (is_valid, message)
   92|      7|            let message = if is_valid {
   98|      7|            (is_valid, message)
  253|      1|        let metrics = strategy.analyze_primary_clustering(&table);
   29|       |        pub metrics: Metrics,
  321|      1|        let metrics = strategy.analyze_double_hashing_quality(&test_key, table_size);
  348|      1|        let metrics = strategy.analyze_double_hashing_quality(&test_key, table_size);
  348|      1|        let metrics = strategy.analyze_secondary_clustering(&table);
  353|      1|        (probe_sequence, metrics, valid_h2_values)
  236|      0|                && metrics.collision_avoidance_score > 0.8
  380|      1|        let metrics_composite = strategy_composite.analyze_secondary_clustering(&table_composite);
  382|      1|        (metrics_prime, metrics_composite)
   54|     29|                metrics: Metrics::default(),
  235|      1|                && metrics.hash_function_independence > 0.1
  370|      1|        let metrics_prime = strategy_prime.analyze_secondary_clustering(&table_prime);
  234|      1|                && metrics.probe_sequence_period == table_size
   72|      1|        fn metrics(table: &HashTable<Key, Value, Entry, Metrics>) -> &Metrics { &table.metrics }
  100|      0|                let mid = n / 2;
  101|      5|                    let mid = self.data.len() / 2;
  104|    111|                let mid = len / 2;
  105|      0|                let mid = n / 2;
  105|  5.81k|                        let mid = len / 2;
  107|    217|                let mid = n / 2;
  119|    108|                let mid = n / 2;
  119|     43|                    let mid = (lo + hi) / 2;
  125|    674|            let mid = values.len() / 2;
  126|  11.0k|            let mid = a.len() / 2;
  127|      0|                let mid = n / 2;
  127|  1.23M|            let mid = a.len() / 2;
  128|      0|            let mid = n / 2;
  131|      5|            let mid = len / 2;
  132|    105|            let mid = a.length() / 2;
  134|     10|        let mid = start + range_size / 2;
  134|     18|        let mid = start + range_size / 2;
  138|     45|        let mid = start + size / 2;
  139|     20|        let mid = start + size / 2;
  143|      0|                    let mid = self.data.len() / 2;
  145|      0|                let mid = n / 2;
  145|      0|                let mid = n / 2;
  155|      0|                let mid = n / 2;
  156|     34|        let mid = start + size / 2;
  161|      0|                let mid = n / 2;
  165|      0|                let mid = n / 2;
  167|    263|            let mid = values.len() / 2;
  167|     38|        let mid = start + size / 2;
  168|     38|            let mid = n / 2;
  169|      0|            let mid = n / 2;
  169|    108|                let mid = n / 2;
  176|      7|                let mid = a.length() / 2;
  177|      0|                let mid = n / 2;
  189|      4|            let mid = len / 2;
  191|      7|                let mid = a.length() / 2;
  193|     50|        let mid = start + size / 2;
  197|      0|                let mid = n / 2;
  215|      0|            let mid = n / 2;
  220|  1.99k|            let mid = n / 2;
  227|      0|                let mid = n / 2;
  228|    106|                let mid = a.length() / 2;
  229|  13.3k|                let mid = left + (right - left) / 2;
  230|      4|            let mid = a.length() / 2;
  234|  15.3k|                let mid = left + (right - left) / 2;
  238|    941|                let mid = (left + right) / 2;
  242|      6|                let mid = a.length() / 2;
  246|      3|            let mid = len / 2;
  262|  50.0k|            let mid = a.length() / 2;
  272|      0|                let mid = n / 2;
  293|      6|            let mid = a.length() / 2;
  295|     51|        let mid = start + size / 2;
  317|      0|                let mid = n / 2;
  317|     73|            let mid = a.length() / 2;
   32|      7|                let mid: ArraySeqStPerS<ArraySeqStPerS<Pair<N, Pair<N, N>>>> =
  342|  1.99k|            let mid = a.length() / 2;
   34|      3|        let mid: ArraySeqStPerS<ArraySeqStPerS<T>> =
   34|      3|            let mid = lo + (hi - lo) / 2;
  362|     25|            let mid = len / 2;
   36|      6|            let mid = lo + (hi - lo) / 2;
   37|      8|            let mid = lo + (hi - lo) / 2;
  398|  33.1k|                let mid = left + (right - left) / 2;
  403|     20|            let mid = len / 2;
   42|     21|        let mid = n / 2;
   42|     21|        let mid = n / 2;
  428|      9|            let mid = len / 2;
  481|      2|                let mid = len / 2;
  564|      4|            let mid = len / 2;
  620|      4|            let mid = len / 2;
   66|     54|            let mid = costs.len() / 2;
   72|     29|            let mid = costs.len() / 2;
   73|     46|                    let mid = (lo + hi) / 2;
   75|    108|            let mid = costs.len() / 2;
   77|  5.04k|                let mid = n / 2;
   82|     16|            let mid = n / 2;
   82|     28|            let mid = costs.len() / 2;
   83|     16|            let mid = n / 2;
   87|     29|            let mid = n / 2;
   89|      6|                let mid = lo + (hi - lo) / 2;
   91|     51|        let mid = start + size / 2;
   92|      4|            let mid = len / 2;
   93|      0|                let mid = n / 2;
   98|      0|                let mid = n / 2;
  282|      1|            (left, middle, right)
   69|    198|                    let middle = <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::singleton(node.value.clone());
  126|     30|                let mid_left = lo;
   66|     26|                let mid_left = n_left / 2;
  350|      1|            let mid_rank = range_table.size() / 2;
  112|     30|                let mid_right = n_right / 2;
   80|     26|                let mid_right = lo;
  130|      7|        println!("split(A, 'mike') = (");
  116|     60|                let min_cost = self.parallel_min_reduction(costs);
  128|     71|                let min_cost = self.parallel_min_reduction(costs);
   70|     50|                let min_cost = (0..l)
   82|    151|                let min_cost = (0..l)
   83|    224|                new_distances.insert(v, min_dist);
   84|    224|                if min_dist != current_dist {
   92|    183|                new_distances.insert(v, min_dist);
   93|    183|                if min_dist != current_dist {
  115|     29|        fn min_edit_distance(&mut self) -> usize {
  136|     16|        fn min_edit_distance(&mut self) -> usize
   32|       |        fn min_edit_distance(&mut self) -> usize;
   34|       |        fn min_edit_distance(&mut self) -> usize
   48|    326|        fn min_edit_distance_rec(&mut self, i: usize, j: usize) -> usize {
   63|  1.07k|        fn min_edit_distance_rec(&mut self, i: usize, j: usize) -> usize {
   51|    179|        fn min_edit_distance_rec(&self, i: usize, j: usize) -> usize
   67|    230|        fn min_edit_distance_rec(&self, i: usize, j: usize) -> usize
  100|     19|        fn min_edit_distance(&self) -> usize {
  120|      9|        fn min_edit_distance(&self) -> usize
   32|       |        fn min_edit_distance(&self) -> usize;
   33|       |        fn min_edit_distance(&self) -> usize
    4|       |pub mod MinEditDistMtEph {
    4|       |pub mod MinEditDistMtPer {
    4|       |pub mod MinEditDistStEph {
    4|       |pub mod MinEditDistStPer {
  108|    117|            let min_element = self.elements.nth(0).clone();
  121|    253|            let min_element = self.elements.nth(0).clone();
  222|    189|                let min_element = self.elements.nth(0).clone();
  226|    214|            let min_element = self.elements.nth(0).clone();
  246|    114|                    let min_element = key.clone();
   87|     23|                    let min_entry = seq.nth(0);
   42|       |            // Min-heap: smaller distance has higher priority
   42|       |            // Min-heap: smaller distance has higher priority
    5|       |//! - Minimal placeholder main to satisfy Cargo bin target.
  170|      2|3. Ensure minimum table size (e.g., never below 8)
  190|       |        /// Minimum is always at the root (index 0)
  220|      1|- Maintain minimum table size
  225|       |        /// Minimum is always at the root
    5|       |//! Selects minimum priority vertices first (lower priority = higher urgency).
   68|       |        /// Minimum is always at the front of sorted list
   73|       |                // Minimum is at index 0 in sorted sequence
  102|       |        fn minimum_key(&self) -> Option<&K>;
  221|      1|        fn minimum_key(&self) -> Option<&K> { Self::min_key_link(&self.root) }
  324|     10|        fn minimum_key(&self) -> Option<&K> { Self::min_key_link(&self.root) }
   62|       |        fn minimum_key(&self) -> Option<&K>;
  148|     22|        fn minimum(&self) -> Option<T> {
  171|      3|        fn minimum(&self) -> Option<&T> { Self::min_link(&self.root) }
  187|     17|        fn minimum(&self) -> Option<T> {
  206|     12|        fn minimum(&self) -> Option<&T> { Self::min_link(&self.root) }
  220|     25|        fn minimum(&self) -> Option<T> {
  227|     19|        fn minimum(&self) -> Option<T> {
  228|     10|        fn minimum(&self) -> Option<&T> { Self::min_link(&self.root) }
  236|    431|        fn minimum(&self) -> Option<T> {
  238|      1|        fn minimum(&self) -> Option<T> { self.tree.minimum() }
  238|      1|        fn minimum(&self) -> Option<T> { self.tree.minimum() }
  238|      1|        fn minimum(&self) -> Option<T> { self.tree.minimum() }
  238|      1|        fn minimum(&self) -> Option<T> { self.tree.minimum() }
  238|      1|        fn minimum(&self) -> Option<T> { self.tree.minimum() }
  238|      1|        fn minimum(&self) -> Option<T> { self.tree.minimum() }
  250|      0|        fn minimum(&self) -> Option<&T> { Self::min_link(&self.root) }
  252|      8|        fn minimum(&self) -> Option<&T> { Self::min_link(&self.root) }
  261|      1|        fn minimum(&self) -> Option<&T> { Self::min_link(&self.root) }
  281|     80|        fn minimum(&self) -> Option<T> {
   33|       |        fn minimum(&self) -> Option<&T>;
   33|       |        fn minimum(&self) -> Option<T>;
   33|       |        fn minimum(&self) -> Option<T>;
   33|       |        fn minimum(&self) -> Option<T>;
   33|       |        fn minimum(&self) -> Option<T>;
   33|       |        fn minimum(&self) -> Option<T>;
   33|       |        fn minimum(&self) -> Option<T>;
   54|       |        fn minimum(&self) -> Option<&T>;
   56|       |        fn minimum(&self) -> Option<&T>;
   56|       |        fn minimum(&self) -> Option<&T>;
   56|       |        fn minimum(&self) -> Option<&T>;
   56|       |        fn minimum(&self) -> Option<&T>;
   56|       |        fn minimum(&self) -> Option<T>;
   58|       |        fn minimum(&self) -> Option<T>;
   58|       |        fn minimum(&self) -> Option<T>;
   58|       |        fn minimum(&self) -> Option<T>;
   59|       |        fn minimum(&self) -> Option<T>;
   59|       |        fn minimum(&self) -> Option<T>;
   62|       |        fn minimum(&self) -> Option<&T>;
   65|     11|        fn minimum(&self) -> Option<&T> { min_node(&self.root) }
  115|      3|                    let min_key = ParamBST::min_key(&right).unwrap_or(key);
  117|      3|                    ParamBST::join_m(left, min_key, reduced_right)
  149|     28|                    let min_key = ParamBST::min_key(&right).unwrap_or(key);
  151|     28|                    ParamBST::join_m(left, min_key, reduced_right)
  141|      1|        fn min_key_link<'a>(link: &'a Link<K, V>) -> Option<&'a K> {
  214|     20|        fn min_key_link<'a>(link: &'a Link<K, V, R>) -> Option<&'a K> {
  101|      8|        fn min_key(tree: &Self) -> Option<T> {
  133|  1.32k|        fn min_key(tree: &Self) -> Option<T> {
  111|     55|        fn min_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  113|     32|        fn min_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  143|     27|        fn min_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  144|     72|        fn min_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  148|     81|        fn min_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  156|      1|        fn min_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  168|     26|        fn min_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  168|  2.84k|        fn min_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  187|     19|        fn min_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  190|     34|        fn min_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  204|    355|        fn min_link<'a>(link: &'a Link<T>) -> Option<&'a T> {
  218|    153|                min_load_factor: min_load,
  119|     29|    fn min_node<'a, T: StT + Ord>(node: &'a BalBinTree<T>) -> Option<&'a T> {
   45|      5|            let min_prefixes = ArraySeqStEphS::from_vec(min_prefixes_vec);
   48|      5|            let min_prefixes = ArraySeqMtEphS::from_vec(min_prefixes_vec);
   54|       |        /// Min-Priority Queue Search from a single source.
   63|       |        /// Min-Priority Queue Search from multiple sources.
  259|      2|            let min_size = capacity * 2;
  138|      2|                let minus_u = self.NMinus(u);
  298|  10.0k|                    let minus_u = self.NMinus(&u);
   25|  11.3k|    fn mk<T: StTInMtT>(value: T, left: Link<T>, right: Link<T>) -> Arc<Node<T>> {
   25|  1.23M|    fn mk<T: StT>(value: T, left: Link<T>, right: Link<T>) -> Rc<Node<T>> {
   47|     21|        let (m_left, p_left, s_left, t_left) = max_contig_sub_sum_aux(&left);
   53|     21|        let (m_left, p_left, s_left, t_left) = result_pair.0;
    4|       |//!  This module defines a single-threaded primitive tree sequence based on the APAS
    4|       |//! This module implements the bottom-up approach to dynamic programming using
    4|       |//! This module implements the bottom-up approach to dynamic programming using
    4|       |//! This module implements the bottom-up approach to dynamic programming using
    4|       |//! This module implements the bottom-up approach to dynamic programming using
    4|       |//! This module implements the top-down (memoization) approach to dynamic programming
    4|       |//! This module implements the top-down (memoization) approach to dynamic programming
    4|       |//! This module implements the top-down (memoization) approach to dynamic programming
    4|       |//! This module implements the top-down (memoization) approach to dynamic programming
    4|       |//! This module provides weighted directed graphs using `OrderedFloat<f64>` for edge weights,
    4|       |//! This module provides weighted undirected graphs using `OrderedFloat<f64>` for edge weights,
  282|      1|   - Monitor (live + dead) / table_size
  288|      1|   - Monitor clustering effects
   48|     21|        let (m_right, p_right, s_right, t_right) = max_contig_sub_sum_aux(&right);
   54|     21|        let (m_right, p_right, s_right, t_right) = result_pair.1;
  171|      8|            return mst_labels;
  236|      9|            return mst_labels;
  239|     27|            if mst_labels.mem(label) {
  342|     37|            if mst_labels.mem(label) {
   27|       |        fn mst_weight<V: StT + Hash>(mst: &Set<LabEdge<V, OrderedFloat<f64>>>) -> OrderedFloat<f64>;
   31|       |        fn mst_weight<V: StT + Hash>(mst: &Set<LabEdge<V, OrderedFloat<f64>>>) -> OrderedFloat<f64>;
   41|       |        fn mst_weight<V: StT + Hash>(mst: &Set<LabeledEdge<V>>) -> OrderedFloat<f64>;
   50|       |        fn mst_weight<V: StT + Hash>(mst: &Set<LabeledEdge<V>>) -> OrderedFloat<f64>;
   86|       |    // MtFn: Multi-threaded function type with common bounds
   91|       |    // MtFnClone: Multi-threaded function type with Clone
  283|       |    impl<T: MtKey + 'static> ParamBSTTrait<T> for ParamBST<T> {
  339|       |    impl<T: MtKey + 'static> ParamTreapTrait<T> for ParamTreap<T> {
  366|       |    impl<K: MtKey, V: MtVal, F: MtReduceFn<V>> AugOrderedTableMtEph<K, V, F> {
  386|       |    impl<K: MtKey, V: MtVal> Clone for OrderedTableMtEph<K, V> {
  396|       |    impl<K: MtKey, V: MtVal, F: MtReduceFn<V>> Display for AugOrderedTableMtEph<K, V, F> {
  407|       |    impl<K: MtKey, V: MtVal, F: MtReduceFn<V>> Debug for AugOrderedTableMtEph<K, V, F> {
   60|       |    impl<K: MtKey, V: MtVal> TableMtEphTrait<K, V> for TableMtEph<K, V> {
   64|       |    impl<T: MtKey + 'static> ParamTreap<T> {
   74|       |    impl<T: MtKey> OrderedSetMtEphTrait<T> for OrderedSetMtEph<T> {
   76|       |    // MtKey: Multi-threaded key type with ordering and static lifetime
   79|       |    impl<T> MtKey for T where T: StTInMtT + Ord + 'static {}
   81|       |    impl<T: MtKey + 'static> ParamBST<T> {
   86|       |    impl<K: MtKey, V: MtVal> OrderedTableMtEphTrait<K, V> for OrderedTableMtEph<K, V> {
   89|       |    impl<K: MtKey, V: MtVal, F: MtReduceFn<V>> AugOrderedTableMtEphTrait<K, V, F> for AugOrderedTableMtEph<K, V, F> {
  193|      1|        let mt_map_time = start.elapsed();
   96|       |    // MtReduceFn: Multi-threaded reducer function type
  140|       |    impl MtT for usize {
  146|       |    impl MtT for isize {
  152|       |    impl MtT for i32 {
  158|       |    impl MtT for u32 {
  164|       |    impl MtT for i64 {
  170|       |    impl MtT for u64 {
  176|       |    impl MtT for bool {
  182|       |    impl MtT for char {
  189|       |    impl MtT for String {
  196|       |    impl<'a> MtT for &'a str {
   63|       |    // MtT: multi-threaded friendly elements; minimal so it can include Mutex<..>
  175|      1|        let mt_time = start.elapsed();
  100|       |    impl<T: MtVal> MinEditDistMtPerTrait<T> for MinEditDistMtPerS<T> {
  104|       |    impl<T: MtVal> SubsetSumMtEphTrait<T> for SubsetSumMtEphS<T> {
  116|       |    impl<T: MtVal> MinEditDistMtEphTrait<T> for MinEditDistMtEphS<T> {
  131|       |    impl<T: MtVal> OBSTMtPerTrait<T> for OBSTMtPerS<T> {
  138|       |    impl<T: MtVal> PartialEq for SubsetSumMtPerS<T> {
  142|       |    impl<T: MtVal> Eq for SubsetSumMtPerS<T> {}
  143|       |    impl<T: MtVal> OBSTMtEphTrait<T> for OBSTMtEphS<T> {
  144|       |    impl<T: MtVal> Display for SubsetSumMtPerS<T> {
  146|       |    impl<T: MtVal> PartialEq for MinEditDistMtPerS<T> {
  150|       |    impl<T: MtVal> Eq for MinEditDistMtPerS<T> {}
  152|       |    impl<T: MtVal> Display for MinEditDistMtPerS<T> {
  162|       |    impl<T: MtVal> PartialEq for SubsetSumMtEphS<T> {
  166|       |    impl<T: MtVal> Eq for SubsetSumMtEphS<T> {}
  168|       |    impl<T: MtVal> Display for SubsetSumMtEphS<T> {
  185|       |    impl<T: MtVal> PartialEq for MinEditDistMtEphS<T> {
  187|       |    impl<T: MtVal> PartialEq for OBSTMtPerS<T> {
  189|       |    impl<T: MtVal> Eq for MinEditDistMtEphS<T> {}
  191|       |    impl<T: MtVal> Display for MinEditDistMtEphS<T> {
  191|       |    impl<T: MtVal> Eq for OBSTMtPerS<T> {}
  193|       |    impl<T: MtVal> Display for OBSTMtPerS<T> {
  203|       |    impl<T: MtVal> IntoIterator for OBSTMtPerS<T> {
  223|       |    impl<T: MtVal + PartialEq> PartialEq for KeyProb<T> {
  229|       |    impl<T: MtVal> Eq for KeyProb<T> {}
  231|       |    impl<T: MtVal + Display> Display for KeyProb<T> {
  234|       |    impl<T: MtVal> PartialEq for OBSTMtEphS<T> {
  243|       |    impl<T: MtVal> Eq for OBSTMtEphS<T> {}
  245|       |    impl<T: MtVal> Display for OBSTMtEphS<T> {
  259|       |    impl<T: MtVal> IntoIterator for OBSTMtEphS<T> {
  295|       |    impl<T: MtVal + PartialEq> PartialEq for KeyProb<T> {
  301|       |    impl<T: MtVal> Eq for KeyProb<T> {}
  303|       |    impl<T: MtVal + Display> Display for KeyProb<T> {
   43|       |    impl<T: MtVal> SubsetSumMtPerS<T> {
   47|       |    impl<T: MtVal> MinEditDistMtPerS<T> {
   53|       |    impl<T: MtVal> SubsetSumMtEphS<T> {
   54|       |    impl<T: MtVal> OBSTMtPerS<T> {
   63|       |    impl<T: MtVal> MinEditDistMtEphS<T> {
   63|       |    impl<T: MtVal> OBSTMtEphS<T> {
   81|       |    // MtVal: Multi-threaded value type with static lifetime
   84|       |    impl<T> MtVal for T where T: StTInMtT + 'static {}
   94|       |    impl<T: MtVal> SubsetSumMtPerTrait<T> for SubsetSumMtPerS<T> {
  128|      1|        fn mul(self, other: Self) -> Self { Probability(self.0 * other.0) }
   52|     50|        fn multiply_cost(&self, i: usize, k: usize, j: usize) -> usize {
   54|     68|        fn multiply_cost(&self, i: usize, k: usize, j: usize) -> usize {
   63|     63|        fn multiply_cost(&self, i: usize, k: usize, j: usize) -> usize {
   64|      6|        fn multiply_cost(&self, i: usize, k: usize, j: usize) -> usize {
  120|      0|        fn multiset_mut(&mut self) -> &mut ArraySeqStEphS<T> { &mut self.multiset }
  142|      0|        fn multiset_mut(&mut self) -> &mut ArraySeqMtEphS<T> { &mut self.multiset }
   39|       |        fn multiset_mut(&mut self) -> &mut ArraySeqStEphS<T>;
   41|       |        fn multiset_mut(&mut self) -> &mut ArraySeqMtEphS<T>;
  224|      2|        fn multiset_range(&self) -> Vec<(N, T)> {
   82|       |        fn multiset_range(&self) -> Vec<(N, T)>;
  110|      3|        fn multiset(&self) -> &ArraySeqStPerS<T> { &self.multiset }
  118|      4|        fn multiset(&self) -> &ArraySeqStEphS<T> { &self.multiset }
  130|      2|        fn multiset(&self) -> &ArraySeqMtPerS<T> { &self.multiset }
  140|      3|        fn multiset(&self) -> &ArraySeqMtEphS<T> { &self.multiset }
   36|       |        fn multiset(&self) -> &ArraySeqStEphS<T>;
   36|       |        fn multiset(&self) -> &ArraySeqStPerS<T>;
   37|       |        fn multiset(&self) -> &ArraySeqMtPerS<T>;
   38|       |        fn multiset(&self) -> &ArraySeqMtEphS<T>;
   55|       |        /// Multi-source graph search (Exercise 53.3).
  122|      1|        println!("  Multi-threaded: key 20 -> {:?}", table_mt_tab.find(&20));
    2|       |//! Parametric multi-threaded BST built around a joinMid interface.
    2|       |//! Parametric multi-threaded Treap (probabilistically balanced BST) with parallel operations.
   55|      1|        println!("After multi-threaded insert - table size: {}", table_mt.size());
  207|      1|  - Must visit each element exactly once
  100|     13|            let mut new_neighbors = AVLTreeSetMtPer::empty();
  100|      1|            let mut first = true;
  100|    472|            let mut values: Vec<T> = Vec::with_capacity(n);
  100|      5|        let mut vertices = Set::empty();
  100|      7|            let mut visited = AVLTreeSetMtEph::empty();
  101|      0|                let mut right_arcs = arcs;
  101|      1|            let mut out = Vec::with_capacity(self.size());
  101|    232|            let mut min_element = self.elements.nth(0);
  101|     51|        let mut merged = pair.0;
  101|      5|                let mut row = self.predecessors.nth(u).clone();
  102|     19|            let mut solver = self.clone();
  102|      1|            let mut count = 0;
  102|      1|            Self::in_order_collect(&self.root, &mut out);
  102|    232|            let mut min_index = 0;
  102|     47|                    let mut frontier_updated = frontier_new;
  103|     16|            let mut result = Self::empty();
  103|     19|        let mut result = Vec::new();
  103|     26|            let mut solver = self.clone();
  103|     55|            let mut result = <ArraySeqStEphS<T> as ArraySeqStEphTraitChap18<T>>::new(n, f(0));
  103|      7|            let mut frontier = AVLTreeSetMtEph::empty();
  104|     19|                let mut result = SSSPResultStEphFloat::new(n, source);
  104|    235|            let mut neighbors = Set::empty();
  104|      5|        let mut edges = Set::empty();
  105|     10|            let mut t = AVLTreeS::new_root();
  105|     11|            let mut new_adj_vec = Vec::with_capacity(self.adj.length());
  105|      2|            let mut result = Self::empty();
  105|      4|            let mut path = Vec::new();
  106|      0|                let mut right_edges = edges;
  106|     11|            let mut neighbors = Set::empty();
  106|     46|                    let mut values = Vec::with_capacity(total_size);
  106|      4|            let mut current = v;
  106|  5.71k|                let mut result: Set<V> = SetLit![];
  106|      6|        let mut component_map = HashMap::new();
  106|      6|                let mut lt = lo;
  106|      8|            let mut s = HashSet::with_capacity(1);
  107|      0|            let mut out = Vec::with_capacity(self.size());
  107|    167|            let mut head: Option<Box<NodeP<T>>> = None;
  107|      1|                let mut new_neighbors_vec: Vec<N> = Vec::new();
  107|      1|            let mut path = Vec::new();
  107|    231|            let mut result = heap.clone();
  107|     39|            let mut out: Set<V> = SetLit![];
  107|     46|                    Self::collect_values(&Some(node.clone()), &mut values);
  107|    533|                let mut doc_ids = ArraySeqStPerS::empty();
  107|      6|                let mut i = lo;
  108|      0|            Self::pre_order_collect(&self.root, &mut out);
  108|    167|            let mut len = 0usize;
  108|    167|                let mut memo_guard = self.memo.lock().unwrap();
  108|      1|            let mut current = v;
  108|     20|        let mut component = AVLTreeSetStPer::singleton(vertex);
  108|    217|                let mut right_vals = vals;
  108|     23|            let mut row = self.matrix.nth(u).clone();
  108|      5|                        let mut s = SetLit![];
  108|      6|                let mut gt = hi;
  108|      8|            let mut edge_found = false;
  109|      0|        let mut visited = visited;
  109|     32|            let mut probe_sequence = Vec::new();
  109|      5|        let mut vertices = Set::empty();
  110|      1|        let mut keys = ArraySetStEph::empty();
  110|      2|                    let mut neighbors = neighbors.clone();
  110|      2|            let mut values: Vec<U> = Vec::with_capacity(a.length());
  110|     32|            let mut unique_positions = std::collections::HashSet::new();
  111|    117|            let mut values = self.elements.values_in_order();
  111|    120|            let mut values: Vec<T> = Vec::with_capacity(n);
  111|     18|            let mut current = self.head.as_deref_mut();
  111|      1|            let mut data = Vec::with_capacity(length);
  111|     20|        let mut visited = visited;
  111|     32|            let mut period = 0;
  111|     47|                    let mut frontier_updated = frontier_new;
  112|     18|            let mut i = 0usize;
  112|      1|            let mut path = Vec::new();
  112|      1|            let mut result_adj = new_adj;
  112|     23|                let mut new_neighbors = AVLTreeSetStPer::empty();
  112|    431|                let mut smallest = i;
  112|      5|                        let mut s = SetLit![];
  113|      1|            let mut current = v;
  113|    232|            let mut new_elements = ArraySeqStPerS::empty();
  114|      1|            let mut new_matrix_vec = Vec::with_capacity(self.n);
  114|      1|        let mut table = create_linear_probing_string_table(8);
  114|     56|            let mut result = Self::empty();
  115|      1|            let mut path = Vec::new();
  115|     25|        rng: &mut StdRng,
  115|      4|            let mut current = self.head.load(Ordering::Relaxed);
  115|      5|        let mut edges = Set::empty();
  115|     75|                let mut vals = Vec::new();
  115|       |            let mut __seen_keys = std::collections::HashSet::new();
  116|     10|            let mut neighbors = Set::empty();
  116|    111|                let mut lt = 0;
  116|     13|                    let mut priorities = AVLTreeSetStEph::empty();
  116|     13|            let mut table_guard = table.lock().unwrap();
  116|     16|            let mut table_guard = table.lock().unwrap();
  116|      1|            let mut current = v;
  116|     23|                    let mut frontier_updated = frontier_new;
  116|    272|            let mut new_table = ArraySeqStPerS::empty();
  116|     30|                let mut lo = 0;
  116|     62|            let mut result = Self::empty();
  117|    111|                let mut i = 0;
  117|     11|            let mut new_row_vec = Vec::with_capacity(self.n);
  117|    135|                let mut neighbors = Set::empty();
  117|     14|        let mut pq = LeftistHeapPQ::empty();
  117|     30|                let mut hi = n_left;
  117|      3|                let mut new_row_vec = Vec::with_capacity(self.n);
  117|     40|            let mut inn: Set<V> = SetLit![];
  117|    533|                let mut doc_vec = Vec::new();
  117|      5|                    let mut combined = left.into_vec();
  118|    111|                let mut gt = len;
  118|    190|            let mut neighbors = Set::empty();
  118|      1|            let mut path = Vec::new();
  118|     25|        let mut flips: HashMap<V, bool> = HashMap::new();
  118|  5.81k|                    let mut lt = 0;
  119|      1|            let mut current = v;
  119|  44.2k|            let mut out = self.clone();
  119|  5.81k|                    let mut i = 0;
  119|      8|            let mut found_index: Option<N> = None;
  120|    108|                let mut right_edges = edges;
  120|     14|                    let mut ns = ns.clone();
  120|      1|            let mut path = Vec::new();
  120|      1|            let mut path = Vec::new();
  120|      1|            let mut result_bits = bitbox![0; self.universe_size];
  120|    217|                let mut result = left_filtered;
  120|      2|                let mut neighbors = Set::empty();
  120|  5.81k|                    let mut gt = len;
  120|     70|                let mut memo_guard = self.memo.lock().unwrap();
  121|     11|            let mut solver = self.clone();
  121|     14|        let mut result = Vec::new();
  121|      1|            let mut current = v;
  121|      1|            let mut current = v;
  121|      1|            let mut it = self.iter();
  121|      4|        let mut result: Set<Edge<V>> = SetLit![];
  122|     12|                let mut memo_guard = self.memo.lock().unwrap();
  122|     19|        result: &mut SSSPResultStEphInt,
  122|      1|            let mut path = Vec::new();
  122|      4|            let mut intersection_entries = Vec::new();
  122|      5|        let mut vertices = Set::empty();
  122|      8|            let mut visited = Set::empty();
  123|      1|            let mut current = v;
  123|      1|            let mut out = <ArraySeqS<T> as ArraySeq<T>>::new(len, first);
  123|      4|            let mut i = 0;
  123|      8|            let mut stack = Vec::new();
  123|     96|                let mut memo_guard = self.memo.lock().unwrap();
  124|     11|        let mut quotient_edges: Set<Edge<V>> = SetLit![];
  124|      1|            let mut index: N = 1;
  124|      1|            let mut new_neighbors_vec: Vec<N> = Vec::new();
  124|    253|            let mut new_elements = ArraySeqStPerS::empty();
  124|      4|            let mut j = 0;
  124|       |                let mut __s = < $crate::Chap05::SetStEph::SetStEph::Set<_> >::empty();
  125|    108|                let mut values: Vec<W> = Vec::with_capacity(a.length());
  125|     10|            let mut solver = self.clone();
  125|  1.83k|            let mut result = Self::empty();
  125|     19|            let mut attempt = 0;
  125|      1|            let mut edges = Set::empty();
  125|     25|        let mut partition: HashMap<V, (V, OrderedFloat<f64>, usize)> = HashMap::new();
  126|     13|                    let mut priorities = AVLTreeSetMtPer::empty();
  126|      5|        let mut edges = Set::empty();
  126|    674|            let mut node = Box::new(Node::new(values[mid].clone()));
  126|      9|                let mut memo_guard = self.memo.lock().unwrap();
  127|  10.8k|            let mut result = Self::empty();
  127|     11|            let mut new_matrix_vec = Vec::with_capacity(self.n);
  127|     13|            let mut initial_frontier = AVLTreeSetStEph::empty();
  127|      1|                let mut neighbors = Set::empty();
  127|      1|            let mut result: Set<V> = SetLit![];
  127|      2|            let mut first = true;
  127|      2|        let mut shortcut = std::vec::Vec::new();
  127|      6|                let mut out_vec: Vec<T> = Vec::with_capacity(len - 1);
  128|      0|                let mut right_verts = vertices;
  128|     11|        let mut result = Vec::new();
  128|    263|                let mut neighbors = Set::empty();
  128|      2|            let mut current = self.head.as_deref();
  128|      2|        let mut visited: HashSet<V> = HashSet::new();
  128|     60|            let mut current = self.head.as_deref();
  129|      5|            let mut merged = Vec::with_capacity(values1.len() + values2.len());
  129|     60|            let mut skipped = 0usize;
  130|     11|            let mut out = HashSet::with_capacity(self.data.len().min(other.data.len()));
  130|     17|                let mut result: Set<Edge<V>> = SetLit![];
  130|      5|            let mut i = 0;
  130|     61|                let mut memo_guard = self.memo.lock().unwrap();
  131|     19|        result: &mut SSSPResultStEphFloat,
  131|      5|            let mut j = 0;
  131|      7|                    let mut priorities = AVLTreeSetStPer::empty();
  132|      0|            let mut elements = Vec::new();
  132|      0|            let mut new_chain = ArraySeqStPerS::empty();
  132|     10|                let mut memo_guard = self.memo.lock().unwrap();
  132|      1|            let mut items = Vec::new();
  132|      1|            let mut result_bits = bitbox![0; self.universe_size];
  132|     38|            let mut elements = Vec::new();
  133|      0|            let mut was_deleted = false;
  133|      1|            let mut new_adj_vec = Vec::with_capacity(self.adj.length());
  134|    271|                let mut temp_vec = Vec::with_capacity(new_len);
  135|      0|            let mut node = Node::new(key, value, priority, node_reduced);
  135|    105|                let mut memo_guard = self.memo.lock().unwrap();
  135|      1|                let mut neighbors = neighbors.clone();
  135|      3|            let mut result = OrderedTableStEph::empty();
  136|      1|            let mut edges = Set::empty();
  136|      1|            let mut result: Set<V> = SetLit![];
  137|      0|                        let mut s = Set::empty();
  137|      0|                        let mut s = Set::empty();
  137|     20|        rng: &mut StdRng,
  137|     25|        let mut neighbors = SetLit![];
  137|     25|        let mut remaining = SetLit![];
  137|      3|            let mut new_chain = ArraySeqStPerS::empty();
  137|    466|            let mut result = ArraySeqStPerS::empty();
  137|      5|        let mut vertices = Set::empty();
  137|      7|            let mut priorities = AVLTreeSetMtEph::empty();
  138|     10|            let mut result_entries = Vec::new();
  138|     13|            let mut initial_frontier = AVLTreeSetMtPer::empty();
  138|      3|            let mut was_deleted = false;
  139|     10|            let mut i = 0;
  139|     11|                let mut count: N = 0;
  139|    272|            let mut result = FlatHashTable {
  139|      5|            let mut result = ArraySeqStPerS::empty();
  139|     60|            let mut out: Vec<T> = Vec::with_capacity(length);
  140|     10|            let mut j = 0;
  140|     20|        let mut coin_flips: HashMap<V, bool> = HashMap::new();
  140|     20|                let mut guard = self.inner.data.lock().unwrap();
  140|      2|                let mut sv = Vec::with_capacity(self_seq.length());
  140|      5|            let mut data = self.to_vec();
  140|      5|            let mut i = 0;
  140|      5|            let mut left: Vec<T> = Vec::new();
  140|      5|            let mut left: Vec<T> = Vec::new();
  140|     60|            let mut taken = 0usize;
  140|      6|            let mut left: Vec<T> = Vec::new();
  140|      6|            let mut left: Vec<T> = Vec::new();
  140|      6|                let mut r = rng();
  140|      7|            let mut left: Vec<T> = Vec::new();
  140|      7|            let mut left: Vec<T> = Vec::new();
  140|      8|            let mut result = <ArraySeqStEphS<T> as ArraySeqStEphTraitChap18<T>>::new(total_len, first_elem);
  141|      5|            let mut j = 0;
  141|      5|            let mut right: Vec<T> = Vec::new();
  141|      5|            let mut right: Vec<T> = Vec::new();
  141|      6|            let mut right: Vec<T> = Vec::new();
  141|      6|            let mut right: Vec<T> = Vec::new();
  141|      7|            let mut right: Vec<T> = Vec::new();
  141|      7|            let mut right: Vec<T> = Vec::new();
  142|     16|                let mut memo_guard = self.memo.lock().unwrap();
  142|      2|            let mut result = <ArraySeqMtEphS<T> as ArraySeqMtEphTraitChap18<T>>::new(total_len, first_elem);
  142|      5|        let mut edges = Set::empty();
  142|      5|            let mut found = false;
  142|      5|            let mut found = false;
  142|      6|            let mut found = false;
  142|      6|            let mut found = false;
  142|      7|            let mut found = false;
  142|      7|            let mut found = false;
  143|      1|            let mut new_matrix_vec = Vec::with_capacity(self.n);
  143|      2|        let mut shortcut = std::vec::Vec::new();
  143|      6|                let mut lt = lo;
  143|      7|            let mut initial_frontier = AVLTreeSetStPer::empty();
  143|      9|            let mut elements = Vec::new();
  143|       |            let mut __tree = $crate::Chap37::BSTPlainStEph::BSTPlainStEph::BSTPlainStEph::new();
  144|     10|                let mut result: Set<V> = SetLit![];
  144|      1|            let mut result_bits = bitbox![0; self.universe_size];
  144|      2|        let mut visited: HashSet<V> = HashSet::new();
  144|      6|                let mut i = lo;
  145|      2|            let mut first = true;
  145|      2|                let mut ov = Vec::with_capacity(other_seq.length());
  145|      3|            let mut result = self.clone();
  145|      6|                let mut gt = hi;
  146|      0|                let mut right_arcs = arcs;
  146|      0|                let mut right_arcs = arcs;
  146|      2|            let mut current = self.head.as_deref();
  146|      3|                let mut new_row_vec = Vec::with_capacity(self.n);
  147|      0|                        let mut s = Set::empty();
  147|      1|            let mut memo_guard = self.memo.lock().unwrap();
  147|      6|            let mut union_entries = Vec::new();
  148|     11|                    let mut values = Vec::with_capacity(total_size);
  148|  3.87k|            let mut values: Vec<T> = Vec::with_capacity(length);
  148|      6|            let mut i = 0;
  148|       |            let mut __tree = $crate::Chap37::BSTPlainStEph::BSTPlainStEph::BSTPlainStEph::new();
  149|      0|            let mut new_buckets = ArraySeqStPerS::empty();
  149|     11|                    Self::collect_values(&Some(node.clone()), &mut values);
  149|     22|            let mut result = Self::empty();
  149|      3|            let mut result = OrderedTableStEph::empty();
  149|      6|            let mut j = 0;
  150|      0|                        let mut s = Set::empty();
  150|     45|        let mut result = pair.0;
  151|     20|        let mut result = pair.0;
  151|  26.3k|                let mut out: Set<V> = SetLit![];
  152|      1|            let mut memo_guard = self.memo.lock().unwrap();
  152|      1|            let mut result = self.clone();
  152|      1|        let mut total = OrderedFloat(0.0);
  152|     48|            let mut vec_elements = Vec::with_capacity(size);
  153|      1|        let mut table_per = TableStPer::empty();
  153|     20|        let mut remaining = SetLit![];
  154|      0|                        let mut s = Set::empty();
  154|      1|            let mut new_buckets = ArraySeqStPerS::empty();
  154|    208|                let mut rng_local = rng();
  155|    178|                    let mut r = rng();
  155|     17|            let mut roots = std::collections::HashSet::new();
  155|     36|                let mut memo_guard = self.memo_table.lock().unwrap();
  155|      5|        let mut vertices = Set::empty();
  155|       |            let mut __set = < $crate::Chap41::ArraySetStEph::ArraySetStEph::ArraySetStEph<_> as $crate::Chap41::ArraySetStEph::ArraySetStEph::ArraySetStEphTrait<_> >::empty();
  156|      0|                    let mut combined = left.into_vec();
  156|      0|                let mut right_arcs = arcs;
  156|      3|                let mut vals = Vec::new();
  156|      7|            let mut values: Vec<U> = Vec::with_capacity(a.length());
  157|  10.9k|            let mut t = AVLTreeSeqStEphS::new_root();
  157|    208|                let mut lt = 0;
  157|     29|                let mut memo_guard = self.memo_table.lock().unwrap();
  158|     10|        let mut vertices = Set::empty();
  158|    178|                    let mut lt = 0;
  158|    208|                let mut i = 0;
  158|    225|            let mut current = self.head.as_deref();
  158|      3|            let mut handles = Vec::with_capacity(a.length());
  158|    629|            let mut guard = self.root.write().unwrap();
  158|       |                let mut __s = < $crate::Chap05::SetStEph::SetStEph::Set<_> >::empty();
  159|    178|                    let mut i = 0;
  159|      1|        let mut complex_vec = Vec::new();
  159|    208|                let mut gt = len;
  159|     20|            let mut probe_positions = std::collections::HashSet::new();
  159|    225|            let mut i = 0usize;
  159|      5|            let mut out: HashSet<Pair<T, U>> = HashSet::new();
   15|       |        next: *mut Node<T>,
  160|      0|            let mut result = NestedHashTable {
  160|    178|                    let mut gt = len;
  160|      1|            let mut found_index: Option<N> = None;
  160|     20|            let mut current_pos = h1_value;
  160|      2|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  160|      3|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  160|      3|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  160|      3|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  160|      3|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  160|      5|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  160|      5|            let mut entries = Vec::with_capacity(total_len);
  161|      1|            let mut result = Self::empty();
  161|     20|            let mut probe_count = 0;
  161|    229|            let mut probe_index = 0;
  161|      7|            let mut result = seq.clone();
  162|      0|                let mut right_edges = edges;
  162|      1|        let mut table_eph = TableStEph::empty();
  162|      2|            let mut acc = x;
  162|      7|            let mut result = ArraySeqStPerS::empty();
  163|     23|            let mut array_seq = ArraySeqStPerS::empty();
  163|     26|                let mut vec_elements = Vec::with_capacity(size);
  163|      2|            let mut memo_guard = self.memo.lock().unwrap();
  163|      5|        let mut edges = Set::empty();
  163|      7|            let mut current_pq = self.clone();
  164|      3|            let mut result = OrderedTableMtEph::empty();
  165|     10|                let mut memo_guard = self.memo.lock().unwrap();
  165|      1|            let mut result = SeparateChainingHashTable {
  165|      2|            let mut left = self.head.as_deref();
  165|      6|            let mut result = init;
  166|      0|                let mut right_verts = vertices;
  166|     10|        let mut edges = Set::empty();
  166|      2|            let mut right = other.head.as_deref();
  166|   555k|                let mut vec_elements = Vec::with_capacity(size + 1);
  166|  63.0k|            let mut values: Vec<T> = Vec::with_capacity(a.length() + b.length());
  167|     33|        rng: &mut StdRng,
  167|      3|            let mut kept: Vec<T> = Vec::new();
  168|    263|            let mut node = Box::new(Node::new(values[mid].clone()));
  168|      4|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  168|      4|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  168|      4|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  168|      4|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  168|      5|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  168|      6|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  168|      6|        let mut neighbors = SetLit![];
  169|      0|                        let mut s = SetLit![];
  169|      1|                let mut out_vec: Vec<T> = Vec::with_capacity(len - 1);
  169|     68|                let mut neighbors = Set::empty();
  169|      6|            let mut all_entries = Vec::new();
  169|      9|                let mut memo_guard = self.memo.lock().unwrap();
  169|      9|        let mut total = OrderedFloat(0.0);
   16|       |//! let mut graph = WeightedDirGraphStEphFloat::empty();
   16|       |//! let mut graph = WeightedUnDirGraphStEphFloat::empty();
  170|    108|                let mut right_self = self_vals;
  170|      1|            let mut map = HashMap::new();
  170|      1|            let mut memo_guard = self.memo.lock().unwrap();
  171|      1|        let mut table_mt = TableMtEph::empty();
  171|      2|        let mut total = OrderedFloat(0.0);
  171|     34|        let mut left_vec: std::vec::Vec<Edge<V>> = pair.0.iter().cloned().collect();
  172|  37.6k|                let mut vec_elements = Vec::with_capacity(size + 1);
  173|      4|            let mut vals: Vec<T> = Vec::with_capacity(e - s);
  174|      1|            let mut first = true;
  175|      1|            let mut current = self.head.as_deref();
  175|      1|            let mut memo_guard = self.memo.lock().unwrap();
  176|      1|            let mut out = Vec::with_capacity(self.size());
  176|     23|            let mut s = HashSet::with_capacity(v.len());
  176|      2|            let mut keep_results = <ArraySeqMtEphS<B> as ArraySeqMtEphTraitChap18<B>>::new(a.length(), false);
  176|       |            let mut __set = < $crate::Chap41::ArraySetEnumMtEph::ArraySetEnumMtEph::ArraySetEnumMtEph as $crate::Chap41::ArraySetEnumMtEph::ArraySetEnumMtEph::ArraySetEnumMtEphTrait >::empty($u);
  177|  1.08k|            let mut values: Vec<T> = Vec::new();
  177|      1|            Self::in_order_collect(&self.root, &mut out);
  177|     20|            let mut values: Vec<T> = Vec::with_capacity(n);
  177|      3|            let mut acc = x;
  178|      0|                let mut right_arcs = arcs;
  178|     89|            let mut pattern = String::new();
  179|     38|        let mut result = pair.0;
  179|     89|            let mut consecutive_count = 1;
  179|       |                let mut __s = < $crate::Chap05::SetStEph::SetStEph::Set<_> >::empty();
  180|      8|                let mut memo_guard = self.memo.lock().unwrap();
  181|     25|        let mut new_mst_labels = mst_labels.clone();
  181|      3|            let mut result = Self::empty();
  181|      5|            let mut data = self.to_vec();
  182|    108|                let mut result = left_intersect;
  182|      1|            let mut out = Vec::with_capacity(self.size());
  182|     96|            let mut elements = Vec::new();
  182|       |                let mut edges = $crate::Chap05::SetStEph::SetStEph::Set::empty();
  183|      1|            Self::pre_order_collect(&self.root, &mut out);
  183|      2|            let mut result_map = HashMap::new();
  184|      0|            let mut new_table = Self::create_table(actual_new_size);
  184|     28|                    let mut result = HashMap::new();
  186|      2|            let mut words = ArraySeqStPerS::empty();
  186|      6|            let mut result = init;
  186|      8|                let mut memo_guard = self.memo.lock().unwrap();
  187|     25|        let mut full_partition: HashMap<V, V> = HashMap::new();
  187|      2|            let mut acc = id.clone();
  187|      5|        let mut vertices = Set::empty();
  188|      0|            let mut s = HashSet::with_capacity(1);
  188|    229|            let mut values: Vec<T> = Vec::new();
  188|     22|            let mut probe_index = 0;
  188|      2|            let mut results = Vec::with_capacity(a.length());
  188|     31|            let mut it = AVLTreeSeqIterStEph {
  188|      6|        let mut neighbors = SetLit![];
  188|      9|            let mut new_table =
  189|      0|                        let mut s = Set::empty();
  189|  1.03k|            let mut guard = self.root.write().unwrap();
  189|      1|            let mut out = Vec::with_capacity(self.length());
  189|     20|            let mut probe_sequences = std::collections::HashSet::new();
  190|      0|            let mut memo_guard = self.memo_table.lock().unwrap();
  190|  1.03k|            let mut rng = rng();
  190|     10|        let mut vertices = Set::empty();
  190|      1|            let mut vals = Vec::with_capacity((e - s) as usize);
  190|      1|            push_inorder(&self.root, &mut out);
  190|      2|            let mut kept_count = 0;
  190|      4|            let mut difference_entries = Vec::new();
  191|     21|            let mut vals: Vec<T> = Vec::with_capacity(e - s);
  191|      2|            let mut handles = Vec::with_capacity(a.length());
  191|      4|            let mut i = 0;
  192|      1|            let mut first = true;
  192|      4|            let mut j = 0;
  192|      5|        let mut reweighted_edges = Set::empty();
  193|      1|            let mut current = self.head.as_deref();
  193|    361|            let mut values: Vec<T> = Vec::with_capacity(length);
  193|      6|            let mut out = Vec::with_capacity(self.size());
  193|    912|            let mut guard = self.root.write().unwrap();
  194|      1|                let mut dimensions_guard = self.dimensions.lock().unwrap();
  194|    301|                let mut sequence = Vec::new();
  194|      6|            ParamBST::collect_in_order(self, &mut out);
  194|       |            let mut __tree = < $crate::Chap37::BSTSplayStEph::BSTSplayStEph::BSTSplayStEph<_> as $crate::Chap37::BSTSplayStEph::BSTSplayStEph::BSTSplayStEphTrait<_> >::new();
  195|     10|                    let mut result = left.to_vec();
  195|     10|        let mut reweighted_edges = Set::empty();
  195|    116|            let mut elements = Vec::new();
  195|     16|            let mut result_entries = Vec::new();
  195|      2|        let mut set_delete = ArraySetStEphLit![1, 2, 3, 4, 5];
  196|    118|            let mut r = rng();
  196|     16|            let mut i = 0;
  196|    191|            let mut cursor = link;
  196|     25|        let mut new_edges = SetLit![];
  196|      2|            let mut acc = x;
  196|  4.61k|            let mut values: Vec<T> = Vec::with_capacity(n);
  197|     16|            let mut j = 0;
  197|      8|        let mut result = HashMap::new();
  198|      0|                let mut right_arcs = arcs;
  198|      1|            let mut memo_guard = self.memo.lock().unwrap();
  198|    328|            let mut r = rng();
  199|     13|            let mut result = a.clone();
  199|      2|            let mut values = self.elements.values_in_order();
  199|     75|            let mut out = Vec::with_capacity(Self::size_link(&*guard));
  200|     13|            let mut updated: HashSet<N> = HashSet::new();
  200|      1|                let mut keys_guard = self.keys.lock().unwrap();
  200|      1|            let mut values: Vec<T> = Vec::with_capacity(length);
  200|      2|            let mut results = Vec::with_capacity(a.length());
  200|      2|            let mut right_elements_filtered = right_elements;
  200|     75|            Self::in_order_collect(&*guard, &mut out);
  201|      0|            let mut out = self.clone();
  201|  31.7k|                let mut inn: Set<V> = SetLit![];
  201|      3|            let mut values: Vec<U> = Vec::with_capacity(a.length());
  201|    436|            let mut new_data: Vec<T> = self.data.iter().cloned().collect();
  202|      0|            let mut result = self.clone();
  202|      2|            let mut first_kept = None;
  202|    676|            let mut out = Vec::new();
  202|       |            let mut pq = $crate::Chap45::UnsortedListPQ::UnsortedListPQ::UnsortedListPQ::empty();
  203|     17|                            let mut new_table = ArraySeqStPerS::empty();
  203|    676|            inorder_collect(&self.root, &mut out);
  204|      1|            let mut memo_guard = self.memo.lock().unwrap();
  204|    269|        let mut words = ArraySeqStPerS::empty();
  204|    563|            let mut out = Vec::with_capacity(self.length());
  205|    121|                let mut vals = self.elements.values_in_order();
  205|      1|                let mut dimensions_guard = self.dimensions.lock().unwrap();
  205|      2|            let mut acc = id.clone();
  205|      2|        let mut set_insert = ArraySetStEphLit![1, 2, 4, 5];
  205|    563|            inorder_collect(&self.root, &mut out);
  206|      1|            let mut out = Vec::with_capacity(Self::size_link(&*guard));
  206|     90|            let mut values = Vec::new();
  207|      0|            let mut new_chain = ArraySeqStPerS::empty();
  207|      1|            Self::pre_order_collect(&*guard, &mut out);
  207|      2|            let mut result_seq = <ArraySeqStEphS<T> as ArraySeqStEphTraitChap18<T>>::new(a.length(), acc.clone());
  207|     50|        let mut merged = pair.0;
  207|     82|            let mut values: Vec<T> = Vec::with_capacity(n);
  207|     90|            traverse(&self.root, &mut values);
  208|      0|            let mut key_existed = false;
  208|    129|            let mut new_chain = ArraySeqStPerS::empty();
  208|      1|        let mut total_words = 0;
  208|     20|                    let mut new_data: Vec<T> = result.data.iter().cloned().collect();
  208|    269|        let mut current_word = String::new();
  209|    129|            let mut key_existed = false;
  209|      1|            let mut memo_guard = self.memo.lock().unwrap();
  209|      1|            let mut values: Vec<U> = Vec::with_capacity(len);
  209|      6|                let mut sv = Vec::with_capacity(self_seq.length());
  210|      0|            let mut result_vec = Vec::with_capacity(a.length());
  210|      1|                let mut keys_guard = self.keys.lock().unwrap();
  210|      2|            let mut out = Vec::with_capacity(self.size);
  211|      0|            let mut acc = x;
  211|      1|            let mut result = self.clone();
  211|      2|            let mut result = <ArraySeqMtEphS<T> as ArraySeqMtEphTraitChap18<T>>::new(kept_count, first_kept);
  211|      2|            Self::collect_keys(&self.root, &mut out);
  211|      5|            let mut out = Vec::with_capacity(self.size());
  212|      0|            let mut out = HashSet::with_capacity(self.data.len().min(other.data.len()));
  212|    130|            let mut values: Vec<T> = Vec::with_capacity(total);
  212|     15|            let mut left = self.head.as_deref();
  212|      2|            let mut result_idx = 1;
  212|      5|            Self::in_order_collect(&self.root, &mut out);
  213|     15|            let mut right = other.head.as_deref();
  213|  1.91k|            let mut guard = self.root.write().unwrap();
  213|      1|            let mut memo_guard = self.memo_table.lock().unwrap();
  214|     17|                            let mut result = FlatHashTable {
  214|      1|            let mut memo_guard = self.memo.lock().unwrap();
  214|      2|            let mut seen: HashSet<T> = HashSet::with_capacity(self.data.len());
  214|      6|                let mut ov = Vec::with_capacity(other_seq.length());
  215|      2|            let mut keep_results = Vec::with_capacity(a.length());
  215|      2|            let mut out: Vec<T> = Vec::with_capacity(self.data.len());
  216|      0|            let mut roots = std::collections::HashSet::new();
  216|     13|            let mut t = AVLTreeS::new_root();
  216|      1|            let mut out = Vec::with_capacity(self.size);
  216|       |            let mut __set = < $crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::AVLTreeSetStPer<_> as $crate::Chap41::AVLTreeSetStPer::AVLTreeSetStPer::AVLTreeSetStPerTrait<_> >::empty();
  217|      1|            Self::collect_values(&self.root, &mut out);
  217|      4|            let mut mapped_entries = Vec::with_capacity(len);
  217|      4|            let mut out = Vec::with_capacity(self.size());
  218|      4|            Self::pre_order_collect(&self.root, &mut out);
  219|      0|                        let mut s = SetLit![];
  219|      1|            let mut memo_guard = self.memo.lock().unwrap();
  220|      2|            let mut pq = Self::empty();
  221|      0|                let mut count: N = 0;
  221|       |            let mut __set = < $crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::AVLTreeSetStEph<_> as $crate::Chap41::AVLTreeSetStEph::AVLTreeSetStEph::AVLTreeSetStEphTrait<_> >::empty();
  223|      1|            let mut values: Vec<T> = Vec::with_capacity(total);
  223|     58|            let mut kept: Vec<T> = Vec::new();
  224|      0|            let mut new_buckets = ArraySeqStPerS::empty();
  224|    149|            let mut elements = Vec::new();
  224|      1|            let mut memo_guard = self.memo.lock().unwrap();
  224|      6|            let mut merged = self_vals;
  225|    129|            let mut new_buckets = ArraySeqStPerS::empty();
  225|  2.44k|            let mut left = 0;
  225|      2|            let mut counts: HashMap<T, N> = HashMap::with_capacity(self.data.len());
  226|  2.44k|            let mut right = self.entries.length();
  226|      2|            let mut acc = x;
  226|      2|            let mut order: Vec<T> = Vec::new();
  227|      2|            let mut kept_values = Vec::new();
  227|      3|            let mut groups: Vec<Pair<K, ArraySeqStPerS<V>>> = Vec::new();
   22|      7|        let mut visited = ArraySeqStEphS::tabulate(&|_| false, n);
   22|      7|        let mut visited = ArraySeqStEphS::tabulate(&|_| false, n);
   22|      7|        let mut visited = AVLTreeSetStPer::empty();
   22|  8.00k|            let mut current = self.load(Ordering::Relaxed);
  228|      0|                let mut right_arcs = arcs;
  228|      8|        let mut rng = StdRng::seed_from_u64(seed);
  229|      0|            let mut map = HashMap::new();
  229|      3|            let mut result = Vec::new();
  229|       |            let mut __tree = < $crate::Chap39::BSTTreapStEph::BSTTreapStEph::BSTTreapStEph<_> as $crate::Chap39::BSTTreapStEph::BSTTreapStEph::BSTTreapStEphTrait<_> >::new();
  230|    214|            let mut new_elements = ArraySeqStPerS::singleton(last_element);
  230|  4.02k|            let mut left = 0;
  230|      9|                let mut found_group = false;
  231|      0|            let mut new_elements = ArraySeqStPerS::empty();
  231|  4.02k|            let mut right = self.entries.length();
  232|    100|            let mut out = Vec::with_capacity(Self::size_link(&*guard));
  232|     29|        rng: &mut StdRng,
   23|      2|            let mut buckets = ArraySeqStPerS::empty();
  232|       |                let mut edges = $crate::Chap05::SetStEph::SetStEph::Set::empty();
  232|       |            let mut __tree = < $crate::Chap40::BSTKeyValueStEph::BSTKeyValueStEph::BSTKeyValueStEph<_, _> as $crate::Chap40::BSTKeyValueStEph::BSTKeyValueStEph::BSTKeyValueStEphTrait<_, _> >::new();
  233|      0|        let mut x = y.left.take().expect("rotate_right requires left child");
  233|    100|            Self::in_order_collect(&*guard, &mut out);
  233|      3|                        let mut values: Vec<V> = (0..group.1.length()).map(|j| group.1.nth(j).clone()).collect();
  233|      8|            let mut out = Vec::with_capacity(self.size());
  234|     12|            let mut values: Vec<T> = Vec::new();
  234|      1|            let mut kept: Vec<T> = Vec::new();
  234|    493|            let mut left = 0;
  234|      8|            Self::in_order_collect(&self.root, &mut out);
  235|    493|            let mut right = n;
  236|      4|        let mut result = Vec::with_capacity(size);
  237|      2|            let mut vals: Vec<T> = Vec::with_capacity(e - s);
  237|      4|        let mut x: i64 = 1;
  237|      7|        let mut total = OrderedFloat(0.0);
   23|      7|        let mut rec_stack = ArraySeqStEphS::tabulate(&|_| false, n);
   23|      7|        let mut visited = AVLTreeSetStPer::empty();
  238|     24|            let mut inner = self.inner.lock().unwrap();
  239|      0|            let mut out = Vec::with_capacity(Self::size_link(&*guard));
  239|      3|            let mut out = Vec::with_capacity(self.size());
  239|      3|            let mut result = Vec::new();
  239|      3|            let mut values = self.elements.values_in_order();
  239|     75|            let mut out = Vec::with_capacity(Self::size_link(&*guard));
  240|      0|            Self::pre_order_collect(&*guard, &mut out);
  240|  2.00k|            let mut values: Vec<T> = Vec::with_capacity(na + nb);
  240|     20|            let mut count = 0;
  240|      3|            Self::pre_order_collect(&self.root, &mut out);
  240|     75|            Self::in_order_collect(&*guard, &mut out);
  241|      0|            let mut out: HashSet<Pair<T, U>> = HashSet::new();
  241|     14|            let mut performance_ranking = vec![
  241|    150|            let mut values: Vec<T> = Vec::with_capacity(a.length() + b.length());
  241|      1|            let mut result = base.clone();
  242|      0|            let mut result_map = HashMap::new();
  243|    845|            let mut inner = self.inner.lock().unwrap();
  243|       |                let mut __s = < $crate::Chap05::SetStEph::SetStEph::Set<_> >::empty();
  244|  17.6M|        let mut y = x.right.take().expect("rotate_left requires right child");
  244|      1|    let mut probe_index = 0;
  244|     25|            let mut new_table = Self::create_table(self.probe_sequence.clone(), actual_new_size);
  244|      3|            let mut left_entries = Vec::new();
  244|      4|            let mut values: Vec<T> = Vec::with_capacity(n);
  245|      1|            let mut values = self.values_vec();
  245|      1|            let mut values: Vec<T> = Vec::new();
  245|      2|            let mut acc = id.clone();
  245|      3|            let mut right_entries = Vec::new();
  246|      2|            let mut out = Vec::with_capacity(Self::size_link(&*guard));
  246|      2|            let mut results = Vec::with_capacity(a.length());
  246|      3|            let mut found_value = None;
  247|      2|            Self::pre_order_collect(&*guard, &mut out);
   24|      7|        let mut rec_stack = AVLTreeSetStPer::empty();
   24|      7|        let mut result = Vec::new();
  248|     20|        let mut new_mst_labels = mst_labels.clone();
  248|      3|            let mut acc = seed;
  248|      6|            let mut count = 0;
  248|     78|            let mut out = Vec::with_capacity(Self::size_link(&*guard));
  249|  24.9k|            let mut guard = self.root.write().unwrap();
  249|     78|            Self::in_order_collect(&*guard, &mut out);
   25|  10.0k|                let mut j = i;
  251|      1|            let mut kept: Vec<T> = Vec::new();
  251|  5.01k|                let mut result: Set<V> = SetLit![];
  251|       |            let mut __tree = < $crate::Chap37::BSTAVLStEph::BSTAVLStEph::BSTAVLStEph<_> as $crate::Chap37::BSTAVLStEph::BSTAVLStEph::BSTAVLStEphTrait<_> >::new();
  252|      2|            let mut values: Vec<T> = Vec::new();
  252|      3|                let mut left_filtered = Vec::new();
  252|      3|            let mut values: Vec<U> = Vec::with_capacity(a.length());
  253|  1.05k|            let mut r = rng();
  253|      1|            let mut merged: BTreeSet<T> = self.values_vec().into_iter().collect();
  254|    105|                    let mut result = Op::identity();
  254|     20|        let mut full_partition: HashMap<V, V> = HashMap::new();
  254|     29|            let mut sequence = Vec::new();
  254|      9|            let mut total_collisions = 0;
  255|      0|            let mut out = Vec::with_capacity(self.size());
  255|      1|            let mut out = Vec::with_capacity(Self::size_link(&*guard));
  255|     20|                let mut updated_entries = Vec::with_capacity(filtered.length() + 1);
  255|     29|            let mut current_pos = h1_value;
  255|      9|            let mut max_chain_length = 0;
  256|      0|            Self::in_order_collect(&self.root, &mut out);
  256|      1|            Self::pre_order_collect(&*guard, &mut out);
  256|      3|            let mut values: Vec<T> = (0..a.length()).map(|i| a.nth(i).clone()).collect();
  256|      9|            let mut non_empty_buckets = 0;
  257|      2|        let mut probe_sequences = Vec::new();
  257|      3|            let mut left_entries = Vec::new();
  257|      6|            let mut out = Vec::with_capacity(self.size());
  257|      9|            let mut total_chain_length = 0;
   25|      7|        let mut result = Vec::new();
   25|      7|        let mut visited = AVLTreeSetStPer::empty();
  258|      0|            let mut s = HashSet::with_capacity(v.len());
  258|      3|            let mut groups: Vec<Pair<K, Vec<V>>> = Vec::new();
  258|      3|            let mut right_entries = Vec::new();
  258|      6|            Self::in_order_collect(&self.root, &mut out);
  258|    973|                let mut insert_pos = updated.entries.length();
  259|    157|            let mut probe_index = 0;
  259|    216|            let mut vals = self.elements.values_in_order();
  259|      3|            let mut _found_value: Option<V> = None;
  260|      2|            let mut range_values = Vec::new();
  260|      4|            let mut values: Vec<T> = Vec::with_capacity(a.length() + b.length());
  260|       |            let mut docs = $crate::Chap19::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS::empty();
   26|      0|        let mut v: Vec<Pair<N, N>> = Vec::with_capacity(len);
  261|      0|            let mut out = Vec::with_capacity(self.size());
  261|      0|            let mut total_collisions = 0;
  261|    157|            let mut insertion_pos = None;
  262|      0|            let mut max_chain_length = 0;
  262|      0|            Self::pre_order_collect(&self.root, &mut out);
  262|      2|            let mut acc = id.clone();
   26|     23|            let mut edge_set = Set::empty();
  262|      3|            let mut right_filtered = Vec::new();
  263|      0|            let mut non_empty_buckets = 0;
  263|      2|            let mut out = Vec::with_capacity(self.size());
  264|      0|            let mut total_chain_length = 0;
  264|  1.98k|                let mut new_entries = Vec::with_capacity(self.entries.length() + 1);
  264|      2|            Self::pre_order_collect(&self.root, &mut out);
  264|      3|            let mut values: Vec<T> = (0..a.length()).map(|i| a.nth(i).clone()).collect();
  265|      1|            let mut seen: HashSet<N> = HashSet::new();
  265|      2|            let mut result_seq = <ArraySeqMtEphS<T> as ArraySeqMtEphTraitChap18<T>>::new(a.length(), acc.clone());
   26|      5|        let mut visited = ArraySeqStEphS::tabulate(&|_| false, n);
  266|      1|            let mut out = Vec::with_capacity(self.size());
   26|     65|            let mut edge_set = Set::empty();
   26|      6|                let mut ancestors = AVLTreeSetStEph::empty();
  267|     18|            let mut new_data: Vec<T> = a.data.iter().cloned().collect();
  267|      1|            Self::in_order_collect(&self.root, &mut out);
   26|      7|        let mut components = AVLTreeSeqStPerS::empty();
   26|      7|        let mut visited = ArraySeqStEphS::tabulate(&|_| false, n);
  268|      1|            let mut out = a.clone();
  268|       |            let mut pq = $crate::Chap45::SortedListPQ::SortedListPQ::SortedListPQ::empty();
  269|      1|            let mut seen: HashSet<N> = HashSet::new();
  270|      1|            _values_with_change_number: &mut ArraySeqMtPerS<Pair<T, N>>,
  270|       |                let mut set = $crate::Chap43::OrderedSetMtEph::OrderedSetMtEph::OrderedSetMtEph::empty();
   27|      0|        let mut v: Vec<Pair<N, Pair<N, N>>> = Vec::with_capacity(len);
  271|      0|            let mut first = true;
  271|     16|            let mut heaps: Vec<Self> = seq.iter().map(|x| Self::singleton(x.clone())).collect();
  271|      8|            let mut acc = id.clone();
  272|      3|            let mut values: Vec<T> = Vec::with_capacity(n);
  272|      8|            let mut values: Vec<T> = Vec::with_capacity(a.length());
  272|       |            let mut __s = < $crate::Chap05::SetStEph::SetStEph::Set<_> >::empty();
  273|      0|                let mut right_verts = vertices;
  273|      3|            let mut filtered_entries = Vec::with_capacity(left_filtered.len() + right_filtered.len());
  273|      4|            let mut result = a.clone();
  273|       |            let mut __set = < $crate::Chap37::BSTSetAVLMtEph::BSTSetAVLMtEph::BSTSetAVLMtEph<_> as $crate::Chap37::BSTSetAVLMtEph::BSTSetAVLMtEph::BSTSetAVLMtEphTrait<_> >::empty();
  273|       |            let mut __set = < $crate::Chap37::BSTSetBBAlphaMtEph::BSTSetBBAlphaMtEph::BSTSetBBAlphaMtEph<_> as $crate::Chap37::BSTSetBBAlphaMtEph::BSTSetBBAlphaMtEph::BSTSetBBAlphaMtEphTrait<_> >::empty();
  273|       |            let mut __set = < $crate::Chap37::BSTSetRBMtEph::BSTSetRBMtEph::BSTSetRBMtEph<_> as $crate::Chap37::BSTSetRBMtEph::BSTSetRBMtEph::BSTSetRBMtEphTrait<_> >::empty();
  273|       |            let mut __set = < $crate::Chap37::BSTSetSplayMtEph::BSTSetSplayMtEph::BSTSetSplayMtEph<_> as $crate::Chap37::BSTSetSplayMtEph::BSTSetSplayMtEph::BSTSetSplayMtEphTrait<_> >::empty();
  273|       |            let mut __set = < $crate::Chap39::BSTSetTreapMtEph::BSTSetTreapMtEph::BSTSetTreapMtEph<_> as $crate::Chap39::BSTSetTreapMtEph::BSTSetTreapMtEph::BSTSetTreapMtEphTrait<_> >::empty();
  273|       |            let mut __tree = < $crate::Chap37::BSTBBAlphaStEph::BSTBBAlphaStEph::BSTBBAlphaStEph<_> as $crate::Chap37::BSTBBAlphaStEph::BSTBBAlphaStEph::BSTBBAlphaStEphTrait<_> >::new();
  274|      2|            let mut result = Vec::with_capacity(total_len);
  275|      9|                let mut next_level = Vec::new();
   27|      5|        let mut result = AVLTreeSetStEph::empty();
  275|       |            let mut __tree = < $crate::Chap37::BSTRBStEph::BSTRBStEph::BSTRBStEph<_> as $crate::Chap37::BSTRBStEph::BSTRBStEph::BSTRBStEphTrait<_> >::new();
  276|      1|            let mut result = self.clone();
  276|      9|            let mut range_entries = Vec::new();
  277|      4|            let mut acc = seed;
   27|      7|        let mut components: AVLTreeSeqStEphS<AVLTreeSetStEph<N>> = AVLTreeSeqStEphS::empty();
  280|      3|            let mut values: Vec<U> = Vec::with_capacity(a.length());
  282|      1|            let mut left_elements = Vec::new();
  283|      1|            let mut groups: Vec<Pair<K, Vec<V>>> = Vec::new();
  283|      1|            let mut right_elements = Vec::new();
   28|     36|            let mut values: Vec<T> = Vec::with_capacity(length);
  284|      2|            let mut acc = x;
  284|      3|            let mut values: Vec<T> = Vec::new();
  285|  2.58k|                let mut insert_pos = self.entries.length();
  285|      2|            let mut kept: Vec<T> = Vec::new();
  285|      7|            let mut acc = id;
  285|      7|            let mut result = a.clone();
   28|      5|        dfs_recursive(graph, &mut visited, &mut result, source);
  286|      0|            let mut pq = Self::empty();
  286|      3|            let mut left_entries = Vec::new();
  286|      3|            let mut result = ArraySeqStPerS::empty();
  287|     10|            let mut range_entries = Vec::new();
  287|      3|            let mut current_heap = self.clone();
  287|      3|            let mut right_entries = Vec::new();
  287|      4|            let mut intersection_entries = Vec::new();
  288|      3|            let mut _found_value = None;
  288|      4|            let mut i = 0;
  289|     33|                    let mut new_data: Vec<T> = result.data.iter().cloned().collect();
  289|      4|            let mut j = 0;
  289|      9|            let mut found = false;
  290|    157|            let mut new_table = ArraySeqStPerS::empty();
  290|      3|            let mut values: Vec<T> = Vec::with_capacity(a.length() + b.length());
  291|      2|        let mut probe_sequences = Vec::new();
   29|      1|        let mut table_eph = TableStEphLit![1 => "Alice".to_string(), 2 => "Bob".to_string(), 3 => "Carol".to_string()];
  292|      4|            let mut it = AVLTreeSeqIter {
  293|    358|            let mut out = Vec::with_capacity(Self::size_link(&*guard));
  293|      4|            let mut prefixes: Vec<T> = Vec::with_capacity(a.length());
  293|      8|            let mut count = 0;
  294|    358|            Self::in_order_collect(&*guard, &mut out);
  294|      4|            let mut acc = id.clone();
  294|      5|        let mut table = SeparateChainingHashTable::create_table(DefaultKeyEquality, StringPositionHashFunction, 5);
  295|      0|            let mut result = Vec::new();
  295|      1|            let mut left: Vec<T> = Vec::new();
   29|      5|            let mut all_prefixes_vec = Vec::with_capacity(n + 1);
  295|       |            let mut __set = < $crate::Chap41::AVLTreeSetMtEph::AVLTreeSetMtEph::AVLTreeSetMtEph<_> as $crate::Chap41::AVLTreeSetMtEph::AVLTreeSetMtEph::AVLTreeSetMtEphTrait<_> >::empty();
  296|      1|            let mut acc = x;
  296|      1|            let mut right: Vec<T> = Vec::new();
  296|      2|            let mut values: Vec<T> = Vec::with_capacity(a.length());
  296|  5.01k|                let mut result: Set<V> = SetLit![];
  297|      1|            let mut found = false;
  297|      1|            let mut values: Vec<A> = Vec::with_capacity(a.length());
  298|      1|            let mut groups: Vec<Pair<T, ArraySeqMtEphS<T>>> = Vec::new();
  299|       |            let mut pq = $crate::Chap45::BalancedTreePQ::BalancedTreePQ::BalancedTreePQ::empty();
  299|       |            let mut __tree = < $crate::Chap40::BSTSizeStEph::BSTSizeStEph::BSTSizeStEph<_> as $crate::Chap40::BSTSizeStEph::BSTSizeStEph::BSTSizeStEphTrait<_> >::new();
  300|      1|            let mut acc = seed;
  300|      1|            let mut out = Vec::with_capacity(Self::size_link(&*guard));
  301|     13|            let mut cursor = link;
  301|      1|            Self::pre_order_collect(&*guard, &mut out);
   30|     13|            let mut edge_set = Set::empty();
  301|      3|                let mut found_group = false;
  301|      3|            let mut kept: Vec<T> = Vec::new();
   30|     16|            let mut edge_set = Set::empty();
   30|     16|        let mut min_prefix = 0;
   30|      1|        let mut table_mt = TableMtEphLit![1 => "Alice".to_string(), 2 => "Bob".to_string(), 3 => "Carol".to_string()];
  302|    202|            let mut r = rng();
  302|      2|            let mut result = Vec::new();
  303|      2|            let mut current_heap = self.clone();
  303|       |            let mut entries = vec![$($crate::Types::Types::Pair($key, $value)),+];
  304|     11|            let mut count = 0;
  304|      1|                        let mut values: Vec<T> = Vec::with_capacity(group.1.length() + 1);
  304|      6|            let mut found = false;
   30|      5|        let mut distances = ArraySeqStEphS::tabulate(&|_| UNREACHABLE, n);
   30|      5|        let mut distances = ArraySeqStPerS::tabulate(&|_| UNREACHABLE, n);
  306|     51|        let mut left_result = pair.0;
   30|     72|            let mut left_count = 0;
   30|     72|            let mut left_count = 0;
  307|     51|        let mut right_result = pair.1;
   30|      7|            let mut edge_set = Set::empty();
   30|      7|            let mut edge_set = Set::empty();
  308|      1|            let mut acc = id;
   30|     83|            let mut left_count = 0;
  309|     11|            let mut values: Vec<T> = (0..a.length()).map(|i| a.nth(i).clone()).collect();
  309|      1|        let mut output = String::new();
  309|      4|            let mut candidate = if n % 2 == 0 { n + 1 } else { n };
  310|      3|            let mut seen = std::collections::HashSet::new();
   31|     16|        let mut running_sum = 0;
  311|       |            let mut __set = < $crate::Chap41::AVLTreeSetMtPer::AVLTreeSetMtPer::AVLTreeSetMtPer<_> as $crate::Chap41::AVLTreeSetMtPer::AVLTreeSetMtPer::AVLTreeSetMtPerTrait<_> >::empty();
  313|      4|            let mut out = Vec::with_capacity(self.size());
  314|      4|            Self::collect_keys(&self.root, &mut out);
  314|      6|            let mut union_entries = Vec::new();
  315|      1|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  315|      2|            let mut result = ArraySeqStPerS::empty();
  315|      6|            let mut i = 0;
   31|      5|        let mut distances = ArraySeqMtEphS::tabulate(&|_| UNREACHABLE, n);
   31|      5|        let mut distances = ArraySeqMtPerS::tabulate(&|_| UNREACHABLE, n);
   31|      5|            let mut running_sum = 0;
  316|      6|            let mut j = 0;
  317|  1.62k|            let mut guard = self.root.write().unwrap();
  317|      1|            let mut pq = Self::empty();
  317|      1|            let mut prefixes: Vec<T> = Vec::with_capacity(len);
  317|     25|            let mut range_entries = Vec::new();
   31|     72|            let mut right_count = 0;
   31|     72|            let mut right_count = 0;
  318|      0|                let mut right_verts = vertices;
  318|      1|            let mut acc = id;
   31|     83|            let mut right_count = 0;
  319|      4|            let mut out = Vec::with_capacity(self.size());
  320|      4|            Self::collect_values(&self.root, &mut out);
   32|     12|                let mut component = AVLTreeSetStEph::empty();
  321|      3|            let mut values: Vec<T> = Vec::new();
   32|     16|        let mut min_prefix = 0;
  322|      1|            let mut acc = x;
  322|      1|            let mut results = Vec::with_capacity(a.length());
   32|    259|            let mut hash: u64 = 0xcbf29ce484222325; // FNV offset basis
  322|      8|            let mut values: Vec<T> = (0..a.length()).map(|i| a.nth(i).clone()).collect();
  323|      1|            let mut acc = id.clone();
  323|      1|            let mut combined: BTreeSet<T> = left.values_vec().into_iter().collect();
  325|      1|        let mut result = ArraySeqStPerS::empty();
  325|      3|            let mut left_entries = Vec::new();
   32|      5|            let mut all_prefixes_vec = Vec::with_capacity(n + 1);
  326|      2|        let mut probe_sequences = Vec::new();
  326|      2|            let mut result = Vec::new();
  326|      3|            let mut right_entries = Vec::new();
   32|     71|            let mut left_count = 0;
  327|     27|            let mut guard = self.root.write().unwrap();
  328|       |            let mut t = $crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::AVLTreeSeqStEphS::from_vec(Vec::new());
  329|      9|        let mut rng = StdRng::seed_from_u64(seed);
   33|     12|                dfs_reach(&transposed, &mut visited, &mut component, vertex);
   33|     16|        let mut running_sum = 0;
  332|      1|            let mut acc = id.clone();
  333|      1|            let mut values: Vec<T> = Vec::with_capacity(a.length());
  333|      3|            let mut acc = x;
  333|       |            let mut t = $crate::Chap37::AVLTreeSeqStEph::AVLTreeSeqStEph::AVLTreeSeqStEphS::from_vec(Vec::new());
  334|     11|            let mut count = 0;
   33|      5|        let mut queue = VecDeque::new();
   33|      5|        let mut queue = VecDeque::new();
   33|     71|            let mut right_count = 0;
  337|      2|            let mut acc = seed;
  337|      3|            let mut out = a.clone();
  338|      2|            let mut left_entries = Vec::new();
  338|      3|            let mut applied: HashSet<N> = HashSet::new();
  339|      0|        let mut x = y.left.take().expect("rotate_right requires left child");
  339|      2|            let mut right_entries = Vec::new();
  339|       |            let mut entries = vec![$($crate::Types::Types::Pair($key, $value)),+];
  340|      1|            let mut result = heaps[0].clone();
  340|     23|            let mut result = identity.clone();
  340|      8|        let mut total = OrderedFloat(0.0);
  341|     23|            let mut first = true;
   34|     12|            let mut current = &mut self.head;
   34|     12|                    let mut vec = components.values_in_order();
   34|     15|        visited: &mut ArraySeqStEphS<B>,
   34|    207|        let mut hasher = std::collections::hash_map::DefaultHasher::new();
  342|    111|            let mut values: Vec<T> = Vec::new();
  343|       |            let mut __tree = < $crate::Chap40::BSTReducedStEph::BSTReducedStEph::BSTReducedStEph<_, _, _, _> as $crate::Chap40::BSTReducedStEph::BSTReducedStEph::BSTReducedStEphTrait<_, _, _, _> >::new();
  345|      1|            let mut acc = x.clone();
   34|      5|        let mut current_layer = VecDeque::new();
   34|      5|        let mut current_layer = VecDeque::new();
   34|      5|            let mut running_sum = 0;
  346|      1|            let mut prefixes: Vec<A> = Vec::with_capacity(a.length());
  347|      1|            let mut result = a.clone();
  347|      1|                let mut seq: Vec<i32> = (1..=size as i32).collect();
  347|      1|                let mut size = 1;
347 |     let mut obst = OBSTStEphLit!(keys: [10, 20,], probs: [0.4, 0.6,]);
  348|       |            let mut table = NestedHashTable::create_table($size);
  349|      1|            let mut less_than = Self::empty();
  349|      2|            let mut out = a.clone();
  350|      1|            let mut equal_or_greater = Self::empty();
   35|      0|        let mut v: Vec<Pair<N, &'static str>> = Vec::with_capacity(a.length() * b.length());
   35|     12|                    let mut vec = Vec::new();
   35|     15|        result: &mut AVLTreeSetStEph<N>,
   35|    207|        let mut buf = String::new();
  352|      6|        let mut y = x.right.take().expect("rotate_left requires right child");
  354|     22|        let mut elements = Vec::new();
  355|       |            let mut pq = $crate::Chap45::BinaryHeapPQ::BinaryHeapPQ::BinaryHeapPQ::empty();
  356|      2|            let mut groups: Vec<Pair<T, ArraySeqMtPerS<T>>> = Vec::new();
  356|       |            let mut __set = < $crate::Chap37::BSTSetPlainMtEph::BSTSetPlainMtEph::BSTSetPlainMtEph<_> as $crate::Chap37::BSTSetPlainMtEph::BSTSetPlainMtEph::BSTSetPlainMtEphTrait<_> >::empty();
  357|      1|            let mut acc = id.clone();
  358|      1|            let mut result = a.clone();
  358|      1|            let mut values: Vec<T> = Vec::with_capacity(a.length());
  358|      4|            let mut difference_entries = Vec::new();
  359|      4|            let mut i = 0;
  359|      8|                let mut found_group = false;
  360|      4|            let mut j = 0;
  361|      2|            let mut groups: Vec<Pair<A, Vec<Bv>>> = Vec::new();
   36|    136|            let mut head: Option<Box<NodeE<T>>> = None;
   36|     24|            let mut buckets = ArraySeqStPerS::empty();
  362|      5|                        let mut values: Vec<T> = (0..group.1.length()).map(|j| group.1.nth(j).clone()).collect();
   36|      2|            let mut found_idx = None;
   36|      5|        let mut current_dist = 0;
   36|      5|        let mut current_dist = 0;
  368|      1|            let mut out = a.clone();
  368|      2|            let mut left_entries = Vec::new();
  368|      2|            let mut left = Self::empty();
  369|      2|            let mut right_entries = Vec::new();
  369|      2|            let mut right = Self::empty();
  370|     21|        let mut elements = Vec::new();
  370|      2|            let mut found = false;
  370|       |                let mut __s = < $crate::Chap05::SetStEph::SetStEph::Set<_> >::empty();
  371|    206|            let mut guard = self.root.write().unwrap();
   37|     19|        visited: &mut ArraySeqStEphS<B>,
   37|    207|        Hash::hash(&buf, &mut hasher);
  373|      1|            let mut seq = ArraySeqStPerS::empty();
  375|     21|            let mut result = identity.clone();
  375|      3|            let mut prefixes: Vec<T> = Vec::with_capacity(len);
  376|     21|            let mut first = true;
  377|    423|            let mut result = a.clone();
  378|      2|            let mut acc = x;
  378|    423|            let mut updated: HashSet<N> = HashSet::new();
  379|     14|            let mut out = Vec::with_capacity(self.size());
  379|     40|            let mut result = identity.clone();
  380|     14|            ParamBST::collect_in_order(self, &mut out);
  380|     40|            let mut first = true;
  381|      4|            let mut guard = self.root.write().unwrap();
   38|     19|        ancestors: &mut AVLTreeSetStEph<N>,
  383|      1|            let mut result = Vec::new();
   38|      4|            let mut global_max = None;
  386|      1|            let mut acc = x.clone();
  386|      3|            let mut values: Vec<T> = Vec::new();
  387|      1|            let mut prefixes: Vec<A> = Vec::with_capacity(a.length());
  387|       |            let mut table = $crate::Chap43::AugOrderedTableStEph::AugOrderedTableStEph::AugOrderedTableStEphTrait::empty($reducer, $identity);
  388|      1|            let mut bucket_counts = vec![0; table_size];
  389|      1|            let mut max_count = 0;
   38|      9|            let mut adj_lists = Vec::with_capacity(n);
  390|      1|            let mut total_collisions = 0;
   39|     10|            let mut matrix_rows = Vec::with_capacity(n);
   39|     19|            let mut attempt = 0;
  393|      1|            let mut result = Vec::new();
   39|      3|            let mut attempt = 0;
  394|  4.74k|            let mut left = 0;
  395|      2|            let mut result = Self::empty();
  395|  4.74k|            let mut right = self.entries.length();
   39|      5|            let mut min_prefixes_vec = Vec::with_capacity(n + 1);
  398|     36|        let mut elements = Vec::new();
   39|      8|            let mut max_sum = None;
  400|      2|            let mut groups: Vec<Pair<A, Vec<Bv>>> = Vec::new();
   40|      0|        let mut visited = ArraySeqStEphS::tabulate(&|_| false, n);
   40|     13|        let mut visited = visited;
   40|     14|            let mut next_layer = VecDeque::new();
   40|     14|            let mut next_layer = VecDeque::new();
  405|      1|            let mut first = true;
   40|      5|            let mut running_min = i32::MAX;
   40|      9|            let mut adj_lists = Vec::with_capacity(n);
   41|      0|        let mut result = Vec::new();
   41|    122|                    let mut l_idx = 0;
   41|     30|        let mut partition_map: HashMap<V, V> = HashMap::new();
  413|      2|            let mut result = BalancedTreePQ::<U>::empty();
   41|      4|        let mut matching: Set<Edge<V>> = SetLit![];
  416|      3|            let mut prefixes: Vec<T> = Vec::with_capacity(len);
   41|      8|            let mut matrix_rows = Vec::with_capacity(n);
  419|      9|        let mut data = Vec::with_capacity(length);
  420|       |            let mut table = $crate::Chap43::AugOrderedTableMtEph::AugOrderedTableMtEph::AugOrderedTableMtEphTrait::empty($reducer, $identity);
   42|    122|                    let mut r_idx = 0;
  422|       |            let mut table = $crate::Chap43::AugOrderedTableStPer::AugOrderedTableStPer::AugOrderedTableStPerTrait::empty($reducer, $identity);
   42|     30|        let mut centers: Set<V> = SetLit![];
   42|      4|        let mut matched_vertices: Set<V> = SetLit![];
   42|      5|            let mut min_prefixes_vec = Vec::with_capacity(n + 1);
   43|    122|                    let mut count = 0;
   43|     30|        let mut processed: Set<V> = SetLit![];
  434|      0|            let mut out = Vec::with_capacity(self.size());
  434|      9|                let mut left_filtered = Vec::new();
  435|      0|            ParamTreap::collect_in_order(self, &mut out);
   43|      5|            let mut running_min = i32::MAX;
   44|      2|                let mut split_off = self.split_off(idx);
  445|      9|            let mut right_filtered = Vec::new();
   44|     76|                    let mut sum = 0;
   45|      0|                dfs_finish_order(graph, &mut visited, &mut result, start);
   45|     14|        let mut pq = UnsortedListPQ::empty();
   45|     17|                let mut running_sum = 0;
   45|    259|            let mut step = ((hash % base) + 1) as N;
   45|      3|            let mut table = self.initialize_base_cases();
   45|    525|            let mut is_composite = false;
  456|      9|            let mut filtered_entries = Vec::with_capacity(left_filtered.len() + right_filtered.len());
   45|      6|            let mut table = self.initialize_base_cases();
   45|     77|                        let mut idx = 0;
   45|      7|        let mut visited = AVLTreeSetStPer::empty();
   45|     90|                        let mut idx = 0;
   45|     98|                        let mut idx = 0;
   46|      0|        let mut visited = AVLTreeSetStPer::empty();
   46|  1.38k|            let mut hasher = DefaultHasher::new();
   46|      7|        let mut result = Vec::new();
   47|      0|        let mut result = Vec::new();
   47|      1|            let mut r = rng();
   47|     50|        let mut rng = StdRng::seed_from_u64(seed);
   47|     58|                        let mut idx = 0;
   48|      1|            let mut edges = Set::empty();
   48|      4|            let mut edges = Set::empty();
   49|     14|        let mut result = Vec::new();
   49|     16|        let mut max_val = *a.nth(0);
   49|    279|            let mut vec_elements = Vec::with_capacity(size);
   49|      4|        let mut rng = StdRng::seed_from_u64(seed);
   49|      4|            let mut r = rng();
   49|      5|            let mut max_sum = None;
   49|      7|        let mut visited = ArraySeqStEphS::tabulate(&|_| false, n);
   50|     16|        let mut max_val = a.nth_cloned(0);
   50|     16|        let mut running_sum = *a.nth(0);
   50|      2|            let mut new_chain = ArraySeqStPerS::empty();
   50|      7|        let mut result = Vec::new();
   51|     16|        let mut running_sum = a.nth_cloned(0);
   51|     19|            let mut r = rng();
   51|    268|            let mut vec_elements = Vec::with_capacity(size);
   51|      2|            let mut key_existed = false;
   51|      5|            let mut max_sum = None;
  516|      2|                let mut updated_entries = Vec::with_capacity(len);
   52|     10|            let mut current = &self.head;
   52|    126|            let mut table = ArraySeqStPerS::empty();
   52|      1|            let mut edges = Set::empty();
   52|      1|            let mut edges = Set::empty();
   52|      3|        let mut vertex_to_block: std::collections::HashMap<V, V> = std::collections::HashMap::new();
   52|      8|            let mut count = 0;
   53|     19|        visited: &mut ArraySeqStEphS<B>,
   53|      2|            let mut count = 0;
   53|      3|            let mut memo = self.memo_table.clone();
   53|     50|        let mut vertex_to_index: HashMap<V, N> = HashMap::new();
   53|      5|            let mut dist_matrix = Vec::with_capacity(n);
   53|     61|            let mut dist_vec = vec![UNREACHABLE; n];
  538|  4.45k|                let mut entries_vec = Vec::with_capacity(new_entries.length());
   54|     12|            let mut m: HashMap<A, B> = HashMap::new();
   54|     15|        let mut visited = visited;
   54|     19|        rec_stack: &mut ArraySeqStEphS<B>,
   54|     20|        let mut distances: HashMap<usize, i64> = HashMap::new();
   54|     23|            let mut edge_set = Set::empty();
   54|     56|            let mut edge_set = Set::empty();
   54|     76|                let mut guard = self.data.lock().unwrap();
   54|      9|                dfs_finish_order(graph, &mut visited, &mut result, start);
   55|      0|            let mut spanning_edges = SetLit![];
   55|     16|                let mut row = vec![UNREACHABLE; n];
   55|     19|        result: &mut Vec<N>,
   55|      1|            let mut attempt = 0;
   55|      3|            let mut attempt = 0;
   55|      5|            let mut dist_matrix = Vec::with_capacity(n);
   55|     71|            let mut dist_vec = vec![UNREACHABLE; n];
   56|      1|            let mut edges = Set::empty();
   56|      1|            let mut edges = Set::empty();
  570|      4|                let mut left_filtered = Vec::new();
   57|     16|                let mut row = vec![UNREACHABLE; n];
   57|     20|        let mut distances: HashMap<usize, OrderedF64> = HashMap::new();
   57|      2|            let mut count = 0;
   57|      3|            let mut count = 0;
   57|      6|            let mut count = 0;
   58|     10|                let mut lt = lo;
  581|      4|            let mut right_filtered = Vec::new();
   59|    107|            let mut neighbors = Set::empty();
   59|     10|                let mut i = lo;
  592|      4|            let mut filtered_entries = Vec::with_capacity(left_filtered.len() + right_filtered.len());
   59|      4|            let mut neighbors = Set::empty();
   59|     50|        let mut coin_flips: HashMap<V, bool> = HashMap::new();
   59|      6|            let mut spanning_edges = SetLit![];
   59|      7|        let mut mst_edges = SetLit![];
   60|     10|                let mut gt = hi;
   60|      2|        let mut total = 0i64;
   60|     59|            let mut last_values: std::collections::HashMap<N, T> = std::collections::HashMap::new();
   60|      7|            let mut count = 0;
   61|    122|            let mut new_chain = ArraySeqStPerS::empty();
   61|      1|            let mut count = 0;
   61|     57|            let mut changed = false;
   61|      5|        let mut all_distances = ArraySeqStEphS::empty();
   61|      7|        let mut total = 0i64;
   62|    122|            let mut key_existed = false;
   62|     27|        visited: &mut ArraySeqStEphS<B>,
   62|      2|        let mut tour = std::vec::Vec::new();
   62|     57|            let mut new_distances: HashMap<usize, i64> = HashMap::new();
   62|      5|        let mut all_predecessors = ArraySeqStEphS::empty();
  626|      4|                let mut left_filtered = Vec::new();
   62|      7|        let mut uf = UnionFind::new();
   63|     14|        let mut pq = SortedListPQ::empty();
   63|  2.40k|            let mut sum = 0;
   63|     27|        result: &mut Vec<N>,
   63|      2|        let mut visited_edges: HashSet<(V, V)> = HashSet::new();
   63|      3|            let mut current = &mut self.head;
   63|      3|            let mut table = vec![vec![0usize; t_len + 1]; s_len + 1];
   63|      6|            let mut table = vec![vec![0usize; t_len + 1]; s_len + 1];
  637|      4|            let mut right_filtered = Vec::new();
   64|     25|        let mut bridges: HashMap<V, (V, OrderedFloat<f64>, usize)> = HashMap::new();
  648|      4|            let mut filtered_entries = Vec::with_capacity(left_filtered.len() + right_filtered.len());
   65|     10|            let mut candidate = n;
   65|      1|            let mut result = Vec::with_capacity(set_size);
   65|    346|                let mut lt = 0;
   65|     36|            let mut all_pairs = ArraySeqStPerS::empty();
   65|     50|        let mut th_edges: std::vec::Vec<(N, V)> = std::vec::Vec::new();
   65|     51|            let mut current = self.head.as_deref();
   65|     51|                        let mut idx = 0;
   65|     52|                        let mut idx = 0;
   65|     86|                        let mut idx = 0;
   66|    346|                let mut i = 0;
   66|      3|            let mut table = vec![vec![0usize; t_len + 1]; s_len + 1];
   66|      4|            let mut table = vec![vec![0usize; t_len + 1]; s_len + 1];
   66|     51|            let mut skipped = 0usize;
   67|     14|        let mut result = Vec::new();
   67|    224|                let mut min_dist = current_dist;
   67|    253|                    let mut lt = 0;
   67|      2|        let mut tour = std::vec::Vec::new();
   67|    346|                let mut gt = len;
   67|      3|            let mut map = vertex_to_block.lock().unwrap();
  676|       |            let mut entries = vec![$($crate::Types::Types::Pair($key, $value)),+];
   67|     73|                        let mut idx = 0;
   68|      1|                let mut neighbors = Set::empty();
   68|    216|            let mut vals = seq.values_in_order();
   68|    253|                    let mut i = 0;
   68|     28|            let mut result = Self::empty();
   68|      2|        let mut visited_edges: HashSet<(V, V)> = HashSet::new();
   68|     31|                let mut neighbors = Set::empty();
   68|      7|        let mut edges_vec: Vec<LabEdge<V, OrderedFloat<f64>>> = graph.labeled_edges().iter().cloned().collect();
   69|    253|                    let mut gt = len;
   69|      2|            let mut new_buckets = ArraySeqStPerS::empty();
   69|      5|        let mut all_distances = ArraySeqStEphS::empty();
   69|       |            values_with_change_number: &mut ArraySeqMtPerS<Pair<T, N>>,
   70|     26|                let mut lo = 0;
   70|      3|            let mut neighbors = AVLTreeSetStEph::empty();
   70|      3|        let mut new_vertices: Set<V> = SetLit![];
   70|      5|        let mut all_predecessors = ArraySeqStEphS::empty();
   71|     16|            let mut first = true;
   71|     20|        let mut visited = visited;
   71|     26|                let mut hi = n_right;
   71|      3|        let mut new_edges: Set<Edge<V>> = SetLit![];
   71|     49|            let mut changed = false;
   72|      1|                let mut neighbors = Set::empty();
   72|    278|            let mut neighbors = Set::empty();
   72|     49|            let mut new_distances: HashMap<usize, OrderedF64> = HashMap::new();
   72|     56|                let mut neighbors = Set::empty();
   72|      5|            let mut arcs = Set::empty();
   72|  7.20k|            let mut new_node = Box::new(Node {
   73|     37|        let mut result = SSSPResultStEphInt::new(n, source);
   73|      3|            let mut neighbors = AVLTreeSetStPer::empty();
   73|     47|        let mut result = SSSPResultStEphFloat::new(n, source);
   73|      5|            let mut vertices = AVLTreeSetStPer::empty();
   74|      1|            let mut result = AVLTreeSetStEph::empty();
   74|     29|            let mut min_element = self.elements.nth(0);
   74|     31|            let mut probe_sequence = Vec::new();
   74|      4|        rng: &mut rand::rngs::StdRng,
   75|     23|            let mut edges = Set::empty();
   75|     31|            let mut unique_positions = std::collections::HashSet::new();
   75|      3|            let mut neighbors = AVLTreeSetMtPer::empty();
   76|     37|        let mut visited: HashMap<usize, i64> = HashMap::new();
   76|     47|        let mut visited: HashMap<usize, OrderedF64> = HashMap::new();
   76|     51|            let mut out: Vec<T> = Vec::with_capacity(length);
   76|      6|        tour: &mut std::vec::Vec<V>,
   76|      7|            let mut issues = Vec::new();
   77|     13|            let mut keys = ArraySetStEph::empty();
   77|     16|        let mut visited = visited;
   77|    183|                let mut min_dist = current_dist;
   77|      1|            let mut bits = bitbox![0; u];
   77|     51|            let mut taken = 0usize;
   77|    586|            let mut singleton_sets = Vec::with_capacity(seq_len);
   77|      6|        visited_edges: &mut HashSet<(V, V)>,
   78|     16|        let mut rec_stack = rec_stack;
   78|     17|            let mut attempt = 0;
   78|     21|            let mut clusters = Vec::new();
   78|      4|            let mut arcs = Set::empty();
   78|     99|            let mut ng: Set<V> = SetLit![];
   79|    134|            let mut singleton_sets = Vec::with_capacity(seq_len);
   79|     21|            let mut current_cluster_size = 0;
   79|      2|        let mut rng = StdRng::seed_from_u64(seed);
   79|   555k|            let mut t = AVLTreeSeqStEphS::new_root();
   80|    122|            let mut new_buckets = ArraySeqStPerS::empty();
   80|      1|            let mut edges = Set::empty();
   80|      1|            let mut edges = Set::empty();
   80|     21|            let mut in_cluster = false;
   80|      2|        let mut matching: Set<Edge<V>> = SetLit![];
   80|     37|        let mut pq: BinaryHeapPQ<PQEntry> = BinaryHeapPQ::singleton(PQEntry::new(0, source));
   80|     47|        let mut pq: BinaryHeapPQ<PQEntry> = BinaryHeapPQ::singleton(PQEntry::new(OrderedF64::from(0.0), source));
   80|      5|            let mut keys = ArraySetStEph::empty();
   81|     14|        let mut pq = BalancedTreePQ::empty();
   81|     17|            let mut node = Node::new(key, priority);
   81|      1|            let mut edges = Set::empty();
   81|      1|            let mut neighbors = Vec::new();
   81|    272|            let mut probe_index = 0;
   81|    307|            let mut insert_pos = 0;
   81|      5|                let mut row = self.distances.nth(u).clone();
   81|      6|        tour: &mut std::vec::Vec<V>,
   81|  7.58k|                let mut guard = link.write().unwrap();
   82|     10|                let mut probe_sequence = Vec::new();
   82|    376|            let mut values = self.elements.values_in_order();
   82|      6|        visited_edges: &mut HashSet<(V, V)>,
   83|      0|        visited: &mut ArraySeqStEphS<B>,
   83|     10|            let mut out: Set<X> = Set::empty();
   83|      1|        let mut total = OrderedFloat(0.0);
   83|      2|        let mut edge_coins: std::collections::HashMap<Edge<V>, bool> = std::collections::HashMap::new();
   83|     36|            let mut word_table = TableStPer::empty();
   83|      5|                let mut row = self.distances.nth(u).clone();
   83|      7|        let mut adj_vecs: Vec<Vec<N>> = vec![Vec::new(); n];
   84|      0|        result: &mut Vec<N>,
   84|     14|        let mut quotient_edges: Set<Edge<V>> = SetLit![];
   84|    272|            let mut insertion_pos = None;
   84|      2|        let mut total = OrderedFloat(0.0);
   84|      4|        let mut coins_vec = std::vec::Vec::with_capacity(n);
   84|    586|            let mut result = Self::empty();
   84|     71|            let mut result = HashMap::new();
   84|      8|        let mut mst_edges = SetLit![];
   85|      0|                        let mut s = Set::empty();
   85|     14|        let mut result = Vec::new();
   85|      1|        let mut handles = Vec::new();
   85|      2|            let mut bits = bitbox![0; u];
   85|    376|            let mut insert_pos = values.len();
   85|      3|        let mut new_vertices: Set<V> = SetLit![];
   85|  5.04k|                let mut result = Vec::with_capacity(n);
   85|      7|        let mut adj_vecs: Vec<Vec<N>> = vec![Vec::new(); n];
   85|      8|            let mut visited = Set::empty();
   85|      8|        let mut visited: std::collections::HashSet<V> = std::collections::HashSet::new();
   86|    134|            let mut result = Self::empty();
   86|    183|                let mut memo_guard = self.memo.lock().unwrap();
   86|    222|        let mut base_seq = <ArraySeqStEphS<V> as ArraySeqStEphTrait<V>>::tabulate(&|i| vertices_vec[i as usize].clone(), n);
   86|      2|            let mut result = NestedHashTable {
   86|      3|                let mut vals = Vec::with_capacity(seq.length());
   86|    487|            let mut result = self.elements.clone();
   86|  5.04k|                let mut i = 0;
   86|      8|            let mut stack = Vec::new();
   87|      0|                        let mut s = Set::empty();
   87|      1|            let mut neighbors = Vec::new();
   87|     31|            let mut attempt = 0;
   87|  5.04k|                let mut j = 0;
   88|    128|                let mut ng: Set<V> = SetLit![];
   88|      1|            let mut edges = Set::empty();
   88|      1|                let mut to_remove = Vec::new();
   88|     24|            let mut new_adj = self.adj.clone();
   88|      3|            let mut component_map = HashMap::new();
   88|      5|            let mut entries = Vec::with_capacity(key_seq.length());
   88|      6|            let mut element_hashes: Vec<u64> = Vec::with_capacity(self.data.len());
   88|      8|        let mut pq = BinaryHeapPQ::<PQEntry<V>>::singleton(PQEntry::new(OrderedFloat(0.0), start.clone(), None));
   89|      4|            let mut attempt = 0;
   89|      7|            let mut data = self.to_vec();
   90|     11|                let mut found = false;
   90|     15|                let mut h = DefaultHasher::new();
   90|    280|            let mut values = self.values_vec();
   90|      3|            let mut result: Set<V> = SetLit![];
   90|      6|            let mut values = self.values_vec();
   90|      6|            let mut values = self.values_vec();
   90|      6|            let mut values = self.values_vec();
   90|      6|            let mut values = self.values_vec();
   90|      7|            let mut values = self.values_vec();
   91|      0|                        let mut s = Set::empty();
   91|    307|            let mut new_elements = ArraySeqStPerS::empty();
   91|      4|            let mut neighbors = Set::empty();
   91|     98|            let mut neighbors = Set::empty();
   91|      9|            let mut it = self.iter();
   92|      0|                        let mut s = Set::empty();
   92|    111|                let mut memo_guard = self.memo.lock().unwrap();
   92|     15|                let mut memo_guard = self.memo_table.lock().unwrap();
   92|    396|            let mut hash_value = 0;
   92|      7|            let mut result = Self::empty();
   93|     13|            let mut new_neighbors = AVLTreeSetStEph::empty();
   93|      2|            let mut component_map = HashMap::new();
   93|      2|            let mut valid_values = Vec::new();
   93|    396|            let mut power = 1;
   93|      3|            let mut attempt = 0;
   93|      9|            let mut out = ArraySeqStEphS::new(len, first.clone());
   94|      0|                let mut right_arcs = arcs;
   94|      0|                        let mut s = Set::empty();
   94|     10|            let mut out: Set<Y> = Set::empty();
   94|     15|                let mut memo_guard = self.memo_table.lock().unwrap();
   94|      2|            let mut candidate = 1;
   94|      7|            let mut result = Self::empty();
   95|    118|            let mut result = Vec::with_capacity(self_len + other_len);
   95|     19|                let mut result = SSSPResultStEphInt::new(n, source);
   95|      1|            let mut count = 0;
   95|    239|            let mut current = self.head.as_deref();
   95|      9|            let mut index: N = 1;
   96|    114|                let mut memo_guard = self.memo.lock().unwrap();
   96|     18|            let mut guard = self.inner.data.lock().unwrap();
   96|    239|            let mut i = 0usize;
   96|      5|            let mut result = <ArraySeqMtEphS<T> as ArraySeqMtEphTraitChap18<T>>::new(n, f(0));
   97|      0|        let mut output = String::new();
   97|     11|            let mut new_neighbors_vec: Vec<N> = Vec::with_capacity(old_neighbors.length() + 1);
   97|    122|            let mut result = SeparateChainingHashTable {
   97|      1|        let mut table = create_linear_probing_string_table(8);
   97|     50|        let mut centers: Set<V> = SetLit![];
   97|  6.96k|                            let mut guard = link.write().unwrap();
   97|      6|        let mut total = OrderedFloat(0.0);
   98|      0|                        let mut s = Set::empty();
   98|     11|                    let mut new_neighbors_vec: Vec<N> = Vec::with_capacity(old_neighbors.length() + 1);
   98|      1|            let mut new_bits = bitbox![0; self.universe_size];
   98|      2|            let mut result: Set<V> = SetLit![];
   98|     30|        visited: &mut ArraySeqStEphS<B>,
   98|     36|            let mut final_table = TableStPer::empty();
   98|      4|            let mut merged: BTreeSet<T> = self.values_vec().into_iter().collect();
   98|      4|            let mut merged: BTreeSet<T> = self.values_vec().into_iter().collect();
   98|      4|            let mut merged: BTreeSet<T> = self.values_vec().into_iter().collect();
   98|      4|            let mut merged: BTreeSet<T> = self.values_vec().into_iter().collect();
   98|     50|        let mut partition_map: HashMap<V, V> = HashMap::new();
   98|      6|            let mut merged: BTreeSet<T> = self.values_vec().into_iter().collect();
   98|      9|            let mut merged: BTreeSet<T> = self.values_vec().into_iter().collect();
   99|      0|                let mut right_edges = edges;
   99|     19|        let mut pq = BinaryHeapPQ::empty();
   99|      1|            let mut edges = Set::empty();
   99|     30|        component: &mut AVLTreeSetStEph<N>,
   99|      5|                let mut row = self.predecessors.nth(u).clone();
   99|      7|            let mut all_adjacent_tails = true;
   99|      8|            let mut edge_found = false;
    2|       |//! StEphemeral (mutable) implicit-order AVL tree sequence.
  128|       |        /// Mutably update sequence S
  130|       |        /// Mutably update sequence S
  133|       |        /// Mutably update sequence T
  138|       |        /// Mutably update sequence T
  164|       |        /// Mutably update sequence S
  169|       |        /// Mutably update sequence T
  217|       |        /// Mutably update sequence S
  225|       |        /// Mutably update sequence T
   17|       |        data: Mutex<Box<[T]>>,
   19|       |        data: Mutex<Box<[T]>>,
  152|      5|                data: Mutex::new(data.into_boxed_slice()),
   38|  22.6k|                data: Mutex::new(values.into_boxed_slice()),
   23|    113|                data: Mutex::new(Vec::new().into_boxed_slice()),
   42|  4.51k|            let my_ticket = self.ticket.fetch_add(1, Ordering::Relaxed);
  100|      0|        vertex: N,
  100|     30|        vertex: N,
  100|    437|                if n == 0 {
  100|     80|            if n == 0 {
  101|    222|                let n = edges.len();
  101|     30|        vertex: N,
  102|    222|                if n == 0 {
  103|    437|                if n == 1 {
  103|      4|        let n = edges.length();
  103|  5.71k|            let n = vertices.len();
  104|      0|        output.push_str(&format!("Input: {:?}\n", textbook.input));
  104|      4|        if n == 0 {
  105|    222|                if n == 1 {
  105|  5.71k|            if n <= 8 {
  106|     26|            let n = solver.multiset.length();
  108|      5|        let n = graph.sizeV();
  112|      0|        output.push_str(&format!("Input: {:?}\n", reverse.input));
  112|     75|            let n = self.size();
  114|    135|            let n = arcs.len();
  114|     21|            let n = self.multiset.length();
  114|     75|            if n <= 8 {
  116|    135|            if n <= 8 {
  117|      2|            let n = arcs.len();
  119|      0|                let n = vertices.len();
  119|      0|        output.push_str(&format!("Input: {:?}\n", sorted.input));
  119|      2|            if n <= 8 {
  120|      0|                if n == 0 {
  123|      0|                if n == 1 {
  124|     11|            let n = solver.keys.len();
  124|      1|            let n = arcs.len();
  125|     11|            solver.obst_rec(0, n)
  125|     19|        let n = graph.vertices().size();
  125|    263|            let n = edges.len();
  126|      0|        output.push_str(&format!("Input: {:?}\n", duplicates.input));
  126|     12|            let n = self.multiset.length();
  126|      1|            if n <= 8 {
  127|    263|            if n <= 8 {
  128|     10|            let n = solver.dimensions.len();
  129|     10|            solver.matrix_chain_rec(0, n - 1)
   12|       |        c1: N,
   12|       |        n: N,
  131|      0|                let n = arcs.len();
  131|      0|                let n = arcs.len();
  131|      4|            let n = self.length();
  132|      0|                if n == 0 {
  132|      0|                if n == 0 {
  134|     19|        let n = graph.vertices().size();
  135|      0|                if n == 1 {
  135|      0|                if n == 1 {
  135|     21|            let n = self.keys.len();
  136|     10|            let n = self.multiset.length();
  136|     21|            self.obst_rec(0, n)
  139|      3|            let n = self.dimensions.len();
   13|       |        c2: N,
   13|       |        n: N,
  140|      3|            self.matrix_chain_rec(0, n - 1)
  141|      0|                let n = arcs.len();
  141|     10|            let n = vertices.len();
  142|      0|                if n == 0 {
  143|     10|            if n <= 8 {
  144|      0|                let n = edges.len();
  145|      0|                if n == 0 {
  145|      0|                if n == 1 {
  148|      0|                if n == 1 {
  148|  26.3k|            let n = arcs.len();
  148|      3|            let n = self.size();
   14|       |        num_elements: N,
  150|  26.3k|            if n <= 8 {
  151|      3|            if n == 0 || m == 0 {
  155|      3|            if n <= 8 {
  156|    218|                let n = self_vals.len();
  157|      0|                let n = vertices.len();
  157|    218|                if n == 0 {
  158|      0|                if n == 0 {
   15|       |        c1: N,
   15|       |        size: N,
  160|    218|                if n == 1 {
  160|     80|            let n = a.length();
  161|      0|                if n == 1 {
  162|      0|                let n = arcs.len();
  163|      0|                if n == 0 {
  163|     80|            if n <= 1 {
  166|      0|                if n == 1 {
  166|     68|            let n = arcs.len();
  167|      6|            let n = self.length();
  168|      2|            let n = self.length();
  168|     68|            if n <= 8 {
  169|     10|            let n = self.dimensions.len();
   16|       |        c2: N,
   16|       |        height: N,
   16|       |        height: N,
   16|       |        size: N,
   16|       |        size: N,
   16|       |        size: N, // Size of subtree rooted at this node
  170|     10|            self.matrix_chain_rec(0, n - 1)
  173|      9|            let n = self.keys.len();
  174|      9|            self.obst_rec(0, n)
  177|     16|            table_size: N,
   17|       |            rank: N, // Distance to nearest leaf (for leftist property)
   17|       |        size: N,
   17|       |        size: N,
   17|       |        size: N,
   17|       |        size: N,
   17|       |        size: N,
  182|     18|            let n = self.data.len();
   18|     22|            let n = a.length();
   18|     30|            let n = a.length();
  183|      0|                let n = arcs.len();
  184|      0|                if n == 0 {
  184|      2|            let n = self.length();
  185|     24|            let n = self.length();
  187|      0|                if n == 1 {
  189|      2|            let n = self.data.len();
   18|       |        size: N,
   18|       |        size: N,
   19|    100|            let n = self.length();
  194|    197|            let n = self.size();
  197|    197|            if n == 0 {
  198|  31.7k|            let n = arcs.len();
   19|     84|            let n = self.length();
   19|     85|            let n = self.length();
   19|       |        len: N,
   19|       |        len: N,
   19|       |        size: N,
   19|       |        size: N,
   19|       |        universe_size: N, // elements are 0..universe_size-1
  200|  31.7k|            if n <= 8 {
   20|      3|        let n = a.length();
  204|    121|            if n <= 8 {
   20|       |        size: N,
  210|  3.99k|            let n = a.length();
  211|  3.99k|            if n == 0 {
  212|      0|                let n = arcs.len();
   21|     22|            if n == 0 {
   21|     30|            if n == 0 {
  213|      0|                if n == 0 {
  214|  3.99k|            if n == 1 {
  216|      0|                if n == 1 {
   21|      6|            let n = a.length();
   21|      6|        let n = graph.length();
   21|      7|        let n = graph.length();
   21|      7|        let n = graph.length();
   21|      7|        let n = graph.length();
   21|      7|        let n = graph.length();
   21|     88|            let n = self.length();
   22|      0|        if n == 0 {
   22|     16|        if n <= 2 {
   22|      5|        if n == 0 {
   22|      7|        let n = graph.length();
   22|       |        num_elements: N,
   22|       |        size: N,
   22|       |        size: N,
   23|      0|        if n == 0 {
  231|     12|            let n = self.length();
  233|    493|            let n = self.size();
   23|      5|        if n == 0 {
   23|     82|            if n == 1 {
   23|     83|            if n == 1 {
   23|     98|            if n == 1 {
   23|       |        size: N,
   24|     29|            if n == 1 {
   24|      5|        if n <= 2 {
   24|      6|            if n == 0 {
   24|      6|            let n = a.length();
  248|  5.01k|            let n = vertices.len();
   24|       |        size: N,
  250|  5.01k|            if n <= 8 {
  252|      1|            let n = a.length();
  255|  97.2M|        update_meta(&mut n);
   25|      7|        let n = graph.length();
   25|      7|        let n = graph.length();
   25|      7|        let n = graph.length();
   25|     86|            if n == 1 {
   26|     21|            if n == 1 {
  264|      0|                let n = vertices.len();
  265|      0|                if n == 0 {
   26|      5|            <ArraySeqStPerS<ArraySeqStPerS<Pair<N, N>>> as ArraySeqStPerTrait<ArraySeqStPerS<Pair<N, N>>>>::tabulate(
   26|      7|        let n = graph.length();
   26|      7|        let n = graph.length();
  268|      0|                if n == 1 {
  272|      1|            _change_index: N,
   27|  2.38k|        if n <= 1 {
   27|      6|            if n == 0 {
  280|      1|                "O(log n) insert and deleteMin".to_string(),
   28|     26|                    <ArraySeqStPerS<Pair<N, N>> as ArraySeqStPerTrait<Pair<N, N>>>::tabulate(&|y| Pair(x, y + 1), n - 1)
   28|     48|        let n = a.length();
   28|     48|        let n = a.length();
  285|      1|                "O(log n) insert and deleteMin".to_string(),
  290|      1|                "O(log n) insert and deleteMin + superior meld".to_string(),
  293|  5.01k|            let n = vertices.len();
  295|  5.01k|            if n <= 8 {
  296|   197M|        let n = node.as_ref().expect("index out of bounds");
   30|     22|            let n = a.length();
   30|     30|            let n = a.length();
  306|      4|            if n <= 2 {
  309|      0|                let n = vertices.len();
   30|      9|            let n = a.length();
  310|      0|                if n == 0 {
   31|     15|        vertex: N,
   31|     18|        if n < 2 {
  313|      0|                if n == 1 {
   31|     48|        if n == 0 {
   31|     48|        if n == 0 {
   31|      5|            let n = a.length();
  319|     11|            if n < 2 {
  322|     10|            if n == 2 {
  325|      9|            if n % 2 == 0 {
   32|      5|        <ArraySeqStPerS<Pair<N, N>> as ArraySeqStPerTrait<Pair<N, N>>>::flatten(&inner)
  331|      6|                if n % i == 0 {
   33|     22|            if n == 0 {
   33|     30|            if n == 0 {
   33|      9|            if n == 0 {
   34|      5|            if n == 0 {
  358|      1|            table_size: N,
   36|     15|        vertex: N,
   36|     29|            if n == 1 {
   36|     47|        if n == 1 {
   36|     47|        if n == 1 {
  365|     20|        update_meta(&mut n);
   36|       |        size: N,
   38|     21|            if n == 1 {
   39|      0|        let n = graph.length();
   39|     19|        vertex: N,
   40|     11|        initial_size: N,
   40|     19|        vertex: N,
  409|     30|        let n = node.as_ref().expect("index out of bounds");
  410|      1|            table_size: N,
   43|     76|            if n < 2 {
   43|       |        num_elements: N,
   44|     22|            if n % 2 == 1 { f(&result, a.nth(n - 1)) } else { result }
   44|      7|        let n = graph.length();
   44|       |        num_deleted: N,
   45|      0|        let n = graph.length();
   45|       |        pub n: usize,
   46|     73|            if n == 2 {
   46|       |        pub n: usize,
   47|       |        pub n: usize,
   48|      2|        initial_size: N,
   48|      7|        let n = graph.length();
   48|    885|            let n = self.data.len();
   48|       |        pub n: usize,
   49|      5|        let n = graph.vertices().size();
   49|     68|            if n % 2 == 0 {
   50|      0|            let n = matrix.length();
   50|      5|        let n = graph.vertices().size();
   51|     15|                if n % 2 == 0 { n } else { n - 1 },
   51|     20|        let n = graph.vertices().size();
   51|     50|        let n = vertices_vec.len() as N;
   52|      0|            let n = matrix.length();
   52|      2|            let n = self.adj.length();
   53|     11|        initial_size: N,
   54|     20|        let n = graph.vertices().size();
   55|     10|        initial_size: N,
   55|     15|            if n % 2 == 1 {
   55|     43|                if n % i == 0 {
   56|     19|        vertex: N,
   56|      2|            let n = self.adj.length();
   59|     10|        let n = graph.vertices().size();
   59|     22|            if n % 2 == 1 {
   59|      5|        let n = graph.vertices().size();
   62|     27|        vertex: N,
   63|      2|        initial_size: N,
   63|      4|        initial_size: N,
   64|     19|        vertex: N,
   64|     27|        vertex: N,
   65|      1|            let n = edges.len();
   65|     31|            let n = arcs.len();
   67|      1|            if n <= 8 {
   67|     31|            if n <= 8 {
   69|      1|            let n = edges.len();
   69|     56|            let n = arcs.len();
   70|     37|        let n = graph.vertices().size();
   70|     47|        let n = graph.vertices().size();
   71|      1|            if n <= 8 {
   71|     38|            let n = a.length();
   71|     56|            if n <= 8 {
   71|       |            change_index: N,
   72|  10.2k|                let n = vals.len();
   72|     38|            let n = a.length();
   72|  8.14k|            let n = guard.len();
   73|  10.2k|                if n <= 1 {
   74|     38|            if n == 0 {
   75|     38|            if n == 0 {
   77|     37|            if n == 1 {
   78|     37|            if n == 1 {
   78|      4|        let n = edges.length();
   79|      0|                let n = arcs.len();
   79|      4|        if n == 0 {
   79|     63|            let n = a.length();
   80|      0|                if n == 0 {
   80|      0|        let n = graph.sizeV();
   80|     15|                if n % 2 == 0 { n } else { n - 1 },
   81|      0|                let n = edges.len();
   82|      0|                if n == 0 {
   82|     63|            if n <= 1 {
   82|      7|        let n = graph.length();
   82|       |        base: N,
   83|      0|                if n == 1 {
   83|      4|            let n = self.length();
   84|     15|            if n % 2 == 1 {
   84|      7|        let n = graph.length();
   85|      0|                if n == 1 {
   85|      0|        vertex: N,
   85|    134|            let n = edges.len();
   86|      0|                let n = arcs.len();
   87|      0|                if n == 0 {
   87|    134|            if n <= 8 {
   88|      0|                let n = edges.len();
   89|      0|                if n == 0 {
   90|      0|                if n == 1 {
   92|      0|                if n == 1 {
   93|      6|            if n == 0 {
   99|    437|                let n = vals.len();
  238|  2.00k|            let na = a.length();
  140|      0|        for (name, data) in efficiency {
   79|      4|        table_eph.map(|name| name.to_uppercase());
   85|      4|        table_mt.map(|name| name.to_uppercase());
  239|  2.00k|            let nb = b.length();
  263|      2|             or nearby positions form contiguous clusters. This leads to longer probe sequences \
  125|     23|        let n_edges = edges_seq.length();
   54|      4|        let n_edges = edges_seq.length();
   56|      4|        if n_edges == 0 {
   92|     22|        let n_edges = edges_seq.length();
   93|      3|        let n_edges = edges_seq.length();
  138|    231|        fn needs_rebuild(node: &Node<T>) -> bool {
   96|    907|        fn needs_rebuild(node: &Node<T>) -> bool {
   57|       |                // Negative cycle detected - return infinity matrix
   67|       |                // Negative cycle detected - return infinity matrix
   67|       |                // Negative cycle detected - return infinity matrix
    6|       |//! Handles negative edge weights and detects negative-weight cycles.
    6|       |//! Handles negative edge weights and detects negative-weight cycles.
  103|    105|                for neighbor in neighbors.iter() {
  103|     97|                for neighbor in neighbors.iter() {
  106|     45|                        let neighbor = neighbors_seq.nth(i);
  109|      1|                    let neighbor = *old_neighbors.nth(i);
  110|      1|                    if neighbor != v {
  110|      4|                euler_tour_dfs(graph, neighbor, Some(current), tree_edges, tour, visited_edges);
  111|      0|            let neighbor = *neighbors.nth(i);
  111|     18|            let neighbor = *neighbors.nth(i);
  113|     18|            let neighbor = *neighbors.nth(i);
  115|     45|                        let neighbor = neighbors_seq.nth(i);
  119|      4|                euler_tour_dfs(graph, neighbor, Some(current), tree_edges, tour, visited_edges);
  120|     17|                        let neighbor = neighbors_seq.nth(i);
  126|      1|                let neighbor = *old_neighbors.nth(i);
  127|     17|                    let neighbor = neighbors_seq.nth(i);
  127|      1|                if neighbor != v {
  131|    128|                        for neighbor in self.neighbors(&current).iter() {
   42|     10|            let neighbor = *neighbors.nth(i);
   47|     10|            let neighbor = *neighbors.nth(i);
   54|     13|            let neighbor = *neighbors.nth(i);
   56|     13|            let neighbor = *neighbors.nth(i);
   59|     97|            for neighbor in neighbors.iter() {
   70|     12|            let neighbor = *neighbors.nth(i);
   73|     18|            let neighbor = *neighbors.nth(i);
   74|     18|            let neighbor = *neighbors.nth(i);
   80|     12|            let neighbor = *neighbors.nth(i);
   82|     12|        for neighbor in neighbors.iter() {
   84|      8|                if neighbor == p {
   88|     12|        for neighbor in neighbors.iter() {
   91|      8|                if neighbor == p {
   94|    128|                        for neighbor in self.neighbors(&current).iter() {
   95|      0|            let neighbor = *neighbors.nth(i);
   90|      6|                (current.clone(), neighbor.clone())
   98|      6|                (current.clone(), neighbor.clone())
  109|     37|                            let neighbor_entry = Pair(Pair(neighbor_p.clone(), neighbor.clone()), neighbor.clone());
  118|     37|                            let neighbor_entry = Pair(Pair(neighbor_p.clone(), neighbor.clone()), neighbor.clone());
  123|     16|                            let neighbor_entry = Pair(Pair(neighbor_p.clone(), neighbor.clone()), neighbor.clone());
  130|     16|                        let neighbor_entry = Pair(Pair(neighbor_p.clone(), neighbor.clone()), neighbor.clone());
  108|     37|                            let neighbor_p = priority_fn.priority(neighbor);
  117|     37|                            let neighbor_p = priority_fn.priority(neighbor);
  122|     16|                            let neighbor_p = priority_fn.priority(neighbor);
  129|     16|                        let neighbor_p = priority_fn.priority(neighbor);
  101|     47|                    let neighbors = graph(&v);
  102|     97|                let neighbors = graph.out_neighbors_weighted(&v);
  102|     99|                let neighbors = graph.out_neighbors_weighted(&v);
  104|     14|                let neighbors = graph(v);
  107|      0|        let neighbors = graph.nth(vertex);
  109|     20|        let neighbors = graph.nth(vertex);
  109|     20|        let neighbors = graph.nth(vertex);
  110|     47|                    let neighbors = graph(&v);
  111|       |        /// Neighbors (in undirected graphs, all neighbors are both in and out)
  112|      2|                    self.adj.insert(u, neighbors, |_, new| new.clone());
  114|       |        /// Neighbors (in undirected graphs, all neighbors are both in and out)
  115|     23|                    let neighbors = graph(&v);
  116|     28|                    let neighbors = graph(v);
  117|       |        /// Neighbors of vertex set
  118|     21|            let neighbors = match self.adj.find(&u) {
  120|       |        /// Neighbors of vertex set
  122|     25|            let neighbors = get_neighbors(graph, &u);
  123|    135|                return neighbors;
  123|     23|                let neighbors = graph(&v);
  125|     19|            let neighbors = match self.adj.find(&u) {
  126|     21|            self.adj.insert(u, neighbors, |_, new| new.clone());
  126|      2|                return neighbors;
  133|      1|                return neighbors;
  136|    263|                return neighbors;
  137|      1|                self.adj.insert(u.clone(), neighbors, |_, new| new.clone());
  145|       |        /// Neighbors (in undirected graphs, all neighbors are both in and out)
  148|       |        /// Neighbors (in undirected graphs, all neighbors are both in and out)
  175|     68|                return neighbors;
  195|       |        /// Neighbors (in undirected graphs, all neighbors are both in and out)
  196|       |        /// Neighbors (in undirected graphs, all neighbors are both in and out)
  198|       |        /// Neighbors (in undirected graphs, all neighbors are both in and out)
  199|       |        /// Neighbors (in undirected graphs, all neighbors are both in and out)
  202|       |        /// Neighbors of vertex set
  205|       |        /// Neighbors of vertex set
   29|       |//! let neighbors = graph.neighbors_weighted(&"A"); // Returns Set<(V, OrderedFloat<f64>)>
   38|     13|        let neighbors = graph.nth(vertex);
   39|     17|                let neighbors = graph.nth(u);
   39|     17|                let neighbors = graph.nth(u);
   44|     17|                    let neighbors = graph.nth_cloned(u);
   44|     17|                    let neighbors = graph.nth(u);
   45|     13|        let neighbors = graph.nth(vertex);
   52|     15|        let neighbors = graph.nth(vertex);
   52|     15|        let neighbors = graph.nth(vertex);
   58|     69|            let neighbors = graph.NG(vertex);
   64|      7|            let neighbors = self.adj.nth(u);
   67|     16|        let neighbors = graph.nth(vertex);
   69|     20|        let neighbors = graph.nth(vertex);
   69|      8|            let neighbors = self.adj.nth(u);
   71|     20|        let neighbors = graph.nth(vertex);
   74|     31|                return neighbors;
   75|     16|        let neighbors = graph.nth(vertex);
   76|      1|                return neighbors;
   78|     56|                return neighbors;
   80|      1|                return neighbors;
   81|      6|        let neighbors = get_neighbors(graph, current);
   86|     20|            let neighbors = graph.nth(u);
   87|      6|        let neighbors = get_neighbors(graph, current);
   88|     20|            let neighbors = graph.nth(u);
   92|      0|        let neighbors = graph.nth(vertex);
   97|     14|                let neighbors = graph(v);
   40|       |        fn Neighbor(&self, u: &V, v: &V) -> B;
   40|       |        fn Neighbor(&self, u: &V, v: &V) -> B;
   43|       |        fn Neighbor(&self, u: &V, v: &V) -> B;
   43|       |        fn Neighbor(&self, u: &V, v: &V) -> B;
   68|     20|        fn Neighbor(&self, u: &V, v: &V) -> B {
   71|     46|        fn Neighbor(&self, u: &V, v: &V) -> B {
   86|     19|        fn Neighbor(&self, u: &V, v: &V) -> B {
   89|  7.04k|        fn Neighbor(&self, u: &V, v: &V) -> B {
   66|      6|                if *neighbors.nth(i) == v {
   71|      6|                if *neighbors.nth(i) == v {
  117|    190|        fn neighbors(&self, v: &V) -> Set<V> {
  122|    263|        fn neighbors(&self, v: &V) -> Set<V> {
   49|       |        fn neighbors(&self, v: &V) -> Set<V>;
   53|       |        fn neighbors(&self, v: &V) -> Set<V>;
  103|     47|                    let neighbors_seq = neighbors.to_seq();
  112|     47|                    let neighbors_seq = neighbors.to_seq();
  117|     23|                    let neighbors_seq = neighbors.to_seq();
  124|     23|                let neighbors_seq = neighbors.to_seq();
  131|      2|Exercise 47.1: Nested Hash Table Implementation
   21|      3|        let nested: ArraySeqStPerS<ArraySeqStPerS<ArraySeqStPerS<T>>> =
   27|     13|        let nested: ArraySeqStPerS<ArraySeqStPerS<N>> =
    2|       |//! Parametric Nested Hash Table - Sequential Ephemeral (Chapter 47, Section 1.1).
   44|      2|        let nested = <ArraySeqStPerS<ArraySeqStPerS<Pair<N, char>>> as ArraySeqStPerTrait<
   54|      0|        let nested: ArraySeqStPerS<ArraySeqStPerS<Pair<N, &'static str>>> =
  298|      0|            writeln!(f, "NestedHashTable {{")?;
    4|       |pub mod NestedHashTable {
  343|       |    macro_rules! NestedHashTableLit {
  357|      0|    fn _nested_hash_table_lit_type_checks() {
  100|      4|        fn new() -> Self {
  101|      1|        fn new() -> Self
  102|      2|        fn new() -> Self {
  105|      1|        fn new() -> Self
  117|      1|        fn new() -> Self
   11|       |//! - `new`: Work O(n²), Span O(n²) for n vertices
   11|       |//! - `new`: Work O(n²), Span O(n²) for n vertices
   11|       |//! - `new`: Work O(n), Span O(n) for n vertices
   11|       |//! - `new`: Work O(n), Span O(n) for n vertices
   12|      4|        fn new() -> Self { Vec::new() }
  129|      2|        fn new() -> Self {
   12|       |//! - `new`: Work O(n²), Span O(n²) for n vertices
   12|       |//! - `new`: Work O(n²), Span O(n²) for n vertices
   12|       |//! - `new`: Work O(n), Span O(n) for n vertices
   12|       |//! - `new`: Work O(n), Span O(n) for n vertices
  132|      1|        fn new() -> Self {
   13|      4|        fn new() -> Self { LinkedList::new() }
  139|      2|        fn new() -> Self {
  143|       |        fn new() -> Self;
  144|      2|        fn new() -> Self {
  144|       |        fn new() -> Self;
  145|      0|        fn new() -> Self { AVLTreeSeqStEphS::new_root() }
  147|     67|        fn new() -> Self {
  149|     11|        fn new() -> Self { BSTSplayStEph { root: None } }
  151|    134|        fn new() -> Self {
  166|      0|        fn new() -> Self {
  168|      1|        fn new() -> Self { Self::empty() }
  168|      2|1. Create new table with size = current_size / 2
  169|      0|        fn new() -> Self { Self::empty() }
  179|      7|        fn new() -> Self { BSTKeyValueStEph { root: None, size: 0 } }
   17|       |        fn new() -> Self;
  181|     30|        fn new() -> Self { BSTTreapStEph { root: None } }
  182|    144|        fn new() -> Self {
  186|    135|        fn new() -> Self {
   19|       |        fn new() -> Self;
   19|       |        fn new() -> Self;
   19|       |        fn new() -> Self;
   19|       |        fn new() -> Self;
   19|       |        fn new() -> Self;
  200|      1|1. Create new hash table with target size
  200|      1|        fn new() -> AVLTreeS<T> { AVLTreeS::new_root() }
  203|      1|4. Return new table
  206|       |                           $crate::Chap38::BSTParaStEph::BSTParaStEph::ParamBSTTrait<_> >::new();
  206|    145|        fn new() -> Self {
  206|     19|        fn new() -> Self { BSTAVLStEph { root: None } }
   20|       |        fn new() -> Self;
   21|       |        fn new() -> Self;
   21|       |        fn new() -> Self;
   21|       |        fn new() -> Self;
   21|       |        fn new() -> Self;
  225|     17|        fn new() -> Self { BSTRBStEph { root: None } }
  228|     12|        fn new() -> Self { BSTBBAlphaStEph { root: None } }
   22|       |        fn new() -> Self
   22|       |        fn new() -> Self
   23|      0|        fn new() -> Self { FlatEntry::Empty }
  236|     11|        fn new() -> Self { BSTSizeStEph { root: None } }
   23|       |        fn new() -> Self
   23|       |        fn new() -> Self
   23|       |        fn new() -> Self
   23|       |        fn new() -> Self;
  242|    410|        fn new() -> Self {
   24|       |        fn new() -> Self
   24|       |        fn new() -> Self
   25|       |        fn new() -> Self
   25|       |        fn new() -> Self;
   27|       |        fn new() -> Self;
   27|       |        fn new() -> Self;
  280|     18|        fn new() -> Self {
  286|  4.12k|        fn new() -> Self {
  289|       |        fn new() -> Self;
   29|       |        fn new() -> Self;
   29|       |        fn new() -> Self;
   29|       |        fn new() -> Self;
   29|       |        fn new() -> Self;
   30|      5|        fn new() -> Self { ChainList::new() }
   30|       |        fn new() -> Self;
   30|       |        fn new() -> Self;
   33|       |        fn new() -> Self;
  342|    541|        fn new() -> Self {
   34|       |        fn new() -> Self;
   36|       |        fn new() -> Self;
   40|       |        fn new() -> Self;
   42|       |        fn new() -> Self;
   42|       |        fn new() -> Self;
   42|       |        fn new() -> Self;
   42|       |        fn new() -> Self;
   42|       |        fn new() -> Self;
   43|       |        fn new() -> Self;
   44|       |        fn new() -> Self;
   44|       |        fn new() -> Self;
   44|       |        fn new() -> Self;
   47|     24|        fn new() -> Self {
   48|       |        fn new() -> Self;
   48|       |        fn new() -> Self;
   50|       |        fn new() -> Self;
   50|       |        fn new() -> Self;
   56|       |        fn new() -> AVLTreeS<T>;
   61|      4|        fn new() -> Self {
   67|      0|        fn new() -> Self { SpinLock::new() }
   73|    153|        fn new() -> Self {
   77|      1|        fn new() -> Self
   81|      1|        fn new() -> Self
   83|       |        fn new() -> Self;
   86|      1|        fn new() -> Self
   88|      3|        fn new() -> Self {
    8|       |//! - `new`: Work O(1), Span O(1)
   90|      3|        fn new() -> Self {
   95|      1|        fn new() -> Self
   96|      1|        fn new() -> Self
  101|      8|            let new_adj = self.adj.insert(v, AVLTreeSetStPer::empty());
  108|      1|            let new_adj = self.adj.delete(&v_clone);
  129|     19|            let new_adj = self.adj.insert(u, neighbors);
  144|      2|                    let new_adj = self.adj.insert(u.clone(), new_neighbors);
   80|      1|            let new_adj = self.adj.delete(v);
   83|      2|            let new_adj = new_adj.map(|neighbors| neighbors.delete(&v_clone));
   90|     24|            if new_adj.find(&u).is_none() {
   93|     24|            if new_adj.find(&v).is_none() {
  100|     24|                adj: new_adj.insert(u, new_u_neighbors),
  109|    172|            let new_base = self.base_table.insert(k, v.clone());
  117|    172|                base_table: new_base,
  126|      2|            let new_base = self.base_table.delete(k);
  132|      2|                base_table: new_base,
  155|      1|            let new_base = self.base_table.map(f);
  157|      1|            let new_base = self.base_table.map(f);
  159|      1|                base_table: new_base,
  161|      1|                base_table: new_base,
  166|      1|            let new_base = self.base_table.map(f);
  168|      1|            let new_base = self.base_table.filter(f);
  170|      1|                base_table: new_base,
  170|      1|            let new_base = self.base_table.filter(f);
  172|      1|                base_table: new_base,
  174|      1|                base_table: new_base,
  179|      1|            let new_base = self.base_table.filter(f);
  183|      1|                base_table: new_base,
  183|      1|            let new_base = self.base_table.intersection(&other.base_table, f);
  187|      1|                base_table: new_base,
  196|      1|            let new_base = self.base_table.union(&other.base_table, f);
  200|      1|                base_table: new_base,
  209|      1|            let new_base = self.base_table.difference(&other.base_table);
  213|      1|                base_table: new_base,
  222|      1|            let new_base = self.base_table.restrict(keys);
  226|      1|                base_table: new_base,
  235|      1|            let new_base = self.base_table.subtract(keys);
  239|      1|                base_table: new_base,
  271|      8|            let new_base = self.base_table.get_key_range(k1, k2);
  275|      8|                base_table: new_base,
  284|     23|            let new_base = self.base_table.get_key_range(k1, k2);
  287|      1|            let new_base = OrderedTableStPer::join_key(&left.base_table, &right.base_table);
  288|     23|                base_table: new_base,
  297|      1|                base_table: new_base,
  306|      7|            let new_base = self.base_table.get_key_range(k1, k2);
  310|      7|                base_table: new_base,
  113|      1|                bits: new_bits,
  161|      0|                buckets: new_buckets,
  166|      1|                buckets: new_buckets,
  242|      0|                buckets: new_buckets,
  243|    129|                buckets: new_buckets,
   87|      2|                buckets: new_buckets,
   98|    122|                buckets: new_buckets,
   23|    107|        fn new(data: Box<[T]>) -> Self { Inner { data: Mutex::new(data) } }
  112|     64|                    let new_dist = OrderedF64::from(dist.0 + weight.0);
  112|     80|                    let new_dist = dist + (*weight as i64);
   37|    111|        fn new(dist: OrderedF64, vertex: usize) -> Self { PQEntry { dist, vertex } }
   37|    117|        fn new(dist: i64, vertex: usize) -> Self { PQEntry { dist, vertex } }
   75|    239|                        let new_dist = u_dist.saturating_add(*weight as i64);
   76|    239|                        if new_dist < min_dist {
   84|    183|                        let new_dist = OrderedF64::from(u_dist.0 + weight.0);
   85|    183|                        if new_dist < min_dist {
  125|     17|                let new_edge = if block_u < block_v {
  127|     40|                let new_edge = if u_center < v_center {
  133|     10|                let new_edge = if u_center < v_center {
  156|     36|                let new_edge = if u_center < v_center {
   87|     12|                let new_edge = if block_u < block_v {
   96|     13|                let new_edge = if u_center < v_center {
  100|      1|            let new_edges = self.edges.filter(move |edge| {
  103|      1|                edges: new_edges,
  106|      1|                edges: new_edges,
  110|     11|            let new_edges = self.edges.insert(Pair(u, v));
  113|     11|                edges: new_edges,
  113|      7|            let new_edges = self.edges.insert(Pair(u, v));
  116|      7|                edges: new_edges,
  119|      1|            let new_edges = self.edges.delete(&Pair(u.clone(), v.clone()));
  122|      1|                edges: new_edges,
  208|     25|        boruvka_mst(&remaining_vertices, &new_edges, new_mst_labels, rng)
  264|     20|        let new_edges = reroute_edges_mt(edges_arc, part_arc, 0, edges_len);
  268|     20|        boruvka_mst_mt(remaining_vec, new_edges, new_mst_labels, rng)
   97|      3|            let new_edges = self.edges.filter(|edge| {
   97|      3|        let new_edges_set = build_edges_parallel(edges_arc, vertex_map_arc, 0, n_edges);
  204|    487|            let new_elements = ArraySeqStPerS::append(&self.elements, &single_seq);
  101|    307|            let new_elem_seq = ArraySeqStPerS::singleton(element);
  528|  4.45k|                let new_entries = ArraySeqMtEphS::tabulate(
  221|      0|            let new_head = ArraySeqStPerS::singleton(new_pair);
  222|    129|            let new_head = ArraySeqStPerS::singleton(new_pair);
   65|      2|            let new_head = ArraySeqStPerS::singleton(new_pair);
   76|    122|            let new_head = ArraySeqStPerS::singleton(new_pair);
  248|    114|                    let new_heap = LeftistHeapPQ { root: melded_root };
  290|     18|                let (new_heap, min_element) = current_heap.delete_min();
  306|     10|                let (new_heap, min_element) = current_heap.delete_min();
   21|    234|        fn new(key: T) -> Self {
   22|  1.07k|        fn new(key: T, priority: u64) -> Self {
   22|    117|        fn new(key: K, value: V, priority: u64) -> Self {
   22|    204|        fn new(key: T) -> Self {
   22|    326|        fn new(key: T, priority: u64) -> Self {
   23|    494|        fn new(key: T) -> Self {
   23|    608|        fn new(key: T) -> Self {
   23|    624|        fn new(key: T) -> Self {
   24|  1.02k|        fn new(key: T, priority: u64) -> Self {
   24|  1.76k|        fn new(key: T) -> Self {
   25|  1.58k|        fn new(key: T) -> Self {
   26|    199|        fn new(key: K, value: V, priority: u64, reduced_value: R) -> Self {
   28|    174|        fn new(key: T) -> Self {
   30|  24.9k|        fn new(key: T) -> Self {
  101|      4|                    let new_left = set_rec(&n.left, index, value)?;
  102|     23|                    let new_left = set_rec(&n.left, index, value)?;
  102|      4|                    Ok(Some(rebalance(mk(n.value.clone(), new_left, n.right.clone()))))
  103|     23|                    Ok(Some(rebalance(mk(n.value.clone(), new_left, n.right.clone()))))
   23|    242|        fn new(left: BalBinTree<T>, value: T, right: BalBinTree<T>) -> Self { BalBinNode { left, value, right } }
  133|    271|                let new_len = self.elements.length() + 1;
  110|      1|        fn new(length: N, init_value: T) -> ArraySeqS<T> {
  114|       |        fn new(length: N, init_value: T) -> ArraySeqStEphS<T>;
  116|       |        fn new(length: N, init_value: T) -> ArraySeqMtPerS<T>;
  117|      9|        fn new(length: N, init_value: T) -> Self {
  141|      2|        fn new(length: N, init_value: T) -> ArraySeqStPerS<T> { ArraySeqStPerS::new(length, init_value) }
  158|      0|        fn new(length: N, init_value: T) -> Self {
   16|       |        fn new(length: N, init_value: T) -> ArraySeqMtPerS<T>;
   16|       |        fn new(length: N, init_value: T) -> ArraySeqStEphS<T>;
   16|       |        fn new(length: N, init_value: T) -> ArraySeqStPerS<T>;
  178|     66|        fn new(length: N, init_value: T) -> ArraySeqStEphS<T> { ArraySeqStEphS::new(length, init_value) }
  181|     14|        fn new(length: N, init_value: T) -> ArraySeqMtEphS<T> { ArraySeqMtEphS::new(length, init_value) }
  183|       |        fn new(length: N, init_value: T) -> Self
  185|      1|        fn new(length: N, init_value: T) -> ArraySeqS<T> { ArraySeqS::new(length, init_value) }
  188|      1|        fn new(length: N, init_value: T) -> ArraySeqMtPerS<T> { ArraySeqMtPerS::new(length, init_value) }
   18|       |        fn new(length: N, init_value: T) -> ArraySeqMtEphS<T>;
   20|       |        fn new(length: N, init_value: T) -> ArraySeqS<T>
  228|      0|        fn new(length: N, init_value: T) -> LinkedListStPerS<T>
  252|      1|        fn new(length: N, init_value: T) -> Self
   25|       |        fn new(length: N, init_value: T) -> LinkedListStPerS<T>
   26|       |        fn new(length: N, init_value: T) -> Self;
   40|       |        fn new(length: N, init_value: T) -> Self;
   64|      1|        fn new(length: N, init_value: T) -> ArraySeqMtEphS<T> {
   70|      2|        fn new(length: N, init_value: T) -> ArraySeqStPerS<T> {
   71|      1|        fn new(length: N, init_value: T) -> ArraySeqStEphS<T> {
   81|       |        fn new(length: N, init_value: T) -> ArraySeqStPerS<T>;
   82|      1|        fn new(length: N, init_value: T) -> ArraySeqMtPerS<T> {
   98|       |        fn new(length: N, init_value: T) -> ArraySeqMtEphS<T>;
  130|      1|        fn new_mt(inner: Self::Inner) -> Self { std::sync::Mutex::new(inner) }
  136|      1|        fn new_mt(inner: Self::Inner) -> Self { inner }
  143|      1|        fn new_mt(inner: Self::Inner) -> Self { inner }
  149|      1|        fn new_mt(inner: Self::Inner) -> Self { inner }
  155|      1|        fn new_mt(inner: Self::Inner) -> Self { inner }
  161|      1|        fn new_mt(inner: Self::Inner) -> Self { inner }
  167|      1|        fn new_mt(inner: Self::Inner) -> Self { inner }
  173|      1|        fn new_mt(inner: Self::Inner) -> Self { inner }
  179|      1|        fn new_mt(inner: Self::Inner) -> Self { inner }
  185|      1|        fn new_mt(inner: Self::Inner) -> Self { inner }
  192|      1|        fn new_mt(inner: Self::Inner) -> Self { inner }
  199|      1|        fn new_mt(inner: Self::Inner) -> Self { inner }
   68|       |        fn new_mt(inner: Self::Inner) -> Self;
   16|       |        fn new(n: N) -> Self;
   17|       |        fn new(n: N) -> Self;
   17|       |        fn new(n: N) -> Self;
   18|       |        fn new(n: N) -> Self;
   27|       |        fn new(n: N) -> Self;
   27|       |        fn new(n: N, source: N) -> Self;
   28|       |        fn new(n: N) -> Self;
   28|       |        fn new(n: N, source: N) -> Self;
   29|       |        fn new(n: N) -> Self;
   30|       |        fn new(n: N) -> Self;
   30|       |        fn new(n: N, source: N) -> Self;
   30|       |        fn new(n: N, source: N) -> Self;
   36|      9|        fn new(n: N) -> Self {
   37|     10|        fn new(n: N) -> Self {
   38|      9|        fn new(n: N) -> Self {
   39|      8|        fn new(n: N) -> Self {
  102|     11|            let new_neighbors = ArraySeqStPerS::from_vec(new_neighbors_vec);
  116|      2|                    let new_neighbors = neighbors.delete(&v_clone);
  131|      1|            let new_neighbors = ArraySeqStPerS::from_vec(new_neighbors_vec);
  143|      2|                    let new_neighbors = neighbors.delete(v);
   43|     11|            let new_node = Box::new(Node {
  133|    272|            let new_num_deleted = if was_dead {
  143|    272|                num_deleted: new_num_deleted,
  307|    157|            let new_num_deleted = if was_dead {
  317|    157|                num_deleted: new_num_deleted,
  101|    122|                num_elements: new_num_elements,
  127|    272|            let new_num_elements = if key_existed {
  142|    272|                num_elements: new_num_elements,
  235|      0|            let new_num_elements = if key_existed {
  236|    129|            let new_num_elements = if key_existed {
  243|      0|                num_elements: new_num_elements,
  246|    129|                num_elements: new_num_elements,
  301|    157|            let new_num_elements = if key_existed {
  316|    157|                num_elements: new_num_elements,
   80|      2|            let new_num_elements = if key_existed {
   88|      2|                num_elements: new_num_elements,
   91|    122|            let new_num_elements = if key_existed {
  220|      0|            let new_pair = Pair(key, value);
  221|    129|            let new_pair = Pair(key, value);
  267|    973|                let new_pair = Pair(key, combined_value);
  294|  2.58k|                let new_pair = Pair(key, value);
  527|  4.45k|                let new_pair = Pair(key, value);
   64|      2|            let new_pair = Pair(key, value);
   75|    122|            let new_pair = Pair(key, value);
  105|    104|            let (new_pq, min_element) = pq.delete_min();
  114|    117|            let new_pq = BalancedTreePQ {
  122|    232|            let new_pq = UnsortedListPQ { elements: new_elements };
  123|     85|            let (new_pq, min_element) = pq.delete_min();
  131|    253|            let new_pq = SortedListPQ { elements: new_elements };
  166|     34|                let (new_pq, min_element) = current_pq.delete_min();
  202|      2|            let new_pq = BalancedTreePQ {
  238|      0|            let new_pq = SortedListPQ { elements: new_elements };
  240|    214|            let new_pq = BinaryHeapPQ { elements: heapified };
  244|      2|                    let new_pq = BalancedTreePQ {
  247|      2|                    return (new_pq, true);
   51|     85|            let (new_pq, min_element) = pq.delete_min();
   69|     85|            let (new_pq, min_element) = pq.delete_min();
   85|    111|            let (new_pq, min_elem) = pq.delete_min();
   85|    117|            let (new_pq, min_elem) = pq.delete_min();
   87|     85|            let (new_pq, min_element) = pq.delete_min();
   92|     34|            let (new_pq, entry_opt) = pq.delete_min();
   43|     34|        fn new(priority: OrderedFloat<f64>, vertex: V, parent: Option<V>) -> Self {
   30|      5|                    Some((new_visited, new_rec_stack, new_result)) => {
   82|      8|                Some((new_visited, new_rec_stack, new_result)) => {
  110|    172|            let new_reduction = if self.base_table.size() == 0 {
  118|    172|                cached_reduction: new_reduction,
  129|      2|            let new_reduction = self.recalculate_reduction(&new_base);
  133|      2|                cached_reduction: new_reduction,
  156|      1|            let new_reduction = Self::calculate_reduction(&new_base, &self.reducer, &self.identity);
  158|      1|            let new_reduction = self.recalculate_reduction(&new_base);
  160|      1|                cached_reduction: new_reduction,
  162|      1|                cached_reduction: new_reduction,
  167|      1|            let new_reduction = Self::calculate_reduction(&new_base, &self.reducer, &self.identity);
  169|      1|            let new_reduction = Self::calculate_reduction(&new_base, &self.reducer, &self.identity);
  171|      1|                cached_reduction: new_reduction,
  171|      1|            let new_reduction = self.recalculate_reduction(&new_base);
  173|      1|                cached_reduction: new_reduction,
  175|      1|                cached_reduction: new_reduction,
  180|      1|            let new_reduction = Self::calculate_reduction(&new_base, &self.reducer, &self.identity);
  184|      1|                cached_reduction: new_reduction,
  184|      1|            let new_reduction = self.recalculate_reduction(&new_base);
  188|      1|                cached_reduction: new_reduction,
  197|      1|            let new_reduction = self.recalculate_reduction(&new_base);
  201|      1|                cached_reduction: new_reduction,
  210|      1|            let new_reduction = self.recalculate_reduction(&new_base);
  214|      1|                cached_reduction: new_reduction,
  223|      1|            let new_reduction = self.recalculate_reduction(&new_base);
  227|      1|                cached_reduction: new_reduction,
  236|      1|            let new_reduction = self.recalculate_reduction(&new_base);
  240|      1|                cached_reduction: new_reduction,
  272|      8|            let new_reduction = Self::calculate_reduction(&new_base, &self.reducer, &self.identity);
  276|      8|                cached_reduction: new_reduction,
  285|     23|            let new_reduction = Self::calculate_reduction(&new_base, &self.reducer, &self.identity);
  288|      1|            let new_reduction = if left.base_table.size() == 0 {
  289|     23|                cached_reduction: new_reduction,
  298|      1|                cached_reduction: new_reduction,
  307|      7|            let new_reduction = self.recalculate_reduction(&new_base);
  311|      7|                cached_reduction: new_reduction,
  106|      2|                    let new_right = set_rec(&n.right, index - ls - 1, value)?;
  107|     16|                    let new_right = set_rec(&n.right, index - ls - 1, value)?;
  187|     31|        fn new(root: &'a Link<T>) -> Self {
  291|      4|        fn new(root: &'a Link<T>) -> Self {
  125|     11|            let new_row = ArraySeqStPerS::from_vec(new_row_vec);
  107|      9|                let new_size = result.load_factor_manager.grow_size(table_size);
  143|      2|- resize(table, new_size): Create new table, rehash all key-value pairs
  150|      0|                let new_size = result.load_factor_manager.grow_size(table_size);
  171|      0|                let new_size = result.load_factor_manager.shrink_size(table_size);
  178|      0|                let new_size = result.load_factor_manager.shrink_size(table_size);
  227|      1|                                let new_size = result.load_factor_manager.shrink_size(table_size);
   77|     23|                let new_size = self.load_factor_manager.grow_size(table_size);
   94|      0|                let new_size = result.load_factor_manager.grow_size(table_size);
  164|     25|            let new_state = { rebuilt.root.borrow().clone() };
  171|      2|            let new_state = { merged.root.borrow().clone() };
  316|  1.62k|            let new_state = rebuilt.root.read().unwrap().clone();
  326|     27|            let new_state = merged.root.read().unwrap().clone();
  370|    206|            let new_state = rebuilt.root.read().unwrap().clone();
  380|      4|            let new_state = merged.root.read().unwrap().clone();
  140|    272|                table: new_table,
  215|     17|                                table: new_table,
  314|    157|                table: new_table,
   23|       |    // Newtype wrapper for key-value pairs that implements Display
  198|     78|            let new_u = full_partition.get(u).cloned().unwrap_or_else(|| u.clone());
  202|     78|            if new_u != new_v {
   24|       |        fn new(u: N) -> Self;
  285|     71|            let new_u = partition.get(u).cloned().unwrap_or_else(|| u.clone());
  288|     71|            if new_u != new_v {
   52|     14|        fn new(u: N) -> Self {
  106|      1|                let new_u_neighbors = u_neighbors.delete(v);
   98|     24|            let new_u_neighbors = u_neighbors.insert(v);
  199|     78|            let new_v = full_partition.get(v).cloned().unwrap_or_else(|| v.clone());
  286|     71|            let new_v = partition.get(v).cloned().unwrap_or_else(|| v.clone());
  105|     21|                        let new_value = Self::compute_cell_value_static(&seq_s_clone, &seq_t_clone, &table_clone, i, j);
  105|     21|                        let new_value = Self::compute_cell_value_static(&seq_s_clone, &seq_t_clone, &table_clone, i, j);
  106|  1.00k|                    let new_value = f(&pair.1);
  107|  1.00k|                    Pair(pair.0.clone(), new_value)
  123|  1.02k|                    let new_value = f(value);
  124|  1.02k|                    Pair(key.clone(), new_value)
  139|    205|                let new_value = f(&pair.0, &pair.1);
  142|    205|                    .insert(pair.0.clone(), new_value, |_old, new| new.clone());
  151|    303|                let new_value = f(&pair.0, &pair.1);
  154|    303|                    .insert(pair.0.clone(), new_value, |_old, new| new.clone());
  182|      0|                    let new_value = f(&pair.1);
  198|    528|                        let new_value = f_clone(&pair.1);
  199|    528|                        Pair(pair.0, new_value)
   19|       |        fn new(value: f64) -> Self;
  208|    528|                    let new_value = f(&pair.1);
  209|    528|                    Pair(pair.0, new_value)
   25|  20.5M|        fn new(value: T, index: N) -> Self {
   30|     39|        fn new(value: T, index: N) -> Self {
   89|     21|                    let new_value = self.compute_cell_value(table, i, j);
   89|     23|                    let new_value = self.compute_cell_value(&table, i, j);
  102|      1|                vertices: new_vertices,
  105|      1|                vertices: new_vertices,
  109|     11|            let new_vertices = self.vertices.insert(u.clone()).insert(v.clone());
  112|     11|                vertices: new_vertices,
  112|      7|            let new_vertices = self.vertices.insert(u.clone()).insert(v.clone());
  115|      7|                vertices: new_vertices,
   96|      1|            let new_vertices = self.vertices.delete(&v_clone);
   98|      1|            let new_vertices = self.vertices.delete(&v_clone);
  112|      0|            let (new_visited, new_result) = dfs_finish_order(graph, visited, result, neighbor);
  114|     18|            let (new_visited, sub_component) = dfs_reach(graph, visited, neighbor);
   31|     12|                let (new_visited, component) = dfs_reach(&transposed, visited, vertex);
   50|      9|                let (new_visited, new_result) = dfs_finish_order(graph, visited, result, start);
   51|      0|                let (new_visited, new_result) = dfs_finish_order(graph, visited, result, start);
   74|     18|            let (new_visited, new_result) = dfs_finish_order(graph, visited, result, neighbor);
  130|     13|            let new_weight = OrderedFloat(weight.0 + p_from.0 - p_to.0);
  146|     15|            let new_weight = (*weight as i64 + p_from - p_to) as i32;
   48|      0|        let new_x = mk(x.value.clone(), x.left.clone(), t2.clone());
   48|      0|        let new_x = mk(x.value.clone(), x.left.clone(), t2.clone());
   41|      0|        let new_y = mk(y.value.clone(), t2.clone(), y.right.clone());
   41|      0|        let new_y = mk(y.value.clone(), t2.clone(), y.right.clone());
   13|       |        pub next: Option<Box<NodeE<T>>>,
   13|       |        pub next: Option<Box<NodeP<T>>>,
   16|       |        pub next: Option<Box<Node<Key, Value>>>,
   24|  25.4k|                let next = current.wrapping_add(delta);
  343|       |                // Next power of 2
   48|  8.11k|                let next = unsafe { (*head).next };
   51|  8.11k|                    .compare_exchange_weak(head, next, Ordering::AcqRel, Ordering::Acquire)
   52|       |        // next(A, 'quinn') → 'rachel'
   58|       |        // next(A, 'mike') → 'rachel'
   40|       |        pub next_key: N,
   45|       |        pub next_key: N,
  225|      7|        fn next_key(&self, k: &K) -> Option<K> { self.base_table.next_key(k) }
  227|     10|        fn next_key(&self, k: &K) -> Option<K> {
  238|      7|        fn next_key(&self, k: &K) -> Option<K> { self.base_table.next_key(k) }
  240|     12|        fn next_key(&self, k: &K) -> Option<K> {
  259|      1|        fn next_key(&self, k: &K) -> Option<K> { self.base_table.next_key(k) }
  269|     12|        fn next_key(&self, k: &K) -> Option<K> {
   55|       |        fn next_key(&self, k: &K) -> Option<K>;
   58|       |        fn next_key(&self, k: &K) -> Option<K>;
   63|       |        fn next_key(&self, k: &K) -> Option<K>;
   63|       |        fn next_key(&self, k: &K) -> Option<K>;
   69|       |        fn next_key(&self, k: &K) -> Option<K>;
   72|       |        fn next_key(&self, k: &K) -> Option<K>;
  206|    187|        fn next(&mut self) -> Option<Self::Item> {
  229|      4|        fn next(&mut self) -> Option<Self::Item> {
  270|      6|        fn next(&mut self) -> Option<Self::Item> {
  311|     11|        fn next(&mut self) -> Option<Self::Item> {
  170|      8|        fn next(&self, k: &T) -> Option<T> {
  186|     22|        fn next(&self, k: &T) -> Option<T> {
  191|      8|        fn next(&self, k: &T) -> Option<T> {
   54|       |        fn next(&self, k: &T) -> Option<T>;
   55|       |        fn next(&self, k: &T) -> Option<T>;
   55|       |        fn next(&self, k: &T) -> Option<T>;
   96|    128|                return ng;
  100|  5.71k|        fn NGOfVertices(&self, u_set: &Set<V>) -> Set<V> {
  138|     10|        fn NGOfVertices(&self, u_set: &Set<V>) -> Set<V> {
   46|       |        fn NGOfVertices(&self, u_set: &Set<V>) -> Set<V>;
   46|       |        fn NGOfVertices(&self, u_set: &Set<V>) -> Set<V>;
   49|       |        fn NGOfVertices(&self, u_set: &Set<V>) -> Set<V>;
   49|       |        fn NGOfVertices(&self, u_set: &Set<V>) -> Set<V>;
   89|      3|        fn NGOfVertices(&self, u_set: &Set<V>) -> Set<V> {
   97|      2|        fn NGOfVertices(&self, u_set: &Set<V>) -> Set<V> {
   43|       |        fn NG(&self, v: &V) -> Set<V>;
   43|       |        fn NG(&self, v: &V) -> Set<V>;
   46|       |        fn NG(&self, v: &V) -> Set<V>;
   46|       |        fn NG(&self, v: &V) -> Set<V>;
   77|     99|        fn NG(&self, v: &V) -> Set<V> {
   82|    134|        fn NG(&self, v: &V) -> Set<V> {
   95|     13|        fn NG(&self, v: &V) -> Set<V> { self.NPlus(v).union(&self.NMinus(v)) }
   98|  12.5k|        fn NG(&self, v: &V) -> Set<V> { self.NPlus(v).union(&self.NMinus(v)) }
  100|      7|                let ng_u = self.NG(u);
  108|  11.4k|                    let ng_u = self.NG(&u);
  146|     13|                    let ng_u = self.NG(&u);
   92|      4|                let ng_u = self.NG(u);
  137|       |        fn ninject(a: &ArraySeqStPerS<T>, updates: &ArraySeqStPerS<Pair<N, T>>) -> ArraySeqStPerS<T>;
  157|       |        fn ninject(a: &ArraySeqMtPerS<T>, updates: &ArraySeqMtPerS<Pair<N, T>>) -> ArraySeqMtPerS<T>;
  163|       |        fn ninject(a: &ArraySeqMtEphS<T>, updates: &ArraySeqMtEphS<Pair<N, T>>) -> ArraySeqMtEphS<T>;
  189|      2|        fn ninject(a: &ArraySeqMtPerS<T>, updates: &ArraySeqMtPerS<Pair<N, T>>) -> ArraySeqMtPerS<T> {
  208|      3|        fn ninject(a: &ArraySeqStPerS<T>, updates: &ArraySeqStPerS<Pair<N, T>>) -> ArraySeqStPerS<T> {
  230|       |        fn ninject(a: &Self, updates: &LinkedListStEphS<Pair<N, T>>) -> Self;
  272|      4|        fn ninject(a: &ArraySeqMtPerS<T>, updates: &ArraySeqMtPerS<Pair<N, T>>) -> ArraySeqMtPerS<T> {
  284|      7|        fn ninject(a: &ArraySeqStPerS<T>, updates: &ArraySeqStPerS<Pair<N, T>>) -> ArraySeqStPerS<T> {
  321|      2|        fn ninject(a: &LinkedListStPerS<T>, updates: &LinkedListStPerS<Pair<N, T>>) -> LinkedListStPerS<T> {
  348|      2|        fn ninject(a: &Self, updates: &LinkedListStEphS<Pair<N, T>>) -> Self {
  356|      1|        fn ninject(a: &Self, updates: &[(N, T)]) -> Self {
  367|      1|        fn ninject(a: &ArraySeqMtEphS<T>, updates: &ArraySeqMtEphS<Pair<N, T>>) -> ArraySeqMtEphS<T> {
   44|       |        fn ninject(a: &ArraySeqMtPerS<T>, updates: &ArraySeqMtPerS<Pair<N, T>>) -> ArraySeqMtPerS<T>;
   60|       |        fn ninject(a: &ArraySeqStPerS<T>, updates: &ArraySeqStPerS<Pair<N, T>>) -> ArraySeqStPerS<T>;
   66|       |        fn ninject(a: &LinkedListStPerS<T>, updates: &LinkedListStPerS<Pair<N, T>>) -> LinkedListStPerS<T>;
   72|       |        fn ninject(a: &Self, updates: &[(N, T)]) -> Self;
   23|     32|            let n_left = left.length();
   28|    151|            let n_left = left.length();
   30|     31|            if n_left == 0 {
  313|      9|                    set_link(&mut n.left, index, value)
   35|    137|            if n_left == 0 {
  426|      0|                    set_link(&mut n.left, index, value)
   44|     31|                if n_left == 1 && n_right == 1 {
   65|     56|            if n_left >= n_right {
  104|      8|                    Ok(Some(mk(value, n.left.clone(), n.right.clone())))
  105|     27|                    Ok(Some(mk(value, n.left.clone(), n.right.clone())))
  107|      2|                    Ok(Some(rebalance(mk(n.value.clone(), n.left.clone(), new_right))))
  108|     14|                    Ok(Some(rebalance(mk(n.value.clone(), n.left.clone(), new_right))))
  135|      1|        fn NMinusOfVertices(&self, u_set: &Set<V>) -> Set<V> {
  290|  5.01k|        fn NMinusOfVertices(&self, u_set: &Set<V>) -> Set<V> {
   58|       |        fn NMinusOfVertices(&self, u_set: &Set<V>) -> Set<V>;
   61|       |        fn NMinusOfVertices(&self, u_set: &Set<V>) -> Set<V>;
  116|     40|        fn NMinus(&self, v: &V) -> Set<V> {
  195|  31.7k|        fn NMinus(&self, v: &V) -> Set<V> {
   52|       |        fn NMinus(&self, v: &V) -> Set<V>;
   55|       |        fn NMinus(&self, v: &V) -> Set<V>;
  325|      1|        output.push_str(&format!("  {}\n\n", stats));
  103|       |                // No changes, converged - build result
  175|      1|                return "No collisions".to_string();
  203|       |    // No custom implementation needed when B = bool
   21|       |    // No custom implementations needed when B = bool
   94|       |                // No changes, converged - build result
  105|  5.11k|        match node {
  105|     89|            let node = insert_at_link(self.root.take(), len, value, &mut self.next_key);
  107|    360|                    if node
  112|  1.13k|                    if node
  113|  2.62k|                    if node
  118|      0|                    let node = Box::from_raw(current);
  120|     29|        match node {
  125|  5.43k|                    if node
  129|    674|            Self::update(&mut node);
  130|    127|        match node {
  136|      3|            let node = insert_at_link(self.root.take(), len, value, &mut self.next_key);
  138|      0|            Self::update_node(&mut node);
  138|    102|            guard.as_ref().map_or(0, |node| node.size)
  145|     11|            guard.as_ref().map_or(0, |node| node.height as N)
  171|    263|            Self::update(&mut node);
  179|    759|                    if node
  207|    187|            let node = self.stack.pop()?;
  275|      6|            let node = self.stack.pop()?;
  276|   117M|        match node {
  304|  15.7k|            guard.as_ref().map_or(0, |node| node.size)
  308|     35|        match node {
  312|     11|            let node = self.stack.pop()?;
  372|      7|                match node {
  389|     59|        match node {
  421|      7|        match node {
   43|  2.22k|        guard.as_ref().map_or(i64::MIN, |node| node.priority)
   48|  2.26k|        guard.as_ref().map_or(0, |node| node.size)
   75|  5.27k|        match node {
   76|  11.2M|            let node = cur.as_ref().expect("index out of bounds");
   76|  2.66k|            let node = cur.as_ref().expect("index out of bounds");
   84|     17|            Self::update_size(&mut node);
   90|  5.13k|        match node {
   98|  7.20k|            let Node { value, .. } = *boxed;
  107|     19|        fn node_at_mut(&mut self, index: N) -> Option<&mut NodeE<T>> {
  154|    226|        fn node_at(&self, index: N) -> Option<&NodeP<T>> {
   91|    240|        fn node_at(&self, index: N) -> Option<&NodeE<T>> {
   18|       |    struct NodeInner<T: MtKey> {
   20|       |    struct NodeInner<T: MtKey> {
   20|       |    struct NodeInner<T: StT + Ord> {
   13|       |    struct Node<K: StT + Ord, V: StT> {
   15|       |    struct Node<K: StT + Ord, V: StT, R: StT> {
  257|    105|                    if &node.key > low {
  262|    105|                    if &node.key >= low && &node.key <= high {
  267|    105|                    if &node.key < high {
   36|      6|                if node.key == key {
   54|     13|                if &node.key == key {
  106|     49|                    Self::insert_link(&mut node.left, value, rng);
  107|    342|                    Self::insert_link(&mut node.left, value, rng);
  112|      0|        fn node(left: Self, value: T, right: Self) -> Self { BalBinTree::node(left, value, right) }
  116|      0|                            Self::rotate_left(&mut node.left);
  116|    102|                            Self::rotate_left(&mut node.left);
  119|     56|                    Self::insert_link(&mut node.left, value, rng);
  120|    567|                        Self::insert_link(&mut node.left, value)
  138|    114|                        Self::insert_link(&mut node.left, value);
  138|  2.08k|                        Self::insert_link(&mut node.left, value);
  159|     78|                    Self::insert_link(&mut node.left, value);
  173|     19|                    Self::insert_link(&mut node.left, key, value, rng);
  176|  3.17k|                    Self::insert_link(&mut node.left, value);
   32|       |        fn node(left: Self, value: T, right: Self) -> Self;
   78|  1.23k|                        Self::insert_link(&mut node.left, value)
   78|  2.06k|                        Self::insert_link(&mut node.left, value)
   80|    149|                        Self::insert_link(&mut node.left, value)
  101|      9|                    if node.left.as_ref().map_or(false, |left| left.priority < node.priority) {
  107|     49|                    if node.left.as_ref().map_or(false, |left| left.priority < node.priority) {
  108|    342|                    if node.left.as_ref().map_or(false, |left| left.priority < node.priority) {
  120|     56|                    if node.left.as_ref().map_or(false, |left| left.priority < node.priority) {
  174|     19|                    if node.left.as_ref().map_or(false, |left| left.priority < node.priority) {
   81|  1.25k|                .map(|node| (node.left.clone(), node.key.clone(), node.priority, node.right.clone()))
   79|  7.89k|                let node_ptr = Box::into_raw(new_node);
   82|  7.89k|                    .compare_exchange_weak(head, node_ptr, Ordering::AcqRel, Ordering::Acquire)
   96|  7.21k|            let node_ptr = self.raw_pop()?;
   85|    724|            let node_rank = final_right.rank() + 1;
   91|    724|                rank: node_rank,
  128|  1.10k|            let node_reduced = Op::lift(&node.value);
  134|      0|            let node_reduced = Op::lift(&value);
  194|    199|                let node_reduced = Op::lift(&value);
  111|  1.13k|                    Self::insert_link(&mut node.right, value, rng);
  112|  2.62k|                    Self::insert_link(&mut node.right, value, rng);
  122|  2.65k|                        Self::insert_link(&mut node.right, value)
  123|      0|                            Self::rotate_right(&mut node.right);
  123|      8|                            Self::rotate_right(&mut node.right);
  124|  5.43k|                    Self::insert_link(&mut node.right, value, rng);
  140|    693|                        Self::insert_link(&mut node.right, value);
  140|  9.00k|                        Self::insert_link(&mut node.right, value);
  161|    541|                    Self::insert_link(&mut node.right, value);
  178|   112k|                    Self::insert_link(&mut node.right, value);
  178|    759|                    Self::insert_link(&mut node.right, key, value, rng);
   80|  6.03k|                        Self::insert_link(&mut node.right, value)
   80|  6.97k|                        Self::insert_link(&mut node.right, value)
   82|  10.9k|                        Self::insert_link(&mut node.right, value)
   13|       |    struct Node<T: StTInMtT> {
   13|       |    struct Node<T: StT + Ord> {
   13|       |    struct Node<T: StT + Ord> {
   13|       |    struct Node<T: StT + Ord> {
   13|       |    struct Node<T: StT + Ord> {
   14|       |    struct Node<T: StT> {
   14|       |    struct Node<T: StTInMtT> {
   14|       |    struct Node<T: StTInMtT + Ord> {
   15|       |    struct Node<T: StTInMtT + Ord> {
   15|       |    struct Node<T: StTInMtT + Ord> {
   15|       |    struct Node<T: StTInMtT + Ord> {
   15|       |    struct Node<T: StT + Ord> {
   17|       |    struct Node<T: StTInMtT + Ord> {
   19|       |    struct Node<T: StT + Ord> {
   21|       |    struct Node<T: StTInMtT + Ord> {
  120|    226|                .map(|node| &node.value)
   47|    240|                .map(|node| &node.value)
   81|  1.29k|                return &node.value;
   81|  2.39M|                return &node.value;
  100|     16|                | None => None,
  102|      1|                return None;
  104|      1|                return None;
  104|       |                    | None => {
  105|     67|                | None => {
  106|      3|                    | None => Some(key),
  109|      1|                return None;
  109|      1|                return None;
   11|      0|            | (None, None) => None,
  112|      0|                    return None;
  112|      1|                return None;
  113|      0|                | None => None,
  114|      0|                    return None;
  115|      1|                return None;
  115|      2|                | None => None,
  115|      3|                    | None => Some(&node.key),
  117|     15|                    | None => Some(&node.key),
  117|      1|                return None;
  117|      1|                return None;
  119|      0|            | None => println!("last(A) = ⊥"),
  119|      0|                    return None;
  119|      1|                return None;
   12|      0|            | (None, None) => None,
  122|      0|                    return None;
  122|     19|                secondary_clustering: None,
  123|      0|                | None => None,
  123|     19|                double_hashing_quality: None,
  123|    237|                | None => (ParamTreap::new(), false, ParamTreap::new()),
  123|    720|                return None;
  124|  11.7k|                return None;
  124|      7|                | None => AVLTreeSetStEph::singleton(v.clone()),
  125|      0|            | None => println!("previous(A, 'rachel') = ⊥"),
  125|      0|                    return None;
  125|  1.27M|                return None;
  125|      2|                | None => None,
  125|      2|                    | None => Some(&node.key),
  127|      0|                    return None;
  127|      0|                    return None;
  127|     15|                    | None => Some(&node.key),
  127|      9|                | None => AVLTreeSetStPer::singleton(v.clone()),
  128|      2|                | None => None,
  128|     57|                    | None => None,
   12|      8|            | (None, Some(_)) => b,
  129|      0|                    return None;
  130|     10|                | None => None,
  131|     25|                | None => None,
  131|       |                | None => {
   13|      4|            | (None, Some(_)) => b,
  135|     15|                | None => None,
  136|      0|                    | None => return LinkedListStPerS::empty(),
  138|     28|                    | None => Some(key),
  139|     10|                | None => AVLTreeSetStPer::empty(),
  140|      0|                | None => false,
  141|     13|                parent: None,
  143|      0|                | None => None,
  143|      4|                | None => None,
  144|     36|                | None => left,
  145|      1|                    | None => Some(&node.key),
  145|      2|                | None => None,
  145|       |                | None => {
  145|       |                | None => {
  146|      3|                | None => None,
  147|      0|                | None => self.clone(),
  147|     10|                    | None => Some(&node.key),
  148|      1|                    | None => break,
  148|     22|                    | None => Some(&node.key),
  148|      7|                parent: None,
  150|      2|                | None => None,
   15|      0|            | (None, None) => None,
  152|     13|                parent: None,
  152|     17|                    | None => Some(&node.key),
  153|      0|                | None => None,
  154|      0|                | None => false,
  155|      1|                    | None => Some(&node.key),
  155|   230k|                | None => None,
  155|     23|                | None => None,
  155|      2|                | None => None,
  156|      1|                return None;
  156|      3|                | None => None,
  157|     10|                    | None => Some(&node.key),
  157|      7|                parent: None,
  158|      0|                | None => None,
  158|     22|                    | None => Some(&node.key),
  158|     65|                    | None => 0,
  158|      8|                | None => b.clone(),
  160|      1|                    | None => Some(&node.key),
  160|      2|                | None => None,
   16|      0|            | (None, None) => None,
   16|      0|            | (None, None) => None,
   16|      0|            | (None, Some(_)) => b,
  162|      0|                | None => false,
  162|     17|                    | None => Some(&node.key),
  163|     16|                primary_clustering: None,
  165|     16|                double_hashing_quality: None,
  165|    274|                return None;
  168|      0|                | None => None,
  170|      1|                    | None => Some(&node.key),
  170|      2|                | None => None,
  170|      2|                | None => None,
   17|      0|            | (None, Some(_)) => b,
   17|      0|            | (None, Some(_)) => b,
  172|    429|                    | None => Some(&node.key),
  172|      8|                    | None => Some(&node.key),
  174|      6|                | None => None,
  174|      8|                | None => ParamTreap::new(),
  177|      4|                | None => None,
  179|     94|                    | None => 0,
  180|      2|                | None => None,
  180|      2|                | None => None,
  182|    429|                    | None => Some(&node.key),
  182|      8|                    | None => Some(&node.key),
  186|      2|                | None => 0,
  188|    101|                    | None => 0,
  189|      2|                | None => None,
  190|     31|                current: None,
  190|     75|                    | None => 0,
   19|      0|            | (None, None) => None,
  191|     16|                | None => None,
  191|      6|                    | None => Some(&node.key),
  192|      0|                | None => None,
  194|      3|                    | None => Some(&node.key),
  194|      9|                | None => ParamTreap::new(),
  199|      2|                | None => None,
   20|      0|            | (None, Some(_)) => b,
  201|     16|                primary_clustering: None,
  201|      6|                    | None => Some(&node.key),
  201|      9|                | None => None,
  202|      0|                | None => None,
  202|      0|                | None => None,
  202|     16|                secondary_clustering: None,
  204|      2|                    | None => Some(&node.key),
  206|      2|                | None => None,
  208|     78|                    | None => Some(&node.key),
  211|    355|                    | None => 0,
   21|      2|                return None;
   21|      2|                return None;
   21|      2|                return None;
  214|     14|                | None => ParamTreap::new(),
  215|    186|                    | None => 0,
  216|      2|                | None => None,
  216|      2|                | None => None,
  218|      2|                | None => (None, None),
  218|    329|                    | None => 0,
  218|     78|                    | None => Some(&node.key),
  218|      8|                    | None => Some(&node.key),
  226|      2|                | None => None,
  228|      8|                    | None => Some(&node.key),
   23|      2|                return None;
  234|    159|                    | None => 0,
  237|      0|                    | None => 0,
  245|  1.00k|                    | None => 0,
  245|      6|                | None => identity,
   25|      1|                return None;
   25|    234|                left: None,
  252|     65|                | None => Op::identity(),
   26|    234|                right: None,
   27|  1.07k|                left: None,
   27|    117|                left: None,
   27|    204|                left: None,
   27|    326|                left: None,
  273|  5.91k|                    | None => 0,
   27|    494|                left: None,
   27|    624|                left: None,
  277|       |            | None => {
   28|  1.07k|                right: None,
   28|    117|                right: None,
   28|      1|                return None;
   28|    204|                right: None,
  282|     18|                root: None,
   28|    326|                right: None,
   28|    494|                right: None,
   28|    624|                right: None,
   29|  1.02k|                left: None,
   29|  1.58k|                left: None,
   29|  1.76k|                left: None,
   29|      2|                    return None; // Cycle detected
  294|    104|                    | None => 0,
  294|      4|                current: None,
   30|  1.02k|                right: None,
   30|  1.58k|                right: None,
   30|  1.76k|                right: None,
  309|      2|            | None => Err("Index out of bounds"),
   31|  20.5M|                left: None,
   32|      1|            return (None, i32::MIN / 2, i32::MIN / 2, 0); // (-∞, -∞, -∞, 0)
   32|      1|            return (None, i32::MIN / 2, i32::MIN / 2, 0); // (-∞, -∞, -∞, 0)
   32|  20.5M|                right: None,
   33|    174|                left: None,
   33|    199|                left: None,
   34|    174|                right: None,
   34|    199|                right: None,
   34|      1|                return None;
   35|      1|                return None;
   35|  24.9k|                left: None,
   36|  24.9k|                right: None,
   36|     39|                left: None,
  365|      1|                primary_clustering: None,
  366|      1|                secondary_clustering: None,
  367|      1|                double_hashing_quality: None,
   37|     39|                right: None,
  390|       |            | None => {
   39|      0|            | None => println!("  Invalid path"),
   41|      0|            | None => println!("Invalid path"),
  422|      2|            | None => Err("Index out of bounds"),
   44|      1|                return None;
   45|      0|            | None => println!("  Invalid path"),
   45|      1|                return None;
   46|      8|                    return None;
   49|      0|            | None => println!("first(A) = ⊥"),
   51|      0|            | None => println!("  Invalid path"),
   53|      5|                    | None => Some(ending_max),
   55|      0|            | None => println!("next(A, 'quinn') = ⊥"),
   55|      5|                    | None => Some(ending_max),
   57|      1|                | None => Err("Index out of bounds"),
   61|      0|            | None => println!("next(A, 'mike') = ⊥"),
   63|     82|                | None => Exposed::Leaf,
   65|      0|                return None;
   66|      0|                return None;
   67|      2|            return None; // Cycle detected
   68|   578k|                root: None,
   70|      8|                | None => Exposed::Leaf,
   71|      2|                return None;
   71|     34|                | None => {
   73|      0|                    | None => return LinkedListStEphS::empty(),
   75|      1|                return None; // -∞
   76|      1|                return None; // -∞
   77|      0|            | None => println!("Invalid path"),
   77|     65|                    | None => 0,
   82|      0|                return None;
   83|     45|                | None => {
   84|      0|                return None;
   84|      0|                return None;
   84|      1|                | None => false,
   84|      2|                | None => false,
   85|      1|                    | None => break,
   87|      0|            | None => println!("select(A, 5) = ⊥"),
   87|      0|                return None;
   87|  4.31k|                | None => Exposed::Leaf,
   88|      0|                return None;
   88|      0|                return None;
   89|      0|                return None;
   89|     46|                root: None,
   89|       |                | None => {
   89|       |                | None => {
   90|      0|                return None;
   90|      0|                return None;
   91|      2|                | None => AVLTreeSetStEph::empty(),
   91|       |                | None => {
   91|       |            | None => {
   91|       |            | None => {
   92|      0|            | None => println!("Invalid path"),
   92|      0|                return None;
   92|      2|                | None => AVLTreeSetStPer::empty(),
   93|      0|                    Ok(Some(mk(value, None, None)))
   93|      1|                return None;
   94|      0|                    Ok(Some(mk(value, None, None)))
   97|      0|                | None => break,
   98|      2|                | None => None,
   21|       |    const NO_PREDECESSOR: usize = usize::MAX;
   21|       |    const NO_PREDECESSOR: usize = usize::MAX;
   22|       |    const NO_PREDECESSOR: usize = usize::MAX;
   22|       |    const NO_PREDECESSOR: usize = usize::MAX;
   23|       |    const NO_PREDECESSOR: usize = usize::MAX;
   24|       |    const NO_PREDECESSOR: usize = usize::MAX;
   24|       |    const NO_PREDECESSOR: usize = usize::MAX;
   24|       |    const NO_PREDECESSOR: usize = usize::MAX;
   64|       |                    // Normalize edge order
   95|       |                // Normalize edge order for undirected graph
  184|       |                    let normalized_edge = if $v1 <= $v2 {
  234|       |                    let normalized_edge = if $v1 <= $v2 {
   87|    131|            let normalized_edge = if v1 <= v2 {
   93|      5|            let normalized_edge = if v1 <= v2 {
  129|      0|        fn normalize_edge(_v1: V, _v2: V) -> LabEdge<V, L> {
  179|      0|        fn normalize_edge(_v1: V, _v2: V) -> LabEdge<V, L> {
   52|       |        fn normalize_edge(v1: V, v2: V) -> LabEdge<V, L>;
   56|       |        fn normalize_edge(v1: V, v2: V) -> LabEdge<V, L>;
  111|       |    // Note: StT + Send + Sync is already covered by existing StTInMtT trait
  121|       |    /// Note: Could be parallelized with filter operation, but overhead likely not worth it
  158|       |    // Note: IntoIterator not implemented for ArraySeqMtPerS, so we don't provide it here
  166|       |    // Note: IntoIterator not implemented for ArraySeqMtPerS, so we don't provide it here
  182|       |    // Note: IntoIterator not implemented for ArraySeqMtEphS, so we don't provide it here
  199|       |        // Note: Union uses a simple merge strategy to avoid thread explosion.
  202|       |    // Note: bool already has MtT implementation above (line ~112)
  205|       |    // Note: IntoIterator not implemented for ArraySeqMtEphS, so we don't provide it here
   20|       |    // Note: bool already implements Display, Debug, Not, etc.
   20|       |        /// Note: Hardware fetch_add is single atomic op; CAS loop may retry under contention, so cannot outperform native.
   24|       |    /// Note: Exponential work makes this impractical for large n. This demonstrates
   48|       |        // Note: Start with first element (not empty prefix) since empty sequence is not allowed
   49|       |        // Note: Start with first element (not empty prefix) since empty sequence is not allowed
    4|       |//! Historical Note: Based on the divide-and-conquer algorithm first designed by Michael Shamos
    4|       |//! Historical Note: This divide-and-conquer algorithm was first designed by Michael Shamos
    4|       |//! Historical Note: This parallel work-optimal version builds on the original divide-and-conquer
    4|       |//! Historical Note: This work-optimal strengthened version builds on the original divide-and-conquer
    4|       |//! Note: NOW uses true parallelism via ParaPair! for neighbor/degree operations.
    4|       |//! Note: NOW uses true parallelism via ParaPair! for neighbor/degree operations.
    4|       |//! Note: NOW uses true parallelism via ParaPair! for neighbor operations.
    4|       |//! Note: NOW uses true parallelism via ParaPair! for neighbor operations.
    4|       |//! Note: NOW uses true parallelism via ParaPair! for weighted neighbor operations.
    4|       |//! Note: NOW uses true parallelism via ParaPair! for weighted neighbor operations.
    4|       |//! Note: NOW uses true parallelism via ParaPair! for weighted neighbor operations.
    4|       |//! Note: NOW uses true parallelism via ParaPair! for weighted neighbor operations.
  126|      1|        fn NPlusOfVertices(&self, u_set: &Set<V>) -> Set<V> {
  245|  5.01k|        fn NPlusOfVertices(&self, u_set: &Set<V>) -> Set<V> {
   55|       |        fn NPlusOfVertices(&self, u_set: &Set<V>) -> Set<V>;
   58|       |        fn NPlusOfVertices(&self, u_set: &Set<V>) -> Set<V>;
  106|     39|        fn NPlus(&self, v: &V) -> Set<V> {
  145|  26.3k|        fn NPlus(&self, v: &V) -> Set<V> {
   49|       |        fn NPlus(&self, v: &V) -> Set<V>;
   52|       |        fn NPlus(&self, v: &V) -> Set<V>;
   24|     32|            let n_right = right.length();
   29|    151|            let n_right = right.length();
  318|     15|                    set_link(&mut n.right, index - left_size - 1, value)
   33|     31|            if n_right == 0 {
   38|    107|            if n_right == 0 {
  431|      2|                    set_link(&mut n.right, index - left_size - 1, value)
  107|       |        fn nth_cloned(&self, index: N) -> T;
  124|    308|        fn nth_cloned(&self, index: N) -> T {
  189|      2|        fn nth_cloned(&self, index: N) -> T { ArraySeqMtEphS::nth_cloned(self, index) }
   26|       |        fn nth_cloned(&self, index: N) -> T;
   44|       |        fn nth_cloned(&self, index: N) -> T;
   84|      2|        fn nth_cloned(&self, index: N) -> T { ArraySeqMtEphTraitChap18::nth_cloned(self, index) }
  295|   197M|    fn nth_link<'a, T: StT>(node: &'a Link<T>, index: N) -> &'a T {
  408|     30|    fn nth_link<'a, T: Copy + Debug>(node: &'a Link<T>, index: N) -> &'a T {
  299|  75.9M|            return nth_link(&n.left, index);
  412|      3|            return nth_link(&n.left, index);
   74|  1.29k|    fn nth_ref<'a, T: StTInMtT>(mut cur: &'a Link<T>, mut index: N) -> &'a T {
   74|  2.39M|    fn nth_ref<'a, T: StT>(mut cur: &'a Link<T>, mut index: N) -> &'a T {
  102|      2|        fn nth(&self, index: N) -> &T { ArraySeqMtPerTraitChap18::nth(self, index) }
  123|       |        fn nth(&self, index: N) -> &T;
  127|     72|        fn nth(&self, index: N) -> &T { &self.data[index] }
  128|       |        fn nth(&self, index: N) -> &T;
  143|     17|        fn nth(&self, index: N) -> &T { ArraySeqStPerS::nth(self, index) }
  147|       |        fn nth(&self, index: N) -> &T;
  148|       |        fn nth(&self, index: N) -> &T;
  149|  40.6M|        fn nth(&self, index: N) -> &T { nth_link(&self.root, index) }
  170|  1.29k|        fn nth(&self, index: N) -> &T { nth_ref(&self.root, index) }
  171|  2.39M|        fn nth(&self, index: N) -> &T { nth_ref(&self.root, index) }
  175|     33|        fn nth(&self, index: N) -> &T { &self.data[index] }
  186|     11|        fn nth(&self, index: N) -> &T { ArraySeqStEphS::nth(self, index) }
  192|      2|        fn nth(&self, index: N) -> &T { ArraySeqMtPerS::nth(self, index) }
  193|     21|        fn nth(&self, index: N) -> &T { ArraySeqS::nth(self, index) }
  194|       |        fn nth(&self, index: N) -> &T;
  206|     23|        fn nth(&self, index: N) -> &T { nth_link(&self.root, index) }
  238|      0|        fn nth(&self, index: N) -> &T { LinkedListStPerS::nth(self, index) }
   24|       |        fn nth(&self, index: N) -> &T;
   24|       |        fn nth(&self, index: N) -> &T;
   24|       |        fn nth(&self, index: N) -> &T;
  265|      0|        fn nth(&self, index: N) -> &T { LinkedListStEphS::nth(self, index) }
   34|       |        fn nth(&self, index: N) -> &T;
   38|       |        fn nth(&self, index: N) -> &T;
   39|       |        fn nth(&self, index: N) -> &T;
   52|       |        fn nth(&self, index: N) -> &T;
   64|       |        fn nth(&self, index: N) -> &T;
   87|       |        fn nth(&self, index: N) -> &T;
   90|      2|        fn nth(&self, index: N) -> &T { ArraySeqStPerTraitChap18::nth(self, index) }
   91|      2|        fn nth(&self, index: N) -> &T { ArraySeqStEphTraitChap18::nth(self, index) }
   74|  7.20k|                next: null_mut(),
   44|       |        /// Number of vertices.
   45|       |        /// Number of vertices.
   46|       |        /// Number of vertices.
   47|       |        /// Number of vertices.
  255|       |        pub num_collisions: N,
   22|       |        fn num_edges(&self) -> N;
   23|       |        fn num_edges(&self) -> N;
   23|       |        fn num_edges(&self) -> N;
   23|       |        fn num_edges(&self) -> N;
   24|       |        fn num_edges(&self) -> N;
   24|       |        fn num_edges(&self) -> N;
   25|       |        fn num_edges(&self) -> N;
   25|       |        fn num_edges(&self) -> N;
   25|       |        fn num_edges(&self) -> N;
   27|       |        fn num_edges(&self) -> N;
   49|      8|        fn num_edges(&self) -> N {
   51|      2|        fn num_edges(&self) -> N {
   55|      2|        fn num_edges(&self) -> N {
   55|      6|        fn num_edges(&self) -> N {
   56|      3|        fn num_edges(&self) -> N {
   57|      7|        fn num_edges(&self) -> N {
   59|      5|        fn num_edges(&self) -> N { self.edges.size() }
   60|      1|        fn num_edges(&self) -> N {
   60|      7|        fn num_edges(&self) -> N { self.edges.size() }
   62|      5|        fn num_edges(&self) -> N { self.edges.size() }
  252|       |        pub num_elements: N,
   28|       |        pub num_elements: N,
  130|     14|        fn num_keys(&self) -> usize { self.keys.len() }
  159|     14|        fn num_keys(&self) -> usize { self.keys.len() }
  179|      9|        fn num_keys(&self) -> usize { self.keys.len() }
  218|      6|        fn num_keys(&self) -> usize {
   45|       |        fn num_keys(&self) -> usize;
   48|       |        fn num_keys(&self) -> usize;
   54|       |        fn num_keys(&self) -> usize;
   54|       |        fn num_keys(&self) -> usize;
  134|     12|        fn num_matrices(&self) -> usize { self.dimensions.len() }
  164|      7|        fn num_matrices(&self) -> usize { self.dimensions.len() }
  175|     12|        fn num_matrices(&self) -> usize { self.dimensions.len() }
  213|      7|        fn num_matrices(&self) -> usize {
   43|       |        fn num_matrices(&self) -> usize;
   45|       |        fn num_matrices(&self) -> usize;
   51|       |        fn num_matrices(&self) -> usize;
   52|       |        fn num_matrices(&self) -> usize;
  215|      0|        fn num_sets(&mut self) -> usize {
   37|       |        fn num_sets(&mut self) -> usize;
   20|       |        fn num_vertices(&self) -> N;
   21|       |        fn num_vertices(&self) -> N;
   21|       |        fn num_vertices(&self) -> N;
   21|       |        fn num_vertices(&self) -> N;
   22|       |        fn num_vertices(&self) -> N;
   22|       |        fn num_vertices(&self) -> N;
   23|       |        fn num_vertices(&self) -> N;
   23|       |        fn num_vertices(&self) -> N;
   23|       |        fn num_vertices(&self) -> N;
   25|       |        fn num_vertices(&self) -> N;
   47|      6|        fn num_vertices(&self) -> N { self.adj.size() }
   49|      1|        fn num_vertices(&self) -> N { self.adj.length() }
   52|      1|        fn num_vertices(&self) -> N { self.adj.length() }
   53|      6|        fn num_vertices(&self) -> N { self.adj.size() }
   54|     12|        fn num_vertices(&self) -> N { self.adj.size() }
   54|      1|        fn num_vertices(&self) -> N { self.n }
   57|      1|        fn num_vertices(&self) -> N { self.n }
   57|      4|        fn num_vertices(&self) -> N { self.vertices.size() }
   58|      5|        fn num_vertices(&self) -> N { self.vertices.size() }
   60|      4|        fn num_vertices(&self) -> N { self.vertices.size() }
  302|  40.6M|            return &n.value;
  415|     21|            return &n.value;
    5|       |//! Span: O(1) (sequential).
  255|      1|            write!(f, "OBSTMtEph(keys: {}, memo_entries: {})", keys_len, memo_size)
  308|       |    macro_rules! OBSTMtEphLit {
  199|      1|            write!(f, "OBSTMtPer(keys: {}, memo_entries: {})", self.keys.len(), memo_size)
   55|    185|        fn obst_rec(&mut self, i: usize, l: usize) -> Probability {
   67|    783|        fn obst_rec(&mut self, i: usize, l: usize) -> Probability {
   86|    237|        fn obst_rec(&self, i: usize, l: usize) -> Probability
   95|    366|        fn obst_rec(&self, i: usize, l: usize) -> Probability
   16|       |        /// Occupied slot with key-value pair
   47|       |                        // Odd index: combine scan result with original element
   74|       |                        // Odd index: combine scan result with original element
  186|     32|                        pattern.push_str(&format!("Cluster of {} consecutive positions; ", consecutive_count));
    6|       |//! - Offers trait `ArraySeqMtEphSliceTrait<T>` mirroring the MT ephemeral API while avoiding `Vec` copies.
  117|      3|            let offset = i - len_a;
  119|      3|            if offset < len_b { Some(b.nth(offset)) } else { None }
  120|      6|            let offset = index - len_a;
  122|      2|            let offset = index - len_a;
  122|      6|            if offset < len_b {
  124|      2|            if offset < len_b {
  304|      6|            let offset = i - len_a;
  306|      6|            if offset < len_b { Some(b.nth(offset)) } else { None }
   90|      0|                | Ok(_) => {} // Element already exists
  265|      0|                | Ok(mutex) => mutex.into_inner().unwrap().into_iter(),
  266|      1|                | Ok(mutex) => mutex.into_inner().unwrap().into_iter(),
  152|      3|                | Ok(pos) => {
  172|      4|                | Ok(pos) => {
  192|      2|                | Ok(pos) => pos,
  223|      1|                | Ok(pos) => pos,
  227|      1|                | Ok(pos) => pos + 1,
  240|      2|                | Ok(pos) => pos,
   26|  8.00k|                    | Ok(previous) => return previous,
   65|     10|            | Ok(res) => res,
   65|      5|            | Ok(res) => res,
  104|     19|                return Ok(result);
  113|     19|                return Ok(result);
   54|      5|            | Ok(result) => result,
   55|      5|            | Ok(result) => result,
  210|      0|                | Ok(vec) => vec.into_iter(),
  211|      0|                | Ok(vec) => vec.into_iter(),
  123|      1|            let old_neighbors = self.adj.nth(u);
   87|     12|            let old_neighbors = self.adj.nth(u);
   89|     11|            let old_neighbors = self.adj.nth(u);
   92|      3|                    if *old_neighbors.nth(i) == v {
   92|      3|                if *old_neighbors.nth(i) == v {
  253|      1|            let old_reduction = self.cached_reduction.clone();
  266|      1|            let old_reduction = self.cached_reduction.clone();
  116|     11|            let old_row = self.matrix.nth(u);
  118|    203|            let old_size = self.base_table.size();
  122|    203|            if old_size == 0 {
  124|  2.51k|            let old_size = self.base_table.size();
  128|  2.51k|            if old_size == 0 {
  118|      7|            let old_value = self.find(k);
  122|      8|            let old_value = self.find(k);
    4|       |//! Work: O(n) expected, Span: O(lg² n) expected.
    4|       |//! Work: O(n) expected, Span: O(lg² n) expected.
    4|       |//! Work: O(n) expected, Span: O(lg² n) expected.
    4|       |//! Work: O(n) expected, Span: O(lg² n) expected.
  108|       |    /// One round of sequential star contraction
  157|       |    /// One round of parallel star contraction
  158|       |    /// One round of parallel edge contraction
    6|       |//! - One round of contraction using greedy matching
   99|       |    /// One round of sequential edge contraction
   42|      1|        let one_cycle = ArraySeqStPerS::from_vec(vec![0, 1, 2, 1]);
   37|     16|        let ones: ArraySeqStPerS<B> = <ArraySeqStPerS<B> as ArraySeqStPerTrait<B>>::filter(&all, &|x| *x);
   38|     16|        if ones.length() == 1 { true } else { false }
  102|       |        /// Only updates rank if trees have same rank.
  131|       |            // Only add if centers are different (no self-loops)
  154|       |            // Only add if centers are different
   26|       |    /// Only the divisor 1 should divide n for it to be prime.
   85|       |            // Only add edge if endpoints are in different blocks (no self-loops)
  265|      6|            let op = Arc::new(op);
  266|      6|            ParamBST::reduce_inner(tree, &op, base)
  268|      2|            let op = Arc::new(op);
  269|      2|            ParamTreap::reduce_inner(tree, &op, base)
  342|      1|            Self::reduce(self, op, base)
  373|      6|            ParamBST::reduce_parallel(self, op, base)
  428|      2|            ParamTreap::reduce_parallel(self, op, base)
    3|       |//! Uses open addressing for collision resolution.
  148|      2|- Resize operation costs O(n) to rehash all elements
  179|      1|        println!("\nMap operation performance:");
  197|      1|The resize operation for separate chaining:
  260|      1|- lookup: operation returns Some(value) on Live match, None to continue
  261|      1|- insert: operation returns Some(position) on Empty/Dead/matching Live
  262|      1|- delete: operation returns Some(position) on matching Live
  276|      1|1. resize Operation:
  147|      2|- All operations have expected cost O(1 + α) where α = n/m
  119|  2.23k|                .map_or_else(|| Op::identity(), |n| n.reduced_value.clone())
  247|    271|                    let op_left = Arc::clone(op);
  247|      4|                    let op_left = Arc::clone(op);
  255|    271|                    let op_ref = op.as_ref();
  255|      4|                    let op_ref = op.as_ref();
  248|    271|                    let op_right = Arc::clone(op);
  248|      4|                    let op_right = Arc::clone(op);
  253|    271|                            ParamBST::reduce_inner(&right, &op_right, right_base)
    4|       |pub mod OptBinSearchTreeMtEph {
    4|       |pub mod OptBinSearchTreeMtPer {
    4|       |pub mod OptBinSearchTreeStEph {
    4|       |pub mod OptBinSearchTreeStPer {
  421|      2|            performance_summary: "Optimal quadratic probing performance".to_string(),
  127|     23|        fn optimal_cost(&mut self) -> Probability {
  131|      5|        fn optimal_cost(&mut self) -> usize {
  168|     10|        fn optimal_cost(&mut self) -> usize {
  171|      9|        fn optimal_cost(&mut self) -> Probability
   37|       |        fn optimal_cost(&mut self) -> usize;
   39|       |        fn optimal_cost(&mut self) -> Probability;
   39|       |        fn optimal_cost(&mut self) -> usize;
   40|       |        fn optimal_cost(&mut self) -> Probability
  115|     13|        fn optimal_cost(&self) -> Probability {
  119|     14|        fn optimal_cost(&self) -> usize {
  158|     12|        fn optimal_cost(&self) -> usize {
  159|     10|        fn optimal_cost(&self) -> Probability
   37|       |        fn optimal_cost(&self) -> usize;
   39|       |        fn optimal_cost(&self) -> Probability;
   39|       |        fn optimal_cost(&self) -> usize;
   40|       |        fn optimal_cost(&self) -> Probability
  298|      1|   - Optimize for cache performance
  183|       |        current: Option<&'a AVLTreeNode<T>>,
  256|       |        current: Option<&'a Node<T>>,
  287|       |        current: Option<&'a AVLTreeNode<T>>,
   18|       |        head: Option<Box<NodeE<T>>>,
   18|       |        head: Option<Box<NodeP<T>>>,
  270|     19|            metrics: &Option<PrimaryClusteringMetrics>,
  288|     16|            metrics: &Option<SecondaryClusteringMetrics>,
   39|       |        parent: Option<V>,
   74|      6|        parent: Option<&V>,
   79|      6|        parent: Option<&V>,
   21|       |    impl<T: Ord + Clone> InsertionSortStTrait<T> for T {
   40|       |    impl Ord for PQEntry {
   40|       |    impl Ord for PQEntry {
   72|       |    impl Ord for Probability {
   17|       |    /// ordered by x major, then y.
   29|       |    /// Ordered by distance (min-heap)
   29|       |    /// Ordered by distance (min-heap)
   32|       |        dist: OrderedF64,
    9|       |//! Uses `OrderedF64` (OrderedFloat<f64>) for weights to ensure Eq/Hash traits.
    9|       |//! Uses `OrderedF64` (OrderedFloat<f64>) for weights to ensure Eq/Hash traits.
    9|       |//! Uses `OrderedF64` (OrderedFloat<f64>) for weights to ensure Eq/Hash traits.
    9|       |//! Uses `OrderedF64` (OrderedFloat<f64>) for weights to ensure Eq/Hash traits.
   37|       |        priority: OrderedFloat<f64>,
   13|       |    use ordered_float::OrderedFloat;
   13|       |//! use ordered_float::OrderedFloat;
   13|       |//! use ordered_float::OrderedFloat;
   15|       |    use ordered_float::OrderedFloat;
   16|       |    use ordered_float::OrderedFloat;
   16|       |    use ordered_float::OrderedFloat;
   17|       |    use ordered_float::OrderedFloat;
   18|       |    use ordered_float::OrderedFloat;
   19|       |    use ordered_float::OrderedFloat;
   19|       |    use ordered_float::OrderedFloat;
   20|       |    use ordered_float::OrderedFloat;
   20|       |    use ordered_float::OrderedFloat;
   21|       |    use ordered_float::OrderedFloat;
   21|       |    use ordered_float::OrderedFloat;
   21|       |    use ordered_float::OrderedFloat;
   23|       |    use ordered_float::OrderedFloat;
    4|       |pub mod OrderedSetMtEph {
  267|       |    macro_rules! OrderedSetMtEphLit {
    4|       |pub mod OrderedSetStEph {
  318|       |    macro_rules! OrderedSetStEphLit {
    4|       |pub mod OrderedSetStPer {
  296|       |    macro_rules! OrderedSetStPerLit {
    4|       |pub mod OrderedTableMtEph {
   96|     32|                base_table: OrderedTableMtEph::empty(),
   22|       |        base_table: OrderedTableMtEph<K, V>,
  410|       |    macro_rules! OrderedTableMtEphLit {
  106|      2|                base_table: OrderedTableMtEph::singleton(k, v.clone()),
    8|       |pub mod OrderedTableMtPer {
   43|     10|                adj: OrderedTableMtPer::empty(),
   14|       |        adj: OrderedTableMtPer<V, AVLTreeSetMtPer<V>>,
    4|       |pub mod OrderedTableStEph {
   47|     10|                adj: OrderedTableStEph::empty(),
   90|     31|                base_table: OrderedTableStEph::empty(),
   19|       |        base_table: OrderedTableStEph<K, V>,
  381|       |    macro_rules! OrderedTableStEphLit {
  100|      2|                base_table: OrderedTableStEph::singleton(k, v.clone()),
   14|       |        adj: OrderedTableStEph<V, AVLTreeSetStEph<V>>,
    4|       |pub mod OrderedTableStPer {
   47|     14|                adj: OrderedTableStPer::empty(),
   87|     27|                base_table: OrderedTableStPer::empty(),
   19|       |        base_table: OrderedTableStPer<K, V>,
  365|       |    macro_rules! OrderedTableStPerLit {
   97|      2|                base_table: OrderedTableStPer::singleton(k, v.clone()),
   14|       |        adj: OrderedTableStPer<V, AVLTreeSetStPer<V>>,
  141|       |        // Ordering operations (ADT 43.1)
  148|       |        // Ordering operations (ADT 43.1)
  153|       |        // Ordering operations (ADT 43.1)
   46|       |        // Ordering operations (ADT 43.1)
   47|       |        // Ordering operations (ADT 43.1)
   47|       |        // Ordering operations (ADT 43.1) - sequential (inherently sequential on trees)
  133|      6|                    | Ordering::Equal => {
  149|     11|                    | Ordering::Equal => {
  164|      3|                    | Ordering::Equal => {
  206|      3|                    | Ordering::Equal => {
  209|     14|                    | Ordering::Equal => {
  235|    348|                    | Ordering::Equal => return Some(pair.1.clone()),
  240|  1.31k|                    | Ordering::Equal => return Some(mid_val.clone()),
  299|      6|                    | Ordering::Equal => {
  332|      3|                    | Ordering::Equal => {
  375|      4|                    | Ordering::Equal => {
  404|    215|                    | Ordering::Equal => return Some(pair.1.clone()),
  132|      0|                    | Ordering::Greater => j += 1,
  148|      3|                    | Ordering::Greater => j += 1,
  160|      0|                    | Ordering::Greater => {
  203|      0|                    | Ordering::Greater => {
  208|     10|                    | Ordering::Greater => j += 1,
  234|  12.3k|                    | Ordering::Greater => left = mid + 1,
  239|  12.1k|                    | Ordering::Greater => left = mid + 1,
  298|      0|                    | Ordering::Greater => j += 1,
  328|      0|                    | Ordering::Greater => {
  372|      0|                    | Ordering::Greater => {
  403|  32.4k|                    | Ordering::Greater => left = mid + 1,
  131|      5|                    | Ordering::Less => i += 1,
  147|     14|                    | Ordering::Less => i += 1,
  156|      7|                    | Ordering::Less => {
  199|      6|                    | Ordering::Less => {
  204|     16|                    | Ordering::Less => {
  233|    671|                    | Ordering::Less => right = mid,
  238|  1.85k|                    | Ordering::Less => right = mid,
  297|      5|                    | Ordering::Less => i += 1,
  324|      7|                    | Ordering::Less => {
  368|      6|                    | Ordering::Less => {
  402|    561|                    | Ordering::Less => right = mid,
   93|  4.00k|                    shared_clone.fetch_add(1, Ordering::Relaxed);
    6|       |pub mod OrderStatSelectMtEph {
    6|       |pub mod OrderStatSelectMtPer {
    6|       |pub mod OrderStatSelectStEph {
    6|       |pub mod OrderStatSelectStPer {
   80|     12|                for original_edge in original_edges.iter() {
   76|    114|                        let orig_val = a_arc2.nth_cloned(i - 1);
   77|    114|                        f_expand(&scan_val, &orig_val)
  100|    162|                | (other, LeftistHeapNode::Leaf) => other,
  187|     62|            let other_clone = other.clone();
  193|      1|            let other_clone = other.clone();
  198|     74|                return other.clone();
  233|      1|            let other_dims = other.dimensions.lock().unwrap();
  106|     38|                if other.find(elem) {
  108|      7|                if other.find(elem) {
  117|     77|                if !other.find(elem) {
  119|     89|                if !other.find(elem) {
  123|      4|            self.elements.retain(|elem| !other.find(elem));
  159|      8|                    if other.find(elem) {
  135|      2|                let other_inner = other.inner.lock().unwrap();
  204|      6|                let other_inner = other.inner.lock().unwrap();
  238|      1|            let other_keys = other.keys.lock().unwrap();
  174|    108|                let other_left = other_vals.clone();
  176|      0|            let other_left = other.clone();
  222|      0|            let other_left = other.clone();
   94|    118|            let other_len = other.elements.length();
  229|      1|            let other_memo = other.memo_table.lock().unwrap();
  237|      1|            let other_memo = other.memo_table.lock().unwrap();
  254|      1|            let other_reduction = other.cached_reduction.clone();
  267|      1|            let other_reduction = other.cached_reduction.clone();
  175|    108|                let other_right = other_vals;
  177|      0|            let other_right = other.clone();
  179|    108|                        parallel_intersect(right_self_final, other_right)
  223|      0|            let other_right = other.clone();
  138|      2|                let other_seq = other_inner.to_seq();
  207|      6|                let other_seq = other_inner.to_seq();
  161|    110|                    let other_set = AVLTreeSetMtEph::from_seq(AVLTreeSeqStEphS::from_vec(other_vals));
  255|      1|            let other_size = other.base_table.size();
  268|      1|            let other_size = other.base_table.size();
  119|      1|            assert_eq!(self.universe_size, other.universe_size, "Universe sizes must match");
  131|      1|            assert_eq!(self.universe_size, other.universe_size, "Universe sizes must match");
  143|      1|            assert_eq!(self.universe_size, other.universe_size, "Universe sizes must match");
  106|      4|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  106|      4|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  106|      4|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  106|      4|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  106|      6|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  106|      9|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  123|      3|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  123|      3|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  123|      3|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  123|      4|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  123|      4|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  123|      7|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  261|      1|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  278|      1|            let other_values: BTreeSet<T> = other.values_vec().into_iter().collect();
  112|    100|                    if other_values.contains(v) {
  112|     10|                    if other_values.contains(v) {
  112|     10|                    if other_values.contains(v) {
  112|     10|                    if other_values.contains(v) {
  112|     10|                    if other_values.contains(v) {
  112|     17|                    if other_values.contains(v) {
  129|     11|                    if !other_values.contains(v) {
  129|     15|                    if !other_values.contains(v) {
  129|     88|                    if !other_values.contains(v) {
  129|      8|                    if !other_values.contains(v) {
  129|      8|                    if !other_values.contains(v) {
  129|      8|                    if !other_values.contains(v) {
  267|      2|                    if other_values.contains(v) {
  284|      2|                    if !other_values.contains(v) {
  115|  10.6k|            inorder_collect(&n.left, out);
  115|    674|                Self::collect_values(&node.left, out);
  116|  7.45k|            inorder_collect(&n.left, out);
  117|  10.6k|            inorder_collect(&n.right, out);
  117|    674|                Self::collect_values(&node.right, out);
  118|  7.45k|            inorder_collect(&n.right, out);
  121|      0|                Err("Index out of bounds")
  121|    226|                .expect("Index out of bounds")
  133|      7|                Self::in_order_collect(&node.left, out);
  135|    204|                Self::in_order_collect(&node.left, out);
  135|      7|                Self::in_order_collect(&node.right, out);
  137|    204|                Self::in_order_collect(&node.right, out);
  138|     33|                    ParamBST::collect_in_order(&left, out);
  140|     33|                    ParamBST::collect_in_order(&right, out);
  142|      3|                Self::pre_order_collect(&node.left, out);
  143|      3|                Self::pre_order_collect(&node.right, out);
  144|      3|                Self::pre_order_collect(&node.left, out);
  145|      3|                Self::pre_order_collect(&node.right, out);
  157|  26.3k|                return out;
  157|    263|                Self::collect_values(&node.left, out);
  159|    263|                Self::collect_values(&node.right, out);
  163|      8|                Self::collect_keys(&node.left, out);
  165|     11|                Self::in_order_collect(&node.left, out);
  165|      8|                Self::collect_keys(&node.right, out);
  166|    734|                Self::in_order_collect(&node.left, out);
  167|     11|                Self::in_order_collect(&node.right, out);
  168|    734|                Self::in_order_collect(&node.right, out);
  169|      2|                Err("Index out of bounds")
  170|    304|                Self::in_order_collect(&node.left, out);
  171|      5|                Self::collect_values(&node.left, out);
  172|    304|                Self::in_order_collect(&node.right, out);
  173|      5|                Self::collect_values(&node.right, out);
  174|      7|                Self::pre_order_collect(&node.left, out);
  175|      0|                Self::pre_order_collect(&node.left, out);
  175|      7|                Self::pre_order_collect(&node.right, out);
  176|      0|                Self::pre_order_collect(&node.right, out);
  178|     15|                Self::in_order_collect(&node.left, out);
  179|     33|                Self::pre_order_collect(&node.left, out);
  180|     15|                Self::in_order_collect(&node.right, out);
  180|     33|                Self::pre_order_collect(&node.right, out);
  190|    165|                Self::in_order_collect(&node.left, out);
  190|    305|                Self::in_order_collect(&node.left, out);
  192|    165|                Self::in_order_collect(&node.right, out);
  192|    305|                Self::in_order_collect(&node.right, out);
  199|      3|                Self::pre_order_collect(&node.left, out);
  199|      8|                Self::pre_order_collect(&node.left, out);
  200|    241|                    traverse(&left, out);
  200|      3|                Self::pre_order_collect(&node.right, out);
  200|      8|                Self::pre_order_collect(&node.right, out);
  202|    241|                    traverse(&right, out);
  209|     45|                Self::in_order_collect(&node.left, out);
  211|     45|                Self::in_order_collect(&node.right, out);
  212|     64|                Self::in_order_collect(&node.left, out);
  214|     64|                Self::in_order_collect(&node.right, out);
  218|      7|                Self::pre_order_collect(&node.left, out);
  219|      7|                Self::pre_order_collect(&node.right, out);
  221|      0|                Self::pre_order_collect(&node.left, out);
  222|      0|                Self::pre_order_collect(&node.right, out);
  226|  29.2k|                Self::in_order_collect(&node.left, out);
  228|  29.2k|                Self::in_order_collect(&node.right, out);
  235|      3|                Self::pre_order_collect(&node.left, out);
  236|      3|                Self::pre_order_collect(&node.right, out);
  236|     56|                Self::collect_keys(&node.left, out);
  238|     56|                Self::collect_keys(&node.right, out);
  244|     56|                Self::collect_values(&node.left, out);
  246|     56|                Self::collect_values(&node.right, out);
  275|    631|                    ParamBST::collect_in_order(&left, out);
  277|    631|                    ParamBST::collect_in_order(&right, out);
  278|      0|                    ParamTreap::collect_in_order(&left, out);
  280|      0|                    ParamTreap::collect_in_order(&right, out);
  439|      3|            push_inorder(&n.left, out);
  441|      3|            push_inorder(&n.right, out);
   48|    240|                .expect("Index out of bounds")
   50|      5|                Err("Index out of bounds")
   55|      0|                        panic!("Index out of bounds in left partition");
   55|      0|                        panic!("Index out of bounds in left partition");
   55|      0|                        panic!("Index out of bounds in left partition");
   57|      0|                        panic!("Index out of bounds in left partition");
   75|      0|                        panic!("Index out of bounds in right partition");
   75|      0|                        panic!("Index out of bounds in right partition");
   75|      0|                        panic!("Index out of bounds in right partition");
   77|      0|                        panic!("Index out of bounds in right partition");
   95|      0|                    Err("Index out of bounds")
   96|      1|                    Err("Index out of bounds")
  148|     21|        fn OutDegree(&self, v: &V) -> N { self.NPlus(v).size() }
   28|       |        fn out_degree(&self, u: N) -> N;
   29|       |        fn out_degree(&self, u: N) -> N;
   29|       |        fn out_degree(&self, u: N) -> N;
   29|       |        fn out_degree(&self, u: &V) -> N;
   30|       |        fn out_degree(&self, u: N) -> N;
  339|  2.69k|        fn OutDegree(&self, v: &V) -> N { self.NPlus(v).size() }
   33|       |        fn out_degree(&self, u: &V) -> N;
   33|       |        fn out_degree(&self, u: &V) -> N;
   34|       |        fn out_degree(&self, u: &V) -> N;
   35|       |        fn out_degree(&self, u: &V) -> N;
   37|       |        fn out_degree(&self, u: &V) -> N;
   68|      4|        fn out_degree(&self, u: &V) -> N { self.out_neighbors(u).size() }
   70|       |        fn OutDegree(&self, v: &V) -> N;
   73|       |        fn OutDegree(&self, v: &V) -> N;
   75|      1|        fn out_degree(&self, u: N) -> N { self.adj.nth(u).length() }
   79|      2|        fn out_degree(&self, u: &V) -> N { self.out_neighbors(u).size() }
   82|      1|        fn out_degree(&self, u: N) -> N { self.adj.nth(u).length() }
   83|      2|        fn out_degree(&self, u: &V) -> N { self.out_neighbors(u).size() }
   85|      2|        fn out_degree(&self, u: &V) -> N { self.out_neighbors(u).size() }
   90|      1|        fn out_degree(&self, u: N) -> N {
   95|      4|        fn out_degree(&self, u: &V) -> N { self.out_neighbors(u).size() }
   97|      1|        fn out_degree(&self, u: N) -> N {
   97|      7|        fn out_degree(&self, u: &V) -> N { self.out_neighbors(u).size() }
  264|      3|                        continue 'outer;
   26|      4|        let outer: ArraySeqStPerS<ArraySeqStPerS<Pair<N, Pair<N, N>>>> = <ArraySeqStPerS<
  105|     11|        fn out_neighbors(&self, v: &V) -> Set<V> {
  111|    135|        fn out_neighbors(&self, v: &V) -> Set<V> {
   26|       |        fn out_neighbors(&self, u: N) -> ArraySeqStEphS<N>;
   27|       |        fn out_neighbors(&self, u: N) -> ArraySeqStEphS<N>;
   27|       |        fn out_neighbors(&self, u: N) -> &ArraySeqStPerS<N>;
   27|       |        fn out_neighbors(&self, u: &V) -> AVLTreeSetMtPer<V>;
   28|       |        fn out_neighbors(&self, u: N) -> ArraySeqStPerS<N>;
   31|       |        fn out_neighbors(&self, u: &V) -> AVLTreeSetStEph<V>;
   31|       |        fn out_neighbors(&self, u: &V) -> AVLTreeSetStPer<V>;
   32|       |        fn out_neighbors(&self, u: &V) -> AVLTreeSetStEph<V>;
   33|       |        fn out_neighbors(&self, u: &V) -> AVLTreeSetStPer<V>;
   35|       |        fn out_neighbors(&self, u: &V) -> AVLTreeSetMtPer<V>;
   49|       |        fn out_neighbors(&self, v: &V) -> Set<V>;
   53|       |        fn out_neighbors(&self, v: &V) -> Set<V>;
   64|      8|        fn out_neighbors(&self, u: &V) -> AVLTreeSetMtPer<V> {
   67|      3|        fn out_neighbors(&self, u: &V) -> AVLTreeSetStEph<V> {
   70|      3|        fn out_neighbors(&self, u: &V) -> AVLTreeSetStPer<V> {
   72|      3|        fn out_neighbors(&self, u: &V) -> AVLTreeSetMtPer<V> {
   73|      1|        fn out_neighbors(&self, u: N) -> ArraySeqStEphS<N> { self.adj.nth(u).clone() }
   76|      1|        fn out_neighbors(&self, u: N) -> ArraySeqStEphS<N> {
   79|      1|        fn out_neighbors(&self, u: N) -> &ArraySeqStPerS<N> { self.adj.nth(u) }
   82|      1|        fn out_neighbors(&self, u: N) -> ArraySeqStPerS<N> {
   88|      8|        fn out_neighbors(&self, u: &V) -> AVLTreeSetStEph<V> {
   89|      9|        fn out_neighbors(&self, u: &V) -> AVLTreeSetStPer<V> {
  114|       |        type Output = Self;
  120|       |        type Output = Self;
  126|       |        type Output = Self;
  132|       |        type Output = Self;
  150|      2|                (sv, ov)
  219|      6|                (sv, ov)
    4|       |//! Work: O(|V| + |E|), Span: O(d·lg n) where d is diameter.
    4|       |//! Work: O(|V| + |E|), Span: O(d·lg n) where d is diameter.
    4|       |//! Work: O(|V| + |E|), Span: O(|V| + |E|).
    4|       |//! Work: O(|V| + |E|), Span: O(|V| + |E|).
    4|       |//! Work: O(|V| + |E|), Span: O(|V| + |E|).
    4|       |//! Work: O(|V| + |E|), Span: O(|V| + |E|).
    4|       |//! Work: O(|V| + |E|), Span: O(|V| + |E|).
    4|       |//! Work: O(|V| + |E|), Span: O(|V| + |E|).
    4|       |//! Work: O(|V| + |E|), Span: O(|V| + |E|).
    4|       |//! Work: O(|V| + |E|), Span: O(|V| + |E|).
    4|       |//! Work: O(|V| + |E|), Span: O(|V| + |E|).
    4|       |//! Work: O(|V| + |E|), Span: O(|V| + |E|).
  388|      0|            writeln!(f, "Overall clustering score: {:.2}", self.overall_clustering_score)?;
   24|       |        pub overall_clustering_score: f64,
  102|     47|                    let p = priority_fn.priority(&v);
  107|     23|                    let p = priority_fn.priority(&v);
  107|      8|                let p = priority_fn.priority(v);
  115|     23|                let p = priority_fn.priority(&v);
  120|     47|                        let p = priority_fn.priority(v);
  130|     47|                        let p = priority_fn.priority(v);
  131|     14|                let p = priority_fn.priority(v);
  135|     23|                        let p = priority_fn.priority(v);
  141|     23|                let p = priority_fn.priority(v);
  142|     14|                let p = priority_fn.priority(v);
  142|     23|                priorities.insert(Pair(v.clone(), p));
  147|      8|                let p = priority_fn.priority(v);
   37|       |        ClosurePriority<V, P, F>
   42|       |        probe_sequence: P,
   48|       |        PriorityFn<V, P> for ClosurePriority<V, P, F>
   95|     47|                    let p = priority_fn.priority(&v);
  108|     26|                    rows: pair.0,
  110|  18.6k|                    if &pair.0 == word {
  114|      0|                if &pair.0 == key {
  120|     24|                    rows: pair.0,
  137|      0|                if &pair.0 != key {
  147|     47|                    rows: pair.0,
  157|     51|                    rows: pair.0,
  212|      0|                if pair.0 != key {
  219|     29|                if &pair.0 < k {
  232|     37|                if &pair.0 < k {
  233|     30|                if &pair.0 > k {
  246|     36|                if &pair.0 > k {
  250|     14|                if &pair.0 < k {
  261|     37|                if &pair.0 < k {
  263|      8|                if &pair.0 < k {
  275|     36|                if &pair.0 > k {
  280|    186|                if &pair.0 >= k1 && &pair.0 <= k2 {
  291|    289|                if &pair.0 >= k1 && &pair.0 <= k2 {
  292|      8|                if &pair.0 < k {
  297|      4|                    if &pair.0 == k {
  297|     70|                if &pair.0 < k {
  308|    127|                if &pair.0 < k {
  321|  7.97k|                if &pair.0 >= k1 && &pair.0 <= k2 {
  338|    127|                if &pair.0 < k {
  421|      2|                if pair.0 == *key {
  437|      9|                    if pair.0 != key_clone {
  448|     13|                if pair.0 != key_clone2 {
  491|      2|                            if pair.0 == key_clone {
  504|      4|                        if pair.0 == key {
   55|      0|                if pair.0 != key {
  105|  1.00k|                    let pair = self.entries.nth(i);
  109|  18.6k|                    let pair = all_pairs.nth(j);
  130|     11|                match pair1.0.cmp(&pair2.0) {
  155|     10|                match pair1.0.cmp(&pair2.0) {
  198|      9|                match pair1.0.cmp(&pair2.0) {
  296|     11|                match pair1.0.cmp(&pair2.0) {
  323|     10|                match pair1.0.cmp(&pair2.0) {
  367|     10|                match pair1.0.cmp(&pair2.0) {
  109|     26|                    cols: pair.1,
  121|     24|                    cols: pair.1,
  127|     11|                let pair1 = self.entries.nth(i);
  113|      0|                let pair = chain.nth(i);
  148|     47|                    cols: pair.1,
  152|     10|                let pair1 = self.entries.nth(i);
  158|     51|                    cols: pair.1,
  116|       |            for pair in &__pairs {
  195|      9|                let pair1 = self.entries.nth(i);
  122|    113|                let pair = chain.nth(i);
  293|     11|                let pair1 = self.entries.nth_cloned(i);
  320|     10|                let pair1 = self.entries.nth_cloned(i);
  136|      0|                let pair = chain.nth(i);
  364|     10|                let pair1 = self.entries.nth_cloned(i);
  138|    205|                let pair = entries.nth(i);
  141|      2|                let pair = chain.nth(i);
  145|     45|        let pair = ParaPair!(move || route_edges_parallel(&edges1, map1, start, mid), move || {
  146|     20|        let pair = ParaPair!(move || build_edges_parallel(edges1, map1, start, mid), move || {
  150|    303|                let pair = entries.nth(i);
  152|    214|                let pair = entries.nth(i);
  165|     34|        let pair = ParaPair!(
  167|     15|                let pair = entries.nth(i);
  168|    310|                let pair = entries.nth(i);
  174|     38|        let pair = ParaPair!(move || route_edges_parallel(&edges1, map1, start, mid), move || {
  181|      0|                    let pair = self.entries.nth_cloned(0);
  188|    112|                let pair = entries.nth(i);
  190|      0|                    let pair = chain.nth(j);
  195|    129|                    let pair = chain.nth(j);
  197|    528|                        let pair = left_entries.nth_cloned(i);
  156|    107|                        .insert(pair.0.clone(), pair.1.clone(), |_old, new| new.clone());
  172|    155|                        .insert(pair.0.clone(), pair.1.clone(), |_old, new| new.clone());
  201|     50|        let pair = ParaPair!(
  207|    528|                    let pair = right_entries.nth_cloned(i);
  211|      0|                let pair = chain.nth(i);
  212|     30|                let pair = chain.nth(i);
  128|     11|                let pair2 = other.entries.nth(j);
  153|     10|                let pair2 = other.entries.nth(j);
  218|     29|                let pair = entries.nth(i);
  196|      9|                let pair2 = other.entries.nth(j);
  294|     11|                let pair2 = other.entries.nth_cloned(j);
  230|  13.3k|                let pair = self.entries.nth(mid);
  231|     37|                let pair = entries.nth(i);
  321|     10|                let pair2 = other.entries.nth_cloned(j);
  232|     30|                let pair = entries.nth(i);
  365|     10|                let pair2 = other.entries.nth_cloned(j);
  238|      0|                let pair = self.entries.nth_cloned(0);
  245|     36|                let pair = entries.nth(i);
  249|     14|                let pair = entries.nth(i);
  254|     29|                    let pair = left_entries.nth_cloned(i);
  260|     37|                let pair = entries.nth(i);
  262|      8|                let pair = entries.nth(i);
  262|       |                let pair = $crate::Types::Types::Pair($id.to_string(), $content.to_string());
  264|     29|                let pair = right_entries.nth_cloned(i);
  274|     36|                let pair = entries.nth(i);
  277|       |                // Pair up heaps and meld them
  279|    186|                let pair = entries.nth(i);
  290|    289|                let pair = entries.nth(i);
  291|      8|                let pair = entries.nth(i);
  296|     70|                let pair = entries.nth(i);
  301|     51|        let pair = ParaPair!(move || reroute_edges_mt(edges1, part1, start, mid), move || {
  307|    127|                let pair = entries.nth(i);
  312|      0|                        let pair = chain.nth(j);
  320|  7.97k|                let pair = entries.nth(i);
  337|    127|                let pair = entries.nth(i);
  344|    131|                let pair = pairs.nth(i);
  379|    120|                let pair = pairs.nth(i);
  383|  3.81k|                let pair = pairs.nth(i);
  399|  33.1k|                let pair = self.entries.nth_cloned(mid);
  420|      2|                let pair = self.entries.nth_cloned(0);
  436|      9|                    let pair = left_entries.nth_cloned(i);
  447|     13|                let pair = right_entries.nth_cloned(i);
  490|      2|                            let pair = left_entries.nth_cloned(i);
  503|      4|                        let pair = right_entries.nth_cloned(i);
   54|      0|                let pair = chain.nth(i);
  556|      0|                let pair = self.entries.nth_cloned(0);
  572|     10|                    let pair = left_entries.nth_cloned(i);
  583|     10|                let pair = right_entries.nth_cloned(i);
  612|      0|                let pair = self.entries.nth_cloned(0);
  628|     10|                    let pair = left_entries.nth_cloned(i);
  639|     10|                let pair = right_entries.nth_cloned(i);
   65|     70|                let pair = chain.nth(i);
   73|      4|                let Pair(_, v) = seq.nth(i);
   76|  1.46k|                    let pair = Pair(word.clone(), doc_id.clone());
   76|      4|                let Pair(_, v) = seq.nth(i);
   78|      4|                let Pair(_, v) = seq.nth(i);
   79|     39|                let pair = self.entries.nth(i);
   86|  1.46k|                let pair = all_pairs.nth(i);
   95|     51|        let pair = ParaPair!(
   95|  60.0k|            for Pair(_, b) in self.pairs.iter() {
   55|  10.0k|            for Pair(a, b) in iter {
   84|  60.0k|            for Pair(a, _) in self.pairs.iter() {
   20|       |        fn pair_even_with_vowels(a: &ArraySeqStPerS<N>, b: &ArraySeqStPerS<char>) -> ArraySeqStPerS<Pair<N, char>>;
  267|      3|                let Pair(idx, val) = updates.nth(i).clone();
  271|      3|                let Pair(idx, val) = updates.nth_cloned(i);
  312|      6|                let Pair(idx, val) = updates.nth(k).clone();
  324|      5|                let Pair(idx, val) = updates.nth(k).clone();
  340|      8|                let Pair(idx, val) = updates.nth(i).clone();
  351|      6|                let Pair(idx, val) = updates.nth(i).clone();
  370|      2|                let Pair(idx, val) = updates.nth_cloned(i);
  202|     26|                let Pair(index, value) = updates.nth(i);
  263|     19|            let Pair(index, item) = item_at;
  275|      8|                let Pair(index, value) = updates.nth(i);
  287|     38|                let Pair(index, value) = updates.nth(i);
  380|    431|                let Pair(index, value) = updates.nth(i);
   62|    108|                let Pair(index, value) = updates.nth(i).clone();
  260|  4.74k|                    let Pair(k, _) = updated.entries.nth(i);
  287|   513k|                    let Pair(k, _) = self.entries.nth(i);
  363|      7|                let Pair(k, v) = a.nth(i).clone();
  402|      7|                let Pair(k, v) = a.nth(i).clone();
  143|     28|                let Pair(key1, val1) = self.entries.nth(i);
  200|     40|                let Pair(key1, val1) = self.entries.nth(i);
  122|  1.02k|                    let Pair(key, value) = self.entries.nth(i);
  144|     28|                let Pair(key2, val2) = other.entries.nth(j);
  218|      9|                let Pair(key, val) = self.entries.nth(i);
  201|     40|                let Pair(key2, _) = other.entries.nth(j);
  229|      9|                let Pair(key, value) = a.nth(i);
  260|      9|                let Pair(key, value) = pairs.nth(i).clone();
  285|      3|                let Pair(key, value) = pairs.nth(i).clone();
  300|      3|                let Pair(key, value) = a.nth_cloned(i);
  358|      8|                let Pair(key, value) = a.nth(i);
  324|     73|            let Pair(l, r) = ParaPair!(
  349|  1.99k|            let Pair(l, r) = ParaPair!(
  273|      0|        let Pair(left, right) = ParaPair!(|| { 1usize }, || { 2usize });
   30|  1.17k|            let Pair(left, right) = ParaPair!(move || fib(n - 1), move || fib(n - 2));
  251|    271|                    let Pair(left_acc, right_acc) =
  251|      4|                    let Pair(left_acc, right_acc) = crate::ParaPair!(
  140|     10|        let Pair((left_dist, left_pred), (right_dist, right_pred)) = crate::ParaPair!(
  140|     18|        let Pair((left_dist, left_pred), (right_dist, right_pred)) = crate::ParaPair!(
  115|    217|                let Pair(left_filtered, right_filtered) = ParaPair!(
  218|     11|                    let Pair(left_filtered, right_filtered) =
  221|    271|                    let Pair(left_filtered, right_filtered) =
  177|    108|                let Pair(left_intersect, right_intersect) =
  177|      6|                    let Pair(left_res, right_res) =
  179|    156|                    let Pair(left_res, right_res) =
  197|      7|                    let Pair(left_res, right_res) =
  200|    156|                    let Pair(left_res, right_res) =
  100|      0|                let Pair(left_result, right_result) =
  105|      0|                let Pair(left_result, right_result) =
  107|      0|                let Pair(left_result, right_result) =
  112|      0|                let Pair(left_result, right_result) =
  126|    108|                let Pair(left_result, right_result) =
  134|      0|                let Pair(left_result, right_result) =
  139|      0|            let Pair(left_result, right_result) =
  152|      0|                let Pair(left_result, right_result) =
  152|      0|                let Pair(left_result, right_result) =
  162|      0|                let Pair(left_result, right_result) =
  168|      0|                let Pair(left_result, right_result) =
  172|      0|                let Pair(left_result, right_result) =
  179|      0|            let Pair(left_result, right_result) =
  184|      0|                let Pair(left_result, right_result) =
  204|      0|                let Pair(left_result, right_result) =
  225|      0|            let Pair(left_result, right_result) = ParaPair!(move || left_set.union(&other_left), move || right_set
  225|  1.99k|            let Pair(left_result, right_result) = ParaPair!(
  234|      0|                let Pair(left_result, right_result) = ParaPair!(
  279|      0|                let Pair(left_result, right_result) =
  324|      0|                let Pair(left_result, right_result) =
   81|  5.04k|                let Pair(left_sorted, right_sorted) =
  161|      6|                    let Pair(left_union, right_union) =
  163|    254|                    let Pair(left_union, right_union) = crate::ParaPair!(
  356|      1|                let Pair(left_val, right_val) =
  344|       |    macro_rules! PairList {
  327|       |    macro_rules! PairLit {
  235|  15.3k|                let Pair(mid_key, mid_val) = self.entries.nth(mid);
   27|      4|            ArraySeqStPerS<Pair<N, Pair<N, N>>>,
   29|      4|            ArraySeqStPerS<Pair<N, Pair<N, N>>>,
   33|      7|                    <ArraySeqStPerS<ArraySeqStPerS<Pair<N, Pair<N, N>>>> as ArraySeqStPerTrait<
   34|      7|                        ArraySeqStPerS<Pair<N, Pair<N, N>>>,
   37|     13|                            <ArraySeqStPerS<Pair<N, Pair<N, N>>> as ArraySeqStPerTrait<Pair<N, Pair<N, N>>>>::tabulate(
   44|      7|                <ArraySeqStPerS<Pair<N, Pair<N, N>>> as ArraySeqStPerTrait<Pair<N, Pair<N, N>>>>::flatten(&mid)
   48|      4|        <ArraySeqStPerS<Pair<N, Pair<N, N>>> as ArraySeqStPerTrait<Pair<N, Pair<N, N>>>>::flatten(&outer)
   65|      9|                let Pair(result, _) = ParaPair!(
  113|       |            let __pairs = vec![ $( $crate::Types::Types::Pair($a, $b) ),* ];
  119|       |            let __pairs: $crate::Chap05::SetStEph::SetStEph::Set<$crate::Types::Types::Pair<_, _>> = < $crate::Chap05::SetStEph::SetStEph::Set<_> >::empty();
  123|       |            let __pairs = {
  339|     23|            let pairs = base.collect();
  370|      2|            let pairs: Vec<Pair<A, LinkedListStEphS<Bv>>> = groups
  370|       |            let pairs = vec![$($crate::Types::Types::Pair($key, $val)),+];
  374|     21|            let pairs = base.collect();
  378|     40|            let pairs = base.collect();
   37|       |    /// Pairs even elements of sequence a with vowels of sequence b.
  386|       |            let pairs = vec![$($crate::Types::Types::Pair($key, $val)),+];
  409|      2|            let pairs: Vec<Pair<A, LinkedListStPerS<Bv>>> = groups
  415|       |            let pairs = vec![$($crate::Types::Types::Pair($key, $val)),+];
   58|  10.0k|            let pairs: Vec<Pair<A, B>> = m.into_iter().map(|(a, b)| Pair(a, b)).collect();
   83|      7|            let pairs = Self::unique_pairs_from_iter(v);
   90|      5|            let pairs = Self::unique_pairs_from_iter(r.iter().cloned());
  176|     38|            let Pair(sorted_left, sorted_right) = ParaPair!(
  101|      1|                let Pair(u, w) = edge;
   91|      1|                    let Pair(u, w) = edge;
   98|      3|                let Pair(u, w) = edge;
   38|     25|                                &|z_idx| Pair(x, Pair(y + 1, z_idx + 2)),
   50|      5|                    &|j| Pair(*x, *filtered_b.nth(j)),
   61|      0|                        &|j| Pair(x, *b.nth(j)),
   31|      0|                    v.push(Pair(x, Pair(y, z)));
    7|       |pub mod ParaHashTableStEph {
  101|       |            // PARALLEL: map-reduce over vertices using divide-and-conquer
  103|       |    /// Parallel edge routing using divide-and-conquer
  104|       |                    // Parallel difference operation
  105|     14|                // Parallel union operation
  107|       |                    // Parallel union operation
  109|       |            // Parallel difference operation
  109|       |        // PARALLEL: filter using divide-and-conquer (unconditionally parallel)
  112|       |            // PARALLEL: filter labeled arcs using divide-and-conquer
  114|       |            // Parallel map-reduce
  115|       |            // PARALLEL: filter weighted arcs using divide-and-conquer
  117|       |        // Parallel edge selection using divide-and-conquer
  119|     37|                            // Parallel union for each new frontier element
  119|       |    /// Parallel bridge star partition
  122|       |            // PARALLEL: filter weighted arcs using divide-and-conquer
  123|       |            // PARALLEL: filter labeled edges using divide-and-conquer
  126|       |            // Parallel divide-and-conquer
  128|       |                // Parallel recursive merge
  129|       |            // Parallel divide-and-conquer
  129|       |        // PARALLEL: intersection using extract-parallelize-rebuild pattern (unconditionally parallel)
  130|       |            // Parallel tabulation using spawn/join
  131|     47|                        // Parallel union for priority set construction
  132|       |    /// Parallel edge routing using divide-and-conquer
  132|       |        // Parallel version: fromSeq a = Seq.reduce Set.union ∅ ⟨{x} : x ∈ a⟩
  136|       |            // Parallel divide-and-conquer
  139|       |            // Parallel divide-and-conquer
  139|       |            // PARALLEL: map-reduce over vertices using divide-and-conquer
  145|       |        // Parallel edge filtering: select edges from Tail→Head
  145|       |        // PARALLEL: intersection using divide-and-conquer (unconditionally parallel)
  146|       |            // PARALLEL: filter arcs using divide-and-conquer
  152|       |            // Parallel map-reduce
  160|       |            // Parallel divide-and-conquer
  163|       |    /// Parallel filter: find edges from Tail→Head
  164|       |            // PARALLEL: filter labeled arcs using divide-and-conquer
  178|       |            // Parallel divide-and-conquer
  188|       |            // Parallel map using spawn/join
   18|       |    /// Parallel Fibonacci using ParaPair! for symmetric binary parallelism.
   18|       |        /// Parallel spanning tree via star contraction
  191|       |        // PARALLEL: difference using filter
  191|       |        // PARALLEL: union using divide-and-conquer (unconditionally parallel)
  196|       |            // PARALLEL: filter arcs using divide-and-conquer
  197|       |        // PARALLEL: union using extract-parallelize-rebuild pattern (unconditionally parallel)
   19|       |        /// Parallel Euler tour of a tree
   19|       |        /// Parallel vertex matching using randomized symmetry breaking
  210|       |            // Parallel divide-and-conquer
  212|       |    /// Parallel Borůvka's MST
   21|       |        /// Parallel edge contraction algorithm
   21|       |        /// Parallel star partition using randomized coin flips
  229|       |            // Parallel via asymmetric fork-join (good when F is expensive)
   22|       |        /// Parallel star contraction higher-order function
  245|       |            // Parallel filter using spawn/join
  246|       |            // PARALLEL: map-reduce over vertices using divide-and-conquer
  259|       |            // Parallel map-reduce
   25|       |    /// parallel recursion patterns; real implementations use memoization or iteration.
  262|       |        // Parallel edge re-routing
   26|       |        /// Parallel shortcut Euler tour
  271|       |    /// Parallel edge re-routing: map edges to new endpoints and remove self-edges
   28|       |        /// Parallel bridge-based star partition
  291|       |            // PARALLEL: map-reduce over vertices using divide-and-conquer
  304|       |            // Parallel map-reduce
   30|       |        /// Parallel Johnson's all-pairs shortest path algorithm
   30|       |        /// Parallel Johnson's all-pairs shortest path algorithm
   30|       |        /// Parallel tour weight computation
  337|       |        /// Parallel range reduction using ParaPair! for unconditional parallelism
   35|       |        /// Parallel Borůvka's MST algorithm
   37|       |        /// Parallel 2-approximation algorithm for metric TSP
    3|       |//! Layer-by-layer parallel BFS for finding distances and reachability.
    3|       |//! Layer-by-layer parallel BFS for finding distances and reachability.
   41|       |        /// Parallel Borůvka's MST with random seed
  427|       |            // Parallel delete using spawn/join
  480|       |                // Parallel update using spawn/join
    4|       |//! Implements parallel graph connectivity algorithms using star contraction.
    4|       |//! Implements parallel versions of Algorithm 66.2 and 66.3 using ParaPair! macro.
    4|       |//! Note: Parallel priority selection would require concurrent priority queues.
   55|       |        /// Parallel reduction to find minimum cost among root choices
  563|       |            // Parallel restrict using spawn/join
   56|       |    /// Parallel vertex bridges using divide-and-conquer reduce
    5|       |//! Uses parallel star partition and parallel edge routing for quotient graph construction.
  619|       |            // Parallel subtract using spawn/join
   61|       |        /// Parallel reduction to find minimum cost among split choices
   63|       |            // PARALLEL: filter weighted arcs using divide-and-conquer
   63|       |            // PARALLEL: filter weighted edges using divide-and-conquer
   64|       |            // Parallel merge: split the longer sequence
   64|       |        /// Parallel reduction to find minimum cost among root choices
   67|       |            // PARALLEL: filter weighted arcs using divide-and-conquer
   67|       |            // PARALLEL: filter weighted edges using divide-and-conquer
   68|       |                        // Parallel evaluation of both branches
    6|       |//! The parallel algorithm concept is demonstrated via use of AVLTreeSetMtPer which has
   71|       |        /// Parallel reduction to find minimum cost among split choices
   71|       |        // PARALLEL: Work: Θ(|E|), Span: Θ(log |E|) - TRUE parallel filter
   74|       |                        // Parallel evaluation of both operations
   77|       |            // Parallel divide-and-conquer
   78|       |    /// Parallel counter increment using spin-lock for mutual exclusion.
   78|       |                        // Parallel evaluation of both branches
   79|       |            // Parallel divide-and-conquer
   79|       |        // PARALLEL: filter using extract-parallelize-rebuild pattern (unconditionally parallel)
    7|       |//! true parallel operations (filter, union, intersection).
   81|       |            // Parallel divide-and-conquer
   82|       |                // Parallel recursive merge
   83|       |            // Parallel divide-and-conquer
   83|       |            // PARALLEL: filter edges using divide-and-conquer
   85|       |        /// Parallel range reduction using spawn/join
   89|       |    /// Parallel Dijkstra execution using recursive divide-and-conquer with ParaPair!
   89|       |    /// Parallel Dijkstra execution using recursive divide-and-conquer with ParaPair!
   90|       |                        // Parallel evaluation of both operations
   91|       |            // Parallel extraction using spawn/join
   95|       |        // PARALLEL: Work: Θ(|E| log |E|), Span: Θ(log² |E|) - TRUE parallel filter
   96|       |            // Parallel filter: spawn thread per element (as if f is expensive)
   96|       |            // Parallel union via AVLTreeSetMtPer's parallel implementation
   99|       |            // Parallel divide-and-conquer
   91|     25|    fn parallel_dijkstra_all(
   91|     46|    fn parallel_dijkstra_all(
   95|    437|            fn parallel_filter<T: StTInMtT + Ord + 'static, F: Fn(&T) -> B + Send + Sync + Clone + 'static>(
  413|       |        fn parallel_heap_construction<T: StT + Ord>(elements: Vec<T>) -> LeftistHeapPQ<T>;
  155|    218|            fn parallel_intersect<T: StTInMtT + Ord + 'static>(self_vals: Vec<T>, other_vals: Vec<T>) -> Vec<T> {
  130|      0|            fn parallel_in<V: StT + MtT + Hash + 'static>(arcs: Vec<LabEdge<V, i32>>, v: V) -> Set<(V, i32)> {
  137|      0|            fn parallel_in<V: StT + MtT + Hash + 'static>(
  179|      0|            fn parallel_in<V: StT + MtT + Hash + 'static, L: StTInMtT + Hash + 'static>(
   12|       |//! - Parallelism in Phase 3: Θ(n) - n independent Dijkstra runs
   12|       |//! - Parallelism in Phase 3: Θ(n) - n independent Dijkstra runs
   33|       |    ///         Parallelism Θ(|E|) in coin flipping phase
   44|       |    ///         Parallelism Θ(|V| + |E|) / log(|V| + |E|)
    5|       |//! True parallelism would require more complex lifetime management for the graph closure.
    6|       |//! unconditional parallelism with 32MB stack per thread.
   10|       |//! - Parallelizable: Lines 5-6 parallelize over vertices
   10|       |//! - Parallelizable: Lines 5-6 parallelize over vertices
  122|       |    /// Parallelizes coin flips and edge filtering.
  215|       |    /// Parallelizes vertex bridge computation and edge routing.
   21|       |        fn parallel_matching_mt<V: StT + MtT + Hash + 'static>(graph: &UnDirGraphMtEph<V>) -> Set<Edge<V>>;
   24|       |        fn parallel_matching_st<V: StT + Hash>(graph: &UnDirGraphStEph<V>) -> Set<Edge<V>>;
   58|    168|        fn parallel_min_reduction(&self, costs: Vec<Probability>) -> Probability {
   64|     97|        fn parallel_min_reduction(&self, costs: Vec<usize>) -> usize {
   67|    287|        fn parallel_min_reduction(&self, costs: Vec<Probability>) -> Probability {
   74|     91|        fn parallel_min_reduction(&self, costs: Vec<usize>) -> usize {
  140|      0|            fn parallel_neighbors<V: HashOrd + MtT + 'static, L: StTInMtT + Hash + 'static>(
   80|      0|            fn parallel_neighbors<V: HashOrd + MtT + 'static>(edges: Vec<LabEdge<V, i32>>, v: V) -> Set<(V, i32)> {
   84|      0|            fn parallel_neighbors<V: HashOrd + MtT + 'static>(
  115|      0|            fn parallel_ng_of_vertices<V: StT + MtT + Hash + 'static>(
  153|      0|            fn parallel_ng_of_vertices<V: StT + MtT + Hash + 'static>(
  100|    222|            fn parallel_ng<V: StT + MtT + Hash + 'static>(edges: Vec<Edge<V>>, v: V) -> Set<V> {
  305|      0|            fn parallel_nminus_of_vertices<V: StT + MtT + Hash + 'static>(
  211|      0|            fn parallel_nminus<V: StT + MtT + Hash + 'static>(arcs: Vec<Edge<V>>, v: V) -> Set<V> {
  260|      0|            fn parallel_nplus_of_vertices<V: StT + MtT + Hash + 'static>(
  161|      0|            fn parallel_nplus<V: StT + MtT + Hash + 'static>(arcs: Vec<Edge<V>>, v: V) -> Set<V> {
  127|      0|            fn parallel_out<V: StT + MtT + Hash + 'static, L: StTInMtT + Hash + 'static>(
   78|      0|            fn parallel_out<V: StT + MtT + Hash + 'static>(arcs: Vec<LabEdge<V, i32>>, v: V) -> Set<(V, i32)> {
   82|      0|            fn parallel_out<V: StT + MtT + Hash + 'static>(
   71|  10.2k|            fn parallel_sort<T: StTInMtT + Ord + 'static>(mut vals: Vec<T>) -> Vec<T> {
   23|       |        fn parallel_star_partition<V: StT + MtT + Hash + Ord + 'static>(graph: &UnDirGraphMtEph<V>) -> Set<Set<V>>;
  200|       |    macro_rules! ParamBSTLit {
   21|       |        left: ParamBST<T>,
   22|       |        right: ParamBST<T>,
   23|       |        left: ParamBST<T>,
   24|       |        right: ParamBST<T>,
   10|       |    /// Parametric entry type for chained hash tables.
   22|       |    /// Parametric nested hash table structure.
    3|       |//! A parametric implementation of hash tables using nested tables.
  441|       |    macro_rules! ParamTreapLit {
   24|       |        left: ParamTreap<T>,
   25|       |        right: ParamTreap<T>,
  255|       |    macro_rules! ParaPair {
  272|      0|    fn _ParaPair_type_checks() {
   13|       |        pub parent: Option<AVLTreeSetStEph<Pair<V, V>>>,
   14|       |        pub parent: Option<AVLTreeSetStEph<Pair<V, V>>>,
   15|       |        pub parent: Option<AVLTreeSetStPer<Pair<V, V>>>, // (child, parent) edges
   17|       |        pub parent: Option<AVLTreeSetMtEph<Pair<V, V>>>,
   17|       |        pub parent: Option<AVLTreeSetStPer<Pair<V, V>>>, // (child, parent)
   18|       |        pub parent: Option<AVLTreeSetMtPer<Pair<V, V>>>,
   18|       |        pub parent: Option<AVLTreeSetMtPer<Pair<V, V>>>,
   60|       |        /// parent of node at index i
   91|    518|                let parent = result.nth(parent_idx);
   61|    518|        fn parent(i: N) -> N { if i == 0 { 0 } else { (i - 1) / 2 } }
   89|    518|                let parent_idx = Self::parent(i);
  101|     34|            let parent_u = entry.parent;
  115|      3|                        LabEdge(u.clone(), parent_v, weight)
  181|      0|            let parent_v = self.parent.get(v).unwrap().clone();
  183|      0|            if parent_v == *v {
   86|  1.17k|            let parent_v = self.parent.get(v).unwrap().clone();
   88|  1.17k|            if parent_v == *v {
  297|     51|        let part1 = partition.clone();
  299|     51|        let part2 = partition;
  302|     51|            reroute_edges_mt(edges2, part2, mid, end)
  263|     20|        let part_arc = Arc::new(full_partition);
   48|     38|        fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(self.cmp(other)) }
   48|     63|        fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(self.cmp(other)) }
   57|     29|        fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(self.cmp(other)) }
   69|    632|        fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(self.cmp(other)) }
   11|       |    impl<Key: PartialEq + Clone, Value: Clone> EntryTrait<Key, Value> for Vec<(Key, Value)> {
   12|       |    impl<Key: PartialEq + Clone, Value: Clone> EntryTrait<Key, Value> for LinkedList<(Key, Value)> {
  143|      3|            T: PartialEq,
  143|       |    impl<K: PartialEq> KeyEquality<K> for DefaultKeyEquality {
   15|       |    #[derive(Clone, PartialEq, Eq, Debug)]
  183|       |    impl PartialEq for MatrixChainMtPerS {
  226|       |    impl PartialEq for TopDownDPMtPerS {
  229|       |    impl PartialEq for MatrixChainMtEphS {
   22|       |    impl<Key: PartialEq + Clone, Value: Clone> EntryTrait<Key, Value> for FlatEntry<Key, Value> {
  234|       |    impl PartialEq for TopDownDPMtEphS {
   29|       |    impl<Key: PartialEq + Clone, Value: Clone> EntryTrait<Key, Value> for ChainList<Key, Value> {
  327|       |    impl<T: PartialEq> PartialEq for ArraySeqS<T> {
   59|       |    impl PartialEq for Probability {
    9|       |    #[derive(Clone, PartialEq, Eq, Debug)]
   47|       |    impl PartialOrd for PQEntry {
   47|       |    impl PartialOrd for PQEntry {
   68|       |    impl PartialOrd for Probability {
  100|       |        // Partition the graph in parallel
  144|     25|        (remaining, partition)
  150|     20|        let partition = filter_tail_to_head_mt(vertices_arc.clone(), bridges_arc, flips_arc, 0, vertices_len);
  160|     20|        (remaining, partition)
   60|       |        // Partition the graph
   62|       |        // Partition the graph in parallel
   95|       |        // Partition the graph
  139|     79|            if !partition.contains_key(v) {
  155|     70|            if !partition.contains_key(v) {
  110|     50|        (centers, partition_map)
   67|     30|        (centers, partition_map)
  219|      0|        fn partition(&self, parts: &Set<Set<T>>) -> B {
   38|       |        fn partition(&self, parts: &Set<Set<T>>) -> B;
  127|     23|        let part_map_arc = Arc::new(partition_map.clone());
  129|     23|        route_edges_parallel(&edges_seq, part_map_arc, 0, n_edges)
   95|     22|        let part_map_arc = Arc::new(partition_map.clone());
   99|      1|            let party_docs = (self.fw)(&"party".to_string());
   38|      1|        let path = ArraySeqStPerS::from_vec(vec![0, 1, 2, 3]);
    3|       |//! Shortest Path Utility Functions - Sequential Ephemeral (Integer Weights)
    3|       |//! Shortest Path Utility Functions - Sequential Persistent
   51|       |    /// Path is a sequence of vertices [v0, v1, ..., vk].
   52|       |    /// Path is a sequence of vertices [v0, v1, ..., vk].
    6|       |//! Shows path weight calculation for simple paths with both positive and negative weights.
   74|      1|        let path = ArraySeqStPerS::from_vec(vec![0, 1, 2, 3]);
   89|      1|        let path = ArraySeqStPerS::from_vec(vec![0, 1, 2]);
  141|     70|                    let path_dist = u_dist.saturating_add(*weight as i64);
  142|     70|                    if path_dist == v_dist {
  150|     73|                    let path_dist = OrderedF64::from(u_dist.0 + weight.0);
  151|     73|                    if path_dist == v_dist {
   11|       |//! - `path_weight`: Work O(k), Span O(k) where k is path length
   11|       |//! - `path_weight`: Work O(k), Span O(k) where k is path length
   28|       |        fn path_weight_float(
   29|       |        fn path_weight_float(
   75|      1|        match path_weight_float(&path, &weights) {
   43|      1|        match path_weight_int(&one_cycle, &weights) {
   24|       |        fn path_weight_int(path: &ArraySeqStPerS<usize>, weights: &ArraySeqStPerS<ArraySeqStPerS<i64>>) -> Option<i64>;
   25|       |        fn path_weight_int(path: &ArraySeqStPerS<usize>, weights: &ArraySeqStEphS<ArraySeqStEphS<i64>>) -> Option<i64>;
   39|      1|        match path_weight_int(&path, &weights) {
   90|      1|        match path_weight_int(&path, &weights) {
   37|      1|        match path_weight_int(&simple_path, &weights) {
   49|      1|        match path_weight_int(&two_cycles, &weights) {
   14|       |pub mod PathWeightUtilsStEph {
   14|       |pub mod PathWeightUtilsStPer {
   11|       |        /// Pattern: reduce max MIN identity
   12|       |        /// Pattern: reduce max MIN identity (parallel)
   17|       |        /// Pattern: reduce (+) 0 identity
   18|       |        /// Pattern: reduce (+) 0 identity (parallel)
   23|       |        /// Pattern: reduce (*) 1 identity
   24|       |        /// Pattern: reduce (*) 1 identity (parallel)
   29|       |        /// Pattern: reduce (||) false identity
   30|       |        /// Pattern: reduce (||) false identity (parallel)
   35|       |        /// Pattern: reduce (&&) true identity
   36|       |        /// Pattern: reduce (&&) true identity (parallel)
  196|     89|            if pattern.is_empty() {
    5|       |//! diagonal pebbling strategy for efficient computation of DP tables.
    5|       |//! diagonal pebbling strategy with in-place mutations for efficiency.
   11|       |//! - `peek`: Work O(1), Span O(1)
  177|       |        // Perform bridge star partition
  244|       |        // Perform bridge star partition
  146|      1|        println!("\n=== Performance Comparison ===");
  175|      2|- Maintained performance with appropriate load factor
  179|       |    /// Performance demonstration: compare indexed search vs brute force
  244|      0|            writeln!(f, "Performance Summary:")?;
   28|       |    /// Performance Impact Assessment
  412|      0|            writeln!(f, "Performance Impact Assessment:")?;
  434|      0|            writeln!(f, "Performance ranking:")?;
  114|     19|            let performance_impact =
  156|     16|            let performance_impact =
  194|     16|            let performance_impact =
   25|       |        pub performance_impact: ClusteringPerformanceImpact,
   57|       |        pub performance_ranking: Vec<(String, f64)>,
  267|      2|        let performance_summary = "Expected probes for unsuccessful search: 1/(1-α). For α=0.5, this is 2 probes. \
  302|      2|        let performance_summary = "For prime table sizes with c₂ ≠ 0, quadratic probing guarantees that the probe \
  336|      2|        let performance_summary = "Double hashing achieves performance close to uniform hashing: expected probes \
  368|      2|        let performance_summary =
   38|       |        pub performance_summary: String,
  121|       |    /// Performs star contraction along vertex bridges using randomized coin flips.
   13|       |        /// Performs DFS from source vertex s on adjacency list graph G
   13|       |        /// Performs DFS from source vertex s on adjacency list graph G
   14|       |        /// Performs BFS from source vertex s on adjacency list graph G
   14|       |        /// Performs BFS from source vertex s on adjacency list graph G
   15|       |        /// Performs parallel BFS from source vertex s on adjacency list graph G
   15|       |        /// Performs parallel BFS from source vertex s on adjacency list graph G
   18|       |    /// Performs DFS from source vertex s on adjacency list graph G.
   18|       |    /// Performs DFS from source vertex s on adjacency list graph G.
   21|       |    /// Performs BFS from source vertex s on adjacency list graph G.
   21|       |    /// Performs BFS from source vertex s on adjacency list graph G.
   22|       |    /// Performs parallel BFS from source vertex s on adjacency list graph G.
   22|       |    /// Performs parallel BFS from source vertex s on adjacency list graph G.
   49|       |    /// Performs DFS traversal that visits each edge twice (once in each direction).
   99|       |    /// Performs star contraction along vertex bridges using randomized coin flips.
  123|     32|            if period == 0 {
  154|     27|            let period = RelativePrimeValidator::probe_sequence_period(h2_value, table_size);
   24|       |        pub period: N,
  297|      1|   - Periodic cleanup of Dead entries
  183|      1|        let per_map_time = start.elapsed();
  120|      1|        println!("  Persistent: key 20 -> {:?}", table_per_tab.find(&20));
   17|       |    /// Persistent single-threaded matrix chain multiplication solver using dynamic programming
   19|       |    /// Persistent multi-threaded matrix chain multiplication solver using parallel dynamic programming
   19|       |    /// Persistent single-threaded optimal binary search tree solver using dynamic programming
   20|       |    /// Persistent multi-threaded optimal binary search tree solver using parallel dynamic programming
    2|       |//! Multi-threaded persistent matrix chain multiplication implementation using Vec and Arc for thread safety.
    2|       |//! Multi-threaded persistent optimal binary search tree implementation using Vec and Arc for thread safety.
    2|       |//! Multi-threaded persistent ordered table implementation.
    2|       |//! Multi-threaded persistent set implementation using AVLTreeSeqMtPer (Arc-based).
    2|       |//! Single-threaded persistent ordered set implementation extending AVLTreeSetStPer.
    2|       |//! Single-threaded persistent ordered table implementation extending TableStPer.
    2|       |//! Single-threaded persistent reducer-augmented ordered table implementation.
    2|       |//! Single-threaded persistent set implementation using AVLTreeSeqStPer as backing store.
   46|      1|            "After persistent insert - original size: {}, new size: {}",
    8|       |//! Uses persistent array sequences for functional-style immutability.
    8|       |//! Uses persistent array sequences for functional-style immutability.
    8|       |//! Uses persistent array sequences for functional-style immutability.
    8|       |//! Uses persistent array sequences for functional-style immutability.
    8|       |//! Uses persistent data structures for path manipulation.
  157|      1|        let per_time = start.elapsed();
   84|     60|                priority_fn: &PF,
   91|     60|                priority_fn: &PF,
   94|     30|                priority_fn: &PF,
  128|     13|            let p_from = *potentials.nth(*from);
  144|     15|            let p_from = *potentials.nth(*from);
   15|       |        pub _phantom: std::marker::PhantomData<(Key, Value)>,
   30|       |        pub _phantom: PhantomData<(Key, Value)>,
  283|     18|                _op: PhantomData,
   55|     29|                _phantom: PhantomData,
   76|       |        _op: PhantomData<Op>,
   10|       |//! - Phase 2 (Reweighting): Work O(m), Span O(m)
   10|       |//! - Phase 2 (Reweighting): Work O(m), Span O(m)
   10|       |//! - Phase 2 (Reweighting): Work O(m), Span O(m) - sequential
   10|       |//! - Phase 2 (Reweighting): Work O(m), Span O(m) - sequential
   11|       |//! - Phase 3 (n Dijkstras in parallel): Work O(n * m log n) = O(mn log n), Span O(m log n)
   11|       |//! - Phase 3 (n Dijkstras in parallel): Work O(n * m log n) = O(mn log n), Span O(m log n)
   11|       |//! - Phase 3 (n Dijkstras): Work O(n * m log n) = O(mn log n), Span O(mn log n) sequential
   11|       |//! - Phase 3 (n Dijkstras): Work O(n * m log n) = O(mn log n), Span O(mn log n) sequential
   35|       |    /// Phase 1: Flip coins for all edges in parallel - Θ(|E|) parallelism
   36|       |    /// Phase 2: Select edges based on local maxima - Θ(|E|) parallelism with degree-dependent checks
   46|       |    /// Phase 1: Build vertex-to-block mapping - Θ(|V|) parallelism
   47|       |    /// Phase 2: Build new vertex set - Θ(|V|) parallelism
   48|       |    /// Phase 3: Build new edge set - Θ(|E|) parallelism
   51|       |        // Phase 1: Add dummy source and run Bellman-Ford
   58|       |        // Phase 1: Flip coins for each vertex (heads = true, tails = false)
   60|       |        // Phase 1: Flip coins for all edges in parallel
   61|       |        // Phase 1: Add dummy source and run Bellman-Ford
   61|       |        // Phase 1: Add dummy source and run Bellman-Ford
   63|       |        // Phase 2: Select edges where coin is heads and all adjacent edges are tails
   64|       |        // Phase 2: Find edges from tails to heads (TH)
   65|       |        // Phase 1: Assign block representatives for matched edges (sequential for now)
   65|       |        // Phase 2: Reweight edges
   68|       |        // Phase 3: Run Dijkstra from each vertex and adjust distances
   69|       |    /// Phase 1: Flip coins for all edges in parallel
   75|       |        // Phase 2: Reweight edges to eliminate negative weights
   75|       |        // Phase 2: Reweight edges to eliminate negative weights
   78|       |        // Phase 3: Run Dijkstra from each vertex IN PARALLEL and adjust distances
   78|       |        // Phase 3: Run Dijkstra from each vertex IN PARALLEL and adjust distances
   84|       |        // Phase 2: Build new vertex set (representatives)
   85|       |        // Phase 3: Build base sequence V' where each index maps to itself
   88|       |        // Phase 4: Convert th_edges to ArraySeqStEphS<Pair<usize, V>>
   90|       |        // Phase 3: Build new edge set in parallel
   93|       |    /// Phase 2: Select edges in parallel where coin is heads and adjacent edges are tails
   93|       |        // Phase 5: Apply inject to get partition map P
   96|       |        // Phase 6: Extract centers (vertices where P[v] = v)
    9|       |//! - Phase 1 (Bellman-Ford): Work O(nm), Span O(nm)
    9|       |//! - Phase 1 (Bellman-Ford): Work O(nm), Span O(nm)
    9|       |//! - Phase 1 (Bellman-Ford): Work O(nm), Span O(nm) - sequential
    9|       |//! - Phase 1 (Bellman-Ford): Work O(nm), Span O(nm) - sequential
  104|  5.81k|                    let pivot = {
  105|      6|                let pivot = median3(a, lo, hi);
  109|    111|                let pivot = if (x0 <= xm && xm <= xl) || (xl <= xm && xm <= x0) {
  113|     30|                let pivot = right.nth(mid_right);
  142|      6|                let pivot = a.nth(idx).clone();
  156|    208|                let pivot = data[idx].clone();
  157|    178|                    let pivot = data[idx].clone();
   28|     72|            let pivot = self.nth(pivot_idx).clone();
   28|     72|            let pivot = self.nth(pivot_idx).clone();
   28|     83|            let pivot = self.nth(pivot_idx).clone();
   30|     71|            let pivot = self.nth_cloned(pivot_idx);
   57|     10|                let pivot = a.nth(lo).clone();
   64|    346|                let pivot = data[0].clone();
   66|    253|                    let pivot = data[0].clone();
   67|     26|                let pivot = left.nth(mid_left);
   27|     72|            let pivot_idx = rand::rng().random_range(0..n);
   27|     72|            let pivot_idx = rand::rng().random_range(0..n);
   27|     83|            let pivot_idx = rand::rng().random_range(0..n);
   29|     71|            let pivot_idx = rand::rng().random_range(0..n);
   15|       |        fn pivot_mt_first(&self, lo: N, hi: N) -> T;
   15|       |        fn pivot_mt_first(&self, lo: N, hi: N) -> T;
   34|      5|        fn pivot_mt_first(&self, lo: N, _hi: N) -> T { self.nth_cloned(lo) }
   34|      9|        fn pivot_mt_first(&self, lo: N, _hi: N) -> T { self.nth_cloned(lo) }
   18|       |        fn pivot_mt_median3(&self, lo: N, hi: N) -> T;
   18|       |        fn pivot_mt_median3(&self, lo: N, hi: N) -> T;
   35|      6|        fn pivot_mt_median3(&self, lo: N, hi: N) -> T {
   36|      8|        fn pivot_mt_median3(&self, lo: N, hi: N) -> T {
   21|       |        fn pivot_mt_random(&self, lo: N, hi: N) -> T;
   21|       |        fn pivot_mt_random(&self, lo: N, hi: N) -> T;
   48|      4|        fn pivot_mt_random(&self, lo: N, hi: N) -> T {
   50|     19|        fn pivot_mt_random(&self, lo: N, hi: N) -> T {
  107|     26|                let pivot_seq = ArraySeqMtPerS::singleton(pivot.clone());
  153|     30|                let pivot_seq = ArraySeqMtPerS::singleton(pivot.clone());
   13|       |        fn pivot_st_first(&self, lo: N, hi: N) -> T;
   32|      2|        fn pivot_st_first(&self, lo: N, _hi: N) -> T { self.nth(lo).clone() }
   16|       |        fn pivot_st_median3(&self, lo: N, hi: N) -> T;
   33|      3|        fn pivot_st_median3(&self, lo: N, hi: N) -> T {
   19|       |        fn pivot_st_random(&self, lo: N, hi: N) -> T;
   46|      1|        fn pivot_st_random(&self, lo: N, hi: N) -> T {
  129|      2|                let plus_u = self.NPlus(u);
  253|  10.0k|                    let plus_u = self.NPlus(&u);
   12|       |        fn points2d(n: N) -> ArraySeqStPerS<Pair<N, N>>;
   12|       |        fn points2d_tab_flat(n: N) -> ArraySeqStPerS<Pair<N, N>>;
   12|       |        fn points3d_loops(n: N) -> ArraySeqStPerS<Pair<N, Pair<N, N>>>;
   12|       |        fn points3d_tab_flat(n: N) -> ArraySeqStPerS<Pair<N, Pair<N, N>>>;
   78|       |    /// Polynomial rolling hash function for strings
   85|       |    impl PolynomialHashFunction {
   10|       |//! - `pop`: Work O(1) amortized, Span O(1) amortized
  127|       |        /// Pop every element into a Vec for testing/teardown convenience.
   29|       |        /// Pop element from stack
   91|       |        /// Pop value from stack using lock-free CAS.
   31|       |        fn pop(&mut self) -> Option<T>;
   53|       |        /// Pops and returns the top item from the stack
   31|       |        fn pop(&self) -> Option<T>;
   95|  7.21k|        fn pop(&self) -> Option<T> {
  109|    272|            let pos = insertion_pos.expect("Table should have space for insertion");
  114|    420|                let pos = strategy.probe_hash(&key.to_string(), i, table_size);
  153|      3|                    if pos > 0 {
  160|      4|                    if pos > 0 {
  173|      4|                    if pos + 1 < self.elements.len() {
  180|      4|                    if pos < self.elements.len() {
  191|      2|            let pos = match self.elements.binary_search(k) {
  196|  3.28k|                    let pos = (i + self.c1 * probe_idx + self.c2 * probe_idx * probe_idx) % size;
  246|      1|        let pos = table.probe_hash(key, probe_index);
  286|    157|            let pos = insertion_pos.expect("Table should have space");
   78|    337|                let pos = strategy.probe_hash(&key.to_string(), i, table_size);
  197|     27|                "Scattered positions (good distribution)".to_string()
   89|     13|            let positions: Vec<(usize, usize)> = (start..=end)
   89|     16|            let positions: Vec<(usize, usize)> = (start..=end)
  435|      2|            performance_summary: "Potentially degraded quadratic probing performance".to_string(),
   58|     15|        let potentials = ArraySeqStEphS::tabulate(&|i| bellman_ford_result.get_distance(i), n);
   63|     15|        let potentials = ArraySeqStEphS::tabulate(&|i| bellman_ford_result.get_distance(i), n);
   73|     15|        let potentials = ArraySeqStEphS::tabulate(&|i| bellman_ford_result.get_distance(i), n);
   73|     28|        let potentials = ArraySeqStEphS::tabulate(&|i| bellman_ford_result.get_distance(i), n);
  137|     10|        let potentials_left = potentials.clone();
  137|     18|        let potentials_left = potentials.clone();
  138|     10|        let potentials_right = potentials.clone();
  138|     18|        let potentials_right = potentials.clone();
   31|       |    struct PQEntry {
   31|       |    struct PQEntry {
   36|       |    impl PQEntry {
   36|       |    impl PQEntry {
   36|       |    struct PQEntry<V: StT + Hash + Ord> {
  104|    123|        while !pq.is_empty() {
  122|     99|        while !pq.is_empty() {
   50|     99|        while !pq.is_empty() {
   68|     99|        while !pq.is_empty() {
   83|    154|        while !pq.is_empty() {
   83|    158|        while !pq.is_empty() {
   86|     99|        while !pq.is_empty() {
   90|     42|        while !pq.is_empty() {
   41|       |        fn pq_min<G, PF>(graph: &G, source: V, priority_fn: &PF) -> PQMinResult<V, P>
   48|       |        fn pq_min<G, PF>(graph: &G, source: V, priority_fn: &PF) -> PQMinResult<V, P>
   49|       |        fn pq_min<G, PF>(graph: &G, source: V, priority_fn: &PF) -> PQMinResult<V, P>
   58|       |        fn pq_min<G, PF>(graph: G, source: V, priority_fn: PF) -> PQMinResult<V, P>
    7|       |pub mod PQMinMtEph {
    8|       |pub mod PQMinMtPer {
   47|       |        fn pq_min_multi<G, PF>(graph: &G, sources: AVLTreeSetStEph<V>, priority_fn: &PF) -> PQMinResult<V, P>
   54|       |        fn pq_min_multi<G, PF>(graph: &G, sources: AVLTreeSetMtPer<V>, priority_fn: &PF) -> PQMinResult<V, P>
   54|       |        fn pq_min_multi<G, PF>(graph: &G, sources: AVLTreeSetStPer<V>, priority_fn: &PF) -> PQMinResult<V, P>
   64|       |        fn pq_min_multi<G, PF>(graph: G, sources: AVLTreeSetMtEph<V>, priority_fn: PF) -> PQMinResult<V, P>
    4|       |pub mod PQMinStEph {
    7|       |pub mod PQMinStPer {
  101|       |    // Pred: Multi-threaded predicate function (boolean function)
  110|     11|                let pred = *self.predecessors.nth(current);
  111|     11|                if pred == NO_PREDECESSOR {
  112|      3|                let pred = *self.predecessors.nth(current);
  113|      3|                if pred == NO_PREDECESSOR {
  117|      3|                let pred = *self.predecessors.nth(current);
  118|      3|                if pred == NO_PREDECESSOR {
  120|      3|                let pred = *self.predecessors.nth(current);
  121|      3|                if pred == NO_PREDECESSOR {
  123|      3|                let pred = *self.predecessors.nth(u).nth(current);
  124|      3|                if pred == NO_PREDECESSOR {
  125|      3|                let pred = *self.predecessors.nth(u).nth(current);
  125|      3|                let pred = *self.predecessors.nth(u).nth(current);
  126|      3|                if pred == NO_PREDECESSOR {
  126|      3|                if pred == NO_PREDECESSOR {
  127|      3|                let pred = *self.predecessors.nth(u).nth(current);
  128|      3|                if pred == NO_PREDECESSOR {
   84|      2|            let pred = *self.predecessors.nth(v);
   85|      2|            if pred == NO_PREDECESSOR { None } else { Some(pred) }
   86|      2|            let pred = *self.predecessors.nth(v);
   86|      2|            let pred = self.predecessors.nth(v).clone();
   87|      2|            if pred == NO_PREDECESSOR { None } else { Some(pred) }
   87|      2|            if pred == NO_PREDECESSOR { None } else { Some(pred) }
   89|      2|            let pred = self.predecessors.nth(v).clone();
   90|      2|            if pred == NO_PREDECESSOR { None } else { Some(pred) }
   90|      2|            let pred = self.predecessors.nth(u).nth(v).clone();
   91|      2|            if pred == NO_PREDECESSOR { None } else { Some(pred) }
   92|      2|            let pred = *self.predecessors.nth(u).nth(v);
   92|      2|            let pred = self.predecessors.nth(u).nth(v).clone();
   93|      2|            if pred == NO_PREDECESSOR { None } else { Some(pred) }
   93|      2|            if pred == NO_PREDECESSOR { None } else { Some(pred) }
   94|      2|            let pred = *self.predecessors.nth(u).nth(v);
   95|      2|            if pred == NO_PREDECESSOR { None } else { Some(pred) }
  161|    112|                let pred_clone = pred.clone();
  181|     11|                let pred_clone = pred.clone();
  218|     12|                let pred_clone = pred.clone();
   42|       |        /// Predecessor matrix: predecessors.nth(u).nth(v) is the predecessor of v on shortest path from u.
   42|       |        /// Predecessor of each vertex in shortest path tree (usize::MAX for source/unreachable).
   43|       |        /// Predecessor matrix: predecessors.nth(u).nth(v) is the predecessor of v on shortest path from u.
   43|       |        /// Predecessor of each vertex in shortest path tree (usize::MAX for source/unreachable).
   44|       |        /// Predecessor matrix: predecessors.nth(u).nth(v) is the predecessor of v on shortest path from u.
   45|       |        /// Predecessor matrix: predecessors.nth(u).nth(v) is the predecessor of v on shortest path from u.
   45|       |        /// Predecessor of each vertex in shortest path tree (usize::MAX for source/unreachable).
   45|       |        /// Predecessor of each vertex in shortest path tree (usize::MAX for source/unreachable).
  138|      0|        let predecessors = ArraySeqStEphS::tabulate(&|_| ArraySeqStEphS::tabulate(&|_| 0, n), n);
  156|      0|        let predecessors = ArraySeqStEphS::tabulate(&|_| ArraySeqStEphS::tabulate(&|_| 0, n), n);
  209|      0|        let predecessors = ArraySeqStEphS::tabulate(&|_| ArraySeqStEphS::tabulate(&|_| 0, n), n);
  215|      0|        let predecessors = ArraySeqStEphS::tabulate(&|_| ArraySeqStEphS::tabulate(&|_| 0, n), n);
   43|       |        pub predecessors: ArraySeqStPerS<ArraySeqStPerS<usize>>,
   43|       |        pub predecessors: ArraySeqStPerS<usize>,
   44|       |        pub predecessors: ArraySeqStEphS<ArraySeqStEphS<usize>>,
   44|       |        pub predecessors: ArraySeqStEphS<usize>,
   45|       |        pub predecessors: ArraySeqStPerS<ArraySeqStPerS<usize>>,
   46|       |        pub predecessors: ArraySeqStEphS<ArraySeqStEphS<usize>>,
   46|       |        pub predecessors: ArraySeqStEphS<usize>,
   46|       |        pub predecessors: ArraySeqStPerS<usize>,
   53|      5|            let predecessors = ArraySeqStPerS::tabulate(&|_| NO_PREDECESSOR, n);
   56|     16|            let predecessors = ArraySeqStPerS::tabulate(&|_| ArraySeqStPerS::tabulate(&|_| NO_PREDECESSOR, n), n);
   56|      5|            let predecessors = ArraySeqStPerS::tabulate(&|_| NO_PREDECESSOR, n);
   56|     61|            let predecessors = ArraySeqStEphS::new(n, NO_PREDECESSOR);
   58|     16|            let predecessors = ArraySeqStPerS::tabulate(&|_| ArraySeqStPerS::tabulate(&|_| NO_PREDECESSOR, n), n);
   58|     71|            let predecessors = ArraySeqStEphS::new(n, NO_PREDECESSOR);
   62|      5|            let predecessors = ArraySeqStEphS::from_vec(pred_matrix);
   64|      5|            let predecessors = ArraySeqStEphS::from_vec(pred_matrix);
  234|      3|            let predicate = Arc::new(predicate);
  235|      3|            ParamTreap::filter_inner(tree, &predicate)
  237|      5|            let predicate = Arc::new(predicate);
  238|      5|            ParamBST::filter_inner(tree, &predicate)
  335|      1|            Self::filter(self, predicate)
  367|      5|            ParamBST::filter_parallel(self, predicate)
  399|     10|                if predicate(current) {
  222|     11|                    if (**predicate)(&key) {
  225|    271|                    if (**predicate)(&key) {
   74|       |        /// Predicates.
  180|  59.3k|                if pred(item) == true {
  255|     14|                if pred(item) == true {
  216|     11|                    let pred_left = Arc::clone(predicate);
  219|    271|                    let pred_left = Arc::clone(predicate);
   61|      5|            let pred_matrix = vec![ArraySeqStEphS::new(n, NO_PREDECESSOR); n];
   63|      5|            let pred_matrix = vec![ArraySeqStEphS::new(n, NO_PREDECESSOR); n];
  217|     11|                    let pred_right = Arc::clone(predicate);
  220|     11|                            ParamTreap::filter_inner(&right, &pred_right)
  220|    271|                    let pred_right = Arc::clone(predicate);
  223|    271|                            ParamBST::filter_inner(&right, &pred_right)
  129|     15|            let pred_seq = ArraySeqStEphS::singleton(dijkstra_result.predecessors.clone());
  129|     28|            let pred_seq = ArraySeqStEphS::singleton(dijkstra_result.predecessors.clone());
  106|       |    // PredVal: Multi-threaded predicate function taking values by value
  226|    311|                if pred(value) == true {
  237|      7|                if pred(value) == true {
  255|     10|                if pred(&value) == true {
  288|     10|                if pred(value) == true {
  304|     13|                if pred(value) == true {
   74|       |            // Preemptive resize check: if inserting a new key would exceed threshold, resize first
  377|     11|                let prefix = a.subseq_copy(0, i);
  418|     10|                let prefix = a.subseq_copy(0, i);
  139|      7|        fn pre_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  141|      7|        fn pre_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  171|     18|        fn pre_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  172|      0|        fn pre_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  176|     68|        fn pre_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  196|     19|        fn pre_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  196|      7|        fn pre_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  215|     16|        fn pre_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  218|      0|        fn pre_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  232|      7|        fn pre_order_collect(link: &Link<T>, out: &mut Vec<T>) {
  118|      0|        fn pre_order(&self) -> ArraySeqStPerS<T> { BalBinTree::pre_order(self) }
  181|      1|        fn pre_order(&self) -> ArraySeqStPerS<T> {
  204|      1|        fn pre_order(&self) -> ArraySeqStPerS<T> {
  216|      4|        fn pre_order(&self) -> ArraySeqStPerS<T> {
  237|      0|        fn pre_order(&self) -> ArraySeqStPerS<T> {
  238|      3|        fn pre_order(&self) -> ArraySeqStPerS<T> {
  244|      2|        fn pre_order(&self) -> ArraySeqStPerS<T> {
  253|      1|        fn pre_order(&self) -> ArraySeqStPerS<T> {
  260|      0|        fn pre_order(&self) -> ArraySeqStPerS<T> {
  262|      2|        fn pre_order(&self) -> ArraySeqStPerS<T> {
  298|      1|        fn pre_order(&self) -> ArraySeqStPerS<T> {
   39|       |        fn pre_order(&self) -> ArraySeqStPerS<T>;
   41|       |        fn pre_order(&self) -> ArraySeqStPerS<T>;
   60|       |        fn pre_order(&self) -> ArraySeqStPerS<T>;
   61|       |        fn pre_order(&self) -> ArraySeqStPerS<T>;
   62|       |        fn pre_order(&self) -> ArraySeqStPerS<T>;
   62|       |        fn pre_order(&self) -> ArraySeqStPerS<T>;
   62|       |        fn pre_order(&self) -> ArraySeqStPerS<T>;
   62|       |        fn pre_order(&self) -> ArraySeqStPerS<T>;
   62|       |        fn pre_order(&self) -> ArraySeqStPerS<T>;
   62|       |        fn pre_order(&self) -> ArraySeqStPerS<T>;
   62|       |        fn pre_order(&self) -> ArraySeqStPerS<T>;
   68|       |        fn pre_order(&self) -> ArraySeqStPerS<T>;
   71|      3|        fn pre_order(&self) -> ArraySeqStPerS<T> { self.root.pre_order() }
  311|      0|                let prev = self.elements.nth(i - 1);
  313|      0|                if prev > curr {
  342|      4|                let prev = self.elements.nth(i - 1);
  344|      4|                if prev > curr {
  122|       |        // previous(A, 'rachel') → 'mike'
  213|      9|        fn previous_key(&self, k: &K) -> Option<K> {
  222|      7|        fn previous_key(&self, k: &K) -> Option<K> { self.base_table.previous_key(k) }
  226|     12|        fn previous_key(&self, k: &K) -> Option<K> {
  235|      7|        fn previous_key(&self, k: &K) -> Option<K> { self.base_table.previous_key(k) }
  255|     12|        fn previous_key(&self, k: &K) -> Option<K> {
  256|      1|        fn previous_key(&self, k: &K) -> Option<K> { self.base_table.previous_key(k) }
   54|       |        fn previous_key(&self, k: &K) -> Option<K>;
   57|       |        fn previous_key(&self, k: &K) -> Option<K>;
   61|       |        fn previous_key(&self, k: &K) -> Option<K>;
   62|       |        fn previous_key(&self, k: &K) -> Option<K>;
   67|       |        fn previous_key(&self, k: &K) -> Option<K>;
   70|       |        fn previous_key(&self, k: &K) -> Option<K>;
  150|      7|        fn previous(&self, k: &T) -> Option<T> {
  172|     14|        fn previous(&self, k: &T) -> Option<T> {
  177|      7|        fn previous(&self, k: &T) -> Option<T> {
   52|       |        fn previous(&self, k: &T) -> Option<T>;
   53|       |        fn previous(&self, k: &T) -> Option<T>;
   53|       |        fn previous(&self, k: &T) -> Option<T>;
   19|       |    /// Primary Clustering Metrics
  231|      1|            writeln!(f, "Primary Clustering Metrics:")?;
  363|      2|             to primary clustering. (2) Quadratic probing spreads probes more evenly but keys \
  104|     19|            let primary_clustering = if self.detailed_metrics {
   21|       |        pub primary_clustering: Option<PrimaryClusteringMetrics>,
  127|     17|                return PrimaryClusteringMetrics {
   58|      1|                return PrimaryClusteringMetrics {
   69|      0|                return PrimaryClusteringMetrics {
   34|       |    /// Prime Table Size Validator
  403|       |    /// Prime vs Composite Table Size Comparison
  410|       |        // Prime table size analysis
  420|      2|            clustering_analysis: "Prime table size ensures good probe sequence distribution".to_string(),
  294|     16|                let prime_bonus = if m.table_size_is_prime { -10.0 } else { 20.0 };
  308|     16|                let prime_bonus = if m.relative_prime_validation { -15.0 } else { 25.0 };
  414|      2|        let prime_results = TextbookExampleResults {
   17|       |    /// primesBF n = { i in 2..n : isPrime(i) }
   13|       |        fn primes_bf(n: N) -> ArraySeqStPerS<N>;
  412|      2|        let prime_sequences = vec![analyzer.analyze_quadratic_probing(test_key, prime_size, 1, 1)];
  419|      2|            probe_sequences: prime_sequences,
   12|       |        fn prime_sieve(n: N) -> ArraySeqStPerS<N>;
  411|      2|        let prime_size = 17;
  417|      2|            table_size: prime_size,
  286|      0|                "AdvancedDoubleHashing(clustering_enabled={}, prime_validation={})",
   39|       |    impl PrimeValidator {
   56|       |    /// Primitive tree sequence stored as a persistent Vec-backed collection.
   24|       |        fn prim_mst<V: StT + Hash + Ord + Display>(
   22|       |        /// Prim's MST algorithm
    7|       |pub mod PrimStEph {
   10|       |pub mod PrimTreeSeqSt {
  104|      5|                    PrimTreeSeqStTree::Two(PrimTreeSeqStS::from_vec(left), PrimTreeSeqStS::from_vec(right))
  146|      0|                    PrimTreeSeqStTree::Two(PrimTreeSeqStS::from_vec(left), PrimTreeSeqStS::from_vec(right))
   53|       |        Two(PrimTreeSeqStS<T>, PrimTreeSeqStS<T>),
  115|      1|                | PrimTreeSeqStTree::One(value) => Self::singleton(value),
  154|      0|                | PrimTreeSeqStTree::One(value) => Self::singleton(value),
  116|      5|                | PrimTreeSeqStTree::Two(left, right) => {
  155|      0|                | PrimTreeSeqStTree::Two(left, right) => {
  114|      1|                | PrimTreeSeqStTree::Zero => Self::empty(),
  153|      0|                | PrimTreeSeqStTree::Zero => Self::empty(),
  123|     13|                    (visited, priorities)
  134|     13|                    (visited, priorities)
  138|      7|                    (visited, priorities)
   13|       |        pub priorities: AVLTreeSetStEph<Pair<V, P>>,
   16|       |        pub priorities: AVLTreeSetMtEph<Pair<V, P>>,
   16|       |        pub priorities: AVLTreeSetStPer<Pair<V, P>>,     // (vertex, priority)
   17|       |        pub priorities: AVLTreeSetMtPer<Pair<V, P>>,
  113|      1|                    let priority = priority_for(&key);
   20|       |    /// Priority function: maps vertices to their priorities.
   20|       |    /// Priority function: maps vertices to their priorities.
   21|       |    /// Priority Queue implemented using Leftist Heap
   28|       |    /// Priority queue entry: (distance, vertex)
   28|       |    /// Priority queue entry: (distance, vertex)
   34|       |    /// Priority queue entry for Prim's algorithm
  368|    206|            let priority = priority_for(&key);
   47|       |        /// Priority Queue Search from a single source.
   53|       |    /// Priority queue minimum search starting from single source.
   53|       |        /// Priority Queue Search from multiple sources.
   60|       |    /// Priority queue minimum search starting from single source.
   60|       |    /// Priority queue minimum search starting from single source.
   64|       |    /// Priority queue minimum search starting from multiple sources.
   69|       |    /// Priority: p(v) = min_{x∈X} w(x,v)
   70|       |    /// Priority queue minimum search starting from single source.
   71|       |    /// Priority queue minimum search starting from multiple sources.
   71|       |    /// Priority queue minimum search starting from multiple sources.
   78|       |        // Priority queue Q: stores PQEntry(distance, vertex)
   78|       |        // Priority queue Q: stores PQEntry(distance, vertex)
   81|       |    /// Priority queue minimum search starting from multiple sources.
   87|       |        // Priority queue
   89|  1.11k|            if priority > left_priority && priority > right_priority {
   47|       |        /// Priority-First Search using thread-safe persistent sets.
    5|       |//! Uses priority-first search similar to Dijkstra's algorithm.
  114|     47|                    explore(graph, priority_fn, visited_new, frontier_updated)
  124|     47|                    explore(graph, priority_fn, visited_new, frontier_updated)
  128|     23|                    explore(graph, priority_fn, visited_new, frontier_updated)
  102|     30|                PF: PriorityFn<V, P>,
   44|       |            PF: PriorityFn<V, P>;
   50|       |            PF: PriorityFn<V, P>;
   51|       |            PF: PriorityFn<V, P>;
   52|       |            PF: PriorityFn<V, P>;
   57|       |            PF: PriorityFn<V, P>;
   57|       |            PF: PriorityFn<V, P>;
   58|     12|        PF: PriorityFn<V, P>,
   61|       |            PF: PriorityFn<V, P>;
   65|     12|        PF: PriorityFn<V, P>,
   65|      6|        PF: PriorityFn<V, P>,
   67|       |            PF: PriorityFn<V, P>;
   69|     13|        PF: PriorityFn<V, P>,
   75|      6|        PF: PriorityFn<V, P>,
   76|     13|        PF: PriorityFn<V, P>,
   76|      7|        PF: PriorityFn<V, P>,
   86|      7|        PF: PriorityFn<V, P>,
   92|     60|                PF: PriorityFn<V, P>,
   99|     60|                PF: PriorityFn<V, P>,
   33|    207|    fn priority_for<T: MtKey>(key: &T) -> i64 {
   18|       |        fn priority(&self, v: &V) -> P;
   22|       |        fn priority(&self, v: &V) -> P;
   23|       |        fn priority(&self, v: &V) -> P;
   23|       |        fn priority(&self, v: &V) -> P;
   36|    145|        fn priority(&self, v: &V) -> P { (self.f)(v) }
   42|    145|        fn priority(&self, v: &V) -> P { (self.f)(v) }
   42|     70|        fn priority(&self, v: &V) -> P { (self.f)(v) }
   50|     70|        fn priority(&self, v: &V) -> P { (self.f)(v) }
  113|       |        // Private helper methods only - no public delegation
   43|       |        // Private helper methods only - no public delegation
   65|       |        // Private helper methods only - no public delegation
   68|       |        // Private helper methods only - no public delegation
   69|       |        // Private helper methods only - no public delegation
   70|       |        // Private helper methods only - no public delegation
   70|       |        // Private helper methods only - no public delegation
   70|       |        // Private helper methods only - no public delegation
   70|       |        // Private helper methods only - no public delegation
   70|       |        // Private helper methods only - no public delegation
   70|       |        // Private helper methods only - no public delegation
   71|       |        // Private helper methods only - no public delegation
   72|       |        // Private helper methods only - no public delegation
   76|       |        // Private helper methods only - no public delegation
  111|     73|                .map(|(key, prob)| KeyProb { key, prob })
  143|     34|                .map(|(key, prob)| KeyProb { key, prob })
  144|       |    macro_rules! prob {
  155|     68|                .map(|(key, prob)| KeyProb { key, prob })
   16|       |        pub prob: Probability,
   16|       |        pub prob: Probability,
   17|       |        pub prob: Probability,
   17|       |        pub prob: Probability,
   99|     45|                .map(|(key, prob)| KeyProb { key, prob })
  138|       |    // Probability implements Eq + Clone + Display + Debug + Sized, so it gets StT automatically
  139|       |    // Probability implements StT + Send + Sync, so it gets StTInMtT automatically
  140|       |    // Probability implements StTInMtT + 'static, so it gets MtVal automatically
   29|       |    impl Probability {
    7|       |pub mod Probability {
   60|      0|                return Probability::infinity();
   69|      0|                return Probability::infinity();
  117|      2|                return Probability::zero();
  129|      2|                return Probability::zero();
  164|      1|                return Probability::zero();
  181|      1|                return Probability::zero();
   12|       |    /// Probe sequence: h_i(k) = (h(k) + i²) mod m
   12|       |    /// Probe sequence: h_i(k) = (h(k) + i·hh(k)) mod m
  153|       |            // Probe variance: variance in cluster sizes
  218|      0|            writeln!(f, "Probe sequence: {:?}", self.probe_sequence)?;
   41|       |    /// Probe Sequence Generator and Analyzer
  187|     20|                probe_sequence_length: probe_count,
  329|      1|        let probe_demo = example_47_4_probe_sequence();
  209|    417|        fn probe_hash(&self, key: &K, probe_index: N, table_size: N) -> N {
   26|    875|        fn probe_hash(&self, key: &K, probe_index: N, table_size: N) -> N {
  269|     82|        fn probe_hash(&self, key: &K, probe_index: N, table_size: N) -> N {
   28|    390|        fn probe_hash(&self, key: &K, probe_index: N, table_size: N) -> N {
  298|    450|        fn probe_hash(&self, key: &K, probe_index: N, table_size: N) -> N {
   32|       |        fn probe_hash(&self, key: &K, probe_index: N, table_size: N) -> N;
   33|    966|        fn probe_hash(&self, key: &K, probe_index: N, table_size: N) -> N {
  195|  3.28k|                for probe_idx in 0..size {
  163|    827|            while probe_index < table_size {
  191|     22|            while probe_index < table_size {
  245|      1|    while probe_index < table.size() {
  262|    523|            while probe_index < table_size {
   85|    870|            while probe_index < table_size {
  164|    290|            while probe_positions.insert(current_pos) && probe_count < table_size {
   50|       |        /// Probes for the next slot in the sequence.
   62|    126|                probe_sequence: probe_seq,
  148|     27|            let probe_sequence = strategy.generate_probe_sequence(&key.to_string(), table_size, self.max_probes);
   21|       |        pub probe_sequence: Vec<N>,
  345|      1|        let probe_sequence = strategy.generate_probe_sequence(&test_key, table_size, 15);
   90|     10|                (key, probe_sequence)
   49|       |    impl ProbeSequenceAnalyzer {
  222|     20|            let probe_sequence_diversity = if expected_diversity > 0.0 {
   30|       |        pub probe_sequence_diversity: f64,
    5|       |pub mod ProbeSequenceExamples {
  114|    308|            Self: ProbeSequence<K> + Clone,
  160|     21|            Self: ProbeSequence<K> + Clone,
   55|     22|            Self: ProbeSequence<K> + Clone,
   25|       |        pub probe_sequence_length: N,
  156|     20|            let probe_sequence_period = RelativePrimeValidator::probe_sequence_period(h2_value, table_size);
   27|       |        pub probe_sequence_period: N,
  360|      2|        let probe_sequences = analyzer.compare_probing_strategies(test_key, table_size);
   36|       |        pub probe_sequences: Vec<ProbeSequenceVisualization>,
   42|     11|        let probe_strategy = LinearProbingStrategy::new(StringPositionHashFunction);
   53|      2|        let probe_strategy = LinearProbingStrategy::new(hash_fn);
   57|     10|        let probe_strategy = QuadraticProbingStrategy::standard(StringPositionHashFunction);
   57|     11|        let probe_strategy = DoubleHashingStrategy::new(hash1, hash2);
   68|      2|        let probe_strategy = QuadraticProbingStrategy::standard(hash_fn);
   70|      4|        let probe_strategy = DoubleHashingStrategy::new(hash1, hash2);
  116|     56|        fn probe(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key, attempt: N) -> N {
   52|       |        fn probe(table: &HashTable<Key, Value, Entry, Metrics>, key: &Key, attempt: N) -> N;
   79|    103|        fn probe(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key, attempt: N) -> N {
   80|     13|        fn probe(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key, attempt: N) -> N {
   27|       |        pub probe_variance: f64,
  236|      0|            for probe_viz in &self.probe_sequences {
    2|       |//! Linear Probing Flat Hash Table - Sequential Ephemeral (Chapter 47).
    2|       |//! Quadratic Probing Flat Hash Table - Sequential Ephemeral (Chapter 47).
   93|      3|                "Quadratic probing parameters are valid".to_string()
   10|       |        /// Problem 21.1 (Points in 2D) - Imperative approach using nested loops
   10|       |        /// Problem 21.3 (Points in 3D) using ArraySeqPer — imperative triple loop
   10|       |        /// Problem 21.4 (Cartesian Product) - Imperative approach using explicit loops
   15|       |    /// Problem 21.1 (Points in 2D) - Imperative approach using nested loops.
   15|       |    /// Problem 21.3 (Points in 3D) using ArraySeqPer — imperative triple loop.
    4|       |pub mod Problem21_1 {
    4|       |pub mod Problem21_3 {
    4|       |pub mod Problem21_4 {
   25|       |    /// Problem 21.4 (Cartesian Product) - Imperative approach using explicit loops.
   44|       |    /// Problem 21.4 (Cartesian Product) - Functional approach using tabulate + flatten.
  102|     60|                let prob_sum: Probability = (0..l)
  111|     71|                let prob_sum: Probability = {
   65|     50|                let prob_sum: Probability = (0..l)
   77|    151|                let prob_sum: Probability = (0..l)
  100|       |            // Process each element directly without intermediate collection
   47|       |            // Process diagonals from top-left to bottom-right
   47|       |            // Process diagonals from top-left to bottom-right
   49|       |            // Process diagonals with parallel computation within each diagonal
   49|       |            // Process diagonals with parallel computation within each diagonal
   96|       |            // Process diagonal elements in parallel
   96|       |            // Process diagonal elements in parallel
   97|       |        // Process edges in parallel
   60|     97|                if !processed.mem(neighbor) {
   48|    143|            if processed.mem(vertex) {
   22|       |        /// Product of all elements via reduce.
   23|       |        /// Product of all elements via parallel reduce.
   26|       |        fn product(a: &ArraySeqStPerS<N>) -> N;
   51|      4|        fn product(a: &ArraySeqStPerS<N>) -> N { ArraySeqStPerS::reduce(a, &|x, y| x * y, 1) }
   27|       |        fn product_parallel(a: &ArraySeqMtPerS<N>) -> N;
   56|      1|        fn product_parallel(a: &ArraySeqMtPerS<N>) -> N {
   84|       |    // Provide an order-independent Hash so sets of sets can be placed in a HashSet.
   29|       |    /// Provides theoretical guarantees for collision analysis
   32|       |        /// Provides a shared view of the underlying elements
    4|       |//! Note: Provides a probability wrapper that implements Eq/Ord for f64 values
    5|       |//! - Provides `ArraySeqMtEphSliceS<T>` backed by `Arc<Mutex<Box<[T]>>>` with range metadata.
   83|       |        /// Provides a shared view of the underlying elements.
   94|     50|        let p_seq = base_seq.inject(&updates_seq);
  129|     13|            let p_to = *potentials.nth(*to);
  145|     15|            let p_to = *potentials.nth(*to);
  114|     15|            let p_u = *potentials.nth(u);
  114|     28|            let p_u = *potentials.nth(u);
  194|     15|            let p_u = *potentials.nth(u);
  197|     28|            let p_u = *potentials.nth(u);
   66|     15|            let p_u = *potentials.nth(u);
   76|     15|            let p_u = *potentials.nth(u);
   25|       |        /// Push element onto stack
   67|       |        /// Push value onto stack using lock-free CAS.
    9|       |//! - `push`: Work O(1) amortized, Span O(1) amortized
   49|       |        /// Pushes an item onto the stack
  437|      7|    fn push_inorder<T: Copy + Debug + Clone>(link: &Link<T>, out: &mut Vec<T>) {
  195|    191|        fn push_left(&mut self, link: &'a Link<T>) {
  260|      6|        fn push_left(&mut self, mut cur: Option<&'a Node<T>>) {
  300|     13|        fn push_left(&mut self, link: &'a Link<T>) {
   27|       |        fn push(&mut self, item: T);
   28|       |        fn push(&self, value: T);
   71|  7.20k|        fn push(&self, value: T) {
  121|     35|                        let p_v = *potentials.nth(v);
  121|     57|                        let p_v = *potentials.nth(v);
  197|     15|                let p_v = *potentials.nth(*v);
  200|     24|                let p_v = *potentials.nth(*v);
   74|     29|                        let p_v = *potentials.nth(v);
   83|     35|                        let p_v = *potentials.nth(v);
    5|       |pub mod QuadProbFlatHashTable {
   17|       |        for QuadProbFlatHashTableStEph
   77|       |        for QuadProbFlatHashTableStEph
   11|       |    /// Quadratic Probing Flat Hash Table implementation.
  296|       |        /// Quadratic probing: h_i(k) = (h(k) + c1*i + c2*i^2) mod m
    3|       |//! Uses quadratic probing for open addressing collision resolution.
  415|      2|            example_name: "Quadratic Probing with Prime Table Size".to_string(),
  429|      2|            example_name: "Quadratic Probing with Composite Table Size".to_string(),
   82|       |            // Quadratic probing: (hash(key) + i²) mod size
  233|     14|            let quadratic_analysis = self.analyze_quadratic_probing(&quadratic_strategy, &quadratic_table);
  258|     14|                quadratic_probing: quadratic_analysis,
  300|    450|            let quadratic_offset = self.c1 * probe_index + self.c2 * probe_index * probe_index;
   35|    966|            let quadratic_offset = self.c1 * probe_index + self.c2 * probe_index * probe_index;
    4|       |pub mod QuadraticProbing {
   53|       |        pub quadratic_probing: ComprehensiveClusteringAnalysis,
  226|     14|            let quadratic_strategy: AdvancedQuadraticProbingStrategy<String, DefaultHashFunction> =
  228|     14|            let quadratic_table: FlatHashTable<
   26|       |//! // Query operations
   26|       |//! // Query operations
  145|     14|        fn query_and(docs_a: &DocumentSet, docs_b: &DocumentSet) -> DocumentSet { docs_a.intersection(docs_b) }
   40|       |        fn query_and(docs_a: &DocumentSet, docs_b: &DocumentSet) -> DocumentSet;
  153|      8|        fn query_and_not(docs_a: &DocumentSet, docs_b: &DocumentSet) -> DocumentSet { docs_a.difference(docs_b) }
   48|       |        fn query_and_not(docs_a: &DocumentSet, docs_b: &DocumentSet) -> DocumentSet;
  287|       |    impl<'a> QueryBuilder<'a> {
  149|     12|        fn query_or(docs_a: &DocumentSet, docs_b: &DocumentSet) -> DocumentSet { docs_a.union(docs_b) }
   44|       |        fn query_or(docs_a: &DocumentSet, docs_b: &DocumentSet) -> DocumentSet;
  135|    111|                    scope.spawn(|| quick_sort(left));
  176|    208|                    scope.spawn(|| quick_sort(left));
   84|    346|                    scope.spawn(|| quick_sort(left));
   24|       |        fn quick_sort_mt_first(&mut self);
   54|      8|        fn quick_sort_mt_first(&mut self) {
   24|       |        fn quick_sort_mt_first(&self);
   56|      7|        fn quick_sort_mt_first(&self) {
   27|       |        fn quick_sort_mt_median3(&mut self);
   93|      6|        fn quick_sort_mt_median3(&mut self) {
   27|       |        fn quick_sort_mt_median3(&self);
   94|      7|        fn quick_sort_mt_median3(&self) {
  144|      5|        fn quick_sort_mt_random(&mut self) {
   30|       |        fn quick_sort_mt_random(&mut self);
  145|      5|        fn quick_sort_mt_random(&self) {
   30|       |        fn quick_sort_mt_random(&self);
   22|       |        fn quick_sort_st_first(&mut self);
   52|      4|        fn quick_sort_st_first(&mut self) {
   25|       |        fn quick_sort_st_median3(&mut self);
   87|      4|        fn quick_sort_st_median3(&mut self) {
  135|      2|        fn quick_sort_st_random(&mut self) {
   28|       |        fn quick_sort_st_random(&mut self);
  149|    421|            fn quick_sort<T: StT + Ord + Send>(data: &mut [T]) {
   59|    699|            fn quick_sort<T: StT + Ord + Send>(data: &mut [T]) {
   98|    227|            fn quick_sort<T: StT + Ord + Send>(data: &mut [T]) {
   82|      7|        println!("rank(A, 'quinn') = {}", quinn_rank);
   81|      7|        let quinn_rank = set_a.rank(&"quinn".to_string());
   76|      6|            for quotient_edge in quotient_tree.iter() {
  104|      8|        let quotient_edges = build_quotient_edges_parallel(graph, &partition_map);
   64|      5|        let quotient_edges = build_quotient_edges(graph, &partition_map);
   66|     15|        let quotient_edges = build_quotient_edges_parallel(graph, &partition_map);
   98|     22|        let quotient_edges = route_edges_parallel(&edges_seq, part_map_arc, 0, n_edges);
   99|      6|        let quotient_edges = build_quotient_edges(graph, &partition_map);
  100|      6|        let quotient_graph = <UnDirGraphStEph<V> as UnDirGraphStEphTrait<V>>::FromSets(centers, quotient_edges);
  105|      8|        let quotient_graph = <UnDirGraphMtEph<V> as UnDirGraphMtEphTrait<V>>::FromSets(centers, quotient_edges);
   64|     14|        let quotient_graph = build_quotient_graph(graph, &centers, &partition_map);
   65|      5|        let quotient_graph = <UnDirGraphStEph<V> as UnDirGraphStEphTrait<V>>::FromSets(centers, quotient_edges);
   67|     15|        let quotient_graph = <UnDirGraphMtEph<V> as UnDirGraphMtEphTrait<V>>::FromSets(centers, quotient_edges);
   69|     22|        let quotient_graph = build_quotient_graph_parallel(graph, &centers, &partition_map);
  182|     38|                    let r = right_arc.clone();
   20|       |        reduced_value: R, // Reduced value of subtree rooted at this node
  240|      1|) -> R
  266|  50.0k|            let r = ArraySeqStPerS::reduce(&right, f, id);
  267|  50.0k|            f(&l, &r)
  328|     73|            f(&l, &r)
  353|  1.99k|            f(&l, &r)
  366|     25|            let r = <LinkedListStPerS<T> as LinkedListStPerTrait<T>>::reduce(&right, f, id);
  367|     25|            f(&l, &r)
  407|     20|            let r = <LinkedListStEphS<T> as LinkedListStEphTrait<T>>::reduce(&right, f, id);
  408|     20|            f(&l, &r)
   67|     14|        let r = star_contract(&quotient_graph, base, expand);
   72|     22|        let r = star_contract_mt(&quotient_graph, seed + 1, base, expand);
  105|    724|                        right: ra,
  135|    170|                                right: ra,
   78|      7|        println!("rank(A, 'rachel') = {}", rachel_rank);
   77|      7|        let rachel_rank = set_a.rank(&"rachel".to_string());
   10|       |    use rand::*;
   10|       |    use rand::*;
   10|       |    use rand::*;
   10|       |    use rand::*;
   17|       |    use rand::*;
   17|       |    use rand::*;
   19|       |    use rand::*;
    8|       |    use rand::*;
    8|       |    use rand::*;
    8|       |    use rand::*;
    8|       |    use rand::*;
   10|       |    use rand::Rng;
   10|       |    use rand::Rng;
   10|       |    use rand::Rng;
   12|       |    use rand::Rng;
   46|       |        use rand::{Rng, SeedableRng};
   76|       |        use rand::Rng;
   77|       |        use rand::{Rng, SeedableRng};
   16|       |    use rand::rngs::StdRng;
   18|       |    use rand::rngs::StdRng;
   18|       |    use rand::rngs::StdRng;
   45|       |        use rand::rngs::StdRng;
   76|       |        use rand::rngs::StdRng;
  192|      0|        let range = int_set.get_range(&3, &9);
  229|     59|            let range_array = ArraySeqStPerS::filter(&array_seq, &|elem| elem >= k1 && elem <= k2);
  237|     10|            let range_array = ArraySeqStPerS::filter(&array_seq, &|elem| elem >= k1 && elem <= k2);
  231|      2|            let range_elements = self.elements[start_pos..end_pos].to_vec();
  233|      2|                elements: range_elements,
   34|       |        range: Range<N>,
  250|    170|        fn range_reduce_link(link: &Link<K, V, R>, low: &K, high: &K) -> R {
  105|       |        fn range_reduce(&self, low: &K, high: &K) -> R;
  330|     29|        fn range_reduce(&self, low: &K, high: &K) -> R { Self::range_reduce_link(&self.root, low, high) }
  100|      6|        fn range(&self) -> Set<Y> { self.rel.range() }
  213|      2|        fn range(&self) -> Vec<T> {
   40|       |        fn range(&self) -> Set<Y>
   43|       |        fn range(&self) -> Set<Y>;
   78|       |        fn range(&self) -> Vec<T>;
   90|     10|        fn range(&self) -> Set<Y>
  232|      9|            let range_seq = AVLTreeSeqStPerS::from_vec(range_array.into_iter().collect());
  240|      2|            let range_seq = AVLTreeSeqStPerS::from_vec(range_array.into_iter().collect());
  285|      9|            let range_seq = AVLTreeSeqStPerS::from_vec(range_entries);
  296|     10|            let range_seq = AVLTreeSeqStPerS::from_vec(range_entries);
  326|     25|            let range_seq = AVLTreeSeqStPerS::from_vec(range_entries);
   65|      7|        let range_set = set_a.get_range(&"burt".to_string(), &"mike".to_string());
  101|     25|        let range_size = end - start;
  101|     46|        let range_size = end - start;
  104|     25|        if range_size == 0 {
  104|     46|        if range_size == 0 {
  109|     25|        if range_size == 1 {
  109|     46|        if range_size == 1 {
  319|      7|            let range_table = self.get_key_range(k1, k2);
  332|     19|            let range_table = self.get_key_range(k1, k2);
  339|      1|            let range_table = self.get_key_range(k1, k2);
  354|      6|            let range_table = self.get_key_range(k1, k2);
  343|      0|                return range_table.identity.clone();
  346|      0|                return range_table.reduce_val();
  342|      1|            if range_table.size() == 0 {
  345|      1|            if range_table.size() == 1 {
  205|    174|                    if rank <= left_size {
  206|     73|                        Self::select_link(&node.left, rank)
  210|     59|                        Self::select_link(&node.right, rank - left_size - 1)
  221|     17|                    if rank <= left_size {
  240|       |            // Rank strategies by performance
  274|     44|            if rank == 0 || rank > self.size() {
  277|     42|                Self::select_link(&self.root, rank)
  282|      4|            if rank == 0 {
  376|      3|                        writeln!(f, "{}{}(rank:{})", indent, key, rank)?;
   76|       |        // rank(A, 'rachel') → 4
   80|       |        // rank(A, 'quinn') → 4 (elements less than 'quinn')
  369|      2|            "Performance ranking (best to worst): Double Hashing > Quadratic Probing > Linear Probing. \
  283|      6|        fn rank_key(&self, k: &K) -> N { self.base_table.rank_key(k) }
  290|      8|        fn rank_key(&self, k: &K) -> N {
  296|      6|        fn rank_key(&self, k: &K) -> N { self.base_table.rank_key(k) }
  301|     11|        fn rank_key(&self, k: &K) -> N {
  318|      1|        fn rank_key(&self, k: &K) -> N { self.base_table.rank_key(k) }
  331|     11|        fn rank_key(&self, k: &K) -> N {
   61|       |        fn rank_key(&self, k: &K) -> N;
   64|       |        fn rank_key(&self, k: &K) -> N;
   69|       |        fn rank_key(&self, k: &K) -> N;
   73|       |        fn rank_key(&self, k: &K) -> N;
   77|       |        fn rank_key(&self, k: &K) -> N;
   79|       |        fn rank_key(&self, k: &K) -> N;
  184|    179|        fn rank_link(link: &Link<T>, key: &T) -> N {
  237|     20|        fn rank(&self, k: &T) -> N {
  238|      6|        fn rank(&self, k: &T) -> N {
  245|      6|        fn rank(&self, k: &T) -> N {
  271|     44|        fn rank(&self, key: &T) -> N { Self::rank_link(&self.root, key) }
   62|       |        fn rank(&self, key: &T) -> N;
   64|       |        fn rank(&self, k: &T) -> N;
   65|       |        fn rank(&self, k: &T) -> N;
   65|       |        fn rank(&self, k: &T) -> N;
   66|  4.42k|        fn rank(&self) -> N {
  118|    143|            let rank_u = *self.rank.get(&root_u).unwrap_or(&0);
  121|    143|            if rank_u < rank_v {
  200|      0|            let rank_u = *self.rank.get(&root_u).unwrap_or(&0);
  203|      0|            if rank_u < rank_v {
  119|    143|            let rank_v = *self.rank.get(&root_v).unwrap_or(&0);
  201|      0|            let rank_v = *self.rank.get(&root_v).unwrap_or(&0);
   38|       |        /// Raw pop operation returning node pointer (private helper).
   42|  7.21k|        fn raw_pop(&self) -> Option<*mut Node<T>> {
  111|    724|                        right: rb,
  123|    554|                                right: rb,
  149|     67|                root: Rc::new(RefCell::new(None)),
   74|     78|                        root: Rc::new(RefCell::new(Some(Box::new(NodeInner { key, size, left, right })))),
   29|       |        root: Rc<RefCell<Option<Box<NodeInner<T>>>>>,
   62|       |        /// Reachability: find all vertices reachable from source.
   52|       |        fn reachable<G>(graph: &G, source: V) -> AVLTreeSetStEph<V>
   56|       |        fn reachable<G>(graph: &G, source: V) -> AVLTreeSetMtPer<V>
   64|       |        fn reachable<G>(graph: &G, source: V) -> AVLTreeSetStPer<V>
  171|       |        /// Reason: `Vec<T>` owns a heap buffer; `into_boxed_slice()` reuses it when
  109|       |        /// Reassembles a primitive tree sequence from an exposed tree.
   44|       |        /// Reassembles a primitive tree sequence from an exposed tree
  103|    907|        fn rebalance_if_needed(link: &mut Link<T>, total_size: N) {
  145|    231|        fn rebalance_if_needed(link: &mut Link<T>, total_size: N) {
  109|  11.0k|        fn rebalance(link: &mut Link<T>) {
  109|    807|        fn rebalance(link: &mut Link<T>) {
  254|  97.2M|    fn rebalance<T: StT>(mut n: Box<AVLTreeNode<T>>) -> Box<AVLTreeNode<T>> {
  364|     20|    fn rebalance<T: Copy + Debug>(mut n: Box<AVLTreeNode<T>>) -> Box<AVLTreeNode<T>> {
   52|     37|    fn rebalance<T: StT>(n: Rc<Node<T>>) -> Rc<Node<T>> {
   52|      6|    fn rebalance<T: StTInMtT>(n: Arc<Node<T>>) -> Arc<Node<T>> {
  168|       |                // Rebuild without the element at idx, using ArraySeq preallocation
  205|    280|        fn rebuild_from_vec(values: Vec<T>) -> BSTRBMtEph<T> {
  205|      6|        fn rebuild_from_vec(values: Vec<T>) -> BSTAVLMtEph<T> {
  205|      6|        fn rebuild_from_vec(values: Vec<T>) -> BSTBBAlphaMtEph<T> {
  205|      6|        fn rebuild_from_vec(values: Vec<T>) -> BSTSplayMtEph<T> {
  205|      6|        fn rebuild_from_vec(values: Vec<T>) -> BSTTreapMtEph<T> {
  205|      7|        fn rebuild_from_vec(values: Vec<T>) -> BSTPlainMtEph<T> {
  114|  3.95k|                        let rebuilt = ParamBST::join_mid(Exposed::Node(lr, root_key, right));
  119|  1.67k|                        let rebuilt = ParamBST::join_mid(Exposed::Node(left, root_key, rl));
  127|     41|                        let rebuilt = ParamTreap::join_with_priority(lr, root_key, priority, right);
  132|    484|                        let rebuilt = ParamTreap::join_with_priority(left, root_key, priority, rl);
  163|     25|            let rebuilt = ParamBST::join_m(left, key, right);
  315|  1.62k|            let rebuilt = ParamBST::join_m(left, key, right);
  369|    206|            let rebuilt = ParamTreap::join_with_priority(left, key, priority, right);
   86|     17|                        let rebuilt = ParamBST::join_mid(Exposed::Node(lr, root_key, right));
   91|     28|                        let rebuilt = ParamBST::join_mid(Exposed::Node(left, root_key, rl));
  132|       |            // Recalculate reduction after deletion
  138|       |            // Recalculate reduction after deletion
  329|      8|        fn recalculate_reduction(&self) -> V {
  364|     20|        fn recalculate_reduction(&self, base: &OrderedTableStPer<K, V>) -> V {
  368|     10|        fn recalculate_reduction(&self) -> V {
  251|       |        /// Recommend optimal table size for given capacity
  258|       |            // Recommend next prime that's at least 2x capacity for good load factor
  334|     51|            let recommended_action = match severity {
   35|       |        pub recommended_action: String,
  101|       |                // Reconstruct predecessors
  110|       |                // Reconstruct predecessors
  117|       |    /// Reconstruct predecessor tree from final distances
  126|       |    /// Reconstruct predecessor tree from final distances
  119|     19|    fn reconstruct_predecessors(
  128|     19|    fn reconstruct_predecessors(
   74|     16|        let rec_stack = rec_stack.insert(vertex);
   91|     12|        let rec_stack = rec_stack.delete(&vertex);
   93|     12|        Some((visited, rec_stack, result))
   66|     19|        if rec_stack.find(&vertex) {
   58|     19|        if *rec_stack.nth(vertex) {
  122|  22.7k|        fn rec<T: StTInMtT>(a: &[T]) -> Link<T> {
  123|  2.51M|        fn rec<T: StT>(a: &[T]) -> Link<T> {
  172|       |            // Recur: UNCONDITIONALLY PARALLEL using ParaPair!
   91|       |            // Recur: sequential recursive calls
  207|       |        // Recurse
  266|       |        // Recurse
  109|       |        /// Recursive helper with parallel branch exploration
  111|       |        /// Recursive helper with parallel branch exploration
  128|       |    /// Recursive helper for parallel edge selection
  133|       |        // Recursive case: split in half and use ParaPair! for unconditional parallelism
  133|       |        // Recursive case: split in half and use ParaPair! for unconditional parallelism
  137|       |        // Recursive case: divide and conquer
  138|       |        // Recursive case: divide and conquer
  155|       |        // Recursive case: divide and conquer
  166|       |        // Recursive case: divide and conquer
   55|       |        /// Recursive helper with memoization
   57|       |        /// Recursive helper with concurrent memoization
   57|       |        /// Recursive helper with concurrent memoization
   58|       |        /// Recursive helper with memoization
   59|       |        // Recursive case:
   64|       |        // Recursive case:
  102|       |        // Recursively compute components in quotient graph
  107|       |        // Recursively compute components in quotient graph
   67|       |        // Recursively count components in quotient graph
   69|       |        // Recursively count components in quotient graph
   92|       |                // Recursively find root and compress path
  378|     11|                let red = <LinkedListStPerS<T> as LinkedListStPerTrait<T>>::reduce(&prefix, f, id.clone());
  419|     10|                let red = <LinkedListStEphS<T> as LinkedListStEphTrait<T>>::reduce(&prefix, f, id.clone());
    2|       |//! Ephemeral Red-Black balanced binary search tree with `find` support and public helpers.
    2|       |//! Ephemeral Red-Black balanced binary search tree with interior locking for multi-threaded access.
   10|       |        /// Reduce a sequence using contraction: contract→solve→expand.
   14|       |        /// Reduce a sequence using parallel contraction: contract→solve→expand.
  162|      2|When to Reduce:
  167|      2|How to Reduce:
  273|       |            // Reduce using meld operations (can be done in parallel)
    2|       |//! Parallel reduce using contraction technique (Chapter 27, Algorithm 27.2).
    2|       |//! Sequential reduce using contraction technique (Chapter 27, Algorithm 27.2).
   67|       |            // Reduce with union operation directly from seq
   83|       |            // Reduce with union operation
   85|       |            // Reduce with union operation
   13|       |        fn reduce_contract<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, id: T) -> T;
   17|     30|        fn reduce_contract<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, id: T) -> T {
    4|       |pub mod ReduceContractMtEph {
   17|       |        fn reduce_contract_parallel<F: Fn(&T, &T) -> T + Send + Sync + 'static>(
   25|     30|        fn reduce_contract_parallel<F: Fn(&T, &T) -> T + Send + Sync + 'static>(
    4|       |pub mod ReduceContractStEph {
  117|  2.23k|        fn reduced_value_link(link: &Link<K, V, R>) -> R {
  104|       |        fn reduced_value(&self) -> R;
  328|     19|        fn reduced_value(&self) -> R { Self::reduced_value_link(&self.root) }
  132|       |        fn reduce<F: Fn(&T, &T) -> T>(a: &ArraySeqStPerS<T>, f: &F, id: T) -> T;
  157|       |        fn reduce<F: Fn(&T, &T) -> T + Send + Sync + Clone + 'static>(a: &ArraySeqMtEphS<T>, f: F, id: T) -> T
  169|     16|        fn reduce<F: Fn(&T, &T) -> T>(a: &ArraySeqStPerS<T>, f: &F, id: T) -> T {
  170|       |        fn reduce<F: Fn(&T, &T) -> T + Send + Sync + Clone + 'static>(a: &ArraySeqMtPerS<T>, f: F, id: T) -> T
  171|       |        fn reduce<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, id: T) -> T;
  184|     18|        fn reduce<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, id: T) -> T {
  219|    215|        fn reduce<F: Fn(&T, &T) -> T + Send + Sync + Clone + 'static>(a: &ArraySeqMtPerS<T>, f: F, id: T) -> T {
  234|     14|        fn reduce<F: Fn(&T, &T) -> T + Send + Sync + Clone + 'static>(a: &ArraySeqMtEphS<T>, f: F, id: T) -> T {
  245|       |        fn reduce<F: Fn(&T, &T) -> T>(a: &Self, f: &F, id: T) -> T;
  255|   100k|        fn reduce<F: Fn(&T, &T) -> T>(a: &ArraySeqStPerS<T>, f: &F, id: T) -> T {
  260|      1|        fn reduce<F: FnMut(T, T) -> T>(&self, op: F, base: T) -> T { BSTSetAVLMtEph::reduce(self, op, base) }
  260|      1|        fn reduce<F: FnMut(T, T) -> T>(&self, op: F, base: T) -> T { BSTSetBBAlphaMtEph::reduce(self, op, base) }
  260|      1|        fn reduce<F: FnMut(T, T) -> T>(&self, op: F, base: T) -> T { BSTSetRBMtEph::reduce(self, op, base) }
  260|      1|        fn reduce<F: FnMut(T, T) -> T>(&self, op: F, base: T) -> T { BSTSetSplayMtEph::reduce(self, op, base) }
  260|      1|        fn reduce<F: FnMut(T, T) -> T>(&self, op: F, base: T) -> T { BSTSetTreapMtEph::reduce(self, op, base) }
  284|     14|        fn reduce<F: Fn(&T, &T) -> T + Send + Sync + Clone + 'static>(a: &Self, f: F, id: T) -> T {
  284|      7|        fn reduce<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, id: T) -> T {
  305|    156|        fn reduce<F: Fn(&T, &T) -> T + Send + Sync + Clone + 'static>(a: &ArraySeqMtPerS<T>, f: F, id: T) -> T
  307|      1|        fn reduce<F: Fn(&T, &T) -> T>(a: &ArraySeqS<T>, f: &F, id: T) -> T {
  330|  3.99k|        fn reduce<F: Fn(&T, &T) -> T + Send + Sync + Clone + 'static>(a: &ArraySeqMtEphS<T>, f: F, id: T) -> T
  354|     69|        fn reduce<F: Fn(&T, &T) -> T>(a: &LinkedListStPerS<T>, f: &F, id: T) -> T {
  372|      6|        fn reduce<F: Fn(T, T) -> T + Send + Sync + 'static>(&self, op: F, base: T) -> T {
  395|     58|        fn reduce<F: Fn(&T, &T) -> T>(a: &Self, f: &F, id: T) -> T {
   50|       |        fn reduce<F: Fn(&T, &T) -> T + Send + Sync + Clone + 'static>(a: &ArraySeqMtEphS<T>, f: F, id: T) -> T;
   52|       |        fn reduce<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, id: T) -> T;
   52|       |        fn reduce<F: Fn(&T, &T) -> T>(a: &ArraySeqStPerS<T>, f: &F, id: T) -> T;
   54|       |        fn reduce<F: Fn(&T, &T) -> T + Send + Sync + Clone + 'static>(a: &ArraySeqMtPerS<T>, f: F, id: T) -> T
   55|       |        fn reduce<F: FnMut(T, T) -> T>(&self, op: F, base: T) -> T;
   55|       |        fn reduce<F: FnMut(T, T) -> T>(&self, op: F, base: T) -> T;
   55|       |        fn reduce<F: FnMut(T, T) -> T>(&self, op: F, base: T) -> T;
   55|       |        fn reduce<F: FnMut(T, T) -> T>(&self, op: F, base: T) -> T;
   55|       |        fn reduce<F: FnMut(T, T) -> T>(&self, op: F, base: T) -> T;
   55|       |        fn reduce<F: FnMut(T, T) -> T>(&self, op: F, base: T) -> T;
   68|       |        fn reduce<F: Fn(&T, &T) -> T + Send + Sync + Clone + 'static>(a: &Self, f: F, id: T) -> T;
   75|       |        fn reduce<F: Fn(T, T) -> T + Send + Sync + 'static>(&self, op: F, base: T) -> T;
   79|       |        fn reduce<F: Fn(&T, &T) -> T>(a: &LinkedListStPerS<T>, f: &F, id: T) -> T;
   98|       |        fn reduce<F: Fn(&T, &T) -> T>(a: &ArraySeqS<T>, f: &F, id: T) -> T
  331|       |        fn reduce<F>(&self, op: F, base: T) -> T
  338|      1|        fn reduce<F>(&self, op: F, base: T) -> T
  424|      2|        fn reduce<F>(&self, op: F, base: T) -> T
  243|    548|        fn reduce_inner<F: Fn(T, T) -> T + Send + Sync + 'static>(tree: &Self, op: &Arc<F>, identity: T) -> T {
  240|     10|        fn reduce_inner<F>(tree: &Self, op: &Arc<F>, identity: T) -> T
  264|      6|        fn reduce_parallel<F: Fn(T, T) -> T + Send + Sync + 'static>(tree: &Self, op: F, base: T) -> T {
  264|      2|        fn reduce_parallel<F>(tree: &Self, op: F, base: T) -> T
  163|      6|        fn reduce<R, F: Fn(R, &K, &V) -> R>(&self, init: R, f: F) -> R {
  179|      6|        fn reduce<R, F>(&self, init: R, f: F) -> R
  180|      3|        fn reduce<R, G: Fn(R, &K, &V) -> R>(&self, init: R, f: G) -> R { self.base_table.reduce(init, f) }
  221|      3|        fn reduce<R: StTInMtT + 'static, G: Fn(R, &K, &V) -> R + Send + Sync + 'static>(&self, init: R, f: G) -> R {
  354|      1|                let reducer = range_table.reducer.clone();
   46|       |        fn reduce<R, G: Fn(R, &K, &V) -> R>(&self, init: R, f: G) -> R;
   47|       |        fn reduce<R, F: Fn(R, &K, &V) -> R>(&self, init: R, f: F) -> R;
   56|       |        fn reduce<R: StTInMtT + 'static, G: Fn(R, &K, &V) -> R + Send + Sync + 'static>(&self, init: R, f: G) -> R;
   60|       |        fn reduce<R: StTInMtT + 'static, F: Fn(R, &K, &V) -> R + Send + Sync + 'static>(&self, init: R, f: F) -> R;
    4|       |//! Note: reduce_range_parallel() uses unconditional parallelism with ParaPair! for range reductions.
  338|      1|        fn reduce_range_parallel(&self, k1: &K, k2: &K) -> V {
   86|       |        fn reduce_range_parallel(&self, k1: &K, k2: &K) -> V;
  318|      7|        fn reduce_range(&self, k1: &K, k2: &K) -> V {
  331|     19|        fn reduce_range(&self, k1: &K, k2: &K) -> V {
  353|      6|        fn reduce_range(&self, k1: &K, k2: &K) -> V {
   74|       |        fn reduce_range(&self, k1: &K, k2: &K) -> V;
   77|       |        fn reduce_range(&self, k1: &K, k2: &K) -> V;
   82|       |        fn reduce_range(&self, k1: &K, k2: &K) -> V;
   72|       |    // Reduces where clause complexity by bundling common requirements
  314|     45|        fn reduce_val(&self) -> V { self.cached_reduction.clone() }
  327|     68|        fn reduce_val(&self) -> V { self.cached_reduction.clone() }
  349|     37|        fn reduce_val(&self) -> V { self.cached_reduction.clone() }
   70|       |        fn reduce_val(&self) -> V;
   73|       |        fn reduce_val(&self) -> V;
   78|       |        fn reduce_val(&self) -> V;
  337|      0|                    "Consider reducing load factor or switching to quadratic probing".to_string()
  186|       |            // Rehash all elements
  191|       |            // Rehash all elements
  246|       |            // Rehash all live entries
  278|      1|   - Rehash all Live entries (skip Empty/Dead)
   17|       |        rel: Relation<A, B>,
  117|       |    macro_rules! RelationLit {
    4|       |pub mod RelationStEph {
   78|      0|                rel: <Relation<X, Y> as RelationStEphTrait<X, Y>>::empty(),
   85|      7|                rel: <Relation<X, Y> as RelationStEphTrait<X, Y>>::FromSet(pairs),
   92|      5|                rel: <Relation<X, Y> as RelationStEphTrait<X, Y>>::FromSet(pairs),
   33|       |    /// Relative Prime Validator for Double Hashing
  153|     20|            let (relative_prime_validation, _) = RelativePrimeValidator::validate_double_hashing(h2_value, table_size);
   29|       |        pub relative_prime_validation: B,
   38|       |    impl RelativePrimeValidator {
  101|       |                // Relax all out-neighbors: add PQEntry(d + w, u) to PQ
  101|       |                // Relax all out-neighbors: add PQEntry(d + w, u) to PQ
   48|       |        /// Release lock by advancing turn counter.
    5|       |//! enabling reliable hashing and ordering of floating-point values including NaN and Infinity.
    5|       |//! enabling reliable hashing and ordering of floating-point values including NaN and Infinity.
  136|       |        // Remaining vertices = all vertices minus contracted tails
  267|     20|        let remaining_vec: Vec<V> = remaining_vertices.iter().cloned().collect();
  178|     25|        let (remaining_vertices, partition) = bridge_star_partition(vertices, &bridges, rng);
  245|     20|        let (remaining_vertices, partition) = bridge_star_partition_mt(vertices_vec, bridges, rng);
  102|       |        /// Remove minimum element (first element in sorted sequence)
  106|       |                // Remove edge if present
  106|       |                    // Remove selected vertex from frontier
  107|       |            // Remove v from all neighbor sets
  109|       |            // Remove v from all neighbor sets
  114|       |                // Remove selected vertex from frontier
  115|       |        /// Remove first element (minimum) from sorted list
  120|       |                // Remove already visited vertices
  189|       |        /// Remove and return maximum element
  222|       |        /// Remove and return maximum element
  237|       |        /// Remove a specific element (not necessarily minimum)
  241|       |        /// Remove root and meld left and right subtrees
   82|       |            // Remove v from all adjacency lists
  127|       |    /// Removes duplicate vertex visits from Euler tour using triangle inequality.
   33|       |        /// Removes and returns minimum element with new queue
   33|       |        /// Removes first element (minimum) from sorted list
   33|       |        /// Removes minimum element (leftmost) from balanced tree
   33|       |        /// Removes root (minimum) and bubbles down to maintain heap property
   45|       |        /// Removes root and melds left and right subtrees
  418|      9|    fn repeat_vec<T: StT + Send + Sync>(length: N, init: T) -> Vec<T> {
  215|       |        /// Replace root with last element and bubble down
   74|     19|        for representative in vertex_to_block.values() {
   86|     24|        for representative in vertex_to_block.values() {
  103|      6|        let (representatives, component_map_quotient) = connected_components(&quotient_graph);
  108|      8|        let (representatives, component_map_quotient) = connected_components_mt(&quotient_graph, seed + 1);
   11|       |    /// Represents the three states a slot can be in.
   21|       |    /// Required by Definition 47.1 for hash table operations
  195|       |        // Re-route edges to new endpoints, removing self-edges
  272|    122|    fn reroute_edges_mt<V: StT + Hash + Ord + Send + Sync + 'static>(
  195|      1|Exercise 47.3: Resize Operation Implementation
  283|      1|   - resize when threshold exceeded
  185|      3|        fn restrict(&mut self, keys: &ArraySetStEph<K>) { self.base_table.restrict(keys); }
  201|      1|        fn restrict(&mut self, keys: &ArraySetStEph<K>) {
  209|      1|        fn restrict(&mut self, keys: &ArraySetStEph<K>) {
  214|      3|        fn restrict(&mut self, keys: &ArraySetStEph<K>) { self.base_table.restrict(keys); }
  275|      4|        fn restrict(&mut self, keys: &ArraySetStEph<K>) {
   48|       |        fn restrict(&mut self, keys: &ArraySetStEph<K>);
   50|       |        fn restrict(&mut self, keys: &ArraySetStEph<K>);
   51|       |        fn restrict(&mut self, keys: &ArraySetStEph<K>);
  548|      4|        fn restrict(&mut self, keys: &ArraySetStEph<K>) {
   54|       |        fn restrict(&mut self, keys: &ArraySetStEph<K>);
   55|       |        fn restrict(&mut self, keys: &ArraySetStEph<K>);
   56|       |        fn restrict(&mut self, keys: &ArraySetStEph<K>);
  164|      2|        fn restrict(&self, keys: &ArraySetStEph<K>) -> Self {
  221|      1|        fn restrict(&self, keys: &ArraySetStEph<K>) -> Self {
  312|      3|        fn restrict(&self, keys: &ArraySetStEph<K>) -> Self {
   47|       |        fn restrict(&self, keys: &ArraySetStEph<K>) -> Self;
   49|       |        fn restrict(&self, keys: &ArraySetStEph<K>) -> Self;
   72|       |        fn restrict(&self, keys: &ArraySetStEph<K>) -> Self;
  101|     70|            let result = if i == j {
  103|    261|                    return result;
  105|      1|            let result = self.base_set.filter(f);
  107|    105|            let result = if l == 0 {
  107|     73|                    return result;
  110|     16|            let result = max_with_neginf(max_left, max_right);
  111|      1|            let result = self.base_set.intersection(&other.base_set);
  111|  5.71k|                return result;
  111|     61|            let result = if i == j {
  116|      4|        let result = graph_search(graph, source, &SelectAll);
  117|      2|            let result = self.base_set.union(&other.base_set);
  118|      0|        (visited, result)
  122|     36|            let result = match (i, j) {
  123|      1|            let result = self.base_set.difference(&other.base_set);
  124|     29|            let result = match (i, j) {
  125|      4|        let result = graph_search(graph, source, &SelectAll);
  128|       |    /// Result is a Hamiltonian cycle (visits each vertex exactly once).
  131|      3|            let result = self.base_table.delete(k);
  132|     17|                return result;
  137|      5|            let result = self.base_table.delete(k);
  139|      1|        let result = graph_search(graph, source, &SelectAll);
  149|     10|                return result;
  167|      0|            if result
  174|      1|            if result
   76|    103|                        let result1 = handle1.join().unwrap();
  186|     28|                    return result;
   86|     45|                        let result1 = handle1.join().unwrap();
  223|     17|                            if result
  225|      5|                let result = f(a.nth(0));
  231|     17|                            return (result, true);
  250|      1|            return result;
  256|  5.01k|                return result;
   77|    103|                        let result2 = handle2.join().unwrap();
   87|     45|                        let result2 = handle2.join().unwrap();
  301|  5.01k|                return result;
   38|       |    /// Result structure for all-pairs shortest paths with integer weights (persistent).
   38|       |    /// Result structure for single-source shortest paths with integer weights (persistent).
   39|       |    /// Result structure for all-pairs shortest paths with integer weights.
   39|       |    /// Result structure for single-source shortest paths with integer weights.
   40|       |    /// Result structure for all-pairs shortest paths with floating-point weights (persistent).
   41|     22|            let result = Self::reduce_contract(&b, f, id);
   41|       |    /// Result structure for all-pairs shortest paths with floating-point weights.
   41|       |    /// Result structure for single-source shortest paths with floating-point weights.
   41|       |    /// Result structure for single-source shortest paths with floating-point weights (persistent).
   51|     87|                return result;
   52|     16|                return result;
   54|    239|            let result = match (i, j) {
   55|    183|            let result = match (i, j) {
   55|     51|                    return result;
   58|     98|                return result;
   59|    183|            let result = match (i, j) {
   59|     68|                    return result;
   60|      1|            let result = action();
   61|      0|                return result;
   61|     27|        mut result: Vec<N>,
   61|     87|            let result = if l == 0 {
   63|    111|            let result = match (i, j) {
   63|     19|        mut result: Vec<N>,
   64|    131|            let result = match (i, j) {
   64|     19|            let result = match (i, j) {
   65|      0|                    return result;
   65|     49|                return result;
   66|    391|                return result;
   67|     19|            let result = match (i, j) {
   68|     61|            let result = if i == j {
   69|    114|            let result = match (i, j) {
   69|     15|            let result = match (i, j) {
   69|     15|            let result = match (i, j) {
   69|    682|            let result = match (i, j) {
   70|    551|                return result;
   72|      2|            let result = DocumentIndex::query_and(&fun_docs, &food_or_chess);
   73|    232|            let result = if l == 0 {
   75|     63|                    return result;
   77|      3|                return result;
   79|    167|            let result = match (i, j) {
   80|     12|            let result = if i == j {
   80|     20|        (visited, result)
   85|      2|            let result = DocumentIndex::query_and_not(&fun_docs, &chess_docs);
   87|     71|            return result;
   94|    141|                    return result;
   96|     16|            let result = max_with_neginf(max_left, max_right);
   97|     76|                    return result;
   98|     96|            let result = if l == 0 {
   99|      0|        mut result: Vec<N>,
  125|      1|                bits: result_bits,
  137|      1|                bits: result_bits,
  149|      1|                bits: result_bits,
  117|     64|                    if result.get_distance(u_idx) > new_dist {
  117|     80|                    if result.get_distance(u_idx) > new_dist {
  106|    122|            if result.load_factor_manager.should_grow(result.num_elements, table_size) {
   93|      2|            if result.load_factor_manager.should_grow(result.num_elements, table_size) {
  149|    272|            if result.load_factor_manager.should_grow(total_occupied, table_size) {
  188|      2|            (reps, result_map)
  247|      0|            (reps, result_map)
   50|     21|        let result_pair = ParaPair!(move || max_contig_sub_sum_aux_mt(&left_clone), move || {
   91|     16|            let result_pair = ParaPair!(move || Self::max_contig_sub_sum_divcon_mt(&left_clone), move || {
  105|      0|        output.push_str(&format!("All results match: {}\n", textbook.all_results_match()));
  106|      0|        output.push_str(&format!("All results sorted: {}\n", textbook.all_results_sorted()));
  112|     13|            let results: Vec<(usize, usize, usize)> =
  112|     16|            let results: Vec<(usize, usize, usize)> =
  113|      0|        output.push_str(&format!("All results match: {}\n", reverse.all_results_match()));
  120|      0|        output.push_str(&format!("All results match: {}\n", sorted.all_results_match()));
  127|      0|        output.push_str(&format!("All results match: {}\n", duplicates.all_results_match()));
  144|       |    /// Results of comparing all heapsort implementations
  194|      2|            let result_seq = ArraySeqStPerS::from_vec(results);
  252|      2|            let result_seq = ArraySeqMtPerS::from_vec(results);
  317|      0|                let result_seq = <ArraySeqMtEphSliceS<T> as ArraySeqMtEphSliceTrait<T>>::tabulate(&|_| id.clone(), 1);
  318|      0|                return (result_seq, a.nth_cloned(0));
  331|      1|            let result_seq = ArraySeqMtEphSliceS::<T>::from_vec(results);
  109|       |            // Return maximum of the three cases
   58|       |        /// Return number of elements.
   62|       |        /// Return a reference to the in-order `index`-th element. Panics if out of bounds.
   79|       |        /// Return subsequence [start, start+length) as a new tree.
   95|       |            // Return maximum of the three cases
  101|       |        /// Returns None if v is unreachable, otherwise returns the path as a sequence.
  106|       |        /// Returns None if v is unreachable, otherwise returns the path as a sequence.
  106|       |    /// Returns true if valid spanning tree
  108|       |    /// Returns:
  109|       |        /// Returns None if v is unreachable from u, otherwise returns the path as a sequence.
  109|       |        /// Returns None if v is unreachable, otherwise returns the path as a sequence.
  110|       |    /// Returns:
  111|       |        /// Returns None if v is unreachable from u, otherwise returns the path as a sequence.
  111|       |        /// Returns None if v is unreachable from u, otherwise returns the path as a sequence.
  113|       |        /// Returns None if v is unreachable from u, otherwise returns the path as a sequence.
   12|       |        /// Returns None for empty sequence (representing -∞).
  132|       |    /// Returns:
  136|       |    /// Returns:
  143|       |        /// Returns:
  150|       |    /// Returns the set of edge labels in the MST.
  152|       |        /// Returns:
   15|       |        /// Returns None for empty sequence (representing -∞).
  161|       |    /// Returns:
  168|       |    /// Returns:
   19|       |    /// Returns Some(sequence) if graph is acyclic, None if contains a cycle.
   19|       |    /// Returns the set of all vertices reachable from s.
   19|       |    /// Returns the set of all vertices reachable from s.
   19|       |    /// Returns true if a cycle exists, false otherwise.
   19|       |    /// Returns true if a cycle exists, false otherwise.
  205|       |    /// Returns:
   20|       |    /// Returns sequence of components, each component is a set of vertices.
   20|       |    /// Returns sequence of components, each component is a set of vertices.
   20|       |    /// Returns Some(sequence) if graph is acyclic, None if contains a cycle.
   21|       |        /// Returns None for empty sequence (representing -∞).
   21|       |        /// Returns (selected vertices, should_track_parents).
  221|       |    /// Returns:
  226|       |    /// Returns:
   22|       |        /// Returns None for empty sequence (representing -∞).
  231|       |    /// Returns:
   23|       |    /// Returns array where result[v] = distance if reachable, UNREACHABLE otherwise.
   23|       |    /// Returns array where result[v] = distance if reachable, UNREACHABLE otherwise.
   24|       |    /// Returns array where result[v] = distance if reachable, UNREACHABLE otherwise.
   24|       |    /// Returns array where result[v] = distance if reachable, UNREACHABLE otherwise.
   25|       |        /// Returns the minimum element (first in sorted list), or None if empty
   25|       |        /// Returns the minimum element (leftmost in balanced tree), or None if empty
   25|       |        /// Returns the minimum element, or None if empty
   25|       |        /// Returns the minimum element (root of min-heap), or None if empty
  322|       |    /// Returns:
  366|       |        /// Returns (left, found, right) where left < element <= right
   36|       |        /// Returns the number of elements in the sequence
   37|       |    /// Returns sequence of vertices in topological order (respecting edge directions).
   37|       |        /// Returns the minimum element (root of heap), or None if empty
   38|       |    /// Returns:
   38|       |    /// Returns:
   40|       |    /// Returns:
   41|       |    /// Returns:
   42|       |    /// Returns:
   43|       |    /// Returns sequence of vertices in topological order (respecting edge directions).
   45|       |    /// Returns:
   46|       |    /// Returns:
   46|       |    /// Returns:
   50|       |    /// Returns a sequence of vertices visited.
   51|       |    /// Returns:
   51|       |    /// Returns a table mapping each vertex to (neighbor, weight, label).
   51|       |        /// Returns the number of documents in the set
   52|       |    /// Returns:
   53|       |    /// Returns the sum of weights along the path, or None if path is invalid.
   54|       |    /// Returns:
   54|       |    /// Returns:
   54|       |    /// Returns:
   54|       |        /// Returns None if the stack is empty
   54|       |    /// Returns the sum of weights along the path, or None if path is invalid.
   55|       |    /// Returns:
   58|       |        /// Returns a reference to the top item without removing it
   59|       |    /// Returns:
   59|       |        /// Returns None if the stack is empty
   60|       |    /// Returns:
   61|       |        /// Returns the distance from source to vertex v.
   62|       |        /// Returns None for empty sequence (representing -∞).
   63|       |        /// Returns None for empty sequence (representing -∞).
   64|       |        /// Returns documents that contain 'fun' AND either 'food' OR 'chess'
   64|       |        /// Returns the distance from source to vertex v.
   64|       |        /// Returns the distance from source to vertex v.
   64|       |        /// Returns the distance from vertex u to vertex v.
   66|       |        /// Returns the distance from source to vertex v.
   66|       |        /// Returns the distance from vertex u to vertex v.
   67|       |        /// Returns the number of elements in the stack
   69|       |    /// Returns:
   69|       |        /// Returns None for empty sequence (representing -∞).
   69|       |        /// Returns the cached reduction of all values using the reducer function
   70|       |        /// Returns None for empty sequence (representing -∞).
   70|       |        /// Returns the distance from vertex u to vertex v.
   72|       |        /// Returns the cached reduction of all values using the reducer function
   72|       |        /// Returns the distance from vertex u to vertex v.
   73|       |    /// Returns:
   74|       |        /// Returns the load (number of entries) and size (table capacity).
   77|       |        /// Returns the cached reduction of all values using the reducer function
   78|       |    /// Returns:
   79|       |        /// Returns the number of documents that contain 'fun' but not 'chess'
   79|       |        /// Returns the predecessor of vertex v in the shortest path from source.
   81|       |        /// Returns the predecessor of vertex v in the shortest path from source.
   81|       |        /// Returns the predecessor of vertex v in the shortest path from source.
   82|       |    /// Returns:
   83|       |        /// Returns:
   84|       |    /// Returns:
   84|       |        /// Returns the predecessor of vertex v in the shortest path from source.
   85|       |        /// Returns the predecessor of vertex v in the shortest path from u.
   87|       |        /// Returns the predecessor of vertex v in the shortest path from u.
   87|       |        /// Returns the predecessor of vertex v in the shortest path from u.
   88|       |        /// Returns the number of elements in the sequence.
   89|       |        /// Returns the predecessor of vertex v in the shortest path from u.
   90|       |    /// Returns sequences of distance and predecessor rows
   90|       |    /// Returns sequences of distance and predecessor rows
   99|       |        /// Returns None if v is unreachable, otherwise returns the path as a sequence.
  111|      0|        let reverse = example_45_2_reverse_sorted();
  109|       |        // Reverse-Sorted Example
  182|       |        fn reverse_sorted_example() -> HeapsortComparison<i32>;
  131|       |    /// Reweight edges: w'(u,v) = w(u,v) + p(u) - p(v)
  181|       |    /// Reweight edges: w'(u,v) = w(u,v) + p(u) - p(v)
  184|       |    /// Reweight edges: w'(u,v) = w(u,v) + p(u) - p(v)
  203|      5|        WeightedDirGraphStEphInt::from_weighted_edges(vertices, reweighted_edges)
  206|     10|        WeightedDirGraphStEphFloat::from_weighted_edges(vertices, reweighted_edges)
   59|      5|        let reweighted_graph = reweight_graph(graph, &potentials, n);
   66|      5|        let reweighted_graph = reweight_graph(graph, &potentials, n);
   76|     10|        let reweighted_graph = reweight_graph(graph, &potentials, n);
   76|      5|        let reweighted_graph = reweight_graph(graph, &potentials, n);
  117|      5|    fn reweight_graph(
  132|      5|    fn reweight_graph(
  182|      5|    fn reweight_graph(
  185|     10|    fn reweight_graph(
  102|      7|        print!("  right: [");
  103|      5|                    let right = self.data[mid..].to_vec();
  110|    360|                        .map_or(false, |right| right.priority < node.priority)
  111|    431|                let right = Self::right_child(i);
  115|  1.13k|                        .map_or(false, |right| right.priority < node.priority)
  116|  2.62k|                        .map_or(false, |right| right.priority < node.priority)
  119|    431|                if right < result.length() && result.nth(right) < result.nth(smallest) {
  128|  11.0k|            let right = rec(&a[mid + 1..]);
  128|  5.43k|                        .map_or(false, |right| right.priority < node.priority)
  129|  1.23M|            let right = rec(&a[mid + 1..]);
  134|    105|            let right = a.subseq_copy(mid, a.length() - mid);
  141|    231|            let right = Self::size_link(&node.right) as f64;
  141|      7|        print!("  right: [");
  145|      0|                    let right = self.data[mid..].to_vec();
  154|      7|        print!("join(left, right) = [");
  170|     38|            let right = a.subseq_copy(mid, n - mid);
  178|      7|                let right = a.subseq_copy(mid, a.length() - mid);
  182|    759|                        .map_or(false, |right| right.priority < node.priority)
  193|      7|                let right = a.subseq_copy(mid, a.length() - mid);
  197|    241|                    let right = node.right.clone();
   19|       |        pub(crate) right: BalBinTree<T>,
   20|       |        pub right: Link<T>,
  222|  1.99k|            let right = a.subseq_copy(mid, n - mid);
  230|    106|                let right = a.subseq_copy(mid, a.length() - mid);
  232|      4|            let right = a.subseq_copy(mid, a.length() - mid);
  241|      1|            let right = Self {
  244|      6|                let right = a.subseq_copy(mid, a.length() - mid);
  248|      1|            (left, right)
  254|      1|            let right = Self {
   25|       |        pub right: Link<T>,
  261|      1|            (left, right)
  264|  50.0k|            let right = a.subseq_copy(mid, a.length() - mid);
  267|      0|                let right = n.right.take().unwrap();
  275|      1|            let right = Self {
  302|      1|            let right = Self {
  309|      1|            (left, right)
  315|      1|            let right = Self {
  319|     73|            let right = a.subseq_copy(mid, a.length() - mid);
  322|      1|            (left, right)
  337|      1|            let right = Self {
   34|  1.02k|                    let right = a.nth(2 * i + 1);
  344|  1.99k|            let right = a.subseq_copy(mid, a.length() - mid);
  344|      1|            (left, right)
   35|  1.02k|                    f(left, right)
   35|  6.96k|            let right = self.right.read().unwrap();
  364|     25|            let right = a.subseq_copy(mid, len - mid);
  377|       |            // Right heavy: check for Right-Left case
  379|      0|                let right = n.right.take().unwrap();
  386|      2|            let right = other.to_vec();
  405|     20|            let right = a.subseq_copy(mid, len - mid);
   44|     21|        let right = a.subseq_copy(mid, n);
   44|     21|        let right = a.subseq(mid, n);
   49|  1.02k|                    let right = a_arc.nth_cloned(2 * i + 1);
   50|  1.02k|                    f_clone(&left, &right)
   51|    114|                    let right = a_arc.nth_cloned(2 * i + 1);
   52|    114|                    f_contract(&left, &right)
   57|       |        /// right child of node at index i
   63|     18|                let right = ArraySeqStPerS::tabulate(
   63|     22|                let right = ArraySeqMtPerS::tabulate(
   63|     30|                let right = ArraySeqStEphS::tabulate(
   64|      0|            let right = n.right.as_ref().unwrap().clone();
   64|      0|            let right = n.right.as_ref().unwrap().clone();
   65|     26|                let right = ArraySeqMtEphS::tabulate(
   67|  1.12k|                let right = Self::right_child(i);
   70|    198|                    let right = node.right.in_order();
   75|  1.12k|                if right < self.elements.length() {
   80|    569|                (left, right)
   83|     37|                    let right = node.right.pre_order();
   84|     16|            let right = a.subseq(mid, n);
   85|     16|            let right = a.subseq_copy(mid, n);
   89|     29|            let right = a.subseq_copy(mid, n - mid);
   99|    907|            let right = Self::size_link(&node.right) as f64;
  174|     38|            let right_arc = Arc::new(right);
  208|     59|            let right_array = ArraySeqStPerS::filter(&array_seq, &|elem| elem > k);
  213|      8|            let right_array = ArraySeqStPerS::filter(&array_seq, &|elem| elem > k);
  242|      1|                base_table: right_base,
  250|    271|                    let right_base = identity;
  250|      4|                    let right_base = identity;
  255|      1|                base_table: right_base,
  276|      1|                base_table: right_base,
  303|      1|                base_table: right_base,
  316|      1|                base_table: right_base,
  338|      1|                base_table: right_base,
  102|     51|        let right_bridges = pair.1;
  293|      1|                (left.reducer)(&left.cached_reduction, &right.cached_reduction)
   58|  1.55k|        fn right_child(i: N) -> N { 2 * i + 2 }
   31|      0|                return right.clone();
   36|     30|                return right.clone();
   48|     21|        let right_clone = right.clone();
   89|     16|            let right_clone = right.clone();
   55|     50|            let right_cols = self.dimensions[j].cols;
   57|     68|            let right_cols = self.dimensions[j].cols;
   67|     63|            let right_cols = dimensions_guard[j].cols;
   67|      6|            let right_cols = self.dimensions[j].cols;
  108|     68|                        let right_cost = self.matrix_chain_rec(k + 1, j);
  110|    114|                        let right_cost = self.obst_rec(i + k + 1, l - k - 1);
  118|     63|                        let right_cost = self.matrix_chain_rec(k + 1, j);
  122|    179|                        let right_cost = self.obst_rec(i + k + 1, l - k - 1);
   73|     87|                        let right_cost = self.obst_rec(i + k + 1, l - k - 1);
   75|     50|                        let right_cost = self.matrix_chain_rec(k + 1, j);
   85|    381|                        let right_cost = self.obst_rec(i + k + 1, l - k - 1);
   87|      6|                        let right_cost = self.matrix_chain_rec(k + 1, j);
   68|     54|            let right_costs = costs[mid..].to_vec();
   74|     29|            let right_costs = costs[mid..].to_vec();
   77|    108|            let right_costs = costs[mid..].to_vec();
   84|     28|            let right_costs = costs[mid..].to_vec();
  166|      6|            let right_diff = other.difference(self);
  197|      2|            let right_elements: Vec<T> = self.elements.drain(pos..).collect();
  250|      1|            let right_elements: Vec<T> = self.elements.drain(i..).collect();
  259|      1|                    elements: right_elements,
  212|      2|                    elements: right_elements_filtered,
  147|      5|            let right_entries = ArraySeqMtEphS::tabulate(
  191|      4|            let right_entries = self.entries.subseq_copy(mid, len - mid);
  248|      3|            let right_entries = self.entries.subseq_copy(mid, len - mid);
  430|      9|            let right_entries = self.entries.subseq_copy(mid, len - mid);
  483|      2|                let right_entries = self.entries.subseq_copy(mid, len - mid);
  566|      4|            let right_entries = self.entries.subseq_copy(mid, len - mid);
  622|      4|            let right_entries = self.entries.subseq_copy(mid, len - mid);
   94|      4|            let right_entries = self.entries.subseq_copy(mid, len - mid);
  112|      3|            match right.expose_internal() {
  146|    319|            match right.expose_internal() {
  143|     53|            match right.expose_with_priority() {
  225|      5|                        ParamTreap::join_pair_inner(left_filtered, right_filtered)
  228|    135|                        ParamBST::join_pair_inner(left_filtered, right_filtered)
   99|     16|            let right_for_prefix = right.clone();
  177|    190|                    let right_guard = child.read().unwrap();
  178|    190|                    if right_guard.is_none() {
   95|     59|                    let right_h = node.right.height();
  261|       |            let right_handle = std::thread::Builder::new()
  303|      6|            let right_handle = std::thread::spawn(move || Self::reduce(&right_slice, f_right, id_right));
  100|     11|            let right_keys = ArraySeqMtEphS::tabulate(&|i| right_entries.nth_cloned(i).0, right_entries.length());
  131|     30|                let right_left = right.subseq_copy(0, mid_right);
   85|     26|                let right_left = right.subseq_copy(0, mid_right);
  135|     30|                let right_left_arc = Arc::new(right_left);
   89|     26|                let right_left_arc = Arc::new(right_left);
  205|      4|            let right_mapped = ArraySeqMtEphS::tabulate(
   78|     54|            let right_min = handle2.join().unwrap();
   80|     54|            std::cmp::min(left_min, right_min)
   84|     29|            let right_min = handle2.join().unwrap();
   87|    108|            let right_min = handle2.join().unwrap();
   89|    108|            std::cmp::min(left_min, right_min)
   94|     28|            let right_min = handle2.join().unwrap();
  171|    194|            fn rightmost<T: StTInMtT + Ord>(link: &Link<T>) -> Option<T> {
   74|     46|                    if right.nth(mid) < pivot {
  181|  1.12k|                    let right_ok = match right.as_ref() {
   88|  1.11k|            let right_priority = tree_priority(&right);
   76|    724|            let right_rank = right.rank();
  127|  1.10k|            let right_reduced = Self::reduced_value_link(&node.right);
  232|      1|            let right_reduction = Self::calculate_reduction(&right_base, &self.reducer, &self.identity);
  243|      1|                cached_reduction: right_reduction,
  245|      1|            let right_reduction = Self::calculate_reduction(&right_base, &self.reducer, &self.identity);
  256|      1|                cached_reduction: right_reduction,
  266|      1|            let right_reduction = self.recalculate_reduction(&right_base);
  277|      1|                cached_reduction: right_reduction,
  293|      1|            let right_reduction = Self::calculate_reduction(&right_base, &self.reducer, &self.identity);
  304|      1|                cached_reduction: right_reduction,
  306|      1|            let right_reduction = Self::calculate_reduction(&right_base, &self.reducer, &self.identity);
  317|      1|                cached_reduction: right_reduction,
  328|      1|            let right_reduction = self.recalculate_reduction(&right_base);
  339|      1|                cached_reduction: right_reduction,
  184|      4|                        ParamTreap::join_pair_inner(left_res, right_res)
  186|      0|                        ParamBST::join_pair_inner(left_res, right_res)
  202|      5|                        ParamTreap::join_pair_inner(left_res, right_res)
  205|    156|                        ParamBST::join_pair_inner(left_res, right_res)
  137|    105|            let right_result = <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::map(&right, f);
  180|      7|                let right_result = <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::reduce(&right, f, id);
  181|      7|                f(&left_result, &right_result)
  195|      7|                let right_result = <ArraySeqStEphS<T> as ArraySeqStEphTrait<T>>::reduce(&right, f, id);
  196|      7|                f(&left_result, &right_result)
  235|      4|            let right_result = ArraySeqMtPerS::map(&right, f);
  237|    106|                let right_result = <ArraySeqMtPerS<T> as ArraySeqMtPerTrait<T>>::reduce(&right, f_clone2, id);
  237|      4|            ArraySeqMtPerS::append(&left_result, &right_result)
  239|    106|                f(&left_result, &right_result)
  251|      6|                let right_result = <ArraySeqMtEphS<T> as ArraySeqMtEphTrait<T>>::reduce(&right, f_clone2, id);
  253|      6|                f(&left_result, &right_result)
  266|       |            let right_result = right_handle.join().expect("right ParaPair task panicked");
  267|       |            $crate::Types::Types::Pair(left_result, right_result)
  306|      6|            let right_result = right_handle.join().unwrap();
  308|     51|        left_result.append(&mut right_result);
  308|      6|            f(&left_result, &right_result)
  132|     30|                let right_right = right.subseq_copy(mid_right + 1, n_right - mid_right - 1);
   86|     26|                let right_right = right.subseq_copy(mid_right, n_right - mid_right);
  137|     30|                let right_right_arc = Arc::new(right_right);
   91|     26|                let right_right_arc = Arc::new(right_right);
  172|    108|                let right_self_final = right_self;
  133|      5|            let right_seq = key_seq.subseq(mid, len - mid);
  213|      9|            let right_seq = AVLTreeSeqStPerS::from_vec(right_array.into_iter().collect());
  218|      2|            let right_seq = AVLTreeSeqStPerS::from_vec(right_array.into_iter().collect());
  260|      3|            let right_seq = AVLTreeSeqStPerS::from_vec(right_entries);
  272|      3|            let right_seq = AVLTreeSeqStPerS::from_vec(right_entries);
  274|      9|            let right_seq = seq.subseq_copy(i, size - i);
  293|      1|            let right_seq = AVLTreeSeqStPerS::from_vec(right_elements);
  304|      3|            let right_seq = AVLTreeSeqStPerS::from_vec(right_entries);
  336|      3|            let right_seq = AVLTreeSeqStPerS::from_vec(right_entries);
  349|      2|            let right_seq = AVLTreeSeqStPerS::from_vec(right_entries);
  379|      2|            let right_seq = AVLTreeSeqStPerS::from_vec(right_entries);
  134|      0|            let right_set = Self::from_seq(AVLTreeSeqMtPerS::from_vec(right_vals));
  175|      0|            let right_set = Self::from_seq(AVLTreeSeqMtPerS::from_vec(right_vals));
  221|      0|            let right_set = Self::from_seq(AVLTreeSeqMtPerS::from_vec(right_vals));
  312|      2|            let right_side = self.and_not(set3, set4);
  314|      2|            self.or(left_side, right_side)
   18|       |        pub right_size: N,
   23|       |        pub right_size: N,
  295|      6|            let right_slice = a.slice(mid, a.length() - mid);
  353|      1|                let right_table = range_table.get_key_range(&mid_key, k2);
  223|      8|                        let right_tree = Self::make_node(node.key.clone(), node.priority, lr, node.right.clone());
  224|      8|                        (ll, right_tree)
  128|      4|                    let right_union = ParamBST::union_inner(&ar, &br);
  501|      2|                let right_updated = ArraySeqMtEphS::tabulate(
  359|      1|                reducer(&left_val, &right_val)
  131|      0|            let right_vals: Vec<T> = (mid..n).map(|i| self.elements.nth(i).clone()).collect();
  172|      0|            let right_vals: Vec<T> = (mid..n).map(|i| self.elements.nth(i).clone()).collect();
  218|      0|            let right_vals: Vec<T> = (mid..n).map(|i| self.elements.nth(i).clone()).collect();
   78|  5.04k|                let right_vals = vals.split_off(mid);
  110|    217|                let right_vals_final = right_vals;
  172|     34|        let right_vec: std::vec::Vec<Edge<V>> = pair.1.iter().cloned().collect();
  256|    271|                    let right_with_key = op_ref(key, right_acc);
  256|      4|                    let right_with_key = op_ref(key, right_acc);
  257|    271|                    op_ref(left_acc, right_with_key)
  257|      4|                    op_ref(left_acc, right_with_key)
  149|     17|                    ParamTreap::join_with_priority(combined_left, r_key, r_priority, combined_right)
  118|  1.67k|                        let (rl, found, rr) = ParamBST::split_inner(&right, key);
  131|    484|                        let (rl, found, rr) = ParamTreap::split_inner(&right, key);
  141|     30|                    let rl = right_left_arc.clone();
  226|      9|                        let (rl, rr) = Self::split_rank_link(&node.right, rank - left_size - 1);
   90|     28|                        let (rl, found, rr) = ParamBST::split_inner(&right, key);
   95|     26|                    let rl = right_left_arc.clone();
   86|     12|            edge_coins.insert(edge.clone(), rng.random::<bool>());
  158|    255|                let root = self.find(v);
  186|      0|                let root = self.find(&parent_v);
  219|      0|                let root = self.find(v);
   26|     13|        let root: N = (n as f64).sqrt().floor() as N;
   35|     13|                if root >= 2 { root - 1 } else { 0 },
   39|       |        pub root: Link<T>,
   44|       |        pub root: Link<T>,
   81|     37|                    let root = <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::singleton(node.value.clone());
   93|    348|                let root = self.find(&parent_v);
   84|     37|                    let root_left = <ArraySeqStPerS<T> as ArraySeqStPerTrait<T>>::append(&root, &left);
  111|    144|            let root_u = self.find(u);
  114|    144|            if root_u == root_v {
  193|      0|            let root_u = self.find(u);
  196|      0|            if root_u == root_v {
  112|    144|            let root_v = self.find(v);
  194|      0|            let root_v = self.find(v);
   58|      0|                let rotated = rotate_left(left);
   58|      0|                let rotated = rotate_left(left);
   66|      0|                let rotated = rotate_right(right);
   66|      0|                let rotated = rotate_right(right);
  142|    158|        fn rotate_left(link: &mut Link<K, V, R>) {
   73|    106|        fn rotate_left(link: &mut Link<K, V>) {
   75|    244|        fn rotate_left(link: &mut Link<T>) {
   76|    730|        fn rotate_left(link: &mut Link<T>) {
   78|  22.9k|        fn rotate_left(link: &mut Link<T>) {
   84|    107|        fn rotate_left(link: &mut Link<T>) {
   88|  1.02k|        fn rotate_left(link: &mut Link<T>) {
   95|    110|        fn rotate_left(link: &mut Link<T>) {
   95|  1.32k|        fn rotate_left(link: &mut Link<T>) {
   67|      0|                return rotate_left(mk(n.value.clone(), n.left.clone(), Some(rotated)));
   67|      0|                return rotate_left(mk(n.value.clone(), n.left.clone(), Some(rotated)));
  270|  17.6M|            return rotate_left(n);
  382|      6|            return rotate_left(n);
   69|      0|            return rotate_left(n);
   69|      0|            return rotate_left(n);
  138|   116k|            let rotate_left_needed = match link {
  142|   116k|            if rotate_left_needed {
  243|  17.6M|    fn rotate_left<T: StT>(mut x: Box<AVLTreeNode<T>>) -> Box<AVLTreeNode<T>> {
  351|      6|    fn rotate_left<T: Copy + Debug>(mut x: Box<AVLTreeNode<T>>) -> Box<AVLTreeNode<T>> {
   45|      0|    fn rotate_left<T: StTInMtT>(x: Arc<Node<T>>) -> Arc<Node<T>> {
   45|      0|    fn rotate_left<T: StT>(x: Rc<Node<T>>) -> Rc<Node<T>> {
  101|     11|        fn rotate_right(link: &mut Link<T>) {
  102|     23|        fn rotate_right(link: &mut Link<T>) {
  156|      5|        fn rotate_right(link: &mut Link<K, V, R>) {
   81|    112|        fn rotate_right(link: &mut Link<T>) {
   81|     16|        fn rotate_right(link: &mut Link<T>) {
   85|      4|        fn rotate_right(link: &mut Link<K, V>) {
   89|     21|        fn rotate_right(link: &mut Link<T>) {
   90|     76|        fn rotate_right(link: &mut Link<T>) {
   97|    463|        fn rotate_right(link: &mut Link<T>) {
   59|      0|                return rotate_right(mk(n.value.clone(), Some(rotated), n.right.clone()));
   59|      0|                return rotate_right(mk(n.value.clone(), Some(rotated), n.right.clone()));
  263|      0|            return rotate_right(n);
  374|      0|            return rotate_right(n);
   61|      0|            return rotate_right(n);
   61|      0|            return rotate_right(n);
  146|   116k|            let rotate_right_needed = match link {
  156|   116k|            if rotate_right_needed {
  232|      0|    fn rotate_right<T: StT>(mut y: Box<AVLTreeNode<T>>) -> Box<AVLTreeNode<T>> {
  338|      0|    fn rotate_right<T: Copy + Debug>(mut y: Box<AVLTreeNode<T>>) -> Box<AVLTreeNode<T>> {
   38|      0|    fn rotate_right<T: StTInMtT>(y: Arc<Node<T>>) -> Arc<Node<T>> {
   38|      0|    fn rotate_right<T: StT>(y: Rc<Node<T>>) -> Rc<Node<T>> {
  108|     38|            if round == n - 1 {
  117|     30|            if round == n - 1 {
   60|     57|        for round in 0..n {
   70|     49|        for round in 0..n {
  106|    112|    fn route_edges_parallel<V: StT + MtT + Hash + Ord + 'static>(
  135|     99|    fn route_edges_parallel<V: StT + MtT + Hash + Ord + 'static>(
   75|       |    /// Routes edges through partition map, removing self-loops.
   80|       |    /// Routes edges through partition map using divide-and-conquer parallelism.
  101|      1|            let row = self.matrix.nth(u);
  116|      3|                let row = self.matrix.nth(i);
  145|      3|                let row = self.matrix.nth(i);
   59|     13|                let row = self.matrix.nth(i);
   63|      4|                let row = self.matrix.nth(i);
   80|      1|            let row = self.matrix.nth(u);
   86|      1|            let row = self.matrix.nth(u);
   94|      1|            let row = self.matrix.nth(u);
   61|     57|                    if *row.nth(j) {
   65|     16|                    if *row.nth(j) {
  104|      4|                if *row.nth(v) {
   83|      4|                if *row.nth(v) {
   89|      4|                if *row.nth(v) {
   97|      4|                if *row.nth(v) {
   13|       |        pub rows: usize,
   13|       |        pub rows: usize,
   15|       |        pub rows: usize,
   15|       |        pub rows: usize,
  145|     30|                    let rr = right_right_arc.clone();
  228|      9|                        (left_tree, rr)
   99|     26|                    let rr = right_right_arc.clone();
   39|       |        /// Run comprehensive demonstration of Example 45.2
   93|       |    /// Run comprehensive demonstration of Example 45.2
   14|       |        fn run_example43_1();
   41|       |        fn run_example_45_2() -> String;
   27|       |    /// Runs Bellman-Ford algorithm on a weighted directed graph
   27|       |    /// Runs Bellman-Ford algorithm on a weighted directed graph
   55|       |    /// Runs Dijkstra's algorithm on a weighted directed graph
   55|       |    /// Runs Dijkstra's algorithm on a weighted directed graph
    6|       |//! using rust vector which is dense.
  100|      0|                        return s;
  110|      5|                        return s;
  114|      5|                        return s;
  152|      0|                        return s;
  156|      0|                        return s;
  168|      6|            let s = start.min(n);
  183|     18|            let s = start.min(n);
  185|      2|            let s = start.min(n);
  186|     24|            let s = start.min(n);
  187|      2|            if s >= e {
  190|      2|            let s = start.min(n);
  232|     12|            let s = start.min(n);
   40|     16|                seq_s: s,
   40|     16|                seq_s: s,
   42|     16|                seq_s: s,
   42|     16|                seq_s: s,
   49|    885|            let s = start.min(n);
   73|  8.14k|            let s = start.min(n);
   77|     20|            strategy: &S,
   82|     20|            strategy: &S,
   89|      0|                        return s;
   90|     32|                strategy: &S,
   93|      0|                        return s;
   96|      0|                        return s;
  128|     22|                // Same rank: attach v under u and increase u's rank
  364|      2|             with same h(k) follow identical sequences. (3) Double hashing provides maximum \
  193|       |                // Sample up to 100 positions
  195|      1|        let sample_content = "I had fun in dance club today!";
  161|       |        /// Scale all weights by a factor
   10|       |        /// Scan a sequence using contraction: contract→solve→expand.
   14|       |        /// Scan a sequence using parallel contraction: contract→solve→expand.
    2|       |//! Parallel scan using contraction technique (Chapter 27, Algorithm 27.3).
    2|       |//! Sequential scan using contraction technique (Chapter 27, Algorithm 27.3).
   82|       |            // Scan table to identify clusters
   13|       |        fn scan_contract<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, id: T) -> ArraySeqStEphS<T>;
   17|     22|        fn scan_contract<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, id: T) -> ArraySeqStEphS<T> {
    4|       |pub mod ScanContractMtEph {
   17|       |        fn scan_contract_parallel<F: Fn(&T, &T) -> T + Send + Sync + 'static>(
   25|     22|        fn scan_contract_parallel<F: Fn(&T, &T) -> T + Send + Sync + 'static>(
    4|       |pub mod ScanContractStEph {
  104|       |        fn scan<F: Fn(&T, &T) -> T>(a: &ArraySeqS<T>, f: &F, id: T) -> (ArraySeqS<T>, T)
  135|       |        fn scan<F: Fn(&T, &T) -> T>(a: &ArraySeqStPerS<T>, f: &F, id: T) -> (ArraySeqStPerS<T>, T);
  162|       |        fn scan<F: Fn(&T, &T) -> T + Send + Sync>(a: &ArraySeqMtEphS<T>, f: &F, id: T) -> (ArraySeqMtEphS<T>, T);
  174|       |        fn scan<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, id: T) -> (ArraySeqStEphS<T>, T);
  175|       |        fn scan<F: Fn(&T, &T) -> T + Send + Sync>(a: &ArraySeqMtPerS<T>, f: &F, id: T) -> (ArraySeqMtPerS<T>, T);
  185|      2|        fn scan<F: Fn(&T, &T) -> T>(a: &ArraySeqStPerS<T>, f: &F, id: T) -> (ArraySeqStPerS<T>, T) {
  200|      2|        fn scan<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, id: T) -> (ArraySeqStEphS<T>, T) {
  243|      2|        fn scan<F: Fn(&T, &T) -> T + Send + Sync>(a: &ArraySeqMtPerS<T>, f: &F, id: T) -> (ArraySeqMtPerS<T>, T) {
  248|       |        fn scan<F: Fn(&T, &T) -> T>(a: &Self, f: &F, id: T) -> (LinkedListStEphS<T>, T);
  257|      2|        fn scan<F: Fn(&T, &T) -> T + Send + Sync>(a: &ArraySeqMtEphS<T>, f: &F, id: T) -> (ArraySeqMtEphS<T>, T) {
  270|      8|        fn scan<F: Fn(&T, &T) -> T>(a: &ArraySeqStPerS<T>, f: &F, id: T) -> (ArraySeqStPerS<T>, T) {
  292|      4|        fn scan<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, id: T) -> (ArraySeqStEphS<T>, T) {
  311|      1|        fn scan<F: Fn(&T, &T) -> T + Send + Sync>(a: &Self, f: &F, id: T) -> (ArraySeqMtEphSliceS<T>, T) {
  315|      1|        fn scan<F: Fn(&T, &T) -> T>(a: &ArraySeqS<T>, f: &F, id: T) -> (ArraySeqS<T>, T) {
  331|      1|        fn scan<F: Fn(&T, &T) -> T + Send + Sync>(a: &ArraySeqMtPerS<T>, f: &F, id: T) -> (ArraySeqMtPerS<T>, T) {
  356|      1|        fn scan<F: Fn(&T, &T) -> T + Send + Sync>(a: &ArraySeqMtEphS<T>, f: &F, id: T) -> (ArraySeqMtEphS<T>, T) {
  370|      3|        fn scan<F: Fn(&T, &T) -> T>(a: &LinkedListStPerS<T>, f: &F, id: T) -> (LinkedListStPerS<T>, T) {
  411|      3|        fn scan<F: Fn(&T, &T) -> T>(a: &Self, f: &F, id: T) -> (LinkedListStEphS<T>, T) {
   52|       |        fn scan<F: Fn(&T, &T) -> T + Send + Sync>(a: &ArraySeqMtEphS<T>, f: &F, id: T) -> (ArraySeqMtEphS<T>, T);
   54|       |        fn scan<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, id: T) -> (ArraySeqStEphS<T>, T);
   54|       |        fn scan<F: Fn(&T, &T) -> T>(a: &ArraySeqStPerS<T>, f: &F, id: T) -> (ArraySeqStPerS<T>, T);
   58|       |        fn scan<F: Fn(&T, &T) -> T + Send + Sync>(a: &ArraySeqMtPerS<T>, f: &F, id: T) -> (ArraySeqMtPerS<T>, T);
   69|       |        fn scan<F: Fn(&T, &T) -> T + Send + Sync>(a: &Self, f: &F, id: T) -> (ArraySeqMtEphSliceS<T>, T);
   82|       |        fn scan<F: Fn(&T, &T) -> T>(a: &LinkedListStPerS<T>, f: &F, id: T) -> (LinkedListStPerS<T>, T);
   75|    114|                        let scan_val = c_arc.nth_cloned(i / 2);
   16|       |        fn scc(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>) -> AVLTreeSeqStEphS<AVLTreeSetStEph<N>>;
   16|       |        fn scc(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>) -> AVLTreeSeqStPerS<AVLTreeSetStPer<N>>;
    6|       |pub mod SCCStEph {
    6|       |pub mod SCCStPer {
  101|     23|            let s_char = *self.seq_s.nth(i - 1);
  102|     21|            if s_char == t_char {
  104|     23|            if s_char == t_char {
  126|     29|                    let s_char = self.seq_s.nth_cloned(i - 1);
  128|     22|                    let s_char = *self.seq_s.nth(i - 1);
  129|     29|                    if s_char == t_char {
  131|     22|                    if s_char == t_char {
  132|     21|            let s_char = *seq_s.nth(i - 1);
  133|     21|            let s_char = seq_s.nth_cloned(i - 1);
  137|     21|            if s_char == t_char {
  138|     21|            if s_char == t_char {
   68|     13|                    let s_char = *self.seq_s.nth(i - 1);
   71|     13|                    if s_char == t_char {
   71|     13|                    let s_char = *self.seq_s.nth(i - 1);
   73|     10|                    let s_char = self.seq_s.nth_cloned(i - 1);
   73|     10|                    let s_char = *self.seq_s.nth(i - 1);
   74|     13|                    if s_char == t_char {
   76|     10|                    if s_char == t_char {
   76|     10|                    if s_char == t_char {
   99|     21|            let s_char = *self.seq_s.nth(i - 1);
    2|       |//! Breadth-First Search - Parallel Ephemeral (Chapter 54).
    2|       |//! Breadth-First Search - Parallel Persistent (Chapter 54).
    2|       |//! Breadth-First Search - Sequential Ephemeral (Chapter 54, Algorithm 54.3).
    2|       |//! Breadth-First Search - Sequential Persistent (Chapter 54, Algorithm 54.3).
    2|       |//! Depth-First Search - Sequential Ephemeral (Chapter 55, Algorithm 55.7).
    2|       |//! Depth-First Search - Sequential Persistent (Chapter 55, Algorithm 55.2).
   33|       |            // Search for existing key and update
  219|       |            // Secondary clustering coefficient: how much probe sequences overlap
  228|       |            // Secondary clustering coefficient based on probe sequence similarity
   22|       |    /// Secondary Clustering Metrics
  321|      1|            writeln!(f, "Secondary Clustering Metrics:")?;
  327|      1|                "  Secondary clustering coefficient: {:.3}",
  146|     16|            let secondary_clustering = if self.detailed_metrics {
   22|       |        pub secondary_clustering: Option<SecondaryClusteringMetrics>,
  229|     20|            let secondary_clustering_coefficient = 1.0 - probe_sequence_diversity;
   29|       |        pub secondary_clustering_coefficient: f64,
  163|      1|                return SecondaryClusteringMetrics {
  175|      0|                return SecondaryClusteringMetrics {
  293|     16|                let secondary_penalty = m.secondary_clustering_coefficient * 30.0;
    4|       |//! Implements Section 4: Approximating Metric TSP via MST
    4|       |//! Implements Section 4: Approximating Metric TSP via MST (parallel version)
  216|      1|        star_contract_mt(graph, seed, &base, &expand)
  250|      0|        star_contract_mt(graph, seed, &base, &expand)
   70|     15|        count_components_mt(&quotient_graph, seed + 1)
   75|      1|        star_contract_mt(graph, seed, &base, &expand)
  272|      3|                if seen.insert(idx) {
  217|      7|                if seen.insert(x.clone()) {
  118|       |                if !__seen_keys.insert(key) {
  156|      1|            let segment: Vec<T> = self.data[start_index..end_exclusive].iter().cloned().collect();
  104|       |                // Select vertex with minimum priority
  124|       |        // Select edges from Tail→Head (Tail=false, Head=true)
   20|       |        /// Select subset U ⊆ F where |U| ≥ 1.
   25|       |    /// Select all vertices in frontier (breadth-first style).
  271|       |            // Select from concatenated sequences: if index < |a| then a[index] else b[index - |a|]
   32|       |    /// Select single arbitrary vertex (depth-first style).
   89|       |        // Select edges where coin is heads and all adjacent edges are tails
  115|     11|        fn select(a: &ArraySeqStEphS<T>, b: &ArraySeqStEphS<T>, index: N) -> Option<T> {
  117|      5|        fn select(a: &ArraySeqMtEphS<T>, b: &ArraySeqMtEphS<T>, index: N) -> Option<T> {
  270|      8|        fn select(a: &LinkedListStPerS<T>, b: &LinkedListStPerS<T>, index: N) -> Option<T> {
   36|       |        fn select(a: &ArraySeqStEphS<T>, b: &ArraySeqStEphS<T>, index: N) -> Option<T>;
   38|       |        fn select(a: &ArraySeqMtEphS<T>, b: &ArraySeqMtEphS<T>, index: N) -> Option<T>;
   54|       |        fn select(a: &LinkedListStPerS<T>, b: &LinkedListStPerS<T>, index: N) -> Option<T>;
   84|       |        // select(A, 5) → 'sam'
  112|      7|        fn select<'a>(a: &'a ArraySeqStPerS<T>, b: &'a ArraySeqStPerS<T>, i: N) -> Option<&'a T> {
  299|     13|        fn select<'a>(a: &'a ArraySeqMtPerS<T>, b: &'a ArraySeqMtPerS<T>, i: N) -> Option<&'a T> {
   36|       |        fn select<'a>(a: &'a ArraySeqStPerS<T>, b: &'a ArraySeqStPerS<T>, i: N) -> Option<&'a T>;
   77|       |        fn select<'a>(a: &'a ArraySeqMtPerS<T>, b: &'a ArraySeqMtPerS<T>, i: N) -> Option<&'a T>;
  105|     23|                let (selected, _) = strategy.select(&frontier);
  118|      4|        let selected = select_edges_recursive(graph_arc, edges_arc, map_arc, 0, n);
   90|     13|            let (selected, _) = strategy.select(&frontier);
   95|     13|            let (selected, _) = strategy.select(&frontier);
   96|      4|    fn select_edges_parallel<V: StT + MtT + Hash + 'static>(
  132|     72|    fn select_edges_recursive<V: StT + MtT + Hash + 'static>(
  101|     13|            let selected_seq = selected.to_seq();
  113|     23|                let selected_seq = selected.to_seq();
   94|     13|            let selected_seq = selected.to_seq();
    3|       |//! Randomized selection algorithm for finding kth order statistic.
    3|       |//! Randomized selection algorithm for finding kth order statistic.
    3|       |//! Randomized selection algorithm for finding kth order statistic with parallel partition.
    3|       |//! Randomized selection algorithm for finding kth order statistic with parallel partition.
    5|       |//! Priority selection is sequential, but set operations benefit from thread-safe structures.
   43|       |            S: SelectionStrategy<V>;
   49|       |            S: SelectionStrategy<V>;
   49|       |            S: SelectionStrategy<V>;
   53|       |            S: SelectionStrategy<V>;
   54|       |            S: SelectionStrategy<V>;
   60|       |            S: SelectionStrategy<V>;
   62|      6|        S: SelectionStrategy<V>,
   67|      6|        S: SelectionStrategy<V>,
   73|      7|        S: SelectionStrategy<V>,
   74|      8|        S: SelectionStrategy<V>,
   78|      7|        S: SelectionStrategy<V>,
   84|     20|            S: SelectionStrategy<V>,
   85|      9|        S: SelectionStrategy<V>,
   89|     20|            S: SelectionStrategy<V>,
   97|     32|                S: SelectionStrategy<V>,
  286|      7|        fn select_key(&self, i: N) -> Option<K> { self.base_table.select_key(i) }
  299|      8|        fn select_key(&self, i: N) -> Option<K> { self.base_table.select_key(i) }
  307|      9|        fn select_key(&self, i: N) -> Option<K> {
  318|     13|        fn select_key(&self, i: N) -> Option<K> {
  321|      1|        fn select_key(&self, i: N) -> Option<K> { self.base_table.select_key(i) }
  348|     14|        fn select_key(&self, i: N) -> Option<K> {
   62|       |        fn select_key(&self, i: N) -> Option<K>;
   65|       |        fn select_key(&self, i: N) -> Option<K>;
   70|       |        fn select_key(&self, i: N) -> Option<K>;
   75|       |        fn select_key(&self, i: N) -> Option<K>;
   78|       |        fn select_key(&self, i: N) -> Option<K>;
   80|       |        fn select_key(&self, i: N) -> Option<K>;
  200|    174|        fn select_link<'a>(link: &'a Link<T>, rank: N) -> Option<&'a T> {
   14|       |        fn select(&self, k: N) -> Option<T>;
   14|       |        fn select(&self, k: N) -> Option<T>;
   14|       |        fn select(&self, k: N) -> Option<T>;
   16|       |        fn select(&self, k: N) -> Option<T>;
   17|       |        fn select(&self, frontier: &AVLTreeSetStEph<V>) -> (AVLTreeSetStEph<V>, B);
   18|    100|        fn select(&self, k: N) -> Option<T> {
   18|     84|        fn select(&self, k: N) -> Option<T> {
   18|     85|        fn select(&self, k: N) -> Option<T> {
   20|     88|        fn select(&self, k: N) -> Option<T> {
   22|     11|        fn select(&self, frontier: &AVLTreeSetStEph<V>) -> (AVLTreeSetStEph<V>, B) { (frontier.clone(), false) }
   22|       |        fn select(&self, frontier: &AVLTreeSetMtPer<V>) -> (AVLTreeSetMtPer<V>, B);
   22|       |        fn select(&self, frontier: &AVLTreeSetStPer<V>) -> (AVLTreeSetStPer<V>, B);
  246|      6|        fn select(&self, i: N) -> Option<T> { self.elements.get(i).cloned() }
  254|     13|        fn select(&self, i: N) -> Option<T> {
  262|      6|        fn select(&self, i: N) -> Option<T> {
   27|     11|        fn select(&self, frontier: &AVLTreeSetMtPer<V>) -> (AVLTreeSetMtPer<V>, B) { (frontier.clone(), false) }
   27|      2|        fn select(&self, frontier: &AVLTreeSetStEph<V>) -> (AVLTreeSetStEph<V>, B) {
  273|     44|        fn select(&self, rank: N) -> Option<&T> {
   29|     20|        fn select(&self, frontier: &AVLTreeSetStPer<V>) -> (AVLTreeSetStPer<V>, B) { (frontier.clone(), false) }
   32|      2|        fn select(&self, frontier: &AVLTreeSetMtPer<V>) -> (AVLTreeSetMtPer<V>, B) {
   36|      3|        fn select(&self, frontier: &AVLTreeSetStPer<V>) -> (AVLTreeSetStPer<V>, B) {
   63|       |        fn select(&self, rank: N) -> Option<&T>;
   66|       |        fn select(&self, i: N) -> Option<T>;
   67|       |        fn select(&self, i: N) -> Option<T>;
   67|       |        fn select(&self, i: N) -> Option<T>;
   80|    632|                    if self.0 < other.0 {
   75|    632|            match (self.0.is_nan(), other.0.is_nan()) {
  102|    423|            match self {
  148|    359|            match self {
  156|     14|            match self {
  164|  2.27k|            match self {
  174|  2.27k|            match self {
  192|     22|            match self {
   20|      3|            match self {
  211|      1|                return <Self as ArraySeqMtEphSliceTrait<T>>::empty();
  264|      0|                return <Self as ArraySeqMtEphSliceTrait<T>>::empty();
  270|      0|                return <Self as ArraySeqMtEphSliceTrait<T>>::empty();
   27|      0|            match self {
   34|      0|            match self {
   49|  8.11k|                if self
   58|      6|            match self {
   65|    418|            match self {
   67|  4.42k|            match self {
   72|      0|                return self;
   75|      0|                return self;
   75|      0|                return self;
   77|      0|                return self;
   78|     85|            match self {
   80|  7.89k|                if self
   91|    139|            match self {
   93|      0|                return self;
   96|      0|                return self;
   97|      0|                return self;
   99|      0|                return self;
  155|      0|                .field("A", &self.A)
  346|      0|                .field("A", &self.A)
  141|      2|            match self.adj.find(u) {
   82|     14|            match self.adj.find(u) {
   82|      9|            match self.adj.find(u) {
   89|      8|            match self.adj.find(u) {
   90|      9|            match self.adj.find(u) {
  128|     21|            if self.adj.find(&v).is_none() {
   71|      3|            if self.adj.find(&v).is_some() {
  108|      1|                    adj: self.adj.insert(u.clone(), new_u_neighbors),
   75|      3|                adj: self.adj.insert(v, AVLTreeSetMtPer::empty()),
  139|     16|            if !self.analysis_enabled {
  180|     16|            if !self.analysis_enabled {
   97|     20|            if !self.analysis_enabled {
   97|     10|                if Self::are_relatively_prime(candidate, table_size) {
  134|       |                self.a, self.b, self.p
  161|     13|                && self.balanced_tree_result == *expected
  283|      1|                base_set: self.base_set.clone(),
  305|      0|                base_set: self.base_set.clone(),
  106|      2|                base_set: self.base_set.delete(x),
  134|      1|                base_set: self.base_set.difference(&other.base_set),
  113|      1|                base_set: self.base_set.filter(f),
   99|     84|                base_set: self.base_set.insert(x),
  120|      1|                base_set: self.base_set.intersection(&other.base_set),
  127|      9|                base_set: self.base_set.union(&other.base_set),
  345|      1|                base_table: self.base_table.clone(),
  361|      2|                base_table: self.base_table.clone(),
  389|      4|                base_table: self.base_table.clone(),
  114|      8|                base_table: self.base_table.delete(k),
  159|      2|                base_table: self.base_table.difference(&other.base_table),
  138|      4|                base_table: self.base_table.filter(f),
  107|    520|                base_table: self.base_table.insert(k, v, |_old, new| new.clone()),
  145|      2|                base_table: self.base_table.intersection(&other.base_table, f),
  131|      4|                base_table: self.base_table.map(f),
  166|      2|                base_table: self.base_table.restrict(keys),
  260|      1|            if self.base_table.size() == 0 {
  273|      1|            if self.base_table.size() == 0 {
  173|      2|                base_table: self.base_table.subtract(keys),
  152|      4|                base_table: self.base_table.union(&other.base_table, f),
  102|     10|                if self.bits[i] {
  122|     10|                result_bits.set(i, self.bits[i] && other.bits[i]);
  134|     10|                result_bits.set(i, self.bits[i] && !other.bits[i]);
  146|     10|                result_bits.set(i, self.bits[i] || other.bits[i]);
  257|      0|                .load_factor(self.num_elements, self.buckets.length())
  281|      9|            HashTableStats::new(self.num_elements, self.buckets.length()).with_collision_stats(
  288|      0|            HashTableStats::new(self.num_elements, self.buckets.length()).with_collision_stats(
  248|      3|            PrimeValidator::validate_quadratic_params(table_size, self.c1, self.c2)
  314|       |                self.c1, self.c2, self.clustering_enabled, self.prime_validation_enabled
  378|      1|                .field("cached_reduction", &self.cached_reduction)
  411|      1|                .field("cached_reduction", &self.cached_reduction)
  413|      1|                .field("cached_reduction", &self.cached_reduction)
  105|      1|                return (self.clone(), None);
  134|     29|                        let self_clone1 = self.clone();
  136|     22|                        let self_clone1 = self.clone();
  114|      0|                return self.clone();
  118|      1|                return (self.clone(), None);
  121|      0|                return self.clone();
  142|      0|            parallel_ng_of_vertices(vertices, self.clone())
  146|      0|                return (self.clone(), false);
  151|      2|                return (self.clone(), false);
   69|    103|                        let self_clone1 = self.clone();
   70|     54|            let self_clone1 = self.clone();
   75|     77|                        let self_clone1 = self.clone();
   76|     29|            let self_clone1 = self.clone();
   79|    108|            let self_clone1 = self.clone();
   79|     45|                        let self_clone1 = self.clone();
  180|      0|            parallel_ng_of_vertices(vertices, self.clone())
   86|     28|            let self_clone1 = self.clone();
   91|     96|                        let self_clone1 = self.clone();
  192|      1|                return (self.clone(), None);
  201|      2|                return self.clone();
  135|     29|                        let self_clone2 = self.clone();
  137|     22|                        let self_clone2 = self.clone();
  218|      1|                return (self.clone(), None);
  225|      0|                return (self.clone(), None);
  257|     16|                return self.clone();
  269|      1|                return (self.clone(), Self::empty());
   70|    103|                        let self_clone2 = self.clone();
   71|     54|            let self_clone2 = self.clone();
   76|     77|                        let self_clone2 = self.clone();
   77|     29|            let self_clone2 = self.clone();
   80|    108|            let self_clone2 = self.clone();
   80|     45|                        let self_clone2 = self.clone();
  283|      1|                (BSTSizeStEph::new(), self.clone())
  287|      0|            parallel_nplus_of_vertices(vertices, self.clone())
   87|     28|            let self_clone2 = self.clone();
   92|     96|                        let self_clone2 = self.clone();
  136|     29|                        let self_clone3 = self.clone();
  138|     22|                        let self_clone3 = self.clone();
  322|      1|                return (self.clone(), Self::empty());
  332|      0|            parallel_nminus_of_vertices(vertices, self.clone())
   72|      0|                return self.clone();
   87|      0|                return self.clone();
   93|      0|                    return self.clone();
   97|      1|                return (self.clone(), None);
  135|     20|            if !self.clustering_enabled {
  162|     21|            if !self.clustering_enabled {
   57|     22|            if !self.clustering_enabled {
   25|  25.4k|                match self.compare_exchange_weak(current, next, Ordering::AcqRel, Ordering::Acquire) {
  181|      0|                return self.create_empty_analysis("DoubleHashing".to_string(), table_size, load_factor);
   98|      1|                return self.create_empty_analysis("LinearProbing".to_string(), 0, 0.0);
  140|      0|                return self.create_empty_analysis("QuadraticProbing".to_string(), 0, 0.0);
  271|      6|            if self.current.is_some() {
   76|     29|                if self.data[i] != other.data[i] {
  139|      0|            match self.data.len() {
   72|     11|            if self.data.len() != other.data.len() {
   97|      7|            match self.data.len() {
  196|      1|                data: self.data[s..e].to_vec(),
  120|     14|            if self.dimensions.len() <= 1 {
  132|      5|            if self.dimensions.len() <= 1 {
  159|     12|            if self.dimensions.len() <= 1 {
  232|      1|            let self_dims = self.dimensions.lock().unwrap();
  101|      5|                distances: self.distances,
  103|      5|                distances: self.distances,
   96|      5|                distances: self.distances,
   99|      5|                distances: self.distances,
  134|      1|                .field("E", &self.E)
  219|      1|                .field("E", &self.E)
   89|      2|                edges: self.edges.clone(),
   91|     14|                edges: self.edges.clone(),
  124|      1|                edges: self.edges.delete(&Pair(u.clone(), v.clone())),
  151|      7|            match self.elements.binary_search(k) {
  171|      8|            match self.elements.binary_search(k) {
  239|      6|            match self.elements.binary_search(k) {
   89|    266|            match self.elements.binary_search(&x) {
  184|    233|                elements: self.elements.clone(),
  192|  5.80k|                elements: self.elements.clone(),
  274|    494|                elements: self.elements.clone(),
  104|    118|            if self.elements.length() == 0 {
  117|    254|            if self.elements.length() == 0 {
  182|     10|            if self.elements.length() == 0 {
  191|      3|            if self.elements.length() == 0 {
  192|     21|            if self.elements.length() == 0 {
  215|      0|            if self.elements.length() == 0 {
  217|    404|            if self.elements.length() == 0 {
  221|    403|            if self.elements.length() == 1 {
  224|      0|            if self.elements.length() == 0 {
  306|      3|            if self.elements.length() == 0 {
  355|      4|            if self.elements.length() == 0 {
   70|     21|            if self.elements.length() == 0 {
   70|     30|            if self.elements.length() == 0 {
   70|     31|            if self.elements.length() == 0 {
   96|    233|            if self.elements.length() == 0 {
  118|  1.71k|                if self.elements.nth(i) == x {
  141|  1.16M|                if self.elements.nth(i) == x {
  143|  20.0M|                if self.elements.nth(i) == x {
   70|    555|                    if self.elements.nth(i) > self.elements.nth(left) {
   76|    542|                    if self.elements.nth(i) > self.elements.nth(right) {
  152|      0|                return Self::empty();
  188|      1|                return Self::empty();
  189|      3|                return Self::empty();
  223|    189|                return (Self::empty(), Some(min_element));
  267|      0|                return Self::empty();
  337|      1|                return Self::empty();
   64|      6|                return Self::empty();
   72|      2|                return Self::empty();
   74|      1|                return Self::empty();
   98|     66|                .map(|i| self.entries.nth(i).0.clone())
  176|     22|            match self.expose_internal() {
  334|  5.28k|            match self.expose_internal() {
  388|    799|            match self.expose_internal() {
  105|    128|                if !self.find(elem) {
  114|     25|                if !self.find(elem) {
  131|    275|            if !self.find(&x) {
  160|  37.6k|            if self.find(&x) {
  163|   555k|            if !self.find(&x) {
  256|    232|            if self.find(&x) {
  276|      9|            (Self::from_seq(left_seq), Self::from_seq(right_seq))
  298|      1|            (Self::from_seq(left_seq), Self::from_seq(right_seq))
  167|      1|                hash_function: self.hash_function.clone(),
  189|      9|                Self::create_table(self.key_equality.clone(), self.hash_function.clone(), actual_new_size);
  244|    129|                hash_function: self.hash_function.clone(),
   99|    122|                hash_function: self.hash_function.clone(),
   46|     11|                next: self.head.take(),
  115|    104|                        if Self::height_link(&left.right) > Self::height_link(&left.left) {
  115|     16|                        if Self::height_link(&left.right) > Self::height_link(&left.left) {
  122|    110|                        if Self::height_link(&right.left) > Self::height_link(&right.right) {
  122|  1.22k|                        if Self::height_link(&right.left) > Self::height_link(&right.right) {
  120|    172|                identity: self.identity.clone(),
  135|      2|                identity: self.identity.clone(),
  162|      1|                identity: self.identity.clone(),
  164|      1|                identity: self.identity.clone(),
  173|      1|                identity: self.identity.clone(),
  175|      1|                identity: self.identity.clone(),
  177|      1|                identity: self.identity.clone(),
  186|      1|                identity: self.identity.clone(),
  190|      1|                identity: self.identity.clone(),
  203|      1|                identity: self.identity.clone(),
  216|      1|                identity: self.identity.clone(),
  229|      1|                identity: self.identity.clone(),
  238|      1|                identity: self.identity.clone(),
  242|      1|                identity: self.identity.clone(),
  245|      1|                identity: self.identity.clone(),
  251|      1|                identity: self.identity.clone(),
  258|      1|                identity: self.identity.clone(),
  272|      1|                identity: self.identity.clone(),
  278|      8|                identity: self.identity.clone(),
  279|      1|                identity: self.identity.clone(),
  291|     23|                identity: self.identity.clone(),
  299|      1|                identity: self.identity.clone(),
  306|      1|                identity: self.identity.clone(),
  312|      1|                identity: self.identity.clone(),
  313|      7|                identity: self.identity.clone(),
  319|      1|                identity: self.identity.clone(),
  334|      1|                identity: self.identity.clone(),
  341|      1|                identity: self.identity.clone(),
  230|      4|            if self.index < self.values.len() {
  134|      2|                let self_inner = self.inner.lock().unwrap();
  203|      6|                let self_inner = self.inner.lock().unwrap();
  311|      4|            while !Self::is_prime(candidate) {
   66|     22|            while !Self::is_prime(candidate) {
   78|      7|            if !Self::is_prime(table_size) {
   87|      7|            if Self::is_prime(table_size) && Self::gcd(c2, table_size) != 1 {
  114|      2|            if !self.is_reachable(u, v) {
  116|      2|            if !self.is_reachable(u, v) {
  116|      2|            if !self.is_reachable(u, v) {
  118|      2|            if !self.is_reachable(u, v) {
  101|      5|            if !self.is_reachable(v) {
  103|      2|            if !self.is_reachable(v) {
  108|      2|            if !self.is_reachable(v) {
  111|      2|            if !self.is_reachable(v) {
  143|    619|            if Self::is_red(&link.as_ref().unwrap().left)
  148|    619|            if Self::is_red(&link.as_ref().unwrap().left) && Self::is_red(&link.as_ref().unwrap().right) {
  144|    426|                && Self::is_red(&link.as_ref().unwrap().left.as_ref().unwrap().left)
  140|    619|            if Self::is_red(&link.as_ref().unwrap().right) && !Self::is_red(&link.as_ref().unwrap().left) {
  100|    122|                key_equality: self.key_equality.clone(),
  168|      1|                key_equality: self.key_equality.clone(),
  245|    129|                key_equality: self.key_equality.clone(),
  123|    113|                if self.key_equality.eq(&pair.0, key) {
  142|      2|                if !self.key_equality.eq(&pair.0, key) {
  213|     30|                if !self.key_equality.eq(&pair.0, &key) {
   66|     70|                if !self.key_equality.eq(&pair.0, &key) {
  237|      1|            let self_keys = self.keys.lock().unwrap();
  103|    114|                    .map(|k| self.keys[i + k].prob)
   66|     87|                    .map(|k| self.keys[i + k].prob)
   78|    381|                    .map(|k| self.keys[i + k].prob)
  116|     13|            if self.keys.is_empty() {
  128|     23|            if self.keys.is_empty() {
  163|     10|            if self.keys.is_empty() {
  137|       |                self.vertices, self.labeled_arcs
  227|       |                self.vertices, self.labeled_arcs
  169|       |                self.vertices, self.labeled_edges
  219|       |                self.vertices, self.labeled_edges
  162|     13|                && self.leftist_heap_result == *expected
  162|      2|            if self.len != other.len {
  209|     15|            if self.len != other.len {
  382|      2|            if self.len() != other.len() {
   93|    118|            let self_len = self.elements.length();
  145|      5|            if self.length() <= 1usize {
  146|      5|            if self.length() <= 1usize {
  212|      6|            if self.length() != other.length() {
  247|      0|            if self.length() != other.length() {
  254|      2|            if self.length() != other.length() {
  341|      4|            if self.length() != other.length() {
   55|      8|            if self.length() <= 1usize {
   57|      7|            if self.length() <= 1usize {
   94|      6|            if self.length() <= 1usize {
   95|      7|            if self.length() <= 1usize {
  386|       |                self.table_size, self.load_factor
  102|    122|                load_factor_manager: self.load_factor_manager.clone(),
  144|    272|                load_factor_manager: self.load_factor_manager.clone(),
  163|      0|                load_factor_manager: self.load_factor_manager.clone(),
  170|      1|                load_factor_manager: self.load_factor_manager.clone(),
  219|     17|                                load_factor_manager: self.load_factor_manager.clone(),
  244|      0|                load_factor_manager: self.load_factor_manager.clone(),
  247|    129|                load_factor_manager: self.load_factor_manager.clone(),
  318|    157|                load_factor_manager: self.load_factor_manager.clone(),
   89|      2|                load_factor_manager: self.load_factor_manager.clone(),
   76|    295|            if self.load_factor_manager.should_grow(total_occupied + 1, table_size) {
  228|      1|            let self_memo = self.memo_table.lock().unwrap();
  236|      1|            let self_memo = self.memo_table.lock().unwrap();
  103|      5|                n: self.n,
  105|      5|                n: self.n,
  129|      1|                n: self.n,
  137|     11|                n: self.n,
  159|      1|                n: self.n,
   81|      5|                n: self.n,
   83|      5|                n: self.n,
  105|    907|                if Self::needs_rebuild(node) {
  147|    231|                if Self::needs_rebuild(node) {
  359|    233|                next_key: self.next_key,
   52|     19|            match self.node_at_mut(index) {
  121|     16|                if self.nth(i) == target {
  162|      2|                if self.nth(i) == target {
  216|     25|                if self.nth(i) != other.nth(i) {
  251|      0|                if self.nth(i) != other.nth(i) {
  258|      6|                if self.nth(i) != other.nth(i) {
  345|     10|                if self.nth(i) != other.nth(i) {
  218|     17|                                num_deleted: self.num_deleted + 1,
  332|      8|            (self.num_elements, self.num_deleted, load_factor)
  162|      0|                num_elements: self.num_elements - 1,
  169|      1|                num_elements: self.num_elements - 1,
  217|     17|                                num_elements: self.num_elements - 1,
  106|     82|            if self.pairs.mem(&Pair(a.clone(), b.clone())) == true {
  174|      0|            if !self.parent.contains_key(&v) {
   67|    169|            if !self.parent.contains_key(&v) {
   76|      5|                predecessors: self.predecessors,
   79|      5|                predecessors: self.predecessors,
   80|      5|                predecessors: self.predecessors,
   82|      5|                predecessors: self.predecessors,
  199|      2|            if !self.prime_validation_enabled {
  244|      4|            if !self.prime_validation_enabled {
  254|      3|            if !self.prime_validation_enabled {
  287|       |                self.clustering_enabled, self.prime_validation_enabled
  141|    272|                probe_sequence: self.probe_sequence.clone(),
  216|     17|                                probe_sequence: self.probe_sequence.clone(),
  315|    157|                probe_sequence: self.probe_sequence.clone(),
  372|      9|                range: self.range.clone(),
  330|      8|            Self::calculate_reduction(&self.base_table, &self.reducer, &self.identity)
  365|     20|            Self::calculate_reduction(base, &self.reducer, &self.identity)
  369|     10|            Self::calculate_reduction(&self.base_table, &self.reducer, &self.identity)
  119|    172|                reducer: self.reducer.clone(),
  134|      2|                reducer: self.reducer.clone(),
  161|      1|                reducer: self.reducer.clone(),
  163|      1|                reducer: self.reducer.clone(),
  172|      1|                reducer: self.reducer.clone(),
  174|      1|                reducer: self.reducer.clone(),
  176|      1|                reducer: self.reducer.clone(),
  185|      1|                reducer: self.reducer.clone(),
  189|      1|                reducer: self.reducer.clone(),
  202|      1|                reducer: self.reducer.clone(),
  215|      1|                reducer: self.reducer.clone(),
  228|      1|                reducer: self.reducer.clone(),
  237|      1|                reducer: self.reducer.clone(),
  241|      1|                reducer: self.reducer.clone(),
  244|      1|                reducer: self.reducer.clone(),
  250|      1|                reducer: self.reducer.clone(),
  257|      1|                reducer: self.reducer.clone(),
  271|      1|                reducer: self.reducer.clone(),
  277|      8|                reducer: self.reducer.clone(),
  278|      1|                reducer: self.reducer.clone(),
  290|     23|                reducer: self.reducer.clone(),
  298|      1|                reducer: self.reducer.clone(),
  305|      1|                reducer: self.reducer.clone(),
  311|      1|                reducer: self.reducer.clone(),
  312|      7|                reducer: self.reducer.clone(),
  318|      1|                reducer: self.reducer.clone(),
  333|      1|                reducer: self.reducer.clone(),
  340|      1|                reducer: self.reducer.clone(),
   78|     23|                return self.resize(new_size).insert(key, value);
  152|     11|            set_link(&mut self.root, index, item)?;
  199|    328|            Self::insert_link(&mut self.root, value, &mut r);
  210|      5|            set_link(&mut self.root, index, item)?;
  227|     22|            match &self.root {
  242|    175|            Self::insert_link(&mut self.root, value);
  243|    115|            match &self.root {
  254|  1.05k|            Self::insert_link(&mut self.root, value, &mut r);
  303|    202|            Self::insert_link(&mut self.root, key, value, &mut r);
   88|    231|                Self::rebalance_if_needed(&mut self.root, total);
  249|      1|                current: self.root.as_deref(),
  211|    642|                root: self.root.clone(),
  228|  5.81k|                root: self.root.clone(),
  358|    233|                root: self.root.clone(),
  137|      2|                let self_seq = self_inner.to_seq();
  206|      6|                let self_seq = self_inner.to_seq();
  139|      1|                seq_s: self.seq_s,
  169|      0|                seq_s: self.seq_s,
  219|      1|                seq_s: self.seq_s,
   98|      1|                seq_s: self.seq_s,
  140|      1|                seq_t: self.seq_t,
  170|      0|                seq_t: self.seq_t,
  220|      1|                seq_t: self.seq_t,
   99|      1|                seq_t: self.seq_t,
  152|     12|            if self.size() == 0 {
  157|      5|            if self.size() == 0 {
  377|      1|                .field("size", &self.size())
  410|      1|                .field("size", &self.size())
  412|      1|                .field("size", &self.size())
  160|     13|                && self.sorted_list_result == *expected
  101|      5|                source: self.source,
   77|      5|                source: self.source,
   80|      5|                source: self.source,
   98|      5|                source: self.source,
  325|      5|            HashTableStats::new(self.num_elements, self.table.length()).with_collision_stats(self.num_deleted, 0, 0.0)
  161|       |                self.source, self.target, memo_size
  200|       |                self.source, self.target, memo_size
   43|   106k|            while self.turn.load(Ordering::Acquire) != my_ticket {
  222|       |                self.sequence_length, self.unique_positions, self.period
  114|      1|                universe_size: self.universe_size,
  126|      1|                universe_size: self.universe_size,
  138|      1|                universe_size: self.universe_size,
  150|      1|                universe_size: self.universe_size,
  133|      1|                .field("V", &self.V)
  154|      0|                .field("V", &self.V)
  218|      1|                .field("V", &self.V)
  345|      0|                .field("V", &self.V)
  133|      2|            let (self_vals, other_vals) = {
  202|      6|            let (self_vals, other_vals) = {
  246|      1|                values: self.values_in_order(),
  121|      1|                vertices: self.vertices.clone(),
  123|      1|                vertices: self.vertices.clone(),
   88|      2|                vertices: self.vertices.insert(v),
   90|     14|                vertices: self.vertices.insert(v),
  117|      9|            if self.vertices().size() == 0 {
   80|      9|            if self.vertices().size() == 0 {
  249|      0|                .field("word_count", &self.word_count())
  250|      0|                .field("word_to_docs", &self.word_to_docs)
  137|     82|            match self.word_to_docs.find(word) {
  122|      9|            T: Send + Sync + 'static,
  124|       |            T: Send + 'static;
  138|     16|            T: Send + Sync + 'static,
  159|       |            T: Send + 'static;
  161|     10|            T: Send + Sync + 'static,
  173|      9|            T: Send + Sync + 'static,
  182|      6|            R: Send + Sync + 'static,
  208|  3.99k|            T: Send + 'static,
  332|  3.99k|            T: Send + 'static,
   35|       |            T: Send + Sync + 'static;
   36|       |            T: Send + Sync + 'static;
   42|       |            T: Send + Sync + 'static;
   42|       |            T: Send + Sync + 'static;
   53|    179|            T: Send + Sync + 'static,
   69|    230|            T: Send + Sync + 'static,
   88|    237|            T: Send + Sync + 'static,
   97|    366|            T: Send + Sync + 'static,
    3|       |//! Uses separate chaining for collision resolution.
    4|       |pub mod SeparateChaining {
  323|      1|        let sep_chain = example_47_2_separate_chaining();
  103|      1|            let seq = domain.to_seq();
  103|      7|        let seq = right_set.to_seq();
  111|      1|            let seq = domain.to_seq();
  127|     11|        let seq = DocumentIndex::to_seq(docs);
  132|      7|        let seq = left_split.to_seq();
  135|      2|        let seq = ArraySeqStEphSLit![1, 3, 2, 3, 1, 4, 2];
  142|      7|        let seq = right_split.to_seq();
  155|     10|                let seq = self.to_seq();
  155|      7|        let seq = joined_set.to_seq();
  160|      3|                let seq = self.to_seq();
  166|     10|                let seq = self.to_seq();
  171|      3|                let seq = self.to_seq();
  173|     14|            let seq = self.to_seq();
  175|      0|        let seq = int_set.to_seq();
  178|      7|            let seq = self.to_seq();
  187|     22|            let seq = self.to_seq();
  192|      8|            let seq = self.to_seq();
  194|      0|        let seq = range.to_seq();
  201|      9|            let seq = self.to_seq();
  205|      0|        let seq = left.to_seq();
  206|      2|            let seq = self.to_seq();
  213|      0|        let seq = right.to_seq();
  223|      9|            let seq = self.to_seq();
  231|      2|            let seq = self.to_seq();
  238|     20|            let seq = self.to_seq();
  246|      6|            let seq = self.to_seq();
  255|     13|            let seq = self.to_seq();
  263|      6|            let seq = self.to_seq();
  264|      0|            let seq = self.to_seq();
  265|     10|            let seq = self.to_seq();
  273|      1|            let seq = self.to_seq();
  275|      7|            for seq in sequences {
  278|      0|            let seq = self.to_seq();
  290|      8|        let seq = AVLTreeSeqStPerS::from_vec(elements);
  312|      1|        let seq = AVLTreeSeqStPerS::from_vec(elements);
   31|      2|                let seq = frontier.to_seq();
   36|      2|                let seq = frontier.to_seq();
  371|       |            let seq = $crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::AVLTreeSeqStPerS::from_vec(pairs);
   37|      7|        let seq = set_a.to_seq();
  387|       |            let seq = $crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::AVLTreeSeqStPerS::from_vec(pairs);
   40|      3|                let seq = frontier.to_seq();
  416|       |            let seq = $crate::Chap37::AVLTreeSeqStPer::AVLTreeSeqStPer::AVLTreeSeqStPerS::from_vec(pairs);
   59|      7|            let seq = domain.to_seq();
   60|     13|                let seq = domain.to_seq();
   67|      7|        let seq = range_set.to_seq();
   71|      3|            let seq = filtered.to_seq();
   72|      5|            let seq = domain_set.to_seq();
   73|      1|            let seq = domain.to_seq();
   74|      3|            let seq = filtered.to_seq();
   76|      3|            let seq = filtered.to_seq();
   77|     47|                    let seq = frontier.to_seq();
   84|     47|                    let seq = frontier.to_seq();
   85|     23|                    let seq = frontier.to_seq();
   85|      3|                let seq = inner.to_seq();
   87|      1|                let seq = self.edges.to_seq();
   94|      7|        let seq = left_set.to_seq();
   95|     23|                    let seq = frontier.to_seq();
  158|      0|                return seq.clone();
    5|       |//! Uses Seq.inject for efficient parallel updates.
  266|      3|            if seq.is_empty() {
   76|    586|            let seq_len = seq.length();
   78|    134|            let seq_len = seq.length();
  157|      7|            if seq.length() <= 1 {
   63|     34|            if seq.length() == 0 {
   71|    588|            if seq.length() == 0 {
   73|    135|            if seq.length() == 0 {
  108|     28|            print!("\"{}\"", seq.nth(i));
  137|     21|            print!("\"{}\"", seq.nth(i));
  147|     21|            print!("\"{}\"", seq.nth(i));
  160|     42|            print!("\"{}\"", seq.nth(i));
  180|      0|            print!("{}", seq.nth(i));
  199|      0|            print!("{}", seq.nth(i));
  210|      0|            print!("{}", seq.nth(i));
  218|      0|            print!("{}", seq.nth(i));
   42|     49|            print!("\"{}\"", seq.nth(i));
   72|     21|            print!("\"{}\"", seq.nth(i));
   99|     21|            print!("\"{}\"", seq.nth(i));
  112|      2|        let seq_result = set_to_seq.to_seq();
   62|      2|        let seq_result = set_to_seq.to_seq();
  101|     21|                    let seq_s_clone = self.seq_s.clone();
  101|     21|                    let seq_s_clone = self.seq_s.clone();
  102|     21|                    let seq_t_clone = self.seq_t.clone();
  102|     21|                    let seq_t_clone = self.seq_t.clone();
  291|      1|4. probe sequence Validation:
   37|       |    /// Sequence trait for the slice-backed MT ephemeral array.
    3|       |//! Mathematical sequence backed by a growable vector. Dense domain 0..len-1.
  182|  1.20k|                if sequence[i] == (sequence[i - 1] + 1) % sequence.len() {
  174|     90|            if sequence.len() <= 1 {
  198|  3.28k|                    if sequence.len() > 10 {
  128|     32|            let sequence_length = probe_sequence.len();
  141|      0|            let sequence_length = self.data.len();
  150|      1|            let sequence_length = self.data.len();
  157|     27|            let sequence_length = probe_sequence.len();
   22|       |        pub sequence_length: N,
   89|     31|            let sequence_length = probe_sequence.len();
  124|    180|            let sequences = <ArraySeqStPerS<ArraySeqStPerS<T>> as ArraySeqStPerTrait<ArraySeqStPerS<T>>>::tabulate(
  144|    107|            let sequences = <ArraySeqMtPerS<ArraySeqMtPerS<T>> as ArraySeqMtPerTrait<ArraySeqMtPerS<T>>>::tabulate(
  243|      1|            let sequences = vec![a.clone(), b.clone()];
  397|      8|                let sequences = analyzer.compare_probing_strategies(test_key, table_size);
  398|      8|                (lf, sequences)
    5|       |//! specification: sequences may be exposed as `Zero`, `One`, or `Two` parts, and the
  263|      2|            if sequences.is_empty() {
  135|     13|            input: sequence.to_vec(),
  108|       |            // Sequential implementation to maintain APAS algorithmic fidelity with closures
  129|       |        // Sequential version: fromseq a = Seq.iterate Set.insert ∅ a
  146|       |            // Sequential implementation for now - parallel mapping would require more complex logic
  165|       |            // Sequential implementation for now - parallel filtering would require more complex logic
  184|       |            // Sequential implementation for now - parallel reduction would require more complex logic
   18|       |        /// Sequential spanning tree via star contraction
   19|       |        /// Sequential star contraction higher-order function
   19|       |        /// Sequential star partition using greedy selection
   20|       |        /// Sequential edge contraction algorithm
   22|       |        /// Sequential version of parallel matching
   24|       |    /// Sequential Star Partition using greedy selection
  291|       |            // Sequential merge (sorted sequences)
  318|       |            // Sequential merge (sorted sequences)
  362|       |            // Sequential merge (sorted sequences)
    4|       |//! Implements sequential star partition using greedy vertex selection.
    5|       |//! - Sequential operations (Rc backing prevents true parallelism)
   21|       |        fn sequential_star_partition<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> Set<Set<V>>;
  117|      2|        let seq_with_dups = AVLTreeSeqStEphLit![2, 7, 2, 8, 11, 2];
   67|      2|        let seq_with_dups = ArraySeqStEphSLit![2, 7, 2, 8, 11, 2];
  166|       |            // Serial compaction: collect all Some values
  189|       |            // Serial compaction phase: count kept values
  226|       |            // Serial compaction phase: collect kept values
  102|       |        /// Set method for ephemeral sequences (alias for update)
  174|      2|        let set1 = ArraySetStEphLit![1, 2, 3, 4, 5];
  125|      1|        println!("\n--- Set Operations ---");
  306|      2|            let set1 = self.find(word1);
   48|      2|        let set1 = ArraySetStEphLit![2, 7, 8, 11];
  174|      0|        print!("Integer Set: [");
   98|      2|        let set1 = AVLTreeSetStEphLit![2, 7, 8, 11];
  217|       |            $( __set = __set.insert($x); )*
  175|      2|        let set2 = ArraySetStEphLit![4, 5, 6, 7, 8];
  307|      2|            let set2 = self.find(word2);
   49|      2|        let set2 = ArraySetStEphLit![7, 9, 11, 14, 17];
   24|       |        /// Set the element at `index` to `item` in place. <br/>
  278|       |    /// Set equivalence comparison for sequences (order-independent, useful for MT tests)
   99|      2|        let set2 = AVLTreeSetStEphLit![7, 9, 11, 14, 17];
  312|       |            $( __set = __set.insert($x); )*
  308|      2|            let set3 = self.find(word3);
   41|       |        /// Set element at index (ephemeral mutation)
  309|      2|            let set4 = self.find(word4);
   43|       |        /// Set element at index (ephemeral mutation)
   44|       |        /// Set matrix dimension at index
   45|       |        /// Set matrix dimension at index
   46|       |        /// Set element in source sequence
   47|       |        /// Set key-probability pair at index
   47|       |        /// Set key-probability pair at index
   48|       |        /// Set operations (union, difference, filter) use parallel implementations.
   49|       |        /// Set element in target sequence
   50|       |        /// Set element in source sequence
   53|       |        /// Set element in target sequence
   57|       |        /// Set operations use thread-safe structures.
   65|       |            // Set base cases: empty string transformations
   65|       |            // Set base cases: empty string transformations
   66|       |        /// Set the in-order `index`-th element to `item`.
   68|       |            // Set base cases: empty string transformations
   68|       |            // Set base cases: empty string transformations
    6|       |//! parallel set operations, but the priority selection itself remains sequential.
   85|  2.25k|            for set in singleton_sets {
   87|  10.8k|            for set in singleton_sets {
   26|      7|        let set_a: OrderedSetStPer<String> = OrderedSetStPerLit![
   30|      2|        let set_abc = ArraySetStEphLit!['a', 'b', 'c'];
   80|      2|        let set_abc = AVLTreeSetStEphLit!['a', 'b', 'c'];
   47|      7|        match set_a.first() {
  117|      7|        match set_a.last() {
   59|      7|        match set_a.next(&"mike".to_string()) {
   53|      7|        match set_a.next(&"quinn".to_string()) {
  123|      7|        match set_a.previous(&"rachel".to_string()) {
   85|      7|        match set_a.select(5) {
  147|      2|        fn set_dimension(&mut self, index: usize, dim: MatrixDim) {
  192|      1|        fn set_dimension(&mut self, index: usize, dim: MatrixDim) {
   45|       |        fn set_dimension(&mut self, index: usize, dim: MatrixDim);
   46|       |        fn set_dimension(&mut self, index: usize, dim: MatrixDim);
  104|     23|        fn set_edge(&mut self, u: N, v: N, exists: B) {
   31|       |        fn set_edge(&mut self, u: N, v: N, exists: B);
   32|       |        fn set_edge(&mut self, u: N, v: N, exists: B);
   83|     12|        fn set_edge(&mut self, u: N, v: N, exists: B) {
  112|     11|        fn set_edge(&self, u: N, v: N, exists: B) -> Self {
   32|       |        fn set_edge(&self, u: N, v: N, exists: B) -> Self;
   16|       |        A: Set<Edge<V>>,
   16|       |        E: Set<Edge<V>>,
  179|       |                      _e: &Set<Edge<V>>,
   19|       |        A: Set<Edge<V>>,
   19|       |        E: Set<Edge<V>>,
  238|       |                      _e: &Set<Edge<V>>,
   24|       |            matching: &Set<Edge<V>>,
   25|       |            matching: &Set<Edge<V>>,
   49|      3|        matching: &Set<Edge<V>>,
   51|       |                      _e: &Set<Edge<V>>,
   54|      0|                      quotient_edges: Set<Edge<V>>| {
   54|       |                      original_edges: &Set<Edge<V>>,
   57|      6|                      quotient_tree: Set<Edge<V>>| {
   58|      3|        matching: &Set<Edge<V>>,
  102|      0|                    return Set::empty();
  133|      0|                    return Set::empty();
  133|      0|                    return Set::empty();
  143|      0|                    return Set::empty();
  146|      0|                    return Set::empty();
  158|      0|                    return Set::empty();
  185|      0|                    return Set::empty();
   58|     15|                vertices: Set::empty(),
   58|     45|                vertices: Set::empty(),
   59|     15|                labeled_arcs: Set::empty(),
   59|     45|                labeled_edges: Set::empty(),
   64|     10|                vertices: Set::empty(),
   64|     13|                vertices: Set::empty(),
   65|     10|                labeled_arcs: Set::empty(),
   65|     13|                labeled_edges: Set::empty(),
   81|      0|                    return Set::empty();
   83|      0|                    return Set::empty();
   88|      0|                    return Set::empty();
   90|      0|                    return Set::empty();
   95|      0|                    return Set::empty();
  118|      2|        let set_from_seq = AVLTreeSetStEph::from_seq(seq_with_dups);
   68|      2|        let set_from_seq = ArraySetStEph::from_seq(seq_with_dups);
  156|       |            $( __set.insert($x); )*
  177|       |            $( __set.insert($x); )*
  222|       |            $( __set.insert($x); )*
  274|       |            $( __set.insert($x); )*
  274|       |            $( __set.insert($x); )*
  274|       |            $( __set.insert($x); )*
  274|       |            $( __set.insert($x); )*
  274|       |            $( __set.insert($x); )*
  296|       |            $( __set.insert($x); )*
  357|       |            $( __set.insert($x); )*
  143|      1|        fn set_key_prob(&mut self, index: usize, key_prob: KeyProb<T>) {
  198|      1|        fn set_key_prob(&mut self, index: usize, key_prob: KeyProb<T>) {
   48|       |        fn set_key_prob(&mut self, index: usize, key_prob: KeyProb<T>);
   48|       |        fn set_key_prob(&mut self, index: usize, key_prob: KeyProb<T>);
   16|       |        labeled_arcs: Set<LabEdge<V, L>>,
   16|       |        labeled_edges: Set<LabEdge<V, L>>,
  209|      1|        spanning_tree: &Set<LabEdge<V, OrderedFloat<f64>>>,
   20|       |        labeled_arcs: Set<LabEdge<V, L>>,
   20|       |        labeled_edges: Set<LabEdge<V, L>>,
  235|      1|        spanning_tree: &Set<LabEdge<V, OrderedFloat<f64>>>,
   33|       |            mst: &Set<LabEdge<V, OrderedFloat<f64>>>,
   60|      2|        tree_edges: &Set<LabEdge<V, OrderedFloat<f64>>>,
   65|      2|        tree_edges: &Set<LabEdge<V, OrderedFloat<f64>>>,
   75|      6|        tree_edges: &Set<LabEdge<V, OrderedFloat<f64>>>,
   80|      6|        tree_edges: &Set<LabEdge<V, OrderedFloat<f64>>>,
  165|     33|        edges: &Set<LabeledEdge<V>>,
  225|      8|        edges: &Set<LabeledEdge<V>>,
   25|       |            edges: &Set<LabeledEdge<V>>,
  326|      9|        edges: &Set<LabeledEdge<V>>,
   38|       |            edges: &Set<LabeledEdge<V>>,
   44|       |            edges: &Set<LabeledEdge<V>>,
   62|     25|        edges: &Set<LabeledEdge<V>>,
  307|     35|    fn set_link<T: StT>(node: &mut Link<T>, index: N, value: T) -> Result<(), &'static str> {
  420|      7|    fn set_link<T: Copy + Debug>(node: &mut Link<T>, index: N, value: T) -> Result<(), &'static str> {
  103|      0|                    return SetLit![];
  105|      0|            return SetLit![];
  114|      0|            return SetLit![];
  115|      0|            return SetLit![];
  116|    104|                    return SetLit![];
  121|      0|                    return SetLit![];
  134|     27|            return SetLit![];
  134|      6|                return SetLit![];
  144|      0|            return SetLit![];
  159|      0|                    return SetLit![];
  163|     25|            return SetLit![];
  164|      0|                    return SetLit![];
  214|      0|                    return SetLit![];
  266|      0|                    return SetLit![];
  267|       |    macro_rules! SetLit {
  311|      0|                    return SetLit![];
   57|      0|            return SetLit![];
   58|      3|                V: SetLit![],
   59|      3|                E: SetLit![],
   61|      4|                V: SetLit![],
   62|      4|                E: SetLit![],
   76|      2|                V: SetLit![],
   77|      2|                A: SetLit![],
   79|      4|                V: SetLit![],
   80|      4|                A: SetLit![],
  132|     40|                return SetLit![new_edge];
  161|     36|                return SetLit![new_edge];
  101|       |        fn set(&mut self, index: N, item: T) -> Result<&mut ArraySeqMtEphS<T>, &'static str>;
  116|      2|        fn set(&mut self, index: N, item: T) -> Result<&mut ArraySeqS<T>, &'static str> {
  117|       |        fn set(&mut self, index: N, item: T) -> Result<&mut ArraySeqStEphS<T>, &'static str>;
  122|      3|        fn set(&mut self, index: usize, value: T) {
  144|      1|        fn set(&mut self, index: usize, value: T) {
  151|     11|        fn set(&mut self, index: N, item: T) -> Result<&mut Self, &'static str> {
  164|      6|        fn set(&mut self, index: N, value: T) -> Result<&mut Self, &'static str> {
  180|      1|        fn set(&mut self, index: N, item: T) -> Result<&mut ArraySeqStEphS<T>, &'static str> {
  183|      0|        fn set(&mut self, index: N, item: T) -> Result<&mut ArraySeqMtEphS<T>, &'static str> {
  187|      2|        fn set(&mut self, index: N, item: T) -> Result<&mut ArraySeqS<T>, &'static str> {
  188|       |        fn set(&mut self, index: N, item: T) -> Result<&mut Self, &'static str>;
  209|      5|        fn set(&mut self, index: N, item: T) -> Result<&mut AVLTreeS<T>, &'static str> {
  259|      0|        fn set(&mut self, index: N, item: T) -> Result<&mut Self, &'static str> {
   26|       |        fn set(&mut self, index: N, item: T) -> Result<&mut ArraySeqS<T>, &'static str>;
   30|       |        fn set(&mut self, index: N, value: T) -> Result<&mut Self, &'static str>;
   42|       |        fn set(&mut self, index: usize, value: T);
   44|       |        fn set(&mut self, index: usize, value: T);
   54|       |        fn set(&mut self, index: N, item: T) -> Result<&mut Self, &'static str>;
   68|       |        fn set(&mut self, index: N, item: T) -> Result<&mut AVLTreeS<T>, &'static str>;
   30|       |        fn set_neighbors(&mut self, v: N, neighbors: ArraySeqStEphS<N>);
   77|      0|        fn set_neighbors(&mut self, v: N, neighbors: ArraySeqStEphS<N>) {
   34|      2|        let set_nums = ArraySetStEphLit![4, 11, 2, 6];
   84|      2|        let set_nums = AVLTreeSetStEphLit![4, 11, 2, 6];
   16|       |        pairs: Set<Pair<A, B>>,
  173|      8|                root: set_rec(&self.root, index, item)?,
  174|     28|                root: set_rec(&self.root, index, item)?,
   89|     14|    fn set_rec<T: StTInMtT>(cur: &Link<T>, index: N, value: T) -> Result<Link<T>, &'static str> {
   89|     67|    fn set_rec<T: StT>(cur: &Link<T>, index: N, value: T) -> Result<Link<T>, &'static str> {
  136|      2|        let set_result = ArraySetStEph::from_seq(seq);
   69|       |        /// Sets the distance from source to vertex v, returning a new structure.
   72|       |        /// Sets the distance from source to vertex v.
   72|       |        /// Sets the distance from source to vertex v, returning a new structure.
   72|       |        /// Sets the distance from vertex u to vertex v, returning a new structure.
   74|       |        /// Sets the distance from source to vertex v.
   74|       |        /// Sets the distance from vertex u to vertex v, returning a new structure.
   78|       |        /// Sets the distance from vertex u to vertex v.
   80|       |        /// Sets the distance from vertex u to vertex v.
   88|       |        /// Sets the predecessor of vertex v in the shortest path from source.
   90|       |        /// Sets the predecessor of vertex v in the shortest path from source.
   90|       |        /// Sets the predecessor of vertex v, returning a new structure.
   93|       |        /// Sets the predecessor of vertex v, returning a new structure.
   94|       |        /// Sets the predecessor of vertex v in the shortest path from u, returning a new structure.
   96|       |        /// Sets the predecessor of vertex v in the shortest path from u.
   96|       |        /// Sets the predecessor of vertex v in the shortest path from u, returning a new structure.
   98|       |        /// Sets the predecessor of vertex v in the shortest path from u.
   43|      2|        let set_search = ArraySetStEphLit![6, 2, 9, 11, 8];
   93|      2|        let set_search = AVLTreeSetStEphLit![6, 2, 9, 11, 8];
  134|       |        fn set(&self, index: N, item: T) -> Result<ArraySeqMtPerS<T>, &'static str>;
  149|       |        fn set(&self, index: N, item: T) -> Result<Self, &'static str>
  150|       |        fn set(&self, index: N, item: T) -> Result<Self, &'static str>
  171|      8|        fn set(&self, index: N, item: T) -> Result<Self, &'static str> {
  172|     28|        fn set(&self, index: N, item: T) -> Result<Self, &'static str> {
  197|    437|        fn set(&self, index: N, item: T) -> Result<ArraySeqMtPerS<T>, &'static str> {
   64|      1|            let set_size = self.size();
  133|      3|        fn set_source(&mut self, index: usize, value: T) {
  160|      2|        fn set_source(&mut self, index: usize, value: T) {
   47|       |        fn set_source(&mut self, index: usize, value: T);
   51|       |        fn set_source(&mut self, index: usize, value: T);
    4|       |pub mod SetStEph {
  139|      3|        fn set_target(&mut self, index: usize, value: T) {
  167|      1|        fn set_target(&mut self, index: usize, value: T) {
   50|       |        fn set_target(&mut self, index: usize, value: T);
   54|       |        fn set_target(&mut self, index: usize, value: T);
  111|      2|        let set_to_seq = AVLTreeSetStEphLit![2, 7, 8, 11];
   61|      2|        let set_to_seq = ArraySetStEphLit![2, 7, 8, 11];
  166|     33|        mst_labels: Set<usize>,
  231|     29|        mst_labels: Set<usize>,
  113|     25|        vertices: &Set<V>,
   15|       |        vertices: Set<V>,
   15|       |        vertices: Set<V>,
   15|       |        V: Set<V>,
   15|       |        V: Set<V>,
  164|     33|        vertices: &Set<V>,
  180|       |                      _centers: &Set<V>,
   18|       |        V: Set<V>,
   18|       |        V: Set<V>,
   19|       |        vertices: Set<V>,
   19|       |        vertices: Set<V>,
  224|      8|        vertices: &Set<V>,
  239|       |                      _centers: &Set<V>,
   27|       |            vertices: &Set<V>,
   28|       |            bridges: &Set<(V, LabeledEdge<V>)>,
   31|       |            vertices: &Set<V>,
  325|      9|        vertices: &Set<V>,
   32|       |            bridges: &Set<(V, LabeledEdge<V>)>,
   41|       |            vertices: &Set<V>,
   43|       |            vertices: &Set<V>,
   52|       |                      _centers: &Set<V>,
   55|       |                      _centers: &Set<V>,
   81|     14|        centers: &Set<V>,
   86|     22|        centers: &Set<V>,
  324|     51|            let severity = if clustering_score < 50.0 {
  348|     51|                clustering_severity: severity,
   31|       |    /// Shared slice view over the mutex-protected backing buffer.
   84|      1|        let shared = Arc::new(AtomicUsize::new(0));
   89|      4|            let shared_clone = Arc::clone(&shared);
  116|       |    /// Shortcut Tour (Parallel version)
  125|       |    /// Shortcut Tour
   28|       |        /// Shortcut Euler tour to avoid revisiting vertices
    6|       |//! - Shortcut to avoid revisiting vertices
   28|       |        fn shortcut_tour_mt<V: StT + MtT + Hash + Ord>(euler_tour: &[V]) -> std::vec::Vec<V>;
   30|       |        fn shortcut_tour<V: StT + Hash + Ord>(euler_tour: &[V]) -> std::vec::Vec<V>;
    3|       |//! All-Pairs Shortest Path Result Structure - Sequential Ephemeral (Float Weights)
    3|       |//! All-Pairs Shortest Path Result Structure - Sequential Ephemeral (Integer Weights)
    3|       |//! All-Pairs Shortest Path Result Structure - Sequential Persistent (Float Weights)
    3|       |//! All-Pairs Shortest Path Result Structure - Sequential Persistent (Integer Weights)
    3|       |//! Single-Source Shortest Path Result Structure - Sequential Ephemeral (Float Weights)
    3|       |//! Single-Source Shortest Path Result Structure - Sequential Ephemeral (Integer Weights)
    3|       |//! Single-Source Shortest Path Result Structure - Sequential Persistent (Float Weights)
    3|       |//! Single-Source Shortest Path Result Structure - Sequential Persistent (Integer Weights)
    5|       |//! All-Pairs Shortest Paths for graphs with negative weights (but no negative cycles).
    5|       |//! All-Pairs Shortest Paths for graphs with negative weights (but no negative cycles).
    5|       |//! All-Pairs Shortest Paths for graphs with negative weights (but no negative cycles).
    5|       |//! All-Pairs Shortest Paths for graphs with negative weights (but no negative cycles).
   67|      1|        println!("  Shortest path from 0 to 1 is undefined (can traverse cycle repeatedly)");
   68|      1|        println!("  Shortest path from 0 to 3 through 1 is also undefined");
  113|       |        // Should not reach here, but handle it
  122|       |        // Should not reach here, but handle it
  138|       |        // Should contain unique elements: {1, 2, 3, 4}
   14|       |        /// should be O(n) work and O(log n) span. We can then determine the overall asymptotic
  148|     38|            if should_select_edge(&graph, edge, &edge_coins) {
  180|     38|    fn should_select_edge<V: StT + MtT + Hash + 'static>(
  199|       |    /// Show index statistics for the tweet collection
  250|       |    /// Shows primary clustering with keys that hash to consecutive positions
  284|       |    /// Shows how quadratic probing avoids primary clustering but may have secondary clustering
  309|      2|            description: "Shows quadratic probing behavior with prime table size m=17".to_string(),
  386|       |    /// Shows how probe sequences change with different load factors
  461|       |    /// Shows how clustering changes with different load factors
   52|       |    /// Shows heapsort performance on worst-case input for some algorithms
   59|       |    /// Shows heapsort performance on best-case input for some algorithms
   66|       |    /// Shows heapsort performance on input with repeated elements
   73|       |    /// Shows heapsort performance on minimal input
   80|       |    /// Shows heapsort performance on empty input
   87|       |    /// Shows the efficiency differences between priority queue implementations
   94|       |    /// Shows all heapsort variants and their comparative performance
  376|      2|            description: "Side-by-side comparison of all three probing strategies".to_string(),
   67|       |    /// Similar to Dijkstra's, but priority is minimum edge weight to visited set X.
  104|       |            // Simple modulo hash - implementers can provide better hash function
  112|       |            // Simple sequential implementation for correctness
  121|       |            // Simple connectivity check using DFS from first vertex
  122|       |            // Simple sequential implementation for correctness
  207|       |        // Simple tokenization: split on whitespace and punctuation
  223|       |            // Simple merge (sequential to avoid thread explosion)
   26|       |    /// Simple wrapper for closure-based priority functions.
   26|       |    /// Simple wrapper for closure-based priority functions.
   40|       |    /// Simple hash function using Rust's built-in hasher
   69|       |            // Simple modulo hash - implementers can provide better hash function
   79|       |            // Simple modulo hash - implementers can provide better hash function
   84|       |            // Simple connectivity check using DFS from first vertex
   36|      1|        let simple_path = ArraySeqStPerS::from_vec(vec![0, 1]);
    2|       |//! The simplest possible version, ignoring parallelism.
  119|       |            // Simplified heuristic based on load factor
  326|       |            // Simplified for flat tables
   85|       |        /// Simply append to end of unsorted list
  191|       |            // Simulate probe sequences for different keys to measure diversity
   45|       |                    // Simulate the merge to find element at position i
   71|       |        // Simulate probe sequences for keys from example
   61|       |    /// Simulates the parallel matching algorithm (Algorithm 61.4) sequentially
  230|       |                    // Since sequence is sorted, we can stop early
  266|       |                    // Since sequence is sorted, we can stop
  132|      0|        let single = example_45_2_single_element();
   27|       |        /// Single round of sequential edge contraction
   28|       |        /// Single round of parallel edge contraction
  188|       |        fn single_element_example() -> HeapsortComparison<i32>;
  107|  5.17k|                let single_seq = ArraySeqStPerS::singleton(elem.clone());
  111|  1.46k|                        let single_seq = ArraySeqStPerS::singleton(pair.1.clone());
  117|  5.50k|                    let single_seq = ArraySeqStPerS::singleton(element.clone());
  123|  4.94k|                let single_seq = ArraySeqStPerS::singleton(entry_to_use);
  127|  6.51k|                let single_seq = ArraySeqStPerS::singleton(elem.clone());
  138|      0|                    let single_seq = ArraySeqStPerS::singleton(pair.clone());
  143|      1|                    let single_seq = ArraySeqStPerS::singleton(pair.clone());
  148|  11.7k|                let single_seq = ArraySeqStPerS::singleton(element);
  149|     29|                    let single_seq = ArraySeqStPerS::singleton(elem_self.clone());
  153|     27|                    let single_seq = ArraySeqStPerS::singleton(elem_other.clone());
  156|      0|                let single_seq = ArraySeqStPerS::singleton(bucket_to_use);
  161|      8|                let single_seq = ArraySeqStPerS::singleton(bucket_to_use);
  162|      2|                let single_seq = ArraySeqStPerS::singleton(elem.clone());
  167|     49|                let single_seq = ArraySeqStPerS::singleton(doc_id.clone());
  168|     34|                    let single_seq = ArraySeqStPerS::singleton(element);
  170|      5|                let single_seq = ArraySeqStPerS::singleton(elem.clone());
  190|     30|                let single_seq = ArraySeqStPerS::singleton(entry.0.clone());
  203|    487|            let single_seq = ArraySeqStPerS::singleton(element);
  210|    161|                                let single_seq = ArraySeqStPerS::singleton(entry_to_use);
  213|      0|                    let single_seq = ArraySeqStPerS::singleton(pair.clone());
  214|  1.34k|                let single_seq = ArraySeqStPerS::singleton(current_word.clone());
  214|     30|                    let single_seq = ArraySeqStPerS::singleton(pair.clone());
  222|    165|            let single_seq = ArraySeqStPerS::singleton(current_word);
  231|      0|                let single_seq = ArraySeqStPerS::singleton(bucket_to_use);
  232|  8.96k|                let single_seq = ArraySeqStPerS::singleton(bucket_to_use);
  233|  1.29k|                let single_seq = ArraySeqStPerS::singleton(elem.clone());
  234|      0|                let single_seq = ArraySeqStPerS::singleton(elem.clone());
  263|       |                let single_seq = $crate::Chap19::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS::singleton(pair);
   27|     20|                let single_seq = ArraySeqStPerS::singleton(empty_chain);
  292|     18|                    let single_seq = ArraySeqStPerS::singleton(element);
  297|  5.74k|                let single_seq = ArraySeqStPerS::singleton(entry_to_use);
  322|      3|                    let single_seq = ArraySeqStPerS::singleton(elem.clone());
  327|      3|            let single_seq = ArraySeqStPerS::singleton(element.clone());
  375|      5|                let single_seq = ArraySeqStPerS::singleton(element);
   40|    448|                let single_seq = ArraySeqStPerS::singleton(empty_chain);
   56|      0|                    let single_seq = ArraySeqStPerS::singleton(pair.clone());
   56|  1.83k|                let single_seq = ArraySeqStPerS::singleton(empty_entry);
   67|     69|                    let single_seq = ArraySeqStPerS::singleton(pair.clone());
   76|     20|                let single_seq = ArraySeqStPerS::singleton(bucket_to_use);
   77|  1.46k|                    let single_seq = ArraySeqStPerS::singleton(pair);
   87|  2.95k|                let single_seq = ArraySeqStPerS::singleton(bucket_to_use);
   87|    437|            let single_seq = ArraySeqStPerS::singleton(element);
   96|    796|                let single_seq = ArraySeqStPerS::singleton(elem.clone());
    2|       |//! Parametric single-threaded BST built around a joinMid interface.
  149|      2|        let singleton1 = ArraySetStEph::singleton(1);
  151|      2|        let singleton2 = ArraySetStEph::singleton(2);
  236|    284|            let singleton = Self::singleton(element);
  150|      2|        let singleton3 = ArraySetStEph::singleton(3);
  152|      2|        let singleton4 = ArraySetStEph::singleton(4);
   90|     15|            let singleton_dist = ArraySeqStEphS::singleton(adjusted_row);
  183|     96|        fn singleton(element: T) -> Self {
  213|    313|        fn singleton(element: T) -> Self {
   22|       |        fn singleton(element: T) -> Self;
   22|       |        fn singleton(element: T) -> Self;
   22|       |        fn singleton(element: T) -> Self;
   22|       |        fn singleton(element: T) -> Self;
   34|       |        fn singleton(element: T) -> Self;
   61|      3|        fn singleton(element: T) -> Self {
   61|      3|        fn singleton(element: T) -> Self {
   61|      5|        fn singleton(element: T) -> Self {
  113|       |        fn singleton(item: T) -> ArraySeqMtEphS<T>;
  122|       |        fn singleton(item: T) -> ArraySeqMtPerS<T>;
  129|       |        fn singleton(item: T) -> ArraySeqStEphS<T>;
  131|      0|        fn singleton(item: T) -> ArraySeqS<T> { ArraySeqS::from_vec(vec![item]) }
  145|    235|        fn singleton(item: T) -> ArraySeqStPerS<T> { ArraySeqStPerS::singleton(item) }
  147|      5|        fn singleton(item: T) -> Self {
  153|       |        fn singleton(item: T) -> Self;
  154|       |        fn singleton(item: T) -> Self;
  156|  10.9k|        fn singleton(item: T) -> Self {
  176|    274|        fn singleton(item: T) -> Self {
  177|  1.85k|        fn singleton(item: T) -> Self {
  179|      0|        fn singleton(item: T) -> Self { MathSeqS { data: vec![item] } }
  190|      0|        fn singleton(item: T) -> ArraySeqMtPerS<T> { ArraySeqMtPerS::singleton(item) }
  190|      0|        fn singleton(item: T) -> ArraySeqStEphS<T> { ArraySeqStEphS::singleton(item) }
  193|      0|        fn singleton(item: T) -> ArraySeqMtEphS<T> { ArraySeqMtEphS::singleton(item) }
  197|      0|        fn singleton(item: T) -> ArraySeqS<T> { ArraySeqS::singleton(item) }
  200|       |        fn singleton(item: T) -> Self;
   20|       |        fn singleton(item: T) -> ArraySeqMtPerS<T>;
   20|       |        fn singleton(item: T) -> ArraySeqStEphS<T>;
   20|       |        fn singleton(item: T) -> ArraySeqStPerS<T>;
  215|     13|        fn singleton(item: T) -> AVLTreeS<T> {
   22|       |        fn singleton(item: T) -> ArraySeqMtEphS<T>;
  236|      0|        fn singleton(item: T) -> LinkedListStPerS<T> { LinkedListStPerS::singleton(item) }
  269|      0|        fn singleton(item: T) -> Self { LinkedListStEphS::singleton(item) }
   33|       |        fn singleton(item: T) -> LinkedListStPerS<T>;
   42|       |        fn singleton(item: T) -> ArraySeqS<T>;
   46|       |        fn singleton(item: T) -> Self;
   50|       |        fn singleton(item: T) -> Self;
   56|       |        fn singleton(item: T) -> Self;
   72|       |        fn singleton(item: T) -> AVLTreeS<T>;
   77|      1|        fn singleton(item: T) -> ArraySeqMtEphS<T> {
   83|     23|        fn singleton(item: T) -> ArraySeqStPerS<T> {
   84|     18|        fn singleton(item: T) -> ArraySeqStEphS<T> {
   93|       |        fn singleton(item: T) -> ArraySeqStPerS<T>;
   95|      2|        fn singleton(item: T) -> ArraySeqMtPerS<T> {
  100|      3|        fn singleton(k: K, v: V) -> Self {
  104|      2|        fn singleton(k: K, v: V, reducer: F, identity: V) -> Self {
   26|       |        fn singleton(k: K, v: V) -> Self;
   27|       |        fn singleton(k: K, v: V) -> Self;
   27|       |        fn singleton(k: K, v: V) -> Self;
   30|       |        fn singleton(k: K, v: V) -> Self;
   36|       |        fn singleton(k: K, v: V, reducer: F, identity: V) -> Self;
   36|       |        fn singleton(k: K, v: V, reducer: F, identity: V) -> Self;
   36|       |        fn singleton(k: K, v: V, reducer: F, identity: V) -> Self;
   50|      1|        fn singleton(k: K, v: V) -> Self {
   95|      2|        fn singleton(k: K, v: V, reducer: F, identity: V) -> Self {
   95|      4|        fn singleton(k: K, v: V) -> Self {
   98|      2|        fn singleton(k: K, v: V, reducer: F, identity: V) -> Self {
   98|      3|        fn singleton(k: K, v: V) -> Self {
   26|       |        fn singleton(key: K, value: V) -> Self;
   29|       |        fn singleton(key: K, value: V) -> Self;
   31|       |        fn singleton(key: K, value: V) -> Self;
   69|      4|        fn singleton(key: K, value: V) -> Self {
   72|      4|        fn singleton(key: K, value: V) -> Self {
   90|      5|        fn singleton(key: K, value: V) -> Self {
   91|     15|            let singleton_pred = ArraySeqStEphS::singleton(dijkstra_result.predecessors.clone());
   71|    103|                let singleton_set = Self::singleton(elem);
   32|       |        fn singleton(u: N, x: N) -> Self;
   76|      1|        fn singleton(u: N, x: N) -> Self {
  128|      0|        fn singleton(value: T) -> Self { Self { data: vec![value] } }
  228|      1|        fn singleton(value: T) -> Self { Self::singleton(value) }
  228|      1|        fn singleton(value: T) -> Self { Self::singleton(value) }
  228|      1|        fn singleton(value: T) -> Self { Self::singleton(value) }
  228|      1|        fn singleton(value: T) -> Self { Self::singleton(value) }
  228|      1|        fn singleton(value: T) -> Self { Self::singleton(value) }
  228|      1|        fn singleton(value: T) -> Self { Self::singleton(value) }
   22|       |        fn singleton(value: T) -> Self;
   23|       |        fn singleton(value: T) -> Self;
   23|       |        fn singleton(value: T) -> Self;
   23|       |        fn singleton(value: T) -> Self;
   23|       |        fn singleton(value: T) -> Self;
   23|       |        fn singleton(value: T) -> Self;
   23|       |        fn singleton(value: T) -> Self;
  187|      0|        fn singleton(x: T) -> Set<T> {
   23|       |        fn singleton(x: T) -> Set<T>;
   24|       |        fn singleton(x: T) -> Self;
   24|       |        fn singleton(x: T) -> Self;
   26|       |        fn singleton(x: T) -> Self;
   26|       |        fn singleton(x: T) -> Self;
   27|       |        fn singleton(x: T) -> Self;
   27|       |        fn singleton(x: T) -> Self;
   31|       |        fn singleton(x: T) -> Self;
   31|       |        fn singleton(x: T) -> Self;
   54|    112|        fn singleton(x: T) -> Self {
   61|    271|        fn singleton(x: T) -> Self {
   62|  1.84k|        fn singleton(x: T) -> Self {
   64|  10.9k|        fn singleton(x: T) -> Self {
   67|     26|        fn singleton(x: T) -> Self {
   82|      1|        fn singleton(x: T) -> Self { OrderedSetMtEph { elements: vec![x] } }
   87|      1|        fn singleton(x: T) -> Self {
   88|      1|        fn singleton(x: T) -> Self {
  111|     43|        let size = end - start;
  112|    112|        let size = end - start;
  113|     43|        if size == 0 {
  114|    112|        if size == 0 {
  117|     43|        if size == 1 {
  118|    112|        if size == 1 {
  119|     19|                table_size: size,
  139|     72|        let size = end - start;
   13|       |//! - `size`: Work O(1), Span O(1)
  141|     72|        if size == 0 {
  141|     99|        let size = end - start;
  143|     99|        if size == 0 {
  145|     72|        if size == 1 {
  147|     99|        if size == 1 {
  148|      1|        let size = 1000;
  151|     48|            let size = self.elements.length();
  161|     16|                table_size: size,
  162|     12|            let size = self.size();
  162|     26|                let size = self.elements.length();
  163|     12|            if size == 0 {
  164|      2|2. Table size is significantly larger than minimum needed
  165|   555k|                let size = self.elements.length();
  167|      5|            let size = self.size();
  168|      5|            if size == 0 {
  171|    120|        let size = end - start;
  171|  37.6k|                let size = self.elements.length();
  172|    120|        if size == 0 {
  174|     14|            let size = seq.length();
  174|     20|            if size == 0 {
  176|    120|        if size == 1 {
  179|      7|            let size = seq.length();
  188|     22|            let size = seq.length();
  193|      8|            let size = seq.length();
   19|       |        pub size: N,
  204|     10|            let size = entries.length();
  205|     10|            if size == 0 {
  215|      9|            let size = entries.length();
  217|      8|            let size = entries.length();
  218|      8|            if size == 0 {
   22|      2|            let size = initial_size.max(8);
  228|     12|            let size = entries.length();
  229|     10|            let size = entries.length();
  239|     20|            let size = seq.length();
  242|     12|            let size = entries.length();
  243|      3|            let size = entries.length();
  246|      8|            let size = entries.length();
  247|      6|            let size = seq.length();
  247|      8|            if size == 0 {
  256|      3|            let size = entries.length();
  257|     12|            let size = entries.length();
  266|     10|            let size = seq.length();
  271|     12|            let size = entries.length();
  274|      1|            let size = seq.length();
  275|      9|            let size = entries.length();
  278|    122|        let size = end - start;
  279|    122|        if size == 0 {
  283|    122|        if size == 1 {
  285|      3|            let size = entries.length();
  286|     10|            let size = entries.length();
  292|      8|            let size = entries.length();
  301|      0|                "  size: {}, load_factor: {:.3}",
  303|     11|            let size = entries.length();
  316|     25|            let size = entries.length();
  319|      4|            let size = entries.length();
  330|      2|            let size = entries.length();
  333|     11|            let size = entries.length();
  348|      1|                if size > 2 {
  348|      5|                while size < desired_size {
  349|      1|                    seq.swap(0, size - 1); // Swap first and last
   35|     24|            let size = initial_size.max(8);
  360|      2|            let size = entries.length();
  385|      0|                "Table size: {}, Load factor: {:.3}",
   48|    279|            let size = self.elements.length();
   50|    268|            let size = self.elements.length();
   51|    126|            let size = initial_size.max(8);
   52|  1.11k|        let size = 1 + tree_size(&left) + tree_size(&right);
   68|     21|            if size == 0 {
   72|     78|                    let size = 1 + left.size() + right.size();
   76|    122|        let size = end - start;
   77|    122|        if size == 0 {
   78|       |        /// size (queryAndNot ((fw 'fun'), (fw 'chess')))
   79|      2|                issues.push(format!("Table size {} is not prime", table_size));
   81|    122|        if size == 1 {
   98|  7.83k|                    let size = 1 + left.size() + right.size();
   37|       |        fn sizeA(&self) -> N;
   40|       |        fn sizeA(&self) -> N;
   84|      4|        fn sizeA(&self) -> N { self.A.size() }
   87|  1.67k|        fn sizeA(&self) -> N { self.A.size() }
  151|       |            Self: Sized;
  152|       |            Self: Sized;
   36|       |            Self: Sized;
   36|       |            Self: Sized;
   36|       |            Self: Sized;
   36|       |            Self: Sized;
   48|       |            Self: Sized;
   58|       |            Self: Sized;
   58|       |            Self: Sized;
   59|       |            Self: Sized;
   59|       |            Self: Sized;
   61|       |            Self: Sized;
   65|       |            Self: Sized;
   66|       |            Self: Sized;
   67|       |            Self: Sized;
   68|       |            Self: Sized;
   70|       |            Self: Sized;
   71|       |            Self: Sized;
   71|       |            Self: Sized;
   73|       |            Self: Sized;
   73|       |            Self: Sized;
   76|       |            Self: Sized;
   78|       |            Self: Sized;
   81|       |            Self: Sized;
   83|       |            Self: Sized;
  157|     35|        fn size(docs: &DocumentSet) -> N { docs.size() }
   52|       |        fn size(docs: &DocumentSet) -> N;
   37|       |        fn sizeE(&self) -> N;
   40|       |        fn sizeE(&self) -> N;
   66|     51|        fn sizeE(&self) -> N { self.E.size() }
   69|     75|        fn sizeE(&self) -> N { self.E.size() }
  112|  7.67k|        fn size_link(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }
  115|  2.24k|        fn size_link(link: &Link<K, V, R>) -> N { link.as_ref().map_or(0, |n| n.size) }
   70|  16.4k|        fn size_link(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }
   70|  20.4k|        fn size_link(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }
   71|  3.45k|        fn size_link(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }
   72|  22.3k|        fn size_link(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }
   72|  9.37k|        fn size_link(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }
   74|  15.6k|        fn size_link(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }
   74|   283k|        fn size_link(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }
   74|   373k|        fn size_link(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }
   74|  3.76k|        fn size_link(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }
   80|  1.96k|        fn size_link(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }
  216|   302M|    fn size_link<T: StT>(n: &Link<T>) -> N {
  322|    167|    fn size_link<T: Copy + Debug>(n: &Link<T>) -> N {
   70|  13.9k|    fn size_of<T: StTInMtT + Ord>(link: &Option<Node<T>>) -> N { link.as_ref().map_or(0, |n| n.size) }
  122|      0|        fn size(&self) -> N { BalBinTree::size(self) }
  136|    102|        fn size(&self) -> N {
  140|     42|        fn size(&self) -> N { self.elements.length() }
  147|    359|        fn size(&self) -> N {
  151|     11|        fn size(&self) -> N { Self::size_link(&self.root) }
  157|    168|        fn size(&self) -> N { self.root.borrow().as_ref().map_or(0, |node| node.size) }
  169|     92|        fn size(&self) -> N {
  170|     32|        fn size(&self) -> N { self.elements.length() }
  181|      6|        fn size(&self) -> N { self.size }
  183|     29|        fn size(&self) -> N { Self::size_link(&self.root) }
   18|       |        fn size(&self) -> N;
   18|       |        fn size(&self) -> N;
  190|     21|        fn size(&self) -> N { self.elements.length() }
  193|      0|        fn size(&self) -> N { self.data.len() }
  201|    103|        fn size(&self) -> N {
  208|     34|        fn size(&self) -> N { Self::size_link(&self.root) }
  208|     95|        fn size(&self) -> N {
   20|       |        fn size(&self) -> N;
   21|       |        fn size(&self) -> N;
  224|   233k|        fn size(&self) -> N {
  227|     21|        fn size(&self) -> N { Self::size_link(&self.root) }
   22|       |        fn size(&self) -> N;
   22|       |        fn size(&self) -> N;
   22|       |        fn size(&self) -> N;
  230|      0|        fn size(&self) -> N { self.tree.size() }
  230|      0|        fn size(&self) -> N { self.tree.size() }
  230|      0|        fn size(&self) -> N { self.tree.size() }
  230|      0|        fn size(&self) -> N { self.tree.size() }
  230|      0|        fn size(&self) -> N { self.tree.size() }
  230|      0|        fn size(&self) -> N { self.tree.size() }
  230|     10|        fn size(&self) -> N { Self::size_link(&self.root) }
  238|     64|        fn size(&self) -> N { Self::size_link(&self.root) }
   23|       |        fn size(&self) -> N;
   23|       |        fn size(&self) -> N;
   23|       |        fn size(&self) -> N;
   23|       |        fn size(&self) -> N;
   23|       |        fn size(&self) -> N;
   25|       |        fn size(&self) -> N;
   25|       |        fn size(&self) -> N;
   25|       |        fn size(&self) -> N;
   25|       |        fn size(&self) -> N;
   25|       |        fn size(&self) -> N;
   25|       |        fn size(&self) -> N;
   25|       |        fn size(&self) -> N;
   25|       |        fn size(&self) -> N;
   25|       |        fn size(&self) -> N;
  263|    465|        fn size(&self) -> N {
  264|     19|        fn size(&self) -> N { self.elements.length() }
   26|       |        fn size(&self) -> N;
   26|       |        fn size(&self) -> N;
   26|       |        fn size(&self) -> N;
  287|     28|        fn size(&self) -> N { Self::size_link(&self.root) }
  293|     21|        fn size(&self) -> N { self.root.size() }
  298|       |        fn size(&self) -> N;
  302|  15.7k|        fn size(&self) -> N {
   30|       |        fn size(&self) -> N;
   34|       |        fn size(&self) -> N;
   34|       |        fn size(&self) -> N;
   34|       |        fn size(&self) -> N;
  358|     34|        fn size(&self) -> N { tree_size(self) }
   35|       |        fn size(&self) -> N;
   40|       |        fn size(&self) -> N;
   42|     15|        fn size(&self) -> N { self.inner.size() }
   42|       |        fn size(&self) -> N;
   42|       |        fn size(&self) -> N;
   44|    253|        fn size(&self) -> N { self.elements.length() }
   44|     71|        fn size(&self) -> N { self.elements.length() }
   44|       |        fn size(&self) -> N;
   44|       |        fn size(&self) -> N;
   44|       |        fn size(&self) -> N;
   44|       |        fn size(&self) -> N;
   45|       |        fn size(&self) -> N;
   46|    263|        fn size(&self) -> N { self.elements.length() }
   47|       |        fn size(&self) -> N;
   47|       |        fn size(&self) -> N;
   47|       |        fn size(&self) -> N;
   47|       |        fn size(&self) -> N;
   47|       |        fn size(&self) -> N;
   50|       |        fn size(&self) -> N;
   50|       |        fn size(&self) -> N;
   51|  1.12k|        fn size(&self) -> N { self.elements.length() }
   51|     53|        fn size(&self) -> N {
   52|       |        fn size(&self) -> N;
   52|       |        fn size(&self) -> N;
   52|       |        fn size(&self) -> N;
   53|     16|        fn size(&self) -> N { self.root.size() }
   56|       |        fn size(&self) -> N;
   56|       |        fn size(&self) -> N;
   59|     19|        fn size(&self) -> N {
   59|    330|        fn size(&self) -> N { self.entries.length() }
   60|       |        fn size(&self) -> N;
   62|  2.68k|        fn size(&self) -> N { self.entries.length() }
   76|     27|        fn size(&self) -> N { self.elements.len() }
   77|     25|        fn size(&self) -> N { self.pairs.size() }
   77|     50|        fn size(&self) -> N { self.base_set.size() }
   78|     33|        fn size(&self) -> N { self.base_set.size() }
   82|     25|        fn size(&self) -> N { self.base_table.size() }
   82|    319|        fn size(&self) -> N { self.entries.length() }
   85|     27|        fn size(&self) -> N { self.base_table.size() }
   85|    282|        fn size(&self) -> N { self.base_table.size() }
   85|       |        fn size(&self) -> N;
   88|    303|        fn size(&self) -> N { self.base_table.size() }
   90|  2.65k|        fn size(&self) -> N { self.base_table.size() }
   91|     36|        fn size(&self) -> N { self.base_table.size() }
   96|      9|        fn size(&self) -> N { self.rel.size() }
   23|  13.8M|    fn size<T: StT>(n: &Link<T>) -> N { n.as_ref().map_or(0, |r| r.size) }
   23|  26.6k|    fn size<T: StTInMtT>(n: &Link<T>) -> N { n.as_ref().map_or(0, |r| r.size) }
   34|       |        fn sizeV(&self) -> N;
   34|       |        fn sizeV(&self) -> N;
   37|       |        fn sizeV(&self) -> N;
   37|       |        fn sizeV(&self) -> N;
   65|     17|        fn sizeV(&self) -> N { self.V.size() }
   68|     21|        fn sizeV(&self) -> N { self.V.size() }
   83|      4|        fn sizeV(&self) -> N { self.V.size() }
   86|  1.67k|        fn sizeV(&self) -> N { self.V.size() }
  107|       |                    // Skip if already visited
  107|       |                    // Skip if already visited
  201|       |            // Skip self-edges
  204|       |                    // Skip out-of-bounds indices instead of panicking
   47|       |            // Skip if already processed as a satellite
   89|       |            // Skip parent to avoid immediate backtrack
   92|       |                // Skip if already visited (handles duplicate entries)
   92|       |                // Skip if already visited (handles duplicate entries)
  130|     93|            while skipped < start {
   67|     80|            while skipped < start {
  103|      1|            let s_len = self.seq_s.length();
  105|      1|            let s_len = self.seq_s.length();
   41|      3|            let s_len = self.seq_s.length();
   41|      6|            let s_len = self.seq_s.length();
   43|      3|            let s_len = self.seq_s.length();
   43|      4|            let s_len = self.seq_s.length();
   49|      3|            let s_len = self.seq_s.length();
   49|      3|            let s_len = self.seq_s.length();
   51|      2|            let s_len = self.seq_s.length();
   51|      2|            let s_len = self.seq_s.length();
   59|      3|            let s_len = self.seq_s.length();
   59|      6|            let s_len = self.seq_s.length();
   62|      3|            let s_len = self.seq_s.length();
   62|      4|            let s_len = self.seq_s.length();
   80|     13|            let s_len = self.seq_s.length();
   80|     20|            let s_len = self.seq_s.length();
   82|     13|            let s_len = self.seq_s.length();
   82|     16|            let s_len = self.seq_s.length();
   33|   100k|            let slice: Vec<T> = self.data[begin..end].iter().cloned().collect();
    2|       |//! MtEph slice-oriented Array sequence variant sharing a single mutex.
  168|     17|        fn slice(&self, start: N, length: N) -> Self {
   58|       |        fn slice(&self, start: N, length: N) -> Self;
  127|     19|                let slot = Self::probe(table, key, attempt);
   19|      3|            let slot = Self::find_slot(table, &key);
   20|     30|            let slot = Self::find_slot(table, &key);
   41|      5|                let slot = Self::probe(table, key, attempt);
   42|     38|                let slot = Self::probe(table, key, attempt);
   57|      1|                let slot = Self::probe(table, key, attempt);
   58|      5|                let slot = Self::probe(table, key, attempt);
   61|      0|            let slot = Self::find_slot(table, &key);
   61|     18|            let slot = Self::find_slot(table, &key);
   62|      0|            if slot < table.table.len() {
   71|      0|                let slot = Self::probe(table, key, attempt);
   72|      0|                if slot < table.table.len() {
   80|     19|                let slot = Self::probe(table, key, attempt);
   90|     55|                let slot = Self::probe(table, key, attempt);
   91|      5|                let slot = Self::probe(table, key, attempt);
   95|      4|                let slot = Self::probe(table, key, attempt);
  123|    431|                if smallest == i {
  336|      1|        output.push_str("Exercise Solutions:\n");
   21|       |        /// Solve DP problem
   21|       |        /// Solve DP problem
   21|       |        /// Solve DP problem with memoization
   21|       |        /// Solve DP problem with memoization
   23|       |        /// Solve DP problem
   23|       |        /// Solve DP problem
   23|       |        /// Solve DP problem with memoization
   23|       |        /// Solve DP problem with memoization
   29|       |        /// Solve subset sum problem
   30|       |        /// Solve subset sum problem where k=target, |S|=multiset size
   31|       |        /// Solve subset sum problem with parallel DP where k=target, |S|=multiset size
   32|       |        /// Solve subset sum problem with parallel DP where k=target, |S|=multiset size
   35|       |            // Solve: recursively scan b to get c
   57|       |            // Solve: recursively scan b to get c (parallel)
   64|       |                // Solve and combine in parallel using ParaPair!
   72|       |                // Solve: recursively reduce b
   32|       |    /// Solves APSP problem with negative weights allowed using:
   33|       |    /// Solves APSP problem with negative float weights allowed using:
   37|       |    /// Solves APSP problem with negative float weights using:
   37|       |    /// Solves APSP problem with negative weights using:
   23|       |        fn solve(&self, input: &[T]) -> T;
   23|       |        fn solve(&self, input: &[T]) -> T;
   23|       |        fn solve(&self, input: &[T]) -> T;
   23|       |        fn solve(&self, input: &[T]) -> T;
   25|       |        fn solve(&self, input: &[T]) -> T;
   25|       |        fn solve(&self, input: &[T]) -> T;
   25|       |        fn solve(&self, input: &[T]) -> T;
   25|       |        fn solve(&self, input: &[T]) -> T;
   57|      0|            return Some(0);
   58|      0|            return Some(0);
  108|     72|                | Some((_, existing_w, _)) => {
  116|     52|                    | Some(_) => Self::min_link(&node.left),
  118|     15|                    | Some(_) => Self::min_link(&node.left),
  126|      3|                    | Some(_) => Self::max_link(&node.right),
  128|    161|                    | Some(_) => Self::max_link(&node.right),
   13|      0|            | (Some(_), None) => a,
   14|      0|            | (Some(_), None) => a,
  146|      0|                    | Some(_) => Self::min_key_link(&node.left),
  148|     15|                    | Some(_) => Self::min_link(&node.left),
  149|     47|                    | Some(_) => Self::min_link(&node.left),
  153|     62|                    | Some(_) => Self::min_link(&node.left),
  156|      1|                    | Some(_) => Self::max_key_link(&node.right),
  158|     17|                    | Some(_) => Self::max_link(&node.right),
  159|     31|                    | Some(_) => Self::max_link(&node.right),
  161|      0|                    | Some(_) => Self::min_link(&node.left),
  163|    117|                    | Some(_) => Self::max_link(&node.right),
   17|      0|            | (Some(_), None) => a,
  171|      2|                    | Some(_) => Self::max_link(&node.right),
  173|     16|                    | Some(_) => Self::min_link(&node.left),
  173|  2.41k|                    | Some(_) => Self::min_link(&node.left),
   18|      0|            | (Some(_), None) => a,
   18|      0|            | (Some(_), None) => a,
  183|     16|                    | Some(_) => Self::max_link(&node.right),
  183|  2.45k|                    | Some(_) => Self::max_link(&node.right),
  192|     11|                    | Some(_) => Self::min_link(&node.left),
  195|     31|                    | Some(_) => Self::min_link(&node.left),
  202|      9|                    | Some(_) => Self::max_link(&node.right),
  205|      9|                    | Some(_) => Self::max_link(&node.right),
  209|    275|                    | Some(_) => Self::min_link(&node.left),
   21|      0|            | (Some(_), None) => a,
  219|     10|                    | Some(_) => Self::min_key_link(&node.left),
  219|    219|                    | Some(_) => Self::max_link(&node.right),
  229|      7|                    | Some(_) => Self::max_key_link(&node.right),
   74|     44|                | Some((_, existing_w, _)) => {
   86|     33|                | Some((_, existing_w, _)) => {
  159|      6|                | Some((al, ak, ap, ar)) => {
  175|      6|                | Some((al, ak, ap, ar)) => {
  195|      7|                | Some((al, ak, ap, ar)) => {
   78|     21|                return Some(*a.nth(0));
   79|     21|                return Some(a.nth_cloned(0));
  120|      3|                return Some(a.nth_cloned(index));
  115|      4|                return Some(a.nth(i));
  302|      7|                return Some(a.nth(i));
  118|      5|                return Some(a.nth(index).clone());
  112|      0|                return Some(ArraySeqStPerS::from_vec(vec![u]));
  114|      0|                return Some(ArraySeqStPerS::from_vec(vec![u]));
  114|      0|                return Some(ArraySeqStPerS::from_vec(vec![u]));
  116|      0|                return Some(ArraySeqStPerS::from_vec(vec![u]));
   54|     21|                    | Some(current_max) => Some(current_max.max(ending_max)),
   56|     21|                    | Some(current_max) => Some(current_max.max(ending_max)),
  138|     72|                | Some(doc_set) => doc_set,
   96|     34|                | Some(e) => e,
  179|     12|                    return Some(elem.clone());
  184|      5|                    return Some(elem.clone());
  193|     20|                    return Some(elem.clone());
  198|      6|                    return Some(elem.clone());
   48|      7|            | Some(first) => println!("first(A) = '{}'", first),
   54|  7.20k|                    return Some(head);
   90|     32|                    return Some(&labeled_arc.2);
   96|     10|                    return Some(&labeled_arc.2);
  100|     41|                    return Some(&labeled_edge.2);
  106|     10|                    return Some(&labeled_edge.2);
  118|      7|            | Some(last) => println!("last(A) = '{}'", last),
  124|    538|                | Some((left, root_key, priority, right)) => match key.cmp(&root_key) {
  215|     11|                | Some((left, key, priority, right)) => {
  246|      4|                | Some((left, key, _priority, right)) => {
  111|     16|            max_with_neginf(result, Some(max_crossing))
   97|     16|            max_with_neginf(result, Some(max_crossing))
  206|      2|            (new_pq, Some(max_element))
  240|      0|            (new_pq, Some(max_element))
  118|    117|            (new_pq, Some(min_element))
  133|    253|            (new_pq, Some(min_element))
  242|    214|            (new_pq, Some(min_element))
  249|    114|                    (new_heap, Some(min_element))
  124|    232|            (new_pq, Some(min_element.clone()))
  178|    274|                root: Some(mk(item, None, None)),
  179|  1.85k|                root: Some(mk(item, None, None)),
  283|  97.2M|            | Some(mut n) => {
  396|     20|            | Some(mut n) => {
  310|     33|            | Some(n) => {
  423|      5|            | Some(n) => {
   98|     14|            | Some(n) => {
   99|     66|            | Some(n) => {
  142|      2|                | Some(neighbors) => {
   83|     13|                | Some(neighbors) => neighbors.find(v),
   83|      7|                | Some(neighbors) => neighbors.find(v),
   90|      6|                | Some(neighbors) => neighbors.clone(),
   91|      7|                | Some(neighbors) => neighbors.clone(),
   49|      0|        mk(y.value.clone(), Some(new_x), y.right.clone())
   49|      0|        mk(y.value.clone(), Some(new_x), y.right.clone())
   54|      7|            | Some(next_elem) => println!("next(A, 'quinn') = '{}'", next_elem),
   60|      7|            | Some(next_elem) => println!("next(A, 'mike') = '{}'", next_elem),
  101|    986|                | Some(node) => {
  114|     55|                | Some(node) => match node.left {
  115|     18|                    return Some(node);
  116|     30|                | Some(node) => match node.left {
  118|  3.22k|                | Some(node) => {
  118|    793|                    | Some(node) if target == &node.key => Some(node.key.clone()),
  119|    675|                    | Some(node) => {
  124|      5|                | Some(node) => match node.right {
  126|    176|                | Some(node) => match node.right {
  129|    775|                | Some(node) => {
  131|    604|                | Some(node) => {
  132|     33|                    | Some(node) => {
  132|    424|                | Some(node) => {
  136|  11.2k|                | Some(node) => {
  136|    382|                | Some(node) => {
  136|    811|                | Some(node) => {
  139|   116k|                | Some(node) => Self::is_red(&node.right) && !Self::is_red(&node.left),
  143|     87|                    | Some(node) => {
  144|      1|                | Some(node) => match node.left {
  144|     36|                | Some(node) => {
  146|     25|                | Some(node) => match node.left {
  147|   116k|                | Some(node) => {
  147|     69|                | Some(node) => match node.left {
  151|     79|                | Some(node) => match node.left {
  154|      2|                | Some(node) => match node.right {
  156|    190|                | Some(node) => {
  156|  2.01M|                | Some(node) => {
  156|     27|                | Some(node) => match node.right {
  157|     53|                | Some(node) => match node.right {
  159|      1|                | Some(node) => match node.left {
  159|     64|                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),
  161|   116k|                | Some(node) => Self::is_red(&node.left) && Self::is_red(&node.right),
  161|    134|                | Some(node) => match node.right {
  162|    225|                    return Some(node);
  169|      3|                | Some(node) => match node.right {
  171|     24|                | Some(node) => match node.left {
  171|  2.84k|                | Some(node) => match &node.left {
  175|  1.18k|                | Some(node) => {
  178|     28|                | Some(node) => {
  180|     86|                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),
  181|     24|                | Some(node) => match node.right {
  181|  2.88k|                | Some(node) => match &node.right {
  187|    177|                | Some(node) => {
  189|    100|                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),
  190|     17|                | Some(node) => match node.left {
  191|     69|                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),
  192|  1.90k|                | Some(node) => {
  193|     34|                | Some(node) => match node.left {
  200|     15|                | Some(node) => match node.right {
  202|  1.90k|                | Some(node) => {
  203|     11|                | Some(node) => match node.right {
  203|    174|                | Some(node) => {
  207|    353|                | Some(node) => match node.left {
  212|    343|                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),
  216|    173|                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),
  217|     18|                | Some(node) => match node.left {
  217|    297|                | Some(node) => match node.right {
  219|     17|                | Some(node) => {
  219|    316|                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),
  227|     15|                | Some(node) => match node.right {
  235|    149|                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),
  238|      0|                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),
  246|  1.00k|                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),
  253|    105|                | Some(node) => {
  274|  5.89k|                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),
  295|    101|                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),
   53|     18|                | Some(node) => {
   64|    114|                | Some(node) => Exposed::Node(node.left.clone(), node.key.clone(), node.right.clone()),
   69|     29|                    | Some(node) => {
   71|    794|                | Some(node) => Exposed::Node(node.left.clone(), node.key.clone(), node.right.clone()),
   76|  8.10k|                | Some(node) => {
   76|  8.21k|                | Some(node) => {
   78|  11.0k|                | Some(node) => {
   78|     64|                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),
   80|     71|                    | Some(node) => {
   83|  6.97k|                    | Some(node) => {
   88|  14.6k|                | Some(node) => Exposed::Node(node.left.clone(), node.key.clone(), node.right.clone()),
   99|    239|                    return Some(node);
   99|     68|                | Some(node) => {
   55|      8|                    return Some(node.value.clone());
  119|     14|                | Some(ns) => {
  126|     10|                | Some(ns) => ns.insert(v.clone()),
   80|      0|            return Some(OrderedFloat(0.0));
   81|      0|            return Some(OrderedFloat(0.0));
  220|      6|                    return Some(pair.0.clone());
  233|      9|                    return Some(pair.0.clone());
  234|      7|                    return Some(pair.0.clone());
  247|      9|                    return Some(pair.0.clone());
  262|      9|                    return Some(pair.0.clone());
  276|      9|                    return Some(pair.0.clone());
  115|      0|                    return Some(&pair.1);
  124|     95|                    return Some(&pair.1);
  124|      7|            | Some(prev) => println!("previous(A, 'rachel') = '{}'", prev),
  105|      2|                    | Some(rec) => Some(rec),
  137|  1.26k|                    | Some(rec) => Some(rec),
  145|     17|                | Some((r_left, r_key, r_priority, r_right)) => {
   86|      7|            | Some(selected) => println!("select(A, 5) = '{}'", selected),
   24|     10|                return Some(self.nth(0).clone());
   24|     11|                return Some(self.nth(0).clone());
   24|     15|                return Some(self.nth(0).clone());
   26|     15|                return Some(self.nth_cloned(0));
   38|     26|            return (Some(val), val, val, val);
   38|     26|            return (Some(val), val, val, val);
   74|      0|                        return Some(val);
  174|    205|                            return Some(value);
   28|      5|                    return Some(v.clone());
   29|      5|                    return Some(v.clone());
   70|      1|            return Some((visited, rec_stack, result));
  158|     43|                return Some(*w);
  189|      3|                return Some(*w);
  209|      6|                return Some(*w);
   38|      1|            | Some(w) => println!("  Path 0→1: {}", w),
   40|      1|            | Some(w) => println!("Path 0→1→2→3 has weight: {}", w),
   44|      1|            | Some(w) => println!("  Path 0→1→2→1 (one cycle): {}", w),
   50|      1|            | Some(w) => println!("  Path 0→1→2→1→2→1 (two cycles): {}", w),
   76|      1|            | Some(w) => println!("Path 0→1→2→3 has weight: {:.1}", w.0),
   91|      1|            | Some(w) => println!("Path 0→1→2 with negative weight has total: {}", w),
   14|     68|            | (Some(x), Some(y)) => Some(x.max(y)),
   15|     53|            | (Some(x), Some(y)) => Some(x.max(y)),
   18|     42|            | (Some(x), Some(y)) => Some(x.max(y)),
   19|     32|            | (Some(x), Some(y)) => Some(x.max(y)),
   19|     42|            | (Some(x), Some(y)) => Some(x.max(y)),
   22|     32|            | (Some(x), Some(y)) => Some(x.max(y)),
   15|       |        /// Sort a sequence using merge sort.
  186|       |            // Sort by key to maintain order
   20|       |        /// Sort a sequence using parallel merge sort.
  250|       |            // Sort by clustering score (lower is better)
    2|       |//! Topological Sort - Sequential Ephemeral (Chapter 55, Algorithm 55.13).
    2|       |//! Topological Sort - Sequential Persistent (Chapter 55, Algorithm 55.13).
   67|       |        // Sort edges by weight
   94|       |            // Sort entries by key
  118|      0|        let sorted = example_45_2_already_sorted();
   92|     29|            let sorted_left = Self::merge_sort(&left);
  250|      0|            write!(f, "SortedListPQ[")?;
    4|       |pub mod SortedListPQ {
  263|       |    macro_rules! SortedListPQLit {
  277|      0|    fn _sorted_list_pq_lit_type_checks() {
  149|       |        pub sorted_list_result: Vec<T>,
  188|     38|            Self::merge_parallel(&sorted_left, &sorted_right)
   93|     29|            let sorted_right = Self::merge_sort(&right);
   96|     29|            Self::merge(&sorted_left, &sorted_right)
  238|      3|            let sorted_seq = self.extract_all_sorted();
  392|      1|            let sorted_seq = self.extract_all_sorted();
  137|  5.81k|                        scope.spawn(|| sort(left));
  177|    178|                        scope.spawn(|| sort(left));
   86|    253|                        scope.spawn(|| sort(left));
  101|     16|            fn sort<T: StT + Ord>(a: &mut ArraySeqStEphS<T>, lo: N, hi: N) {
  136|     14|            fn sort<T: StT + Ord>(a: &mut ArraySeqStEphS<T>, lo: N, hi: N) {
  150|    361|                fn sort<T: StT + Ord + Send>(data: &mut [T]) {
   53|     24|            fn sort<T: StT + Ord>(a: &mut ArraySeqStEphS<T>, lo: N, hi: N) {
   61|    512|                fn sort<T: StT + Ord + Send>(data: &mut [T]) {
   99|  11.6k|                fn sort<T: StT + Ord + Send>(data: &mut [T]) {
   22|      6|        if source >= n {
   22|      7|        if source >= n {
   26|      7|        if source >= n {
   26|      7|        if source >= n {
   27|      7|        if source >= n {
   27|      7|        if source >= n {
   44|       |        /// Source vertex.
   45|       |        pub source: usize,
   45|       |        /// Source vertex.
   46|       |        pub source: usize,
   47|       |        /// Source vertex.
   47|       |        /// Source vertex.
   48|       |        pub source: usize,
   48|       |        pub source: usize,
   58|    173|                    let source_char = self.source.nth(i - 1);
   61|    173|                    if source_char == target_char {
   67|     93|                    let source_char = self.source.nth(i - 1);
   70|     93|                    if source_char == target_char {
   73|    550|                    let source_char = self.source.nth(i - 1);
   76|    550|                    if source_char == target_char {
   83|    118|                    let source_char = self.source.nth_cloned(i - 1);
   86|    118|                    if source_char == target_char {
  105|     19|            let source_len = solver.source.length();
  119|     29|            let source_len = self.source.length();
  130|      9|            let source_len = self.source.length();
  146|     16|            let source_len = self.source.length();
  129|      2|        fn source_mut(&mut self) -> &mut ArraySeqStEphS<T> { &mut self.source }
  156|      1|        fn source_mut(&mut self) -> &mut ArraySeqMtEphS<T> { &mut self.source }
   41|       |        fn source_mut(&mut self) -> &mut ArraySeqStEphS<T>;
   45|       |        fn source_mut(&mut self) -> &mut ArraySeqMtEphS<T>;
   60|     12|        let sources = AVLTreeSetStEph::singleton(source);
   61|     12|        pq_min_multi(graph, sources, priority_fn)
   64|      6|        let sources = AVLTreeSetStEph::singleton(source);
   65|      6|        graph_search_multi(graph, sources, strategy)
   67|     12|        let sources = AVLTreeSetMtPer::singleton(source);
   67|      6|        let sources = AVLTreeSetStPer::singleton(source);
   68|     12|        pq_min_multi(graph, sources, priority_fn)
   68|      6|        pq_min_multi(graph, sources, priority_fn)
   69|      6|        let sources = AVLTreeSetMtPer::singleton(source);
   70|      6|        graph_search_multi(graph, sources, strategy)
   76|      8|        let sources = AVLTreeSetStPer::singleton(source);
   77|      6|        let sources = AVLTreeSetMtEph::singleton(source);
   77|      8|        graph_search_multi(graph, sources, strategy)
   78|      6|        pq_min_multi(graph, sources, priority_fn)
  111|      3|        fn source(&self) -> &ArraySeqStPerS<T> { &self.source }
  125|      8|        fn source(&self) -> &ArraySeqStEphS<T> { &self.source }
  136|      2|        fn source(&self) -> &ArraySeqMtPerS<T> { &self.source }
  152|      9|        fn source(&self) -> &ArraySeqMtEphS<T> { &self.source }
   35|       |        fn source(&self) -> &ArraySeqStEphS<T>;
   35|       |        fn source(&self) -> &ArraySeqStPerS<T>;
   38|       |        fn source(&self) -> &ArraySeqMtPerS<T>;
   39|       |        fn source(&self) -> &ArraySeqMtEphS<T>;
  104|      7|            let sources_seq = sources.to_seq();
  128|     13|            let sources_seq = sources.to_seq();
  139|     13|            let sources_seq = sources.to_seq();
  144|      7|            let sources_seq = sources.to_seq();
  131|       |    /// Span Θ(log k + avg_degree), Parallelism Θ(k/log k)
   20|       |        fn spanning_tree_star_contraction_mt<V: StT + MtT + Hash + Ord + 'static>(
   20|       |        fn spanning_tree_star_contraction<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> Set<Edge<V>>;
    6|       |pub mod SpanTreeMtEph {
    6|       |pub mod SpanTreeStEph {
  188|       |    // Special case: ad-hoc implementation for String
   29|       |    impl SpinLock {
   66|       |    impl SpinLockTrait for SpinLock {
    2|       |//! Ephemeral Splay Tree (standard BST semantics) with public methods.
    2|       |//! Ephemeral splay-style (simple BST) structure with interior locking for multi-threaded access.
  347|       |        /// Split heap at a given value (returns (less_than, equal_or_greater))
  365|       |        /// Split the priority queue at a given element
  128|       |        // split(A, 'mike') → ({'artie', 'burt', 'finn'}, true, {'rachel', 'sam', 'tina'})
   54|     50|            let split_cols = self.dimensions[k].cols;
   56|     68|            let split_cols = self.dimensions[k].cols;
   66|     63|            let split_cols = dimensions_guard[k].cols;
   66|      6|            let split_cols = self.dimensions[k].cols;
  109|     68|                        let split_cost = self.multiply_cost(i, k, j);
  119|     63|                        let split_cost = self.multiply_cost(i, k, j);
   76|     50|                        let split_cost = self.multiply_cost(i, k, j);
   88|      6|                        let split_cost = self.multiply_cost(i, k, j);
  108|  7.88k|        fn split_inner(tree: &Self, key: &T) -> (Self, B, Self) {
  121|    775|        fn split_inner(tree: &Self, key: &T) -> (Self, B, Self) {
   80|     80|        fn split_inner(tree: &Self, key: &T) -> (Self, B, Self) {
  228|      1|        fn split_key(&mut self, k: &K) -> (Self, Self) {
  241|      1|        fn split_key(&mut self, k: &K) -> (Self, Self) {
  254|      3|        fn split_key(&mut self, k: &K) -> (Self, Self) {
  283|      3|        fn split_key(&mut self, k: &K) -> (Self, Self) {
   59|       |        fn split_key(&mut self, k: &K) -> (Self, Self)
   64|       |        fn split_key(&mut self, k: &K) -> (Self, Self)
   71|       |        fn split_key(&mut self, k: &K) -> (Self, Self)
   74|       |        fn split_key(&mut self, k: &K) -> (Self, Self)
  241|      3|        fn split_key(&self, k: &K) -> (Self, Option<V>, Self) {
  262|      1|        fn split_key(&self, k: &K) -> (Self, Option<V>, Self) {
   56|       |        fn split_key(&self, k: &K) -> (Self, Option<V>, Self)
   65|       |        fn split_key(&self, k: &K) -> (Self, Option<V>, Self)
  146|     17|                    let (split_left, _, split_right) = ParamTreap::split_inner(&left, &r_key);
  190|      2|        fn split(&mut self, k: &T) -> (Self, B, Self) {
  205|      2|        fn split(&mut self, k: &T) -> (Self, B, Self) {
   57|       |        fn split(&mut self, k: &T) -> (Self, B, Self)
   57|       |        fn split(&mut self, k: &T) -> (Self, B, Self)
   46|      2|                self.append(&mut split_off);
   90|       |        // splitRank(A, 3) → ({'artie', 'burt', 'finn'}, {'mike', 'rachel', 'sam', 'tina'})
  289|      1|        fn split_rank_key(&mut self, i: N) -> (Self, Self) {
  302|      1|        fn split_rank_key(&mut self, i: N) -> (Self, Self) {
  328|      2|        fn split_rank_key(&mut self, i: N) -> (Self, Self) {
  358|      2|        fn split_rank_key(&mut self, i: N) -> (Self, Self) {
   66|       |        fn split_rank_key(&mut self, i: N) -> (Self, Self)
   71|       |        fn split_rank_key(&mut self, i: N) -> (Self, Self)
   79|       |        fn split_rank_key(&mut self, i: N) -> (Self, Self)
   81|       |        fn split_rank_key(&mut self, i: N) -> (Self, Self)
  317|      4|        fn split_rank_key(&self, i: N) -> (Self, Self) {
  324|      1|        fn split_rank_key(&self, i: N) -> (Self, Self) {
   63|       |        fn split_rank_key(&self, i: N) -> (Self, Self)
   76|       |        fn split_rank_key(&self, i: N) -> (Self, Self)
  216|     19|        fn split_rank_link(link: &Link<T>, rank: N) -> (Link<T>, Link<T>) {
  249|      1|        fn split_rank(&mut self, i: N) -> (Self, Self) {
  272|      1|        fn split_rank(&mut self, i: N) -> (Self, Self) {
   69|       |        fn split_rank(&mut self, i: N) -> (Self, Self)
   69|       |        fn split_rank(&mut self, i: N) -> (Self, Self)
  264|     10|        fn split_rank(&self, i: N) -> (Self, Self) {
  281|      4|        fn split_rank(&self, rank: N) -> (BSTSizeStEph<T>, BSTSizeStEph<T>) {
   64|       |        fn split_rank(&self, rank: N) -> (BSTSizeStEph<T>, BSTSizeStEph<T>);
   68|       |        fn split_rank(&self, i: N) -> (Self, Self)
  186|      1|        fn split(&self, key: &T) -> (Self, B, Self) { ParamBST::split_inner(self, key) }
  200|      9|        fn split(&self, k: &T) -> (Self, B, Self) {
  252|      1|        fn split(&self, pivot: &T) -> (Self, B, Self) { BSTSetAVLMtEph::split(self, pivot) }
  252|      1|        fn split(&self, pivot: &T) -> (Self, B, Self) { BSTSetBBAlphaMtEph::split(self, pivot) }
  252|      1|        fn split(&self, pivot: &T) -> (Self, B, Self) { BSTSetRBMtEph::split(self, pivot) }
  252|      1|        fn split(&self, pivot: &T) -> (Self, B, Self) { BSTSetSplayMtEph::split(self, pivot) }
  252|      1|        fn split(&self, pivot: &T) -> (Self, B, Self) { BSTSetTreapMtEph::split(self, pivot) }
  294|      1|        fn split(&self, pivot: &T) -> (Self, B, Self) {
  313|       |        fn split(&self, key: &T) -> (Self, B, Self);
  346|      4|        fn split(&self, key: &T) -> (Self, B, Self) { ParamBST::split_inner(self, key) }
  400|      4|        fn split(&self, key: &T) -> (Self, B, Self) { ParamTreap::split_inner(self, key) }
   47|       |        fn split(&self, pivot: &T) -> (Self, B, Self);
   47|       |        fn split(&self, pivot: &T) -> (Self, B, Self);
   47|       |        fn split(&self, pivot: &T) -> (Self, B, Self);
   47|       |        fn split(&self, pivot: &T) -> (Self, B, Self);
   47|       |        fn split(&self, pivot: &T) -> (Self, B, Self);
   47|       |        fn split(&self, pivot: &T) -> (Self, B, Self);
   50|       |        fn split(&self, key: &T) -> (Self, B, Self);
   56|       |        fn split(&self, k: &T) -> (Self, B, Self)
   57|       |        fn split(&self, key: &T) -> (Self, B, Self);
  329|      8|            let sqrt_n = (n as f64).sqrt() as N;
   53|     48|            let sqrt_n = (n as f64).sqrt() as N;
   16|       |pub mod SSSPResultStEphFloat {
   51|       |    impl SSSPResultStEphFloat {
   68|       |    /// SSSPResultStEphFloat with distances and predecessors
   15|       |pub mod SSSPResultStEphInt {
   49|       |    impl SSSPResultStEphInt {
   68|       |    /// SSSPResultStEphInt with distances and predecessors
   16|       |pub mod SSSPResultStPerFloat {
   51|       |    impl SSSPResultStPerFloat {
   15|       |pub mod SSSPResultStPerInt {
   48|       |    impl SSSPResultStPerInt {
    5|       |//! A stack is a Last-In-First-Out (LIFO) data structure.
   15|       |pub mod StackStEph {
   27|       |        /// Standard quadratic probing with c1=1, c2=1
    5|       |//! A star partition divides a graph into blocks where each block is a
    7|       |pub mod StarContractionMtEph {
    7|       |pub mod StarContractionStEph {
   24|       |        fn star_contract_mt<V, R, F, G>(graph: &UnDirGraphMtEph<V>, base: F, expand: G) -> R
   21|       |        fn star_contract<V, R, F, G>(graph: &UnDirGraphStEph<V>, base: F, expand: G) -> R
    7|       |pub mod StarPartitionMtEph {
    8|       |pub mod StarPartitionStEph {
  152|      1|        let start = std::time::Instant::now();
  161|      1|        let start = std::time::Instant::now();
  163|       |            // Start from last non-leaf node and bubble down
  170|      1|        let start = std::time::Instant::now();
  181|      1|        let start = std::time::Instant::now();
  186|      1|        let start = std::time::Instant::now();
  191|      1|        let start = std::time::Instant::now();
  194|      0|            ArraySeqMtPerS::subseq_copy(self, start, length)
  234|      1|            ArraySeqMtEphS::subseq_copy(self, start, length)
  240|      0|            LinkedListStPerS::subseq_copy(self, start, length)
   24|     11|        for start in 0..n {
   24|     11|        for start in 0..n {
   26|     14|        for start in 0..n {
   27|     14|        for start in 0..n {
  412|      1|            let start = std::time::Instant::now();
   43|      0|        for start in 0..n {
   48|     20|        for start in 0..n {
   49|      0|        for start in 0..n {
   52|     20|        for start in 0..n {
   65|      2|        euler_tour_dfs(graph, start, None, tree_edges, &mut tour, &mut visited_edges);
   70|      2|        euler_tour_dfs(graph, start, None, tree_edges, &mut tour, &mut visited_edges);
   83|     13|            let start = max(1, k.saturating_sub(t_len));
   83|     20|            let start = max(1, k.saturating_sub(t_len));
   85|     13|            let start = max(1, k.saturating_sub(t_len));
   85|     16|            let start = max(1, k.saturating_sub(t_len));
   88|      1|            ArraySeqMtEphTraitChap18::subseq_copy(self, start, length)
   97|     18|            let start = self.range.start;
  316|      2|            let start_idx = (1 << level) - 1; // 2^level - 1
  142|      0|            let start_index = start.min(sequence_length);
  151|      1|            let start_index = start.min(sequence_length);
  222|      2|            let start_pos = match self.elements.binary_search(k1) {
  122|       |        /// Static method to compute value for a single DP table cell
  122|       |        /// Static method to compute value for a single DP table cell
  145|       |            T: 'static;
  172|       |            T: 'static;
  219|     10|            T: 'static,
  307|    156|            T: 'static,
   36|       |            T: 'static;
   55|      0|            <ArraySeqStPerS<ArraySeqStPerS<Pair<N, &'static str>>> as ArraySeqStPerTrait<
   56|      0|                ArraySeqStPerS<Pair<N, &'static str>>,
   56|       |            T: 'static;
   60|      0|                    <ArraySeqStPerS<Pair<N, &'static str>> as ArraySeqStPerTrait<Pair<N, &'static str>>>::tabulate(
   67|      0|        <ArraySeqStPerS<Pair<N, &'static str>> as ArraySeqStPerTrait<Pair<N, &'static str>>>::flatten(&nested)
    2|       |//! Order Statistics - Parallel Ephemeral (Chapter 35, Algorithm 35.2).
    2|       |//! Order Statistics - Parallel Persistent (Chapter 35, Algorithm 35.2).
    2|       |//! Order Statistics - Sequential Ephemeral (Chapter 35, Algorithm 35.2).
    2|       |//! Order Statistics - Sequential Persistent (Chapter 35, Algorithm 35.2).
  324|      1|        let stats = sep_chain.statistics();
    6|       |    use std::cell::RefCell;
    9|       |    use std::cmp::{max, min};
    9|       |    use std::cmp::{max, min};
    9|       |    use std::cmp::{max, min};
    9|       |    use std::cmp::{max, min};
   76|     50|                    .fold(Probability::infinity(), std::cmp::min);
   88|    151|                    .fold(Probability::infinity(), std::cmp::min);
   12|       |    use std::cmp::Ordering;
   12|       |    use std::cmp::Ordering;
    6|       |    use std::cmp::Ordering;
    6|       |    use std::cmp::Ordering;
    6|       |    use std::cmp::Ordering;
    9|       |    use std::cmp::Ordering;
    9|       |    use std::cmp::Ordering;
  122|    496|                    | std::cmp::Ordering::Equal => (left, true, right),
  135|     13|                    | std::cmp::Ordering::Equal => (left, true, right),
  181|      4|                    | std::cmp::Ordering::Equal => Some(root_key),
  242|    176|                    | std::cmp::Ordering::Equal => return true,
  339|    149|                    | std::cmp::Ordering::Equal => Some(root_key),
  393|    126|                    | std::cmp::Ordering::Equal => Some(root_key),
   94|      6|                    | std::cmp::Ordering::Equal => (left, true, right),
  117|       |                    | std::cmp::Ordering::Greater => {
  130|       |                    | std::cmp::Ordering::Greater => {
  180|      6|                    | std::cmp::Ordering::Greater => ParamBSTTrait::find(&right, key),
  243|     92|                    | std::cmp::Ordering::Greater => right = mid,
  338|    415|                    | std::cmp::Ordering::Greater => ParamBSTTrait::find(&right, key),
  392|    305|                    | std::cmp::Ordering::Greater => ParamTreapTrait::find(&right, key),
   89|       |                    | std::cmp::Ordering::Greater => {
  112|       |                    | std::cmp::Ordering::Less => {
  125|       |                    | std::cmp::Ordering::Less => {
  179|      7|                    | std::cmp::Ordering::Less => ParamBSTTrait::find(&left, key),
  241|    673|                    | std::cmp::Ordering::Less => left = mid + 1,
  337|  4.56k|                    | std::cmp::Ordering::Less => ParamBSTTrait::find(&left, key),
  391|    361|                    | std::cmp::Ordering::Less => ParamTreapTrait::find(&left, key),
   84|       |                    | std::cmp::Ordering::Less => {
    6|       |    use std::collections::BTreeSet;
    6|       |    use std::collections::BTreeSet;
    6|       |    use std::collections::BTreeSet;
    6|       |    use std::collections::BTreeSet;
    6|       |    use std::collections::BTreeSet;
    6|       |    use std::collections::BTreeSet;
   10|       |    use std::collections::HashMap;
   10|       |    use std::collections::HashMap;
   11|       |    use std::collections::{HashMap, HashSet};
   11|       |    use std::collections::{HashMap, HashSet};
   12|       |    use std::collections::HashMap;
   12|       |    use std::collections::HashMap;
   13|       |    use std::collections::HashMap;
   13|       |    use std::collections::HashMap;
   14|       |    use std::collections::HashMap;
   14|       |    use std::collections::HashMap;
    6|       |    use std::collections::HashMap;
    6|       |    use std::collections::HashMap;
    6|       |    use std::collections::HashMap;
    6|       |    use std::collections::HashMap;
    6|       |    use std::collections::HashMap;
    6|       |    use std::collections::HashMap;
    6|       |    use std::collections::HashMap;
    6|       |    use std::collections::HashMap;
    6|       |    use std::collections::HashMap;
    6|       |    use std::collections::HashMap;
    6|       |    use std::collections::HashMap;
    6|       |    use std::collections::HashMap;
    6|       |    use std::collections::HashMap;
    6|       |    use std::collections::HashMap;
    6|       |    use std::collections::HashMap;
    6|       |    use std::collections::HashMap;
    6|       |    use std::collections::HashMap;
    8|       |    use std::collections::HashMap;
    8|       |    use std::collections::HashMap;
    9|       |    use std::collections::HashMap;
    9|       |    use std::collections::HashMap;
    9|       |    use std::collections::HashMap;
    9|       |    use std::collections::HashMap;
    9|       |    use std::collections::HashMap;
    9|       |    use std::collections::HashMap;
    9|       |    use std::collections::HashMap;
    9|       |    use std::collections::HashMap;
    9|       |    use std::collections::HashMap;
    9|       |    use std::collections::HashMap;
    9|       |    use std::collections::{HashMap, HashSet};
   87|       |            use std::collections::hash_map::DefaultHasher;
  183|     38|        edge_coins: &std::collections::HashMap<Edge<V>, bool>,
   10|       |    use std::collections::hash_map::Entry;
    6|       |    use std::collections::HashSet;
    6|       |    use std::collections::HashSet;
    6|       |    use std::collections::HashSet;
    6|       |    use std::collections::HashSet;
    6|       |    use std::collections::HashSet;
    6|       |    use std::collections::HashSet;
    8|       |    use std::collections::HashSet;
    8|       |    use std::collections::HashSet;
    6|       |    use std::collections::hash_set::Iter;
    7|       |    use std::collections::LinkedList;
    8|       |    use std::collections::VecDeque;
    8|       |    use std::collections::VecDeque;
    8|       |    use std::collections::VecDeque;
    8|       |    use std::collections::VecDeque;
   11|       |    use std::fmt;
   11|       |    use std::fmt;
    6|       |    use std::fmt;
   10|       |    use std::fmt::{Debug, Display};
   10|       |    use std::fmt::{Debug, Display};
   10|       |    use std::fmt::{Debug, Display};
   10|       |    use std::fmt::{Debug, Display};
   10|       |    use std::fmt::{Debug, Display};
   10|       |    use std::fmt::{Debug, Display};
   10|       |    use std::fmt::{Debug, Display};
   10|       |    use std::fmt::{Debug, Display};
   10|       |    use std::fmt::{Debug, Display, Formatter, Result as FmtResult};
   11|       |    use std::fmt::{Debug, Display, Formatter};
   12|       |    use std::fmt::Debug;
   12|       |    use std::fmt::{Debug, Display, Formatter};
   14|       |    use std::fmt::{Debug, Display, Formatter, Result as FmtResult};
   14|       |    use std::fmt::{Debug, Display, Formatter, Result as FmtResult};
   34|       |    use std::fmt::{Debug, Display, Formatter, Result};
   34|       |    use std::fmt::{Debug, Display, Formatter, Result};
    6|       |    use std::fmt::Debug;
    6|       |    use std::fmt::Debug;
    6|       |    use std::fmt::Debug;
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    6|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |    use std::fmt::{Debug, Display};
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |    use std::fmt::{Debug, Display, Formatter, Result};
    7|       |    use std::fmt::{Debug, Display, Formatter, Result as FmtResult};
    7|       |    use std::fmt::{Debug, Display, Formatter, Result as FmtResult};
    7|       |    use std::fmt::{Debug, Display, Formatter, Result as FmtResult};
    8|       |    use std::fmt::{Debug, Display, Formatter, Result};
    9|       |    use std::fmt::{Debug, Display, Formatter, Result};
    9|       |    use std::fmt::{Debug, Display, Formatter, Result};
    9|       |    use std::fmt::{Debug, Display, Formatter, Result};
    9|       |    use std::fmt::{Debug, Display, Formatter, Result};
    9|       |    use std::fmt::{Debug, Display, Formatter, Result};
    9|       |    use std::fmt::{Debug, Display, Formatter, Result};
   11|       |    use std::fmt::{Display, Formatter, Result as FmtResult};
  268|       |    impl<T: std::fmt::Display + Copy + Debug> std::fmt::Display for AVLTreeS<T> {
    9|       |    use std::fmt::Display;
    6|       |    use std::fmt::Write;
  105|      0|            K: std::hash::Hash,
   10|       |    use std::hash::Hash;
   10|       |    use std::hash::Hash;
   10|       |    use std::hash::Hash;
   10|       |    use std::hash::Hash;
   10|       |    use std::hash::Hash;
   10|       |    use std::hash::Hash;
   10|       |    use std::hash::Hash;
   10|       |    use std::hash::Hash;
   10|       |    use std::hash::Hash;
   10|       |    use std::hash::Hash;
   10|       |    use std::hash::Hash;
   10|       |    use std::hash::Hash;
   10|       |    use std::hash::Hash;
   10|       |    use std::hash::Hash;
   10|       |    use std::hash::Hash;
   11|       |    use std::hash::Hash;
   11|       |    use std::hash::{Hash, Hasher};
  125|      0|            K: std::hash::Hash,
   12|       |    use std::hash::Hash;
   12|       |    use std::hash::Hash;
   13|       |    use std::hash::Hash;
   13|       |    use std::hash::Hash;
   13|       |    use std::hash::Hash;
  181|      0|            K: std::hash::Hash,
  200|      0|            K: std::hash::Hash,
   35|       |    use std::hash::Hash;
   35|       |    use std::hash::Hash;
   42|      2|            K: std::hash::Hash,
    7|       |    use std::hash::Hash;
    7|       |    use std::hash::Hash;
    7|       |    use std::hash::Hash;
    7|       |    use std::hash::Hash;
    7|       |    use std::hash::Hash;
    7|       |    use std::hash::Hash;
    7|       |    use std::hash::{Hash, Hasher};
    8|       |    use std::hash::Hash;
    8|       |    use std::hash::Hash;
    8|       |    use std::hash::{Hash, Hasher};
    9|       |    use std::hash::Hash;
    9|       |    use std::hash::Hash;
    9|       |    use std::hash::Hash;
    9|       |    use std::hash::Hash;
    9|       |    use std::hash::Hash;
    9|       |    use std::hash::Hash;
    9|       |    use std::hash::Hash;
    6|       |    use std::hint::spin_loop;
   10|       |    use std::marker::PhantomData;
  116|     54|                _phantom: std::marker::PhantomData,
  123|     25|                _phantom: std::marker::PhantomData,
  128|      1|                _phantom: std::marker::PhantomData,
  136|     42|                _phantom: std::marker::PhantomData,
  149|      4|                _phantom: std::marker::PhantomData,
  193|      1|                _phantom: std::marker::PhantomData,
   19|     38|                _phantom: std::marker::PhantomData,
   21|     23|                _phantom: std::marker::PhantomData,
   23|     18|                _phantom: std::marker::PhantomData,
   30|     13|                _phantom: std::marker::PhantomData,
   34|     13|                _phantom: std::marker::PhantomData,
   36|      7|                _phantom: std::marker::PhantomData,
   37|     66|                _phantom: std::marker::PhantomData,
   42|      7|                _phantom: std::marker::PhantomData,
   47|      2|                _phantom: std::marker::PhantomData,
    6|       |    use std::marker::PhantomData;
   12|       |        _phantom: std::marker::PhantomData<K>,
   13|       |        _phantom: std::marker::PhantomData<K>,
   14|       |        _phantom: std::marker::PhantomData<K>,
   16|       |        _phantom: std::marker::PhantomData<K>,
  185|       |        _phantom: std::marker::PhantomData<K>,
   18|       |        _phantom: std::marker::PhantomData<K>,
   19|       |        _phantom: std::marker::PhantomData<K>,
   23|       |        _phantom: std::marker::PhantomData<(V, P)>,
   27|       |        _phantom: std::marker::PhantomData<(V, P)>,
   29|       |        _phantom: std::marker::PhantomData<(V, P)>,
   33|       |        _phantom: std::marker::PhantomData<(V, P)>,
  113|       |    impl std::ops::Add for Probability {
  131|       |    impl std::ops::Div for Probability {
  125|       |    impl std::ops::Mul for Probability {
   12|       |    use std::ops::Range;
  119|       |    impl std::ops::Sub for Probability {
    6|       |    use std::ptr::null_mut;
    7|       |    use std::rc::Rc;
    7|       |    use std::rc::Rc;
  101|       |        use std::sync::Arc;
   10|       |    use std::sync::Arc;
   10|       |    use std::sync::Arc;
   10|       |    use std::sync::Arc;
   11|       |    use std::sync::Arc;
   11|       |    use std::sync::{Arc, Mutex};
   11|       |    use std::sync::{Arc, Mutex};
   11|       |    use std::sync::{Arc, Mutex};
   11|       |    use std::sync::{Arc, Mutex};
   11|       |    use std::sync::{Arc, Mutex};
   12|       |    use std::sync::{Arc, Mutex};
   13|       |    use std::sync::{Arc, Mutex};
   14|       |    use std::sync::Arc;
   47|       |        use std::sync::{Arc, Mutex};
   60|       |        use std::sync::{Arc, Mutex};
    6|       |    use std::sync::Arc;
    6|       |    use std::sync::Arc;
    6|       |    use std::sync::Arc;
    6|       |    use std::sync::Arc;
    6|       |    use std::sync::Arc;
    6|       |    use std::sync::{Arc, RwLock};
    6|       |    use std::sync::{Arc, RwLock};
    6|       |    use std::sync::{Arc, RwLock};
    6|       |    use std::sync::{Arc, RwLock};
    6|       |    use std::sync::{Arc, RwLock};
    6|       |    use std::sync::{Arc, RwLock};
    6|       |    use std::sync::{Arc, RwLock};
    7|       |    use std::sync::Arc;
    7|       |    use std::sync::Arc;
    7|       |    use std::sync::Arc;
    7|       |    use std::sync::Arc;
    8|       |    use std::sync::{Arc, Mutex};
    8|       |    use std::sync::{Arc, Mutex};
    8|       |    use std::sync::{Arc, Mutex};
    8|       |    use std::sync::{Arc, Mutex};
    8|       |    use std::sync::{Arc, Mutex};
    8|       |    use std::sync::{Arc, Mutex};
    8|       |    use std::sync::{Arc, Mutex};
    8|       |    use std::sync::{Arc, Mutex};
    8|       |    use std::sync::{Arc, RwLock};
    9|       |    use std::sync::Arc;
    9|       |    use std::sync::Arc;
    9|       |    use std::sync::Arc;
    9|       |    use std::sync::{Arc, Mutex};
  134|     72|        edges: std::sync::Arc<ArraySeqStEphS<Edge<V>>>,
  135|     72|        edge_coins: std::sync::Arc<std::collections::HashMap<Edge<V>, bool>>,
  133|     72|        graph: std::sync::Arc<UnDirGraphMtEph<V>>,
    7|       |    use std::sync::atomic::{AtomicPtr, Ordering};
    6|       |    use std::sync::atomic::{AtomicUsize, Ordering};
    8|       |    use std::sync::atomic::{AtomicUsize, Ordering};
    6|       |    use std::sync::Mutex;
    6|       |    use std::sync::Mutex;
   10|       |    use std::thread;
   10|       |    use std::thread;
   10|       |    use std::thread;
   10|       |    use std::thread;
   12|       |    use std::thread;
   12|       |    use std::thread;
   12|       |    use std::thread;
   12|       |    use std::thread;
   12|       |    use std::thread;
   16|       |    use std::thread;
   16|       |    use std::thread;
    6|       |    use std::thread;
    6|       |    use std::thread;
    7|       |    use std::thread;
    7|       |    use std::thread;
    7|       |    use std::thread;
    7|       |    use std::thread;
    7|       |    use std::thread;
    8|       |    use std::thread;
    8|       |    use std::thread;
    9|       |    use std::thread;
    9|       |    use std::thread;
    9|       |    use std::thread;
    9|       |    use std::thread;
    9|       |    use std::thread;
    9|       |    use std::thread;
    9|       |    use std::thread;
    9|       |    use std::thread;
    9|       |    use std::thread;
  124|      0|            return std::vec::Vec::new();
  140|      0|            return std::vec::Vec::new();
  118|     56|            let step = Self::second_hash(key, table.current_size);
  238|       |        // Step 1: Compute Euler tour
  241|       |        // Step 2: Apply shortcuts
  244|       |        // Step 3: Compute tour weight
   48|    259|            if step % 2 == 0 && step < table_size - 1 {
   64|       |            // Step 1: Create word-document pairs using tagWords
   82|       |            // Step 2: Build table by inserting word-document pairs
   97|       |            // Step 3: Convert the table to have sets as values instead of single documents
  153|       |            // Store result in memo table
  155|       |            // Store result in memo table
   85|       |            // Store result in memo table
   88|       |            // Store result in memo table
   90|       |            // Store result in memo table
   92|       |            // Store result in memo table
  187|  1.00k|        table_eph.map(|s| s.to_uppercase());
  192|  1.00k|        table_mt.map(|s| s.to_uppercase());
  102|     13|            explore(graph, strategy, visited_new, frontier_new)
  106|     32|            let strategy: AdvancedQuadraticProbingStrategy<String, DefaultHashFunction> =
  111|     13|            explore(graph, strategy, visited_new, frontier_new)
  124|     23|                explore(graph, strategy, visited_new, frontier_new)
  145|     27|            let strategy: AdvancedDoubleHashingStrategy<String, DefaultHashFunction, DefaultHashFunction> =
   18|       |    /// Strategy for selecting which frontier vertices to visit next.
   19|       |        /// Strategy: Always return an odd number (works for power-of-2 sizes),
  214|       |        /// Strategy name for debugging and analysis
  245|      1|        let strategy: AdvancedLinearProbingStrategy<String, DefaultHashFunction> =
  277|       |        /// Strategy name for debugging and analysis
  304|       |        /// Strategy name for debugging and analysis
  314|      1|        let strategy: AdvancedDoubleHashingStrategy<String, DefaultHashFunction, DefaultHashFunction> =
  338|      1|        let strategy: AdvancedDoubleHashingStrategy<String, DefaultHashFunction, DefaultHashFunction> =
  340|      1|        let strategy: AdvancedQuadraticProbingStrategy<String, DefaultHashFunction> =
  365|       |        // Strategy with prime table size (17)
  372|       |        // Strategy with composite table size (16)
  382|      0|            writeln!(f, "Strategy: {}", self.strategy_name)?;
   71|     31|            let strategy: AdvancedLinearProbingStrategy<String, DefaultHashFunction> =
    8|       |//! this strategy with more sophisticated tree management when needed.
  373|      1|        let strategy_composite: AdvancedQuadraticProbingStrategy<String, DefaultHashFunction> =
   18|       |        pub strategy_name: String,
   18|       |        pub strategy_name: String,
  216|      1|        fn strategy_name(&self) -> String { "AdvancedLinearProbing".to_string() }
  279|      2|        fn strategy_name(&self) -> String { "AdvancedDoubleHashing".to_string() }
  306|      2|        fn strategy_name(&self) -> String { format!("AdvancedQuadraticProbing(c1={}, c2={})", self.c1, self.c2) }
   31|      2|        fn strategy_name(&self) -> String { format!("LinearProbing({})", self.base_hash.description()) }
   35|       |        fn strategy_name(&self) -> String;
   38|      3|        fn strategy_name(&self) -> String {
   39|      5|        fn strategy_name(&self) -> String {
  366|      1|        let strategy_prime: AdvancedQuadraticProbingStrategy<String, DefaultHashFunction> =
   22|       |    /// Strengthened return type: (max_sum, max_prefix, max_suffix, total).
   23|       |    /// Strengthened return type: (max_sum, max_prefix, max_suffix, total).
   24|       |    type StrengthResult = (Option<i32>, i32, i32, i32);
   24|       |    type StrengthResult = (Option<i32>, i32, i32, i32);
  195|       |    // String slice implementation
  357|      1|            strategy_name: String,
   54|       |    /// String hash function from Example 47.1 in textbook
   10|       |    pub struct AdjMatrixGraphStEph {
   10|       |    pub struct AdjSeqGraphStEph {
   10|       |    pub struct ArraySetStEph<T: StT + Ord> {
   10|       |    pub struct AVLTreeSetStPer<T: StT + Ord> {
   10|       |    pub struct DoubleHashingStrategy<K: StT, H1: HashFunClone<K>, H2: HashFunClone<K>> {
   10|       |    pub struct LinearProbingStrategy<K: StT, H: HashFunClone<K>> {
   10|       |    pub struct QuadraticProbingStrategy<K: StT, H: HashFunClone<K>> {
  110|       |    pub struct UniversalIntegerHashFunction {
   11|       |    pub struct AdjMatrixGraphStPer {
   11|       |    pub struct AdjSeqGraphStPer {
   11|       |    pub struct BSTPlainStEph<T: StT + Ord> {
   11|       |    pub struct EdgeSetGraphStEph<V: StT + Ord> {
   11|       |    pub struct NodeE<T: StT> {
   11|       |    pub struct NodeP<T: StT> {
   11|       |    pub struct PQMinResult<V: StT + Ord, P: StT + Ord> {
   11|       |    pub struct SearchResult<V: StT + Ord> {
   12|       |    pub struct ArraySeqS<T> {
   12|       |    pub struct ArraySeqStEphS<T: StT> {
   12|       |    pub struct ArraySeqStPerS<T: StT> {
   12|       |    pub struct AVLTreeSetStEph<T: StT + Ord> {
   12|       |    pub struct BalancedTreePQ<T: StT + Ord> {
   12|       |    pub struct BinaryHeapPQ<T: StT + Ord> {
   12|       |    pub struct EdgeSetGraphStPer<V: StT + Ord> {
   12|       |    pub struct LinProbFlatHashTableStEph;
   12|       |    pub struct MatrixDim {
   12|       |    pub struct MatrixDim {
   12|       |    pub struct NestedHashTable<K: StT, V: StT> {
   12|       |    pub struct OrderedSetStPer<T: StT + Ord> {
   12|       |    pub struct SeparateChainingHashTable<K, V, H, E>
   12|       |    pub struct SortedListPQ<T: StT + Ord> {
   12|       |    pub struct UnsortedListPQ<T: StT + Ord> {
  134|       |    pub struct AVLTreeSeqMtPerS<T: StTInMtT> {
  135|       |    pub struct AVLTreeSeqStPerS<T: StT> {
   13|       |    pub struct AdjTableGraphMtPer<V: StTInMtT + Ord + 'static> {
   13|       |    pub struct AdjTableGraphStEph<V: StT + Ord> {
   13|       |    pub struct AdjTableGraphStPer<V: StT + Ord> {
   13|       |    pub struct AdvancedDoubleHashingStrategy<K: StT, H1: HashFunClone<K>, H2: HashFunClone<K>> {
   13|       |    pub struct AdvancedLinearProbingStrategy<K: StT, H: HashFunClone<K>> {
   13|       |    pub struct AdvancedQuadraticProbingStrategy<K: StT, H: HashFunClone<K>> {
   13|       |    pub struct BSTSetAVLMtEph<T: StTInMtT + Ord> {
   13|       |    pub struct BSTSetBBAlphaMtEph<T: StTInMtT + Ord> {
   13|       |    pub struct BSTSetPlainMtEph<T: StTInMtT + Ord> {
   13|       |    pub struct BSTSetRBMtEph<T: StTInMtT + Ord> {
   13|       |    pub struct BSTSetSplayMtEph<T: StTInMtT + Ord> {
   13|       |    pub struct BSTSetTreapMtEph<T: StTInMtT + Ord> {
   13|       |    pub struct ChainEntry<Key, Value, Container> {
   13|       |    pub struct Node<Key, Value> {
   13|       |    pub struct OrderedSetMtEph<T: MtKey> {
   13|       |    pub struct OrderedSetStEph<T: StT + Ord> {
   13|       |    pub struct OrderedTableStEph<K: StT + Ord, V: StT> {
   13|       |    pub struct OrderedTableStPer<K: StT + Ord, V: StT> {
   13|       |    pub struct QuadProbFlatHashTableStEph;
   13|       |    pub struct SearchResult<V: StT + Ord> {
   13|       |    pub struct Set<T> {
   13|       |    pub struct TableStEph<K: StT + Ord, V: StT> {
   13|       |    pub struct TableStPer<K: StT + Ord, V: StT> {
  141|       |    pub struct DefaultKeyEquality;
  146|       |    pub struct HeapsortComparison<T: StT + Ord> {
  149|       |    pub struct CaseInsensitiveStringEquality;
   14|       |    pub struct AVLTreeNode<T: StT> {
   14|       |    pub struct DirGraphStEph<V: StT + Hash> {
   14|       |    pub struct DoubleHashFlatHashTableStEph;
   14|       |    pub struct EdgeSetGraphMtPer<V: StTInMtT + Ord + 'static> {
   14|       |    pub struct KeyProb<T: StT> {
   14|       |    pub struct KeyProb<T: StT> {
   14|       |    pub struct LabDirGraphStEph<V: StT + Hash, L: StT + Hash> {
   14|       |    pub struct LabUnDirGraphStEph<V: HashOrd, L: StT + Hash> {
   14|       |    pub struct MatrixDim {
   14|       |    pub struct MatrixDim {
   14|       |    pub struct MinEditDistStEphS<T: StT> {
   14|       |    pub struct MinEditDistStPerS<T: StT> {
   14|       |    pub struct PQMinResult<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static> {
   14|       |    pub struct PQMinResult<V: StT + Ord, P: StT + Ord> {
   14|       |    pub struct SpinLock {
   14|       |    pub struct SubsetSumStEphS<T: StT> {
   14|       |    pub struct SubsetSumStPerS<T: StT> {
   14|       |    pub struct UnDirGraphStEph<V: StT + Hash> {
  156|       |    pub struct UniversalIntegerHashFamily {
   15|       |    pub struct AugOrderedTableStEph<K: StT + Ord, V: StT, F>
   15|       |    pub struct AugOrderedTableStPer<K: StT + Ord, V: StT, F>
   15|       |    pub struct KeyProb<T: MtVal> {
   15|       |    pub struct KeyProb<T: MtVal> {
   15|       |    pub struct MinEditDistMtPerS<T: MtVal> {
   15|       |    pub struct PQMinResult<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static> {
   15|       |    pub struct Relation<A, B> {
   15|       |    pub struct SubsetSumMtPerS<T: MtVal> {
   16|       |    pub struct ArraySeqMtEphS<T: StTInMtT> {
   16|       |    pub struct ArraySeqMtPerS<T: StTInMtT> {
   16|       |    pub struct BalBinNode<T: StT> {
   16|       |    pub struct Mapping<A, B> {
   16|       |    pub struct MinEditDistMtEphS<T: MtVal> {
   16|       |    pub struct OrderedTableMtEph<K: MtKey, V: MtVal> {
   16|       |    pub struct OrderedTableMtPer<K: StTInMtT + Ord, V: StTInMtT> {
   16|       |    pub struct SearchResult<V: StTInMtT + Ord + 'static> {
   16|       |    pub struct SubsetSumMtEphS<T: MtVal> {
   16|       |    pub struct TableMtEph<K: MtKey, V: MtVal> {
   17|       |    pub struct ArraySetEnumMtEph {
   17|       |    pub struct ComprehensiveClusteringAnalysis {
   17|       |    pub struct DirGraphMtEph<V: StT + MtT + Hash + 'static> {
   17|       |    pub struct LinkedListStEphS<T: StT> {
   17|       |    pub struct LinkedListStPerS<T: StT> {
   17|       |    pub struct LoadAndSize {
   17|       |    pub struct ProbeSequenceVisualization {
   17|       |    pub struct UnDirGraphMtEph<V: StT + MtT + Hash + 'static> {
  181|       |    pub struct AVLTreeSeqIterStEph<'a, T: StT> {
  182|       |    pub struct ProbeSequenceGenerator<K, H1: HashFunction<K>, H2: HashFunction<K>> {
   18|       |    pub struct LabDirGraphMtEph<V: StT + MtT + Hash + 'static, L: StTInMtT + Hash + 'static> {
   18|       |    pub struct LabUnDirGraphMtEph<V: HashOrd + MtT + 'static, L: StTInMtT + Hash + 'static> {
   18|       |    pub struct MathSeqS<T: StT> {
   19|       |    pub struct AVLTreeNode<T: Copy + Debug> {
   19|       |    pub struct AVLTreeSetMtEph<T: StTInMtT + Ord + 'static> {
   19|       |    pub struct AVLTreeSetMtPer<T: StTInMtT + Ord + 'static> {
   19|       |    pub struct MatrixChainStEphS {
   19|       |    pub struct MatrixChainStPerS {
  207|       |    pub struct Edge<V: StT>(pub V, pub V);
  209|       |    pub struct LoadFactorManager {
   20|       |    pub struct ConcurrentStackMt<T: StTInMtT> {
   20|       |    pub struct SelectAll;
   21|       |    pub struct AugOrderedTableMtEph<K: MtKey, V: MtVal, F: MtReduceFn<V>> {
   21|       |    pub struct ChainList<Key, Value> {
   21|       |    pub struct ClosurePriority<V: StT + Ord, P: StT + Ord, F: Fn(&V) -> P> {
   21|       |    pub struct MatrixChainMtEphS {
   21|       |    pub struct MatrixChainMtPerS {
   21|       |    pub struct OBSTStEphS<T: StT> {
   21|       |    pub struct OBSTStPerS<T: StT> {
  221|       |    pub struct AVLTreeSeqMtPerIter<T: StTInMtT> {
  223|       |    pub struct LabEdge<V: StT, L: StT + Hash>(pub V, pub V, pub L);
   22|       |    pub struct OBSTMtEphS<T: MtVal> {
   22|       |    pub struct OBSTMtPerS<T: MtVal> {
   22|       |    pub struct PrimaryClusteringMetrics {
   23|       |    pub struct HashTable<Key, Value, Entry, Metrics> {
   24|       |    pub struct DocumentIndex {
   24|       |    pub struct DoubleHashingMetrics {
   24|       |    pub struct LeftistHeapPQ<T: StT + Ord> {
  251|       |    pub struct HashTableStats {
  254|       |    pub struct AVLTreeSeqStPerIter<'a, T: StT> {
   25|       |    pub struct ClosurePriority<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static, F: Fn(&V) -> P> {
   25|       |    pub struct Pair<K, V>(pub K, pub V);
   25|       |    pub struct SecondaryClusteringMetrics {
   25|       |    pub struct SelectAll;
   25|       |    pub struct SelectOne;
   26|       |    pub struct ParamBST<T: MtKey> {
   26|       |    pub struct SelectAll;
   27|       |    pub struct BottomUpDPStEphS {
   27|       |    pub struct BottomUpDPStPerS {
   27|       |    pub struct ClosurePriority<
   27|       |    pub struct ClosurePriority<V: StT + Ord, P: StT + Ord, F: Fn(&V) -> P> {
   27|       |    pub struct Probability(pub f64);
   27|       |    pub struct TopDownDPStEphS {
   27|       |    pub struct TopDownDPStPerS {
  283|       |    pub struct QueryBuilder<'a> {
  285|       |    pub struct AVLTreeSeqIter<'a, T: Copy + Debug> {
   28|       |    pub struct ParamBST<T: StT + Ord> {
   29|       |    pub struct BottomUpDPMtEphS {
   29|       |    pub struct BottomUpDPMtPerS {
   29|       |    pub struct ParamTreap<T: MtKey> {
   29|       |    pub struct TopDownDPMtEphS {
   29|       |    pub struct TopDownDPMtPerS {
  301|       |    pub struct HashTableUtils;
   30|       |    pub struct SelectOne;
   31|       |    pub struct ClusteringPerformanceImpact {
   31|       |    pub struct TextbookExampleResults {
   32|       |    pub struct ArraySeqMtEphSliceS<T: StT + Send + Sync> {
   32|       |    pub struct BSTSplayStEph<T: StT + Ord> {
   33|       |    pub struct SelectOne;
   33|       |    pub struct Triple<A, B, C>(pub A, pub B, pub C);
   34|       |    pub struct BSTAVLStEph<T: StT + Ord> {
   34|       |    pub struct BSTBBAlphaStEph<T: StT + Ord> {
   34|       |    pub struct BSTKeyValueStEph<K: StT + Ord, V: StT> {
   34|       |    pub struct BSTSizeStEph<T: StT + Ord> {
   34|       |    pub struct BSTSplayMtEph<T: StTInMtT + Ord> {
   34|       |    pub struct BSTTreapStEph<T: StT + Ord> {
  361|       |            pub struct $name;
   36|       |    pub struct BSTAVLMtEph<T: StTInMtT + Ord> {
   36|       |    pub struct BSTBBAlphaMtEph<T: StTInMtT + Ord> {
   36|       |    pub struct BSTTreapMtEph<T: StTInMtT + Ord> {
   36|       |    pub struct RelativePrimeValidator;
   36|       |    pub struct TweetQueryExamples {
   37|       |    pub struct PrimeValidator;
  383|       |    pub struct HashFunctionTester;
   38|       |    pub struct AVLTreeSeqStEphS<T: StT> {
   39|       |    pub struct AllPairsResultStPerInt {
   39|       |    pub struct SSSPResultStPerInt {
   39|       |    pub struct StackStEph<T: StT> {
   40|       |    pub struct AllPairsResultStEphInt {
   40|       |    pub struct BSTRBStEph<T: StT + Ord> {
   40|       |    pub struct FlatHashTable<K: StT, V: StT, P: ProbeSequence<K>> {
   40|       |    pub struct SSSPResultStEphInt {
   40|       |    pub struct UnionFind<V: StT + Hash> {
   41|       |    pub struct AllPairsResultStPerFloat {
   42|       |    pub struct AllPairsResultStEphFloat {
   42|       |    pub struct BSTPlainMtEph<T: StTInMtT + Ord> {
   42|       |    pub struct BSTRBMtEph<T: StTInMtT + Ord> {
   42|       |    pub struct DefaultHashFunction;
   42|       |    pub struct SSSPResultStEphFloat {
   42|       |    pub struct SSSPResultStPerFloat {
   43|       |    pub struct AVLTreeS<T: Copy + Debug> {
   43|       |    pub struct KeyVal<K, V> {
   44|       |    pub struct ProbeSequenceAnalyzer {
   45|       |    pub struct VecChainedHashTableStEph;
   51|       |    pub struct ClusteringComparison {
   51|       |    pub struct SumOp<T>(PhantomData<T>);
   55|       |    pub struct LinkedListChainedHashTableStEph;
   57|       |    pub struct StringPositionHashFunction;
   58|       |    pub struct PrimTreeSeqStS<T: StT> {
   61|       |    pub struct MaxOp<T>(PhantomData<T>);
   63|       |    pub struct ClusteringAnalyzer {
   65|       |    pub struct CountOp<T>(PhantomData<T>);
   74|       |    pub struct BSTReducedStEph<K: StT + Ord, V: StT, R: StT, Op: ReduceOp<V, R>> {
   79|       |    /// Struct Chained Hash Table implementation.
   80|       |    pub struct StructChainedHashTableStEph;
   81|       |    pub struct PolynomialHashFunction {
    5|       |pub mod StructChainedHashTable {
  101|       |        for StructChainedHashTableStEph
   84|       |        for StructChainedHashTableStEph
    5|       |//! Data structure for storing the result of all-pairs shortest path algorithms
    5|       |//! Data structure for storing the result of all-pairs shortest path algorithms
    5|       |//! Data structure for storing the result of all-pairs shortest path algorithms
    5|       |//! Data structure for storing the result of all-pairs shortest path algorithms
    5|       |//! Data structure for storing the result of single-source shortest path algorithms
    5|       |//! Data structure for storing the result of single-source shortest path algorithms
    5|       |//! Data structure for storing the result of single-source shortest path algorithms
    5|       |//! Data structure for storing the result of single-source shortest path algorithms
  100|     30|                P: StT + Ord,
  104|       |    impl<V: StT + Hash> UnDirGraphStEph<V> {
  107|       |    impl<K: StT, H1: HashFunClone<K>, H2: HashFunClone<K>> AdvancedDoubleHashingStrategy<K, H1, H2> {
  108|       |    impl<K: StT + Ord, V: StT, R: StT, Op: ReduceOp<V, R>> Default for BSTreeReduced<K, V, R, Op> {
  109|       |    impl<T: StT> BalBinTreeStEphTrait<T> for BalBinTree<T> {
  112|       |    impl<Key: StT, Value: StT, Metrics: Default> 
  112|       |    impl<K: StT, H: HashFunClone<K>> AdvancedQuadraticProbingStrategy<K, H> {
  112|       |    impl<K: StT + Ord, V: StT, R: StT, Op: ReduceOp<V, R>> BSTReducedStEph<K, V, R, Op> {
  113|       |    impl<T: StT> MathSeqS<T> {
  115|       |    impl<T: StT> Display for SubsetSumStPerS<T> {
  116|       |    impl<T: StT + Send + Sync + 'static> ArraySeqMtEphSliceTrait<T> for ArraySeqMtEphSliceS<T> {
  118|       |    impl<T: StT> Display for MinEditDistStPerS<T> {
  124|       |    impl<T: StT + Send> MtT for std::sync::Mutex<T> {
  124|       |    impl<T: StT> std::fmt::Display for LinkedListStEphS<T> {
  125|       |    impl<T: StT> PrimTreeSeqStTrait<T> for PrimTreeSeqStS<T> {
  126|       |    impl<T: StT> IntoIterator for SubsetSumStPerS<T> {
  126|       |    impl<V: StT + Hash, L: Clone + Display + Debug + Eq + Hash> Display for LabDirGraphStEph<V, L> {
  130|       |    impl<T: StT> IntoIterator for MinEditDistStPerS<T> {
  130|       |    impl<V: StT + Hash> Debug for UnDirGraphStEph<V> {
  132|       |    impl<V: StT + Hash, L: Clone + Display + Debug + Eq + Hash> Debug for LabDirGraphStEph<V, L> {
  133|       |    impl<A: StT + Send + Sync, B: StT + Send + Sync> MtT for Pair<A, B> {
  133|       |    impl<T: StT> Display for SubsetSumStEphS<T> {
  133|       |    impl<T: StT> IntoIterator for &SubsetSumStPerS<T> {
  135|       |    impl<T: StT> Display for OBSTStPerS<T> {
  139|       |    impl<V: StT + Hash> Display for UnDirGraphStEph<V> {
  140|       |    impl<T: StT> ArraySeqStPerTrait<T> for ArraySeqStPerS<T> {
  142|       |    impl<T: StT> AVLTreeSeqStEphTrait<T> for AVLTreeSeqStEphS<T> {
  142|       |    impl<T: StT> std::fmt::Debug for LinkedListStEphS<T> {
  143|       |    impl<V: StT + Hash> PartialEq for UnDirGraphStEph<V> {
  144|       |    impl<T: StT> IntoIterator for SubsetSumStEphS<T> {
  145|       |    impl<T: StT + Ord> Default for ArraySetStEph<T> {
  146|       |    impl<T: StT> IntoIterator for OBSTStPerS<T> {
  146|       |    impl<T: StT + Ord> ParamBSTTrait<T> for ParamBST<T> {
  146|       |    impl<V: StT + Hash> Eq for UnDirGraphStEph<V> {}
  148|       |    impl<T: StT> IntoIterator for &MinEditDistStPerS<T> {
  148|       |    impl<T: StT + Ord> BSTSplayStEphTrait<T> for BSTSplayStEph<T> {
  149|       |    impl<T: StT + Ord> UnsortedListPQ<T> {
   14|       |    impl<Key: StT, Value: StT, Metrics: Default> 
   14|       |        K: StT,
  150|       |    impl<T: StT> Display for MinEditDistStEphS<T> {
  151|       |    impl<T: StT> IntoIterator for MathSeqS<T> {
  151|       |    impl<T: StT> IntoIterator for &SubsetSumStEphS<T> {
  151|       |    impl<V: StT + Hash> Debug for DirGraphStEph<V> {
  155|       |    impl<T: StT + Ord> HeapsortComparison<T> {
  157|       |    impl<T: StT + Hash> MathSeqTrait<T> for MathSeqS<T> {
  158|       |    impl<T: StT> IntoIterator for &mut SubsetSumStEphS<T> {
   15|       |    impl<Key: StT, Value: StT, Metrics: Default> 
   15|       |    impl<K: StT, H: HashFunClone<K>> LinearProbingStrategy<K, H> {
   15|       |        V: StT,
  160|       |    impl<T: StT> Display for KeyProb<T> {
  160|       |    impl<T: StT> PartialEq for LinkedListStEphS<T> {
  160|       |    impl<V: StT + Hash> Display for DirGraphStEph<V> {
  162|       |    impl<T: StT> IntoIterator for MinEditDistStEphS<T> {
  164|       |    impl<T: StT> Eq for KeyProb<T> {}
  164|       |    impl<V: StT + Hash> PartialEq for DirGraphStEph<V> {
  165|       |    impl<V: StT + Hash> UnionFindStEphTrait<V> for UnionFind<V> {
  166|       |    impl<T: StT> Display for OBSTStEphS<T> {
  167|       |    impl<T: StT> AVLTreeSeqStPerTrait<T> for AVLTreeSeqStPerS<T> {
  167|       |    impl<V: StT + Hash> Eq for DirGraphStEph<V> {}
   16|       |    impl<K: StT, H1: HashFunClone<K>, H2: HashFunClone<K>> DoubleHashingStrategy<K, H1, H2> {
   16|       |    impl<T: StT + Clone> ReduceContractStEphTrait<T> for ArraySeqStEphS<T> {
   16|       |    impl<T: StT + Clone> ScanContractStEphTrait<T> for ArraySeqStEphS<T> {
   16|       |    impl<V: StT + Hash + Ord> WeightedUnDirGraphStEphInt<V> {
   16|       |    impl<V: StT + Hash> WeightedDirGraphStEphInt<V> {
  171|       |    impl<T: StT> std::fmt::Display for LinkedListStPerS<T> {
  174|       |    impl<T: StT + Ord> BinaryHeapPQTrait<T> for BinaryHeapPQ<T> {
  177|       |    impl<T: StT> ArraySeqStEphTrait<T> for ArraySeqStEphS<T> {
  177|       |    impl<T: StT> IntoIterator for OBSTStEphS<T> {
  177|       |    impl<T: StT + Ord> Default for AVLTreeSetStEph<T> {
  178|       |    impl<K: StT + Ord, V: StT> BSTKeyValueStEphTrait<K, V> for BSTKeyValueStEph<K, V> {
  178|       |    impl<T: StT> Eq for LinkedListStEphS<T> {}
  178|       |    impl<T: StT + Ord> Default for UnsortedListPQ<T> {
  179|       |    impl<T: StT + Ord> BalancedTreePQ<T> {
   17|       |    impl<K: StT, H: HashFunClone<K>> QuadraticProbingStrategy<K, H> {
   17|       |    impl<T: StT + Ord> OrderStatSelectStEphTrait<T> for ArraySeqStEphS<T> {
   17|       |    impl<T: StT + Ord> OrderStatSelectStPerTrait<T> for ArraySeqStPerS<T> {
  180|       |    impl<T: StT> IntoIterator for &MinEditDistStEphS<T> {
  180|       |    impl<T: StT + Ord> BSTTreapStEphTrait<T> for BSTTreapStEph<T> {
  181|       |    impl<T: StT + Ord> Clone for AVLTreeSetStEph<T> {
  182|       |    impl<T: StT + Ord> Display for UnsortedListPQ<T> {
  184|       |    impl<T: StT + Hash> SetStEphTrait<T> for Set<T> {
  185|       |    impl<T: StT + Ord> Default for AVLTreeSetStPer<T> {
  189|       |    impl<T: StT + Ord> Clone for AVLTreeSetStPer<T> {
  189|       |    impl<T: StT + Ord> fmt::Debug for AVLTreeSetStEph<T> {
  189|       |    impl<T: StT> std::fmt::Debug for LinkedListStPerS<T> {
  189|       |    impl<V: StT + MtT + Hash> UnDirGraphMtEph<V> {
   18|       |    impl<K: StT, V: StT> Display for Entry<K, V> {
   18|       |    impl<K: StT, V: StT> NestedHashTable<K, V> {
   18|       |    impl<T: StT> ArraySeqStEphS<T> {
   18|       |    impl<T: StT> ArraySeqStPerS<T> {
  197|       |    impl<T: StT + Ord> std::fmt::Display for AVLTreeSetStPer<T> {
  198|       |    impl<T: StT> Display for KeyProb<T> {
  199|       |    impl<T: StT> IntoIterator for &mut MinEditDistStEphS<T> {
  199|       |    impl<T: StT + Ord> SortedListPQ<T> {
  202|       |    impl<T: StT> Eq for KeyProb<T> {}
  202|       |    impl<T: StT + Ord> fmt::Display for AVLTreeSetStEph<T> {
  204|       |    impl<T: StT + Ord> LeftistHeapPQTrait<T> for LeftistHeapPQ<T> {
  205|       |    impl<T: StT + Ord> BSTAVLStEphTrait<T> for BSTAVLStEph<T> {
  206|       |    impl<K: StT, H: HashFunClone<K>> ProbeSequence<K> for AdvancedLinearProbingStrategy<K, H> {
  207|       |    impl<T: StT> PartialEq for LinkedListStPerS<T> {
  209|       |    impl<V: StT> std::fmt::Display for Edge<V> {
   20|       |    impl<T: StT + Ord> Node<T> {
   20|       |    impl<V: StT + MtT + Hash + 'static> WeightedDirGraphMtEphFloat<V> {
   20|       |    impl<V: StT + MtT + Hash + 'static> WeightedDirGraphMtEphInt<V> {
  210|       |    impl<T: StT> PartialEq for AVLTreeSeqStPerS<T> {
  213|       |    impl<V: StT> From<(V, V)> for Edge<V> {
  215|       |    impl<V: StT + MtT + Hash + 'static> std::fmt::Debug for UnDirGraphMtEph<V> {
  216|       |    impl<V: StT + MtT + Hash, L: StTInMtT + Hash> Display for LabDirGraphMtEph<V, L> {
  217|       |    impl<T: StT + Ord> UnsortedListPQ<T> {
  217|       |    impl<V: StT> From<Edge<V>> for (V, V) {
  219|       |    impl<K: StT, H: HashFunClone<K>> Display for AdvancedLinearProbingStrategy<K, H> {
   21|       |    impl<K: StT + Ord, V: StT> Node<K, V> {
   21|       |    impl<T: StT + Ord> MergeSortStTrait<T> for ArraySeqStPerS<T> {
   21|       |    impl<T: StT + Ord> Node<T> {
   21|       |    impl<T: StT + Ord> Node<T> {
   21|       |    impl<T: StT + Ord> Node<T> {
   21|       |    impl<V: StT + Ord> SelectionStrategy<V> for SelectAll {
  222|       |    impl<V: StT + MtT + Hash, L: StTInMtT + Hash> Debug for LabDirGraphMtEph<V, L> {
  223|       |    impl<T: StT> Eq for AVLTreeSeqStPerS<T> {}
  224|       |    impl<T: StT + Ord> BSTRBStEphTrait<T> for BSTRBStEph<T> {
  224|       |    impl<V: StT + MtT + Hash + 'static> std::fmt::Display for UnDirGraphMtEph<V> {
  225|       |    impl<T: StT> Clone for AVLTreeSeqStPerS<T> {
  225|       |    impl<T: StT> Eq for LinkedListStPerS<T> {}
  225|       |    impl<V: StT, L: StT + Hash> std::fmt::Display for LabEdge<V, L> {
  226|       |    impl<V: StT + Hash> Default for UnionFind<V> {
  227|       |    impl<T: StT> LinkedListStPerTrait<T> for LinkedListStPerS<T> {
  227|       |    impl<T: StT + Ord> BSTBBAlphaStEphTrait<T> for BSTBBAlphaStEph<T> {
  228|       |    impl<V: StT + MtT + Hash + 'static> PartialEq for UnDirGraphMtEph<V> {
   22|       |    impl<T: StT> BalBinNode<T> {
   22|       |    impl<T: StT> LinkedListStEphS<T> {
   22|       |    impl<T: StT + Ord> Node<T> {
   22|       |    impl<T: StT + Send + Sync> Inner<T> {
  231|       |    impl<V: StT, L: StT + Hash> From<(V, V, L)> for LabEdge<V, L> {
  231|       |    impl<V: StT + MtT + Hash + 'static> Eq for UnDirGraphMtEph<V> {}
  233|       |    impl<T: StT> std::fmt::Debug for AVLTreeSeqStPerS<T> {
  235|       |    impl<T: StT + Ord> BSTSizeStEphTrait<T> for BSTSizeStEph<T> {
  235|       |    impl<V: StT, L: StT + Hash> From<LabEdge<V, L>> for (V, V, L) {
   23|       |            V: StT + Hash + Ord,
  240|       |    impl<T: StT> AVLTreeSeqStPerS<T> {
  244|       |    impl<T: StT + Ord> Default for SortedListPQ<T> {
  248|       |    impl<T: StT + Ord> Display for SortedListPQ<T> {
   24|       |    impl<K: StT, H: HashFunClone<K>> ProbeSequence<K> for LinearProbingStrategy<K, H> {
   24|       |    impl<T: StT> AVLTreeNode<T> {
   24|       |    impl<T: StT + Send + Sync + Clone + 'static> ReduceContractMtEphTrait<T> for ArraySeqMtEphS<T> {
   24|       |    impl<T: StT + Send + Sync + Clone + 'static> ScanContractMtEphTrait<T> for ArraySeqMtEphS<T> {
  251|       |    impl<T: StT> LinkedListStEphTrait<T> for LinkedListStEphS<T> {
   25|       |    impl<K: StT + Ord, V: StT, R: StT> Node<K, V, R> {
  266|       |    impl<K: StT, H1: HashFunClone<K>, H2: HashFunClone<K>> ProbeSequence<K> for AdvancedDoubleHashingStrategy<K, H1, H2> {
   26|       |    impl<K: StT, H1: HashFunClone<K>, H2: HashFunClone<K>> ProbeSequence<K> for DoubleHashingStrategy<K, H1, H2> {
   26|       |    impl<T: StT + Ord + Send + Sync + 'static> MergeSortMtTrait<T> for ArraySeqMtPerS<T> {
   26|       |    impl<V: StT + Ord, P: StT + Ord, F: Fn(&V) -> P> ClosurePriority<V, P, F> {
   26|       |    impl<V: StT + Ord> SelectionStrategy<V> for SelectOne {
   26|       |            V: StT + MtT + Hash + Ord + 'static,
  273|       |    impl<T: StT + Ord> BinaryHeapPQ<T> {
  275|       |    impl<T: StT + Ord> Default for BalancedTreePQ<T> {
  277|       |    impl<K: StT + Ord, V: StT, R: StT, Op: ReduceOp<V, R>> BSTReducedStEphTrait<K, V, R, Op>
  279|       |    impl<T: StT + Ord> Display for BalancedTreePQ<T> {
   27|       |    impl<T: StT + Ord> Node<T> {
   27|       |            R: StT + MtT + 'static,
  280|       |    impl<T: StT + Ord> Clone for OrderedSetStPer<T> {
  282|       |    impl<K: StT, H1: HashFunClone<K>, H2: HashFunClone<K>> Display for AdvancedDoubleHashingStrategy<K, H1, H2> {
  283|       |    impl<T: StT + Ord> SortedListPQ<T> {
   28|       |    impl<V: StT + Ord> SelectionStrategy<V> for SelectAll {
   28|       |        K: StT,
  295|       |    impl<K: StT, H: HashFunClone<K>> ProbeSequence<K> for AdvancedQuadraticProbingStrategy<K, H> {
  296|       |    impl<K: StT + Display, V: StT + Display> Display for NestedHashTable<K, V> {
  299|       |    impl<T: StT + Ord> LeftistHeapPQ<T> {
   29|       |        V: StT,
  302|       |    impl<T: StT + Ord> Clone for OrderedSetStEph<T> {
  309|       |    impl<K: StT, H: HashFunClone<K>> Display for AdvancedQuadraticProbingStrategy<K, H> {
   30|       |    impl<K: StT, H: HashFunClone<K>> AdvancedLinearProbingStrategy<K, H> {
  314|       |    impl<T: StT + Ord> BalancedTreePQ<T> {
   31|       |    impl<K: StT, H: HashFunClone<K>> ProbeSequence<K> for QuadraticProbingStrategy<K, H> {
   31|       |    impl<T: StT + Ord> Chapter36StTrait<T> for ArraySeqStEphS<T> {
  324|       |    impl<K: StT + Ord, V: StT, F> AugOrderedTableStEph<K, V, F>
   32|       |    impl<V: StT + Ord, P: StT + Ord, F: Fn(&V) -> P> ClosurePriority<V, P, F> {
  331|       |    impl<T: StT + Ord> Default for BinaryHeapPQ<T> {
  335|       |    impl<T: StT + Ord> Display for BinaryHeapPQ<T> {
  336|       |    impl<K: StT + Display, V: StT + Display, P: ProbeSequence<K> + Clone> Display for FlatHashTable<K, V, P> {
  339|       |    impl<T: StT> PartialEq for AVLTreeSeqStEphS<T> {
   33|       |    impl<T: StT + Ord + Send + Sync> Chapter36MtTrait<T> for ArraySeqMtEphS<T> {
   33|       |    impl<T: StT + Ord + Send + Sync + 'static> Chapter36MtSliceTrait<T> for ArraySeqMtEphSliceS<T> {
  342|       |    impl<K: StT + Ord, V: StT> Clone for OrderedTableStPer<K, V> {
  342|       |    impl<V: StT + MtT + Hash + 'static> std::fmt::Debug for DirGraphMtEph<V> {
  351|       |    impl<V: StT + MtT + Hash + 'static> std::fmt::Display for DirGraphMtEph<V> {
  353|       |    impl<T: StT> Eq for AVLTreeSeqStEphS<T> {}
  355|       |    impl<T: StT> Clone for AVLTreeSeqStEphS<T> {
  355|       |    impl<V: StT + MtT + Hash + 'static> PartialEq for DirGraphMtEph<V> {
  357|       |    impl<K: StT + Ord, V: StT, F> Display for AugOrderedTableStEph<K, V, F>
  358|       |    impl<K: StT + Ord, V: StT> Clone for OrderedTableStEph<K, V> {
  358|       |    impl<V: StT + MtT + Hash + 'static> Eq for DirGraphMtEph<V> {}
  359|       |    impl<K: StT + Ord, V: StT, F> AugOrderedTableStPer<K, V, F>
   35|       |    impl<V: StT + Ord, P: StT + Ord, F: Fn(&V) -> P> PriorityFn<V, P> for ClosurePriority<V, P, F> {
   35|       |    impl<V: StT + Ord> SelectionStrategy<V> for SelectOne {
  364|       |    impl<T: StT + Ord> BalancedTreePQ<T> {
  365|       |    impl<T: StT + Ord> Default for LeftistHeapPQ<T> {
  368|       |    impl<T: StT + Send + Sync> Clone for ArraySeqMtEphSliceS<T> {
  369|       |    impl<T: StT + Ord> Display for LeftistHeapPQ<T> {
  370|       |    impl<T: StT + Ord> BinaryHeapPQ<T> {
  371|       |    impl<K: StT + Ord, V: StT, F> Debug for AugOrderedTableStEph<K, V, F>
  377|       |    impl<T: StT + Send + Sync + 'static> PartialEq for ArraySeqMtEphSliceS<T> {
  391|       |    impl<T: StT + Send + Sync + 'static> Eq for ArraySeqMtEphSliceS<T> {}
  392|       |    impl<K: StT + Ord, V: StT, F> Display for AugOrderedTableStPer<K, V, F>
  393|       |    impl<T: StT + Send + Sync> Debug for ArraySeqMtEphSliceS<T> {
  402|       |    impl<T: StT + Send + Sync> Display for ArraySeqMtEphSliceS<T> {
  406|       |    impl<K: StT + Ord, V: StT, F> Debug for AugOrderedTableStPer<K, V, F>
  410|      2|            U: StT + Ord,
   41|       |    impl<T: StT> PartialEq for ArraySeqStPerS<T> {
   41|       |    impl<V: StT + Ord, P: StT + Ord, F: Fn(&V) -> P> PriorityFn<V, P> for ClosurePriority<V, P, F> {
   42|       |    impl<T: StT + Ord> BSTPlainStEph<T> {
   42|       |    impl<T: StT> SubsetSumStPerS<T> {
   42|       |    impl<V: StT + Hash + Ord> PQEntry<V> {
   43|       |    impl<T: StT + Ord> ArraySetStEphTrait<T> for ArraySetStEph<T> {
   43|       |    impl<T: StT + Ord> AVLTreeSetStPerTrait<T> for AVLTreeSetStPer<T> {
   44|       |    impl<T: StT> MinEditDistStPerS<T> {
   44|       |    impl<T: StT> StackStEph<T> {
   44|       |    impl<V: StT + Hash + Ord> WeightedUnDirGraphStEphFloat<V> {
   44|       |    impl<V: StT + Hash> WeightedDirGraphStEphFloat<V> {
   44|       |    impl<V: StT + Ord> AdjTableGraphStEphTrait<V> for AdjTableGraphStEph<V> {
   44|       |    impl<V: StT + Ord> AdjTableGraphStPerTrait<V> for AdjTableGraphStPer<V> {
   45|       |    impl<T: StT> Eq for ArraySeqStPerS<T> {}
   45|       |    impl<T: StT + Ord> AVLTreeSetStEphTrait<T> for AVLTreeSetStEph<T> {
   45|       |    impl<V: StT + Hash> UnionFind<V> {
   45|       |    impl<V: StT + Ord> EdgeSetGraphStEphTrait<V> for EdgeSetGraphStEph<V> {
   46|       |    impl<T: StT + Ord> BSTPlainStEphTrait<T> for BSTPlainStEph<T> {
   46|       |    impl<V: StT + Ord> EdgeSetGraphStPerTrait<V> for EdgeSetGraphStPer<V> {
   47|       |    impl<Key: StT, Value: StT, Metrics: Default> 
   47|       |    impl<T: StT> Debug for ArraySeqStPerS<T> {
   48|       |    impl<K: StT, V: StT, P: ProbeSequence<K> + Clone> FlatHashTable<K, V, P> {
   50|     25|        V: StT + Hash + Ord,
   50|       |    impl<T: StT> BalBinTree<T> {
   51|       |    impl<T: StT> OBSTStPerS<T> {
   51|       |    impl<T: StT> SubsetSumStEphS<T> {
   52|       |    impl<T: StT + Ord> BalancedTreePQTrait<T> for BalancedTreePQ<T> {
   52|       |    impl<T: StT + Ord> BinaryHeapPQ<T> {
   52|       |    impl<T: StT + Ord> SortedListPQTrait<T> for SortedListPQ<T> {
   52|       |    impl<T: StT + Ord> UnsortedListPQTrait<T> for UnsortedListPQ<T> {
   52|       |    impl<V: StT + Hash + Ord> Ord for PQEntry<V> {
   54|       |    impl<A: StT + Hash, B: StT + Hash> Relation<A, B> {
   55|     29|        V: StT + MtT + Hash + Ord + 'static,
   55|       |    impl<V: StT + Hash, L: StT + Hash> LabDirGraphStEphTrait<V, L> for LabDirGraphStEph<V, L> {
   55|       |    impl<V: StT + Hash> UnDirGraphStEphTrait<V> for UnDirGraphStEph<V> {
   55|       |    // StT: single-threaded friendly elements: Eq + Clone + Display + Debug + Sized
   56|       |    impl<Key: StT, Value: StT, Metrics: Default> 
   56|       |    impl<V: StT + Hash + Ord> PartialOrd for PQEntry<V> {
   57|       |    impl<Key: StT, Value: StT, Metrics: Default> 
   57|       |    impl<K: StT + Ord, V: StT> TableStEphTrait<K, V> for TableStEph<K, V> {
   57|       |    impl<T> StT for T where T: Eq + Clone + Display + Debug + Sized {}
   58|       |    impl<A: StT + Hash, B: StT + Hash> PartialEq for Relation<A, B> {
   58|       |    impl<T: StT> IntoIterator for ArraySeqStPerS<T> {
   58|       |    impl<V: StT + MtT + Hash + 'static> UnDirGraphMtEphTrait<V> for UnDirGraphMtEph<V> {
   59|       |    impl<T: StT> MinEditDistStEphS<T> {
   59|       |    impl<T: StT + Ord> ParamBST<T> {
   59|       |    impl<V: StT + MtT + Hash + 'static, L: StTInMtT + Hash + 'static> LabDirGraphMtEphTrait<V, L>
   60|       |    impl<V: StT + Hash + Ord + Display> Display for PQEntry<V> {
   62|       |    impl<A: StT + Hash, B: StT + Hash> Eq for Relation<A, B> {}
   62|       |    impl<T: StT> PrimTreeSeqStS<T> {
   63|       |    impl<A: StT + Hash, B: StT + Hash> PartialEq for Mapping<A, B> {
   63|       |    impl<T: StT> OBSTStEphS<T> {
   63|       |    impl<T: StT + Ord> Default for BSTSplayStEph<T> {
   64|       |    impl<A: StT + Hash, B: StT + Hash> Debug for Relation<A, B> {
   64|       |    impl<Key: StT, Value: StT, Metrics: Default> 
   64|       |    impl<T: StT + Ord> Default for BSTreeTreap<T> {
   64|       |    impl<T: StT + Ord> LeftistHeapNode<T> {
   65|       |    impl<T: StT> AVLTreeSeqStEphS<T> {
   65|       |    impl<T: StT> Display for ArraySeqStPerS<T> {
   65|       |    impl<T: StT + Ord> Default for BSTAVLStEph<T> {
   65|       |    impl<T: StT + Ord> Default for BSTBBAlphaStEph<T> {
   66|       |    impl<A: StT + Hash, B: StT + Hash> Eq for Mapping<A, B> {}
   66|       |    impl<K: StT + Ord, V: StT> Default for BSTreeKeyValue<K, V> {
   67|       |    impl<T: StT + Ord> BSTSplayStEph<T> {
   67|       |    impl<T: StT + Ord> Default for BSTreeSize<T> {
   67|       |    impl<T: StT> ReduceOp<T, N> for CountOp<T> {
   68|       |    impl<A: StT + Hash, B: StT + Hash> Debug for Mapping<A, B> {
   68|       |    impl<A: StT + Hash, B: StT + Hash> Display for Relation<A, B> {
   68|       |    impl<T: StT + Ord> BSTTreapStEph<T> {
   69|       |    impl<T: StT> ArraySeqStPerTrait<T> for ArraySeqStPerS<T> {
   69|       |    impl<T: StT + Ord> BSTAVLStEph<T> {
   69|       |    impl<T: StT + Ord> BSTBBAlphaStEph<T> {
   70|       |    impl<K: StT + Ord, V: StT> BSTKeyValueStEph<K, V> {
   70|       |    impl<T: StT> ArraySeqStEphTrait<T> for ArraySeqStEphS<T> {
   71|       |    impl<A: StT + Hash, B: StT + Hash> Display for Mapping<A, B> {
   71|       |    impl<T: StT + Ord> BSTSizeStEph<T> {
   71|       |    impl<T: StT + Ord> Default for BSTRBStEph<T> {
   72|       |    impl<T: StT> Default for StackStEph<T> {
   72|       |    impl<X: StT + Hash, Y: StT + Hash> RelationStEphTrait<X, Y> for Relation<X, Y> {
   73|       |    impl<T: StT + Ord> OrderedSetStPerTrait<T> for OrderedSetStPer<T> {
   73|       |    impl<V: StT + Hash> DirGraphStEphTrait<V> for DirGraphStEph<V> {
   74|       |    impl<Key: StT, Value: StT, Metrics: Default> 
   74|       |    impl<T: StT + Ord> OrderedSetStEphTrait<T> for OrderedSetStEph<T> {
   74|       |    impl<T: StT> PartialEq for ArraySeqStEphS<T> {
   75|       |    impl<Key: StT, Value: StT, Metrics: Default> 
   75|       |    impl<T: StT + Ord> BSTRBStEph<T> {
   75|       |    impl<T: StT + Send + Sync + 'static> ArraySeqMtEphSliceS<T> {
   75|       |    impl<X: StT + Hash, Y: StT + Hash> MappingStEphTrait<X, Y> for Mapping<X, Y> {
   76|       |    impl<Key: StT, Value: StT, Metrics: Default> 
   76|       |    impl<T: StT> SubsetSumStPerTrait<T> for SubsetSumStPerS<T> {
   76|       |    impl<V: StT + MtT + Hash + 'static> DirGraphMtEphTrait<V> for DirGraphMtEph<V> {
   77|       |    impl<K: StT + Ord, V: StT, F> AugOrderedTableStPerTrait<K, V, F> for AugOrderedTableStPer<K, V, F>
   78|       |    impl<T: StT> Eq for ArraySeqStEphS<T> {}
   80|       |    impl<K: StT + Ord, V: StT, F> AugOrderedTableStEphTrait<K, V, F> for AugOrderedTableStEph<K, V, F>
   80|       |    impl<T: StT> Debug for ArraySeqStEphS<T> {
   80|       |    impl<T: StT> MinEditDistStPerTrait<T> for MinEditDistStPerS<T> {
   81|       |    impl<K: StT + Ord, V: StT> OrderedTableStPerTrait<K, V> for OrderedTableStPer<K, V> {
   81|       |    impl<K: StT + Ord, V: StT> TableStPerTrait<K, V> for TableStPer<K, V> {
   82|     20|            V: StT + Ord,
   82|       |    impl<Key: StT, Value: StT, Metrics: Default> 
   84|       |    impl<K: StT + Ord, V: StT> OrderedTableStEphTrait<K, V> for OrderedTableStEph<K, V> {
   85|       |    impl<T: StT> PartialEq for MathSeqS<T> {
   85|       |    impl<T: StT> SubsetSumStEphTrait<T> for SubsetSumStEphS<T> {
   87|       |    impl<T: StT> OBSTStPerTrait<T> for OBSTStPerS<T> {
   89|     60|                V: StT + Ord,
   89|       |    impl<T: StT> Eq for MathSeqS<T> {}
   90|     60|                P: StT + Ord,
   91|       |    impl<T: StT> IntoIterator for ArraySeqStEphS<T> {
   91|       |    impl<T: StT> std::fmt::Debug for MathSeqS<T> {
   94|       |    impl<T: StT> LinkedListStPerS<T> {
   95|     32|                V: StT + Ord,
   95|       |    impl<T: StT> MinEditDistStEphTrait<T> for MinEditDistStEphS<T> {
   97|       |    impl<T: StT> std::fmt::Display for MathSeqS<T> {
   98|       |    impl<T: StT> Display for ArraySeqStEphS<T> {
   99|     30|                V: StT + Ord,
   99|       |    impl<Key: StT, Value: StT, Metrics: Default> 
   99|       |    impl<T: StT> OBSTStEphTrait<T> for OBSTStEphS<T> {
  100|       |    impl<T: StTInMtT> std::fmt::Display for ArraySeqMtPerS<T> {
  109|       |    impl<T: StTInMtT> Default for ConcurrentStackMt<T> {
  112|       |    // StTInMtT + 'static pattern can be expressed as StTInMtT + 'static inline
  113|       |    impl<T: StTInMtT> Drop for ConcurrentStackMt<T> {
  116|       |    impl<V: StTInMtT + Ord + 'static> Default for AdjTableGraphMtPer<V> {
  126|       |    impl<T: StTInMtT> ConcurrentStackMt<T> {
  129|       |    impl<V: StTInMtT + Ord + 'static> Default for EdgeSetGraphMtPer<V> {
  150|       |    impl<T: StTInMtT + Ord> BSTSplayMtEphTrait<T> for BSTSplayMtEph<T> {
  166|       |    impl<T: StTInMtT> AVLTreeSeqMtPerTrait<T> for AVLTreeSeqMtPerS<T> {
  166|       |    impl<T: StTInMtT> std::fmt::Display for ArraySeqMtEphS<T> {
   17|       |    impl<T: StTInMtT + Ord> OrderStatSelectMtPerTrait<T> for ArraySeqMtPerS<T> {
  180|       |    impl<T: StTInMtT + 'static> ArraySeqMtEphTrait<T> for ArraySeqMtEphS<T> {
  181|       |    impl<T: StTInMtT + Ord> BSTTreapMtEphTrait<T> for BSTTreapMtEph<T> {
  185|       |    impl<T: StTInMtT + Ord> BSTBBAlphaMtEphTrait<T> for BSTBBAlphaMtEph<T> {
  187|       |    impl<T: StTInMtT> ArraySeqMtPerTrait<T> for ArraySeqMtPerS<T> {
   19|       |    impl<T: StTInMtT + Ord + 'static> OrderStatSelectMtEphTrait<T> for ArraySeqMtEphS<T> {
  205|       |    impl<T: StTInMtT + Ord> BSTAVLMtEphTrait<T> for BSTAVLMtEph<T> {
  208|       |    impl<T: StTInMtT> Clone for AVLTreeSeqMtPerS<T> {
   20|       |    impl<T: StTInMtT> ArraySeqMtEphS<T> {
   20|       |    impl<T: StTInMtT> ArraySeqMtPerS<T> {
  216|       |    impl<T: StTInMtT> Default for AVLTreeSeqMtPerS<T> {
  225|       |    impl<T: StTInMtT + Ord> BSTSetAVLMtEphTrait<T> for BSTSetAVLMtEph<T> {
  225|       |    impl<T: StTInMtT + Ord> BSTSetBBAlphaMtEphTrait<T> for BSTSetBBAlphaMtEph<T> {
  225|       |    impl<T: StTInMtT + Ord> BSTSetPlainMtEphTrait<T> for BSTSetPlainMtEph<T> {
  225|       |    impl<T: StTInMtT + Ord> BSTSetRBMtEphTrait<T> for BSTSetRBMtEph<T> {
  225|       |    impl<T: StTInMtT + Ord> BSTSetSplayMtEphTrait<T> for BSTSetSplayMtEph<T> {
  225|       |    impl<T: StTInMtT + Ord> BSTSetTreapMtEphTrait<T> for BSTSetTreapMtEph<T> {
  226|       |    impl<T: StTInMtT> Iterator for AVLTreeSeqMtPerIter<T> {
   22|       |    impl<T: StTInMtT + Ord> Node<T> {
   22|       |    impl<T: StTInMtT + Ord> Node<T> {
   23|       |    impl<T: StTInMtT + Ord> Node<T> {
   23|       |    impl<T: StTInMtT + Ord> Node<T> {
  240|       |    impl<T: StTInMtT> IntoIterator for AVLTreeSeqMtPerS<T> {
  241|       |    impl<T: StTInMtT + Ord> BSTRBMtEphTrait<T> for BSTRBMtEph<T> {
  248|       |    impl<T: StTInMtT + Ord + 'static> Default for AVLTreeSetMtEph<T> {
   24|       |    impl<T: StTInMtT + Ord> Node<T> {
  252|       |    impl<T: StTInMtT + Ord + 'static> Clone for AVLTreeSetMtEph<T> {
  252|       |    impl<T: StTInMtT> PartialEq for AVLTreeSeqMtPerS<T> {
  261|       |    impl<T: StTInMtT + Ord + 'static> fmt::Debug for AVLTreeSetMtEph<T> {
  266|       |    impl<T: StTInMtT> Eq for AVLTreeSeqMtPerS<T> {}
  267|       |    impl<T: StTInMtT + Ord + 'static> Default for AVLTreeSetMtPer<T> {
  268|       |    impl<T: StTInMtT> Debug for AVLTreeSeqMtPerS<T> {
   26|       |    impl<V: StTInMtT + Ord + 'static> SelectionStrategy<V> for SelectAll {
  271|       |    impl<T: StTInMtT + Ord + 'static> Clone for AVLTreeSetMtPer<T> {
  275|       |    impl<T: StTInMtT + Ord + 'static> fmt::Display for AVLTreeSetMtEph<T> {
  279|       |    impl<T: StTInMtT + Ord + 'static> fmt::Debug for AVLTreeSetMtPer<T> {
   28|       |        V: StTInMtT + Ord + 'static,
  292|       |    impl<T: StTInMtT + Ord + 'static> fmt::Display for AVLTreeSetMtPer<T> {
   29|       |    impl<T: StTInMtT + Ord> Node<T> {
   29|       |        P: StTInMtT + Ord + 'static,
   30|       |    impl<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static, F: Fn(&V) -> P> ClosurePriority<V, P, F> {
   31|       |    impl<V: StTInMtT + Ord + 'static> SelectionStrategy<V> for SelectOne {
   36|       |    impl<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static, F: Fn(&V) -> P + Send + Sync + 'static>
   37|       |    impl<T: StTInMtT> ConcurrentStackMt<T> {
   39|       |    impl<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static, F: Fn(&V) -> P> PriorityFn<V, P>
   40|       |    impl<V: StTInMtT + Ord + 'static> AdjTableGraphMtPerTrait<V> for AdjTableGraphMtPer<V> {
   41|       |    impl<K: StTInMtT + Ord, V: StTInMtT> OrderedTableMtPerTrait<K, V> for OrderedTableMtPer<K, V> {
   47|       |    impl<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static, F: Fn(&V) -> P + Send + Sync + 'static>
   48|       |    impl<V: StTInMtT + Ord + 'static> EdgeSetGraphMtPerTrait<V> for EdgeSetGraphMtPer<V> {
   50|       |    impl<T: StTInMtT + Ord + 'static> AVLTreeSetMtEphTrait<T> for AVLTreeSetMtEph<T> {
   50|       |    impl<T: StTInMtT + Ord + 'static> AVLTreeSetMtPerTrait<T> for AVLTreeSetMtPer<T> {
   59|       |    // StTInMtT: St-friendly elements that can be shared across threads (StT + Send + Sync)
   60|       |    impl<T: StTInMtT> ConcurrentStackMtTrait<T> for ConcurrentStackMt<T> {
   61|       |    impl<T> StTInMtT for T where T: StT + Send + Sync {}
   62|       |    impl<T: StTInMtT + Ord> BSTSetAVLMtEph<T> {
   62|       |    impl<T: StTInMtT + Ord> BSTSetBBAlphaMtEph<T> {
   62|       |    impl<T: StTInMtT + Ord> BSTSetPlainMtEph<T> {
   62|       |    impl<T: StTInMtT + Ord> BSTSetRBMtEph<T> {
   62|       |    impl<T: StTInMtT + Ord> BSTSetSplayMtEph<T> {
   62|       |    impl<T: StTInMtT + Ord> BSTSetTreapMtEph<T> {
   63|       |    impl<T: StTInMtT> Clone for ArraySeqMtPerS<T> {
   63|       |    impl<T: StTInMtT + 'static> ArraySeqMtEphTrait<T> for ArraySeqMtEphS<T> {
   64|       |    impl<T: StTInMtT + Ord> BSTPlainMtEph<T> {
   65|       |    impl<T: StTInMtT + Ord> Default for BSTAVLMtEph<T> {
   65|       |    impl<T: StTInMtT + Ord> Default for BSTBBAlphaMtEph<T> {
   65|       |    impl<T: StTInMtT + Ord> Default for BSTRBMtEph<T> {
   65|       |    impl<T: StTInMtT + Ord> Default for BSTSplayMtEph<T> {
   65|       |    impl<T: StTInMtT + Ord> Default for BSTTreapMtEph<T> {
   69|       |    impl<T: StTInMtT + Ord> BSTAVLMtEph<T> {
   69|       |    impl<T: StTInMtT + Ord> BSTBBAlphaMtEph<T> {
   69|       |    impl<T: StTInMtT + Ord> BSTRBMtEph<T> {
   69|       |    impl<T: StTInMtT + Ord> BSTSplayMtEph<T> {
   69|       |    impl<T: StTInMtT + Ord> BSTTreapMtEph<T> {
   70|       |    impl<T: StTInMtT> PartialEq for ArraySeqMtPerS<T> {
   72|       |    impl<T: StTInMtT + Ord> BSTPlainMtEphTrait<T> for BSTPlainMtEph<T> {
   81|       |    impl<T: StTInMtT + 'static> ArraySeqMtPerTrait<T> for ArraySeqMtPerS<T> {
   84|       |    impl<T: StTInMtT + Eq> Eq for ArraySeqMtPerS<T> {}
   85|       |    impl<K: StTInMtT + Ord, V: StTInMtT> Default for OrderedTableMtPer<K, V> {
   85|       |    impl<T: StTInMtT> Clone for ArraySeqMtEphS<T> {
   87|     20|            V: StTInMtT + Ord + 'static,
   89|       |    impl<K: StTInMtT + Ord, V: StTInMtT> Clone for OrderedTableMtPer<K, V> {
   89|       |    impl<T: StTInMtT> PartialEq for ArraySeqMtEphS<T> {
   93|       |    impl<T: StTInMtT> Eq for ArraySeqMtEphS<T> {}
   93|       |    impl<T: StTInMtT> IntoIterator for ArraySeqMtPerS<T> {
   96|     60|                V: StTInMtT + Ord + 'static,
   97|     60|                P: StTInMtT + Ord + 'static,
  274|       |            // Stub implementation - complex atomic operations not needed for basic functionality
  162|     10|            let sub = self.clamp_subrange(start, length);
  169|     17|            let sub = self.clamp_subrange(start, length);
  172|     17|                range: sub,
    6|       |//! vertex-induced subgraph with respect to a star graph.
    6|       |//! the sub-paths property for shortest paths with both integer and float weights.
    6|       |//! the sub-paths property for shortest paths with integer edge weights.
  122|      2|        fn sub(self, other: Self) -> Self { Probability(self.0 - other.0) }
  138|       |        fn subseq(a: &ArraySeqStEphS<T>, start: N, length: N) -> ArraySeqStEphS<T>;
  208|     22|        fn subseq(a: &ArraySeqStEphS<T>, start: N, length: N) -> ArraySeqStEphS<T> { a.subseq(start, length) }
  216|      1|        fn subseq(a: &ArraySeqS<T>, start: N, length: N) -> ArraySeqS<T> { a.subseq_copy(start, length) }
   54|       |        fn subseq(a: &ArraySeqS<T>, start: N, length: N) -> ArraySeqS<T>
  102|       |        fn subseq_copy(a: &ArraySeqStPerS<T>, start: N, length: N) -> ArraySeqStPerS<T>;
  163|      0|        fn subseq_copy(a: &ArraySeqStPerS<T>, start: N, length: N) -> ArraySeqStPerS<T> { a.subseq_copy(start, length) }
  104|      0|        fn subseq_copy(&self, start: N, length: N) -> ArraySeqMtPerS<T> {
  127|       |        fn subseq_copy(&self, start: N, length: N) -> ArraySeqMtEphS<T>;
  131|       |        fn subseq_copy(&self, start: N, length: N) -> ArraySeqMtPerS<T>;
  159|       |        fn subseq_copy(&self, start: N, length: N) -> Self;
  160|       |        fn subseq_copy(&self, start: N, length: N) -> Self;
  161|     10|        fn subseq_copy(&self, start: N, length: N) -> Self {
  166|      6|        fn subseq_copy(&self, start: N, length: N) -> Self {
  183|      2|        fn subseq_copy(&self, start: N, length: N) -> Self {
  184|     24|        fn subseq_copy(&self, start: N, length: N) -> Self {
  188|      2|        fn subseq_copy(&self, start: N, length: N) -> Self {
  193|      0|        fn subseq_copy(&self, start: N, length: N) -> ArraySeqMtPerS<T> {
  209|       |        fn subseq_copy(&self, start: N, length: N) -> Self;
  227|     12|        fn subseq_copy(&self, start: N, length: N) -> AVLTreeS<T>
  233|      1|        fn subseq_copy(&self, start: N, length: N) -> ArraySeqMtEphS<T> {
  239|      0|        fn subseq_copy(&self, start: N, length: N) -> LinkedListStPerS<T> {
   26|       |        fn subseq_copy(&self, start: N, length: N) -> ArraySeqMtPerS<T>;
   26|       |        fn subseq_copy(&self, start: N, length: N) -> ArraySeqStEphS<T>;
   26|       |        fn subseq_copy(&self, start: N, length: N) -> ArraySeqStPerS<T>;
  287|      0|        fn subseq_copy(&self, start: N, length: N) -> Self { LinkedListStEphS::subseq_copy(self, start, length) }
   28|       |        fn subseq_copy(&self, start: N, length: N) -> ArraySeqMtEphS<T>;
   42|       |        fn subseq_copy(&self, start: N, length: N) -> LinkedListStPerS<T>;
   54|       |        fn subseq_copy(&self, start: N, length: N) -> Self;
   56|       |        fn subseq_copy(&self, start: N, length: N) -> Self;
   62|       |        fn subseq_copy(&self, start: N, length: N) -> Self;
   81|       |        fn subseq_copy(&self, start: N, length: N) -> AVLTreeS<T>
   86|      1|        fn subseq_copy(&self, start: N, length: N) -> ArraySeqMtEphS<T> {
   92|      0|        fn subseq_copy(&self, start: N, length: N) -> ArraySeqStPerS<T> {
   93|     15|        fn subseq_copy(&self, start: N, length: N) -> ArraySeqStEphS<T> {
  181|     18|        fn subseq(&self, start: N, length: N) -> &[T] {
   50|       |        fn subseq(&self, start: N, length: N) -> &[T];
  140|     22|                for subset in parts.data.iter() {
  222|      0|                for subset in parts.data.iter() {
  141|     22|                    if subset.data.contains(x) {
  223|      0|                    if subset.data.contains(x) {
    4|       |pub mod SubsetSumMtEph {
    4|       |pub mod SubsetSumMtPer {
  103|     21|        fn subset_sum(&mut self, target: i32) -> bool
  122|     10|        fn subset_sum(&mut self, target: i32) -> bool
   31|       |        fn subset_sum(&mut self, target: i32) -> bool
   33|       |        fn subset_sum(&mut self, target: i32) -> bool
   46|    199|        fn subset_sum_rec(&mut self, i: usize, j: i32) -> bool
   55|    131|        fn subset_sum_rec(&mut self, i: usize, j: i32) -> bool
   47|    234|        fn subset_sum_rec(&self, i: usize, j: i32) -> bool
   57|    114|        fn subset_sum_rec(&self, i: usize, j: i32) -> bool
  112|     12|        fn subset_sum(&self, target: i32) -> bool
   31|       |        fn subset_sum(&self, target: i32) -> bool
   32|       |        fn subset_sum(&self, target: i32) -> bool
   94|     27|        fn subset_sum(&self, target: i32) -> bool
    4|       |pub mod SubsetSumStEph {
    4|       |pub mod SubsetSumStPer {
  146|     29|                        let substitute_cost = handle3.join().unwrap();
  148|     22|                        let substitute_cost = handle3.join().unwrap();
   78|      6|                        let substitute_cost = 1 + self.med_recursive(i - 1, j - 1);
   81|      6|                        let substitute_cost = 1 + self.med_recursive(i - 1, j - 1, memo);
   83|      6|                        let substitute_cost = 1 + self.med_recursive_concurrent(i - 1, j - 1);
   85|      6|                        let substitute_cost = 1 + self.med_recursive_concurrent(i - 1, j - 1);
  188|      3|        fn subtract(&mut self, keys: &ArraySetStEph<K>) { self.base_table.subtract(keys); }
  207|      1|        fn subtract(&mut self, keys: &ArraySetStEph<K>) {
  215|      1|        fn subtract(&mut self, keys: &ArraySetStEph<K>) {
  217|      3|        fn subtract(&mut self, keys: &ArraySetStEph<K>) { self.base_table.subtract(keys); }
  281|      4|        fn subtract(&mut self, keys: &ArraySetStEph<K>) {
   50|       |        fn subtract(&mut self, keys: &ArraySetStEph<K>);
   51|       |        fn subtract(&mut self, keys: &ArraySetStEph<K>);
   53|       |        fn subtract(&mut self, keys: &ArraySetStEph<K>);
   55|       |        fn subtract(&mut self, keys: &ArraySetStEph<K>);
   57|       |        fn subtract(&mut self, keys: &ArraySetStEph<K>);
   58|       |        fn subtract(&mut self, keys: &ArraySetStEph<K>);
  604|      4|        fn subtract(&mut self, keys: &ArraySetStEph<K>) {
  171|      2|        fn subtract(&self, keys: &ArraySetStEph<K>) -> Self {
  234|      1|        fn subtract(&self, keys: &ArraySetStEph<K>) -> Self {
  317|      3|        fn subtract(&self, keys: &ArraySetStEph<K>) -> Self {
   48|       |        fn subtract(&self, keys: &ArraySetStEph<K>) -> Self;
   51|       |        fn subtract(&self, keys: &ArraySetStEph<K>) -> Self;
   75|       |        fn subtract(&self, keys: &ArraySetStEph<K>) -> Self;
  218|       |                // Successful search: approximately (1/α) * ln(1/(1-α))
  272|       |                // Successful search: approximately 1 - ln(1-α)/α
  110|     19|            let successful_probes = strategy.estimate_successful_probe_count(load_factor);
  152|     16|            let successful_probes = strategy.estimate_probe_count(load_factor, true);
  190|     16|            let successful_probes = strategy.estimate_probe_count(load_factor, true);
  257|      1|        let successful_probes = strategy.estimate_successful_probe_count(0.5);
  324|      1|        let successful_probes = strategy.estimate_probe_count(0.5, true);
  330|      1|        (metrics, successful_probes, unsuccessful_probes, validation)
  346|     51|                expected_successful_probes: successful_probes,
  351|      1|        let successful_probes = strategy.estimate_probe_count(0.5, true);
  357|      1|        (metrics, successful_probes, unsuccessful_probes, validation)
  101|       |                // Sum probabilities for this subsequence
  110|       |                // Sum probabilities for this subsequence (thread-safe access)
   16|       |        /// Sum all elements via reduce.
   17|       |        /// Sum all elements via parallel reduce.
   64|       |                // Sum probabilities for this subsequence
   76|       |                // Sum probabilities for this subsequence
   20|       |        fn sum(a: &ArraySeqStPerS<N>) -> N;
   49|     10|        fn sum(a: &ArraySeqStPerS<N>) -> N { ArraySeqStPerS::reduce(a, &|x, y| x + y, 0) }
   21|       |        fn sum_parallel(a: &ArraySeqMtPerS<N>) -> N;
   51|      1|        fn sum_parallel(a: &ArraySeqMtPerS<N>) -> N {
  163|       |    /// Sums the weights of edges in the tour.
  156|      0|                let sum_squared_diff: f64 = clusters.iter().map(|&size| (size as f64 - mean).powi(2)).sum();
    7|       |//! - Supports sequence-like operations similar to `ArraySeq` plus `from_vec`, iterator, and conversion to `ArrayS`.
  127|       |                // Swap current with smallest child
  135|       |        /// Swap elements at indices i and j
   97|       |                // Swap current with parent
  136|    466|        fn swap_elements(&self, seq: &ArraySeqStPerS<T>, i: N, j: N) -> ArraySeqStPerS<T> {
  111|       |                // Symmetric case: split right sequence
   28|  11.3k|        let sz = 1 + size(&left) + size(&right);
   28|  1.23M|        let sz = 1 + size(&left) + size(&right);
   32|  11.3k|            size: sz,
   32|  1.23M|            size: sz,
  104|       |    impl<F, T> Pred<T> for F where F: Fn(&T) -> B + Send + Sync + 'static {}
  109|       |    impl<F, T> PredVal<T> for F where F: Fn(T) -> B + Send + Sync + 'static {}
  137|       |            fn((T, T)) -> Pair<T, T>,
  139|       |    impl<'a, T: StT> IntoIterator for &'a MathSeqS<T> {
  145|       |    impl<'a, T: StT> IntoIterator for &'a mut MathSeqS<T> {
   14|       |            key: T,
   14|       |        key: T,
   14|       |        key: T,
   14|       |        key: T,
   14|       |        key: T,
   14|       |        Node(ParamBST<T>, T, ParamBST<T>),
   14|       |        value: T,
  153|       |    impl<'a, T: StT> IntoIterator for &'a OBSTStPerS<T> {
  155|       |            fn((T, T)) -> Pair<T, T>,
   15|       |        key: T,
   15|       |        value: T,
   15|       |        value: T,
  169|       |            fn((T, T)) -> Pair<T, T>,
   16|       |        key: T,
   16|       |        key: T,
   16|       |        key: T,
   16|       |        key: T,
   16|       |        Node(ParamBST<T>, T, ParamBST<T>),
   16|       |        Node(ParamTreap<T>, T, ParamTreap<T>),
  184|       |    impl<'a, T: StT> IntoIterator for &'a OBSTStEphS<T> {
  186|       |    impl<'a, T: StT> AVLTreeSeqIterStEph<'a, T> {
  187|       |            fn((T, T)) -> Pair<T, T>,
   18|       |        key: T,
  191|       |    impl<'a, T: StT> IntoIterator for &'a mut OBSTStEphS<T> {
   19|       |        key: T,
  204|       |    impl<'a, T: StT> Iterator for AVLTreeSeqIterStEph<'a, T> {
  206|       |            fn((T, T)) -> Pair<T, T>,
   20|       |            id: T,
   20|       |            id: T,
   20|       |        key: T,
  216|       |    impl<'a, T: MtVal> IntoIterator for &'a OBSTMtPerS<T> {
   21|       |        key: T,
   21|       |        key: T,
  234|      0|        let t2 = x.right.take();
  245|  17.6M|        let t2 = y.left.take();
   22|       |        key: T,
  340|      0|        let t2 = x.right.take();
  353|      6|        let t2 = y.left.take();
   40|      0|        let t2 = x.right.clone();
   40|      0|        let t2 = x.right.clone();
   47|      0|        let t2 = y.left.clone();
   47|      0|        let t2 = y.left.clone();
  259|       |    impl<'a, T: StT> AVLTreeSeqStPerIter<'a, T> {
  268|       |    impl<'a, T: StT> Iterator for AVLTreeSeqStPerIter<'a, T> {
  275|       |    impl<'a, T: MtVal> IntoIterator for &'a OBSTMtEphS<T> {
   28|     22|            id: T,
   28|     30|            id: T,
  285|       |    impl<'a, T: MtVal> IntoIterator for &'a mut OBSTMtEphS<T> {
  290|       |    impl<'a, T: Copy + Debug> AVLTreeSeqIter<'a, T> {
  309|       |    impl<'a, T: Copy + Debug> Iterator for AVLTreeSeqIter<'a, T> {
  350|       |    impl<'a, T> IntoIterator for &'a ArraySeqS<T> {
  357|       |    impl<'a, T> IntoIterator for &'a mut ArraySeqS<T> {
   41|     16|                seq_t: t,
   41|     16|                seq_t: t,
   43|     16|                seq_t: t,
   43|     16|                seq_t: t,
   51|       |    impl<'a, T: StT> IntoIterator for &'a ArraySeqStPerS<T> {
   74|       |    impl<K, T> HashFunClone<K> for T where T: crate::Chap47::HashFunctionTraits::HashFunctionTraits::HashFunction<K> + Clone {}
   84|       |    impl<'a, T: StT> IntoIterator for &'a ArraySeqStEphS<T> {
   86|       |    impl<'a, T: StTInMtT> IntoIterator for &'a ArraySeqMtPerS<T> {
  100|      1|        println!("Ephemeral table after filter (keys <= 2): size = {}", table_eph.size());
  104|      1|            "Multi-threaded table after filter (keys <= 2): size = {}",
  126|      1|        let table1 = TableStPerLit![1 => "A".to_string(), 2 => "B".to_string()];
  135|      2|1. Outer Table: Use an array of size m to map hash codes to inner tables
  158|      1|        println!("Persistent table construction: {:?}", per_time);
  167|      1|        println!("Ephemeral table construction: {:?}", eph_time);
  176|      1|        println!("Multi-threaded table construction: {:?}", mt_time);
  127|      1|        let table2 = TableStPerLit![2 => "X".to_string(), 3 => "Y".to_string()];
  232|      0|            writeln!(f, "Table size: {}", self.table_size)?;
  249|      1|        let table: FlatHashTable<String, String, AdvancedLinearProbingStrategy<String, DefaultHashFunction>> =
   24|       |        pub table: Vec<Entry>,
   33|      1|        println!("Persistent table size: {}", table_per.size());
  333|      2|             all table positions before repeating, eliminating both primary and secondary clustering."
   34|      1|        println!("Ephemeral table size: {}", table_eph.size());
  344|      1|        let table: FlatHashTable<String, String, AdvancedQuadraticProbingStrategy<String, DefaultHashFunction>> =
   35|      1|        println!("Multi-threaded table size: {}", table_mt.size());
  389|      0|                $crate::Chap43::AugOrderedTableStEph::AugOrderedTableStEph::AugOrderedTableStEphTrait::insert(&mut table, $k, $v, |_old, new| new.clone());
  422|      0|                $crate::Chap43::AugOrderedTableMtEph::AugOrderedTableMtEph::AugOrderedTableMtEphTrait::insert(&mut table, $k, $v, |_old, new| new.clone());
   47|      3|            let table = Arc::new(Mutex::new(self.initialize_base_cases()));
   47|      4|            let table = Arc::new(Mutex::new(self.initialize_base_cases()));
   49|     13|                self.compute_diagonal(&mut table, k);
   63|      1|        println!("Persistent table domain size: {}", domain_per.size());
   64|      1|        println!("Ephemeral table domain size: {}", domain_eph.size());
   65|      1|        println!("Multi-threaded table domain size: {}", domain_mt.size());
   71|      1|            "Persistent table after map (original unchanged): {:?}",
   75|      1|            "Persistent table after map (new table): {:?}",
   81|      1|            "Ephemeral table after map (modified in place): {:?}",
   87|      1|            "Multi-threaded table after map (modified in place): {:?}",
   95|      1|            "Persistent table after filter (keys <= 2): size = {}",
   98|       |            // Table full - return first slot as fallback (shouldn't happen with proper load factor)
  107|      1|        let (table_after_delete, _) = table.delete(&"E".to_string());
  100|     21|                    let table_clone = Arc::clone(&table);
  100|     21|                    let table_clone = Arc::clone(&table);
  375|      1|        let table_composite: FlatHashTable<
   85|      2|                size: table.current_size,
  116|      3|        let table_eph_tab = TableStEph::tabulate(|k| k * k, &keys);
  135|     21|            let table_guard = table.lock().unwrap();
  136|     21|            let table_guard = table.lock().unwrap();
    4|       |pub mod TableMtEph {
  121|      1|                return TableMtEph::empty();
   95|     83|                base_table: TableMtEph::empty(),
   17|       |        base_table: TableMtEph<K, V>,
  671|       |    macro_rules! TableMtEphLit {
  102|      3|                base_table: TableMtEph::singleton(k, v),
  127|      0|                return TableMtEph::singleton(key.clone(), value);
  136|      3|                base_table: TableMtEph::tabulate(f, keys),
  117|      3|        let table_mt_tab = TableMtEph::tabulate(|k| k * k, &keys);
   28|      1|        let table_per = TableStPerLit![1 => "Alice".to_string(), 2 => "Bob".to_string(), 3 => "Carol".to_string()];
   93|      4|        let table_per_filtered = table_per_new.filter(|k, _v| *k <= 2);
   69|      4|        let table_per_mapped = table_per_new.map(|name| name.to_uppercase());
   44|      1|        let table_per_new = table_per.insert(4, "Dave".to_string(), |_old, new| new.clone());
  115|      3|        let table_per_tab = TableStPer::tabulate(|k| k * k, &keys);
  368|      1|        let table_prime: FlatHashTable<String, String, AdvancedQuadraticProbingStrategy<String, DefaultHashFunction>> =
  119|      1|        println!("Tabulated tables (f(k) = k²):");
  136|      2|2. Inner Tables: Each position contains a Table ADT instance
  149|      1|        println!("Building tables with {} entries...", size);
   32|      1|        println!("Initial tables created with 3 entries each");
  108|      0|            let table_size = self.buckets.length();
  117|     99|            let table_size = self.buckets.length();
  128|      0|            let table_size = self.buckets.length();
  133|      3|            let table_size = self.buckets.length();
  160|    229|            let table_size = self.table.length();
  169|      0|                .should_shrink(result.num_elements, table_size)
  176|      1|                .should_shrink(result.num_elements, table_size)
  185|     16|                Some(strategy.analyze_double_hashing_quality(key, table_size))
  187|     22|            let table_size = self.table.length();
   19|       |        pub table_size: N,
  203|      0|            let table_size = self.buckets.length();
  204|    129|            let table_size = self.buckets.length();
  206|      2|            RelativePrimeValidator::validate_double_hashing(h2_value, table_size)
  207|     12|                self.analyze_linear_probing(key, table_size),
  208|     12|                self.analyze_quadratic_probing(key, table_size, 1, 1),
  209|     12|                self.analyze_double_hashing(key, table_size),
   20|       |        pub table_size: N,
  224|    706|            if table_size == 0 {
  225|     17|                                .should_shrink(result.num_elements, table_size)
  233|    693|            self.load_factor(num_elements, table_size) > self.max_load_factor
  239|     10|            self.load_factor(num_elements, table_size) < self.min_load_factor
   25|    259|            if table_size <= 2 {
  253|       |        pub table_size: N,
  254|      2|        let table_size = 11; // Prime table size
  258|    157|            let table_size = self.table.length();
  259|      6|            probe_sequences.push(analyzer.analyze_linear_probing(key, table_size));
  288|      2|        let table_size = 17; // Prime table size
  293|      6|            probe_sequences.push(analyzer.analyze_quadratic_probing(key, table_size, 1, 1));
  318|      1|        let table_size = 13; // Prime table size
  323|      2|        let table_size = 13; // Prime table size
  328|      6|            probe_sequences.push(analyzer.analyze_double_hashing(key, table_size));
  342|      1|        let table_size = 11; // Prime table size
   34|       |        pub table_size: N,
  357|      2|        let table_size = 11; // Prime table size
  391|      2|        let table_size = 13;
   39|      2|        let table_size = 5;
   45|      2|            let table_size = self.buckets.length();
  466|      1|        let table_size = 17; // Prime table size
   56|    122|            let table_size = self.buckets.length();
   61|     26|            if table_size == 0 {
   69|      2|        let table_size = 8;
   72|    295|            let table_size = self.table.length();
   73|      2|                    Self::gcd(h2_value, table_size)
   98|     31|                period: table_size, // Linear probing always has period = table_size
  185|     20|            let table_size_is_prime = PrimeValidator::is_prime(size);
   31|       |        pub table_size_is_prime: B,
  403|      1|            HashTableStats::new(keys.len(), table_size).with_collision_stats(total_collisions, max_count, avg_count)
    4|       |pub mod TableStEph {
   93|     96|                base_table: TableStEph::empty(),
   14|       |        base_table: TableStEph<K, V>,
  298|       |    macro_rules! TableStEphLit {
  100|      3|                base_table: TableStEph::singleton(k, v),
  129|      3|                base_table: TableStEph::tabulate(f, keys),
    4|       |pub mod TableStPer {
  179|      0|                word_to_docs: TableStPer::empty(),
   90|     93|                base_table: TableStPer::empty(),
   14|       |        base_table: TableStPer<K, V>,
  334|       |    macro_rules! TableStPerLit {
   97|      4|                base_table: TableStPer::singleton(k, v),
  124|      2|                base_table: TableStPer::tabulate(f, keys),
   25|       |        word_to_docs: TableStPer<Word, DocumentSet>,
  128|     19|                match &table.table[slot] {
   20|      3|            match &table.table[slot] {
   21|     30|            match &table.table[slot] {
   42|      5|                match &table.table[slot] {
   43|     38|                match &table.table[slot] {
   58|      1|                match &table.table[slot] {
   59|      5|                match &table.table[slot] {
   62|     18|            match &table.table[slot] {
   81|     19|                match &table.table[slot] {
   91|     55|                match &table.table[slot] {
   92|      5|                match &table.table[slot] {
   96|      4|                match &table.table[slot] {
  109|      1|        println!("\n--- Tabulate Operations ---");
  105|      4|        fn tabulate<F: Fn(&K) -> V>(f: F, keys: &ArraySetStEph<K>) -> Self {
  108|    120|        fn tabulate<F: Fn(N) -> T + Send + Sync>(f: &F, n: N) -> ArraySeqMtPerS<T> {
  115|      6|        fn tabulate<F: Fn(&K) -> V + Send + Sync + 'static>(f: F, keys: &ArraySetStEph<K>) -> Self {
  116|       |        fn tabulate<F: Fn(N) -> T + Send + Sync>(f: &F, n: N) -> ArraySeqMtEphS<T>;
  122|      2|        fn tabulate<F: Fn(&K) -> V>(f: F, keys: &ArraySetStEph<K>) -> Self {
  127|      3|        fn tabulate<F: Fn(&K) -> V>(f: F, keys: &ArraySetStEph<K>) -> Self {
  132|       |        fn tabulate<F: Fn(N) -> T>(f: &F, length: N) -> ArraySeqStEphS<T>;
  137|       |        fn tabulate<F: Fn(N) -> T + Send + Sync>(f: &F, n: N) -> ArraySeqMtPerS<T>;
  147|  3.87k|        fn tabulate<F: Fn(N) -> T>(f: &F, length: N) -> ArraySeqStPerS<T> {
  176|     20|        fn tabulate<F: Fn(N) -> T + Send + Sync>(f: &F, n: N) -> Self {
  192|    361|        fn tabulate<F: Fn(N) -> T>(f: &F, length: N) -> ArraySeqStEphS<T> {
  195|  4.61k|        fn tabulate<F: Fn(N) -> T + Send + Sync>(f: &F, n: N) -> ArraySeqMtEphS<T> {
  199|      1|        fn tabulate<F: Fn(N) -> T>(f: &F, length: N) -> ArraySeqS<T> {
  203|       |        fn tabulate<F: Fn(N) -> T>(f: &F, n: N) -> Self;
  206|     82|        fn tabulate<F: Fn(N) -> T + Send + Sync>(f: &F, n: N) -> ArraySeqMtPerS<T> {
  243|      4|        fn tabulate<F: Fn(N) -> T>(f: &F, n: N) -> LinkedListStPerS<T> {
  271|      3|        fn tabulate<F: Fn(N) -> T>(f: &F, n: N) -> Self {
   29|       |        fn tabulate<F: Fn(N) -> T + Send + Sync>(f: &F, n: N) -> ArraySeqMtPerS<T>;
   30|       |        fn tabulate<F: Fn(&K) -> V>(f: F, keys: &ArraySetStEph<K>) -> Self;
   30|       |        fn tabulate<F: Fn(N) -> T>(f: &F, n: N) -> ArraySeqStEphS<T>;
   30|       |        fn tabulate<F: Fn(N) -> T>(f: &F, n: N) -> ArraySeqStPerS<T>;
   31|       |        fn tabulate<F: Fn(N) -> T + Send + Sync>(f: &F, n: N) -> ArraySeqMtEphS<T>;
   33|       |        fn tabulate<F: Fn(&K) -> V + Send + Sync + 'static>(f: F, keys: &ArraySetStEph<K>) -> Self;
   37|       |        fn tabulate<F: Fn(&K) -> V>(f: F, keys: &ArraySetStEph<K>) -> Self;
   39|       |        fn tabulate<F: Fn(&K) -> V>(f: F, keys: &ArraySetStEph<K>) -> Self;
   41|       |        fn tabulate<F: Fn(&K) -> V>(f: F, keys: &ArraySetStEph<K>) -> Self;
   44|       |        fn tabulate<F: Fn(&K) -> V + Send + Sync + 'static>(f: F, keys: &ArraySetStEph<K>) -> Self;
   45|       |        fn tabulate<F: Fn(N) -> T>(f: &F, n: N) -> LinkedListStPerS<T>;
   46|       |        fn tabulate<F: Fn(N) -> T>(f: &F, length: N) -> ArraySeqS<T>;
   60|       |        fn tabulate<F: Fn(N) -> T + Send + Sync>(f: &F, n: N) -> Self;
   86|      5|        fn tabulate<F: Fn(&K) -> V>(f: F, keys: &ArraySetStEph<K>) -> Self {
   91|      6|        fn tabulate<F: Fn(N) -> T + Send + Sync>(f: &F, n: N) -> ArraySeqMtEphS<T> {
   96|       |        fn tabulate<F: Fn(N) -> T>(f: &F, length: N) -> ArraySeqStPerS<T>;
   97|    472|        fn tabulate<F: Fn(N) -> T>(f: &F, n: N) -> ArraySeqStPerS<T> {
   98|     80|        fn tabulate<F: Fn(N) -> T>(f: &F, n: N) -> ArraySeqStEphS<T> {
  131|      3|        fn tabulate<F>(f: F, keys: &ArraySetStEph<K>) -> Self
  141|      1|        fn tabulate<G: Fn(&K) -> V>(f: G, keys: &ArraySetStEph<K>, reducer: F, identity: V) -> Self {
  143|      1|        fn tabulate<G: Fn(&K) -> V>(f: G, keys: &ArraySetStEph<K>, reducer: F, identity: V) -> Self {
  147|      1|        fn tabulate<G: Fn(&K) -> V + Send + Sync + 'static>(
   41|       |        fn tabulate<G: Fn(&K) -> V>(f: G, keys: &ArraySetStEph<K>, reducer: F, identity: V) -> Self;
   43|       |        fn tabulate<G: Fn(&K) -> V>(f: G, keys: &ArraySetStEph<K>, reducer: F, identity: V) -> Self;
   43|       |        fn tabulate<G: Fn(&K) -> V + Send + Sync + 'static>(
   73|       |                // Tag each word with the document ID
  188|     25|        for (tail, (head, _, _)) in partition.iter() {
  255|     28|        for (tail, (head, _, _)) in partition.iter() {
  141|    147|            while taken < length {
   78|    122|            while taken < length {
  100|     68|                    if target == &node.key {
  102|    986|                    if target == &node.key {
  103|      2|                        Self::find_link(&node.left, target)
  105|    134|                        Self::find_link(&node.left, target)
  105|     58|                        Self::find_link(&node.right, target)
  107|     21|            if target < 0 {
  107|     26|            solver.subset_sum_rec(n, target)
  107|    690|                        Self::find_link(&node.right, target)
  108|  5.11k|                if target == &inner.value {
  111|     18|                    find_node(&inner.left, target)
  113|  4.97k|                    find_node(&inner.right, target)
  115|     21|            self.subset_sum_rec(n, target)
  116|     12|            if target < 0 {
  126|     10|            if target < 0 {
  126|    675|                        find_rec(&branch, target)
  127|     12|            self.subset_sum_rec(n, target)
  131|    175|            find_rec(&self.root, target)
  132|    604|                    if target == &node.key {
  133|    424|                    if target == &node.key {
  135|    217|                        Self::find_link(&node.left, target)
  136|    163|                        Self::find_link(&node.left, target)
  137|     10|            self.subset_sum_rec(n, target)
  137|    278|                        Self::find_link(&node.right, target)
  137|    382|                    if target == &node.key {
  138|    132|                        Self::find_link(&node.right, target)
  140|    130|                        Self::find_link(&node.left, target)
  142|    133|                        Self::find_link(&node.right, target)
  145|     36|                    if target == &node.key {
  148|      9|                        Self::find_link(&node.left, target)
  150|     16|                        Self::find_link(&node.right, target)
  157|    190|                    if target == &node.key {
  157|  2.01M|                    if target == &node.key {
  160|   633k|                        Self::find_link(&node.left, target)
  160|     77|                        Self::find_link(&node.left, target)
  162|  1.37M|                        Self::find_link(&node.right, target)
  162|     75|                        Self::find_link(&node.right, target)
  176|  1.18k|                    if target == &node.key {
  179|     28|                    if target == &node.key {
  179|    506|                        Self::find_link(&node.left, target)
  181|    470|                        Self::find_link(&node.right, target)
  182|      4|                        Self::find_link(&node.left, target)
  184|     16|                        Self::find_link(&node.right, target)
  193|  1.90k|                    if target == &node.key {
  196|    403|                        Self::find_link(&node.left, target)
  198|  1.07k|                        Self::find_link(&node.right, target)
   93|  5.12k|                if target == &inner.value {
   96|     21|                    contains_node(&inner.left, target)
   98|     27|            if target < 0 {
   98|  4.98k|                    contains_node(&inner.right, target)
   59|    173|                    let target_char = self.target.nth(j - 1);
   68|     93|                    let target_char = self.target.nth(j - 1);
   74|    550|                    let target_char = self.target.nth(j - 1);
   84|    118|                    let target_char = self.target.nth_cloned(j - 1);
  164|    178|            Self::find_link(&*guard, target).cloned()
  196|    154|            Self::find_link(&*guard, target).cloned()
  203|    134|            Self::find_link(&*guard, target).cloned()
  219|   232k|            Self::find_link(&*guard, target).cloned()
  258|    445|            Self::find_link(&*guard, target).cloned()
  106|     19|            let target_len = solver.target.length();
  108|     19|            solver.min_edit_distance_rec(source_len, target_len)
  120|     29|            let target_len = self.target.length();
  122|     29|            self.min_edit_distance_rec(source_len, target_len)
  131|      9|            let target_len = self.target.length();
  133|      9|            self.min_edit_distance_rec(source_len, target_len)
  147|     16|            let target_len = self.target.length();
  149|     16|            self.min_edit_distance_rec(source_len, target_len)
  131|      2|        fn target_mut(&mut self) -> &mut ArraySeqStEphS<T> { &mut self.target }
  158|      1|        fn target_mut(&mut self) -> &mut ArraySeqMtEphS<T> { &mut self.target }
   44|       |        fn target_mut(&mut self) -> &mut ArraySeqStEphS<T>;
   48|       |        fn target_mut(&mut self) -> &mut ArraySeqMtEphS<T>;
  113|      3|        fn target(&self) -> &ArraySeqStPerS<T> { &self.target }
  127|      8|        fn target(&self) -> &ArraySeqStEphS<T> { &self.target }
  138|      2|        fn target(&self) -> &ArraySeqMtPerS<T> { &self.target }
  154|      8|        fn target(&self) -> &ArraySeqMtEphS<T> { &self.target }
   38|       |        fn target(&self) -> &ArraySeqStEphS<T>;
   38|       |        fn target(&self) -> &ArraySeqStPerS<T>;
   41|       |        fn target(&self) -> &ArraySeqMtPerS<T>;
   42|       |        fn target(&self) -> &ArraySeqMtEphS<T>;
  100|     21|            let t_char = *self.seq_t.nth(j - 1);
  102|     23|            let t_char = *self.seq_t.nth(j - 1);
  127|     29|                    let t_char = self.seq_t.nth_cloned(j - 1);
  129|     22|                    let t_char = *self.seq_t.nth(j - 1);
  133|     21|            let t_char = *seq_t.nth(j - 1);
  134|     21|            let t_char = seq_t.nth_cloned(j - 1);
   69|     13|                    let t_char = *self.seq_t.nth(j - 1);
   72|     13|                    let t_char = *self.seq_t.nth(j - 1);
   74|     10|                    let t_char = self.seq_t.nth_cloned(j - 1);
   74|     10|                    let t_char = *self.seq_t.nth(j - 1);
  208|    487|            let temp_pq = BinaryHeapPQ { elements: new_elements };
  143|       |        // Test 1: searching for 'fun' should return {"jack", "mary", "peter"}
  150|       |        // Test 2: searching for 'club' should return {"mary"}
  157|       |        // Test 3: complex query should return ⟨'jack', 'peter'⟩
  170|       |        // Test 4: count query should return 2
  178|       |        // Test map operation performance
  233|      0|            writeln!(f, "Test keys: {:?}", self.keys)?;
  382|       |    /// Test utilities for hash functions
  386|       |        /// Test hash function distribution
  297|      1|        let test_cases = vec![
  213|     14|            let test_key = "clustering_test_key".to_string();
  317|      1|        let test_key = "example_key".to_string();
  341|      1|        let test_key = "probe_test".to_string();
  358|      2|        let test_key = "comparison_test";
  392|      2|        let test_key = "load_test";
  408|      2|        let test_key = "prime_test";
   24|       |        /// Tests if two keys are equal
   25|       |    /// Tests if a number is prime by checking divisibility up to sqrt(n).
   41|      2|        let test_strings = vec![
  101|       |        // Textbook Example
  103|      0|        let textbook = example_45_2_textbook_example();
  240|       |    /// Textbook Example: Primary Clustering Analysis
  249|       |    /// Textbook Example 47.4: Linear Probing Demonstration
  283|       |    /// Textbook Example 47.5: Quadratic Probing with Prime Table Size
   28|       |    /// Textbook Example Results
  308|       |    /// Textbook Example: Double Hashing with Relative Prime Validation
  318|       |    /// Textbook Example 47.6: Double Hashing Optimal Distribution
  335|       |    /// Textbook Example: Secondary Clustering Analysis with Prime Table Size
  450|       |    /// Textbook Example: Comprehensive Clustering Analysis
  180|       |        fn textbook_example() -> HeapsortComparison<i32>;
   19|       |    /// The triple loop is intentionally inefficient (sequential) to contrast with parallel functional methods.
  264|      1|This unifies the probe logic while allowing different behaviors.
  264|      2|             as the cluster grows, degrading performance significantly at high load factors."
  298|      2|             follow the same probe sequence (secondary clustering), but different initial \
  313|       |        /// The key innovation: O(1) reduction using cached value
  326|       |        /// The key innovation: O(1) reduction using cached value
  348|       |        /// The key innovation: O(1) reduction using cached value
    7|       |//! balanced. The balancing here chooses a midpoint split; higher chapters can replace
   81|       |        /// The period is table_size / gcd(h2_value, table_size)
  115|       |            // Then acquire lock once and write all results
  115|       |            // Then acquire lock once and write all results in-place
  116|       |            // This is a simplified check - in practice would need access to table internals
  130|       |            // This method signature doesn't make sense for LabEdge without a label
  130|       |        // (This would be implemented as a simple loop with insert)
  131|       |            // This is a design issue - we need the label to create a LabEdge
  133|       |        // This is what our implementation uses
  180|       |            // This method signature doesn't make sense for LabEdge without a label
  181|       |            // This is a design issue - we need the label to create a LabEdge
   18|       |    /// This is an educational example showing imperative style for comparison with functional approaches.
   19|       |    /// This is an educational example showing imperative style for comparison.
  209|       |            // This is a sequential operation anyway
   23|       |    /// This avoids recomputing max_prefix and max_suffix in the combine step.
  256|       |        /// This is what makes leftist heaps superior for applications requiring frequent melding
   28|       |    /// This is an educational example showing imperative style for comparison.
   31|      0|                    // This shouldn't happen if find_slot works correctly
  353|       |            // This would require access to internal tree structure
  410|       |        /// This would be much slower with other priority queue implementations!
  417|       |    /// This would be much slower with other priority queue implementations!
  431|       |        // This could be parallelized using the reduce pattern
   43|       |            // This ensures 1 <= step < m and step != 0
   47|       |    /// This shows the functional parallel approach for comparison with the imperative version.
   48|       |            // This gives the max subsequence ending at position i-1 in original array
    4|       |//! Note: This is a SEQUENTIAL implementation using thread-safe types.
    4|       |//! Note: This uses AVLTreeSetMtEph which wraps mutable state with Arc<Mutex<...>>.
   54|       |        /// This ensures the probe sequence visits all table positions
   92|       |                    // This shouldn't happen since we're building from scratch, but just in case
   96|       |        /// This is the key innovation that makes meld O(log n)!
   98|       |    /// This is a validation utility, not used in actual shortest path algorithms.
   99|       |    /// This is a validation utility, not used in actual shortest path algorithms.
  201|      1|2. Iterate through all chains in old table
   16|       |        /// Time). Since the code uses insert sequentially and since there are n inserts, the algorithm
  104|      1|            let t_len = self.seq_t.length();
  106|      1|            let t_len = self.seq_t.length();
  106|      1|            self.med_recursive_parallel(s_len, t_len)
  108|      1|            self.med_recursive_parallel(s_len, t_len)
  143|      1|                "BottomUpDPStPer(s_len={}, t_len={})",
  151|      1|                "BottomUpDPStEph(s_len={}, t_len={})",
  158|      1|                "TopDownDPStPer(s_len={}, t_len={}, memo_size={})",
  159|      1|                "TopDownDPStEph(s_len={}, t_len={}, memo_size={})",
  176|      1|                "BottomUpDPMtPer(s_len={}, t_len={})",
  187|      1|                "BottomUpDPMtEph(s_len={}, t_len={})",
  246|      1|                "TopDownDPMtPer(s_len={}, t_len={}, memo_size={})",
  254|      1|                "TopDownDPMtEph(s_len={}, t_len={}, memo_size={})",
   42|      3|            let t_len = self.seq_t.length();
   42|      6|            let t_len = self.seq_t.length();
   44|      3|            let t_len = self.seq_t.length();
   44|      4|            let t_len = self.seq_t.length();
   50|      3|            let t_len = self.seq_t.length();
   50|      3|            let t_len = self.seq_t.length();
   52|      2|            let t_len = self.seq_t.length();
   52|      2|            let t_len = self.seq_t.length();
   52|      3|            self.med_recursive(s_len, t_len)
   54|      2|            self.med_recursive_concurrent(s_len, t_len)
   54|      2|            self.med_recursive_concurrent(s_len, t_len)
   55|      3|            self.med_recursive(s_len, t_len, &mut memo)
   60|      3|            let t_len = self.seq_t.length();
   60|      6|            let t_len = self.seq_t.length();
   63|      3|            let t_len = self.seq_t.length();
   63|      4|            let t_len = self.seq_t.length();
   81|     13|            let t_len = self.seq_t.length();
   81|     20|            let t_len = self.seq_t.length();
   83|     13|            let t_len = self.seq_t.length();
   83|     16|            let t_len = self.seq_t.length();
  106|     13|            edges.insert((*from, *to, *weight));
  117|     15|            edges.insert((*from, *to, *weight));
  131|     13|            edges.insert((*from, *to, new_weight));
  147|     15|            edges.insert((*from, *to, new_weight));
   23|    222|                .map(|(from, to, weight)| LabEdge(from.clone(), to.clone(), *weight))
  260|       |                .expect("failed to spawn left thread");
  264|       |                .expect("failed to spawn right thread");
   27|     26|                .map(|(from, to, weight)| LabEdge(from.clone(), to.clone(), *weight))
   27|     32|                .map(|(from, to, weight)| LabEdge(from.clone(), to.clone(), *weight))
   42|      0|            self.add_labeled_arc(from, to, weight);
   51|    180|                .map(|(from, to, weight)| LabEdge(from.clone(), to.clone(), *weight))
   66|      1|            self.add_labeled_arc(from, to, weight);
   74|       |    /// to a representative of its component.
   84|     15|            self.labeled_arcs.insert(LabEdge(from, to, label));
   90|      2|            self.labeled_arcs.insert(LabEdge(from, to, label));
   49|      1|            self.get_arc_label(from, to).copied()
   73|      4|            self.get_arc_label(from, to).copied()
  201|       |    /// Tokenization function: splits content into words
    7|       |pub mod TopDownDPMtEph {
   38|       |    impl TopDownDPMtEphS {
    7|       |pub mod TopDownDPMtPer {
   38|       |    impl TopDownDPMtPerS {
    7|       |pub mod TopDownDPStEph {
   36|       |    impl TopDownDPStEphS {
    7|       |pub mod TopDownDPStPer {
   36|       |    impl TopDownDPStPerS {
   15|       |        fn topo_sort(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>) -> AVLTreeSeqStEphS<N>;
   16|       |        fn topo_sort(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>) -> AVLTreeSeqStPerS<N>;
    6|       |pub mod TopoSortStEph {
    6|       |pub mod TopoSortStPer {
  110|       |        // toSeq {2, 7, 8, 11} = ⟨8, 11, 2, 7⟩ (order may vary)
   60|       |        // toSeq {2, 7, 8, 11} = ⟨8, 11, 2, 7⟩ (order may vary)
   63|       |        /// toSeq (queryAnd ((fw 'fun'), queryOr ((fw 'food'), (fw 'chess'))))
  161|     23|        fn to_seq(docs: &DocumentSet) -> ArraySeqStPerS<DocumentId> {
   56|       |        fn to_seq(docs: &DocumentSet) -> ArraySeqStPerS<DocumentId>;
  127|      0|        fn to_seq(&self) -> AVLTreeSeqStPerS<T> { AVLTreeSeqStPerS::from_vec(self.elements.clone()) }
  128|     38|        fn to_seq(&self) -> AVLTreeSeqStPerS<T> {
  139|    166|        fn to_seq(&self) -> AVLTreeSeqStPerS<T> { self.base_set.to_seq() }
  146|      2|        fn to_seq(&self) -> ArraySeqStPerS<T> { self.elements.clone() }
  176|      1|        fn to_seq(&self) -> AVLTreeSeqStPerS<T> { self.elements.clone() }
  196|     13|        fn to_seq(&self) -> ArraySeqStPerS<T> { self.elements.clone() }
   20|       |        fn to_seq(&self) -> ArraySeqStEphS<T>;
   20|       |        fn to_seq(&self) -> AVLTreeSeqStPerS<T>;
   22|       |        fn to_seq(&self) -> AVLTreeSeqStEphS<T>;
  270|      1|        fn to_seq(&self) -> ArraySeqStPerS<T> { self.elements.clone() }
   27|       |        fn to_seq(&self) -> AVLTreeSeqMtPerS<T>;
   27|       |        fn to_seq(&self) -> AVLTreeSeqStEphS<T>;
   28|       |        fn to_seq(&self) -> ArraySeqMtEphS<N>;
   42|       |        fn to_seq(&self) -> AVLTreeSeqStPerS<T>;
   43|       |        fn to_seq(&self) -> AVLTreeSeqStPerS<T>;
   43|       |        fn to_seq(&self) -> AVLTreeSeqStPerS<T>;
   46|    279|        fn to_seq(&self) -> AVLTreeSeqStPerS<T> {
   46|     54|        fn to_seq(&self) -> ArraySeqStEphS<T> { self.elements.clone() }
   48|    268|        fn to_seq(&self) -> AVLTreeSeqStEphS<T> {
   49|       |        fn to_seq(&self) -> ArraySeqStPerS<T>;
   49|       |        fn to_seq(&self) -> ArraySeqStPerS<T>;
   49|       |        fn to_seq(&self) -> ArraySeqStPerS<T>;
   49|       |        fn to_seq(&self) -> AVLTreeSeqStPerS<T>;
   53|    147|        fn to_seq(&self) -> AVLTreeSeqMtPerS<T> { self.elements.clone() }
   56|     60|        fn to_seq(&self) -> AVLTreeSeqStEphS<T> {
   63|      1|        fn to_seq(&self) -> ArraySeqMtEphS<N> {
  139|    231|            let total = node.size as f64;
  196|    907|                let total = Self::size_link(&*guard);
  211|    130|            let total = a.length() + b.length();
  219|      1|            let total = a.length() + b.length();
  220|      1|            if total == 0 {
   25|     32|            let total = n_left + n_right;
   27|     32|            if total == 0 {
   28|       |//! let total = graph.total_weight(); // Returns OrderedFloat<f64>
   28|       |//! let total = graph.total_weight(); // Returns OrderedFloat<f64>
   30|   100k|            let total = self.data.len();
   30|    151|            let total = n_left + n_right;
   32|    151|            if total == 0 {
   36|     16|        let total = running_sum;
  381|      3|            let total = <LinkedListStPerS<T> as LinkedListStPerTrait<T>>::reduce(a, f, id);
   38|     16|        let total = running_sum;
  382|      3|            (LinkedListStPerS::from_vec(prefixes), total)
   39|    110|            let total = self.data.len();
  422|      3|            let total = <LinkedListStEphS<T> as LinkedListStEphTrait<T>>::reduce(a, f, id);
  423|      3|            (LinkedListStEphS::from_vec(prefixes), total)
   43|     87|            if total <= 2 {
   61|     21|        let total = t_left + t_right;
   61|       |        // total = t_left + t_right
   62|     21|        let total = t_left + t_right;
   87|    231|                let total = Self::size_link(&self.root);
   97|    907|            let total = node.size as f64;
  138|      4|            let total_cluster_elements: N = clusters.iter().sum();
  136|      4|            let total_clusters = clusters.len();
   23|       |        pub total_clusters: N,
  131|      8|            let total_len = a.length() + b.length();
  132|      8|            if total_len == 0 {
  133|      2|            let total_len = a.length() + b.length();
  134|      2|            if total_len == 0 {
  159|      5|            let total_len = left_entries.length() + right_entries.length();
  249|      1|            let total_len = a.length() + b.length();
  268|      5|            let total_len: N = sequences.iter().map(|s| s.length()).sum();
  269|      2|            if total_len == 0 {
  148|    272|            let total_occupied = result.num_elements + result.num_deleted;
   75|    295|            let total_occupied = self.num_elements + self.num_deleted;
  213|      1|        let tour = shortcut_tour_mt(&euler);
  242|      1|        let tour = shortcut_tour(&euler);
   32|       |        fn tour_weight_mt<V: StT + MtT + Hash + Ord>(
   34|       |        fn tour_weight<V: StT + Hash + Ord>(
  191|     22|        fn to_vec(&self) -> Vec<T> {
  287|      1|   - Track probe distances
   75|       |        // Track visited vertices (X in the algorithm)
   75|       |        // Track visited vertices (X in the algorithm)
  103|       |    pub trait Pred<T>: Fn(&T) -> B + Send + Sync + 'static {}
  108|       |    pub trait PredVal<T>: Fn(T) -> B + Send + Sync + 'static {}
   10|       |    pub trait Algorithm21_5Trait {
   10|       |    pub trait Chapter36StTrait<T: StT + Ord> {
   10|       |    pub trait DivConReduceMtTrait {
   10|       |    pub trait Example45_2Trait {
   10|       |    pub trait MaxContigSubSumOptTrait {
  111|       |    pub trait ArraySeqStEphTrait<T: StT> {
  113|       |    pub trait ArraySeqMtPerTrait<T: StTInMtT> {
  116|       |    pub trait HashOrd: StT + Hash + Ord {}
   11|       |    pub trait Example43_1Trait {
   11|       |    pub trait FibonacciMtTrait {
   11|       |    pub trait HashExamplesTrait {
   11|       |    pub trait HashFunction<K> {
  121|       |    pub trait ArithmeticT: StT + std::ops::Add<Output = Self> + Default + Copy {}
   12|       |    pub trait Chapter36MtSliceTrait<T: StT + Ord + Send> {
   12|       |    pub trait Chapter36MtTrait<T: StT + Ord + Send> {
   12|       |    pub trait CycleDetectStEphTrait {
   12|       |    pub trait CycleDetectStPerTrait {
   12|       |    pub trait DFSStEphTrait {
   12|       |    pub trait DFSStPerTrait {
   12|       |    pub trait Example41_3Trait {
   12|       |    pub trait OrderStatSelectMtPerTrait<T: StTInMtT + Ord> {
   12|       |    pub trait OrderStatSelectStEphTrait<T: StT + Ord> {
   12|       |    pub trait OrderStatSelectStPerTrait<T: StT + Ord> {
   12|       |    pub trait TopoSortStEphTrait {
  138|       |    pub trait AVLTreeSeqMtPerTrait<T: StTInMtT> {
  139|       |    pub trait AVLTreeSeqStPerTrait<T: StT> {
   13|       |    pub trait ArraySeqMtPerTrait<T: StTInMtT> {
   13|       |    pub trait BFSStEphTrait {
   13|       |    pub trait BFSStPerTrait {
   13|       |    pub trait Example42_1Trait {
   13|       |    pub trait MaxContigSubSumOptMtTrait {
   13|       |    pub trait ReduceContractMtEphTrait<T: StT + Send + Sync> {
   13|       |    pub trait ScanContractMtEphTrait<T: StT + Send + Sync> {
   13|       |    pub trait SCCStEphTrait {
   13|       |    pub trait SCCStPerTrait {
   13|       |    pub trait TopoSortStPerTrait {
   14|       |    pub trait AdjSeqGraphStEphTrait {
   14|       |    pub trait ArraySeqStEphTrait<T: StT> {
   14|       |    pub trait ArraySeqStPerTrait<T: StT> {
   14|       |    pub trait BFSMtEphTrait {
   14|       |    pub trait BFSMtPerTrait {
   14|       |    pub trait MergeSortMtTrait<T: StT + Ord + Send + Sync + 'static> {
   14|       |    pub trait OrderStatSelectMtEphTrait<T: StTInMtT + Ord> {
   14|       |    pub trait UnionFindStEphTrait<V: StT + Hash> {
   14|       |    /// Trait for primitive tree sequence operations
   15|       |    pub trait AdjMatrixGraphStEphTrait {
   15|       |    pub trait AdjSeqGraphStPerTrait {
   15|       |    pub trait Example56_1Trait {
   15|       |    pub trait Example56_3Trait {
   15|       |    pub trait PrimTreeSeqStTrait<T: StT> {
   15|       |    /// Trait for bottom-up dynamic programming operations
   15|       |    /// Trait for bottom-up dynamic programming operations
   15|       |    /// Trait for probability operations
   15|       |    /// Trait for top-down dynamic programming operations
   15|       |    /// Trait for top-down dynamic programming operations
   16|       |    pub trait AdjMatrixGraphStPerTrait {
   16|       |    pub trait ArraySeqMtEphTrait<T: StTInMtT> {
   16|       |    pub trait ArraySetStEphTrait<T: StT + Ord> {
   16|       |    pub trait AVLTreeSetStPerTrait<T: StT + Ord> {
   16|       |    pub trait BottomUpDPStEphTrait<T: StT> {
   16|       |    pub trait BottomUpDPStPerTrait<T: StT> {
   16|       |    pub trait EdgeSetGraphStEphTrait<V: StT + Ord> {
   16|       |    pub trait HeapsortTrait {
   16|       |    pub trait ProbabilityTrait {
   16|       |    pub trait SelectionStrategy<V: StT + Ord> {
   16|       |    pub trait TopDownDPStEphTrait<T: StT> {
   16|       |    pub trait TopDownDPStPerTrait<T: StT> {
   16|       |    /// Trait defining the Meldable Priority Queue ADT operations (Data Type 45.1)
   16|       |    /// Trait defining the Meldable Priority Queue ADT operations (Data Type 45.1)
   16|       |    /// Trait defining the Meldable Priority Queue ADT operations (Data Type 45.1)
   16|       |    /// Trait defining the Meldable Priority Queue ADT operations (Data Type 45.1)
  178|       |    pub trait HeapsortExamplesTrait {
   17|       |    pub trait AdjTableGraphMtPerTrait<V: StTInMtT + Ord + 'static> {
   17|       |    pub trait AdjTableGraphStEphTrait<V: StT + Ord> {
   17|       |    pub trait AdjTableGraphStPerTrait<V: StT + Ord> {
   17|       |    pub trait ArraySeq<T> {
   17|       |    pub trait BalancedTreePQTrait<T: StT + Ord> {
   17|       |    pub trait BinaryHeapPQTrait<T: StT + Ord> {
   17|       |    pub trait BSTPlainStEphTrait<T: StT + Ord> {
   17|       |    pub trait EdgeSetGraphStPerTrait<V: StT + Ord> {
   17|       |    pub trait PriorityFn<V: StT + Ord, P: StT + Ord> {
   17|       |    pub trait SetStEphTrait<T: StT + Hash> {
   17|       |    pub trait SortedListPQTrait<T: StT + Ord> {
   17|       |    pub trait SpanTreeMtEphTrait {
   17|       |    pub trait SpanTreeStEphTrait {
   17|       |    pub trait UnsortedListPQTrait<T: StT + Ord> {
   17|       |    pub trait VertexMatchingStEphTrait {
   17|       |    /// Trait for bottom-up dynamic programming operations
   17|       |    /// Trait for bottom-up dynamic programming operations
   17|       |    /// Trait for top-down dynamic programming operations
   17|       |    /// Trait for top-down dynamic programming operations
  180|       |    pub trait LinkedListStEphTrait<T: StT> {
   18|       |    pub trait AVLTreeSetStEphTrait<T: StT + Ord> {
   18|       |    pub trait BottomUpDPMtEphTrait<T: MtVal> {
   18|       |    pub trait BottomUpDPMtPerTrait<T: MtVal> {
   18|       |    pub trait KruskalStEphTrait {
   18|       |    pub trait StarContractionStEphTrait {
   18|       |    pub trait StarPartitionStEphTrait {
   18|       |    pub trait TopDownDPMtEphTrait<T: MtVal> {
   18|       |    pub trait TopDownDPMtPerTrait<T: MtVal> {
   18|       |    pub trait TSPApproxMtEphTrait {
   18|       |    pub trait VertexMatchingMtEphTrait {
   18|       |    /// Trait defining all ordered set operations (ADT 41.1 + ADT 43.1)
   18|       |    /// Trait for brute force maximum contiguous subsequence sum.
   19|       |    pub trait BoruvkaStEphTrait {
   19|       |    pub trait BSTSetAVLMtEphTrait<T: StTInMtT + Ord>: Sized {
   19|       |    pub trait BSTSetBBAlphaMtEphTrait<T: StTInMtT + Ord>: Sized {
   19|       |    pub trait BSTSetPlainMtEphTrait<T: StTInMtT + Ord>: Sized {
   19|       |    pub trait BSTSetRBMtEphTrait<T: StTInMtT + Ord>: Sized {
   19|       |    pub trait BSTSetSplayMtEphTrait<T: StTInMtT + Ord>: Sized {
   19|       |    pub trait BSTSetTreapMtEphTrait<T: StTInMtT + Ord>: Sized {
   19|       |    pub trait DirGraphStEphTrait<V: StT + Hash> {
   19|       |    pub trait EdgeContractionStEphTrait {
   19|       |    pub trait EdgeSetGraphMtPerTrait<V: StTInMtT + Ord + 'static> {
   19|       |    pub trait LabDirGraphStEphTrait<V: StT + Hash, L: StT + Hash> {
   19|       |    pub trait LabUnDirGraphStEphTrait<V: HashOrd, L: StT + Hash> {
   19|       |    pub trait MaxContigSubSumBruteTrait {
   19|       |    pub trait OrderedSetStPerTrait<T: StT + Ord> {
   19|       |    pub trait RelationStEphTrait<X: StT + Hash, Y: StT + Hash> {
   19|       |    pub trait SelectionStrategy<V: StT + Ord> {
   19|       |    pub trait SpinLockTrait {
   19|       |    pub trait UnDirGraphStEphTrait<V: StT + Hash> {
   19|       |    /// Trait defining all ordered set operations (ADT 41.1 + ADT 43.1) with ephemeral semantics
   19|       |    /// Trait defining all ordered set operations (ADT 41.1 + ADT 43.1) with multi-threaded ephemeral semantics
   19|       |    /// Trait defining all ordered table operations (ADT 42.1 + ADT 43.1 for keys)
   19|       |    /// Trait defining all ordered table operations (ADT 42.1 + ADT 43.1 for keys) with ephemeral semantics
   19|       |    /// Trait defining the Table ADT operations from Chapter 42
   19|       |    /// Trait defining the Table ADT operations from Chapter 42
   19|       |    /// Trait for reduced force maximum contiguous subsequence sum.
   19|       |    /// Trait for stack operations
   19|       |    /// Trait for subset sum operations
   19|       |    /// Trait for subset sum operations
   20|       |    pub trait EdgeContractionMtEphTrait {
   20|       |    pub trait MappingStEphTrait<X: StT + Hash, Y: StT + Hash> {
   20|       |    pub trait MaxContigSubSumReducedTrait {
   20|       |    pub trait OrderedSetMtEphTrait<T: MtKey> {
   20|       |    pub trait OrderedSetStEphTrait<T: StT + Ord> {
   20|       |    pub trait OrderedTableMtPerTrait<K: StTInMtT + Ord, V: StTInMtT> {
   20|       |    pub trait OrderedTableStEphTrait<K: StT + Ord, V: StT> {
   20|       |    pub trait OrderedTableStPerTrait<K: StT + Ord, V: StT> {
   20|       |    pub trait StackStEphTrait<T: StT> {
   20|       |    pub trait StarPartitionMtEphTrait {
   20|       |    pub trait SubsetSumStEphTrait<T: StT> {
   20|       |    pub trait SubsetSumStPerTrait<T: StT> {
   20|       |    pub trait TableStEphTrait<K: StT + Ord, V: StT> {
   20|       |    pub trait TableStPerTrait<K: StT + Ord, V: StT> {
   20|       |    pub trait TSPApproxStEphTrait {
   20|       |    /// Trait for key equality testing
   20|       |    /// Trait for minimum edit distance operations
   20|       |    /// Trait for minimum edit distance operations
   20|       |    /// Trait for parallel subset sum operations
   21|       |    pub trait BellmanFordStEphFloatTrait {
   21|       |    pub trait BellmanFordStEphIntTrait {
   21|       |    pub trait BoruvkaMtEphTrait {
   21|       |    pub trait ChainedHashTable<Key: StT, Value: StT, Entry: EntryTrait<Key, Value>, Metrics: Default>:
   21|       |    pub trait MinEditDistStEphTrait<T: StT> {
   21|       |    pub trait MinEditDistStPerTrait<T: StT> {
   21|       |    pub trait PathWeightUtilsStPerTrait {
   21|       |    pub trait PrimStEphTrait {
   21|       |    pub trait PriorityFn<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static> {
   21|       |    pub trait SelectionStrategy<V: StTInMtT + Ord + 'static> {
   21|       |    pub trait StarContractionMtEphTrait {
   21|       |    pub trait SubsetSumMtPerTrait<T: MtVal> {
   21|       |    /// Trait for parallel minimum edit distance operations
   21|       |    /// Trait for parallel subset sum operations
   22|       |    pub trait ArraySetEnumMtEphTrait {
   22|       |    pub trait ConnectivityStEphTrait {
   22|       |    pub trait DijkstraStEphFloatTrait {
   22|       |    pub trait DijkstraStEphIntTrait {
   22|       |    pub trait DirGraphMtEphTrait<V: StT + MtT + Hash + 'static> {
   22|       |    pub trait KeyEquality<K> {
   22|       |    pub trait LinkedListStPerTrait<T: StT> {
   22|       |    pub trait MinEditDistMtPerTrait<T: MtVal> {
   22|       |    pub trait PathWeightUtilsStEphTrait {
   22|       |    pub trait PriorityFn<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static>: Send + Sync + 'static {
   22|       |    pub trait PriorityFn<V: StT + Ord, P: StT + Ord> {
   22|       |    pub trait SubsetSumMtEphTrait<T: MtVal> {
   22|       |    pub trait UnDirGraphMtEphTrait<V: StT + MtT + Hash + 'static> {
   22|       |    /// Trait defining all ordered table operations (ADT 42.1 + ADT 43.1 for keys) with multi-threaded ephemeral semantics
   22|       |    /// Trait defining the Table ADT operations from Chapter 42
   22|       |    /// Trait for parallel minimum edit distance operations
   23|       |    pub trait AVLTreeSetMtEphTrait<T: StTInMtT + Ord + 'static> {
   23|       |    pub trait AVLTreeSetMtPerTrait<T: StTInMtT + Ord + 'static> {
   23|       |    pub trait LabDirGraphMtEphTrait<V: StT + MtT + Hash + 'static, L: StTInMtT + Hash + 'static> {
   23|       |    pub trait LabUnDirGraphMtEphTrait<V: HashOrd + MtT + 'static, L: StTInMtT + Hash + 'static> {
   23|       |    pub trait MathSeqTrait<T: StT + Hash> {
   23|       |    pub trait MinEditDistMtEphTrait<T: MtVal> {
   23|       |    pub trait OrderedTableMtEphTrait<K: MtKey, V: MtVal> {
   23|       |    pub trait TableMtEphTrait<K: MtKey, V: MtVal> {
   23|       |    /// Trait for all-pairs shortest path result operations
   23|       |    /// Trait for single-source shortest path result operations
   24|       |    pub trait AllPairsResultStPerIntTrait {
   24|       |    pub trait ConcurrentStackMtTrait<T: StTInMtT> {
   24|       |    pub trait JohnsonStEphIntTrait {
   24|       |    pub trait SSSPResultStPerIntTrait {
   24|       |    /// Trait for all-pairs shortest path result operations
   24|       |    /// Trait for matrix chain multiplication operations
   24|       |    /// Trait for matrix chain multiplication operations
   24|       |    /// Trait for single-source shortest path result operations
  257|       |    pub trait HeapsortAnalysisTrait {
   25|       |    pub trait AllPairsResultStEphIntTrait {
   25|       |    pub trait ConnectivityMtEphTrait {
   25|       |    pub trait JohnsonStEphFloatTrait {
   25|       |    pub trait MatrixChainStEphTrait {
   25|       |    pub trait MatrixChainStPerTrait {
   25|       |    pub trait SSSPResultStEphIntTrait {
   25|       |    /// Trait for all-pairs shortest path result operations
   26|       |    pub trait AllPairsResultStPerFloatTrait {
   26|       |    pub trait BalBinTreeStEphTrait<T: StT> {
   26|       |    /// Trait for all-pairs shortest path result operations
   26|       |    /// Trait for optimal BST operations
   26|       |    /// Trait for optimal BST operations
   26|       |    /// Trait for parallel matrix chain multiplication operations
   26|       |    /// Trait for parallel matrix chain multiplication operations
   26|       |    /// Trait for single-source shortest path result operations
   26|       |    /// Trait for single-source shortest path result operations
   27|       |    pub trait AllPairsResultStEphFloatTrait {
   27|       |    pub trait MatrixChainMtEphTrait {
   27|       |    pub trait MatrixChainMtPerTrait {
   27|       |    pub trait OBSTStEphTrait<T: StT> {
   27|       |    pub trait OBSTStPerTrait<T: StT> {
   27|       |    pub trait SSSPResultStEphFloatTrait {
   27|       |    pub trait SSSPResultStPerFloatTrait {
   27|       |    /// Trait defining all augmented ordered table operations (ADT 43.3)
   27|       |    /// Trait defining all augmented ordered table operations (ADT 43.3) with ephemeral semantics
   27|       |    /// Trait for parallel optimal BST operations
   27|       |    /// Trait for parallel optimal BST operations
  286|       |    pub trait ParamTreapTrait<T: MtKey + 'static>: Sized {
   28|       |    pub trait OBSTMtEphTrait<T: MtVal> {
   28|       |    pub trait OBSTMtPerTrait<T: MtVal> {
   28|       |    /// Trait defining the Document Index ADT (Data Type 44.1)
   28|       |    /// Trait defining the Meldable Priority Queue ADT operations (Data Type 45.1)
   28|       |    /// Trait for probe sequence generation
   29|       |    pub trait AugOrderedTableStEphTrait<K: StT + Ord, V: StT, F>
   29|       |    pub trait AugOrderedTableStPerTrait<K: StT + Ord, V: StT, F>
   29|       |    pub trait DocumentIndexTrait {
   29|       |    pub trait JohnsonMtEphFloatTrait {
   29|       |    pub trait JohnsonMtEphIntTrait {
   29|       |    pub trait LeftistHeapPQTrait<T: StT + Ord> {
   29|       |    pub trait ProbeSequence<K: StT> {
   30|       |    pub trait ParamBSTTrait<T: MtKey + 'static>: Sized {
   30|       |    pub trait UniversalHashFamily<K> {
   30|       |    /// Trait defining all augmented ordered table operations (ADT 43.3) with multi-threaded ephemeral semantics
  312|       |    pub trait SequenceUtilsTrait {
   32|       |    pub trait AugOrderedTableMtEphTrait<K: MtKey, V: MtVal, F: MtReduceFn<V>> {
   32|       |    pub trait ParamBSTTrait<T: StT + Ord>: Sized {
   33|       |    /// Trait for parametric nested hash tables.
   35|       |    pub trait EntryTrait<Key, Value> {
   38|       |    pub trait ArraySeqMtEphSliceTrait<T: StT + Send + Sync> {
   38|       |    pub trait BSTSplayStEphTrait<T: StT + Ord> {
   38|       |    pub trait GraphSearchStEphTrait<V: StT + Ord> {
   39|       |    pub trait PQMinStEphTrait<V: StT + Ord, P: StT + Ord> {
   39|       |    /// Trait for associative reduction operations
  408|       |    pub trait LeftistHeapDemoTrait {
   40|       |    pub trait BSTAVLStEphTrait<T: StT + Ord> {
   40|       |    pub trait BSTBBAlphaStEphTrait<T: StT + Ord> {
   40|       |    pub trait BSTSizeStEphTrait<T: StT + Ord> {
   40|       |    pub trait BSTSplayMtEphTrait<T: StTInMtT + Ord>: Sized {
   40|       |    pub trait BSTTreapStEphTrait<T: StT + Ord> {
   40|       |    pub trait ReduceOp<V: StT, R: StT> {
   41|       |    pub trait BSTKeyValueStEphTrait<K: StT + Ord, V: StT> {
   42|       |    pub trait BSTAVLMtEphTrait<T: StTInMtT + Ord>: Sized {
   42|       |    pub trait BSTBBAlphaMtEphTrait<T: StTInMtT + Ord>: Sized {
   42|       |    pub trait BSTTreapMtEphTrait<T: StTInMtT + Ord>: Sized {
   42|       |    /// Trait for parametric nested hash tables.
   43|       |    pub trait AVLTreeSeqStEphTrait<T: StT> {
   43|       |    pub trait GraphSearchMtPerTrait<V: StTInMtT + Ord + 'static> {
   43|       |    pub trait ParaHashTableStEphTrait<Key: StT, Value: StT, Entry: EntryTrait<Key, Value>, Metrics: Default>
   45|       |    pub trait PQMinMtPerTrait<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static> {
   45|       |    pub trait PQMinStPerTrait<V: StT + Ord, P: StT + Ord> {
   46|       |    pub trait BSTRBStEphTrait<T: StT + Ord> {
   47|       |    pub trait FlatHashTable<Key: StT, Value: StT, Entry: EntryTrait<Key, Value>, Metrics: Default>:
   47|       |    pub trait GraphSearchStPerTrait<V: StT + Ord> {
   48|       |    pub trait AVLTreeSeq<T: Copy + Debug> {
   48|       |    pub trait BSTPlainMtEphTrait<T: StTInMtT + Ord>: Sized {
   48|       |    pub trait BSTRBMtEphTrait<T: StTInMtT + Ord>: Sized {
   53|       |    pub trait PQMinMtEphTrait<V: StTInMtT + Ord + 'static, P: StTInMtT + Ord + 'static> {
   56|       |    pub trait StT: Eq + Clone + Display + Debug + Sized {}
   59|       |    /// Trait for divide-and-conquer maximum contiguous subsequence sum.
   60|       |    pub trait MaxContigSubSumDivConTrait {
   60|       |    pub trait StTInMtT: StT + Send + Sync {}
   60|       |    /// Trait for parallel divide-and-conquer maximum contiguous subsequence sum.
   61|       |    pub trait MaxContigSubSumDivConMtTrait {
   65|       |    pub trait MtT: Sized + Send + Sync {
   66|       |    /// Trait for parallel strengthened divide-and-conquer maximum contiguous subsequence sum.
   67|       |    pub trait MaxContigSubSumDivConOptMtTrait {
   67|       |    /// Trait for strengthened divide-and-conquer maximum contiguous subsequence sum.
   68|       |    pub trait MaxContigSubSumDivConOptTrait {
    6|       |    pub trait InsertionSortStTrait<T: Ord + Clone> {
   73|       |    pub trait HashFunClone<K>: crate::Chap47::HashFunctionTraits::HashFunctionTraits::HashFunction<K> + Clone {}
   78|       |    pub trait ArraySeqStPerTrait<T: StT> {
   78|       |    pub trait MtKey: StTInMtT + Ord + 'static {}
   81|       |    pub trait BSTReducedStEphTrait<K: StT + Ord, V: StT, R: StT, Op: ReduceOp<V, R>> {
   83|       |    pub trait MtVal: StTInMtT + 'static {}
   88|       |    pub trait MtFn<Args, Output>: Fn(Args) -> Output + Send + Sync + 'static {}
    8|       |    pub trait FetchAddCasTrait {
   93|       |    pub trait MtFnClone<Args, Output>: Fn(Args) -> Output + Send + Sync + Clone + 'static {}
   95|       |    pub trait ArraySeqMtEphTrait<T: StTInMtT> {
   98|       |    pub trait MtReduceFn<V>: Fn(&V, &V) -> V + Clone + Send + Sync + 'static {}
    9|       |    pub trait Algorithm21_1Trait {
    9|       |    pub trait Algorithm21_2Trait {
    9|       |    pub trait Algorithm21_6Trait {
    9|       |    pub trait DivConReduceStTrait {
    9|       |    pub trait Exercise21_5Trait {
    9|       |    pub trait Exercise21_7Trait {
    9|       |    pub trait Exercise21_8Trait {
    9|       |    pub trait MergeSortStTrait<T: StT + Ord> {
    9|       |    pub trait Problem21_1Trait {
    9|       |    pub trait Problem21_3Trait {
    9|       |    pub trait Problem21_4Trait {
    9|       |    pub trait ReduceContractStEphTrait<T: StT> {
    9|       |    pub trait ScanContractStEphTrait<T: StT> {
    9|       |    /// Trait for Example 45.2 operations
   23|      7|        let transposed = transpose_graph(graph);
   23|      7|        let transposed = transpose_graph(graph);
   81|      7|    fn transpose_graph(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>) -> ArraySeqStEphS<ArraySeqStEphS<N>> {
   83|      7|    fn transpose_graph(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>) -> ArraySeqStPerS<ArraySeqStPerS<N>> {
  193|    572|            fn traverse<T: StTInMtT + Ord>(link: &Link<T>, out: &mut Vec<T>) {
    2|       |//! Ephemeral Treap (randomized heap-ordered BST) with `find` support.
    2|       |//! Ephemeral Treap (randomized heap-ordered BST) with interior locking for multi-threaded access.
   69|       |            // Treat edges as unordered: {u,v}
   72|       |            // Treat edges as unordered: {u,v}
  113|      7|            match tree {
  152|      0|            match tree {
  205|       |            let __tree = < $crate::Chap38::BSTParaStEph::BSTParaStEph::ParamBST<_> as
  206|    280|            let tree = BSTRBMtEph::new();
  206|      6|            let tree = BSTAVLMtEph::new();
  206|      6|            let tree = BSTBBAlphaMtEph::new();
  206|      6|            let tree = BSTSplayMtEph::new();
  206|      6|            let tree = BSTTreapMtEph::new();
  206|      7|            let tree = BSTPlainMtEph::new();
  216|       |            let __tree = $crate::Chap37::BSTPlainMtEph::BSTPlainMtEph::BSTPlainMtEph::new();
  217|     34|            let tree = BSTRBMtEph::new();
  217|     41|            let tree = BSTBBAlphaMtEph::new();
  217|     41|            let tree = BSTSplayMtEph::new();
  217|     44|            let tree = BSTAVLMtEph::new();
  217|     48|            let tree = BSTPlainMtEph::new();
  217|     48|            let tree = BSTTreapMtEph::new();
  218|       |            let __tree = < $crate::Chap37::BSTSplayMtEph::BSTSplayMtEph::BSTSplayMtEph<_> as $crate::Chap37::BSTSplayMtEph::BSTSplayMtEph::BSTSplayMtEphTrait<_> >::new();
  221|       |            let __tree = $crate::Chap37::BSTPlainMtEph::BSTPlainMtEph::BSTPlainMtEph::new();
  251|       |            let __tree = < $crate::Chap39::BSTTreapMtEph::BSTTreapMtEph::BSTTreapMtEph<_> as $crate::Chap39::BSTTreapMtEph::BSTTreapMtEph::BSTTreapMtEphTrait<_> >::new();
  258|       |            let __tree = < $crate::Chap37::BSTBBAlphaMtEph::BSTBBAlphaMtEph::BSTBBAlphaMtEph<_> as $crate::Chap37::BSTBBAlphaMtEph::BSTBBAlphaMtEph::BSTBBAlphaMtEphTrait<_> >::new();
  267|       |            let __tree = < $crate::Chap37::BSTAVLMtEph::BSTAVLMtEph::BSTAVLMtEph<_> as $crate::Chap37::BSTAVLMtEph::BSTAVLMtEph::BSTAVLMtEphTrait<_> >::new();
    2|       |//! Primitive tree sequence implementation for Chapter 23.
  312|       |            let __tree = < $crate::Chap37::BSTRBMtEph::BSTRBMtEph::BSTRBMtEph<_> as $crate::Chap37::BSTRBMtEph::BSTRBMtEph::BSTRBMtEphTrait<_> >::new();
  446|       |            let __tree = < $crate::Chap39::BSTParaTreapMtEph::BSTParaTreapMtEph::ParamTreap<_> as $crate::Chap39::BSTParaTreapMtEph::BSTParaTreapMtEph::ParamTreapTrait<_> >::new();
   70|      2|            let tree = BSTAVLMtEph::new();
   70|      2|            let tree = BSTBBAlphaMtEph::new();
   70|      2|            let tree = BSTPlainMtEph::new();
   70|      2|            let tree = BSTRBMtEph::new();
   70|      2|            let tree = BSTSplayMtEph::new();
   70|      2|            let tree = BSTTreapMtEph::new();
  112|      5|        if tree_edges.size() != expected_edges {
   83|      0|        if tree_edges.size() != expected_edges {
  102|      8|            match tree.expose_internal() {
  109|  7.88k|            match tree.expose_internal() {
  134|  1.32k|            match tree.expose_internal() {
  135|     72|            match tree.expose_internal() {
  216|    547|            match tree.expose_internal() {
  244|    548|            match tree.expose_internal() {
  272|  1.27k|            match tree.expose_internal() {
  275|      0|            match tree.expose_internal() {
   81|     80|            match tree.expose_internal() {
  122|    775|            match tree.expose_with_priority() {
  213|     25|            match tree.expose_with_priority() {
  244|     10|            match tree.expose_with_priority() {
  233|       |            $( __tree.insert($k, $v); )*
  344|       |            $( __tree.insert($k, $v); )*
  149|       |            $( __tree.insert($x); )*
  195|       |            $( __tree.insert($x); )*
  207|       |            $( __tree.insert($x); )*
  219|       |            $( __tree.insert($x); )*
  222|       |            $( __tree.insert($x); )*
  230|       |            $( __tree.insert($x); )*
  252|       |            $( __tree.insert($x); )*
  252|       |            $( __tree.insert($x); )*
  259|       |            $( __tree.insert($x); )*
  268|       |            $( __tree.insert($x); )*
  274|       |            $( __tree.insert($x); )*
  276|       |            $( __tree.insert($x); )*
  300|       |            $( __tree.insert($x); )*
  313|       |            $( __tree.insert($x); )*
  447|       |            $( __tree.insert($x); )*
   41|  2.22k|    fn tree_priority<T: MtKey>(tree: &ParamTreap<T>) -> i64 {
   46|  2.26k|    fn tree_size<T: MtKey>(tree: &ParamTreap<T>) -> N {
   31|       |    // Triple wrapper for three-element tuples
  100|      2|                        return true;
  105|     38|                    return true;
  106|      0|            return true;
  107|      0|            return true;
  107|      3|                        new_bits.set(elem_i, true);
  111|     13|                    return true;
  111|      4|                    return true;
  114|     54|                clustering_enabled: true,
  115|     54|                prime_validation_enabled: true,
  116|     84|                    return true;
  118|      1|                return true; // Empty graph is considered connected
  119|    223|                    return true;
  121|     25|                clustering_enabled: true,
  122|     25|                prime_validation_enabled: true,
  134|      0|            return true;
  134|     42|                clustering_enabled: true,
  135|      0|            return true;
  135|     42|                prime_validation_enabled: true,
  142|    291|                    return true;
  144|    792|                    return true;
  147|      2|                    return true;
  164|     33|                self.bits.set(x, true);
  175|      0|            (result, true)
  182|      1|            (result, true)
  200|      0|                return (true, "Validation disabled".to_string());
  227|      7|                    return true;
  245|      1|                return (true, "Validation disabled".to_string());
   28|      3|                    return true;
   28|      3|                    return true;
  323|      1|                return true;
   36|     66|                clustering_enabled: true,
  380|      0|                return true;
   42|      3|            return true;
   43|      3|            return (true, visited);
   45|      2|        assert_eq!(set_search.find(&6), true);
   47|      5|                return true;
   55|     23|                visualization_enabled: true,
   57|      7|                return true;
   59|      7|                return (true, new_visited);
   62|      1|            return true;
   63|      1|                        return true;
   63|      2|                        return true;
   67|      5|                    return true;
   69|      2|                        return true;
   70|     20|            if true == self.E.mem(&Edge(u.clone(), v.clone())) || true == self.E.mem(&Edge(v.clone(), u.clone())) {
   72|      5|                    return true;
   73|     13|                analysis_enabled: true,
   73|     46|            if true == self.E.mem(&Edge(u.clone_mt(), v.clone_mt()))
   74|     13|                detailed_metrics: true,
   74|     23|                || true == self.E.mem(&Edge(v.clone_mt(), u.clone_mt()))
   76|      0|                | (true, true) => Ordering::Equal,
   77|      0|                | (true, false) => Ordering::Greater, // NaN > everything
   79|      1|                bits.set(x, true);
   81|      1|                return true; // Empty graph is considered connected
   88|     19|            if true == self.A.mem(&Edge(u.clone(), v.clone())) {
   89|     11|                    bits.set(elem, true);
   91|  7.04k|            if true == self.A.mem(&Edge(u.clone_mt(), v.clone_mt())) {
   95|      2|        assert_eq!(set_search.find(&6), true);
   99|     17|                    return true;
   64|       |                        // Try both including and excluding the element
   69|       |                // Try each key as root and find minimum cost
   71|       |                // Try each possible split point and find minimum cost
   73|       |                        // Try both including and excluding the element
   81|       |                // Try each key as root and find minimum cost
   83|       |                // Try each possible split point and find minimum cost
    7|       |pub mod TSPApproxMtEph {
    9|       |pub mod TSPApproxStEph {
   41|       |    impl TweetQueryExamples {
  181|      1|        let tweets = create_tweet_collection();
  201|      1|        let tweets = create_tweet_collection();
   23|     20|        let tweets = create_tweet_collection();
   48|      1|        let two_cycles = ArraySeqStPerS::from_vec(vec![0, 1, 2, 1, 2, 1]);
   10|       |    pub type N = usize;
   11|       |    pub type ArraySeqMtPerS<T> = ArraySeqMtPerSChap18<T>;
   12|       |    pub type ArraySeqStEphS<T> = ArraySeqStEphSChap18<T>;
   12|       |    pub type ArraySeqStPerS<T> = ArraySeqStPerSChap18<T>;
   13|       |    pub type WeightedDirGraphStEphInt<V> = LabDirGraphStEph<V, i32>;
   13|       |    pub type WeightedUnDirGraphStEphInt<V> = LabUnDirGraphStEph<V, i32>;
   14|       |    pub type ArraySeqMtEphS<T> = ArraySeqMtEphSChap18<T>;
   14|       |    pub type ArraySetS<T> = ArraySetStEph<T>;
   14|       |    pub type AVLTreeSetPer<T> = AVLTreeSetStPer<T>;
   14|       |    pub type B = bool;
   14|       |    pub type HashFun<K> = Box<dyn Fn(&K) -> N>;
   14|       |    pub type Word = String;
   15|       |    pub type BSTree<T> = BSTPlainStEph<T>;
   15|       |    pub type DocumentId = String;
   16|       |    pub type ArrayStEph<T> = ArraySeqStEphS<T>;
   16|       |    pub type ArrayStPer<T> = ArraySeqStPerS<T>;
   16|       |    pub type AVLTreeSetS<T> = AVLTreeSetStEph<T>;
   16|       |    pub type Contents = String;
   16|       |    pub type OrderedSetPer<T> = OrderedSetStPer<T>;
   17|       |    pub type BSTSetAVLMt<T> = BSTSetAVLMtEph<T>;
   17|       |    pub type BSTSetBBAlphaMt<T> = BSTSetBBAlphaMtEph<T>;
   17|       |    pub type BSTSetPlainMt<T> = BSTSetPlainMtEph<T>;
   17|       |    pub type BSTSetRBMt<T> = BSTSetRBMtEph<T>;
   17|       |    pub type BSTSetSplayMt<T> = BSTSetSplayMtEph<T>;
   17|       |    pub type BSTSetTreapMt<T> = BSTSetTreapMtEph<T>;
   17|       |    pub type DocumentSet = AVLTreeSetStPer<DocumentId>;
   17|       |    pub type OrderedSetEph<T> = OrderedSetStEph<T>;
   17|       |    pub type OrderedSetMt<T> = OrderedSetMtEph<T>;
   17|       |    pub type OrderedTableEph<K, V> = OrderedTableStEph<K, V>;
   17|       |    pub type OrderedTablePer<K, V> = OrderedTableStPer<K, V>;
   17|       |    pub type TableS<K, V> = TableStEph<K, V>;
   17|       |    pub type TableS<K, V> = TableStPer<K, V>;
   17|       |    pub type WeightedDirGraphMtEphFloat<V> = LabDirGraphMtEph<V, OrderedF64>;
   17|       |    pub type WeightedDirGraphMtEphInt<V> = LabDirGraphMtEph<V, i32>;
   17|       |    pub type WeightedUnDirGraphMtEphFloat<V> = LabUnDirGraphMtEph<V, OrderedF64>;
   17|       |    pub type WeightedUnDirGraphMtEphInt<V> = LabUnDirGraphMtEph<V, i32>;
   20|       |    pub type DocumentCollection = ArraySeqStPerS<Pair<DocumentId, Contents>>;
   20|       |    pub type OrderedTableMt<K, V> = OrderedTableMtEph<K, V>;
   20|       |    pub type TableS<K, V> = TableMtEph<K, V>;
  243|       |    pub type OrderedF32 = OrderedFloat<f32>;
  244|       |    pub type OrderedF64 = OrderedFloat<f64>;
   25|       |    pub type AugOrderedTableEph<K, V, F> = AugOrderedTableStEph<K, V, F>;
   25|       |    pub type AugOrderedTablePer<K, V, F> = AugOrderedTableStPer<K, V, F>;
  289|       |    /// Type aliases for common configurations
   28|       |    pub type AugOrderedTableMt<K, V, F> = AugOrderedTableMtEph<K, V, F>;
  290|       |    pub type StringSeparateChaining<V> =
  326|       |    /// Type aliases for common configurations
  327|       |    pub type StringNestedHashTable<V> = NestedHashTable<String, V>;
  328|       |    pub type IntegerNestedHashTable<V> = NestedHashTable<i32, V>;
  333|       |    // Type aliases for common reductions
  334|       |    pub type BSTSumStEph<K, V> = BSTReducedStEph<K, V, V, SumOp<V>>;
  335|       |    pub type BSTCountStEph<K, V> = BSTReducedStEph<K, V, N, CountOp<V>>;
   34|       |    /// Type alias for linear probing hash table
   35|       |    pub type LinearProbingHashTable<K, V, H> = FlatHashTable<K, V, LinearProbingStrategy<K, H>>;
   36|       |    pub type BSTreeSplay<T> = BSTSplayStEph<T>;
   38|       |    pub type BSTreeAVL<T> = BSTAVLStEph<T>;
   38|       |    pub type BSTreeBBAlpha<T> = BSTBBAlphaStEph<T>;
   38|       |    pub type BSTreeSize<T> = BSTSizeStEph<T>;
   38|       |    pub type BSTreeSplay<T> = BSTSplayMtEph<T>;
   38|       |    pub type BSTreeTreap<T> = BSTTreapStEph<T>;
   39|       |    pub type BSTreeKeyValue<K, V> = BSTKeyValueStEph<K, V>;
   40|       |    pub type BSTreeAVL<T> = BSTAVLMtEph<T>;
   40|       |    pub type BSTreeBBAlpha<T> = BSTBBAlphaMtEph<T>;
   40|       |    pub type BSTreeTreap<T> = BSTTreapMtEph<T>;
   41|       |    pub type WeightedDirGraphStEphFloat<V> = LabDirGraphStEph<V, OrderedF64>;
   41|       |    pub type WeightedUnDirGraphStEphFloat<V> = LabUnDirGraphStEph<V, OrderedF64>;
   44|       |    pub type BSTreeRB<T> = BSTRBStEph<T>;
   46|       |    pub type BSTreeRB<T> = BSTRBMtEph<T>;
   46|       |    pub type BSTree<T> = BSTPlainMtEph<T>;
   46|       |    pub type LabeledEdge<V> = (V, V, OrderedFloat<f64>, usize);
   47|       |    /// Type alias for double hashing hash table
   48|       |    pub type DoubleHashingHashTable<K, V, H1, H2> = FlatHashTable<K, V, DoubleHashingStrategy<K, H1, H2>>;
   49|       |    /// Type alias for quadratic probing hash table
   50|       |    pub type QuadraticProbingHashTable<K, V, H> = FlatHashTable<K, V, QuadraticProbingStrategy<K, H>>;
   54|       |    pub type LabeledEdge<V> = (V, V, OrderedFloat<f64>, usize);
   54|       |    // Type bounds shorthands
   79|       |    pub type BSTreeReduced<K, V, R, Op> = BSTReducedStEph<K, V, R, Op>;
    2|       |//! Common types used across the crate.
    5|       |pub mod Types {
  100|     34|            let u = entry.vertex;
  100|      5|            if u < self.n && v < self.n {
  102|     14|                if (u == current && v == neighbor) || (u == neighbor && v == current) {
  104|    105|                    let (u, weight) = neighbor;
  104|     70|                    let (u, weight) = neighbor;
  105|     23|            if u >= self.n || v >= self.n {
  107|  17.1k|                for u in vertices {
  107|     33|        for (u, v) in partition_map.iter() {
  108|      4|            for u in vertices {
  110|     15|            let u = start;
  110|     28|            let u = start;
  110|      2|            let u = *path.nth(i);
  111|     14|                if (u == current && v == neighbor) || (u == neighbor && v == current) {
  111|      2|            if u == v {
  111|      2|            let u = *path.nth(i);
  112|      2|            if u >= distances.length() || v >= distances.length() {
  113|     11|            if u >= self.n || v >= self.n {
  113|      2|            if u >= distances.length() || v >= distances.length() {
  113|      2|            if u == v {
  113|      2|            if u == v {
  114|      2|                let u = seq.nth(i);
  115|      2|            if u == v {
  120|      1|            if u >= self.adj.length() {
  126|     79|        for (u, (v, w, label)) in bridges.iter() {
  128|      2|            for u in u_set.iter() {
  137|      2|            for u in u_set.iter() {
  138|     70|            for (u, weight) in in_neighbors.iter() {
  139|      2|            let u = *path.nth(i);
  140|      2|            let u = *path.nth(i);
  141|      2|            if u >= distances.length() || v >= distances.length() {
  142|      2|            if u >= distances.length() || v >= distances.length() {
  143|     51|                        result.set_predecessor(v, *u);
  145|     23|                for u in vertices {
  147|     73|            for (u, weight) in in_neighbors.iter() {
  152|     51|                        result.set_predecessor(v, *u);
  155|      3|            let u = &tour[i];
  166|     15|        for u in 0..n {
  169|     28|        for u in 0..n {
  174|      6|            let u = &tour[i];
  178|     70|            let u = &vertices[start];
  184|     12|            for (u, v) in partition_map.iter() {
  193|     15|        for u in 0..n {
  196|     28|        for u in 0..n {
  197|     78|        for (u, v, w, label) in edges.iter() {
  198|     32|        for (u, v) in partition_map.iter() {
  243|      0|            for (u, v) in partition_map.iter() {
  252|  15.0k|                for u in vertices {
  284|     71|            let (u, v, w, label) = &edges[start];
  297|  15.0k|                for u in vertices {
   55|     14|                universe_size: u,
   61|      7|            if u >= self.adj.length() {
   62|      4|            let u = *path.nth(i);
   63|     18|            let u = *path.nth(i);
  111|       |        a: u64,
  112|       |        b: u64,
  113|       |        p: u64, // Large prime
  157|       |        p: u64,
   64|     15|        for u in 0..n {
   15|       |        priority: u64,
   15|       |        priority: u64,
  165|      4|        seed: u64,
   16|       |        priority: u64,
  172|      1|        seed: u64,
   17|       |        priority: u64,
   18|       |        priority: u64,
  225|      0|        seed: u64,
  226|      8|        seed: u64,
  327|      9|        seed: u64,
   32|       |            seed: u64,
   44|      1|        seed: u64,
   45|     50|        seed: u64,
   45|       |            seed: u64,
   49|      2|        seed: u64,
   64|      4|            if u >= weights.length() || v >= weights.nth(u).length() {
   64|      2|        seed: u64,
   64|      4|        seed1: u64,
   65|      4|        seed2: u64,
   89|     10|        seed: u64,
   65|     18|            if u >= weights.length() || v >= weights.nth(u).length() {
   66|      8|            if u >= self.adj.length() {
   66|      8|            if u >= self.n || v >= self.n {
   67|     78|            let (u, v, w, label) = edge.clone();
   68|      8|            if u >= self.n || v >= self.n {
   70|      6|            if u >= self.n || v >= self.n {
   71|    301|                for (u, weight) in in_neighbors.iter() {
   72|     15|        for u in 0..n {
   72|     64|            if u >= self.n || v >= self.n {
   74|     48|            if u >= self.n || v >= self.n {
   74|      5|            if u >= self.n || v >= self.n {
   75|      7|            if u >= self.n || v >= self.n {
   76|      5|            if u >= self.n || v >= self.n {
   77|      1|            if u >= self.n {
   80|      5|            if u < self.n && v < self.n {
   81|    228|                for (u, weight) in in_neighbors.iter() {
   82|      5|            if u < self.n && v < self.n {
   83|      1|            if u >= self.n {
   83|     71|            let (u, v, w, label) = edges[start].clone();
   84|     12|            if u >= self.adj.length() || v >= self.adj.length() {
   85|     20|        for u in 0..n {
   85|      2|            let u = *path.nth(i);
   86|     11|            if u >= self.adj.length() || v >= self.adj.length() {
   86|      5|            let u = *path.nth(i);
   87|     20|        for u in 0..n {
   87|      2|            if u >= self.n || v >= self.n {
   87|      2|            if u >= weights.length() || v >= weights.nth(u).length() {
   88|      5|            if u >= weights.length() || v >= weights.nth(u).length() {
   89|      2|            if u >= self.n || v >= self.n {
   89|      2|            if u >= self.n || v >= self.n {
   91|      1|            if u >= self.n {
   91|      2|            if u >= self.n || v >= self.n {
   91|      4|            for u in u_set.iter() {
   92|      1|                    if u == &v_clone || w == &v_clone {
   96|      5|            if u >= self.n || v >= self.n {
   98|      1|            if u >= self.n {
   98|      5|            if u < self.n && v < self.n {
   98|      5|            if u >= self.n || v >= self.n {
   99|      7|            for u in u_set.iter() {
  122|     67|            let u_center = partition_map.get(u).unwrap_or(u);
  126|     67|            if u_center != v_center {
  128|     41|            let u_center = partition_map.get(u).unwrap_or(u);
  132|     41|            if u_center != v_center {
  151|     61|            let u_center = partition_map.get(u).unwrap_or(u);
  155|     61|            if u_center != v_center {
   82|     12|                    let u_center = partition_map.get(u).unwrap_or(u);
   86|     12|                    if (u_center == c1 && v_center == c2) || (u_center == c2 && v_center == c1) {
   90|     47|            let u_center = partition_map.get(u).unwrap_or(u);
   94|     47|            if u_center != v_center {
  130|      6|                    Edge(v_center.clone(), u_center.clone())
  136|      2|                    Edge(v_center.clone(), u_center.clone())
  159|      4|                    Edge(v_center.clone(), u_center.clone())
   99|      5|                    Edge(v_center.clone(), u_center.clone())
  113|     14|                        LabEdge(parent_v, u.clone(), weight)
   58|      6|            vertex_to_block.insert(u.clone(), u.clone());
   59|      6|            vertex_to_block.insert(v.clone(), u.clone());
   68|      3|            let u_clone = u.clone();
   70|      6|                map.insert(u.clone(), u.clone());
   71|      3|            let u_clone = u.clone();
   71|      6|                map.insert(v.clone(), u.clone());
   73|      3|            let u_clone = u.clone();
   80|     40|                    th_edges.push((v_idx, u.clone()));
  149|     73|                if u_dist.0 != f64::INFINITY {
   83|    228|                    if u_dist.0 != f64::INFINITY {
  139|     70|                let u_dist = *distances.get(u).unwrap_or(&i64::MAX);
  140|     70|                if u_dist != i64::MAX {
  148|     73|                let u_dist = *distances.get(u).unwrap_or(&OrderedF64::from(f64::INFINITY));
   72|    301|                    let u_dist = *distances.get(u).unwrap_or(&i64::MAX);
   73|    301|                    if u_dist != i64::MAX {
   82|    228|                    let u_dist = *distances.get(u).unwrap_or(&OrderedF64::from(f64::INFINITY));
   80|     24|            if !uf.equals(u, v) {
  127|     79|            let u_heads = flips.get(u).copied().unwrap_or(false);
  131|     79|            if !u_heads && v_heads {
  180|     70|                let u_heads = coin_flips.get(u).copied().unwrap_or(false);
  183|     70|                if !u_heads && v_heads {
   68|    162|            let u_heads = coin_flips.get(u).copied().unwrap_or(false);
   72|    162|            if !u_heads && v_heads {
  105|    105|                    let u_idx = *u;
  105|     70|                    let u_idx = *u;
    6|       |//! from Ulf Grenander. See Jon Bentley, Programming Pearls (1st edition), page 76.
    6|       |//! for unconditional parallelism.
  127|       |            // Unconditionally parallel divide-and-conquer using ParaPair!
  133|       |                // Unconditionally parallel - no thresholding
  135|       |                    // Unconditionally parallel - no thresholding
  154|       |            // Unconditionally parallel divide-and-conquer using ParaPair!
  168|       |            // Unconditionally parallel divide-and-conquer using ParaPair!
  174|       |                // Unconditionally parallel - no thresholding
  175|       |                    // Unconditionally parallel - no thresholding
  214|       |            // Unconditionally parallel divide-and-conquer using ParaPair!
  219|       |            // Unconditionally parallel using ParaPair!
  250|       |            // Unconditionally use parallel filter
  262|       |            // Unconditionally use parallel from_seq
  316|       |            // Unconditionally parallel using ParaPair!
  341|       |            // Unconditionally parallel using ParaPair!
  349|       |            // Unconditionally parallel split using ParaPair!
    3|       |//! Note: Unconditionally parallel - no thresholding per APAS rules.
    3|       |//! Note: Unconditionally parallel - no thresholding per APAS rules.
   70|       |            // Unconditionally parallel merge sort using ParaPair!
   79|       |        // Unconditionally parallel using recursive divide-and-conquer with ParaPair!
   79|       |        // Unconditionally parallel using recursive divide-and-conquer with ParaPair!
   82|       |                // Unconditionally parallel - no thresholding
   84|       |                    // Unconditionally parallel - no thresholding
   94|       |            // Unconditionally parallel divide-and-conquer using ParaPair!
    7|       |pub mod UnDirGraphMtEph {
  234|       |    macro_rules! UnDirGraphMtEphLit {
  120|     23|        graph: &UnDirGraphMtEph<V>,
  155|      0|                graph: UnDirGraphMtEph<V>,
  164|      4|        graph: &UnDirGraphMtEph<V>,
  171|      1|        graph: &UnDirGraphMtEph<V>,
  181|     38|        graph: &UnDirGraphMtEph<V>,
   21|       |            graph: &UnDirGraphMtEph<V>,
  224|      0|        graph: &UnDirGraphMtEph<V>,
   24|       |            graph: &UnDirGraphMtEph<V>,
   31|       |            graph: &UnDirGraphMtEph<V>,
   43|      1|        graph: &UnDirGraphMtEph<V>,
   44|     50|        graph: &UnDirGraphMtEph<V>,
   57|      3|        graph: &UnDirGraphMtEph<V>,
   85|     22|        graph: &UnDirGraphMtEph<V>,
   88|     10|        graph: &UnDirGraphMtEph<V>,
   97|      4|        graph: &UnDirGraphMtEph<V>,
    4|       |pub mod UnDirGraphStEph {
  149|       |    macro_rules! UnDirGraphStEphLit {
  121|     11|        graph: &UnDirGraphStEph<V>,
   23|       |            graph: &UnDirGraphStEph<V>,
   48|      3|        graph: &UnDirGraphStEph<V>,
   80|     14|        graph: &UnDirGraphStEph<V>,
   97|     24|            let u_neighbors = new_adj.find(&u).unwrap_or_else(|| AVLTreeSetMtPer::empty());
  130|      1|        let union = table1.union(&table2, |v1, v2| format!("{}+{}", v1, v2));
  149|       |        // Union the two sets
  178|       |        // Union the two sets
   27|       |        /// Union two sets containing u and v using union by rank
    5|       |//! - union: Work Θ(n+m), Span Θ(log(n+m)) via PARALLEL divide-and-conquer
    5|       |//! - union: Work Θ(n+m), Span Θ(log(n+m)) via PARALLEL divide-and-conquer
   83|     16|                // Union the components
   99|       |        /// Union two sets containing u and v
  146|      6|        fn union<F: Fn(&V, &V) -> V>(&mut self, other: &Self, combine: F) {
  150|      4|        fn union<F: Fn(&V, &V) -> V>(&self, other: &Self, f: F) -> Self {
  163|      6|        fn union<F: Fn(&V, &V) -> V>(&self, other: &Self, combine: F) -> Self {
  179|      5|        fn union<F: Fn(&V, &V) -> V>(&mut self, other: &Self, f: F) { self.base_table.union(&other.base_table, f); }
  312|      6|        fn union<F: Fn(&V, &V) -> V + Send + Sync>(&mut self, other: &Self, combine: F) {
   38|       |        fn union<F: Fn(&V, &V) -> V>(&mut self, other: &Self, combine: F);
   41|       |        fn union<F: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, combine: F);
   45|       |        fn union<F: Fn(&V, &V) -> V>(&self, other: &Self, f: F) -> Self;
   51|       |        fn union<F: Fn(&V, &V) -> V>(&mut self, other: &Self, f: F);
   52|       |        fn union<F: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, f: F);
   55|       |        fn union<F: Fn(&V, &V) -> V>(&self, other: &Self, combine: F) -> Self;
    4|       |//! Implements Union-Find (Disjoint Set Union) with path compression and union by rank.
    5|       |//! Uses Union-Find data structure for efficient cycle detection.
    7|       |pub mod UnionFindStEph {
  203|      5|        fn union<F>(&mut self, other: &Self, f: F)
  189|      1|        fn union<G: Fn(&V, &V) -> V>(&mut self, other: &Self, f: G) {
  195|      1|        fn union<G: Fn(&V, &V) -> V>(&self, other: &Self, f: G) -> Self {
  197|      1|        fn union<G: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, f: G) {
   45|       |        fn union<G: Fn(&V, &V) -> V>(&self, other: &Self, f: G) -> Self;
   48|       |        fn union<G: Fn(&V, &V) -> V>(&mut self, other: &Self, f: G);
   52|       |        fn union<G: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, f: G);
  122|      9|        fn union_inner(a: &Self, b: &Self) -> Self {
  156|     14|        fn union_inner(a: &Self, b: &Self) -> Self {
  158|    511|        fn union_inner(a: &Self, b: &Self) -> Self {
  111|      3|        fn union(&mut self, other: &Self) {
  116|      2|        fn union(&mut self, other: &Self) {
  192|      0|        fn union(&mut self, u: &V, v: &V) {
   29|       |        fn union(&mut self, u: &V, v: &V);
   39|       |        fn union(&mut self, other: &Self);
   39|       |        fn union(&mut self, other: &Self);
  100|      2|        let union_result = set1.union(&set2);
   50|      2|        let union_result = set1.union(&set2);
  124|  1.83k|        fn union(&self, other: &Self) -> Self {
  125|      9|        fn union(&self, other: &Self) -> Self {
  126|  10.8k|        fn union(&self, other: &Self) -> Self {
  142|      1|        fn union(&self, other: &Self) -> Self {
  190|      1|        fn union(&self, other: &Self) -> Self { ParamBST::union_inner(self, other) }
  193|    197|        fn union(&self, other: &Self) -> Self {
  197|      0|        fn union(&self, other: &Set<T>) -> Set<T>
  200|      6|        fn union(&self, other: &Self) -> Self {
  246|      1|        fn union(&self, other: &Self) -> Self { BSTSetAVLMtEph::union(self, other) }
  246|      1|        fn union(&self, other: &Self) -> Self { BSTSetBBAlphaMtEph::union(self, other) }
  246|      1|        fn union(&self, other: &Self) -> Self { BSTSetRBMtEph::union(self, other) }
  246|      1|        fn union(&self, other: &Self) -> Self { BSTSetSplayMtEph::union(self, other) }
  246|      1|        fn union(&self, other: &Self) -> Self { BSTSetTreapMtEph::union(self, other) }
  252|      1|        fn union(&self, other: &Self) -> Self {
  319|       |        fn union(&self, other: &Self) -> Self;
   32|       |        fn union(&self, other: &Set<T>) -> Set<T>;
   34|       |        fn union(&self, other: &Self) -> Self;
   34|       |        fn union(&self, other: &Self) -> Self;
  354|      3|        fn union(&self, other: &Self) -> Self { ParamBST::union_inner(self, other) }
   36|       |        fn union(&self, other: &Self) -> Self;
   38|       |        fn union(&self, other: &Self) -> Self;
  408|      2|        fn union(&self, other: &Self) -> Self { ParamTreap::union_inner(self, other) }
   41|       |        fn union(&self, other: &Self) -> Self;
   41|       |        fn union(&self, other: &Self) -> Self;
   41|       |        fn union(&self, other: &Self) -> Self;
   41|       |        fn union(&self, other: &Self) -> Self;
   41|       |        fn union(&self, other: &Self) -> Self;
   41|       |        fn union(&self, other: &Self) -> Self;
   41|       |        fn union(&self, other: &Self) -> Self;
   41|       |        fn union(&self, other: &Self) -> Self;
   42|       |        fn union(&self, other: &Self) -> Self;
   54|       |        fn union(&self, other: &Self) -> Self;
   63|       |        fn union(&self, other: &Self) -> Self;
   92|    118|        fn union(&self, other: &Self) -> Self {
   53|     12|        fn unique_pairs_from_iter<I: IntoIterator<Item = Pair<A, B>>>(iter: I) -> Set<Pair<A, B>> {
  149|     27|            let unique_positions: std::collections::HashSet<_> = probe_sequence.iter().cloned().collect();
   23|       |        pub unique_positions: N,
  117|    420|                if unique_positions.contains(&pos) && period == 0 {
  136|     32|                unique_positions: unique_positions.len(),
  165|     27|                unique_positions: unique_positions.len(),
   97|     31|                unique_positions: unique_positions.len(),
  169|     20|            let unique_probe_positions = probe_positions.len();
   26|       |        pub unique_probe_positions: N,
  205|      1|        let unique_word_count = index.word_count();
  215|      1|        (document_count, unique_word_count, total_words)
  106|       |    /// Universal hash function for integers
  146|      2|- With universal hashing, expected inner table size is O(1 + α)
  155|       |    /// Universal hash family for integers
   28|       |    /// Universal hash function family generator
  167|       |    impl UniversalHashFamily<i32> for UniversalIntegerHashFamily {
  160|       |    impl UniversalIntegerHashFamily {
  116|       |    impl UniversalIntegerHashFunction {
    5|       |//! Memory: ⌈universe_size / 64⌉ × 8 bytes. Only filter() uses parallelism.
   79|       |        // (unless both endpoints are in the same block)
   26|       |        fn unlock(&self);
   71|      0|        fn unlock(&self) { SpinLock::unlock(self) }
   36|       |    /// Unmatched vertices form singleton blocks.
   40|       |    /// Unmatched vertices form singleton blocks.
   19|       |    const UNREACHABLE: N = N::MAX;
   19|       |    const UNREACHABLE: N = N::MAX;
   20|       |    const UNREACHABLE: i64 = i64::MAX;
   20|       |    const UNREACHABLE: i64 = i64::MAX;
   20|       |    const UNREACHABLE: N = N::MAX;
   20|       |    const UNREACHABLE: N = N::MAX;
   21|       |    const UNREACHABLE: i64 = i64::MAX;
   21|       |    const UNREACHABLE: i64 = i64::MAX;
   22|       |    const UNREACHABLE: OrderedF64 = OrderedFloat(f64::INFINITY);
   23|       |    const UNREACHABLE: OrderedF64 = OrderedFloat(f64::INFINITY);
   23|       |    const UNREACHABLE: OrderedF64 = OrderedFloat(f64::INFINITY);
   23|       |    const UNREACHABLE: OrderedF64 = OrderedFloat(f64::INFINITY);
   64|      0|                return UNREACHABLE;
   67|      0|                return UNREACHABLE;
   67|      0|                return UNREACHABLE;
   67|      0|                return UNREACHABLE;
   69|      0|                return UNREACHABLE;
   69|      0|                return UNREACHABLE;
   73|      0|                return UNREACHABLE;
   75|      0|                return UNREACHABLE;
   72|       |                &|_| unreachable!("empty sequence has no elements"),
   78|       |                &|_| unreachable!("empty sequence has no elements"),
   79|       |                &|_| unreachable!("empty sequence has no elements"),
   90|       |                &|_| unreachable!("empty sequence has no elements"),
  161|      0|        output.push_str("- Unsorted and sorted list implementations are Θ(n²) and impractical\n");
  184|      1|            write!(f, "UnsortedListPQ[")?;
    4|       |pub mod UnsortedListPQ {
  197|       |    macro_rules! UnsortedListPQLit {
  211|      0|    fn _unsorted_list_pq_lit_type_checks() {
  148|       |        pub unsorted_list_result: Vec<T>,
  225|       |                // Unsuccessful search: approximately 1/(1-α)
  279|       |                // Unsuccessful search: approximately 1/(1-α)
  337|      2|             for unsuccessful search ≈ 1/(1-α), and for successful search ≈ (1/α)ln(1/(1-α)). \
  111|     19|            let unsuccessful_probes = strategy.estimate_unsuccessful_probe_count(load_factor);
  115|     19|                self.assess_performance_impact(successful_probes, unsuccessful_probes, clustering_score);
  153|     16|            let unsuccessful_probes = strategy.estimate_probe_count(load_factor, false);
  157|     16|                self.assess_performance_impact(successful_probes, unsuccessful_probes, clustering_score);
  191|     16|            let unsuccessful_probes = strategy.estimate_probe_count(load_factor, false);
  195|     16|                self.assess_performance_impact(successful_probes, unsuccessful_probes, clustering_score);
  256|      1|        let unsuccessful_probes = strategy.estimate_unsuccessful_probe_count(0.5);
  259|      1|        (metrics, unsuccessful_probes, successful_probes)
  325|      1|        let unsuccessful_probes = strategy.estimate_probe_count(0.5, false);
  347|     51|                expected_unsuccessful_probes: unsuccessful_probes,
  352|      1|        let unsuccessful_probes = strategy.estimate_probe_count(0.5, false);
  104|       |            // Update adjacency list
  115|       |                    // Update predecessor if this is a better path
  115|       |                    // Update predecessor if this is a better path
  121|       |            // Update cached reduction
  121|       |            // Update priorities of neighbors
  127|       |            // Update cached reduction
   15|       |            // Update if key exists, otherwise append
  160|       |        /// Update `self[index]` to `item` in place if in bounds, and return `self` for chaining. <br/>
   16|       |            // Update if key exists, otherwise append
   22|      0|                    // Update existing
   23|      1|                    // Update existing
   47|       |        /// Update matrix dimensions
   48|       |        /// Update matrix dimensions
   50|       |        /// Update probability for key at index
   50|       |        /// Update probability for key at index
   68|       |            // Update buckets
   69|       |            // Update bridge for u
   79|       |            // Update buckets
   81|       |            // Update bridge for v
   82|       |                // Update distance (Line 6)
   89|       |            // Update distances for next round
   91|       |                // Update distance (Line 6)
   98|       |            // Update distances for next round
  136|       |        fn update(a: &mut ArraySeqMtEphS<T>, item_at: (N, T)) -> &mut ArraySeqMtEphS<T>;
  154|       |        fn update(a: &ArraySeqMtPerS<T>, item_at: Pair<N, T>) -> ArraySeqMtPerS<T>;
  223|     84|        fn update(a: &ArraySeqStPerS<T>, index: N, item: T) -> ArraySeqStPerS<T> {
  224|       |        fn update(a: &mut Self, item_at: Pair<N, T>) -> &mut Self;
  230|      1|        fn update(a: &ArraySeqStEphS<T>, index: N, item: T) -> ArraySeqStEphS<T> {
  255|      1|        fn update(a: &ArraySeqS<T>, Pair(index, item): Pair<N, T>) -> ArraySeqS<T> {
  262|     19|        fn update(a: &ArraySeqMtPerS<T>, item_at: Pair<N, T>) -> ArraySeqMtPerS<T> {
  262|      1|        fn update(a: &mut ArraySeqMtEphS<T>, (index, item): (N, T)) -> &mut ArraySeqMtEphS<T> {
  289|      1|        fn update(a: &ArraySeqMtEphS<T>, index: N, item: T) -> ArraySeqMtEphS<T> {
  295|      2|        fn update(a: &LinkedListStPerS<T>, Pair(index, item): Pair<N, T>) -> LinkedListStPerS<T> {
  331|      5|        fn update(a: &mut Self, Pair(index, item): Pair<N, T>) -> &mut Self {
   60|       |        fn update(a: &ArraySeqMtEphS<T>, index: N, item: T) -> ArraySeqMtEphS<T>;
   60|       |        fn update(a: &LinkedListStPerS<T>, item_at: Pair<N, T>) -> LinkedListStPerS<T>;
   62|       |        fn update(a: &ArraySeqStEphS<T>, index: N, item: T) -> ArraySeqStEphS<T>;
   66|       |        fn update(a: &ArraySeqStPerS<T>, index: N, item: T) -> ArraySeqStPerS<T>;
   72|       |        fn update(a: &ArraySeqS<T>, update: Pair<N, T>) -> ArraySeqS<T>;
  256|    973|                let updated = self.delete(&key);
  155|      1|        fn update_dimension(&mut self, index: usize, rows: usize, cols: usize) {
  202|      1|        fn update_dimension(&mut self, index: usize, rows: usize, cols: usize) {
   48|       |        fn update_dimension(&mut self, index: usize, rows: usize, cols: usize);
   49|       |        fn update_dimension(&mut self, index: usize, rows: usize, cols: usize);
  207|     24|                if updated.insert(*index) {
  101|      5|            let updated_row = ArraySeqStPerS::update(self.predecessors.nth(u), v, pred);
   77|      5|            let updated_row = ArraySeqStPerS::update(self.distances.nth(u), v, dist);
   79|      5|            let updated_row = ArraySeqStPerS::update(self.distances.nth(u), v, dist);
   99|      5|            let updated_row = ArraySeqStPerS::update(self.predecessors.nth(u), v, pred);
  224|   150M|    fn update_meta<T: StT>(n: &mut Box<AVLTreeNode<T>>) {
  330|     38|    fn update_meta<T: Copy + Debug>(n: &mut Box<AVLTreeNode<T>>) {
  135|     22|        fn update(&mut self, index: N, item: T) -> Result<&mut Self, &'static str> {
  150|       |        fn update(&mut self, update: Pair<N, T>) -> &mut ArraySeqStEphS<T>;
  244|      1|        fn update(&mut self, update: Pair<N, T>) -> &mut ArraySeqStEphS<T> { ArraySeqStEphS::update(self, update) }
   33|  6.96k|        fn update(&mut self) {
   48|       |        fn update(&mut self, index: N, item: T) -> Result<&mut Self, &'static str>;
  114|  3.48k|        fn update(node: &mut Node<T>) { node.size = 1 + Self::size_link(&node.left) + Self::size_link(&node.right); }
   72|  8.21k|        fn update(node: &mut Node<T>) { node.size = 1 + Self::size_link(&node.left) + Self::size_link(&node.right); }
   72|  8.77k|        fn update(node: &mut Node<T>) { node.size = 1 + Self::size_link(&node.left) + Self::size_link(&node.right); }
   73|  1.71k|        fn update(node: &mut Node<T>) { node.size = 1 + Self::size_link(&node.left) + Self::size_link(&node.right); }
   74|  11.0k|        fn update(node: &mut Node<T>) { node.size = 1 + Self::size_link(&node.left) + Self::size_link(&node.right); }
   74|  4.58k|        fn update(node: &mut Node<T>) { node.size = 1 + Self::size_link(&node.left) + Self::size_link(&node.right); }
   76|  1.86k|        fn update(node: &mut Node<T>) {
   76|   186k|        fn update(node: &mut Node<T>) { node.size = 1 + Self::size_link(&node.left) + Self::size_link(&node.right); }
   76|  25.0k|        fn update(node: &mut Node<T>) {
   82|    973|        fn update(node: &mut Node<T>) { node.size = 1 + Self::size_link(&node.left) + Self::size_link(&node.right); }
  122|  1.10k|        fn update_node(node: &mut Node<K, V, R>) {
  151|      3|        fn update_prob(&mut self, index: usize, prob: Probability) {
  208|      1|        fn update_prob(&mut self, index: usize, prob: Probability) {
   51|       |        fn update_prob(&mut self, index: usize, prob: Probability);
   51|       |        fn update_prob(&mut self, index: usize, prob: Probability);
  247|      9|            ArraySeqStEphS::inject(self, updates)
  181|      1|        fn update_single(a: &ArraySeqMtPerS<T>, index: N, item: T) -> ArraySeqMtPerS<T> {
   42|       |        fn update_single(a: &ArraySeqMtPerS<T>, index: N, item: T) -> ArraySeqMtPerS<T>;
   76|  7.59k|        fn update_size(node: &mut Node<T>) {
   89|     50|        let updates_seq = ArraySeqStEphS::from_vec(
  165|      2|3. Memory usage optimization is important
  114|       |                // Use parallel reduction to find minimum
  115|       |                // Use parallel reduction to find minimum
  124|       |                // Use parallel reduction to find minimum
  127|       |                // Use parallel reduction to find minimum
  171|       |            // Use seed to generate pseudo-random a and b
   18|       |    pub use std::cmp::Ordering as O;
  206|       |            // Use proper sequence filter operations
  211|       |            // Use proper sequence filter operations
  228|       |            // Use proper sequence filter operation
  236|       |            // Use proper sequence filter operation
   23|       |            // Use key bytes directly instead of memory address
  240|       |    pub use ordered_float::OrderedFloat;
  272|       |            // Use subseq_copy for known index ranges
  284|      1|   - Use lower thresholds than separate chaining
   47|       |            // Use parallel reduce from ArraySeqMtPer (already uses ParaPair!)
   52|       |            // Use parallel reduce from ArraySeqMtPer (already uses ParaPair!)
   57|      6|            // Use the first vertex as the representative
   57|       |            // Use parallel reduce from ArraySeqMtPer (already uses ParaPair!)
   61|       |            // Use bit-level comparison for exact equality
   62|       |            // Use parallel reduce from ArraySeqMtPer (already uses ParaPair!)
   67|       |            // Use parallel reduce from ArraySeqMtPer (already uses ParaPair!)
  181|       |    /// Used in flat hash tables for open addressing
  239|       |            // Used in Algorithm 62.3 (Star Partition)
  340|      2|            if use_prime {
  101|       |        /// Uses union by rank: attaches smaller tree under larger tree.
  114|       |        /// Uses c1=1, c2=1 which work well with prime table sizes
   13|       |    /// Uses two hash functions to avoid both primary and secondary clustering.
   18|       |    /// Uses the sieve of Eratosthenes approach with functional programming constructs.
   19|       |    /// Uses separate chaining (linked lists or sequences) for collision resolution.
   40|       |    /// Uses Union-Find to detect cycles efficiently.
   42|       |    /// Uses recursive star contraction to count the number of connected components.
   45|       |    /// Uses open addressing (linear probing, quadratic probing, double hashing).
   45|       |    /// Uses recursive parallel star contraction to count connected components.
    4|       |//! Note: Uses unconditional parallelism with ParaPair! for divide-and-conquer operations (map, reduce).
    4|       |//! Note: Uses unconditional parallelism with ParaPair! for divide-and-conquer operations (map, reduce).
   59|       |    /// Uses parallel reduce over edges.
   75|       |        /// Uses path compression: makes all nodes on path point directly to root.
   13|       |    /// Using Rust's built-in bool with normal true/false literals
  108|     43|        start: usize,
  109|    112|        start: usize,
  109|     43|        end: usize,
  110|    112|        end: usize,
  120|      5|        n: usize,
  123|     19|        source: usize,
  129|     21|            i: usize,
  129|     21|            i: usize,
  130|     21|            j: usize,
  130|     21|            j: usize,
  132|     19|        source: usize,
  135|      5|        n: usize,
  136|     72|        start: usize,
  137|     72|        end: usize,
  138|     99|        start: usize,
  139|     99|        end: usize,
  155|     10|        n: usize,
  168|    120|        start: usize,
  169|    120|        end: usize,
  185|      5|        n: usize,
  188|     10|        n: usize,
  223|       |        index: usize,
  275|    122|        start: usize,
  276|    122|        end: usize,
   33|       |        vertex: usize,
   33|       |        vertex: usize,
   52|     20|        source: usize,
   73|    122|        start: usize,
   74|    122|        end: usize,
   94|     25|        start: usize,
   94|     46|        start: usize,
   95|     25|        end: usize,
   95|     46|        end: usize,
   96|     25|        n: usize,
   96|     46|        n: usize,
   97|      5|        n: usize,
  300|       |    /// Utility functions for hash table implementation
    5|       |//! Provides utility functions for computing path weights and validating
    5|       |//! Provides utility functions for computing path weights and validating
  101|      2|                cached_reduction: v,
  102|      4|        table_mt.filter(|k, _v| *k <= 2);
  103|     14|                let v = selected_seq.nth(i);
  103|    190|        for (v, (neighbor, w, label)) in right_bridges {
  103|      4|            for v in 0..self.n {
  105|     71|                for v in 0..n {
  106|      7|            self.edges.insert(Pair(u, v));
  106|      8|                let v = sources_seq.nth(i);
  107|      2|                cached_reduction: v,
  109|     73|            for v in self.iter() {
  110|     73|                if v == target {
  111|      2|            let v = *path.nth(i + 1);
  112|      2|            let v = *path.nth(i + 1);
  112|       |        ( V: [ $( $v:expr ),* $(,)? ], E: [ $( ($v1:expr, $v2:expr, $weight:expr) ),* $(,)? ] ) => {{
  113|    147|                (self.reducer)(&self.cached_reduction, &v)
  114|       |        ( V: [ $( $v:expr ),* $(,)? ], E: [ $( ($from:expr, $to:expr, $weight:expr) ),* $(,)? ] ) => {{
  115|     28|                    let v = selected_seq.nth(i);
  117|  2.90k|            self.base_table.insert(k, v, combine);
  118|     64|                        result.set_predecessor(u_idx, v);
  118|     80|                        result.set_predecessor(u_idx, v);
  119|     47|                        let v = visited_seq.nth(i);
  119|     79|        for v in vertices.iter() {
  123|     52|            for v in neighbors.iter() {
  125|      3|            for v in it {
  126|     71|        for v in 0..n {
  127|     71|            if v == source {
  129|      0|                v: V,
  129|     47|                        let v = visited_seq.nth(i);
  130|     14|                let v = sources_seq.nth(i);
  130|       |        ( V: [ $( $v:expr ),* $(,)? ], E: [ $( ($v1:expr, $v2:expr, $weight:expr) ),* $(,)? ] ) => {{
  134|     23|                        let v = visited_seq.nth(i);
  135|     71|        for v in 0..n {
  136|     71|            if v == source {
  138|     79|        for v in vertices.iter() {
  139|      0|                v: V,
  140|     23|                let v = visited_seq.nth(i);
  140|      2|            let v = *path.nth(i + 1);
  141|     14|                let v = sources_seq.nth(i);
  141|      2|            let v = *path.nth(i + 1);
  142|      0|                v: V,
  142|       |        ( V: [ $( $v:expr ),* $(,)? ], E: [ $( ($v1:expr, $v2:expr, $weight:expr) ),* $(,)? ] ) => {{
  145|      6|            for v in self.iter() {
  146|      6|                if v == target {
  146|      8|                let v = sources_seq.nth(i);
  147|       |        ( V: [ $( $v:expr ),* $(,)? ], A: [ $( ($from:expr, $to:expr, $label:expr) ),* $(,)? ] ) => {{
  150|      1|        tour: &[V],
  151|      1|            identity: V,
  151|       |            let __V: $crate::Chap05::SetStEph::SetStEph::Set<_> = $crate::SetLit![];
  152|     43|        u: &V,
  153|     43|        v: &V,
  154|     70|        for v in vertices_arc.iter() {
  155|       |        ( V: [ $( $v:expr ),* $(,)? ], E: [ $( ( $u:expr , $w:expr ) ),* $(,)? ] ) => {{
  156|      3|            let v = &tour[i + 1];
  156|       |            let __V: $crate::Chap05::SetStEph::SetStEph::Set<_> = $crate::SetLit![ $( $v ),* ];
  157|    255|            for v in keys.iter() {
   15|       |        Live(K, V),
   15|       |        value: V,
  165|       |        ( V: [ $( $v:expr ),* $(,)? ], E: [ $( ($v1:expr, $v2:expr, $weight:expr) ),* $(,)? ] ) => {{
  168|     15|                let (v, w) = v_w;
  168|      3|            for v in vertices {
  169|     15|                edges.insert((u, *v, *w));
  169|      2|        tour: &[V],
  171|     24|                let (v, w) = v_w;
  171|      3|            for v in vertices.iter() {
  172|     24|                edges.insert((u, *v, *w));
  172|       |            let __V: $crate::Chap05::SetStEph::SetStEph::Set<_> = $crate::SetLit![];
  174|     15|        for v in 0..n {
  174|       |        ( V: [ $( $v:expr ),* $(,)? ], E: [ $( ($from:expr, $to:expr, $weight:expr) ),* $(,)? ] ) => {{
  175|     15|            edges.insert((n, v, 0));
  175|      6|            let v = &tour[i + 1];
  176|       |        ( V: [ $( $v:expr ),* $(,)? ], A: [ $( ( $u:expr , $w:expr ) ),* $(,)? ] ) => {{
  177|     28|        for v in 0..n {
  177|       |            let __V: $crate::Chap05::SetStEph::SetStEph::Set<_> = $crate::SetLit![ $( $v ),* ];
  178|     28|            edges.insert((n, v, OrderedF64::from(0.0)));
  179|       |        ( V: [ $( $v:expr ),* $(,)? ], E: [ $( ($v1:expr, $v2:expr, $label:expr) ),* $(,)? ] ) => {{
   17|       |        value: V,
  181|      0|                v: V,
  183|      3|        u: &V,
  184|      3|        v: &V,
  184|       |        ( V: [ $( $v:expr ),* $(,)? ], A: [ $( ($from:expr, $to:expr, $weight:expr) ),* $(,)? ] ) => {{
  189|       |        ( V: [ $( $v:expr ),* $(,)? ], A: [ $( ($from:expr, $to:expr, $weight:expr) ),* $(,)? ] ) => {{
   90|      0|                LabEdge(v2, v1, label)
  191|     58|        for v in remaining_vertices.iter() {
  196|     15|                let (v, w) = v_w;
   96|      1|                LabEdge(v2, v1, label)
  199|     15|                reweighted_edges.insert((u, *v, w_prime as i32));
  199|     24|                let (v, w) = v_w;
  202|     24|                reweighted_edges.insert((u, *v, w_prime));
  203|      6|        u: &V,
  204|      6|        v: &V,
  210|      1|        start: &V,
  218|      0|            for v in keys.iter() {
   21|       |        identity: V,
   21|       |        identity: V,
   23|     59|                .map(|(v1, v2, weight)| LabEdge(v1.clone(), v2.clone(), *weight))
   27|     13|                .map(|(v1, v2, weight)| LabEdge(v1.clone(), v2.clone(), *weight))
   27|     13|                .map(|(v1, v2, weight)| LabEdge(v1.clone(), v2.clone(), *weight))
  229|       |        ( V: [ $( $v:expr ),* $(,)? ], E: [ $( ($v1:expr, $v2:expr, $label:expr) ),* $(,)? ] ) => {{
   22|       |        cached_reduction: V,
   22|       |        cached_reduction: V,
  230|      0|            for v in vertices.iter() {
  235|      1|            let v = self.values_in_order();
  236|      1|fn probe_operation<K, V, F, R>(
  236|      1|        start: &V,
  236|       |            let __V: $crate::Chap05::SetStEph::SetStEph::Set<_> = $crate::SetLit![];
  237|       |        ( V: [ $( $v:expr ),* $(,)? ], A: [ $( ($from:expr, $to:expr, $label:expr) ),* $(,)? ] ) => {{
   23|       |            start: V,
  240|       |        ( V: [ $( $v:expr ),* $(,)? ], E: [ $( ( $u:expr , $w:expr ) ),* $(,)? ] ) => {{
  241|       |            let __V: $crate::Chap05::SetStEph::SetStEph::Set<_> = $crate::SetLit![ $( $v ),* ];
   42|      1|            self.add_labeled_edge(v1, v2, weight);
  242|      5|            let v = self.values_in_order();
   24|       |        identity: V,
   51|     59|                .map(|(v1, v2, weight)| LabEdge(v1.clone(), v2.clone(), *weight))
  252|     17|            self.filter(move |v| v != &x_clone)
  258|     42|        for v in remaining_vertices.iter() {
   25|       |        cached_reduction: V,
   25|       |            start: V,
   66|     61|            self.add_labeled_edge(v1, v2, weight);
   26|       |    impl<K, V, H, E> SeparateChainingHashTable<K, V, H, E>
   26|       |            start: V,
  272|      0|            for v in self.iter() {
   28|      0|                FlatEntry::Occupied(k, v) if k == key => Some(v.clone()),
   88|    131|                LabEdge(v1, v2, label)
  291|       |        SeparateChainingHashTable<String, V, StringPositionHashFunction, DefaultKeyEquality>;
   94|      4|                LabEdge(v1, v2, label)
   49|      4|            self.get_edge_label(v1, v2).copied()
   73|     16|            self.get_edge_label(v1, v2).copied()
   33|       |            tour: &[V],
   35|       |            tour: &[V],
  363|       |            let __V: $crate::Chap05::SetStEph::SetStEph::Set<_> = $crate::SetLit![];
  367|       |        ( V: [ $( $v:expr ),* $(,)? ], A: [ $( ( $u:expr , $w:expr ) ),* $(,)? ] ) => {{
  368|       |            let __V: $crate::Chap05::SetStEph::SetStEph::Set<_> = $crate::SetLit![ $( $v ),* ];
   38|       |        vertex: V,
   41|     18|                    let v = *neighbors.nth(i);
   41|     18|                    let v = *neighbors.nth(i);
   43|      3|                    FlatEntry::Occupied(k, v) if k == key => return Some(v.clone()),
   44|     34|                    FlatEntry::Occupied(k, v) if k == key => return Some(v.clone()),
   46|     18|                        let v = neighbors.nth_cloned(i);
   46|     18|                        let v = *neighbors.nth(i);
   47|       |            identity: V,
   54|     19|                let v = domain_seq.nth(i);
   55|     75|        for v in 0..n {
   58|     74|        for v in 0..n {
   59|      2|        start: &V,
   61|     74|                if v == source {
   62|     13|                    let v = seq.nth(i);
   62|     14|                let v = seq.nth(i);
   63|      4|            let v = *path.nth(i + 1);
   63|      8|            if v >= self.distances.length() {
   64|     18|            let v = *path.nth(i + 1);
   64|      2|        start: &V,
   65|    224|            for v in 0..n {
   66|    269|            if v >= self.distances.length() {
   66|      8|            if v >= self.distances.length() {
   68|    279|            if v >= self.distances.length() {
   71|      5|            if v >= self.distances.length() {
   73|      6|        current: &V,
   74|    175|            if v < self.distances.length() {
   74|      5|            if v >= self.distances.length() {
   75|    183|            for v in 0..n {
   76|    173|            if v < self.distances.length() {
   78|      0|            if v < self.adj.length() {
   78|      6|        current: &V,
   81|      2|            if v >= self.predecessors.length() {
   82|     14|                    FlatEntry::Occupied(k, v) if k == key => return Some(v.clone()),
   82|      4|            for v in 0..self.n {
   82|      8|        start: &V,
   83|      2|            if v >= self.predecessors.length() {
   83|      2|            if v >= self.predecessors.length() {
   84|      0|                v: V,
   84|     16|                uf.union(u, v);
   86|      0|                v: V,
   86|      2|            if v >= self.predecessors.length() {
   86|      2|            let v = *path.nth(i + 1);
   87|      5|            let v = *path.nth(i + 1);
   88|     18|                let v = *neighbors.nth(i);
   88|      4|            for v in 0..self.n {
   89|       |                // v is the root
   90|    111|                let v = entry.vertex;
   90|    117|                let v = entry.vertex;
   90|    136|            if v < self.predecessors.length() {
   90|     18|                let v = *neighbors.nth(i);
   92|    120|            if v < self.predecessors.length() {
   92|      5|            if v >= self.predecessors.length() {
   95|      5|            if v >= self.predecessors.length() {
   96|     14|                let v = selected_seq.nth(i);
   96|     38|            for v in it {
   96|      4|            for v in 0..self.n {
   96|     71|                for v in 0..n {
   98|      2|                cached_reduction: v,
   99|      4|        table_eph.filter(|k, _v| *k <= 2);
   99|       |    impl<T, V> MtReduceFn<V> for T where T: Fn(&V, &V) -> V + Clone + Send + Sync + 'static {}
  205|     16|                        result_entries.push(Pair(key1.clone(), val1.clone()));
  215|  2.00k|                let val = f(&a.nth_cloned(0));
  231|      3|                let val = self.values[self.index].clone();
   37|     26|            let val = *a.nth(0);
   37|     26|            let val = a.nth_cloned(0);
   45|       |        pub val: V,
  219|      9|                result_entries.push(Pair(key.clone(), val.clone()));
  152|       |            // Validate relative primality
  196|       |        /// Validate configuration for optimal double hashing
  241|       |        /// Validate table size and coefficients for optimal quadratic probing
  327|       |        // Validate configuration
  354|       |        // Validate configuration
   53|       |        /// Validate that h2(k) and table_size are relatively prime
   72|       |        /// Validate quadratic probing parameters for given table size
  126|       |    /// Validates the sub-paths property for floating-point weights.
  127|       |    /// Validates the sub-paths property for floating-point weights.
   34|       |        /// Validates the sub-paths property for integer weights.
   35|       |        /// Validates the sub-paths property for integer weights.
   42|       |        /// Validates the sub-paths property for floating-point weights.
   43|       |        /// Validates the sub-paths property for floating-point weights.
   96|       |    /// Validates the sub-paths property: every sub-path of a shortest path is itself a shortest path.
   97|       |    /// Validates the sub-paths property: every sub-path of a shortest path is itself a shortest path.
   12|       |//! - `validate_subpath_property`: Work O(k²), Span O(k²) for k-vertex path
   12|       |//! - `validate_subpath_property`: Work O(k²), Span O(k²) for k-vertex path
   43|       |        fn validate_subpath_property_float(
   44|       |        fn validate_subpath_property_float(
   35|       |        fn validate_subpath_property_int(
   36|       |        fn validate_subpath_property_int(
  328|      1|        let validation = strategy.validate_configuration(&test_key, table_size);
  355|      1|        let validation = strategy.validate_configuration(17);
  351|      1|        let valid_h2_values = RelativePrimeValidator::generate_valid_h2_values(table_size, 5);
   96|     12|            while valid_values.len() < max_count as usize && candidate < table_size {
  288|       |        let __vals = vec![$x; $n];
  293|       |        let __vals = vec![$($x),*];
   74|  5.25k|                    return vals;
   83|      3|            let vals = {
  100|       |        ChainedHashTable<Key, Value, ChainList<Key, Value>, Metrics> 
  105|  1.18k|                if value < node.key {
  106|  2.97k|                if value < node.key {
  109|    446|            for value in elts.into_iter().rev() {
  110|     14|                    let value = f(key);
  111|     14|                    Pair(key.clone(), value)
  111|    613|            descend(&self.root, value);
  113|       |        FlatHashTable<Key, Value, FlatEntry<Key, Value>, Metrics> 
  118|  5.48k|                if value < node.key {
  126|      0|                let value = f(key);
   12|       |        pub value: T,
   12|       |        pub value: T,
  137|  11.2k|                    if value < node.key {
  137|    811|                    if value < node.key {
  140|     15|                        let value = f_clone(key);
  141|     15|                        Pair(key.clone(), value)
  143|     16|            for value in self.tree.in_order().iter() {
  143|     16|            for value in self.tree.in_order().iter() {
  143|     19|            for value in self.tree.in_order().iter() {
  143|     28|            for value in self.tree.in_order().iter() {
  143|     31|            for value in self.tree.in_order().iter() {
  143|     51|            for value in self.tree.in_order().iter() {
  144|     16|                if value < pivot {
  144|     16|                if value < pivot {
  144|     19|                if value < pivot {
  144|     28|                if value < pivot {
  144|     31|                if value < pivot {
  144|     51|                if value < pivot {
  150|     19|                    let value = f(key);
  151|     19|                    Pair(key.clone(), value)
  158|    620|                if value < node.key {
   15|       |        ParaHashTableStEphTrait<Key, Value, FlatEntry<Key, Value>, Metrics> 
   15|       |        pub value: T,
   15|       |        pub value: Value,
  160|    112|                let value = a.nth(i).clone();
  161|     10|            for value in right.values_vec() {
  161|      4|            for value in right.values_vec() {
  161|      5|            for value in right.values_vec() {
  161|      5|            for value in right.values_vec() {
  161|      5|            for value in right.values_vec() {
  161|      5|            for value in right.values_vec() {
   16|       |        ParaHashTableStEphTrait<Key, Value, FlatEntry<Key, Value>, Metrics> 
  170|     13|            for value in right.values_vec() {
  170|     23|            for value in right.values_vec() {
  170|      6|            for value in right.values_vec() {
  170|      6|            for value in right.values_vec() {
  170|      6|            for value in right.values_vec() {
  170|      7|            for value in right.values_vec() {
  175|   116k|                if value < node.key {
   17|       |        Occupied(Key, Value),
  180|     11|                let value = a.nth_cloned(i);
   18|       |        pub(crate) value: T,
  193|      8|                let value = a.nth_cloned(i);
  207|  22.7k|            for value in values {
  207|     36|            for value in values {
  207|     36|            for value in values {
  207|     36|            for value in values {
  207|     36|            for value in values {
  207|     43|            for value in values {
   20|       |        pub value: T,
  217|     12|                let value = a.nth_cloned(i);
  218|    100|            for value in values {
  218|    132|            for value in values {
  218|    147|            for value in values {
  218|    176|            for value in values {
  218|    181|            for value in values {
  218|    329|            for value in values {
  225|    311|                let value = a.nth(i);
   22|      7|            self.push((key, value));
   22|       |        ParaHashTableStEphTrait<Key, Value, Entry, Metrics>
  236|      7|                let value = a.nth(i);
   23|      7|            self.push_back((key, value));
  254|     10|                let value = a.nth_cloned(i);
  254|      1|            for value in other.values_vec() {
   25|       |    impl<Key, Value> ChainList<Key, Value> {
  268|  1.98k|                new_entries.push(Pair(key, value));
  287|     10|                let value = a.nth(i);
  298|      3|            for value in self.tree.in_order().iter() {
  299|      3|                if value < pivot {
  303|     13|                let value = a.nth(i);
  316|      1|            for value in right.values_vec() {
  325|      1|            for value in right.values_vec() {
   33|      9|                table.table[index].insert(key, value);
   48|       |        ParaHashTableStEphTrait<Key, Value, Entry, Metrics>
   48|       |        ParaHashTableStEphTrait<Key, Value, Vec<(Key, Value)>, Metrics> 
   54|    242|            BalBinTree::Node(Box::new(BalBinNode::new(left, value, right)))
   57|       |        ParaHashTableStEphTrait<Key, Value, FlatEntry<Key, Value>, Metrics> 
   58|       |        ParaHashTableStEphTrait<Key, Value, LinkedList<(Key, Value)>, Metrics> 
   63|      0|                table.table[slot].insert(key, value);
   64|    106|                    last_values.insert(index, value);
   65|       |        ChainedHashTable<Key, Value, Vec<(Key, Value)>, Metrics> 
   75|       |        ChainedHashTable<Key, Value, LinkedList<(Key, Value)>, Metrics> 
   76|       |        FlatHashTable<Key, Value, FlatEntry<Key, Value>, Metrics> 
   77|       |        FlatHashTable<Key, Value, FlatEntry<Key, Value>, Metrics> 
   80|  5.08k|                if value < inner.value {
   83|       |        ParaHashTableStEphTrait<Key, Value, ChainList<Key, Value>, Metrics> 
   84|  6.97k|                        if value == node.key {
   91|     14|                let value = f(key);
   92|     14|                entries.push(Pair(key.clone(), value));
   99|     15|            for value in other.values_vec() {
   99|      5|            for value in other.values_vec() {
   99|      5|            for value in other.values_vec() {
   99|      5|            for value in other.values_vec() {
   99|      5|            for value in other.values_vec() {
   99|     90|            for value in other.values_vec() {
  119|    272|                    Entry::Live(key.clone(), value.clone())
  293|    157|                    Entry::Live(key.clone(), value.clone())
  350|      2|                    result.update(index, value.clone()).unwrap();
  361|      3|                    result.update(index, value.clone()).unwrap();
  208|    160|            let value_ref: &T = &node.value;
  276|      5|            let value_ref: &T = &node.value;
  313|      9|            let value_ref: &T = &node.value;
  125|      5|            let values1 = self.elements.values_in_order();
  134|     16|                if values1[i] <= values2[j] {
  126|      5|            let values2 = other.elements.values_in_order();
  259|      2|            let values = self.elements.values_in_order();
   51|    885|            let values: Vec<T> = self.data[s..e].iter().cloned().collect();
   65|  1.42k|            let values: Vec<T> = self.data.iter().cloned().collect();
   75|  8.14k|            let values: Vec<T> = guard[s..e].iter().cloned().collect();
   23|       |        fn value(&self) -> f64;
  163|       |        fn values_in_order(&self) -> Vec<T>;
  164|       |        fn values_in_order(&self) -> Vec<T>;
  201|    676|        fn values_in_order(&self) -> Vec<T> {
  203|    563|        fn values_in_order(&self) -> Vec<T> {
   39|  4.08k|                data: values.into_boxed_slice(),
  122|  1.39k|            if values.is_empty() {
  164|    537|            if values.is_empty() {
  101|       |        fn values(&self) -> ArraySeqStPerS<V>;
  215|      1|        fn values(&self) -> ArraySeqStPerS<V> {
  318|      4|        fn values(&self) -> ArraySeqStPerS<V> {
   61|       |        fn values(&self) -> ArraySeqStPerS<V>;
  203|    309|        fn values_vec(&self) -> Vec<T> { self.tree.in_order().iter().cloned().collect() }
  203|     37|        fn values_vec(&self) -> Vec<T> { self.tree.in_order().iter().cloned().collect() }
  203|     39|        fn values_vec(&self) -> Vec<T> { self.tree.in_order().iter().cloned().collect() }
  203|     40|        fn values_vec(&self) -> Vec<T> { self.tree.in_order().iter().cloned().collect() }
  203|     50|        fn values_vec(&self) -> Vec<T> { self.tree.in_order().iter().cloned().collect() }
  203|     54|        fn values_vec(&self) -> Vec<T> { self.tree.in_order().iter().cloned().collect() }
  154|      4|            let variance = if total_clusters > 1 {
  167|      4|                probe_variance: variance,
  277|     19|                let variance_penalty = m.probe_variance.sqrt() * 10.0;
  123|     67|            let v_center = partition_map.get(v).unwrap_or(v);
  129|     41|            let v_center = partition_map.get(v).unwrap_or(v);
  152|     61|            let v_center = partition_map.get(v).unwrap_or(v);
   83|     12|                    let v_center = partition_map.get(v).unwrap_or(v);
   91|     47|            let v_center = partition_map.get(v).unwrap_or(v);
  128|     34|                    Edge(u_center.clone(), v_center.clone())
  134|      8|                    Edge(u_center.clone(), v_center.clone())
  157|     32|                    Edge(u_center.clone(), v_center.clone())
   97|      8|                    Edge(u_center.clone(), v_center.clone())
  100|      1|            let v_clone = v.clone();
  107|      1|            let v_clone = v.clone();
  119|    203|            self.base_table.insert(k, v.clone(), combine);
  125|  2.51k|            self.base_table.insert(k, v.clone(), combine);
   99|      1|            let v_clone2 = v_clone.clone();
   74|     41|                    th_edges.push((u_idx, v.clone()));
   81|      1|            let v_clone = v.clone();
   84|      1|            let v_clone = v.clone();
   95|      1|            let v_clone = v.clone();
   97|      1|            let v_clone = v.clone();
  108|      0|            parallel_out(arcs, v.clone_mt())
  113|      0|            parallel_neighbors(edges, v.clone_mt())
  115|      0|            parallel_out(arcs, v.clone_mt())
  120|      0|            parallel_neighbors(edges, v.clone_mt())
  135|      6|            parallel_ng(edges, v.clone_mt())
  160|      0|            parallel_in(arcs, v.clone_mt())
  160|      0|            parallel_out(arcs, v.clone_mt())
  170|      0|            parallel_in(arcs, v.clone_mt())
  176|      0|            parallel_neighbors(edges, v.clone_mt())
  192|      0|            parallel_nplus(arcs, v.clone_mt())
  212|      0|            parallel_in(arcs, v.clone_mt())
  242|      0|            parallel_nminus(arcs, v.clone_mt())
  141|     52|            if v_dist.0 == f64::INFINITY {
  131|     52|            let v_dist = *distances.get(&v).unwrap_or(&i64::MAX);
  132|     52|            if v_dist == i64::MAX {
  140|     52|            let v_dist = *distances.get(&v).unwrap_or(&OrderedF64::from(f64::INFINITY));
    3|       |//! Uses Vec for separate chaining collision resolution.
  345|      1|            ("AllSame".to_string(), vec![42; size]),
   44|       |    /// Vec Chained Hash Table implementation.
  182|       |        stack: Vec<&'a AVLTreeNode<T>>,
  255|       |        stack: Vec<&'a Node<T>>,
  286|       |        stack: Vec<&'a AVLTreeNode<T>>,
    5|       |pub mod VecChainedHashTable {
   49|       |        for VecChainedHashTableStEph
   66|       |        for VecChainedHashTableStEph
   49|     29|                table: Vec::<Entry>::with_capacity(initial_size),
  134|      4|                data: vec![init_value; length],
  160|      0|                data: vec![init_value; length],
   22|       |        keys: Vec<KeyProb<T>>,
   22|       |        keys: Vec<KeyProb<T>>,
  128|      0|                arcs: Vec<LabEdge<V, L>>,
  138|      0|                arcs: Vec<LabEdge<V, OrderedF64>>,
  141|      0|                edges: Vec<LabEdge<V, L>>,
  180|      0|                arcs: Vec<LabEdge<V, L>>,
   83|      0|                arcs: Vec<LabEdge<V, OrderedF64>>,
   85|      0|                edges: Vec<LabEdge<V, OrderedF64>>,
  230|     29|        edges_vec: Vec<LabeledEdge<V>>,
   20|       |        dimensions: Vec<MatrixDim>,
   20|       |        dimensions: Vec<MatrixDim>,
  101|      0|                    return Vec::new();
  102|      4|                keys: Vec::new(),
  104|      2|                dimensions: Vec::new(),
  158|      0|                    return Vec::new();
  189|     31|                stack: Vec::new(),
  248|      1|                stack: Vec::new(),
  280|      0|            return Vec::new();
  291|     37|            return Vec::new();
  293|      4|                stack: Vec::new(),
   90|      3|                keys: Vec::new(),
   92|      3|                dimensions: Vec::new(),
   23|     25|                data: Vec::new().into_boxed_slice(),
  289|     34|                return vec![(new_u, new_v, *w, *label)];
   14|       |        elements: Vec<T>,
   19|       |        data: Vec<T>,
  222|       |        values: Vec<T>,
   41|       |        elements: Vec<T>,
   59|       |        data: Vec<T>,
   96|    437|                vals: Vec<T>,
  378|      2|            keys: vec![test_key.to_string()],
  418|      2|            keys: vec![test_key.to_string()],
  432|      2|            keys: vec![test_key.to_string()],
  314|       |        fn vec_to_array_seq<T: StT>(vec: &[T]) -> ArraySeqStPerS<T>;
  316|       |        fn vec_to_avl_seq<T: StT>(vec: &[T]) -> AVLTreeSeqStPerS<T>;
  116|      0|                vertices: Vec<V>,
  135|     20|        vertices_vec: Vec<V>,
  154|      0|                vertices: Vec<V>,
  229|     29|        vertices_vec: Vec<V>,
  261|      0|                vertices: Vec<V>,
  306|      0|                vertices: Vec<V>,
  367|      4|                    groups.push(Pair(k, vec![v]));
  406|      4|                    groups.push(Pair(k, vec![v]));
  267|      6|                groups.push(Pair(key, vec![value]));
  289|      2|                    groups.push(Pair(key, vec![value]));
  105|       |    /// Verify MST has correct number of edges
  139|       |    /// Verify the expected results from the textbook examples
  156|       |        /// Verify that all implementations produce the same sorted result
   22|       |        /// Verify spanning tree properties
   24|       |        /// Verify spanning tree properties
  260|       |        /// Verify that all heapsort implementations produce correct results
  294|      1|   - Verify termination conditions
  295|       |    /// Verify that all heapsort implementations produce correct results
   29|       |        /// Verify MST has correct size
   78|       |    /// Verify that result is a valid spanning tree
   99|       |    /// Verify that result is a valid spanning tree
   31|       |        fn verify_mst_size<V: StT + Hash + Ord>(
   24|       |        fn verify_spanning_tree<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>, tree: &Set<Edge<V>>) -> B;
   26|       |        fn verify_spanning_tree<V: StT + MtT + Hash + Ord>(graph: &UnDirGraphMtEph<V>, tree: &Set<Edge<V>>) -> B;
  105|    222|            if *vertex == center {
  117|      0|        result.insert(0, vertex);
  130|     10|        for vertex in euler_tour.iter() {
  141|     70|        for vertex in vertices_vec.iter() {
  146|     11|        for vertex in euler_tour.iter() {
   29|     20|            let vertex = *finish_order.nth(i);
   30|     20|            let vertex = *finish_order.nth(i);
   46|    143|        for vertex in graph.vertices().iter() {
   57|      0|            for (vertex, center) in partition_map.iter() {
   58|      0|                if vertex != center {
    5|       |//! using vertex bridges and graph contraction with randomized star contraction.
   60|    222|        for vertex in vertices_vec.iter() {
   61|     24|            for (vertex, center) in partition_map.iter() {
   63|     19|        for vertex in graph.vertices().iter() {
   63|     23|        for vertex in graph.vertices().iter() {
   63|     24|                if vertex != center {
   75|     24|            for vertex in graph.vertices().iter() {
   77|     12|        result.insert(0, vertex);
   78|     20|        result.insert(0, vertex);
   79|     20|        result.insert(0, vertex);
   89|      7|            for vertex in graph.vertices().iter() {
   90|     81|            th_edges.into_iter().map(|(idx, vertex)| Pair(idx, vertex)).collect()
   92|     12|        result.insert(0, vertex);
   94|      4|            for vertex in graph.vertices().iter() {
   99|      0|        result.insert(0, vertex);
   24|       |        fn vertex_bridges_mt<V: StT + Hash + Ord + Send + Sync + 'static>(
   22|       |        fn vertex_bridges<V: StT + Hash + Ord>(edges: &Set<LabeledEdge<V>>) -> Set<(V, LabeledEdge<V>)>;
   62|      0|                        Edge(center.clone(), vertex.clone())
   65|      7|                vertex_to_block.insert(vertex.clone(), vertex.clone());
   68|      5|                        Edge(center.clone(), vertex.clone())
   77|     12|                    map.insert(vertex.clone(), vertex.clone());
   95|      3|        let vertex_map_arc = Arc::new(vertex_to_block);
    7|       |pub mod VertexMatchingMtEph {
    8|       |pub mod VertexMatchingStEph {
   63|      3|        let vertex_to_block = Arc::new(Mutex::new(std::collections::HashMap::new()));
   82|      3|        let vertex_to_block = Arc::try_unwrap(vertex_to_block).unwrap().into_inner().unwrap();
   64|     19|            if !vertex_to_block.contains_key(vertex) {
  102|  5.71k|            let vertices: Vec<V> = u_set.iter().cloned().collect();
  104|      3|            let vertices: Vec<V> = (0..seq.length()).map(|i| seq.nth(i).clone()).collect();
  113|       |            let vertices = $crate::SetLit![ $( $v ),* ];
  115|       |            let vertices = $crate::SetLit![ $( $v ),* ];
  131|       |            let vertices = $crate::SetLit![ $( $v ),* ];
  140|     10|            let vertices: Vec<V> = u_set.iter().cloned().collect();
  143|       |            let vertices = $crate::SetLit![ $( $v ),* ];
  148|       |            let vertices = $crate::SetLit![ $( $v ),* ];
  166|       |            let vertices = $crate::SetLit![ $( $v ),* ];
  167|      2|            let vertices: Vec<_> = current_edges.iter().map(|e| e.0.clone()).collect();
  175|       |            let vertices = $crate::SetLit![ $( $v ),* ];
  180|       |            let vertices = $crate::SetLit![ $( $v ),* ];
  185|       |            let vertices = $crate::SetLit![ $( $v ),* ];
  190|       |            let vertices = $crate::SetLit![ $( $v ),* ];
  230|       |            let vertices = $crate::SetLit![ $( $v ),* ];
  238|       |            let vertices = $crate::SetLit![ $( $v ),* ];
  247|  5.01k|            let vertices: Vec<V> = u_set.iter().cloned().collect();
  292|  5.01k|            let vertices: Vec<V> = u_set.iter().cloned().collect();
   45|       |    /// Vertices u,v change during contraction, but weight and label are immutable
  147|     20|        let vertices_arc = Arc::new(vertices_vec);
  117|      3|            &|vertices| vertices.clone(),
  170|      4|            &|vertices| vertices.clone(),
  146|     20|        let vertices_len = vertices_vec.len();
   26|       |        fn vertices(&self) -> &AVLTreeSetStEph<V>;
   27|       |        fn vertices(&self) -> AVLTreeSetStEph<V>;
   27|       |        fn vertices(&self) -> &AVLTreeSetStPer<V>;
   27|       |        fn vertices(&self) -> AVLTreeSetStPer<V>;
   28|       |        fn vertices(&self) -> &Set<V>;
   28|       |        fn vertices(&self) -> &Set<V>;
   28|       |        fn vertices(&self) -> &Set<V>;
   28|       |        fn vertices(&self) -> &Set<V>;
   29|       |        fn vertices(&self) -> &AVLTreeSetMtPer<V>;
   31|       |        fn vertices(&self) -> &Set<V>;
   31|       |        fn vertices(&self) -> &Set<V>;
   32|       |        fn vertices(&self) -> &Set<V>;
   32|       |        fn vertices(&self) -> &Set<V>;
   61|      0|        fn vertices(&self) -> &AVLTreeSetStEph<V> { &self.vertices }
   62|      0|        fn vertices(&self) -> &AVLTreeSetStPer<V> { &self.vertices }
   63|     68|        fn vertices(&self) -> &Set<V> { &self.V }
   64|      0|        fn vertices(&self) -> &AVLTreeSetMtPer<V> { &self.vertices }
   66|     91|        fn vertices(&self) -> &Set<V> { &self.V }
   67|    201|        fn vertices(&self) -> &Set<V> { &self.vertices }
   70|      5|        fn vertices(&self) -> AVLTreeSetStPer<V> {
   70|     93|        fn vertices(&self) -> &Set<V> { &self.vertices }
   71|      1|        fn vertices(&self) -> AVLTreeSetStEph<V> {
   73|     53|        fn vertices(&self) -> &Set<V> { &self.vertices }
   76|     51|        fn vertices(&self) -> &Set<V> { &self.vertices }
   81|      4|        fn vertices(&self) -> &Set<V> { &self.V }
   84|      5|        fn vertices(&self) -> &Set<V> { &self.V }
  330|      9|        let vertices_vec: Vec<V> = vertices.iter().cloned().collect();
   50|     50|        let vertices_vec: std::vec::Vec<V> = graph.vertices().iter().cloned().collect();
  194|     50|        let verts1 = vertices.clone();
  197|     50|        let verts2 = vertices;
  128|     79|            let v_heads = flips.get(v).copied().unwrap_or(false);
  181|     70|                let v_heads = coin_flips.get(v).copied().unwrap_or(false);
   69|    162|            let v_heads = coin_flips.get(v).copied().unwrap_or(false);
   78|    162|            if !v_heads && u_heads {
    2|       |//! Divide-and-conquer via reduce pattern - parallel implementation (Chapter 26, Section 5).
    2|       |//! Divide-and-conquer via reduce pattern - sequential implementation (Chapter 26, Section 5).
   86|       |        // Visit all neighbors connected by tree edges
  101|      9|                    return visited;
  103|      0|            return (visited, result);
  104|     10|            return (visited, AVLTreeSetStPer::empty());
  105|      7|        let visited = explore(graph, strategy, AVLTreeSetStEph::empty(), sources);
  106|      0|        let visited = visited.insert(vertex);
  107|     20|        let visited = visited.insert(vertex);
  112|     18|            dfs_reach(graph, visited, component, neighbor);
  114|      7|        let visited = explore(graph, strategy, AVLTreeSetMtPer::empty(), sources);
  128|      9|            let visited = explore(graph, strategy, AVLTreeSetStPer::empty(), sources);
   12|       |        pub visited: AVLTreeSetStEph<V>,
   12|       |        pub visited: AVLTreeSetStEph<V>,
  136|     13|            let (visited, priorities) = explore(graph, priority_fn, AVLTreeSetStEph::empty(), initial_frontier);
  147|     13|            let (visited, priorities) = explore(graph, priority_fn, AVLTreeSetMtPer::empty(), initial_frontier);
   14|       |        pub visited: AVLTreeSetStPer<V>,
  152|      7|            let (visited, priorities) = explore(graph, priority_fn, AVLTreeSetStPer::empty(), initial_frontier);
   15|       |        pub visited: AVLTreeSetMtEph<V>,
   15|       |        pub visited: AVLTreeSetStPer<V>,
   16|       |        pub visited: AVLTreeSetMtPer<V>,
   17|       |        pub visited: AVLTreeSetMtPer<V>,
   34|      2|            return visited;
   37|     13|        let visited = visited.insert(vertex);
   48|     10|            dfs_recursive(graph, visited, result, neighbor);
   50|     15|        let visited = visited.insert(vertex);
   64|      8|        (false, visited)
   65|      7|            return (visited, result);
   68|     20|        let visited = visited.insert(vertex);
   73|     16|        let visited = visited.insert(vertex);
   75|     18|            dfs_finish_order(graph, visited, result, neighbor);
   87|      7|                return visited;
   92|      7|                return visited;
   96|      0|            dfs_finish_order(graph, visited, result, neighbor);
  108|    105|                    if visited.contains_key(&u_idx) {
  108|     70|                    if visited.contains_key(&u_idx) {
   93|    111|                if visited.contains_key(&v) {
   93|    117|                if visited.contains_key(&v) {
  103|     34|            if visited.contains(&u) {
  124|     52|                if !visited.contains(v) {
  131|     10|            if !visited.contains(vertex) {
  147|     11|            if !visited.contains(vertex) {
  103|      8|            if visited_edges.contains(&edge_key) {
   95|      8|            if visited_edges.contains(&edge_key) {
  128|     17|                    if !visited.find(neighbor) {
   25|     11|            if !visited.find(&start) {
   28|     14|            if !visited.find(&start) {
   49|     20|            if !visited.find(&start) {
   50|      0|            if !visited.find(&start) {
  102|      0|        if visited.find(&vertex) {
  103|     30|        if visited.find(&vertex) {
   30|     20|            if !visited.find(&vertex) {
   33|     15|        if visited.find(&vertex) {
   46|     16|        if visited.find(&vertex) {
   64|     27|        if visited.find(&vertex) {
   69|     17|        if visited.find(&vertex) {
  129|     72|                    if visited.mem(&current) == false {
   92|     72|                    if visited.mem(&current) == false {
  132|    128|                            if visited.mem(neighbor) == false {
   95|    128|                            if visited.mem(neighbor) == false {
  108|     23|                let visited_new = visited.union(&selected);
  108|     47|                    let visited_new = visited.union(&AVLTreeSetMtPer::singleton(v.clone()));
  112|     23|                    let visited_new = visited.union(&AVLTreeSetStPer::singleton(v.clone()));
   91|     13|            let visited_new = visited.union(&selected);
   97|     13|            let visited_new = visited.union(&selected);
   99|     47|                    let visited_new = visited.union(&AVLTreeSetStEph::singleton(v.clone()));
  107|     45|                        if !visited_new.find(neighbor) {
  116|     45|                        if !visited_new.find(neighbor) {
  121|     17|                        if !visited_new.find(neighbor) {
   25|     11|            if !*visited.nth(start) {
   27|     14|            if !*visited.nth(start) {
   44|      0|            if !*visited.nth(start) {
   53|     20|            if !*visited.nth(start) {
  102|     30|        if *visited.nth(vertex) {
   31|     20|            if !*visited.nth(vertex) {
   38|     15|        if *visited.nth(vertex) {
   45|     16|        if *visited.nth(vertex) {
   61|     17|        if *visited.nth(vertex) {
   66|     27|        if *visited.nth(vertex) {
   87|      0|        if *visited.nth(vertex) {
  117|     13|                    let visited_seq = visited.to_seq();
  127|     13|                    let visited_seq = visited.to_seq();
  132|      7|                    let visited_seq = visited.to_seq();
  138|      7|            let visited_seq = visited.to_seq();
   46|       |        pub visualization_enabled: B,
  102|      0|                let v_left = v.clone_mt();
  104|      0|                let v_left = v.clone_mt();
  109|      0|                let v_left = v.clone_mt();
  123|    108|                let v_left = v.clone_mt();
  149|      0|                let v_left = v.clone_mt();
  149|      0|                let v_left = v.clone_mt();
  159|      0|                let v_left = v.clone_mt();
  165|      0|                let v_left = v.clone_mt();
  181|      0|                let v_left = v.clone_mt();
  201|      0|                let v_left = v.clone_mt();
  231|      0|                let v_left = v.clone_mt();
   97|      0|                let v_left = v.clone_mt();
  102|      0|                        right_arcs, v_right
  103|      0|                let v_right = v;
  105|      0|                let v_right = v;
  107|      0|                        parallel_neighbors(right_edges, v_right)
  109|      0|                        right_arcs, v_right
  110|      0|                let v_right = v;
  114|      0|                        parallel_neighbors(right_edges, v_right)
  124|    108|                let v_right = v;
  150|      0|                let v_right = v;
  150|      0|                let v_right = v;
  154|      0|                        right_arcs, v_right
  154|      0|                        right_arcs, v_right
  160|      0|                let v_right = v;
  164|      0|                        right_arcs, v_right
  166|      0|                let v_right = v;
  170|      0|                        parallel_neighbors(right_edges, v_right)
  182|      0|                let v_right = v;
  186|      0|                        right_arcs, v_right
  202|      0|                let v_right = v;
  206|      0|                        right_arcs, v_right
  232|      0|                let v_right = v;
   98|      0|                let v_right = v;
  372|      4|                .map(|Pair(k, vs)| Pair(k, LinkedListStEphS::from_vec(vs)))
  411|      4|                .map(|Pair(k, vs)| Pair(k, LinkedListStPerS::from_vec(vs)))
  167|     15|            for v_w in graph.out_neighbors_weighted(&u).iter() {
  170|     28|            for v_w in graph.out_neighbors_weighted(&u).iter() {
  195|     15|            for v_w in graph.out_neighbors_weighted(&u).iter() {
  198|     28|            for v_w in graph.out_neighbors_weighted(&u).iter() {
  109|     72|                    if w < *existing_w {
   75|     44|                    if w < *existing_w {
   87|     33|                    if w < *existing_w {
  113|    272|            let was_dead = matches!(self.table.nth(pos), Entry::Dead);
  288|    157|            let was_dead = matches!(self.table.nth(pos), Entry::Dead);
  145|      0|            if !was_deleted {
  150|      3|            if !was_deleted {
   43|       |                // We manually compute inclusive prefix sums instead of using scan_contract
  214|      1|        let weight = tour_weight_mt(graph, &tour);
  216|      1|        (tour, weight)
  245|      1|        let weight = tour_weight(graph, &tour);
  247|      1|        (tour, weight)
   27|       |//! let weight = graph.get_edge_weight(&"A", &"B"); // Returns Option<OrderedFloat<f64>>
   27|       |//! let weight = graph.get_edge_weight(&"A", &"B"); // Returns Option<OrderedFloat<f64>>
    2|       |//! Ephemeral weight-balanced (BB[α]) binary search tree with `find` support.
    2|       |//! Ephemeral weight-balanced (BB[α]) binary search tree with interior locking for multi-threaded access.
    7|       |pub mod WeightedDirGraphMtEphFloat {
  185|       |    macro_rules! WeightedDirGraphMtEphFloatLit {
  154|     10|        graph: &WeightedDirGraphMtEphFloat<usize>,
  186|     10|        graph: &WeightedDirGraphMtEphFloat<usize>,
    7|       |pub mod WeightedDirGraphMtEphInt {
  170|       |    macro_rules! WeightedDirGraphMtEphIntLit {
  183|      5|        graph: &WeightedDirGraphMtEphInt<usize>,
   32|       |pub mod WeightedDirGraphStEphFloat {
  180|       |    macro_rules! WeightedDirGraphStEphFloatLit {
  118|      5|        graph: &WeightedDirGraphStEphFloat<usize>,
  129|     19|        graph: &WeightedDirGraphStEphFloat<usize>,
   51|     20|        graph: &WeightedDirGraphStEphFloat<usize>,
   92|     46|        graph: &WeightedDirGraphStEphFloat<usize>,
   96|      5|        graph: &WeightedDirGraphStEphFloat<usize>,
    4|       |pub mod WeightedDirGraphStEphInt {
  110|       |    macro_rules! WeightedDirGraphStEphIntLit {
  120|     19|        graph: &WeightedDirGraphStEphInt<usize>,
  133|      5|        graph: &WeightedDirGraphStEphInt<usize>,
   92|     25|        graph: &WeightedDirGraphStEphInt<usize>,
    7|       |pub mod WeightedUnDirGraphMtEphFloat {
  138|       |    macro_rules! WeightedUnDirGraphMtEphFloatLit {
    7|       |pub mod WeightedUnDirGraphMtEphInt {
  126|       |    macro_rules! WeightedUnDirGraphMtEphIntLit {
   32|       |pub mod WeightedUnDirGraphStEphFloat {
  161|       |    macro_rules! WeightedUnDirGraphStEphFloatLit {
    4|       |pub mod WeightedUnDirGraphStEphInt {
  108|       |    macro_rules! WeightedUnDirGraphStEphIntLit {
   28|      1|        let weights = ArraySeqStEphS::from_vec(vec![
   31|      1|        let weights = ArraySeqStEphS::from_vec(vec![
   47|      1|        let weights = ArraySeqStEphS::from_vec(vec![
   52|       |    /// Weights is an adjacency matrix where weights.nth(i).nth(j) is the weight of edge (i,j).
   53|       |    /// Weights is an adjacency matrix where weights.nth(i).nth(j) is the weight of edge (i,j).
   59|      1|        let _weights = ArraySeqStEphS::from_vec(vec![
   83|      1|        let weights = ArraySeqStEphS::from_vec(vec![
  213|      1|- Double when α > threshold (e.g., 0.75)
  108|       |    /// where p is a large prime and a, b are random
   14|       |        /// where φ = (1+√5)/2 ≈ 1.618 (golden ratio)
   22|       |    /// where φ = (1+√5)/2 ≈ 1.618 (golden ratio)
   61|       |    /// where n = number of vertices, m = number of edges
   61|       |    /// where n = number of vertices, m = number of edges
  303|      2|             sequence will visit at least (m+1)/2 distinct positions before repeating, \
    2|       |//! BST with general reduced values augmentation using associative functions.
   34|      1|        println!("Graph with negative cycle 1->2->1 (weight = 2 + (-4) = -2):");
  365|      2|             distribution with different probe patterns for each key."
   66|      1|        println!("\nGraph with cycle 1->2->1 (weight = 1 + (-3) = -2):");
  103|    533|                let word = &entry.0;
  232|      0|        move |word: &Word| index.find(word)
   32|      3|        move |word: &Word| index.find(word)
   75|  1.46k|                    let word = word_tokens.nth(j);
   87|  1.46k|                let word = &pair.0;
   99|     36|            let word_entries = word_table.collect();
  211|      5|            let word_tokens = tokens(&doc.1);
   71|    258|                let word_tokens = tokens(content);
  101|       |        /// Work: O(n), Span: O(n)
  103|       |        /// Work: Θ(|a|), Span: Θ(1).
  103|       |    /// Work Θ(|V| + |E|), Span Θ(|V| + |E|), Parallelism Θ(1)
  104|       |    /// Work Θ(|E|), Span Θ(log |E|), Parallelism Θ(|E| / log |E|)
  105|       |    /// Work O(k), Span O(lg k), where k = end - start
  105|       |        // Work: Θ(n log n), Span: Θ(log² n) - remove vertex and all incident edges
  107|       |        // Work: Θ(log |V| + log |E|), Span: Θ(log |V| + log |E|)
  110|       |        // Work: Θ(log |V| + log |E|), Span: Θ(log |V| + log |E|)
  110|       |        // Work: Θ(n), Span: Θ(log n)
  111|       |        // Work: Θ(n), Span: Θ(n) - copy row and update
  114|       |        /// Work: O(n), Span: O(log n) - parallel tabulation
  114|       |        /// Work: O(n), Span: O(n)
  117|       |        // Work: Θ(log |E|), Span: Θ(log |E|)
  118|       |    /// Work O(m), Span O(lg m), Parallelism Θ(m/lg m)
  118|       |        // Work: Θ(n), Span: Θ(n)
  119|       |    /// Work O(m), Span O(m)
  120|       |        /// Work: O(n + m), Span: O(n + m)
  120|       |        // Work: Θ(log |E|), Span: Θ(log |E|)
  123|       |        // Work: Θ(log n), Span: Θ(log n) - update neighbor set
  130|       |    /// Work Θ(k × avg_degree) where k = end - start
  130|       |        // Work: Θ(n+m), Span: Θ(log(n+m))
  134|       |    /// Work O(k), Span O(lg k), where k = end - start
  139|       |        /// Work: Θ(1), Span: Θ(1).
  139|       |        // Work: Θ(log n), Span: Θ(log n)
  141|       |        // Work: Θ(n²), Span: Θ(1) with parallel - Exercise 52.6
  145|       |        /// Work: O(n + m), Span: O(n + m)
  146|       |        // Work: Θ(n+m), Span: Θ(log(n+m))
  148|       |        /// Work: Θ(1) to compute bounds; allocation and cloning Θ(length) in this owning representation.
  161|       |        /// Work: Θ(1), Span: Θ(1).
  162|       |    /// Work Θ(|V| + |E| × avg_degree), Span Θ(log |V| + log |E| + avg_degree)
  170|       |        /// Work: Θ(n) worst case (shrink-to-fit moves), Θ(1) best case (rebrand); Span: Θ(1). <br/>
  174|       |        /// Work: O(n), Span: O(log n) - parallel map
  178|      2|- O(n) work to rehash all elements
  188|       |        /// Work: O(n + m), Span: O(n + m)
  190|       |    /// Work O(|P|), Span O(lg |P|), Parallelism Θ(|P|/lg |P|)
  192|       |        // Work: Θ(n+m), Span: Θ(log(n+m))
  198|       |        // Work: Θ(n+m), Span: Θ(log(n+m))
   20|       |    /// Work: Θ(n²), Span: Θ(n²) (sequential due to imperative loops)
  222|       |        /// Work: O(log n), Span: O(log n)
  228|       |        /// Work: O(n), Span: O(log n) - parallel filter
  242|       |        /// Work: O(n), Span: O(n)
  248|       |        /// Work: O(n), Span: O(n)
   25|       |        /// Work: Θ(1), Span: Θ(1).
  274|       |        /// Work: O(n + m), Span: O(n + m)
  280|       |        /// Work: O(n + m), Span: O(n + m)
  284|       |        /// Work: O(n + m), Span: O(log(n + m)) - parallel intersection
   29|       |        /// Work: Θ(1), Span: Θ(1).
  311|       |        /// Work: O(n + m), Span: O(log(n + m)) - parallel union
   32|       |    /// Work: O(nm), Span: O(n lg n) where n = |V|, m = |E|
   32|       |    /// Work: O(nm), Span: O(n lg n) where n = |V|, m = |E|
   33|       |        /// Work: Θ(1), Span: Θ(1).
  356|       |        /// Work: O(n + m), Span: O(log(n + m)) - parallel difference
   37|       |        /// Work: Θ(1), Span: Θ(1).
   37|       |        // Work: Θ(n), Span: Θ(n) - create n empty neighbor lists
   38|       |        // Work: Θ(n²), Span: Θ(n²) - create n×n matrix of false
  391|       |        /// Work: O(log n), Span: O(log n) - binary search
  411|       |        /// Work: O(n), Span: O(log n) - parallel filter
   41|       |        /// Work: Θ(1), Span: Θ(1).
   45|       |        /// Work: Θ(length), Span: Θ(1).
  467|       |        /// Work: O(n), Span: O(log n) - parallel insert with combine
   46|       |        /// Work O(1), Span O(1)
   49|       |        /// Work: Θ(|a|), Span: Θ(1).
   50|       |        /// Work O(1) amortized, Span O(1) amortized
   51|       |        // Work: Θ(1), Span: Θ(1)
   53|       |        // Work: Θ(1), Span: Θ(1) - table size
   53|       |        /// Work: Θ(length), Span: Θ(1).
  547|       |        /// Work: O(n + m), Span: O(log n) - parallel restrict
   54|       |        // Work: Θ(n), Span: Θ(n) - sum all neighbor list lengths
   55|       |        /// Work O(1) amortized, Span O(1) amortized
   56|       |        /// Work: O((|V| + |E|) log |V|), Span: O(|V| log |V|) sequential rounds.
   56|       |        /// Work: O(|V| + |E|), Span: O(|V|) (sequential rounds).
   56|       |        // Work: Θ(1), Span: Θ(1)
   56|       |        // Work: Θ(n), Span: Θ(log n) - sum all neighbor set sizes
   58|       |        /// Work: O(1), Span: O(1)
   59|       |        /// Work: Θ(|a| + |b|), Span: Θ(1).
   59|       |        // Work: Θ(n²), Span: Θ(n²) - count all true entries
    5|       |//! Achieves Work O(m log n), Span O(log² n).
  603|       |        /// Work: O(n + m), Span: O(log n) - parallel subtract
   60|       |        /// Work O(1), Span O(1)
   60|       |    /// Work: O(m log n), Span: O(m log n)
   60|       |    /// Work: O(m log n), Span: O(m log n)
   61|       |        /// Work: O(1), Span: O(1)
   61|       |        /// Work: O(1), Span: O(1)
   62|       |            // Work efficient and parallel implementation
   63|       |        /// Work: O(|V| + |E|), Span: O(|V|).
   63|       |        /// Work: Θ(|a|), Span: Θ(1).
   64|       |        /// Work O(1), Span O(1)
   64|       |        /// Work: O(1), Span: O(1)
   64|       |        // Work: Θ(d(u)), Span: Θ(d(u)) - linear search in neighbor list
   66|       |        // Work: Θ(log |E|), Span: Θ(log |E|)
   67|       |        /// Work: Θ(total length), Span: Θ(1).
   68|       |        /// Work O(1), Span O(1)
   68|       |        /// Work: O(1), Span: O(1)
   68|       |        // Work: Θ(log |E|), Span: Θ(log |E|)
   69|       |        // Work: Θ(|E|), Span: Θ(log |E|) - filter over all edges
   70|       |            // Work efficient and parallel implementation
   71|       |        /// Work: O(1), Span: O(1)
   71|       |        /// Work: Θ(|a|), Span: Θ(1).
   71|       |    /// Work Θ(|E|), Span Θ(log |E|), Parallelism Θ(|E|/log |E|)
   72|       |            // Work efficient and parallel implementation
   73|       |        // Work: Θ(1), Span: Θ(1) - direct array access
   75|       |        /// Work: O(n), Span: O(n)
   75|       |        /// Work: Θ(|a| + |updates|), Span: Θ(1).
   78|       |        /// Work: O(n), Span: O(log n) - parallel domain extraction
   78|       |        // Work: Θ(1), Span: Θ(1) - direct access
   79|       |        /// Work: Θ(1), Span: Θ(1).
   80|       |        // Work: Θ(log n), Span: Θ(log n) - table lookup + set membership
   80|       |        // Work: Θ(n), Span: Θ(log n)
   81|       |        // Work: Θ(1), Span: Θ(1)
   81|       |        // Work: Θ(n), Span: Θ(n) - scan row for true entries
   82|       |        // Work: Θ(|E|), Span: Θ(log |E|)
   83|       |        /// Work: Θ(1), Span: Θ(1).
   84|       |        // Work: Θ(|E|), Span: Θ(log |E|)
   84|       |        // Work: Θ(n), Span: Θ(n) - must copy entire sequence to update
   85|       |        /// Work: O(n), Span: O(n)
   85|       |        // Work: Θ(log |V|), Span: Θ(log |V|)
   87|       |        // Work: Θ(log |V|), Span: Θ(log |V|)
   87|       |        /// Work: Θ(|pairs|²) worst case due to linear search, Span: Θ(1).
   88|       |        // Work: Θ(log n), Span: Θ(log n) - table lookup
   93|       |        // Work: Θ(|E| log |E|), Span: Θ(log² |E|) - must remove all incident edges
   95|       |    /// Work Θ(|E| × avg_degree), Span Θ(log |E| + avg_degree), Parallelism Θ(|E|/log |E|)
   96|       |        // Work: Θ(log n), Span: Θ(log n) - lookup + size
   96|       |        // Work: Θ(n), Span: Θ(n)
   97|       |        /// Work: Θ(|a|), Span: Θ(1).
   99|       |        // Work: Θ(log n), Span: Θ(log n) - insert empty neighbor set
  100|      4|            handle.join().expect("parallel_increment: worker panicked");
  432|      0|            writeln!(f, "Worst strategy: {}", self.worst_strategy)?;
  254|     14|            let worst_strategy = performance_ranking[2].0.clone();
   56|       |        pub worst_strategy: String,
  198|     15|                let w_prime = (*w as i64) + p_u - p_v;
  201|     24|                let w_prime = OrderedF64::from(w.0 + p_u.0 - p_v.0);
  112|       |        // Wrap in Arc for thread-safe sharing
  106|    111|                let x0 = data[0].clone();
  107|  5.81k|                        let x0 = data[0].clone();
  110|  5.81k|                        if (x0 <= xm && xm <= xl) || (xl <= xm && xm <= x0) {
   35|      3|            let x0 = self.nth(lo).clone();
   37|      6|            let x0 = self.nth_cloned(lo);
   38|      3|            if (x0 <= xm && xm <= xl) || (xl <= xm && xm <= x0) {
   38|      8|            let x0 = self.nth_cloned(lo);
   40|      6|            if (x0 <= xm && xm <= xl) || (xl <= xm && xm <= x0) {
   41|      8|            if (x0 <= xm && xm <= xl) || (xl <= xm && xm <= x0) {
   90|      6|                let x0 = a.nth(lo).clone();
   93|      6|                if (x0 <= xm && xm <= xl) || (xl <= xm && xm <= x0) {
  101|      4|            for x in &self.data {
  106|     23|                    Self::update_size(&mut x);
  108|    463|                    Self::update(&mut x);
  109|  8.12k|                if x == *v {
  110|     11|                    Self::update(&mut x);
  120|  74.1k|            for x in other.data.iter() {
  126|     48|            let x = *key as u64;
  131|  15.0k|            for x in self.data.intersection(&other.data) {
  138|     11|            for x in self.data.iter() {
  146|    158|                    Self::update_node(&mut x);
  153|  65.2k|                    if x == *v {
  157|      1|            if x < self.universe_size {
  160|      5|                    Self::update_node(&mut x);
  163|     36|            if x < self.universe_size {
  177|   171k|            for x in v {
  188|     88|            self.filter(move |x| !other_clone.find(x))
  194|     10|            self.filter(move |x| !other_clone.find(x))
  202|      0|            for x in other.data.iter() {
  213|      0|            for x in self.data.intersection(&other.data) {
  216|      7|            for x in self.data.iter() {
  220|      0|            for x in self.data.iter() {
  227|      6|            for x in self.data.iter() {
  239|      0|        update_meta(&mut x);
  247|  17.6M|        update_meta(&mut x);
  259|      0|            for x in v {
   27|      0|        for x in 0..n {
   28|      0|        for x in 0..n {
   33|       |        // {x ∈ {4, 11, 2, 6} | x < 7} = {4, 2, 6}
  347|      0|        update_meta(&mut x);
  356|      6|        update_meta(&mut x);
   39|      0|        let x = y.left.as_ref().expect("rotate_right requires left").clone();
   39|      0|        let x = y.left.as_ref().expect("rotate_right requires left").clone();
   46|     19|            Some(ArraySeqStPerS::reduce(a, &|x, y| (*x).max(*y), *a.nth(0)))
   48|     19|            Some(ArraySeqMtPerS::reduce(a, &|x: &N, y: &N| (*x).max(*y), *a.nth(0)))
   48|      3|                let x = filtered_a.nth(i);
   53|     10|            ArraySeqMtPerS::reduce(a, &|x: &N, y: &N| *x + *y, 0)
   58|      4|            ArraySeqMtPerS::reduce(a, &|x: &N, y: &N| *x * *y, 1)
   59|      0|                    let x = *a.nth(i);
   63|     18|            ArraySeqMtPerS::reduce(a, &|x: &B, y: &B| *x || *y, false)
   68|     18|            ArraySeqMtPerS::reduce(a, &|x: &B, y: &B| *x && *y, true)
   72|     19|            for x in self.data.iter() {
   78|      1|            if x < u {
   79|    244|                    Self::update(&mut x);
   80|    730|                    Self::update(&mut x);
   83|       |        // {x ∈ {4, 11, 2, 6} | x < 7} = {4, 2, 6}
   86|    112|                    Self::update(&mut x);
   86|     16|                    Self::update(&mut x);
   89|  22.9k|                    Self::update(&mut x);
   92|  1.02k|                    Self::update_size(&mut x);
   92|    266|                    self.elements.insert(pos, x);
   93|    107|                    Self::update(&mut x);
   93|     21|                    Self::update(&mut x);
   94|     76|                    Self::update(&mut x);
   99|    110|                    Self::update(&mut x);
   99|  1.32k|                    Self::update(&mut x);
  251|      8|            let x_clone = x.clone();
  121|      6|                        let xgt = a.nth(gt).clone();
  158|      8|                        let xgt = a.nth(gt).clone();
   73|      4|                        let xgt = a.nth(gt).clone();
  110|     24|                    let xi = a.nth(i).clone();
  111|     24|                    if xi < pivot {
  147|     23|                    let xi = a.nth(i).clone();
  148|     23|                    if xi < pivot {
   62|     37|                    let xi = a.nth(i).clone();
   63|     37|                    if xi < pivot {
  108|    111|                let xl = data[last].clone();
  109|  5.81k|                        let xl = data[last].clone();
   37|      3|            let xl = self.nth(hi - 1).clone();
   39|      6|            let xl = self.nth_cloned(hi - 1);
   40|      8|            let xl = self.nth_cloned(hi - 1);
   92|      6|                let xl = a.nth(hi - 1).clone();
   42|      0|        mk(x.value.clone(), x.left.clone(), Some(new_y))
   42|      0|        mk(x.value.clone(), x.left.clone(), Some(new_y))
  113|      4|                            let xlt = a.nth(lt).clone();
  150|      5|                            let xlt = a.nth(lt).clone();
   65|     21|                            let xlt = a.nth(lt).clone();
  107|    111|                let xm = data[mid].clone();
  108|  5.81k|                        let xm = data[mid].clone();
   36|      3|            let xm = self.nth(mid).clone();
   38|      6|            let xm = self.nth_cloned(mid);
   39|      8|            let xm = self.nth_cloned(mid);
   91|      6|                let xm = a.nth(mid).clone();
  100|    110|                    Self::update(&mut y);
  100|  1.32k|                    Self::update(&mut y);
  107|     23|                    Self::update_size(&mut y);
  119|  9.13k|                if y == *v {
  147|    158|                    Self::update_node(&mut y);
  161|      5|                    Self::update_node(&mut y);
  203|  76.0k|                    if y == *v {
  236|      0|        update_meta(&mut y);
  250|  17.6M|        update_meta(&mut y);
   28|      0|            for y in 1..n {
   29|      0|            for y in 1..=n {
   29|      0|                v.push(Pair(x, y));
  343|      0|        update_meta(&mut y);
  360|      6|        update_meta(&mut y);
   46|      0|        let y = x.right.as_ref().expect("rotate_left requires right").clone();
   46|      0|        let y = x.right.as_ref().expect("rotate_left requires right").clone();
   80|    244|                    Self::update(&mut y);
   81|    730|                    Self::update(&mut y);
   85|    112|                    Self::update(&mut y);
   85|     16|                    Self::update(&mut y);
   93|  1.02k|                    Self::update_size(&mut y);
   94|     21|                    Self::update(&mut y);
   95|     76|                    Self::update(&mut y);
   30|      0|                for z in 2..=n + 1 {
  268|      2|             For α=0.9, this increases to 10 probes, showing severe performance degradation."
  206|      1|- Work: Θ(n) where n is number of elements
  209|      1|- Span: Θ(n) sequential rehashing
  457|      1|        analyzer.compare_probing_strategies(17, 0.6)
  370|      1|                    expected_successful_probes: 1.0,
  371|      1|                    expected_unsuccessful_probes: 1.0,
  102|      0|        output.push_str("PART 1: Textbook Example Dataset\n");
  102|       |    /// 1. All vertices are included
  119|     25|                c1: 1,
  120|     25|                c2: 1,
  141|      0|                | 1 => PrimTreeSeqStTree::One(self.data[0].clone()),
  146|       |        // 1. Create singleton sets: ⟨{1}, {3}, {2}, {3}, {1}, {4}, {2}⟩
  218|       |    /// 1. Given spanning tree T (should be MST for best results)
  219|    313|                    rank: 1,
   24|    234|                size: 1,
   25|    204|                height: 1,
   26|      0|                return 1;
   26|  1.07k|                size: 1,
   26|    204|                size: 1,
   26|    326|                size: 1,
   26|    494|                size: 1,
   26|    608|                height: 1,
   26|    624|                size: 1,
   27|  1.76k|                height: 1,
   27|       |    /// 1. Pick an arbitrary unprocessed vertex v as a star center
   27|    608|                size: 1,
   28|  1.02k|                size: 1,
   28|  1.58k|                size: 1,
   28|  1.76k|                size: 1,
   28|  20.5M|                height: 1,
   29|      1|            ArraySeqStEphS::from_vec(vec![0, 1, i64::MAX]),
   29|       |    /// 1. Flip a coin for each vertex
   31|  11.3k|            height: 1 + hl.max(hr),
   31|  1.23M|            height: 1 + hl.max(hr),
   31|    199|                size: 1,
   32|    174|                size: 1,
   33|       |    /// 1. Base case: If no edges, return empty edge set
   33|       |    /// 1. Bellman-Ford to compute potentials and eliminate negative weights
   33|     39|                height: 1,
  341|      1|            AdvancedQuadraticProbingStrategy::new_with_coefficients(hash_fn, 1, 1);
   34|       |    /// 1. Bellman-Ford to compute potentials and eliminate negative weights
   34|  24.9k|                size: 1,
  367|      1|            AdvancedQuadraticProbingStrategy::new_with_coefficients(hash_fn.clone(), 1, 1);
  374|      1|            AdvancedQuadraticProbingStrategy::new_with_coefficients(hash_fn, 1, 1);
   38|       |    /// 1. Bellman-Ford to compute potentials (sequential)
   38|       |    /// 1. Bellman-Ford to compute potentials (sequential)
   43|       |    /// 1. Initialize distances: d(s) = 0, d(v) = ∞ for v ≠ s
   43|       |    /// 1. Initialize distances: d(s) = 0, d(v) = ∞ for v ≠ s
   43|       |    /// 1. Sort edges by weight
   60|      1|            ArraySeqStEphS::from_vec(vec![0, 1, i64::MAX, i64::MAX]),
   60|       |        // 1. Compute star partition
   65|       |        // 1. Compute parallel star partition
   99|      1|                | 1 => PrimTreeSeqStTree::One(self.data[0].clone()),
    2|       |
    2|       |//!
    2|       |//!
    2|       |//!
    2|       |//!
    2|       |//!
    2|       |//!
    2|       |//!
    2|       |//!
    2|       |//!
    2|       |//!
    2|       |//!
    2|       |//!
    2|       |//!
    2|       |//!
    2|       |//!
    2|       |//!
    2|       |//!
  103|       |    /// 2. Exactly |V| - 1 edges
  110|      0|        output.push_str("PART 2: Reverse-Sorted Input\n");
  147|       |        // 2. Reduce with union: {1} ∪ {3} ∪ {2} ∪ {3} ∪ {1} ∪ {4} ∪ {2} = {1, 2, 3, 4}
  179|      2|        assert_eq!(intersection.size(), 2);
  219|       |    /// 2. Compute Euler tour (visits each edge twice)
   28|       |    /// 2. Add all neighbors of v as satellites
   30|       |    /// 2. Find edges from tails (non-centers) to heads (centers)
  307|      0|                return 2;
   34|       |    /// 2. Compute star partition (centers and partition map)
   34|       |    /// 2. Dijkstra from each vertex on reweighted graph
  345|      0|                    return 2;
   35|       |    /// 2. Dijkstra from each vertex on reweighted graph
   39|       |    /// 2. Reweight edges (sequential)
   39|       |    /// 2. Reweight edges (sequential)
   44|       |    /// 2. For each edge (u,v) in sorted order:
   44|       |    /// 2. For each round k = 0 to |V|-1:
   44|       |    /// 2. For each round k = 0 to |V|-1:
   63|       |        // 2. Build quotient graph
   68|       |        // 2. Build quotient graph in parallel
  217|       |    /// 2-approximation algorithm for metric TSP:
   39|       |        /// 2-approximation algorithm for metric TSP
    7|       |//! - 2-approximation guarantee
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
    3|       |//!
  104|       |    /// 3. All edges are from original graph
  117|      0|        output.push_str("PART 3: Already-Sorted Input\n");
  187|      2|        assert_eq!(difference.size(), 3);
  220|       |    /// 3. Apply shortcuts using triangle inequality
   29|       |    /// 3. Remove v and its satellites from consideration
    2|       |//! Chapter 3 insertion sort over mutable slices.
   31|      2|        assert_eq!(set_abc.size(), 3);
   31|       |    /// 3. Use Seq.inject to map satellites to centers
   35|       |    /// 3. Add all edges from partition map to spanning tree
   36|      2|        assert_eq!(filtered.size(), 3);
   40|       |    /// 3. Parallel Dijkstra from each vertex using ParaPair! divide-and-conquer
   40|       |    /// 3. Parallel Dijkstra from each vertex using ParaPair! divide-and-conquer
   49|       |    /// 3. If |V| rounds completed without convergence, negative cycle exists
   49|       |    /// 3. If |V| rounds completed without convergence, negative cycle exists
   66|       |        // 3. Recursively contract quotient graph
   71|       |        // 3. Recursively contract quotient graph
   81|      2|        assert_eq!(set_abc.size(), 3);
   86|      2|        assert_eq!(filtered.size(), 3);
   92|      7|        println!("splitRank(A, 3) = (");
    4|       |
    4|       |
    4|       |
    4|       |
    4|       |
    4|       |
    4|       |
    4|       |
    4|       |
    4|       |
    4|       |
    4|       |
    4|       |
    4|       |
    4|       |
    4|       |
    4|       |
    4|       |
    4|       |
    4|       |
    4|       |
    4|       |
    4|       |//!
    4|       |//!
    4|       |//!
    4|       |//!
    4|       |//!
    4|       |//!
    4|       |//!
    4|       |//!
    4|       |//!
    4|       |//!
    4|       |//!
    4|       |//!
    4|       |//!
    4|       |//!
    4|       |//!
    4|       |//!
    4|       |//!
    4|       |//!
    4|       |//!
  113|      2|        assert_eq!(seq_result.length(), 4);
  119|      2|        assert_eq!(set_from_seq.size(), 4);
  124|      0|        output.push_str("PART 4: Input with Duplicates\n");
  139|      2|        assert_eq!(set_result.size(), 4);
  162|      2|        assert_eq!(manual_union.size(), 4);
  197|      2|        assert_eq!(set_delete.size(), 4);
  221|       |    /// 4. Result has weight ≤ 2 × w(T)
   30|       |    /// 4. Repeat until all vertices are processed
   32|       |    /// 4. Remaining vertices become singleton centers
   36|       |    /// 4. Build quotient graph
   63|      2|        assert_eq!(seq_result.length(), 4);
   69|      2|        assert_eq!(set_from_seq.size(), 4);
   69|       |        // 4. Expand result back to original graph
   74|       |        // 4. Expand result back to original graph
    4|       |//! Abstract:
    4|       |//! Abstract:
    4|       |//! Abstract:
    4|       |//! Implements:
    4|       |//! Implements:
    4|       |//! Implements:
    4|       |//! Implements:
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
    5|       |
  131|      0|        output.push_str("PART 5: Edge Cases\n");
  207|      2|        assert_eq!(set_insert.size(), 5);
  212|      2|        assert_eq!(set_insert.size(), 5);
   32|      1|            ArraySeqStEphS::from_vec(vec![0, 5, 10, i64::MAX]),
   37|       |    /// 5. Recursively compute spanning tree of quotient
    2|       |//! Chapter 5.1 ephemeral Set built on `std::collections::HashSet`.
    2|       |//! Chapter 5.2 ephemeral Relation built on `Set<Pair<A,B>>`.
    2|       |//! Chapter 5.5 ephemeral Mapping (Function) built on `Relation<A,B>`.
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |
    6|       |//!
    6|       |//!
    6|       |//!
    6|       |//!
    6|       |//!
    6|       |//!
    6|       |//!
    6|       |//!
    6|       |//!
  138|      0|        output.push_str("PART 6: Efficiency Comparison\n");
    2|       |//! Chapter 6 Labeled Directed Graph (ephemeral) using Set for vertices and labeled arcs.
    2|       |//! Chapter 6 Labeled Directed Graph (ephemeral) using Set for vertices and labeled arcs - Multi-threaded version.
    2|       |//! Chapter 6 Labeled Undirected Graph (ephemeral) using Set for vertices and labeled edges.
    2|       |//! Chapter 6 Labeled Undirected Graph (ephemeral) using Set for vertices and labeled edges - Multi-threaded version.
    2|       |//! Chapter 6 Weighted Directed Graph (ephemeral) with floating-point weights - Multi-threaded version.
    2|       |//! Chapter 6 Weighted Directed Graph (ephemeral) with floating-point weights - Single-threaded version.
    2|       |//! Chapter 6 Weighted Directed Graph (ephemeral) with integer weights - Multi-threaded version.
    2|       |//! Chapter 6 Weighted Directed Graph (ephemeral) with integer weights - Single-threaded version.
    2|       |//! Chapter 6 Weighted Undirected Graph (ephemeral) with floating-point weights - Multi-threaded version.
    2|       |//! Chapter 6 Weighted Undirected Graph (ephemeral) with floating-point weights - Single-threaded version.
    2|       |//! Chapter 6 Weighted Undirected Graph (ephemeral) with integer weights - Multi-threaded version.
    2|       |//! Chapter 6 Weighted Undirected Graph (ephemeral) with integer weights - Single-threaded version.
   38|       |    /// 6. Map quotient tree edges back to original edges
    6|       |use crate::Types::Types::*;
    6|       |use crate::Types::Types::*;
    6|       |use crate::Types::Types::*;
    6|       |use crate::Types::Types::*;
    6|       |use std::collections::hash_map::DefaultHasher;
    2|       |//! Chapter 6.1 Directed Graph (ephemeral) using Set for vertices and arcs.
    2|       |//! Chapter 6.1 Directed Graph (ephemeral) using Set for vertices and arcs - Multi-threaded version.
    2|       |//! Chapter 6.1 Undirected Graph (ephemeral) using Set for vertices and edges.
    2|       |//! Chapter 6.1 Undirected Graph (ephemeral) using Set for vertices and edges - Multi-threaded version.
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |
    7|       |//!
    7|       |//!
    7|       |//!
    7|       |//!
    7|       |//!
    7|       |//!
    7|       |//!
    7|       |//!
    7|       |//!
    7|       |//!
    7|       |//!
    7|       |//!
  101|      2|        assert_eq!(union_result.size(), 7);
  146|      0|        output.push_str("PART 7: Complexity Analysis\n");
   51|      2|        assert_eq!(union_result.size(), 7);
    7|       |use crate::Chap47::FlatHashTable::FlatHashTable::*;
    7|       |use crate::Chap47::FlatHashTable::FlatHashTable::*;
    7|       |use crate::Chap47::FlatHashTable::FlatHashTable::*;
    7|       |use crate::Chap47::FlatHashTable::FlatHashTable::ProbeSequence;
    7|       |use std::collections::HashMap;
    7|       |use std::collections::HashMap;
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |
    8|       |//!
    8|       |//!
  154|      0|        output.push_str("PART 8: Correctness Verification\n");
    8|       |use crate::Chap47::HashFunctionTraits::HashFunctionTraits::*;
    8|       |use crate::Chap47::HashFunctionTraits::HashFunctionTraits::*;
    8|       |use crate::Chap47::HashFunctionTraits::HashFunctionTraits::*;
    8|       |use crate::Chap47::HashFunctionTraits::HashFunctionTraits::*;
    8|       |use crate::Types::Types::*;
    8|       |use crate::Types::Types::*;
    8|       |use crate::Types::Types::*;
    8|       |use std::hash::Hash;
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |
    9|       |    };
    9|       |    };
    9|       |//!
    9|       |//!
    9|       |//!
    9|       |//!
    9|       |//!
    9|       |//!
  193|      0|        print!("getRange(3, 9) = [");
    9|       |    #[derive(Clone)]
    9|       |    #[derive(Clone)]
    9|       |//! ```rust
    9|       |//! ```rust
    9|       |use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |use crate::Chap18::ArraySeqStPer::ArraySeqStPer::*;
    9|       |use crate::Chap47::LinearProbing::LinearProbing::*;
    9|       |use crate::Types::Types::*;
    9|       |use crate::Types::Types::*;
    9|       |use crate::Types::Types::*;
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |
   10|       |        ///
   10|       |    };
   10|       |//!
   10|       |//!
   10|       |//!
   10|       |//!
   10|      0|}
   63|      2|                max_probes: 10,
   84|      1|            ArraySeqStEphS::from_vec(vec![0, 10, i64::MAX]),
   10|       |    #[derive(Clone)]
   10|       |use crate::Chap47::FlatHashTable::FlatHashTable::*;
   10|       |use crate::Chap47::FlatHashTable::FlatHashTable::*;
   10|       |use crate::Chap47::FlatHashTable::FlatHashTable::*;
   10|       |use crate::Chap47::HashFunctionTraits::HashFunctionTraits::*;
   10|       |use crate::Chap47::HashFunctionTraits::HashFunctionTraits::*;
   10|       |use crate::Chap47::HashFunctionTraits::HashFunctionTraits::*;
   10|       |use crate::Chap47::SeparateChaining::SeparateChaining::*;
   10|       |use crate::Types::Types::*;
   10|       |use crate::Types::Types::*;
   10|       |use crate::Types::Types::*;
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |
   11|       |    
   11|       |    };
    2|       |//! Chapter 11 — Parallel Fibonacci (multi-threaded).
   11|       |    #[derive(Clone)]
   11|       |    #[derive(Clone)]
   11|       |    #[derive(Clone)]
   11|       |    #[derive(Clone)]
   11|       |    #[derive(PartialEq)]
   11|       |        Leaf,
   11|       |use crate::Chap47::AdvancedDoubleHashing::AdvancedDoubleHashing::*;
   11|       |use crate::Chap47::AdvancedDoubleHashing::AdvancedDoubleHashing::*;
   11|       |use crate::Chap47::HashFunctionTraits::HashFunctionTraits::*;
   11|       |use crate::Chap47::HashFunctionTraits::HashFunctionTraits::*;
   11|       |use crate::Chap47::HashFunctionTraits::HashFunctionTraits::*;
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |
   12|       |    }
   12|       |    }
   12|       |    }
   12|       |    }
   12|     23|        DocumentCollectionLit![
    2|       |//! Chapter 12 — Exercise 12.1: spin-lock via fetch-and-add tickets.
    2|       |//! Chapter 12 — Exercise 12.2: implement fetch-and-add using compare-and-swap.
    2|       |//! Chapter 12 — Exercise 12.5: lock-free concurrent stack using compare-and-swap.
   12|       |    #[derive(Clone)]
   12|       |    #[derive(Clone)]
   12|       |    #[derive(Clone)]
   12|       |    #[derive(Clone)]
   12|       |    #[derive(PartialEq)]
   12|       |    #[derive(PartialEq)]
   12|       |    #[derive(PartialEq)]
   12|       |    #[derive(PartialEq)]
   12|       |        Leaf,
   12|       |        Node(Box<BalBinNode<T>>),
   12|       |        Red,
   12|       |use crate::Chap47::AdvancedLinearProbing::AdvancedLinearProbing::*;
   12|       |use crate::Chap47::AdvancedLinearProbing::AdvancedLinearProbing::*;
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |
   13|       |    }
   13|       |    }
   13|       |    }
   13|       |    }
   13|       |    }
   13|       |    }
   13|       |    }
   13|       |    }
   13|       |    }
   13|       |    }
   13|       |    }
   13|       |        Black,
   13|       |    #[derive(Clone)]
   13|       |    #[derive(Clone)]
   13|       |    #[derive(Clone)]
   13|       |    #[derive(Clone)]
   13|       |    #[derive(Clone)]
   13|       |    #[derive(Clone)]
   13|       |    #[derive(Clone)]
   13|       |    #[derive(Debug)]
   13|       |        Empty,
   13|       |        Leaf,
   13|       |use crate::Chap47::AdvancedQuadraticProbing::AdvancedQuadraticProbing::*;
   13|       |use crate::Chap47::AdvancedQuadraticProbing::AdvancedQuadraticProbing::*;
   13|       |    where
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |
   14|       |        
   14|       |    }
   14|       |    }
   14|       |    }
   14|       |    }
   14|       |    }
   14|       |    }
   14|       |    }
   14|       |    }
   14|       |    }
   14|       |    }
   14|       |    }
   14|       |    }
   14|       |    }
   14|       |    }
   14|       |    }
   14|       |    }
   14|       |    }
   14|       |    }
   14|       |    }
   14|       |//!
   14|       |//!
   14|       |        Dead,
   14|       |        #[default]
   14|       |    #[derive(Clone)]
   14|       |        Red,
   14|       |use crate::Chap47::FlatHashTable::FlatHashTable::*;
   14|       |use crate::Chap47::FlatHashTable::FlatHashTable::*;
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |
   15|       |        
   15|       |        }
   15|       |    }
   15|       |    }
   15|       |    }
   15|       |    }
   15|       |    }
   15|       |    }
   15|       |    }
   15|       |    }
   15|       |    }
   15|       |    }
   15|       |    }
   15|       |    }
   15|       |    }
   15|       |    }
   15|       |    }
   15|       |    }
   15|       |    }
   15|       |    }
   15|       |    }
   15|       |    }
   15|       |    }
   15|       |    }
   15|       |    }
   15|       |    }
   15|       |    }
   15|       |        Black,
   15|       |    #[derive(Clone)]
   15|       |    #[derive(Debug)]
   15|       |    #[derive(Debug)]
   15|       |    #[derive(PartialEq)]
   15|       |        Empty,
   15|       |        Leaf,
   15|       |        Leaf,
   15|       |use crate::Chap47::HashFunctionTraits::HashFunctionTraits::*;
   15|       |use crate::Chap47::HashFunctionTraits::HashFunctionTraits::*;
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |
   16|       |        ///
   16|       |        }
   16|       |    ///
   16|       |    }
   16|       |    }
   16|       |    }
   16|       |    }
   16|       |    }
   16|       |    }
   16|       |    }
   16|       |    }
   16|       |    }
   16|       |    }
   16|       |    }
   16|       |    }
  250|      1|            FlatHashTable::create_table(strategy.clone(), 16);
   16|     76|    }
   16|       |    #[derive(Clone)]
   16|       |    #[derive(Clone)]
   16|       |    #[derive(Clone)]
   16|       |    #[derive(Clone)]
   16|       |    where
   16|       |    where
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |
   17|       |    ///
   17|       |    ///
   17|       |    ///
   17|       |    {
   17|       |    }
   17|       |    }
   17|       |    }
   17|       |    }
   17|       |    }
   17|       |    }
   17|       |    }
   17|       |    }
   17|       |    }
   17|       |    }
   17|       |    }
   17|       |    }
   17|       |    }
   17|       |    }
   17|       |    }
   17|       |    }
   17|       |    }
   17|       |    }
   17|       |    }
   17|       |    }
   17|       |    }
   17|       |    }
   17|       |    }
   17|       |    }
   17|       |    }
  345|      1|            FlatHashTable::create_table(strategy.clone(), 17);
  369|      1|            FlatHashTable::create_table(strategy_prime.clone(), 17);
   17|     57|    }
   17|       |    #[derive(Clone)]
   17|       |    #[derive(Clone)]
   17|       |    #[derive(Clone)]
   17|       |    #[derive(Debug)]
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |
   18|       |    
   18|       |        
   18|       |        ]
   18|       |        },
   18|       |    ///
   18|       |    ///
   18|       |    ///
   18|       |    {
   18|       |    {
   18|       |    {
   18|       |    {
   18|       |    }
   18|       |    }
   18|       |    }
   18|       |    }
   18|       |    }
   18|       |    }
   18|       |    }
   18|       |    }
   18|       |    }
   18|       |    }
   18|       |    }
   18|       |    }
   18|       |    }
   18|       |    }
   18|       |    }
   18|       |    }
   18|       |    }
   18|       |    }
    2|       |//! Chapter 18 algorithms for `ArraySeqMtEph<T>` (ephemeral, MT).
    2|       |//! Chapter 18 algorithms for ArraySeqMtPer multithreaded.
    2|       |//! Chapter 18 algorithms for LinkedListStEph (ephemeral).
    2|       |//! Chapter 18 algorithms for LinkedListStPer.
    2|       |//! Chapter 18 persistent sequence implementation for array-backed sequences.
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |
   19|       |    
   19|       |    
   19|       |        
   19|       |        ///
   19|       |        }
   19|       |    ///
   19|       |    }
   19|       |    }
   19|       |    }
   19|       |    }
   19|       |    }
   19|       |    }
   19|       |    }
   19|       |    }
   19|       |    }
   19|       |    }
   19|       |    }
   19|       |    }
   19|       |    }
   19|       |    }
   19|       |//!
   19|       |//!
   19|      1|                    return;
   19|     23|    }
   19|     23|                hash1,
    2|       |//! Chapter 19 algorithms for `ArraySeqMtEph<T>` (ephemeral, MT).
    2|       |//! Chapter 19 algorithms for ArraySeqMtPer, just the one multi-threaded update of code that Umut and Guy snuck into this chapter.
    2|       |//! Chapter 19 algorithms for `ArraySeqStEph<T>`.
    2|       |//! Chapter 19 algorithms for ArraySeqStPer.
   19|       |        Deleted,
   19|       |    #[derive(Clone)]
   19|       |    #[derive(Debug)]
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |
   20|       |        }
   20|       |        }
   20|       |    ///
   20|       |    }
   20|       |    }
   20|       |    }
   20|       |    }
   20|       |    }
   20|       |    }
   20|       |    }
   20|       |    }
   20|       |    }
   20|       |    }
   20|       |    }
   20|       |    }
   20|       |    }
   20|       |    }
   20|       |    }
   20|       |    }
   20|       |    }
   20|       |    }
   20|      1|                    return;
   20|      2|                }
   20|     23|                hash2,
   20|     38|            }
   20|     42|    }
   54|     23|                max_probes: 20,
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |
   21|       |            }
   21|       |    }
   21|       |    }
   21|       |    }
   21|       |    }
   21|       |    }
   21|       |    }
   21|       |    }
   21|       |    }
   21|     18|                c1,
   21|      2|                }
    2|       |//! Chapter 21 — Algorithm 21.1: 2D Points using ArraySeqPer via tabulate + flatten.
    2|       |//! Chapter 21 — Algorithm 21.2: 3D Points using ArraySeqPer via flatten of nested tabulates.
    2|       |//! Chapter 21 — Algorithm 21.5: Brute Force Solution to the Primes Problem.
    2|       |//! Chapter 21 — Algorithm 21.6: Prime Sieve using ArraySeqPer and ninject.
    2|       |//! Chapter 21 — Exercise 21.5: All contiguous subsequences.
    2|       |//! Chapter 21 — Exercise 21.7: Comprehension with Conditionals - even elements paired with vowels.
    2|       |//! Chapter 21 — Exercise 21.8: Brute Force Primality Test (isPrime).
    2|       |//! Chapter 21 — Problem 21.1: Points in 2D using imperative loops.
    2|       |//! Chapter 21 — Problem 21.3: Points in 3D using imperative triple loop.
    2|       |//! Chapter 21 — Problem 21.4: Cartesian Product using different approaches.
   21|     32|    }
   21|     38|        }
   21|     42|    }
   21|       |        where
   22|       |
   22|       |
   22|       |
   22|       |
   22|       |
   22|       |
   22|       |
   22|       |
   22|       |
   22|       |
   22|       |
   22|       |
   22|       |
   22|       |
   22|       |
   22|       |
   22|       |
   22|       |
   22|       |
   22|       |
   22|       |
   22|       |
   22|       |
   22|       |        
   22|       |            }
   22|       |    }
   22|       |    }
   22|       |    }
   22|       |    }
   22|       |    }
   22|       |    }
   22|       |    }
   22|       |    }
   22|       |    }
   22|       |    }
   22|     18|                c2,
   22|     23|            }
   22|   238k|            }
   22|     23|                .iter()
   22|  4.88k|            }
   22|     65|                .iter()
   22|     82|            }
   22|     83|            }
   22|     98|            }
   22|       |        where
   23|       |
   23|       |
   23|       |
   23|       |
   23|       |
   23|       |
   23|       |
   23|       |
   23|       |
   23|       |
   23|       |
   23|       |
   23|       |
   23|       |
   23|       |
   23|       |
   23|       |
   23|       |
   23|       |
   23|       |
   23|       |
   23|       |
   23|       |
   23|       |
   23|       |
   23|       |        
   23|       |        }
   23|       |    ///
   23|       |    {
   23|       |    }
   23|       |    }
   23|       |    }
   23|       |    }
   23|       |    }
   23|       |    }
   23|       |    }
   23|       |    }
   23|       |    }
   23|       |    }
   23|       |    }
   23|     21|            }
   23|     23|        }
   23|    234|                key,
   23|   238k|        }
   23|     29|            }
   23|      3|                ArraySeqStPerS<ArraySeqStPerS<T>>,
   23|  4.88k|        }
   23|      8|        }
   23|       |        where
   23|       |        where
   24|       |
   24|       |
   24|       |
   24|       |
   24|       |
   24|       |
   24|       |
   24|       |
   24|       |
   24|       |
   24|       |
   24|       |
   24|       |
   24|       |
   24|       |
   24|       |
   24|       |
   24|       |
   24|       |
   24|       |
   24|       |
   24|       |
   24|       |
   24|       |
   24|       |
   24|       |
   24|       |
   24|       |
   24|       |
   24|       |
   24|       |            
   24|       |            }
   24|       |    ///
   24|       |    }
   24|       |    }
   24|       |    }
   24|       |    }
   24|       |    }
   24|       |    }
   24|       |    }
   24|       |    }
   24|       |    }
   24|       |    }
   24|       |    }
   24|       |    }
   24|       |    }
   24|       |    }
   24|       |    }
   24|       |    }
   24|       |    }
   24|       |    }
   24|       |//! );
   24|       |//! );
   24|      0|                }
   24|      0|        }
   24|  1.07k|                key,
   24|    113|            }
   24|    117|                key,
   24|     13|        }
   24|     18|            }
   24|    204|                key,
   24|     20|        DocumentIndex::make_index(&tweets)
   24|     23|                .collect::<Vec<_>>();
   24|     25|            }
   24|     32|    }
   24|    326|                key,
   24|      3|            >>::tabulate(
   24|      5|        }
   24|      5|        }
   24|      5|        }
   24|     65|                .collect::<Vec<_>>();
   24|      8|        }
   24|     86|            }
   24|       |        where
   24|       |        where
   24|       |        where
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |
   25|       |    ///
   25|       |    ///
   25|       |    }
   25|       |    }
   25|       |    }
   25|       |    }
   25|       |    }
   25|       |    }
   25|       |    }
   25|       |    }
   25|       |//!
   25|       |//!
   25|      0|        }
   25|      1|                }
   25|  1.07k|                priority,
   25|    113|        }
   25|    117|                value,
   25|     18|        }
   25|     20|    }
   25|     25|        }
   25|      3|        }
   25|    326|                priority,
   25|      4|        }
   25|    494|                key,
   25|    608|                key,
   25|    624|                key,
   25|     72|            }
   25|     72|            }
   25|     83|            }
   25|       |        where
   25|       |        where
   25|       |        where
   26|       |
   26|       |
   26|       |
   26|       |
   26|       |
   26|       |
   26|       |
   26|       |
   26|       |
   26|       |
   26|       |
   26|       |
   26|       |
   26|       |
   26|       |
   26|       |
   26|       |
   26|       |
   26|       |
   26|       |
   26|       |
   26|       |
   26|       |
   26|       |
   26|       |
   26|       |
   26|       |
   26|       |
   26|       |
   26|       |
   26|       |        
   26|       |    }
   26|       |    }
   26|       |    }
   26|       |    }
   26|       |    }
   26|       |    }
   26|       |    }
   26|       |    }
   26|       |    }
   26|       |    }
   26|       |    }
   26|       |    }
   26|       |    }
   26|       |    }
   26|       |    }
   26|  1.02k|                key,
   26|    117|                priority,
   26|     13|                .iter()
   26|     16|                .iter()
   26|  1.76k|                key,
   26|      1|        where
   26|     22|            }
   26|      3|        }
   26|      5|            }
   26|      7|    }
   26|      7|                .iter()
   26|      7|                .iter()
   26|       |        where
   26|       |        where
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |
   27|       |        
   27|       |    ///
   27|       |    ///
   27|       |    ///
   27|       |    }
   27|       |    }
   27|       |    }
   27|       |    }
   27|       |    }
   27|       |    }
   27|       |    }
   27|      0|            guard.len()
   27|  1.02k|                priority,
   27|  1.58k|                key,
   27|     16|        }
   27|  20.5M|                value,
   27|    234|            }
   27|    259|            }
   27|     71|            }
   27|      7|            "artie".to_string(),
   27|       |    where
   28|       |
   28|       |
   28|       |
   28|       |
   28|       |
   28|       |
   28|       |
   28|       |
   28|       |
   28|       |
   28|       |
   28|       |
   28|       |
   28|       |
   28|       |
   28|       |
   28|       |
   28|       |
   28|       |
   28|       |
   28|       |
   28|       |
   28|       |
   28|       |
   28|       |
   28|       |
   28|       |
   28|       |
   28|       |
   28|       |            
   28|       |                }
   28|       |        {
   28|       |    ///
   28|       |    ///
   28|       |    }
   28|       |    }
   28|       |    }
   28|       |    }
   28|       |    }
   28|      0|        }
   28|  1.20k|            n
   28|     13|                .collect::<Vec<_>>();
   28|     15|            }
   28|     16|                .collect::<Vec<_>>();
   28|    199|                key,
   28|    222|                edge_set.insert(edge);
   28|    234|        }
   28|     49|        where
   28|      5|        }
   28|      5|        }
   28|     59|                edge_set.insert(edge);
   28|      7|            "burt".to_string(),
   28|      7|                .collect::<Vec<_>>();
   28|      7|                .collect::<Vec<_>>();
   28|       |    #[derive(Clone)]
   29|       |
   29|       |
   29|       |
   29|       |
   29|       |
   29|       |
   29|       |
   29|       |
   29|       |
   29|       |
   29|       |
   29|       |
   29|       |
   29|       |
   29|       |
   29|       |
   29|       |
   29|       |
   29|       |
   29|       |
   29|       |
   29|       |
   29|       |
   29|       |
   29|       |
   29|       |
   29|       |                    )
   29|       |            }
   29|       |    ///
   29|       |    ///
   29|       |    }
   29|       |    }
   29|       |    }
   29|       |    }
   29|       |    }
   29|       |    }
   29|  1.07k|            }
   29|    117|            }
   29|     13|                },
   29|     13|                f,
   29|    199|                value,
   29|      2|                }
   29|     20|            }
   29|    204|            }
   29|    222|            }
   29|      3|                }
   29|      3|                }
   29|      3|                }
   29|     31|            }
   29|    326|            }
   29|      3|        filtered
   29|    494|            }
   29|  49.9M|                }
   29|      5|            }
   29|      5|        }
   29|      5|        }
   29|     59|            }
   29|      5|        result
   29|    624|            }
   29|      7|            "finn".to_string(),
   29|    875|        }
   30|       |
   30|       |
   30|       |
   30|       |
   30|       |
   30|       |
   30|       |
   30|       |
   30|       |
   30|       |
   30|       |
   30|       |
   30|       |
   30|       |
   30|       |
   30|       |
   30|       |
   30|       |
   30|       |
   30|       |
   30|       |
   30|       |
   30|       |
   30|       |
   30|       |
   30|       |        
   30|       |            }
   30|       |            }
   30|       |        {
   30|       |    ///
   30|       |    ///
   30|       |    }
   30|       |    }
   30|       |    }
   30|       |    }
   30|       |    }
   30|       |//! ```
   30|       |//! ```
   30|      0|            }
   30|      1|        }
   30|  1.07k|        }
   30|     10|                values.push(init_value.clone());
   30|  11.3k|            value,
   30|    117|        }
   30|  1.23M|            value,
   30|     16|        }
   30|    174|                key,
   30|    199|                priority,
   30|      2|                }
   30|    204|        }
   30|     28|                }
   30|    326|        }
   30|    494|        }
   30|      4|        >>::tabulate(
   30|      5|                }
   30|      5|                },
   30|      5|            }
   30|      5|    }
   30|      5|                n,
   30|      6|    }
   30|    608|            }
   30|    624|        }
   30|      7|            "mike".to_string(),
   30|  8.00k|        }
   30|       |    where
   30|       |    where
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |
   31|       |            );
   31|       |            }
   31|       |            }
   31|       |        }
   31|       |        }
   31|       |        }
   31|       |    ///
   31|       |    ///
   31|       |    ///
   31|       |    ///
   31|       |    ///
   31|       |    ///
   31|       |    }
   31|       |    }
   31|       |    }
   31|       |    }
   31|       |    }
   31|       |    }
   31|       |    }
   31|       |    }
   31|       |    }
   31|       |    }
   31|       |    }
   31|       |    }
   31|       |    }
   31|       |}
   31|      0|        }
   31|     10|            }
   31|  1.02k|            }
   31|     13|            }
   31|  1.58k|            }
   31|  1.76k|            }
   31|      2|            None
   31|      3|                n,
   31|      5|            }
   31|    608|        }
   31|      7|            }
   31|      7|            "rachel".to_string(),
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |
   32|       |            );
   32|       |        ]);
   32|       |        }
   32|       |        }
   32|       |        }
   32|       |    ///
   32|       |    ///
   32|       |    {
   32|       |    {
   32|       |    {
   32|       |    }
   32|       |    }
   32|       |    }
   32|       |    }
   32|       |    }
   32|      0|                }
   32|      0|        ArraySeqStPerS::from_vec(v)
   32|  1.02k|        }
   32|     13|        }
   32|     13|                edge_set.insert(edge);
   32|     13|                edge_set.insert(edge);
   32|  1.58k|        }
   32|  1.76k|        }
   32|    199|                reduced_value,
   32|     23|        }
   32|  24.9k|                key,
   32|     26|                edge_set.insert(edge);
   32|      2|                buckets,
   32|      2|            None
   32|     31|            }
   32|     32|                edge_set.insert(edge);
   32|     36|            ArraySeqMtPerS::from_vec(values)
   32|     39|                value,
   32|     49|        }
   32|      4|        false
   32|      5|    }
   32|     65|        }
   32|      7|        }
   32|      7|        }
   32|      7|            "sam".to_string(),
   32|       |        where
   32|       |        where
   33|       |
   33|       |
   33|       |
   33|       |
   33|       |
   33|       |
   33|       |
   33|       |
   33|       |
   33|       |
   33|       |
   33|       |
   33|       |
   33|       |
   33|       |
   33|       |
   33|       |
   33|       |
   33|       |
   33|       |
   33|       |
   33|       |
   33|       |
   33|       |
   33|       |
   33|       |
   33|       |
   33|       |
   33|       |
   33|       |            
   33|       |            }
   33|       |    ///
   33|       |    ///
   33|       |    ///
   33|       |    ///
   33|       |    ///
   33|       |    }
   33|       |    }
   33|       |    }
   33|       |    }
   33|       |    }
   33|       |    }
   33|       |    }
   33|       |    }
   33|      0|    }
   33|      1|    }
   33|  11.3k|            left,
   33|  1.23M|            left,
   33|     13|            }
   33|     13|            }
   33|     13|                f,
   33|     16|        }
   33|  20.5M|                index,
   33|  2.38k|    }
   33|     26|            }
   33|     32|            }
   33|     36|        }
   33|     47|        }
   33|     47|        }
   33|      4|        false
   33|      5|    }
   33|      5|        Some(AVLTreeSeqStEphS::from_vec(result))
   33|      7|        }
   33|      7|    }
   33|      7|            "tina".to_string()
   33|       |        where
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |
   34|       |        
   34|       |            }
   34|       |        ];
   34|       |        }
   34|       |    ///
   34|       |    ///
   34|       |    ///
   34|       |    ///
   34|       |    }
   34|       |    }
   34|       |    }
   34|       |    }
   34|       |    }
   34|       |    }
   34|       |    }
   34|       |    }
   34|       |    }
   34|       |    }
   34|       |    }
   34|       |    }
   34|       |}
   34|       |}
   34|       |}
   34|       |}
   34|      0|                }
   34|      1|                }
   34|   100k|            Self::from_vec(slice)
   34|  11.3k|            right,
   34|  1.23M|            right,
   34|    137|            }
   34|  20.5M|            }
   34|     26|                all_prefixes_vec.push(running_sum);
   34|      4|            }
   34|      5|                    }
   34|     54|                },
   34|      5|        queue.push_back(source);
   34|      5|        queue.push_back(source);
   34|      7|    }
   34|      7|    }
   34|      9|            }
   34|       |        where
   34|       |        where
   35|       |
   35|       |
   35|       |
   35|       |
   35|       |
   35|       |
   35|       |
   35|       |
   35|       |
   35|       |
   35|       |
   35|       |
   35|       |
   35|       |
   35|       |
   35|       |
   35|       |
   35|       |
   35|       |
   35|       |
   35|       |
   35|       |
   35|       |
   35|       |
   35|       |
   35|       |
   35|       |
   35|       |
   35|       |
   35|       |
   35|       |            }
   35|       |            }
   35|       |    ///
   35|       |    ///
   35|       |    }
   35|       |    }
   35|       |    }
   35|       |    }
   35|      0|        ArraySeqStPerS::from_vec(v)
   35|   100k|        }
   35|  11.3k|        })
   35|  1.23M|        })
   35|     12|                    vec.push(component);
   35|     13|            }
   35|     13|        }
   35|    174|            }
   35|    199|            }
   35|      2|            }
   35|      2|        }
   35|  20.5M|        }
   35|     21|            }
   35|     24|        }
   35|     26|            }
   35|     29|            }
   35|     30|            }
   35|      4|        }
   35|      5|        current_layer.push_back(source);
   35|      5|        current_layer.push_back(source);
   35|      7|                f,
   35|      7|                    >>::tabulate(
   35|      8|            }
   35|      9|        }
   35|       |        where
   35|       |        where
   35|       |        where
   35|       |        where
   35|       |        where
   35|       |        where
   35|       |        where
   36|       |
   36|       |
   36|       |
   36|       |
   36|       |
   36|       |
   36|       |
   36|       |
   36|       |
   36|       |
   36|       |
   36|       |
   36|       |
   36|       |
   36|       |
   36|       |
   36|       |
   36|       |
   36|       |
   36|       |
   36|       |
   36|       |
   36|       |
   36|       |
   36|       |
   36|       |
   36|       |
   36|       |
   36|       |                }
   36|       |            );
   36|       |        ]);
   36|       |    ///
   36|       |    ///
   36|       |    ///
   36|       |    ///
   36|       |    ///
   36|       |    }
   36|       |    }
   36|       |    }
   36|       |    }
   36|       |    }
   36|       |    }
   36|       |    }
   36|       |    }
   36|       |    }
   36|       |    }
   36|       |    }
   36|       |    }
   36|       |    }
   36|       |    }
   36|      0|    }
   36|  1.02k|                },
   36|  11.3k|    }
   36|  1.23M|    }
   36|     13|        }
   36|     13|        }
   36|     16|        }
   36|    174|        }
   36|    199|        }
   36|      2|        }
   36|    285|            Probability(value)
    2|       |//! Chapter 36 (Multi-threaded): Quicksort with three pivot strategies over `ArraySeqMtEph`.
    2|       |//! Chapter 36 (Multi-threaded Slice): Quicksort over `ArraySeqMtEphSlice` without extra copies.
    2|       |//! Chapter 36 (Single-threaded): Quicksort with three pivot strategies over `ArraySeqStEph`.
   36|      2|                self.remove(pos);
   36|      3|        }
   36|     30|        }
   36|    390|        }
   36|      3|        mid
   36|      4|            }
   36|      7|        }
   36|      7|        }
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |
   37|       |    ///
   37|       |    ///
   37|       |    ///
   37|       |    ///
   37|       |    ///
   37|       |    ///
   37|       |    ///
   37|       |    ///
   37|       |    ///
   37|       |    }
   37|       |    }
   37|       |    }
   37|       |    }
   37|       |    }
   37|       |    }
   37|       |    }
   37|       |}
   37|      0|                    true
   37|    107|            }
   37|     12|                }
   37|     22|                half,
   37|     24|        }
   37|  24.9k|            }
   37|     26|                all_prefixes_vec.push(running_sum);
   37|    285|        }
   37|      2|        assert!(filtered.find(&4));
   37|      2|                true
   37|      3|    }
   37|      6|                        vec.push(components.nth(i).clone());
   37|      7|            }
   37|      7|            }
   37|    966|        }
   38|       |
   38|       |
   38|       |
   38|       |
   38|       |
   38|       |
   38|       |
   38|       |
   38|       |
   38|       |
   38|       |
   38|       |
   38|       |
   38|       |
   38|       |
   38|       |
   38|       |
   38|       |
   38|       |
   38|       |        
   38|       |                }
   38|       |            );
   38|       |        ///
   38|       |        }
   38|       |    ///
   38|       |    {
   38|       |    }
   38|       |    }
   38|       |    }
   38|       |    }
   38|       |    }
   38|       |    }
   38|       |    }
   38|       |    }
   38|       |    }
   38|       |    }
   38|       |}
   38|      1|        }
   38|      1|                    return;
   38|     22|            }
   38|  24.9k|        }
   38|     26|            }
   38|      2|        assert!(filtered.find(&2));
   38|     30|            ArraySeqStPerS::tabulate(
   38|     39|                index,
   38|      6|                    }
   38|     66|            }
   38|  6.96k|        }
   38|      7|        }
   38|      8|            }
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |
   39|       |            }
   39|       |        ///
   39|       |        }
   39|       |    ///
   39|       |    ///
   39|       |    }
   39|       |    }
   39|       |    }
   39|       |    }
   39|       |    }
   39|       |    }
   39|       |    }
   39|       |    }
   39|       |    }
   39|       |    }
   39|       |    }
   39|       |    }
   39|      0|            }
   39|      0|                false
   39|    101|                }
   39|  1.03k|                }
   39|    105|                }
   39|     12|                    vec.push(component);
   39|    132|                }
   39|     16|    }
   39|     18|    }
   39|    207|    }
   39|     21|        }
   39|     21|        }
   39|  22.6k|            }
   39|      2|        assert!(filtered.find(&6));
   39|      2|            return;
   39|      2|                xm
   39|    311|            }
   39|     39|            }
   39|      3|            format!(
   39|      5|                }
   39|      5|        Some(AVLTreeSeqStPerS::from_vec(result))
   39|     66|        }
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |
   40|       |                            )
   40|       |            }
   40|       |            }
   40|       |            }
   40|       |            }
   40|       |            }
   40|       |            }
   40|       |        }
   40|       |        }
   40|       |    ///
   40|       |    ///
   40|       |    ///
   40|       |    }
   40|       |    }
   40|       |    }
   40|       |    }
   40|       |    }
   40|       |    }
   40|       |}
   40|     13|        }
   40|     15|            }
   40|      2|        }
   40|  22.6k|        }
   40|      2|        assert!(!filtered.find(&11));
   40|      2|                    break;
   40|     35|                adj_lists.push(empty_list.clone());
   40|     39|        }
   40|  4.08k|            }
   40|      5|            format!(
   40|      7|    }
   40|      7|        components
   40|     87|            }
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |
   41|       |            
   41|       |            }
   41|       |    ///
   41|       |    ///
   41|       |    ///
   41|       |    ///
   41|       |    ///
   41|       |    ///
   41|       |    ///
   41|       |    ///
   41|       |    ///
   41|       |    {
   41|       |    }
   41|       |    }
   41|       |    }
   41|       |    }
   41|       |    }
   41|       |    }
   41|       |    }
   41|      0|                }
   41|      0|                }
   41|      0|        }
   41|      0|        ArraySeqStPerS::from_vec(v)
   41|      0|                x0
   41|      1|    }
   41|    127|                }
   41|     13|                        },
   41|    136|        }
   41|     16|    }
   41|      2|        }
   41|      2|        where
   41|     35|            }
   41|     38|                matrix_rows.push(false_row.clone());
   41|      3|                self.hash1.description(),
   41|  4.08k|        }
   41|     42|            }
   41|      5|                xm
   41|      7|    }
   41|      7|                f,
   41|       |        where
   41|       |        where
   41|       |        where
   41|       |        where
    2|       |//! Example 41.3: Demonstrating set operations from Example 41.1
   42|       |
   42|       |
   42|       |
   42|       |
   42|       |
   42|       |
   42|       |
   42|       |
   42|       |
   42|       |
   42|       |
   42|       |
   42|       |
   42|       |
   42|       |
   42|       |
   42|       |
   42|       |
   42|       |
   42|       |
   42|       |            }
   42|       |            }
   42|       |        }
   42|       |    ///
   42|       |    ///
   42|       |    }
   42|       |    }
   42|       |    }
   42|       |    }
   42|       |    }
   42|       |    }
   42|       |    }
   42|       |    }
   42|       |    }
   42|       |}
   42|      0|    }
   42|    110|            Self::from_vec(self.data[begin..end].iter().cloned().collect())
   42|      2|            "aa".to_string(),
    2|       |//! Chapter 42 Example 42.1 demonstrating table operations.
    2|       |//! Chapter 42 multi-threaded ephemeral table implementation using ArraySeqMtEph as backing store.
    2|       |//! Chapter 42 single-threaded ephemeral table implementation using ArraySeq as backing store.
    2|       |//! Chapter 42 single-threaded persistent table implementation using ArraySeq as backing store.
   42|     35|                adj_lists.push(empty_list.clone());
   42|     38|            }
   42|      3|                self.hash2.description()
   42|    448|            }
   42|      5|                self.base_hash.description(),
   42|      6|                xm
   42|      8|            }
   42|      9|                table.table[index].lookup(key)
   42|       |        where
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |
   43|       |                    );
   43|       |            )
   43|       |            }
   43|       |        {
   43|       |        }
   43|       |        }
   43|       |    ///
   43|       |    }
   43|       |    }
   43|       |    }
   43|       |    }
   43|       |    }
   43|       |    }
   43|       |    }
   43|      0|        }
   43|      0|    }
   43|      0|    }
   43|      0|                x0
   43|      1|        }
   43|      1|    }
   43|    104|                a
   43|    110|        }
   43|     13|        result.insert(vertex);
   43|     16|            }
   43|     16|            }
   43|     16|        }
   43|      1|                xl
   43|     29|                matrix_rows.push(false_row.clone());
   43|      2|            "bb".to_string(),
   43|     31|                min_prefixes_vec.push(running_min);
   43|     35|            }
   43|     38|            self.dist.cmp(&other.dist)
   43|     63|            self.dist.cmp(&other.dist)
   43|      7|            }
   43|       |                self.c1,
    2|       |//! Example 43.1 from the textbook demonstrating ordered set operations.
   44|       |
   44|       |
   44|       |
   44|       |
   44|       |
   44|       |
   44|       |
   44|       |
   44|       |
   44|       |
   44|       |
   44|       |
   44|       |
   44|       |
   44|       |
   44|       |
   44|       |
   44|       |
   44|       |
   44|       |
   44|       |
   44|       |
   44|       |
   44|       |
   44|       |            }
   44|       |    ///
   44|       |    ///
   44|       |    ///
   44|       |    {
   44|       |    }
   44|       |    }
   44|       |    }
   44|       |    }
   44|      0|                None
   44|      0|                x0
   44|     10|            }
   44|     10|        }
   44|   101k|                spin_loop();
   44|     11|    }
   44|     11|                key,
   44|     12|                        queue.push_back(v);
   44|     12|                        queue.push_back(v);
   44|     16|        }
   44|     16|        }
   44|     16|        }
   44|  2.22k|    }
   44|  2.62M|            guard.len()
   44|     29|            }
   44|      2|            "cc".to_string(),
    2|       |//! Chapter 44: Document Indexing and Searching implementation.
    2|       |//! Chapter 44: Example 44.1 - Tweet Document Collection
   44|      3|        }
   44|      3|        }
   44|     31|            }
   44|     38|        }
   44|     63|        }
   44|      7|        }
   44|      7|        components
   44|      7|        println!("]");
   44|      9|            }
   44|       |                self.c2
   45|       |
   45|       |
   45|       |
   45|       |
   45|       |
   45|       |
   45|       |
   45|       |
   45|       |
   45|       |
   45|       |
   45|       |
   45|       |
   45|       |
   45|       |
   45|       |
   45|       |
   45|       |
   45|       |
   45|       |
   45|       |
   45|       |
   45|       |
   45|       |
   45|       |
   45|       |
   45|       |
   45|       |
   45|       |            )
   45|       |            }
   45|       |    ///
   45|       |    ///
   45|       |    ///
   45|       |    ///
   45|       |    ///
   45|       |    }
   45|       |    }
   45|       |    }
   45|       |    }
   45|       |    }
   45|       |    }
   45|       |    }
   45|      1|            }
   45|     10|        }
   45|   101k|            }
   45|     10|                n,
   45|     11|                value,
   45|     12|                    }
   45|     12|                    }
   45|     16|            }
   45|     16|            }
   45|     16|        }
   45|      1|        println!(
   45|      1|                xl
   45|     24|                buckets,
   45|  2.62M|        }
    2|       |//! Chapter 45: Example 45.2 - Heapsort Algorithm Demonstrations
    2|       |//! Chapter 45: Heapsort Example - Algorithm 45.2 using all Priority Queue implementations
    2|       |//! Chapter 45: Priority Queue implementation using Balanced Trees (AVL Tree)
    2|       |//! Chapter 45: Priority Queue implementation using Binary Heap
    2|       |//! Chapter 45: Priority Queue implementation using Leftist Heap (Data Structure 45.3)
    2|       |//! Chapter 45: Priority Queue implementation using Sorted List
    2|       |//! Chapter 45: Priority Queue implementation using Unsorted List
   45|      2|            "dd".to_string(),
   45|      2|                split_off.pop_front();
   45|      3|        }
   45|     30|        }
   45|     34|                priority,
   45|      7|            },
   45|      7|    }
   45|     73|            }
   45|      9|        }
   46|       |
   46|       |
   46|       |
   46|       |
   46|       |
   46|       |
   46|       |
   46|       |
   46|       |
   46|       |
   46|       |
   46|       |
   46|       |
   46|       |
   46|       |
   46|       |
   46|       |
   46|       |
   46|       |
   46|       |
   46|       |
   46|       |
   46|       |
   46|       |
   46|       |
   46|       |
   46|       |
   46|       |
   46|       |
   46|       |
   46|       |            
   46|       |                }
   46|       |                }
   46|       |            }
   46|       |            }
   46|       |        }
   46|       |    ///
   46|       |    ///
   46|       |    ///
   46|       |    ///
   46|       |    }
   46|       |    }
   46|       |    }
   46|       |    }
   46|       |    }
   46|       |    }
   46|       |    }
   46|       |    }
   46|      0|            }
   46|      1|            }
   46|     10|            }
   46|     13|        visited
   46|     16|        }
   46|     16|        }
   46|    240|            self.node_at(index)
   46|      2|            "ee".to_string(),
   46|      2|        >>::tabulate(
   46|      2|                xl
   46|     31|                min_prefixes_vec.push(running_min);
   46|     34|                vertex,
   46|  4.51k|        }
   46|      4|            n,
   46|      5|        }
   46|      9|            }
   46|      9|        }
   47|       |
   47|       |
   47|       |
   47|       |
   47|       |
   47|       |
   47|       |
   47|       |
   47|       |
   47|       |
   47|       |
   47|       |
   47|       |
   47|       |
   47|       |
   47|       |
   47|       |
   47|       |
   47|       |
   47|       |
   47|       |
   47|       |
   47|       |
   47|       |
   47|       |
   47|       |
   47|       |
   47|       |            }
   47|       |        );
   47|       |        ///
   47|       |        }
   47|       |    ///
   47|       |    }
   47|       |    }
   47|       |    }
   47|       |    }
   47|       |    }
   47|       |    }
   47|       |    }
   47|       |}
   47|      0|            }
   47|      0|            }
   47|     10|        }
   47|     11|            });
   47|     15|        }
   47|     15|    }
   47|     16|        }
   47|     17|            }
   47|    192|                    }
   47|    199|        where
   47|      1|            table_per.size(),
   47|      2|        }
    2|       |//! Chapter 47: Advanced Double Hashing Strategy with Dual Hash Functions and Relative Prime Validation
    2|       |//! Chapter 47: Advanced Linear Probing Strategy with Primary Clustering Analysis
    2|       |//! Chapter 47: Advanced Quadratic Probing Strategy with Secondary Clustering Avoidance
    2|       |//! Chapter 47: Clustering Analysis for Hash Table Probing Strategies
    2|       |//! Chapter 47: Double Hashing Strategy
    2|       |//! Chapter 47: Flat Hash Table - Data Structure 47.6 Parametric Implementation
    2|       |//! Chapter 47: Hash Function Traits and Utilities
    2|       |//! Chapter 47: Hash Table Examples from Textbook
    2|       |//! Chapter 47: Linear Probing Strategy
    2|       |//! Chapter 47: Nested Hash Table implementation - Section 1.1 Parametric Design
    2|       |//! Chapter 47: Probe Sequence Examples for Advanced Probing Strategies
    2|       |//! Chapter 47: Quadratic Probing Strategy
    2|       |//! Chapter 47: Separate Chaining implementation - Definition 47.3
   47|      2|            "ff".to_string(),
   47|      2|                true
   47|     31|            }
   47|     34|                parent,
   47|    436|        }
   47|      6|        }
   47|  8.11k|                }
   47|      8|                n,
   47|      9|        }
   47|       |        where
   47|       |        where
   47|       |        where
   47|       |        where
  314|      1|        output.push_str("Example 47.1 - Hash Function:\n");
  322|      1|        output.push_str("Example 47.2 - Separate Chaining:\n");
  328|      1|        output.push_str("Example 47.4 - probe Sequences:\n");
    3|       |//! Definition 47.7: Linear probing with h_i(k) = (h(k) + i) mod m
    3|       |//! Definition 47.8: Quadratic probing with h_i(k) = (h(k) + c1*i + c2*i^2) mod m
    3|       |//! Definition 47.9: Double hashing with h_i(k) = (h1(k) + i * h2(k)) mod m
   48|       |
   48|       |
   48|       |
   48|       |
   48|       |
   48|       |
   48|       |
   48|       |
   48|       |
   48|       |
   48|       |
   48|       |
   48|       |
   48|       |
   48|       |
   48|       |
   48|       |
   48|       |
   48|       |
   48|       |
   48|       |
   48|       |
   48|       |
   48|       |
   48|       |
   48|       |
   48|       |
   48|       |
   48|       |        }
   48|       |        }
   48|       |    ///
   48|       |    ///
   48|       |    }
   48|       |    }
   48|       |    }
   48|       |    }
   48|       |    }
   48|       |}
   48|      0|        AVLTreeSeqStEphS::from_vec(result)
   48|      0|        textbook_example()
   48|     10|            }
   48|  1.22k|                Ok(self)
   48|     14|            }
   48|     14|        }
   48|     15|        }
   48|     17|        }
   48|     19|                    }
   48|      1|            ArraySeqStEphS::from_vec(vec![
   48|      1|            table_per_new.size()
   48|      2|                    }
   48|      2|            }
   48|    234|        where
   48|      2|            "gg".to_string(),
   48|     34|            }
   48|     68|            }
   48|      8|            }
   48|      8|        }
   48|     85|        }
   48|       |        where
   49|       |
   49|       |
   49|       |
   49|       |
   49|       |
   49|       |
   49|       |
   49|       |
   49|       |
   49|       |
   49|       |
   49|       |
   49|       |
   49|       |
   49|       |
   49|       |
   49|       |
   49|       |
   49|       |
   49|       |
   49|       |
   49|       |
   49|       |                    }
   49|       |                    }
   49|       |                }
   49|       |                }
   49|       |                }
   49|       |        );
   49|       |        ///
   49|       |        {
   49|       |    ///
   49|       |    ///
   49|       |    ///
   49|       |    ///
   49|       |    {
   49|       |    {
   49|       |    }
   49|       |    }
   49|       |    }
   49|       |    }
   49|       |    }
   49|       |    }
   49|       |    }
   49|       |    }
   49|       |    }
   49|       |    }
   49|       |    }
   49|      0|    }
   49|      0|    }
   49|      0|                false
   49|     10|        }
   49|     10|        }
   49|     12|        }
   49|     12|                            next_layer.push_back(v);
   49|     12|                            next_layer.push_back(v);
   49|  1.38k|        }
   49|     14|        }
   49|      1|                OrderedFloat(0.0),
   49|      1|            self.nth(idx).clone()
   49|      2|        }
   49|      2|        }
   49|  2.26k|    }
   49|    240|        }
   49|     25|    where
    2|       |//! Chapter 49: Minimum Edit Distance - ephemeral, multi-threaded.
    2|       |//! Chapter 49: Minimum Edit Distance - ephemeral, single-threaded.
    2|       |//! Chapter 49: Minimum Edit Distance - persistent, multi-threaded.
    2|       |//! Chapter 49: Minimum Edit Distance - persistent, single-threaded.
    2|       |//! Chapter 49: Subset Sum - ephemeral, multi-threaded.
    2|       |//! Chapter 49: Subset Sum - ephemeral, single-threaded.
    2|       |//! Chapter 49: Subset Sum - persistent, multi-threaded.
    2|       |//! Chapter 49: Subset Sum - persistent, single-threaded.
   49|      2|            "hh".to_string(),
   49|     34|        }
   49|    372|                    break;
   49|      5|    }
   49|  5.25M|            guard[index].clone()
   49|     57|                }
   49|     74|                continue;
   49|      8|        }
   49|       |        where
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |
   50|       |            }
   50|       |            }
   50|       |            }
   50|       |            }
   50|       |            }
   50|       |        {
   50|       |        }
   50|       |    ///
   50|       |    ///
   50|       |    {
   50|       |    }
   50|       |    }
   50|       |    }
   50|       |    }
   50|       |    }
   50|       |    }
   50|       |}
   50|      0|                }
   50|      0|    }
   50|      0|    }
   50|      1|        }
   50|      1|        }
   50|     12|                        }
   50|     12|                        }
   50|     13|            }
   50|     15|    }
   50|    155|            }
   50|     15|        ancestors.insert(vertex);
   50|      1|                OrderedFloat(2.5),
   50|     20|            }
   50|    228|                },
   50|     23|                .iter()
   50|     24|            }
   50|     24|            }
   50|     29|                hash_fn,
    2|       |//! Chapter 50: Matrix Chain Multiplication - ephemeral, single-threaded.
    2|       |//! Chapter 50: Matrix Chain Multiplication - persistent, single-threaded.
    2|       |//! Chapter 50: Optimal Binary Search Tree - ephemeral, single-threaded.
    2|       |//! Chapter 50: Optimal Binary Search Tree - persistent, single-threaded.
    2|       |//! Chapter 50: Probability wrapper type for OBST algorithms.
   50|      2|            "ii".to_string(),
   50|      4|        }
   50|  48.4k|                }
   50|  5.25M|        }
   50|     56|                .iter()
   50|      5|        distances
   50|      5|        distances
   50|     69|            }
   50|      7|            }
   50|  8.11k|                    .head
   50|       |        where
   51|       |
   51|       |
   51|       |
   51|       |
   51|       |
   51|       |
   51|       |
   51|       |
   51|       |
   51|       |
   51|       |
   51|       |
   51|       |
   51|       |
   51|       |
   51|       |
   51|       |
   51|       |
   51|       |
   51|       |
   51|       |
   51|       |
   51|       |
   51|       |
   51|       |
   51|       |
   51|       |
   51|       |
   51|       |            
   51|       |                    }
   51|       |                    }
   51|       |            }
   51|       |            }
   51|       |    ///
   51|       |    ///
   51|       |    }
   51|       |    }
   51|       |    }
   51|       |    }
   51|       |}
   51|      0|            None
   51|      0|            None
   51|      1|        }
   51|  1.02k|                },
   51|  1.09k|                vec_elements.push(self.elements.nth(i).clone());
   51|    115|                                }
   51|    117|            }
   51|    137|                                }
   51|    157|                                }
   51|      1|                OrderedFloat(5.0),
   51|      2|            }
   51|      2|        }
   51|     21|            max_contig_sub_sum_aux_mt(&right_clone)
   51|     24|        }
   51|     24|        }
   51|     29|                initial_size,
   51|      2|            "jj".to_string(),
   51|      3|                    filtered_b.length(),
   51|     48|            }
   51|      4|            self.nth_cloned(idx)
   51|      7|            }
   51|      7|        }
   51|      7|    }
   51|      7|    }
   51|      8|            }
   51|       |        where
   51|       |        Zero,
   52|       |
   52|       |
   52|       |
   52|       |
   52|       |
   52|       |
   52|       |
   52|       |
   52|       |
   52|       |
   52|       |
   52|       |
   52|       |
   52|       |
   52|       |
   52|       |
   52|       |
   52|       |
   52|       |
   52|       |
   52|       |
   52|       |
   52|       |
   52|       |
   52|       |
   52|       |
   52|       |
   52|       |                )
   52|       |            );
   52|       |            {
   52|       |        ];
   52|       |        }
   52|       |    ///
   52|       |    ///
   52|       |    ///
   52|       |    }
   52|       |    }
   52|       |    }
   52|       |    }
   52|       |    }
   52|       |}
   52|       |}
   52|      0|                }
   52|      0|                }
   52|      0|        }
   52|  1.09k|            }
   52|    117|        }
   52|    121|                            }
   52|  1.22k|        }
   52|     13|            }
   52|     16|            }
   52|    179|        where
   52|     19|        }
   52|      1|            edges
   52|      1|                OrderedFloat(f64::INFINITY),
   52|     21|        });
   52|     22|                half,
   52|    239|            }
   52|     23|                .collect::<Vec<_>>();
   52|    259|            step
   52|      2|        assert!(union_result.find(&2));
    2|       |//! Chapter 52: Adjacency Matrix Graph (ephemeral, single-threaded).
    2|       |//! Chapter 52: Adjacency Matrix Graph (persistent, single-threaded).
    2|       |//! Chapter 52: Adjacency Sequence Graph (ephemeral, single-threaded).
    2|       |//! Chapter 52: Adjacency Sequence Graph (persistent, single-threaded).
    2|       |//! Chapter 52: Adjacency Table Graph representation (ephemeral, single-threaded).
    2|       |//! Chapter 52: Adjacency Table Graph representation (persistent, multi-threaded with TRUE parallelism).
    2|       |//! Chapter 52: Adjacency Table Graph representation (persistent, single-threaded).
    2|       |//! Chapter 52: Edge Set Graph representation (ephemeral, single-threaded).
    2|       |//! Chapter 52: Edge Set Graph representation (persistent, multi-threaded with TRUE parallelism).
    2|       |//! Chapter 52: Edge Set Graph representation (persistent, single-threaded).
   52|      3|        }
   52|      4|        }
   52|      4|            edges
   52|      4|            global_max
   52|     56|                .collect::<Vec<_>>();
   52|      7|        }
   52|  8.11k|                    .is_ok()
   52|    885|            ArraySeqMtPerS::from_vec(values)
   52|      8|            max_sum
   52|       |        One(T),
   52|       |        where
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |
   53|       |                {
   53|       |            );
   53|       |            ]),
   53|       |            {
   53|       |            }
   53|       |            }
   53|       |    ///
   53|       |    ///
   53|       |    ///
   53|       |    {
   53|       |    }
   53|       |    }
   53|       |    }
   53|       |    }
   53|       |    }
   53|       |    }
   53|      1|            }
   53|      1|        }
   53|     11|            }
   53|    114|                },
   53|  1.25k|                vec_elements.push(self.elements.nth(i).clone());
   53|    183|            }
   53|     19|            }
   53|     19|            self.nth_cloned(idx)
   53|    259|        }
   53|    279|            AVLTreeSeqStPerS::from_vec(vec_elements)
   53|      2|        assert!(union_result.find(&7));
    2|       |//! Chapter 53: Generic Graph Search (ephemeral, single-threaded).
    2|       |//! Chapter 53: Generic Graph Search (persistent, multi-threaded).
    2|       |//! Chapter 53: Generic Graph Search (persistent, single-threaded).
    2|       |//! Chapter 53: Min-Priority Queue Search - ephemeral, multi-threaded.
    2|       |//! Chapter 53: Min-Priority Queue Search - ephemeral, single-threaded.
    2|       |//! Chapter 53: Min-Priority Queue Search - persistent, multi-threaded.
    2|       |//! Chapter 53: Min-Priority Queue Search - persistent, single-threaded.
   53|      3|            },
   53|      3|        }
   53|      3|        }
   53|      3|            table[s_len][t_len]
   53|      3|                table.table[index].delete(key)
   53|      4|        }
   53|      5|        }
   53|    525|        });
   53|     53|            inner.size()
   53|     57|                            }
   53|     62|                            }
   53|     64|                                }
   53|     66|                            }
   53|      6|            table[s_len][t_len]
   53|      7|            }
   53|     85|                result.push(element);
   53|    885|        }
   53|      9|        }
   53|       |        where
   54|       |
   54|       |
   54|       |
   54|       |
   54|       |
   54|       |
   54|       |
   54|       |
   54|       |
   54|       |
   54|       |
   54|       |
   54|       |
   54|       |
   54|       |
   54|       |
   54|       |
   54|       |
   54|       |
   54|       |
   54|       |
   54|       |
   54|       |
   54|       |
   54|       |
   54|       |
   54|       |                        }
   54|       |                        }
   54|       |                        }
   54|       |        {
   54|       |        }
   54|       |        }
   54|       |    ///
   54|       |    ///
   54|       |    }
   54|       |    }
   54|       |    }
   54|       |    }
   54|       |    }
   54|       |    }
   54|      0|            }
   54|      0|        }
   54|      1|        }
   54|      1|        }
   54|  1.25k|            }
   54|     13|        filtered
   54|     15|                half,
   54|     19|        }
   54|      1|            ArraySeqStEphS::from_vec(vec![
   54|     21|            }
   54|     22|        where
   54|    279|        }
   54|     29|    where
   54|      2|        assert!(union_result.find(&8));
   54|      2|            filtered_a.length(),
   54|      2|        test_strings
   54|      3|        }
   54|     53|        }
   54|      5|                n,
   54|      6|        }
   54|      7|        }
   54|      8|        }
   54|     85|            }
   55|       |
   55|       |
   55|       |
   55|       |
   55|       |
   55|       |
   55|       |
   55|       |
   55|       |
   55|       |
   55|       |
   55|       |
   55|       |
   55|       |
   55|       |
   55|       |
   55|       |
   55|       |
   55|       |
   55|       |
   55|       |
   55|       |
   55|       |
   55|       |
   55|       |
   55|       |
   55|       |
   55|       |
   55|       |                };
   55|       |            );
   55|       |            );
   55|       |        );
   55|       |        ///
   55|       |        }
   55|       |    ///
   55|       |    ///
   55|       |    ///
   55|       |    }
   55|       |    }
   55|       |}
   55|       |}
   55|      0|            }
   55|      0|        }
   55|      0|                false
   55|      0|                            left.nth(i).clone()
   55|      0|        reverse_sorted_example()
   55|      1|            }
   55|      1|    }
   55|     11|            }
   55|  1.11k|                key,
   55|     14|                    return;
   55|     16|    }
   55|     18|                    Ok(self)
   55|      1|                OrderedFloat(f64::INFINITY),
   55|      2|        }
   55|      2|        }
   55|      2|    }
   55|     21|        }
   55|    242|        }
   55|    268|            AVLTreeSeqStEphS::from_vec(vec_elements)
   55|      2|        assert!(union_result.find(&9));
   55|      2|            .into_iter()
   55|     51|                            }
   55|      5|                distances,
   55|      7|        AVLTreeSeqStPerS::from_vec(result)
   55|      8|        }
   55|    908|                }
   55|       |        where
   55|       |        where
   55|       |        where
   55|       |        where
   56|       |
   56|       |
   56|       |
   56|       |
   56|       |
   56|       |
   56|       |
   56|       |
   56|       |
   56|       |
   56|       |
   56|       |
   56|       |
   56|       |
   56|       |
   56|       |
   56|       |
   56|       |
   56|       |
   56|       |
   56|       |                        }
   56|       |                }
   56|       |            {
   56|       |            }
   56|       |            }
   56|       |            }
   56|       |        {
   56|       |        }
   56|       |        }
   56|       |        }
   56|       |        };
   56|       |    }
   56|       |    }
   56|       |    }
   56|       |    }
   56|       |}
   56|       |}
   56|      0|        }
   56|      0|    }
   56|      0|        AVLTreeSeqStPerS::from_vec(result)
   56|     10|                }
   56|  1.11k|                priority,
   56|     12|    where
   56|    131|        where
   56|     14|            }
   56|     16|        max_val
   56|    180|                edge_set.insert(edge);
   56|    183|                }
   56|      1|            edges
   56|      1|            edges
   56|      1|                OrderedFloat(0.0),
   56|      1|                return;
   56|    222|        }
   56|     23|            }
   56|    268|        }
   56|     29|            }
   56|      2|        assert!(union_result.find(&11));
   56|      3|        }
   56|      3|            final_table[s_len][t_len]
   56|      4|            final_table[s_len][t_len]
   56|      4|        matching
   56|      5|                }
   56|     59|                edge_set.insert(edge);
   56|      5|                n,
   56|      5|                predecessors,
   56|      7|    }
   56|     77|                    },
   56|      7|                ancestors.delete(&vertex);
   56|      9|            }
   56|     90|                    },
   56|     98|                    },
   56|      9|            self
    3|       |//! Example 56.1 - Path Weight Computation
    3|       |//! Example 56.3 - Negative Weight Cycles
   57|       |
   57|       |
   57|       |
   57|       |
   57|       |
   57|       |
   57|       |
   57|       |
   57|       |
   57|       |
   57|       |
   57|       |
   57|       |
   57|       |
   57|       |
   57|       |
   57|       |
   57|       |
   57|       |                };
   57|       |            );
   57|       |            }
   57|       |        }
   57|       |        }
   57|       |        }
   57|       |    ///
   57|       |    ///
   57|       |    ///
   57|       |    }
   57|       |    }
   57|       |    }
   57|       |    }
   57|       |    }
   57|       |    }
   57|       |    }
   57|       |}
   57|      0|    }
   57|      0|            >>::tabulate(
   57|      1|        }
   57|      1|        }
   57|  10.0k|            }
   57|  1.11k|                size,
   57|    112|            }
   57|     14|        }
   57|     14|        }
   57|     14|        result
   57|     16|    }
   57|     16|                dist_matrix.push(ArraySeqStEphS::from_vec(row));
   57|     16|        max_val
   57|    180|            }
   57|     19|                }
   57|      1|                OrderedFloat(1.5),
   57|      2|    }
   57|     23|                        }
   57|     23|        }
   57|     25|                    left_count,
   57|     28|                    left_count,
   57|     29|        }
   57|      2|        assert!(union_result.find(&14));
   57|      2|            count
   57|      3|        }
   57|      3|        }
   57|      3|        }
   57|     32|                    left_count,
   57|     37|                }
   57|      4|        }
   57|      4|    }
   57|     42|            }
   57|     49|            }
   57|     50|        }
   57|     59|            }
   57|      5|                source,
   57|     68|            }
   57|      7|            }
   57|  7.21k|        }
   57|      7|        AVLTreeSeqStEphS::from_vec(result)
   57|      9|        }
   57|       |        where
   57|       |        where
   57|       |        where
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |
   58|       |                        }
   58|       |                );
   58|       |                );
   58|       |                );
   58|       |            }
   58|       |            }
   58|       |            }
   58|       |            }
   58|       |            }
   58|       |        ///
   58|       |        {
   58|       |    ///
   58|       |    {
   58|       |    }
   58|       |    }
   58|       |    }
   58|       |    }
   58|       |    }
   58|       |    }
   58|       |    }
   58|       |    }
   58|       |    }
   58|       |}
   58|      0|        }
   58|  1.11k|                left,
   58|    112|        }
   58|    114|        where
   58|     14|    }
   58|     16|            }
   58|     16|    }
   58|    161|            }
   58|  1.83k|            }
   58|      1|                OrderedFloat(f64::INFINITY),
   58|      1|                return;
   58|      2|        }
   58|      2|        }
   58|      2|        assert!(union_result.find(&17));
   58|      4|        }
   58|     42|        }
   58|     49|        }
   58|      5|            }
   58|      5|        }
   58|     58|                    },
   58|      5|                distances,
   58|      5|                distances,
   58|      5|            max_sum
   58|      6|            }
   58|     60|            inner.to_seq()
   58|     61|                distances,
   58|     68|        }
   58|      7|    }
   58|       |        where
   58|       |        where
   58|       |        where
   59|       |
   59|       |
   59|       |
   59|       |
   59|       |
   59|       |
   59|       |
   59|       |
   59|       |
   59|       |
   59|       |
   59|       |
   59|       |
   59|       |
   59|       |
   59|       |
   59|       |
   59|       |
   59|       |
   59|       |
   59|       |
   59|       |
   59|       |
   59|       |
   59|       |
   59|       |
   59|       |
   59|       |                    }
   59|       |                }
   59|       |            ]),
   59|       |            }
   59|       |        }
   59|       |    ///
   59|       |    ///
   59|       |    ///
   59|       |    {
   59|       |    {
   59|       |    }
   59|       |    }
   59|       |}
   59|      0|                    },
   59|      0|            }
   59|      1|            }
   59|      1|        }
   59|     10|    }
   59|     11|    }
   59|  1.11k|                right,
   59|     12|            Set::FromVec(pairs)
   59|    161|        }
   59|     16|                dist_matrix.push(ArraySeqStEphS::from_vec(row));
   59|     19|        }
   59|      1|            self.lock();
   59|     20|            })
   59|     24|                    left_count,
   59|     25|                left.select(k)
   59|     26|            }
   59|  2.75k|            }
   59|     28|                left.select(k)
    2|       |//! Chapter 59: Johnson's Algorithm - Multi-threaded Ephemeral Float Weights
    2|       |//! Chapter 59: Johnson's Algorithm - Multi-threaded Ephemeral Integer Weights
    2|       |//! Chapter 59: Johnson's Algorithm - Single-threaded Ephemeral Float Weights
    2|       |//! Chapter 59: Johnson's Algorithm - Single-threaded Ephemeral Integer Weights
   59|      2|            None
   59|     32|                left.select(k)
   59|     42|            true
   59|      5|        }
   59|      5|        distances
   59|      5|        distances
   59|      5|                predecessors,
   59|      5|                predecessors,
   59|      6|            }
   59|      6|        }
   59|     60|        }
   59|     61|                predecessors,
   59|     68|        }
   59|      7|        }
   59|     74|            distances.insert(
   59|     87|            }
   59|      8|            count
   59|       |        where
   60|       |
   60|       |
   60|       |
   60|       |
   60|       |
   60|       |
   60|       |
   60|       |
   60|       |
   60|       |
   60|       |
   60|       |
   60|       |
   60|       |
   60|       |
   60|       |
   60|       |
   60|       |
   60|       |
   60|       |
   60|       |
   60|       |
   60|       |
   60|       |
   60|       |
   60|       |
   60|       |
   60|       |
   60|       |
   60|       |
   60|       |                );
   60|       |            }
   60|       |        ///
   60|       |        {
   60|       |        };
   60|       |    ///
   60|       |    ///
   60|       |    {
   60|       |    }
   60|       |    }
   60|       |    }
   60|       |    }
   60|       |    }
   60|       |    }
   60|       |    }
   60|       |    }
   60|       |    }
   60|      0|                }
   60|      0|            }
   60|      0|            }
   60|      0|                    total,
   60|     10|        }
   60|    111|                }
   60|  1.11k|            })))),
   60|     12|        }
   60|     15|            }
   60|     15|        }
   60|     16|            }
   60|     17|        }
   60|      1|            ArraySeqStEphS::from_vec(vec![
   60|      1|            edges
   60|      1|            edges
   60|     23|        }
   60|  2.75k|        }
   60|      2|            .collect()
   60|      3|            }
   60|     45|            }
   60|     56|        }
   60|      5|                distances,
   60|      5|            max_sum
   60|      5|                n,
   60|      5|                source,
   60|      6|            }
   60|      6|        }
   60|     61|                source,
   60|      6|    where
   60|      7|    }
   60|      7|    }
   60|     71|                distances,
   60|     74|                v,
   60|     76|        }
   60|      8|        }
   60|      9|            }
   60|       |        where
   61|       |
   61|       |
   61|       |
   61|       |
   61|       |
   61|       |
   61|       |
   61|       |
   61|       |
   61|       |
   61|       |
   61|       |
   61|       |
   61|       |
   61|       |
   61|       |
   61|       |
   61|       |
   61|       |
   61|       |
   61|       |
   61|       |
   61|       |
   61|       |
   61|       |
   61|       |
   61|       |
   61|       |
   61|       |                );
   61|       |            {
   61|       |            {
   61|       |            }
   61|       |            }
   61|       |            }
   61|       |    {
   61|       |    {
   61|       |    }
   61|       |    }
   61|       |    }
   61|       |    }
   61|       |    }
   61|       |    }
   61|       |    }
   61|       |}
   61|       |}
   61|       |}
   61|      1|        }
   61|      1|        }
   61|      1|        }
   61|     10|                main_result
   61|  1.11k|        }
   61|  11.3k|            }
   61|    126|                table,
   61|     15|        }
   61|    168|            }
   61|     19|            }
   61|     19|        }
   61|      1|                OrderedFloat(f64::INFINITY),
   61|      1|            self.unlock();
   61|      2|    }
   61|     21|                Some(pivot)
   61|     24|                left.select(k)
   61|     25|                Some(pivot)
   61|     26|                Some(pivot)
    2|       |//! Chapter 61: Edge Contraction - Multi-threaded Ephemeral Implementation
    2|       |//! Chapter 61: Edge Contraction - Sequential Ephemeral Implementation
    2|       |//! Chapter 61: Vertex Matching - Multi-threaded Ephemeral Implementation
    2|       |//! Chapter 61: Vertex Matching - Sequential Ephemeral Implementation
   61|      2|            count
   61|      3|        }
   61|     45|        }
   61|      5|            }
   61|      5|            }
   61|      5|                predecessors,
   61|      6|        }
   61|     61|            }
   61|     71|                predecessors,
   61|     76|            Ok(self)
   61|      8|        ancestors.delete(&vertex);
   61|     91|            }
   62|       |
   62|       |
   62|       |
   62|       |
   62|       |
   62|       |
   62|       |
   62|       |
   62|       |
   62|       |
   62|       |
   62|       |
   62|       |
   62|       |
   62|       |
   62|       |
   62|       |
   62|       |
   62|       |
   62|       |
   62|       |
   62|       |
   62|       |
   62|       |
   62|       |
   62|       |
   62|       |
   62|       |
   62|       |
   62|       |
   62|       |            {
   62|       |            }
   62|       |        }
   62|       |        }
   62|       |    ///
   62|       |    ///
   62|       |    }
   62|       |    }
   62|       |    }
   62|       |    }
   62|       |    }
   62|       |    }
   62|      0|        already_sorted_example()
   62|      0|                        b.length(),
   62|  1.11k|    }
   62|  11.3k|        }
   62|     12|    }
   62|    131|            }
   62|      1|                OrderedFloat(f64::INFINITY),
   62|      1|            result
   62|      2|        }
   62|     20|                    OrderedF64::from(0.0)
   62|     22|        }
   62|    222|        }
    2|       |//! Chapter 62: Star Contraction - Multi-threaded Ephemeral Implementation
    2|       |//! Chapter 62: Star Contraction - Sequential Ephemeral Implementation
    2|       |//! Chapter 62: Star Partition - Multi-threaded Ephemeral Implementation
    2|       |//! Chapter 62: Star Partition - Sequential Ephemeral Implementation
   62|    353|                    return;
   62|     37|        }
   62|      5|        }
   62|      5|        }
   62|     56|            }
   62|      5|                n,
   62|      6|        }
   62|      6|        }
   62|     61|        }
   62|     71|                source,
   62|     76|        }
   62|      8|        false
   62|     91|        }
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |
   63|       |                    )
   63|       |                    };
   63|       |        ///
   63|       |    ///
   63|       |    {
   63|       |    }
   63|       |    }
   63|       |    }
   63|       |    }
   63|       |    }
   63|       |    }
   63|       |    }
   63|       |    }
   63|       |    }
   63|       |}
   63|      0|    }
   63|      1|        }
   63|     12|    where
   63|     16|        }
   63|     19|    }
   63|      1|                OrderedFloat(0.0),
   63|     21|                Some(pivot)
   63|     22|        }
   63|     26|            }
    2|       |//! Chapter 63: Graph Connectivity - Multi-threaded Ephemeral Implementation
    2|       |//! Chapter 63: Graph Connectivity - Sequential Ephemeral Implementation
   63|      3|        }
   63|    346|                }
   63|     36|        }
   63|      4|            }
   63|    408|                }
   63|     43|                    }
   63|      5|            }
   63|      6|    where
   63|      7|            }
   63|     71|            }
   63|     74|                }
   64|       |
   64|       |
   64|       |
   64|       |
   64|       |
   64|       |
   64|       |
   64|       |
   64|       |
   64|       |
   64|       |
   64|       |
   64|       |
   64|       |
   64|       |
   64|       |
   64|       |
   64|       |
   64|       |
   64|       |
   64|       |
   64|       |
   64|       |
   64|       |
   64|       |
   64|       |                    }
   64|       |                    }
   64|       |                }
   64|       |            }
   64|       |            }
   64|       |        ]);
   64|       |    }
   64|       |    }
   64|       |    }
   64|       |    }
   64|       |}
   64|      0|                },
   64|      0|            }
   64|      1|                };
   64|     12|            f.debug_set().entries(self.data.iter()).finish()
   64|     19|            }
   64|      1|                OrderedFloat(0.5),
   64|      2|        }
   64|     23|            uf.insert(vertex.clone());
   64|    259|                        return;
   64|    271|            }
    2|       |//! Chapter 64: Minimum Spanning Trees - Spanning Tree via Star Contraction (Parallel)
    2|       |//! Chapter 64: Minimum Spanning Trees - Spanning Tree via Star Contraction (Sequential)
    2|       |//! Chapter 64: TSP 2-Approximation via MST (Parallel)
    2|       |//! Chapter 64: TSP 2-Approximation via MST (Sequential)
   64|      3|            }
   64|      3|            }
   64|      4|            }
   64|      4|        }
   64|     40|                            left.nth(l_idx).clone()
   64|     48|            }
   64|     48|    }
   64|      5|            }
   64|      5|        }
   64|     51|            }
   64|     54|            }
   64|     54|                    OrderedF64::from(f64::INFINITY)
   64|      5|                distances,
   64|     71|        }
   64|       |        where
   65|       |
   65|       |
   65|       |
   65|       |
   65|       |
   65|       |
   65|       |
   65|       |
   65|       |
   65|       |
   65|       |
   65|       |
   65|       |
   65|       |
   65|       |
   65|       |
   65|       |
   65|       |
   65|       |                },
   65|       |            ]),
   65|       |            }
   65|       |            }
   65|       |        }
   65|       |    ///
   65|       |    ///
   65|       |    }
   65|       |    }
   65|       |    }
   65|       |}
   65|      0|                }
   65|      0|        }
   65|      0|                a.length(),
   65|      1|                }
   65|    106|                }
   65|    107|            neighbors
   65|    116|            }
   65|     12|        }
   65|     13|                    }
   65|    135|        }
   65|     14|                }
   65|     15|                }
   65|     15|                }
   65|  1.84k|            }
   65|     19|    }
   65|      2|            }
   65|     21|            }
   65|     23|        }
   65|    253|                    }
   65|    271|        }
   65|     28|            }
    2|       |//! Chapter 65: Kruskal's MST Algorithm (Sequential Ephemeral)
    2|       |//! Chapter 65: Prim's MST Algorithm (Sequential Ephemeral)
    2|       |//! Chapter 65: Union-Find Data Structure (Sequential Ephemeral)
   65|      3|        }
   65|      3|        }
   65|      4|                }
   65|      4|        }
   65|     48|        }
   65|     48|    }
   65|      5|        }
   65|      5|                predecessors,
   65|      6|    where
   65|     76|                vertices,
   65|      8|            }
   65|       |        where
   65|       |        where
   65|       |        where
   66|       |
   66|       |
   66|       |
   66|       |
   66|       |
   66|       |
   66|       |
   66|       |
   66|       |
   66|       |
   66|       |
   66|       |
   66|       |
   66|       |
   66|       |
   66|       |
   66|       |
   66|       |
   66|       |
   66|       |
   66|       |
   66|       |
   66|       |
   66|       |
   66|       |
   66|       |
   66|       |
   66|       |                    }
   66|       |            );
   66|       |            );
   66|       |            }
   66|       |            }
   66|       |            }
   66|       |            }
   66|       |            }
   66|       |            }
   66|       |        {
   66|       |    ///
   66|       |    ///
   66|       |    {
   66|       |    {
   66|       |    }
   66|       |    }
   66|       |    }
   66|       |    }
   66|       |    }
   66|       |}
   66|      0|                }
   66|     10|            }
   66|    107|        }
   66|    114|                }
   66|    116|        }
   66|     12|            }
   66|    126|            }
   66|     13|            }
   66|  1.42k|            ArraySeqMtPerS::from_vec(values)
   66|  1.84k|        }
   66|    196|        }
   66|      1|            ArraySeqStEphS::from_vec(vec![
   66|      2|        }
   66|     20|        }
    2|       |//! Chapter 66: Borůvka's MST Algorithm (Parallel Ephemeral)
    2|       |//! Chapter 66: Borůvka's MST Algorithm (Sequential Ephemeral)
   66|     31|                            right.nth(r_idx).clone()
   66|      3|            count
   66|      4|            }
   66|      4|        matching
   66|      5|                distances,
   66|      5|                n,
   66|      6|    }
   66|     61|            }
   66|     65|            }
   66|     65|            }
   66|     71|            }
   66|     72|            }
   66|     73|            }
   66|     76|                labeled_edges,
   66|     78|            }
   66|      8|        }
   66|     85|        }
   66|      8|            self.distances.nth(v).clone()
   66|       |        where
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |
   67|       |                        }
   67|       |                }
   67|       |            }
   67|       |            }
   67|       |        }
   67|       |        }
   67|       |    {
   67|       |    }
   67|       |    }
   67|       |    }
   67|       |    }
   67|       |    }
   67|       |    }
   67|       |    }
   67|       |    }
   67|       |    }
   67|       |    }
   67|      1|        }
   67|      1|        }
   67|     10|        }
   67|  10.9k|            }
   67|    126|        }
   67|     13|        }
   67|     13|    where
   67|     14|                    }
   67|  1.42k|        }
   67|     18|            }
   67|      1|            guard.iter().cloned().collect()
   67|      1|                OrderedFloat(f64::INFINITY),
   67|      2|            }
   67|      2|        tour
   67|      3|        }
   67|      3|        }
   67|      4|    }
   67|      4|            neighbors
   67|      5|            }
   67|      5|                predecessors,
   67|     61|        }
   67|     65|        }
   67|     65|        }
   67|    682|            }
   67|     71|        }
   67|     72|        }
   67|     73|        }
   67|     76|            }
   67|     78|        }
   67|      7|            count
   67|      7|            return;
   67|      8|        }
   67|     97|            }
   67|       |        where
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |
   68|       |                );
   68|       |                }
   68|       |            };
   68|       |        ///
   68|       |    ///
   68|       |    ///
   68|       |    ///
   68|       |    {
   68|       |    }
   68|       |    }
   68|       |    }
   68|       |    }
   68|       |    }
   68|      0|            }
   68|      0|            }
   68|      0|    }
   68|      1|                }
   68|      1|        }
   68|     10|            }
   68|    107|            }
   68|  10.9k|        }
   68|     12|            }
   68|     17|        }
   68|     18|            }
   68|      1|                OrderedFloat(f64::INFINITY),
   68|      2|                    }
   68|      2|        }
   68|      2|    }
   68|     20|        }
   68|     21|                        }
   68|    230|        where
   68|    269|            }
   68|     30|    }
   68|      4|        }
   68|      4|                    result.push(i);
   68|      5|        }
   68|      5|        count_components(&quotient_graph)
   68|      5|                n,
   68|      6|            count
   68|      7|        }
   68|     76|        }
   68|      8|            }
   68|      8|            }
   68|      8|            }
   69|       |
   69|       |
   69|       |
   69|       |
   69|       |
   69|       |
   69|       |
   69|       |
   69|       |
   69|       |
   69|       |
   69|       |
   69|       |
   69|       |
   69|       |
   69|       |
   69|       |
   69|       |
   69|       |
   69|       |
   69|       |
   69|       |
   69|       |
   69|       |
   69|       |
   69|       |
   69|       |                    };
   69|       |                }
   69|       |            }
   69|       |            }
   69|       |            }
   69|       |            }
   69|       |        }
   69|       |    }
   69|       |    }
   69|       |    }
   69|       |}
   69|       |}
   69|      0|                    }
   69|      0|        duplicates_example()
   69|      1|    }
   69|    107|        }
   69|     10|            candidate
   69|     12|    }
   69|     15|                        left.nth(l_idx).clone()
   69|     17|                }
   69|      1|                OrderedFloat(f64::INFINITY),
   69|      2|        }
   69|    269|            *self.distances.nth(v)
   69|      2|                format!(
   69|      5|            }
   69|      6|                }
   69|      6|        }
   69|      6|        }
   69|      6|    }
   69|     63|        }
   69|     84|            }
   69|      8|            self.distances.nth(u).nth(v).clone()
   69|      8|            self.distances.nth(v).clone()
   69|      9|    }
   69|       |        where
   70|       |
   70|       |
   70|       |
   70|       |
   70|       |
   70|       |
   70|       |
   70|       |
   70|       |
   70|       |
   70|       |
   70|       |
   70|       |
   70|       |
   70|       |
   70|       |
   70|       |
   70|       |
   70|       |
   70|       |
   70|       |
   70|       |
   70|       |
   70|       |
   70|       |
   70|       |
   70|       |                    }
   70|       |                    }
   70|       |                }
   70|       |            }
   70|       |            }
   70|       |            }
   70|       |        {
   70|       |        }
   70|       |        };
   70|       |        };
   70|       |    ///
   70|       |    ///
   70|       |    {
   70|       |    }
   70|       |    }
   70|       |    }
   70|       |    }
   70|       |    }
   70|       |}
   70|      0|            }
   70|      0|    }
   70|     10|        }
   70|    168|            }
   70|      1|            count
   70|      1|                OrderedFloat(0.0),
   70|      1|        println!(
   70|      2|    }
   70|     26|            }
   70|    269|        }
   70|    279|            }
   70|    287|            }
   70|  2.88k|                }
   70|     29|            }
   70|      2|        assert!(set_from_seq.find(&2));
   70|      2|            false
   70|      2|        Some(total)
   70|     37|        }
   70|      5|        }
   70|   578k|            }
   70|     59|            self
   70|      6|        }
   70|      8|            }
   70|      8|        }
   70|      8|        }
   70|       |        where
   70|       |        where
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |
   71|       |                }
   71|       |            ]),
   71|       |            }
   71|       |            }
   71|       |    }
   71|       |    }
   71|       |    }
   71|       |}
   71|       |}
   71|      0|            false
   71|      1|                }
   71|      1|        }
   71|      1|        }
   71|     10|                }
   71|     10|            }
   71|    103|                                }
   71|     14|            }
   71|     14|            }
   71|     14|            }
   71|     16|        }
   71|    169|        }
   71|     17|                true
   71|     18|    }
   71|      1|            ArraySeqMtEphS::from_vec(result)
   71|      1|                None
   71|      2|    }
   71|    232|            }
   71|     25|    }
   71|     26|        }
   71|    279|            *self.distances.nth(v)
   71|      2|        assert!(set_from_seq.find(&7));
   71|      2|                None
   71|      2|            tree.insert(value);
   71|      2|            tree.insert(value);
   71|      2|            tree.insert(value);
   71|      2|            tree.insert(value);
   71|      2|            tree.insert(value);
   71|      2|            tree.insert(value);
   71|      3|                }
   71|     36|                        right.nth(r_idx).clone()
   71|     37|        n
   71|  4.42k|        }
   71|     49|                                }
   71|     56|        }
   71|   578k|        }
   71|     59|        }
   71|     59|                vertices,
   71|      6|    }
   71|      6|        n
   71|      7|        }
   71|     73|                                }
   71|      7|        Some(total)
   71|      7|    where
   71|     85|                result.push(element);
   71|      8|            self.distances.nth(u).nth(v).clone()
   71|      9|            }
   71|       |                    h2_value,
   72|       |
   72|       |
   72|       |
   72|       |
   72|       |
   72|       |
   72|       |
   72|       |
   72|       |
   72|       |
   72|       |
   72|       |
   72|       |
   72|       |
   72|       |
   72|       |
   72|       |
   72|       |
   72|       |
   72|       |
   72|       |
   72|       |
   72|       |
   72|       |
   72|       |
   72|       |                    }
   72|       |            {
   72|       |            }
   72|       |            }
   72|       |            }
   72|       |            };
   72|       |        );
   72|       |        ]);
   72|       |    ///
   72|       |    ///
   72|       |    }
   72|       |    }
   72|       |    }
   72|       |    }
   72|       |    }
   72|       |    }
   72|      0|            false
   72|      0|            spanning_edges
   72|      1|        }
   72|    183|            result
   72|      1|            table_per_new.find(&1)
   72|     22|                        OrderedFloat(f64::INFINITY)
   72|    279|        }
   72|     27|            w1.cmp(w2)
   72|     29|                    }
   72|     29|            }
   72|      2|        assert!(set_from_seq.find(&8));
   72|      2|                    new_chain.clone()
   72|      2|        tour
   72|      3|        }
   72|     31|                AdvancedLinearProbingStrategy::new(DefaultHashFunction);
   72|     32|                (i..j)
   72|     37|    }
   72|      4|            }
   72|      4|    }
   72|    555|                    }
   72|     59|                labeled_edges,
   72|      6|            }
   72|      6|            }
   72|      6|    }
   72|      7|        }
   72|      7|    }
   72|     79|                    }
   72|      8|        }
   72|     85|            }
   72|      8|    where
   72|       |                    table_size,
   72|       |        where
   72|       |        where
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |
   73|       |            
   73|       |                }
   73|       |                }
   73|       |            }
   73|       |        );
   73|       |        }
   73|       |    ///
   73|       |    }
   73|       |    }
   73|       |    }
   73|       |    }
   73|       |    }
   73|       |}
   73|       |                0,
   73|      0|                }
   73|      0|        };
   73|      1|                }
   73|      1|        }
   73|    103|            }
   73|    108|            }
   73|    119|                            }
   73|    122|                },
   73|    199|        }
   73|      2|                    }
   73|      2|        }
   73|      2|        }
   73|      2|        }
   73|      2|        }
   73|      2|        }
   73|      2|        }
   73|      2|        }
   73|      2|    }
   73|  2.40k|        }
   73|     27|        });
   73|     28|                Some(self.elements.nth(0))
   73|      2|        assert!(set_from_seq.find(&11));
   73|      2|            "B".to_string(),
   73|      3|            }
   73|     34|                }
   73|      3|                false
   73|      3|            table
   73|      4|        }
   73|      5|            }
   73|     53|                            }
   73|    569|                }
   73|    586|            }
   73|     59|            }
   73|      6|            *self.matrix.nth(u).nth(v)
   73|      6|            table
   73|      6|    where
   73|  7.20k|                value,
   73|      8|            }
   73|    802|        }
   73|     85|                            }
   73|     86|                                }
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |
   74|       |                        }
   74|       |                        }
   74|       |                        }
   74|       |                )
   74|       |                }
   74|       |                }
   74|       |            )
   74|       |            }
   74|       |            }
   74|       |            }
   74|       |            }
   74|       |            }
   74|       |            }
   74|       |        ///
   74|       |        }
   74|       |        }
   74|       |    ///
   74|       |    ///
   74|       |    {
   74|       |    }
   74|       |    }
   74|       |    }
   74|       |    }
   74|       |    }
   74|       |}
   74|      0|                    }
   74|      1|        }
   74|     10|            }
   74|     10|            }
   74|     13|    where
   74|     16|        }
   74|     18|                    self.buckets.nth(i).clone()
   74|      1|        println!(
   74|      2|    }
   74|     20|                Some(self.elements.nth(0))
   74|     28|            result
   74|      2|            DocumentIndex::to_seq(&result)
   74|      2|            "D".to_string(),
   74|      3|        }
   74|     30|                total,
   74|      4|        }
   74|      4|                neighbors.insert(v.clone());
   74|     59|        }
   74|      6|        }
   74|      6|        }
   74|     64|            }
   74|      7|        println!("]");
   74|      7|    where
   74|      9|            }
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |
   75|       |                    }
   75|       |                }
   75|       |                };
   75|       |            )
   75|       |            {
   75|       |            }
   75|       |            }
   75|       |            }
   75|       |            };
   75|       |    ///
   75|       |    {
   75|       |    }
   75|       |    }
   75|       |}
   75|      0|                    }
   75|      0|                };
   75|      0|            }
   75|      1|        }
   75|     13|            }
   75|    134|            }
   75|     13|                    None
   75|     14|        result
   75|     18|        }
   75|      2|            }
   75|      2|        }
   75|     20|        }
   75|      2|            "E".to_string(),
   75|      3|        }
   75|     30|        }
   75|     30|        }
   75|     34|        }
   75|      3|            false
   75|      3|            self
   75|      4|            }
   75|      4|            }
   75|     41|                }
   75|    418|        }
   75|  5.04k|                }
   75|     64|            *self.distances.nth(u).nth(v)
   75|  7.20k|            });
   75|     78|                    }
   75|     87|                    })
   75|      9|            }
   75|     90|                            }
   75|       |        where
   76|       |
   76|       |
   76|       |
   76|       |
   76|       |
   76|       |
   76|       |
   76|       |
   76|       |
   76|       |
   76|       |
   76|       |
   76|       |
   76|       |
   76|       |
   76|       |
   76|       |
   76|       |
   76|       |
   76|       |
   76|       |
   76|       |
   76|       |
   76|       |
   76|       |
   76|       |
   76|       |
   76|       |                        }
   76|       |                    }
   76|       |                }
   76|       |                }
   76|       |        ///
   76|       |    ///
   76|       |    ///
   76|       |    {
   76|       |    }
   76|       |    }
   76|       |    }
   76|       |    }
   76|       |    }
   76|      0|                }
   76|      0|        single_element_example()
   76|      1|    }
   76|    102|                    }
   76|    121|            }
   76|    122|            }
   76|  1.25k|                }
   76|     13|        }
   76|     14|    }
   76|    153|            }
   76|    167|                }
   76|    175|            }
   76|     18|        }
   76|     19|        }
   76|      1|            table_per_mapped.find(&1)
   76|      2|        }
   76|     21|            }
   76|     21|        }
   76|    239|            result
   76|     29|    }
   76|      2|            "A".to_string(),
   76|      3|            }
   76|      3|        }
   76|      3|        }
   76|     32|        }
   76|     33|                true
   76|     37|            }
   76|      3|            neighbors
   76|      3|                result.insert(seq.nth(i).clone());
   76|      3|            table
   76|      4|        }
   76|     48|            }
   76|      4|            table
   76|      5|            }
   76|      5|            }
   76|     51|                    },
   76|     52|                    },
   76|      5|            arcs
   76|     64|        }
   76|      7|    where
   76|      8|            }
   76|      8|        }
   76|  8.14k|            ArraySeqMtEphS::from_vec(values)
   76|     86|                    },
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |
   77|       |                }
   77|       |            }
   77|       |            }
   77|       |            }
   77|       |            }
   77|       |            };
   77|       |        );
   77|       |    ///
   77|       |    {
   77|       |    {
   77|       |    {
   77|       |    }
   77|       |    }
   77|       |}
   77|      0|            }
   77|      0|    }
   77|     12|                }
   77|    122|        }
   77|    153|        }
   77|    175|        }
   77|     18|        }
   77|     18|                    right_count,
   77|     22|                    right_count,
248 |         target_mut.set(2, 77);
   77|      2|            "F".to_string(),
   77|      3|            }
   77|      3|        }
   77|      3|        }
   77|      3|        }
   77|     30|                    right_count,
   77|    326|        }
   77|     34|                    }
363 |         target_mut.set(2, 77);
   77|     37|            }
   77|      4|        }
   77|     48|            *self.distances.nth(u).nth(v)
   77|      5|        }
   77|     51|                },
   77|      5|            vertices
   77|      7|            }
   77|  8.14k|        }
   77|     91|            }
   77|       |        where
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |
   78|       |                    }
   78|       |                );
   78|       |                );
   78|       |                );
   78|       |                }
   78|       |            }
   78|       |        ];
   78|       |        }
   78|       |    ///
   78|       |    {
   78|       |    }
   78|       |    }
   78|      0|                    }
   78|      0|            None
   78|     12|                    }
   78|     12|                }
   78|     12|            }
   78|     12|        true
   78|     13|                false
   78|    144|            }
   78|     15|                n,
   78|    171|                        }
   78|    173|            }
   78|    192|            }
   78|      1|            result
   78|      1|        where
   78|      2|            }
   78|  2.24k|                    }
   78|     24|                    }
   78|     26|        }
   78|     27|                }
   78|    278|            neighbors
   78|      4|            }
   78|     47|                    Some(seq.nth(0).1.clone())
   78|     48|        }
   78|      5|            }
   78|      5|            }
   78|      5|        }
   78|     50|                    })
   78|    542|                    }
   78|     73|                    },
   78|  7.59k|        }
   78|      7|            *self.matrix.nth(u).nth(v)
   78|      8|    }
   78|     81|        }
   78|       |    where
   79|       |
   79|       |
   79|       |
   79|       |
   79|       |
   79|       |
   79|       |
   79|       |
   79|       |
   79|       |
   79|       |
   79|       |
   79|       |
   79|       |
   79|       |
   79|       |
   79|       |
   79|       |
   79|       |
   79|       |
   79|       |
   79|       |                }
   79|       |                }
   79|       |                }
   79|       |                }
   79|       |                }
   79|       |                }
   79|       |            );
   79|       |            }
   79|       |            }
   79|       |            }
   79|       |            }
   79|       |            }
   79|       |            };
   79|       |        ///
   79|       |    ///
   79|       |    ///
   79|       |    ///
   79|       |    {
   79|       |    {
   79|       |    }
   79|       |    }
   79|       |    }
   79|       |    }
   79|       |                0,
   79|      0|            }
   79|      0|            }
   79|      0|        }
   79|      0|                0.0
   79|      1|            }
   79|      1|        }
   79|      1|    }
   79|    122|        }
   79|  1.25k|            guard
   79|  1.46k|                }
   79|     16|            }
   79|    173|        }
   79|  1.86k|        }
   79|     19|    }
   79|    191|                }
   79|      2|        }
   79|    228|                },
   79|     23|            edges
   79|  25.0k|        }
   79|     26|                    right_count,
   79|     27|    }
   79|    272|            }
   79|    278|        }
   79|     32|                    .min()
   79|    337|                probe_sequence.push(pos);
   79|      3|            neighbors
   79|      5|        }
   79|    582|                }
   79|      6|    }
   79|     62|                    }
   79|      6|            max_sum
   79|      6|        tour.push(current.clone());
   79|      7|        }
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |
   80|       |            
   80|       |                    }
   80|       |                );
   80|       |                }
   80|       |            )
   80|       |            }
   80|       |            }
   80|       |            }
   80|       |            }
   80|       |            }
   80|       |            }
   80|       |        {
   80|       |        }
   80|       |    {
   80|       |    }
   80|       |                0,
   80|      0|            }
   80|      0|        }
   80|      1|            }
   80|      1|        }
   80|     10|        where
   80|  1.25k|                .as_ref()
   80|    129|            }
   80|     16|            }
   80|  1.66k|                singleton_sets.push(Self::singleton(elem));
   80|      1|        println!(
   80|     23|        }
   80|    255|                        }
   80|     28|            }
   80|      2|        keys.into_iter()
   80|      3|        }
   80|      3|        }
   80|     32|                    .unwrap_or(0)
   80|    337|                unique_positions.insert(pos);
   80|     39|                keys.insert(pair.0.clone());
   80|      4|            }
   80|     46|        }
   80|      5|            }
   80|      6|        }
   80|     60|            }
   80|      6|                        insert_cost.min(delete_cost).min(substitute_cost)
   80|      6|            max_sum
   80|      8|            true
   80|       |        where
   81|       |
   81|       |
   81|       |
   81|       |
   81|       |
   81|       |
   81|       |
   81|       |
   81|       |
   81|       |
   81|       |
   81|       |
   81|       |
   81|       |
   81|       |
   81|       |
   81|       |
   81|       |
   81|       |
   81|       |
   81|       |
   81|       |
   81|       |
   81|       |
   81|       |
   81|       |
   81|       |
   81|       |            
   81|       |                    }
   81|       |                    }
   81|       |                }
   81|       |            )
   81|       |            );
   81|       |            };
   81|       |    ///
   81|       |    ///
   81|       |    }
   81|       |}
   81|      0|                }
   81|      0|            }
   81|      0|        }
   81|      0|                self.num_elements
   81|      1|            }
   81|      1|        }
   81|    100|        }
   81|  1.07k|            guard.iter().cloned().collect()
   81|     11|        }
   81|    131|            result
   81|     16|        }
   81|  1.66k|            }
   81|    168|        }
   81|     16|                        i64::MAX
   81|      1|            height_rec(&self.root)
   81|     20|        where
   81|     27|    }
   81|     28|        }
   81|     28|            true
   81|     29|            Some(min_element)
   81|    379|                        Ordering::Less
   81|     39|            }
   81|      3|            neighbors
   81|      4|            }
   81|      4|        }
   81|     40|                }
   81|      5|            }
   81|      6|        }
   81|     71|                        out.push(node.value.clone());
   81|  7.89k|                    .head
   81|      8|            }
   81|     84|        }
   81|     85|        }
   81|       |    where
   82|       |
   82|       |
   82|       |
   82|       |
   82|       |
   82|       |
   82|       |
   82|       |
   82|       |
   82|       |
   82|       |
   82|       |
   82|       |
   82|       |
   82|       |
   82|       |
   82|       |
   82|       |
   82|       |
   82|       |
   82|       |
   82|       |
   82|       |
   82|       |
   82|       |
   82|       |
   82|       |
   82|       |            
   82|       |                }
   82|       |            }
   82|       |            };
   82|       |            };
   82|       |        ///
   82|       |        {
   82|       |    }
   82|       |    }
   82|       |    }
   82|       |    }
   82|       |    }
   82|       |    }
   82|       |    }
   82|       |    }
   82|       |}
   82|      0|                }
   82|      0|            }
   82|      1|        }
   82|      1|        }
   82|      1|        }
   82|  10.6k|                singleton_sets.push(Self::singleton(elem));
   82|    107|            }
   82|  1.07k|        }
   82|    122|            }
   82|  1.25k|        }
   82|    131|        }
   82|     13|            keys
   82|     13|                    None
   82|     15|            self.vertices.insert(from.clone());
   82|     19|        }
   82|      1|                        false
   82|      1|            table_eph.find(&1)
   82|      1|        where
   82|      2|        }
   82|  20.5M|            }
   82|     24|            }
   82|     28|        }
   82|      3|        }
   82|     31|        }
   82|      4|        }
   82|      4|            arcs
   82|      5|            }
   82|      5|        }
   82|      5|                        false
   82|      7|        }
   82|      8|            }
   82|       |        where
   82|       |        where
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |
   83|       |                    };
   83|       |                    };
   83|       |            };
   83|       |            };
   83|       |        );
   83|       |        }
   83|       |    ///
   83|       |    {
   83|       |    }
   83|       |    }
   83|       |    }
   83|       |    }
   83|       |    }
   83|       |    }
   83|       |}
   83|       |}
   83|       |}
   83|       |}
   83|      0|        empty_example()
   83|    106|        }
   83|  10.6k|            }
   83|    107|        }
   83|    122|                    new_chain.clone()
   83|     13|        }
   83|     15|                &all_predecessors,
   83|     15|            self.vertices.insert(to.clone());
   83|    167|                        Ordering::Greater
   83|      2|            }
   83|      2|            }
   83|      2|            }
   83|     25|            }
   83|      4|        }
   83|      5|        }
   83|      6|                        insert_cost.min(delete_cost).min(substitute_cost)
   83|  7.89k|                    .is_ok()
   83|      7|                    None
   83|     87|            result
   83|     88|        }
   83|      9|    where
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |
   84|       |                    }
   84|       |                {
   84|       |            };
   84|       |        {
   84|       |    }
   84|       |    }
   84|       |    }
   84|       |}
   84|      0|                }
   84|      0|    }
   84|      0|                    break;
   84|      1|            }
   84|    103|        }
   84|     15|                &ArraySeqStEphS::singleton(dijkstra_result.predecessors.clone()),
   84|    185|        }
   84|      1|            edges
   84|      1|            edges
   84|      2|            }
   84|      2|            }
   84|    229|                }
   84|     25|        }
   84|     28|            }
   84|     29|            }
   84|      2|                    neighbors.push(v);
   84|      5|            }
   84|      5|            }
   84|  5.01k|                }
   84|   555k|            t
   84|      5|                        false
   84|      5|                (i..j)
   84|      6|            }
   84|      6|        tour.push(current.clone());
   84|     71|                    }
   84|      7|    where
   84|     85|        }
   85|       |
   85|       |
   85|       |
   85|       |
   85|       |
   85|       |
   85|       |
   85|       |
   85|       |
   85|       |
   85|       |
   85|       |
   85|       |
   85|       |
   85|       |
   85|       |
   85|       |
   85|       |
   85|       |
   85|       |
   85|       |
   85|       |
   85|       |
   85|       |
   85|       |
   85|       |
   85|       |                    }
   85|       |                    }
   85|       |                    };
   85|       |                }
   85|       |            );
   85|       |            }
   85|       |            }
   85|       |            }
   85|       |            }
   85|       |        {
   85|       |    {
   85|       |    }
   85|       |}
   85|      0|                }
   85|      0|        }
   85|      0|                return;
   85|      1|            }
   85|      1|        }
   85|      1|        }
   85|      1|        }
   85|      1|        }
   85|      1|        }
   85|     10|            n,
   85|  1.11k|            }
   85|     13|        }
   85|    131|            self.vertices.insert(v1.clone());
   85|     15|        }
   85|     16|            }
   85|    178|                    break;
   85|     17|            Some(Box::new(node))
   85|    183|            {
   85|      1|            edges
   85|      1|            self.vertices.delete(&v_clone);
   85|      2|                }
   85|      2|            }
   85|      2|            }
   85|      2|        }
   85|     28|        }
   85|  2.83k|                    self.buckets.nth(i).clone()
   85|      3|        }
   85|    337|                }
   85|    346|                    quick_sort(right);
   85|      4|        }
   85|  4.01M|            }
   85|     45|                }
   85|     47|                    Some(seq.nth(0).1.clone())
   85|      4|                    continue;
   85|      5|        }
   85|      5|        }
   85|   555k|        }
   85|      5|            n,
   85|     61|            result
   85|      6|                        insert_cost.min(delete_cost).min(substitute_cost)
   85|  7.20k|                    break;
   85|  8.09k|                        Self::update(node);
   85|  8.21k|                        Self::update(node);
   85|     86|                        Ordering::Equal
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |
   86|       |                    }
   86|       |                    }
   86|       |                    }
   86|       |                }
   86|       |                }
   86|       |                }
   86|       |                }
   86|       |                };
   86|       |            }
   86|       |            }
   86|       |            };
   86|       |        }
   86|       |        }
   86|       |        }
   86|       |        }
   86|       |    {
   86|      0|                }
   86|      0|            }
   86|      0|                    keys.insert(self.entries.nth_cloned(0).0);
   86|      1|        }
   86|     10|        }
   86|    110|        }
   86|     12|            }
   86|    131|            self.vertices.insert(v2.clone());
   86|     14|        }
   86|    159|                }
   86|     17|        }
   86|      1|        println!(
   86|      2|                    }
   86|      2|            }
   86|      2|        }
   86|     20|        where
   86|     23|        }
   86|     29|            left_min.min(right_min)
   86|      2|            DocumentIndex::size(&result)
   86|    346|                });
   86|     38|            coins_vec.push(rng.random::<bool>());
   86|      4|                }
   86|      5|            }
   86|      5|        }
   86|     50|            }
   86|     51|                },
   86|  60.0k|            }
   86|    694|                }
   86|  6.97k|                        }
   86|      7|            }
   86|    796|                }
   86|      8|                }
   86|  8.09k|                    }
   86|  8.21k|                    }
   86|      9|        }
   86|     99|            ng
   87|       |
   87|       |
   87|       |
   87|       |
   87|       |
   87|       |
   87|       |
   87|       |
   87|       |
   87|       |
   87|       |
   87|       |
   87|       |
   87|       |
   87|       |
   87|       |
   87|       |
   87|       |
   87|       |
   87|       |
   87|       |
   87|       |
   87|       |                }
   87|       |                }
   87|       |                }
   87|       |                }
   87|       |            }
   87|       |            }
   87|       |            }
   87|       |            };
   87|       |        ]);
   87|       |        }
   87|       |    {
   87|       |    }
   87|       |    }
   87|       |    }
   87|       |    }
   87|       |    }
   87|       |    }
   87|      0|            }
   87|      0|                        s
   87|      1|                }
   87|     10|    }
   87|     10|            out
   87|  11.0k|                        Self::update(node);
   87|     12|        }
   87|    124|                        }
   87|  1.29k|    }
   87|     15|                n,
   87|  1.66k|            }
   87|     18|        }
   87|    184|            }
   87|     19|            result
   87|      1|            ArraySeqStEphS::from_vec(neighbors)
   87|      1|        where
   87|      2|        }
   87|      2|        }
   87|  22.9k|                        Self::update(left);
   87|    237|        where
   87|  2.39M|    }
   87|    244|        }
   87|    253|                        sort(right);
   87|      2|        assert!(filtered.find(&4));
   87|     38|        }
   87|    381|                    })
   87|      4|            }
   87|      5|        }
   87|      5|    }
   87|  5.27k|    }
   87|     60|            }
   87|    699|            }
   87|      6|                        insert_cost.min(delete_cost).min(substitute_cost)
   87|      7|        }
   87|     80|                    probe_sequence.push(hash_pos);
   87|  8.10k|                    inserted
   87|  8.21k|                    inserted
   87|     97|        }
   87|     99|        }
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |
   88|       |                    }
   88|       |                    }
   88|       |                }
   88|       |                }
   88|       |            );
   88|       |            }
   88|       |            }
   88|       |            }
   88|       |            }
   88|       |            }
   88|       |            };
   88|       |            };
   88|       |        }
   88|       |    }
   88|      0|            return;
   88|      1|        }
   88|     10|        }
   88|     11|            }
   88|  11.0k|                    }
   88|     13|            }
   88|    183|            }
   88|    184|        }
   88|      1|            table_mt.find(&1)
   88|      2|            }
   88|      2|        }
   88|      2|        }
   88|    220|                    vals.push(seq.nth(i).clone());
   88|  22.9k|                    }
   88|     23|                    Some(min_entry.1.clone())
   88|     24|        }
   88|    253|                    });
   88|     28|        }
   88|      2|        assert!(filtered.find(&2));
   88|      2|            self.vertices.insert(from.clone_mt());
   88|      3|        }
   88|     45|                    }
   88|     50|        }
   88|     51|        }
   88|     51|            LinkedListStEphS::from_vec(out)
   88|    586|            result
   88|     60|            where
   88|    724|                key,
   88|    730|        }
   88|     80|                }
   88|     85|        }
   89|       |
   89|       |
   89|       |
   89|       |
   89|       |
   89|       |
   89|       |
   89|       |
   89|       |
   89|       |
   89|       |
   89|       |
   89|       |
   89|       |
   89|       |
   89|       |
   89|       |
   89|       |
   89|       |
   89|       |
   89|       |
   89|       |
   89|       |
   89|       |
   89|       |
   89|       |
   89|       |
   89|       |
   89|       |                }
   89|       |                }
   89|       |                }
   89|       |            }
   89|       |            }
   89|       |        );
   89|       |        {
   89|       |        {
   89|       |        }
   89|       |    }
   89|       |}
   89|      0|                }
   89|      0|        }
   89|      0|            None
   89|      0|                        Set::empty()
   89|      1|            }
   89|      1|        }
   89|  10.6k|            }
   89|  11.0k|                    inserted
   89|     16|                multiset,
   89|     18|                adj_vecs[v].push(u);
   89|     19|                    }
   89|      2|            }
   89|      2|            }
   89|    218|                    break;
   89|    220|                }
   89|    231|            }
   89|     27|                reducer,
   89|      2|        assert!(filtered.find(&6));
   89|      2|            self.vertices.insert(to.clone_mt());
   89|      4|            }
   89|      5|            }
   89|    512|                }
   89|     56|        }
   89|    588|        }
   89|    632|        }
   89|  7.20k|        }
   89|      7|        mst_edges
   89|      8|                    }
   89|     85|                result.push(element);
   89|      8|                stack.push(start.clone());
   89|      8|                true
   89|     97|                            node.left.clone()
   90|       |
   90|       |
   90|       |
   90|       |
   90|       |
   90|       |
   90|       |
   90|       |
   90|       |
   90|       |
   90|       |
   90|       |
   90|       |
   90|       |
   90|       |
   90|       |
   90|       |
   90|       |
   90|       |
   90|       |
   90|       | 
   90|       |                    }
   90|       |                    };
   90|       |                }
   90|       |                }
   90|       |                }
   90|       |            };
   90|       |        {
   90|       |    }
   90|      0|        efficiency_demonstration()
   90|      1|            }
   90|      1|        }
   90|     11|                }
   90|    134|            result
   90|  14.3k|                        result.push(left_sorted[i].clone());
   90|     17|        }
   90|     18|            }
   90|    183|            result
   90|  18.9k|        }
   90|     19|            result
   90|      2|            }
   90|      2|            };
   90|     20|            &self,
   90|    232|        }
   90|     27|                identity,
   90|    287|        }
   90|  2.98k|                }
   90|      2|        assert!(!filtered.find(&11));
   90|      2|                    neighbors.push(v);
   90|      3|        }
   90|     30|            }
   90|      3|                vals
   90|    437|            }
   90|      4|        ArraySeqStEphS::from_vec(coins_vec)
   90|      5|            }
   90|      6|                    })
   90|      6|                sort(data);
   90|      7|    }
   90|    823|                v.clone()
   90|     85|            }
   90|      9|            }
   91|       |
   91|       |
   91|       |
   91|       |
   91|       |
   91|       |
   91|       |
   91|       |
   91|       |
   91|       |
   91|       |
   91|       |
   91|       |
   91|       |
   91|       |
   91|       |
   91|       |
   91|       |                }
   91|       |                };
   91|       |            {
   91|       |            }
   91|       |            }
   91|       |            }
   91|       |            }
   91|       |            };
   91|       |            };
   91|       |            };
   91|       |        );
   91|       |        }
   91|       |    }
   91|       |    }
   91|       |                0,
   91|      0|                }
   91|      0|                }
   91|      0|                }
   91|      0|                }
   91|      0|    }
   91|      1|            }
   91|      1|        }
   91|     10|            })
   91|     10|                main_result
   91|     10|        where
   91|    111|            {
   91|     11|                false
   91|    135|        }
   91|     15|            {
   91|     16|            }
   91|     18|                adj_vecs[v].push(u);
   91|      2|                }
   91|      2|            }
   91|      2|            }
   91|      2|        }
   91|      2|        }
   91|      2|        }
   91|     21|                }
   91|     23|                }
   91|    234|        }
   91|    234|                    true
   91|     27|            }
   91|     28|        }
   91|     29|            guard[self.range.start..self.range.end].iter().cloned().collect()
   91|    349|            }
   91|     35|                }
   91|      4|    }
   91|    437|        }
   91|     46|            }
   91|      5|                    .min()
   91|      5|            n,
   91|      5|            self.vertices.insert(v1.clone_mt());
   91|      6|            });
   91|    682|            result
   91|  6.87k|                            node.right.clone()
   91|      7|            }
   91|    907|                    true
   91|     93|            }
   92|       |
   92|       |
   92|       |
   92|       |
   92|       |
   92|       |
   92|       |
   92|       |
   92|       |
   92|       |
   92|       |
   92|       |
   92|       |
   92|       |
   92|       |
   92|       |
   92|       |
   92|       |
   92|       |
   92|       |
   92|       |
   92|       |
   92|       |
   92|       |
   92|       |
   92|       |
   92|       |
   92|       |
   92|       |
   92|       |                        };
   92|       |                }
   92|       |                }
   92|       |            )
   92|       |            }
   92|       |            }
   92|       |            }
   92|       |            }
   92|       |            }
   92|       |            }
   92|       |            }
   92|       |            };
   92|       |        ///
   92|       |        }
   92|       |        }
   92|       |        }
   92|       |    }
   92|       |    }
   92|      0|            }
   92|      0|            }
   92|      0|            }
   92|      1|        }
   92|  1.07k|        }
   92|    107|                    Self::update(x.left.as_mut().unwrap());
   92|    131|            self.labeled_edges.insert(normalized_edge);
   92|    136|            }
   92|     14|            }
   92|     15|                element_hashes.push(h.finish());
   92|     16|            }
   92|     16|        }
   92|     16|                Self::max_contig_sub_sum_divcon_mt(&right_clone)
   92|     18|                    }
   92|     18|            }
   92|      1|                self.num_elements
   92|      2|                }
   92|      2|        }
   92|    268|                        break;
   92|     27|        }
   92|    280|                values.remove(pos);
   92|     29|        }
   92|      2|            .collect()
   92|      3|            }
   92|      3|        }
   92|     31|                reducer,
   92|  4.00k|                    lock_clone.lock();
   92|     46|        }
   92|      4|                    continue;
   92|      5|        }
   92|      5|            self.vertices.insert(v2.clone_mt());
   92|      5|                    .unwrap_or(0)
   92|  6.23k|                true
   92|      6|                values.remove(pos);
   92|      6|                values.remove(pos);
   92|      6|                values.remove(pos);
   92|      6|                values.remove(pos);
   92|      6|                values.remove(pos);
   92|      7|        }
   92|    724|            }
   92|      8|        }
   92|     93|        }
   93|       |
   93|       |
   93|       |
   93|       |
   93|       |
   93|       |
   93|       |
   93|       |
   93|       |
   93|       |
   93|       |
   93|       |
   93|       |
   93|       |
   93|       |
   93|       |
   93|       |
   93|       |
   93|       |
   93|       |
   93|       |                    }
   93|       |                    }
   93|       |            {
   93|       |            }
   93|       |            }
   93|       |            }
   93|       |            }
   93|       |            };
   93|       |            };
   93|       |        {
   93|       |        }
   93|       |        }
   93|       |        }
   93|       |        }
   93|       |    ///
   93|       |    }
   93|      0|                }
   93|      0|                }
   93|      1|            }
   93|      1|            }
   93|    112|        }
   93|     13|            }
   93|     13|        }
   93|    131|        }
   93|    136|        }
   93|     14|            }
   93|     14|        }
   93|     14|        result
   93|     15|            {
   93|     15|            }
   93|     16|            });
   93|     16|        }
   93|     19|        }
   93|      1|            ArraySeqStPerS::from_vec(neighbors)
   93|      1|            f.debug_list().entries(self.data.iter()).finish()
   93|      1|        Some(total)
   93|      1|                        to_remove.push(edge.clone());
   93|      2|            }
   93|      2|        }
   93|      2|        }
   93|      2|    }
   93|     22|        }
   93|     25|            }
   93|    266|                }
   93|     28|                })
   93|      2|                        result.push(right_sorted[j].clone());
   93|      3|        }
   93|     31|                })
   93|     31|                identity,
   93|      4|                }
   93|      5|            }
   93|      5|            }
   93|      5|    }
   93|      6|            }
   93|      6|        }
   93|    624|                    true
   93|     68|                        visited.insert(current.clone());
   93|      6|            None
   93|      6|            spanning_edges
   93|    724|        }
   93|      7|                    None
   93|      8|        }
   93|    932|                    new_doc.clone()
   94|       |
   94|       |
   94|       |
   94|       |
   94|       |
   94|       |
   94|       |
   94|       |
   94|       |
   94|       |
   94|       |
   94|       |
   94|       |
   94|       |
   94|       |
   94|       |
   94|       |
   94|       |
   94|       |
   94|       |
   94|       |
   94|       |
   94|       |
   94|       |
   94|       |
   94|       |
   94|       |
   94|       |
   94|       |
   94|       |
   94|       |                }
   94|       |            {
   94|       |            }
   94|       |        }
   94|       |    ///
   94|       |    }
   94|       |    }
   94|      0|                    }
   94|      0|            }
   94|      0|            }
   94|      0|                        break;
   94|      0|                        s
   94|      1|                    }
   94|      1|        }
   94|      1|        }
   94|      1|        }
   94|      1|    }
   94|      1|    }
   94|    111|            }
   94|    120|            }
   94|    124|                    true
   94|     13|                .collect();
   94|     14|    }
   94|     14|                    continue;
   94|     15|            }
   94|     16|                .collect();
   94|     18|                    continue;
   94|     19|    }
   94|      1|            edges
   94|      1|        println!(
   94|      2|        }
   94|      2|        }
   94|     20|            table
   94|     20|        where
   94|    239|            }
   94|     25|        }
   94|    252|                    break;
   94|    258|                    }
   94|     25|        bridges
   94|     25|                source,
   94|    280|            }
   94|      2|        Some(total)
   94|      3|                }
   94|      3|            }
   94|     31|            }
   94|     31|                table_size,
   94|     32|            where
   94|     38|        }
   94|      4|            }
   94|      4|            }
   94|  4.00k|                    lock_clone.unlock();
   94|      5|            }
   94|      5|        }
   94|      5|        }
   94|      5|                    xm
   94|      6|            }
   94|      6|            }
   94|      6|            }
   94|      6|            }
   94|      6|            }
   94|      6|        };
   94|  6.97k|                        drop(guard);
   94|      6|            element_hashes.sort_unstable();
   94|      7|    }
   94|    813|                false
   94|  8.44k|        }
   94|      9|        }
   94|  9.01k|        }
   94|    932|                });
   94|     96|            }
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |
   95|       |                }
   95|       |                }
   95|       |                }
   95|       |                },
   95|       |            }
   95|       |            }
   95|       |            }
   95|       |            }
   95|       |            };
   95|       |        }
   95|       |    }
   95|       |    }
   95|       |}
   95|       |}
   95|      0|        }
   95|      0|        true
   95|      1|        }
   95|      1|        }
   95|    114|            {
   95|    120|        }
   95|    124|                }
   95|     16|            }
   95|      1|                return;
   95|      2|                    }
   95|      2|    }
   95|     20|        }
   95|  22.9k|        }
   95|    232|            result
   95|    239|                }
   95|     25|    }
   95|     25|                target,
   95|    266|                }
   95|    266|        }
   95|     27|        where
   95|    280|        }
   95|      3|                    }
   95|      3|        }
   95|     31|        }
   95|     31|                probe_sequence,
   95|    348|                root
   95|      3|            result
   95|      4|        }
   95|  4.00k|                }
   95|      4|                        clusters.push(current_cluster_size);
   95|      5|            }
   95|      5|                continue;
   95|      6|        }
   95|      6|        }
   95|      6|        }
   95|      6|        }
   95|     60|            where
   95|      6|            self.data.len().hash(state);
   95|      7|        }
   95|     96|                }
   95|     96|        }
   95|     97|                }
   95|     99|                }
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |
   96|       |                }
   96|       |                }
   96|       |                }
   96|       |                }
   96|       |            }
   96|       |            }
   96|       |            }
   96|       |            }
   96|       |            }
   96|       |            }
   96|       |            };
   96|       |        {
   96|       |    }
   96|       |}
   96|      0|                }
   96|      0|                }
   96|      0|    }
   96|      0|                continue;
   96|      0|                        Set::empty()
   96|      0|                    x0
   96|      1|        }
   96|    111|            result
   96|  11.7k|        }
   96|     15|            }
   96|     15|        }
   96|     15|            result
   96|      1|                return;
   96|      1|            table_per_filtered.size()
   96|      1|                to_remove
   96|      1|        where
   96|      2|            }
   96|      2|        }
   96|     23|                    Some(seq.nth(0).1.clone())
   96|     28|            left_min.min(right_min)
   96|      3|        }
   96|     31|                sequence_length,
   96|    366|        where
   96|      4|            }
   96|      4|            }));
   96|      5|            }
   96|     64|                                stack.push(neighbor.clone());
   96|      7|            }
   96|      7|    }
   96|  7.04k|        }
   96|    783|        }
   96|     83|            }
   97|       |
   97|       |
   97|       |
   97|       |
   97|       |
   97|       |
   97|       |
   97|       |
   97|       |
   97|       |
   97|       |
   97|       |
   97|       |
   97|       |
   97|       |
   97|       |
   97|       |
   97|       |
   97|       |
   97|       |
   97|       |
   97|       |                    };
   97|       |                }
   97|       |                }
   97|       |                }
   97|       |            }
   97|       |            }
   97|       |            };
   97|       |            };
   97|       |        );
   97|       |        {
   97|       |        }
   97|       |    }
   97|       |    }
   97|       |}
   97|      0|                }
   97|      0|        }
   97|  1.17k|        }
   97|     12|                }
   97|     12|            result
   97|     15|                h.hash(state);
   97|     16|                }
   97|    179|        }
   97|     18|                .into_iter()
   97|      1|            self
   97|      1|        where
   97|      2|                        }
   97|     24|        }
   97|     25|            }
   97|      3|    }
   97|      4|                }
   97|      5|            }
   97|      5|    }
   97|  5.04k|                result.extend_from_slice(&left_sorted[i..]);
   97|      6|            }
   97|      6|            }
   97|  60.0k|            }
   97|     63|        }
   97|     64|                            }
   97|      8|            }
   97|     80|        }
   97|     83|        }
   97|     91|        }
   97|     98|            neighbors
   98|       |
   98|       |
   98|       |
   98|       |
   98|       |
   98|       |
   98|       |
   98|       |
   98|       |
   98|       |
   98|       |
   98|       |
   98|       |
   98|       |
   98|       |
   98|       |
   98|       |
   98|       |
   98|       |
   98|       |
   98|       |        
   98|       |                        }
   98|       |                    }
   98|       |            {
   98|       |            }
   98|       |            }
   98|       |            }
   98|       |            }
   98|       |            }
   98|       |            };
   98|       |        );
   98|       |        {
   98|       |        {
   98|       |    ///
   98|       |    }
   98|       |    }
   98|       |    }
   98|       |    }
   98|      0|                }
   98|      0|                }
   98|      0|            }
   98|      0|        where
   98|      1|        }
   98|     10|            out
   98|     10|                    valid_values.push(candidate);
   98|    114|            }
   98|     12|                multiset,
   98|     13|                .into_iter()
   98|     14|            }
   98|     15|            }
   98|     15|        }
   98|     15|            result
   98|     15|                    result.insert(elem.clone());
   98|     16|                .into_iter()
   98|  1.81k|            }
   98|     18|                .zip(probs.into_iter())
   98|      1|                    xl
   98|      2|        }
   98|    232|            }
   98|     25|        }
   98|     25|        ArraySeqStEphS<ArraySeqStEphS<i64>>,
   98|    282|                    }
   98|      2|            result
   98|     30|            }
   98|     30|            where
   98|     31|        }
   98|     32|                reducer,
   98|    376|            }
   98|     38|        }
   98|      4|            }
   98|      4|            });
   98|     46|        ArraySeqStEphS<ArraySeqStEphS<OrderedF64>>,
   98|      5|            }
   98|      5|            }
   98|  5.04k|                result.extend_from_slice(&right_sorted[j..]);
   98|      5|            self.labeled_edges.insert(normalized_edge);
   98|     70|                }
   98|    796|            }
   98|      8|        }
   98|     98|        }
   99|       |
   99|       |
   99|       |
   99|       |
   99|       |
   99|       |
   99|       |
   99|       |
   99|       |
   99|       |
   99|       |
   99|       |
   99|       |
   99|       |
   99|       |
   99|       |
   99|       |
   99|       |
   99|       |
   99|       |
   99|       |
   99|       |
   99|       |
   99|       |
   99|       |
   99|       |
   99|       |
   99|       |
   99|       |                {
   99|       |                }
   99|       |                }
   99|       |                }
   99|       |            }
   99|       |        {
   99|       |    }
   99|       |    }
   99|       |    }
   99|       |}
   99|      0|                }
   99|      0|            }
   99|     10|                }
   99|     10|        }
   99|    107|        }
   99|     13|            }
   99|    139|        }
   99|     14|            }
   99|     15|                }
   99|     19|            }
   99|      1|                self.edges.delete(&edge);
   99|      2|                }
   99|      2|        }
   99|    218|                result.push(self.elements.nth(i).clone());
233 |         source_mut.set(0, 99);
   99|     24|        }
   99|     25|        ArraySeqStEphS<ArraySeqStEphS<usize>>,
   99|     28|                .collect();
   99|     29|            }
   99|      2|                reducer,
   99|     31|                collision_pattern,
   99|     32|                identity,
348 |         source_mut.set(0, 99);
   99|    376|        }
   99|      3|                new_neighbors_vec.push(*old_neighbors.nth(i));
   99|      4|                    }
   99|      4|        }
   99|     46|        ArraySeqStEphS<ArraySeqStEphS<usize>>,
   99|      4|            neighbors
   99|      5|            }
   99|      5|        }
   99|      5|        }
   99|  5.04k|                result
   99|      5|            None
   99|      6|        }
   99|  6.96k|                                node.update();
   99|      7|        }
   99|     71|                }
   99|  7.20k|            Some(value)
   99|      7|                dimensions,
   99|      7|            result
   99|       |        where
  100|       |
  100|       |
  100|       |
  100|       |
  100|       |
  100|       |
  100|       |
  100|       |
  100|       |
  100|       |
  100|       |
  100|       |
  100|       |
  100|       |
  100|       |
  100|       |
  100|       |
  100|       |
  100|       |
  100|       |
  100|       |
  100|       |
  100|       |
  100|       |
  100|       |
  100|       |        
  100|       |                }
  100|       |                };
  100|       |            {
  100|       |            {
  100|       |            }
  100|       |            }
  100|       |            }
  100|       |            }
  100|       |            }
  100|       |        ///
  100|       |        {
  100|       |        }
  100|       |    ///
  100|       |    ///
  100|       |    }
  100|       |}
  100|       |}
  100|      0|                }
  100|      0|            }
  100|      0|    }
  100|      1|            }
  100|      1|            }
  100|  1.02k|        }
  100|  10.2k|            }
  100|    114|            result
  100|     12|            }
  100|     15|        }
  100|     15|                merged.insert(value);
  100|     18|        }
  100|     18|                .collect();
  100|    218|            }
  100|    251|                }
  100|     26|                }
  100|     26|            }
  100|     28|            ArraySetStEph::from_seq(crate::Chap19::ArraySeqStEph::ArraySeqStEph::ArraySeqStEphS::from_vec(
  100|      2|                identity,
  100|      2|                self.elements.remove(pos);
  100|      3|            }
  100|      3|            });
  100|      3|    }
  100|     31|            }
  100|     32|            }
  100|    396|            hash_value
  100|      3|                        new_neighbors_vec.push(*old_neighbors.nth(i));
  100|      4|        }
  100|      4|        }
  100|      5|            }
  100|      5|        }
  100|      5|                merged.insert(value);
  100|      5|                merged.insert(value);
  100|      5|                merged.insert(value);
  100|      5|                merged.insert(value);
  100|      5|            n,
  100|      5|            result
  100|      6|            }
  100|  6.96k|                            }
  100|      7|        }
  100|  7.21k|        }
  100|     84|            }
  100|     90|                merged.insert(value);
  100|      9|            out
  101|       |
  101|       |
  101|       |
  101|       |
  101|       |
  101|       |
  101|       |
  101|       |
  101|       |
  101|       |
  101|       |
  101|       |
  101|       |
  101|       |
  101|       |
  101|       |
  101|       |
  101|       |
  101|       |
  101|       |
  101|       |
  101|       |
  101|       |
  101|       |
  101|       |
  101|       |
  101|       |                    }
  101|       |            }
  101|       |            }
  101|       |            };
  101|       |        }
  101|       |    ///
  101|       |    }
  101|       |    }
  101|       |}
  101|      0|                    }
  101|      0|            }
  101|      0|            }
  101|      1|                        }
  101|      1|            }
  101|      1|        }
  101|     10|        }
  101|     10|        where
  101|    114|        }
  101|    116|                    return;
  101|     11|            new_neighbors_vec.push(v);
  101|     12|        }
  101|     14|        }
  101|     15|            }
  101|     16|                }
  101|      1|            count
  101|      2|            }
  101|      2|            }
  101|     21|        }
  101|     22|    }
  101|     24|            }
  101|     28|                keys,
  101|      3|                    }
  101|      3|            }
  101|     31|        }
  101|     32|        }
  101|    396|        }
  101|      4|        }
  101|      5|            }
  101|      5|            }
  101|      5|            }
  101|      5|            }
  101|      5|        }
  101|      6|        }
  101|      7|            }
  101|  7.83k|                    }
  101|      7|        println!("],");
  101|      7|            result
  101|     84|        }
  101|      8|                        Some(&node.key)
  101|     90|            }
  101|    907|        }
  102|       |
  102|       |
  102|       |
  102|       |
  102|       |
  102|       |
  102|       |
  102|       |
  102|       |
  102|       |
  102|       |
  102|       |
  102|       |
  102|       |
  102|       |
  102|       |
  102|       |
  102|       |
  102|       |
  102|       |
  102|       |
  102|       |                    }
  102|       |                }
  102|       |            ))
  102|       |            }
  102|       |    ///
  102|       |    {
  102|       |    }
  102|       |    }
  102|       |}
  102|      0|                }
  102|      0|        }
  102|      1|            }
  102|      1|        }
  102|      1|        }
  102|    104|        }
  102|    111|                }
  102|     11|                    new_neighbors_vec.push(v);
  102|  1.52k|                values.push(f(i));
  102|     16|                &right_for_prefix
  102|      1|        where
  102|      2|        }
  102|      2|        }
  102|     20|            vertices.insert(i);
  102|     23|                }
  102|     24|        }
  102|      2|        assert!(union_result.find(&2));
  102|      2|                reducer,
  102|      3|        }
  102|     34|            }
  102|    437|                }
  102|    487|            result
  102|      4|                            break;
  102|      4|            Self::from_sorted_iter(merged.into_iter())
  102|      4|            Self::from_sorted_iter(merged.into_iter())
  102|      4|            Self::from_sorted_iter(merged.into_iter())
  102|      4|            Self::from_sorted_iter(merged.into_iter())
  102|      4|                        Self::rotate_right(link);
  102|      5|            }
  102|      5|            }
  102|      5|    }
  102|  5.13k|    }
  102|     55|            }
  102|  5.81k|                        return;
  102|  6.97k|                        inserted
  102|      6|            false
  102|      6|            Self::from_sorted_iter(merged.into_iter())
  102|      6|        total
  102|      7|            }
  102|      7|        }
  102|      7|        }
  102|     76|        }
  102|     82|        where
  102|      9|            Self::from_sorted_iter(merged.into_iter())
  103|       |
  103|       |
  103|       |
  103|       |
  103|       |
  103|       |
  103|       |
  103|       |
  103|       |
  103|       |
  103|       |
  103|       |
  103|       |
  103|       |
  103|       |
  103|       |
  103|       |
  103|       |
  103|       |
  103|       |
  103|       |
  103|       |
  103|       |
  103|       |
  103|       |
  103|       |
  103|       |
  103|       |
  103|       |
  103|       |
  103|       |                    ));
  103|       |                    }
  103|       |                }
  103|       |            ));
  103|       |            {
  103|       |            }
  103|       |            }
  103|       |        ///
  103|       |        ///
  103|       |        {
  103|       |        }
  103|       |    ///
  103|      0|                }
  103|      1|            });
  103|      1|        }
  103|      1|        }
  103|     10|                    return;
  103|     10|            return;
  103|    122|            };
  103|  1.52k|            }
  103|    162|                        Some(&node.key)
  103|      1|            ArraySeqStPerS::from_vec(out)
  103|      1|        println!(
  103|      1|        shared.load(Ordering::Relaxed)
  103|      2|                }
  103|     20|        }
  103|     20|        }
  103|    216|            vals.dedup();
  103|     23|        }
  103|     28|        }
  103|      2|        assert!(union_result.find(&7));
  103|      2|                identity,
  103|      2|            result
  103|      2|            valid_values
  103|      3|            }
  103|      4|            }
  103|      4|        }
  103|      4|        }
  103|      4|        }
  103|      4|        }
  103|    487|        }
  103|      5|                    }
  103|      5|        }
  103|      5|        }
  103|  5.81k|                    }
  103|    596|                        }
  103|      5|            None
  103|      6|        }
  103|      6|    }
  103|      8|        }
  103|      9|        }
  104|       |
  104|       |
  104|       |
  104|       |
  104|       |
  104|       |
  104|       |
  104|       |
  104|       |
  104|       |
  104|       |
  104|       |
  104|       |
  104|       |
  104|       |
  104|       |
  104|       |
  104|       |
  104|       |
  104|       |
  104|       |
  104|       |
  104|       |
  104|       |
  104|       |
  104|       |
  104|       |
  104|       |
  104|       |
  104|       |
  104|       |                    }
  104|       |            {
  104|       |            }
  104|       |            }
  104|       |            };
  104|       |        {
  104|       |    ///
  104|       |    ///
  104|       |    ///
  104|       |    }
  104|      0|                }
  104|      0|                }
  104|      0|        }
  104|      0|                clusters.push(current_cluster_size);
  104|      0|                continue;
  104|      0|            None
  104|      0|        where
  104|      1|            }
  104|      1|            }
  104|      1|        }
  104|      1|    }
  104|    105|                }
  104|      2|            }
  104|      2|        }
  104|      2|        }
  104|     20|        }
  104|     21|        where
  104|    222|                }
  104|     26|                });
  104|     27|                }
  104|      2|        assert!(union_result.find(&8));
  104|      3|        }
  104|      4|            }
  104|     46|        }
  104|    472|            ArraySeqStPerS::from_vec(values)
  104|      4|                    break;
  104|      5|            }
  104|      5|            }
  104|      6|                }
  104|  7.83k|        }
  104|      7|            self.vertices.insert(u.clone());
  104|      9|        }
  104|      9|                continue;
  104|      9|                    inserted
  105|       |
  105|       |
  105|       |
  105|       |
  105|       |
  105|       |
  105|       |
  105|       |
  105|       |
  105|       |
  105|       |
  105|       |
  105|       |
  105|       |
  105|       |
  105|       |
  105|       |
  105|       |
  105|       |
  105|       |                {
  105|       |                }
  105|       |                }
  105|       |            }
  105|       |            }
  105|       |        {
  105|       |    ///
  105|       |    }
  105|       |    }
  105|       |    }
  105|       |}
  105|      0|                }
  105|      0|                }
  105|      0|                left_result.union(&right_result)
  105|      1|                    }
  105|      1|            }
  105|      1|        }
  105|      1|        }
  105|     10|                }
  105|  1.11k|        }
  105|     18|            }
  105|     19|                Some(strategy.analyze_primary_clustering(table))
  105|      1|            edges
  105|      1|            table_mt.size()
  105|      2|        }
  105|     20|        }
  105|     21|            }
  105|    217|                }
  105|    240|        }
  105|     25|            }
  105|      2|        assert!(union_result.find(&9));
  105|     38|            }
  105|      4|        }
  105|    472|        }
  105|      5|        }
  105|      5|        }
  105|      5|                a
  105|      7|            self.vertices.insert(v.clone());
  105|      8|            }
  105|       |        where
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |
  106|       |                        ..
  106|       |                    }
  106|       |                }
  106|       |            }
  106|       |            }
  106|       |            }
  106|       |        );
  106|       |        ///
  106|       |        {
  106|       |        {
  106|       |    ///
  106|       |    }
  106|       |    }
  106|      0|            }
  106|      0|            }
  106|      0|            }
  106|      0|        }
  106|      0|                return;
  106|      1|                }
  106|      1|        }
  106|    104|                    result.push(elem.clone());
  106|     10|                .into_iter()
  106|    111|            }
  106|    117|            }
  106|     14|    }
  106|     18|        }
  106|      1|            self.adj.delete(&v_clone);
  106|      1|        where
  106|      2|                }
  106|      2|                }
  106|      2|            }
  106|    216|            }
  106|     25|        }
  106|      2|        assert!(union_result.find(&11));
  106|      2|            self.labeled_edges()
  106|      4|        }
  106|    423|        }
  106|     46|        }
  106|    463|                        Self::update(right);
  106|      5|            }
  106|    608|                        true
  106|     78|                }
  106|      9|                keys.insert(left_keys.nth_cloned(i));
  107|       |
  107|       |
  107|       |
  107|       |
  107|       |
  107|       |
  107|       |
  107|       |
  107|       |
  107|       |
  107|       |
  107|       |
  107|       |
  107|       |
  107|       |
  107|       |
  107|       |
  107|       |
  107|       |
  107|       |                    }
  107|       |                    },
  107|       |                }
  107|       |                },
  107|       |            }
  107|       |            }
  107|       |            }
  107|       |            }
  107|       |    ///
  107|       |    }
  107|       |    }
  107|       |    }
  107|       |    }
  107|      0|                None
  107|      1|            }
  107|      1|        }
  107|      1|        }
  107|      1|        }
  107|     10|                }
  107|    104|                }
  107|    104|                result.push(element);
  107|    110|        }
  107|     13|        }
  107|  1.32k|        }
  107|     14|            }
  107|    158|            }
  107|    167|            {
  107|      2|            }
  107|      2|        }
  107|     20|        component.insert(vertex);
  107|     21|                    })
  107|     21|                    })
  107|     21|            }
  107|    216|        }
  107|     23|            }
  107|      2|        assert!(union_result.find(&14));
  107|      2|                .iter()
  107|    463|                    }
  107|      4|            path.push(current);
  107|      5|        }
  107|     55|            result
  107|      5|                multiset,
  107|     63|                true
  107|     67|                }
  107|      7|        }
  107|      7|        }
  107|      7|        }
  107|     89|        }
  107|      9|            }
  107|       |    #[macro_export]
  107|       |    #[macro_export]
  108|       |
  108|       |
  108|       |
  108|       |
  108|       |
  108|       |
  108|       |
  108|       |
  108|       |
  108|       |
  108|       |
  108|       |
  108|       |
  108|       |
  108|       |
  108|       |
  108|       |
  108|       |
  108|       |
  108|       |
  108|       |
  108|       |
  108|       |
  108|       |
  108|       |
  108|       |
  108|       |
  108|       |        
  108|       |                    }
  108|       |                }
  108|       |                }
  108|       |            }
  108|       |            }
  108|       |            }
  108|       |            }
  108|       |            }
  108|       |            }
  108|       |            }
  108|       |            }
  108|       |            };
  108|       |        {
  108|       |        }
  108|       |    }
  108|      0|                    });
  108|      0|        }
  108|      0|            false
  108|      1|        }
  108|      1|        }
  108|  1.00k|                },
  108|    104|            }
  108|     11|                    new_adj_vec.push(new_neighbors.clone());
  108|     13|            false
  108|      1|            count
  108|      2|        }
  108|     21|                }
  108|     21|                })
  108|     21|                })
  108|     21|                        Self::rotate_right(link);
  108|     22|        }
  108|     23|            }
  108|     27|        }
  108|      2|        assert!(union_result.find(&17));
  108|      2|                reducer,
  108|      3|                    }
  108|    360|                        .right
  108|      4|                .tree
  108|      4|                .tree
  108|      4|                .tree
  108|      4|                .tree
  108|     61|                }
  108|      6|                .tree
  108|      7|    }
  108|     71|                }
  108|     80|        }
  108|    901|                }
  108|      9|                .tree
  109|       |
  109|       |
  109|       |
  109|       |
  109|       |
  109|       |
  109|       |
  109|       |
  109|       |
  109|       |
  109|       |
  109|       |
  109|       |
  109|       |
  109|       |
  109|       |
  109|       |
  109|       |
  109|       |
  109|       |
  109|       |
  109|       |
  109|       |
  109|       |                }
  109|       |                }
  109|       |            }
  109|       |            }
  109|       |            }
  109|       |            }
  109|       |        }
  109|       |    ///
  109|       |    ///
  109|       |    }
  109|       |}
  109|      0|            ArraySeqStPerS::from_vec(out)
  109|      1|                }
  109|      1|            }
  109|      1|        }
  109|      1|        }
  109|     10|                    neighbors.insert(labeled_arc.1.clone());
  109|    113|            }
  109|    117|                    Some(&inner.value)
  109|     11|                keys.insert(right_keys.nth_cloned(i));
  109|     11|                    Self::update(x.right.as_mut().unwrap());
  109|     13|        }
  109|     13|                .collect();
  109|     16|                .collect();
  109|     19|        }
  109|     19|                false
  109|      1|            path.push(current);
  109|      1|        table_after_delete
  109|     21|            }
  109|     25|                        continue;
  109|     27|                .into_iter()
  109|     28|                    }
  109|      2|                identity,
  109|      3|        }
  109|     30|                source,
  109|     31|        }
  109|    360|                        .as_ref()
  109|      3|            None
  109|      3|                    result.insert(elem.clone());
  109|      3|                self.entries.length(),
  109|      4|                }
  109|      4|                .in_order()
  109|      4|                .in_order()
  109|      4|                .in_order()
  109|      4|                .in_order()
  109|      4|                visited_edges.insert(edge_key);
  109|      5|            }
  109|     51|        }
  109|  5.12k|                }
  109|  5.17k|            }
  109|    520|        }
  109|      5|                        s.insert(b.clone_mt());
  109|      6|                        continue;
  109|      6|                .in_order()
  109|     70|        }
  109|  7.58k|            }
  109|     76|                        Self::rotate_right(link);
  109|      8|        }
  109|      8|        }
  109|    861|                }
  109|      8|                frontier.insert(entry);
  109|      9|                .in_order()
  109|       |    #[macro_export]
  110|       |
  110|       |
  110|       |
  110|       |
  110|       |
  110|       |
  110|       |
  110|       |
  110|       |
  110|       |
  110|       |
  110|       |
  110|       |
  110|       |
  110|       |
  110|       |
  110|       |
  110|       |
  110|       |
  110|       |
  110|       |
  110|       |
  110|       |
  110|       |
  110|       |
  110|       |
  110|       |                    ));
  110|       |                {
  110|       |            );
  110|       |            }
  110|       |            }
  110|       |            }
  110|       |            }
  110|       |            }
  110|       |            }
  110|       |        }
  110|       |        }
  110|       |    }
  110|       |    }
  110|       |    }
  110|       |    }
  110|       |    }
  110|       |            $crate::Chap06::LabUnDirGraphStEph::LabUnDirGraphStEph::LabUnDirGraphStEph::empty()
  110|      0|            }
  110|      0|        }
  110|      0|                left_result.union(&right_result)
  110|      1|            }
  110|      1|        }
  110|      1|        }
  110|      1|    }
  110|     10|            t
  110|     11|            }
  110|  11.4k|                }
  110|    118|            result.sort();
  110|     13|        }
  110|     15|                }
  110|     15|        }
  110|    167|            }
  110|     16|            result
  110|     18|            }
  110|      2|            }
  110|      2|        }
  110|      2|        }
  110|    235|            neighbors
  110|     26|                })
  110|    266|                    }
  110|     27|                .zip(probs.into_iter())
  110|     30|                    new_adj_vec.push(self.adj.nth(i).clone());
  110|     30|                target,
  110|     33|        }
  110|     37|            }
  110|      4|                }
  110|      4|                .iter()
  110|      4|                .iter()
  110|      4|                .iter()
  110|      4|                .iter()
  110|      5|        }
  110|      5|                        break;
  110|      6|        }
  110|     64|                    }
  110|      6|                .iter()
  110|     79|                    xm
  110|      7|        println!("]");
  110|      8|            }
  110|     80|                    }
  110|      9|                .iter()
  111|       |
  111|       |
  111|       |
  111|       |
  111|       |
  111|       |
  111|       |
  111|       |
  111|       |
  111|       |
  111|       |
  111|       |
  111|       |
  111|       |
  111|       |
  111|       |
  111|       |
  111|       |
  111|       |
  111|       |
  111|       |
  111|       |
  111|       |
  111|       |
  111|       |
  111|       |
  111|       |
  111|       |
  111|       |            }
  111|       |            }
  111|       |        }
  111|       |        }
  111|       |        }};
  111|       |        }};
  111|       |    ///
  111|       |    }
  111|       |    }
  111|       |    }
  111|       |}
  111|      0|            }
  111|      0|                        new_neighbors_vec.push(neighbor);
  111|      0|                self.clone()
  111|     10|        }
  111|  1.00k|        }
  111|    106|                    {
  111|     10|                .collect();
  111|  11.0k|                Self::update(node);
  111|    122|            result
  111|     14|    }
  111|     16|        }
  111|     19|        result
  111|      1|        keys.insert(10);
  111|      2|        }
  111|     20|            vertices.insert(i);
  111|     21|        }
  111|     23|        }
  111|    235|        }
  111|     25|                v
  111|      2|                    neighbors.delete(&v_clone);
  111|     30|                }
  111|     37|                        }
  111|  3.86k|                            xm
  111|      4|    }
  111|     49|                    }
  111|      4|                dimensions,
  111|      4|            keys
  111|      4|                tour.push(current.clone());
  111|      5|        (
  111|     50|    }
  111|     68|                    })
  111|      7|                    }
  111|      7|        println!(")");
  111|    807|                Self::update(node);
  111|  8.09k|                }
  111|     82|        }
  111|    907|        }
  112|       |
  112|       |
  112|       |
  112|       |
  112|       |
  112|       |
  112|       |
  112|       |
  112|       |
  112|       |
  112|       |
  112|       |
  112|       |
  112|       |
  112|       |
  112|       |
  112|       |
  112|       |
  112|       |
  112|       |
  112|       |
  112|       |
  112|       |
  112|       |
  112|       |
  112|       |
  112|       |
  112|       |
  112|       |                        ..
  112|       |                    }
  112|       |                }
  112|       |            }
  112|       |            }
  112|       |            }
  112|       |            }
  112|       |}
  112|       |}
  112|       |            $crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::LabDirGraphStEph::empty()
  112|      0|                }
  112|      0|                }
  112|      0|            }
  112|      0|                left_result.union(&right_result)
  112|      1|                    }
  112|      1|            }
  112|    106|                        Self::rotate_left(link);
  112|    114|                    })
  112|    117|            values.remove(0);
  112|     11|            neighbors
  112|    122|        }
  112|     14|                },
  112|     15|                }
  112|    167|            result
  112|     19|    }
  112|      1|        keys.insert(20);
  112|      2|            }
  112|     20|        }
  112|     20|        }
  112|     21|            self.memo.clear();
  112|     26|                    x0
  112|     27|                .collect();
  112|      2|            result
  112|      3|        }
  112|     30|            }
  112|    307|        }
  112|     38|        }
  112|     39|                    .collect();
  112|      4|            }
  112|    446|            }
  112|      5|        }
  112|     54|                hash1,
  112|      6|                }
  112|    613|        }
  112|     67|    }
  112|     69|                }
  112|      7|                values.push(f(&a.nth_cloned(i)));
  113|       |
  113|       |
  113|       |
  113|       |
  113|       |
  113|       |
  113|       |
  113|       |
  113|       |
  113|       |
  113|       |
  113|       |
  113|       |
  113|       |
  113|       |
  113|       |
  113|       |
  113|       |
  113|       |
  113|       |
  113|       |
  113|       |
  113|       |
  113|       |
  113|       |
  113|       |
  113|       |                    },
  113|       |                }
  113|       |            }
  113|       |            }
  113|       |            }
  113|       |            }
  113|       |        }
  113|       |        }};
  113|       |    }
  113|       |    }
  113|      0|            }
  113|      0|            }
  113|      0|            }
  113|      1|                }
  113|      1|            }
  113|      1|        }
  113|      1|        }
  113|      1|        }
  113|      1|    }
  113|     11|                }
  113|     11|        }
  113|  1.13k|                        .right
  113|    118|            }
  113|     12|        where
  113|  1.53k|                values.push(f(i));
  113|  17.2k|                    }
  113|     18|        }
  113|  1.88k|                            x0
  113|      1|            ArraySeqS::from_vec(data)
  113|      1|        keys.insert(30);
  113|      2|            }
  113|      2|        }
  113|      2|        }
  113|     23|        }
  113|    230|        }
  113|    254|                    }
  113|     27|        }
  113|     30|        }
  113|    308|        where
  113|     39|            out
  113|      4|            }
  113|     47|                        Some(v.clone())
  113|      4|                    break;
  113|      4|                key_seq.length(),
  113|      4|                        Some(v.clone())
  113|      4|                        Some(v.clone())
  113|      4|                        Some(v.clone())
  113|      4|                        Some(v.clone())
  113|      4|    where
  113|     54|                hash2,
  113|      5|            dummy_idx,
  113|      5|                        s.insert(a.clone_mt());
  113|      5|                        Some(v.clone())
  113|     60|                    .collect();
  113|      7|            }
  113|     71|                    (0..l)
  113|      9|        }
  113|      9|    }
  114|       |
  114|       |
  114|       |
  114|       |
  114|       |
  114|       |
  114|       |
  114|       |
  114|       |
  114|       |
  114|       |
  114|       |
  114|       |
  114|       |
  114|       |
  114|       |
  114|       |
  114|       |
  114|       |
  114|       |
  114|       |
  114|       |
  114|       |
  114|       |
  114|       |
  114|       |
  114|       |
  114|       |
  114|       |
  114|       |
  114|       |                }
  114|       |                }
  114|       |            );
  114|       |            {
  114|       |            }
  114|       |            };
  114|       |        }
  114|       |    }
  114|       |    }
  114|       |    }
  114|       |    }
  114|       |    }
  114|       |}
  114|       |}
  114|      0|                }
  114|      1|            }
  114|      1|        }
  114|      1|        }
  114|     10|                }
  114|     10|    }
  114|     10|                dimensions,
  114|     11|            }
  114|  1.13k|                        .as_ref()
  114|    118|        }
  114|     11|                path.push(pred);
  114|  1.53k|            }
  114|    167|        }
  114|      1|            false
  114|      1|            path.push(current);
  114|      1|        where
  114|      2|            }
  114|     23|        }
  114|  2.62k|                        .right
  114|      2|            ArraySeqMtEphS::from_vec(values)
  114|     30|            }
  114|     30|    }
  114|    360|                    inserted
  114|     39|        }
  114|      4|        }
  114|      4|        }
  114|    463|        }
  114|      5|        )
  114|      6|    }
  114|      6|            false
  114|      6|                source,
  114|      6|                    xl
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |
  115|       |        
  115|       |                {
  115|       |                }
  115|       |                };
  115|       |            }
  115|       |            }
  115|       |            }
  115|       |        {
  115|       |        {
  115|       |    {
  115|       |    {
  115|       |}
  115|      0|                    });
  115|      0|            }
  115|      0|        }
  115|      1|            }
  115|      1|        }
  115|      1|        }
  115|     10|        }
  115|    104|                    }
  115|     11|            }
  115|     11|            }
  115|     11|        }
  115|    120|            ArraySeqMtPerS::from_vec(values)
  115|     12|                        None
  115|     14|        }
  115|      2|            }
  115|      2|            }
  115|      2|            }
  115|      2|        }
  115|     20|    }
  115|     24|                    self.insert(elem.clone());
  115|  2.62k|                        .as_ref()
  115|      3|                }
  115|     39|                self.parallel_min_reduction(costs)
  115|      3|        star_contract(
  115|    420|                probe_sequence.push(pos);
  115|     43|        }
  115|      5|    }
  115|     53|                        None
  115|     60|                            xl
  115|      6|                        None
  115|      6|                        None
  115|      6|                        None
  115|      6|                        None
  115|      6|                target,
  115|      8|            }
  116|       |
  116|       |
  116|       |
  116|       |
  116|       |
  116|       |
  116|       |
  116|       |
  116|       |
  116|       |
  116|       |
  116|       |
  116|       |
  116|       |
  116|       |
  116|       |
  116|       |                        }
  116|       |                    }
  116|       |                    }
  116|       |                    }
  116|       |                    }
  116|       |                    }
  116|       |                    }
  116|       |                    }
  116|       |                    };
  116|       |                };
  116|       |            {
  116|       |            }
  116|       |            }
  116|       |            };
  116|       |        {
  116|       |        }
  116|       |        }};
  116|       |    ///
  116|       |    }
  116|      0|                }
  116|      1|            }
  116|      1|        }
  116|     10|            }
  116|  10.6k|            out.push(n.value.clone());
  116|     11|        }
  116|     11|        }
  116|    112|        }
  116|    117|            };
  116|     12|        }
  116|    120|        }
  116|    143|            }
  116|      1|            builder.complex_query(
  116|     21|        }
  116|     24|                }
  116|    244|                    {
  116|     25|                }
  116|      3|            }
  116|      3|            graph,
  116|      3|                path.push(pred);
  116|  44.2k|        where
  116|     51|        merged
  116|     56|        }
  116|      6|                        }
  116|    674|                out.push(node.key.clone());
  116|      8|        }
  116|       |    #[macro_export]
  117|       |
  117|       |
  117|       |
  117|       |
  117|       |
  117|       |
  117|       |
  117|       |
  117|       |
  117|       |
  117|       |
  117|       |
  117|       |
  117|       |
  117|       |
  117|       |
  117|       |
  117|       |
  117|       |
  117|       |                    };
  117|       |                },
  117|       |            }
  117|       |            }
  117|       |    ///
  117|       |    ///
  117|       |    }
  117|       |    }
  117|       |    }
  117|      0|                left_result.union(&right_result)
  117|      1|        }
  117|     10|                })
  117|     10|                })
  117|     10|                })
  117|     10|                })
  117|     10|        }
  117|    100|                })
  117|    102|                        }
  117|    108|                }
  117|    122|    }
  117|    154|                }
  117|     16|                        }
  117|     17|                })
  117|     18|        }
  117|      1|                &"fun".to_string(),
  117|      1|            path.push(current);
  117|      1|            self.labeled_arcs()
  117|      1|            write!(
  117|      2|            }
  117|     23|                frontier.delete(&entry);
  117|    244|                }
  117|    244|                        Self::rotate_left(link);
  117|     27|            }
  117|     29|            self.memo.clear();
  117|      4|        }
  117|      4|        result.visited
  117|      5|            }
  117|  5.11k|    }
  117|     54|            }
  117|      6|            }
  117|      7|            }
  117|      7|    }
  117|    730|                    {
  117|  7.45k|            out.push(n.value.clone());
  117|      7|                multiset,
  118|       |
  118|       |
  118|       |
  118|       |
  118|       |
  118|       |
  118|       |
  118|       |
  118|       |
  118|       |
  118|       |
  118|       |
  118|       |
  118|       |
  118|       |
  118|       |
  118|       |
  118|       |
  118|       |
  118|       |
  118|       |
  118|       |
  118|       |                );
  118|       |                }
  118|       |            }
  118|       |            }
  118|       |            }
  118|       |        {
  118|       |        }
  118|       |        }};
  118|       |    ///
  118|       |    }
  118|       |}
  118|      0|                    }
  118|      0|                    }
  118|      0|                }
  118|      0|            }
  118|      1|            }
  118|      1|            }
  118|     10|                .into_iter()
  118|     11|            }
  118|  11.3k|        }
  118|     12|            }
  118|     15|        }
  118|      1|                f,
  118|      1|                .iter()
  118|      1|                &"party".to_string(),
  118|      1|        where
  118|      2|                }
  118|  2.23k|            link.as_ref()
  118|     27|        }
  118|     28|                }
  118|  2.90k|        }
  118|      3|        }
  118|      3|        }
  118|     36|                }
  118|      4|    }
  118|      4|                .collect();
  118|      4|                .collect();
  118|      4|                .collect();
  118|      4|                .collect();
  118|      4|            path.reverse();
  118|      4|                visited_edges.insert(edge_key);
  118|     54|        }
  118|      5|                    combined.extend(right.into_vec());
  118|      6|        }
  118|      6|                .collect();
  118|      7|        }
  118|    720|            }
  118|    730|                        Self::rotate_left(link);
  118|    886|                    }
  118|      9|                .collect();
  119|       |
  119|       |
  119|       |
  119|       |
  119|       |
  119|       |
  119|       |
  119|       |
  119|       |
  119|       |
  119|       |
  119|       |
  119|       |
  119|       |
  119|       |
  119|       |
  119|       |
  119|       |
  119|       |
  119|       |
  119|       |
  119|       |
  119|       |
  119|       |
  119|       |
  119|       |            
  119|       |                }
  119|       |                },
  119|       |            }
  119|       |            }
  119|       |            }
  119|       |            }
  119|       |            };
  119|       |        )
  119|       |    }
  119|       |}
  119|       |}
  119|       |}
  119|      0|    }
  119|      0|            None
  119|    104|                    Self::rotate_right(link);
  119|    118|        }
  119|  1.39k|        }
  119|     16|                        i64::MAX
  119|     16|                    Self::rotate_right(link);
  119|  1.89k|                    }
  119|      1|                &"chess".to_string(),
  119|      2|                }
  119|      2|        }
  119|     21|            }
  119|     21|            }
  119|  22.0k|    }
  119|    226|            self.node_at(index)
  119|    253|            }
  119|     29|            }
  119|     29|                        OrderedF64::from(f64::INFINITY)
  119|      2|                Ok(self)
  119|    388|                }
  119|     43|                }
  119|      4|            Self::from_sorted_iter(filtered.into_iter())
  119|      4|            Self::from_sorted_iter(filtered.into_iter())
  119|      4|            Self::from_sorted_iter(filtered.into_iter())
  119|      4|            Self::from_sorted_iter(filtered.into_iter())
  119|      4|            Some(ArraySeqStPerS::from_vec(path))
  119|     53|                        vals.push(elem.clone());
  119|     55|        }
  119|  5.50k|                }
  119|    554|                            *ra,
  119|      5|                    PrimTreeSeqStS::from_vec(combined)
  119|      6|            }
  119|     64|                    }
  119|      6|            Self::from_sorted_iter(filtered.into_iter())
  119|      7|            }
  119|     70|            {
  119|      7|            self.base_table.delete(k);
  119|      8|            }
  119|      8|            }
  119|     80|                    }
  119|  8.01k|        }
  119|      9|            ArraySeqMtEphSliceS::from_vec(data)
  119|      9|            false
  119|      9|                    neighbors.insert(labeled_arc.0.clone());
  119|      9|            Self::from_sorted_iter(filtered.into_iter())
  120|       |
  120|       |
  120|       |
  120|       |
  120|       |
  120|       |
  120|       |
  120|       |
  120|       |
  120|       |
  120|       |
  120|       |
  120|       |
  120|       |
  120|       |
  120|       |
  120|       |
  120|       |                }
  120|       |                }
  120|       |                }
  120|       |                }
  120|       |            }
  120|       |            }
  120|       |            }
  120|       |        {
  120|       |        }
  120|       |        }
  120|       |    ///
  120|       |    ///
  120|       |}
  120|      0|        }
  120|      0|            None
  120|      1|            }
  120|      1|            }
  120|     11|                }
  120|     11|                    new_row_vec.push(exists);
  120|    122|                        neighbors.insert(labeled_arc.1.clone_mt());
  120|     13|        }
  120|  1.46k|                    doc_vec.push(doc_id.clone());
  120|  1.49k|                }
  120|  15.4k|    }
  120|     16|        }
  120|     16|        }
  120|     19|                load_factor,
  120|      1|                &"food".to_string(),
  120|      1|            path.push(current);
  120|      1|            path.reverse();
  120|      1|            write!(
  120|  2.23k|        }
  120|     23|                visited.insert(v.clone());
  120|     29|                }
  120|      2|        assert!(set_from_seq.find(&2));
  120|      2|        matching
  120|      3|                }
  120|      3|        }
  120|      3|    }
  120|     30|    }
  120|     38|                    result.insert(elem.clone());
  120|      3|                        new_row_vec.push(false);
  120|      4|        }
  120|      4|        }
  120|      4|        }
  120|      4|        }
  120|    420|                unique_positions.insert(pos);
  120|      4|                tour.push(current.clone());
  120|      5|        }
  120|      6|        }
  120|     64|                    }
  120|      7|                }
  120|      7|        }
  120|      7|        }
  120|      7|            old_value
  120|     85|        }
  120|      9|        }
  120|      9|        }
  120|     93|        }
  120|       |                self.multiset,
  121|       |
  121|       |
  121|       |
  121|       |
  121|       |
  121|       |
  121|       |
  121|       |
  121|       |
  121|       |
  121|       |
  121|       |
  121|       |
  121|       |
  121|       |
  121|       |
  121|       |
  121|       |
  121|       |
  121|       |
  121|       |
  121|       |
  121|       |
  121|       |
  121|       |
  121|       |
  121|       |
  121|       |
  121|       |                    }
  121|       |                }
  121|       |                };
  121|       |            )
  121|       |            }
  121|       |            }
  121|       |            }
  121|       |            }
  121|       |            }
  121|       |            }
  121|       |        }};
  121|       |    }
  121|       |    }
  121|       |}
  121|       |}
  121|       |}
  121|      0|                }
  121|      0|            }
  121|      0|            }
  121|      1|            }
  121|      1|        }
  121|      1|        }
  121|      1|        }
  121|  1.18k|                    Self::update(node);
  121|     12|            {
  121|  1.46k|                }
  121|     14|                    ns.insert(v.clone());
  121|    172|            }
  121|    181|                    neighbors.insert(labeled_edge.1.clone());
  121|     19|        }
  121|     19|                primary_clustering,
  121|      1|                f,
  121|      1|                self.memo.len()
  121|      1|            Some(ArraySeqStPerS::from_vec(path))
  121|      2|            }
  121|      2|            }
  121|      2|    }
  121|    217|                result.extend(right_filtered);
  121|     23|                        Self::rotate_right(link);
  121|      2|        assert!(set_from_seq.find(&7));
  121|    308|        }
  121|     32|        }
  121|    354|                    }
  121|    364|                }
  121|     37|                        }
  121|      3|                path.push(pred);
  121|      4|            }
  121|  4.67k|                    self.table.nth(i).clone()
  121|     51|                }
  121|     56|            result
  121|     63|                    })
  121|      7|        }
  121|     80|                            node.left.clone()
  121|  9.11k|                }
  121|      9|        where
  122|       |
  122|       |
  122|       |
  122|       |
  122|       |
  122|       |
  122|       |
  122|       |
  122|       |
  122|       |
  122|       |
  122|       |
  122|       |
  122|       |
  122|       |
  122|       |        
  122|       |                    }
  122|       |                }
  122|       |                };
  122|       |            )
  122|       |            }
  122|       |            }
  122|       |            }
  122|       |            }
  122|       |        }
  122|       |        }
  122|       |        }
  122|       |        }
  122|       |    }
  122|       |}
  122|       |}
  122|      0|                }
  122|      1|            }
  122|      1|        }
  122|      1|        }
  122|     10|            }
  122|     10|            neighbors
  122|  1.18k|                }
  122|     14|            }
  122|     14|                    ns
  122|    172|        }
  122|      1|            path.push(current);
  122|      1|            path.push(current);
  122|      2|            }
  122|      2|        }
  122|    217|                result
  122|    226|        }
  122|     24|                })
  122|     28|                    new_row_vec.push(*old_row.nth(j));
  122|  2.97k|                    Self::update(node);
  122|      2|        assert!(set_from_seq.find(&8));
  122|     33|                    }
  122|     35|                    .collect();
  122|     47|                    }
  122|      4|    where
  122|      5|            }
  122|    501|            false
  122|     56|        }
  122|     56|        }
  122|      6|                        new_row_vec.push(!*row.nth(j));
  122|      7|        }
  122|     70|            }
  122|  74.1k|            }
  122|     79|        }
  122|     96|            {
  123|       |
  123|       |
  123|       |
  123|       |
  123|       |
  123|       |
  123|       |
  123|       |
  123|       |
  123|       |
  123|       |
  123|       |
  123|       |
  123|       |
  123|       |
  123|       |
  123|       |
  123|       |
  123|       |
  123|       |
  123|       |
  123|       |
  123|       |
  123|       |
  123|       |                    }
  123|       |                    }
  123|       |                }
  123|       |                },
  123|       |                };
  123|       |            }
  123|       |            }
  123|       |            }
  123|       |        {
  123|       |        }
  123|       |        }
  123|       |        }};
  123|       |    ///
  123|       |    }
  123|       |    }
  123|       |    }
  123|       |    }
  123|       |    }
  123|       |    }
  123|      1|            }
  123|      1|        }
  123|     10|        }
  123|     10|                .collect();
  123|     10|        where
  123|     12|                memo_guard.clear();
  123|     15|        }
  123|    172|                    neighbors.insert(labeled_edge.0.clone());
  123|      1|        true
  123|      2|        }
  123|     28|                }
  123|     29|        }
  123|  2.97k|                }
  123|      2|        assert!(set_from_seq.find(&11));
  123|      3|                }
  123|      4|        }
  123|     40|            inn
  123|    437|            }
  123|  44.2k|            out
  123|    595|                            node.right.clone()
  123|      5|                Some(b.nth(offset).clone())
  123|      6|                    }
  123|      6|    }
  123|     62|            result
  123|      6|                    break;
  123|    724|        }
  123|      8|            self.base_table.delete(k);
  123|       |                self.source,
  123|       |        where
  124|       |
  124|       |
  124|       |
  124|       |
  124|       |
  124|       |
  124|       |
  124|       |
  124|       |
  124|       |
  124|       |
  124|       |
  124|       |
  124|       |
  124|       |
  124|       |
  124|       |
  124|       |
  124|       |
  124|       |
  124|       |                        };
  124|       |                }
  124|       |                }
  124|       |            }
  124|       |            }
  124|       |    {
  124|       |    }
  124|       |    }
  124|       |    }
  124|       |    }
  124|       |}
  124|      0|            }
  124|      0|        where
  124|      1|        }
  124|      1|        }
  124|      1|    }
  124|     10|                }
  124|    110|                        }
  124|     12|            }
  124|  1.21k|                        }
  124|     15|            vertices.insert(i);
  124|    179|                    })
  124|      1|                        false
  124|      1|                hash1,
  124|      1|            path.push(current);
  124|      1|        true
  124|      2|                    }
  124|      2|            }
  124|      2|    }
  124|     20|    }
  124|     25|                    }
  124|     25|            }
  124|     37|        result
  124|      3|                path.push(pred);
  124|     40|        }
  124|  44.2k|        }
  124|     47|        result
  124|  4.85k|                }
  124|    487|        }
  124|     51|                },
  124|     62|        }
  124|    674|            }
  124|     70|            result
  124|     75|                };
  124|     86|                },
  124|      8|            old_value
  124|      9|        }
  124|       |                self.target,
  125|       |
  125|       |
  125|       |
  125|       |
  125|       |
  125|       |
  125|       |
  125|       |
  125|       |
  125|       |
  125|       |
  125|       |
  125|       |
  125|       |
  125|       |
  125|       |
  125|       |
  125|       |
  125|       |
  125|       |
  125|       |
  125|       |
  125|       |                    };
  125|       |                }
  125|       |                }
  125|       |            }
  125|       |            }
  125|       |            }
  125|       |            },
  125|       |            };
  125|       |        {
  125|       |    }
  125|      0|                    }
  125|      0|                    }
  125|      0|                }
  125|      0|            }
  125|      1|            }
  125|      1|            }
  125|      1|        }
  125|      1|    }
  125|  1.02k|                },
  125|  11.0k|            }
  125|    146|        }
  125|     15|        }
  125|     15|                n,
  125|     16|                        }
  125|     18|                }
  125|     19|                performance_impact,
  125|      1|                hash2,
  125|      1|                None
  125|      1|            path.reverse();
  125|      1|                self.memo.len()
  125|      1|        table
  125|      2|            }
  125|      2|        }
  125|      2|        }
  125|    200|                }
  125|    233|        }
  125|     25|        }
  125|     28|                n,
  125|      2|                Some(b.nth_cloned(offset))
  125|     32|            }
  125|     32|            }
  125|    326|            }
  125|     35|                self.parallel_min_reduction(costs)
  125|     37|    }
  125|      3|                new_matrix_vec.push(ArraySeqStEphS::from_vec(new_row_vec));
  125|      3|            self.memo.clear();
  125|      3|                .tree
  125|      3|                .tree
  125|      3|                .tree
  125|     47|    }
  125|      4|        result
  125|      4|                .tree
  125|      4|                .tree
  125|      4|        true
  125|      5|        (
  125|    554|                            },
  125|     60|            }
  125|    675|                        drop(guard);
  125|     71|                    .collect();
  125|  7.88k|        }
  125|      7|                .tree
  125|      8|        }
  125|     85|                result.push(element);
  125|      9|            {
  125|     96|            }
  125|       |    #[macro_export]
  125|       |    #[macro_export]
  126|       |
  126|       |
  126|       |
  126|       |
  126|       |
  126|       |
  126|       |
  126|       |
  126|       |
  126|       |
  126|       |
  126|       |
  126|       |
  126|       |
  126|       |
  126|       |
  126|       |
  126|       |
  126|       |
  126|       |
  126|       |
  126|       |
  126|       |
  126|       |                        );
  126|       |                    }
  126|       |                    };
  126|       |            )
  126|       |            );
  126|       |            );
  126|       |            }
  126|       |            }
  126|       |            }
  126|       |            }
  126|       |            };
  126|       |        {
  126|       |        }
  126|       |        }
  126|       |    ///
  126|       |    ///
  126|       |    }
  126|       |}
  126|       |}
  126|       |}
  126|       |}
  126|      1|        }
  126|      1|        }
  126|      1|    }
  126|  1.02k|            }
  126|     10|                dimensions,
  126|    110|                    Self::rotate_left(link);
  126|  1.22k|                    Self::rotate_left(link);
  126|  1.23M|            }
  126|     13|        }
  126|  1.50k|        }
  126|    174|            }
  126|     19|            }
  126|    190|            neighbors
  126|      1|            Some(ArraySeqStPerS::from_vec(path))
  126|       |                2,
  126|      2|        }
  126|      3|                }
  126|      3|        }
  126|      3|                .in_order()
  126|      3|                .in_order()
  126|      3|                .in_order()
  126|      3|            Self::from_seq(AVLTreeSeqStEphS::from_vec(filtered))
  126|      4|    }
  126|      4|                .in_order()
  126|      4|                .in_order()
  126|      4|        result.visited
  126|      5|    }
  126|  5.43k|                        .right
  126|      7|                .in_order()
  126|      8|                    }
  126|     85|            }
  126|      8|                self.entries.length(),
  126|      8|                stack.push(start.clone());
  126|       |                __s
  127|       |
  127|       |
  127|       |
  127|       |
  127|       |
  127|       |
  127|       |
  127|       |
  127|       |
  127|       |
  127|       |
  127|       |
  127|       |
  127|       |
  127|       |
  127|       |
  127|       |
  127|       |
  127|       |
  127|       |
  127|       |
  127|       |
  127|       |                    }
  127|       |                }
  127|       |                },
  127|       |            );
  127|       |            );
  127|       |            }
  127|       |            };
  127|       |    }
  127|       |}
  127|      0|                }
  127|      0|            }
  127|      0|                None
  127|      1|            }
  127|      1|        }
  127|    108|                    values.push(f(a.nth(i)));
  127|     11|        }
  127|     11|        where
  127|    190|        }
  127|      1|            self.labeled_edges()
  127|      2|        }
  127|     20|        }
  127|    203|        }
  127|     26|                    }
  127|     29|    }
  127|      3|        }
  127|    308|            guard[idx].clone()
  127|  3.22k|                        Self::update(node);
  127|  3.99k|        }
  127|      3|                .iter()
  127|      3|                .iter()
  127|      3|                .iter()
  127|      3|                path.push(pred);
  127|      4|    }
  127|      4|                .iter()
  127|      4|                .iter()
  127|  5.43k|                        .as_ref()
  127|      5|            dummy_idx,
  127|     60|            }
  127|    681|                }
  127|      7|                .iter()
  127|     96|            result
  127|  9.75k|                }
  127|      9|                memo_guard.clear();
  128|       |
  128|       |
  128|       |
  128|       |
  128|       |
  128|       |
  128|       |
  128|       |
  128|       |
  128|       |
  128|       |
  128|       |
  128|       |
  128|       |
  128|       |
  128|       |
  128|       |
  128|       |
  128|       |
  128|       |                    };
  128|       |            }
  128|       |            }
  128|       |            };
  128|       |        ///
  128|       |        }
  128|       |    }
  128|       |    }
  128|       |    }
  128|       |}
  128|       |            $crate::Chap06::LabUnDirGraphMtEph::LabUnDirGraphMtEph::LabUnDirGraphMtEph::empty()
  128|      0|            }
  128|      0|            }
  128|      0|                    new_neighbors_vec.push(neighbor);
  128|      1|        }
  128|     10|            }
  128|     10|            }
  128|    108|                }
  128|    108|                        right_edges,
  128|     12|        }
  128|     19|                continue;
  128|      1|                .iter()
  128|      1|            path.reverse();
  128|      1|            std::sync::Mutex::new(inner)
  128|      2|            }
  128|    237|        }
  128|     26|                }
  128|      3|                }
  128|      3|                }
  128|      3|        }
  128|    308|        }
  128|  3.22k|                    }
  128|      4|            None
  128|      4|                self.num_elements
  128|      5|            }
  128|      5|        )
  128|      9|            }
  128|      9|            }
  129|       |
  129|       |
  129|       |
  129|       |
  129|       |
  129|       |
  129|       |
  129|       |
  129|       |
  129|       |
  129|       |
  129|       |
  129|       |
  129|       |
  129|       |
  129|       |
  129|       |
  129|       |
  129|       |
  129|       |
  129|       |
  129|       |
  129|       |
  129|       |
  129|       |        
  129|       |                    }
  129|       |                }
  129|       |                },
  129|       |                };
  129|       |            }
  129|       |            }
  129|       |        {
  129|       |        };
  129|       |        }};
  129|       |        }};
  129|       |    ///
  129|       |    ///
  129|       |    }
  129|       |    }
  129|       |    }
  129|       |}
  129|      0|                }
  129|      1|                }
  129|      1|            }
  129|      1|        }
  129|     10|        }
  129|  1.01k|                    }
  129|  1.02k|                    {
  129|    108|                        v_right
  129|     14|        result
  129|    180|        }
  129|      1|            out
  129|      1|            Some(ArraySeqStPerS::from_vec(path))
  129|      2|                }
  129|      2|        }
  129|  3.22k|                    inserted
  129|      3|                path.push(pred);
  129|      3|                path.push(pred);
  129|     48|        }
  129|      5|        }
  129|      5|        }
  129|      5|    }
  129|     52|            }
  129|     61|            {
  129|  6.51k|            }
  129|      8|                    out_vec.push(self.nth(i).clone());
  129|      9|        }
  129|     99|        }
  130|       |
  130|       |
  130|       |
  130|       |
  130|       |
  130|       |
  130|       |
  130|       |
  130|       |
  130|       |
  130|       |
  130|       |
  130|       |
  130|       |
  130|       |
  130|       |
  130|       |
  130|       |
  130|       |
  130|       |
  130|       |
  130|       |                    ));
  130|       |                }
  130|       |                }
  130|       |                }
  130|       |            }
  130|       |            }
  130|       |            }
  130|       |            }
  130|       |        }
  130|       |    }
  130|       |    }
  130|       |    }
  130|      1|            }
  130|      1|        }
  130|      1|        }
  130|  1.02k|                        Self::rotate_left(link);
  130|    105|            }
  130|     10|                        Some(v.clone())
  130|  11.0k|                Self::update(node);
  130|     11|                    new_matrix_vec.push(new_row.clone());
  130|     14|        }
  130|     14|    }
  130|     16|            }
  130|      2|        }
  130|     21|            }
  130|  22.7k|        }
  130|     23|    }
  130|     27|                source,
  130|      2|        r#"
  130|      3|                }
  130|      3|            }
  130|  35.4k|            }
  130|     45|                        Some(v.clone())
  130|      5|                        Some(v.clone())
  130|      5|                        Some(v.clone())
  130|      5|                        Some(v.clone())
  130|    674|            Some(node)
  130|     68|                        visited.insert(current.clone());
  130|      7|            }
  130|      8|                }
  130|      8|        }
  130|    807|                Self::update(node);
  130|    850|            }
  130|      8|                        Some(v.clone())
  131|       |
  131|       |
  131|       |
  131|       |
  131|       |
  131|       |
  131|       |
  131|       |
  131|       |
  131|       |
  131|       |
  131|       |
  131|       |
  131|       |
  131|       |
  131|       |
  131|       |
  131|       |
  131|       |                };
  131|       |            }
  131|       |            }
  131|       |            }
  131|       |            };
  131|       |            };
  131|       |    ///
  131|       |    }
  131|       |    }
  131|       |    }
  131|       |    }
  131|       |    }
  131|      1|        }
  131|      1|        }
  131|     10|            {
  131|     10|        }
  131|  1.10k|        }
  131|  11.0k|            }
  131|    110|                        Some(&node.value)
  131|  1.39k|        }
  131|     16|                        frontier.insert(neighbor_entry);
  131|    178|        }
  131|     18|        }
  131|      1|            edges
  131|      1|            path.reverse();
  131|      2|                    }
  131|      2|            }
  131|     21|        }
  131|     22|            }
  131|  2.51M|        }
  131|    270|                        neighbors.insert(labeled_edge.1.clone_mt());
  131|     27|                target,
  131|      3|        }
  131|     36|            }
  131|      3|                path.push(pred);
  131|  4.41k|                    }
  131|   543k|                result.insert(elem.clone());
  131|  5.81k|                        }
  131|    648|        rec(a)
  131|    807|            }
  131|      9|        }
  132|       |
  132|       |
  132|       |
  132|       |
  132|       |
  132|       |
  132|       |
  132|       |
  132|       |
  132|       |
  132|       |
  132|       |
  132|       |
  132|       |
  132|       |
  132|       |
  132|       |
  132|       |
  132|       |
  132|       |
  132|       |
  132|       |
  132|       |
  132|       |
  132|       |
  132|       |                    }
  132|       |                    };
  132|       |                }
  132|       |                }
  132|       |    ///
  132|       |    }
  132|       |}
  132|       |}
  132|       |}
  132|       |}
  132|      1|                }
  132|      1|        }
  132|    108|                left_result.union(&right_result)
  132|  11.0k|        }
  132|     13|        }
  132|    144|        }
  132|     16|                    }
  132|     16|            &self,
  132|    175|        }
  132|      1|            f.debug_struct("UnDirGraphStEph")
  132|      1|            format!(
  132|      1|            result
  132|      1|            Some(ArraySeqStPerS::from_vec(path))
  132|      2|
  132|     22|            result.push(doc_id.clone());
  132|    231|            result
  132|  2.48k|            }
  132|     28|                    new_matrix_vec.push(self.matrix.nth(i).clone());
  132|     36|        }
  132|     37|                    out_vec.push(self.nth(i).clone());
  132|  39.5k|        rec(a)
  132|      3|                        None
  132|      3|                        None
  132|      3|                        None
  132|      3|                        None
  132|      3|        where
  132|      4|            }
  132|     42|                c1,
  132|     43|                        None
  132|   543k|            }
  132|      5|                        None
  132|     61|            }
  132|    648|    }
  132|      6|                shortcut.push(vertex.clone());
  132|      8|            }
  132|    807|        }
  132|      8|        mst_edges
  132|      9|        }
  133|       |
  133|       |
  133|       |
  133|       |
  133|       |
  133|       |
  133|       |
  133|       |
  133|       |
  133|       |
  133|       |
  133|       |
  133|       |
  133|       |
  133|       |
  133|       |
  133|       |                    }
  133|       |                    }
  133|       |                    }
  133|       |                    }
  133|       |                    }
  133|       |                    }
  133|       |                }
  133|       |            }
  133|       |            }
  133|       |    ///
  133|       |    }
  133|       |}
  133|      0|                }
  133|      1|        }
  133|    109|                        Some(&node.key)
  133|     10|                memo_guard.clear();
  133|  15.0k|            }
  133|     17|                };
  133|      1|            path.reverse();
  133|      1|            path.reverse();
  133|      1|        println!(
  133|      2|            }
  133|      2|        }
  133|    208|                        neighbors.insert(labeled_edge.0.clone_mt());
  133|     21|            self.memo.clear();
  133|     22|        }
  133|    222|            }
  133|    231|        }
  133|    231|                    true
  133|  2.51k|        }
  133|     27|            }
  133|     27|            }
  133|     28|                }
  133|     32|                table_size,
  133|     37|                }
  133|  39.5k|    }
  133|      4|        }
  133|      4|        }
  133|     42|                c2,
  133|     47|                    }
  133|     58|            }
  133|     64|                                stack.push(neighbor.clone());
  133|      7|        }
  133|      8|        }
  133|      8|    }
  133|       |            std::iter::Zip<
  134|       |
  134|       |
  134|       |
  134|       |
  134|       |
  134|       |
  134|       |
  134|       |
  134|       |
  134|       |
  134|       |
  134|       |
  134|       |
  134|       |
  134|       |
  134|       |
  134|       |
  134|       |
  134|       |                    }
  134|       |                    };
  134|       |                }
  134|       |            }
  134|       |            }
  134|       |        {
  134|       |        }
  134|       |        }
  134|       |        }};
  134|       |    }
  134|      0|                }
  134|      0|                }
  134|      0|            }
  134|      0|            }
  134|      0|                elements.push(seq.nth(i).clone());
  134|      0|            memo_guard.len()
  134|     10|            }
  134|    105|            {
  134|     11|                })
  134|    129|                        Some(&node.key)
  134|     14|            }
  134|     15|                })
  134|    172|                elements.push(eph_seq.nth(i).clone());
  134|      1|            Some(ArraySeqStPerS::from_vec(path))
  134|      1|            Some(ArraySeqStPerS::from_vec(path))
  134|      1|            write!(
  134|      2|
  134|      2|                }
  134|      2|        }
  134|    254|        }
  134|     27|        }
  134|      2|                new_adj
  134|      3|            }
  134|     32|                probe_sequence,
  134|      3|            result
  134|      4|            }
  134|  4.00k|                items.push(value);
  134|      5|    }
  134|     51|            }
  134|  5.48k|                    Self::update_size(node);
  134|      6|            }
  134|    601|                    }
  134|     61|            result
  134|     64|                            }
  134|      7|                out.push(node.key.clone());
  134|      8|                })
  134|      8|                })
  134|      8|                })
  134|      8|            }
  134|     88|                })
  134|      9|        }
  135|       |
  135|       |
  135|       |
  135|       |
  135|       |
  135|       |
  135|       |
  135|       |
  135|       |
  135|       |
  135|       |
  135|       |
  135|       |
  135|       |
  135|       |
  135|       |
  135|       |
  135|       |
  135|       |
  135|       |                        }
  135|       |                }
  135|       |                }
  135|       |            )
  135|       |            }
  135|       |            }
  135|       |            }
  135|       |            },
  135|       |            };
  135|       |        ///
  135|       |        }
  135|       |    ///
  135|       |    }
  135|       |    }
  135|       |    }
  135|       |    }
  135|       |}
  135|      0|                }
  135|      0|            }
  135|      0|        }
  135|      0|            write!(
  135|      1|            }
  135|      1|        }
  135|     10|                    merged.push(values1[i].clone());
  135|     11|        }
  135|     11|        result.sort();
  135|    134|        }
  135|    172|            }
  135|  1.85k|            }
  135|     19|        }
  135|      1|                f,
  135|      1|                .finish()
  135|      1|            intersection.size(),
  135|      1|            path.reverse();
  135|      2|        }
  135|      2|        }
  135|  22.1k|        }
  135|      3|        }
  135|     32|                sequence_length,
  135|     33|                    }
  135|      3|                .collect();
  135|      3|                .collect();
  135|      3|                .collect();
  135|      4|            }
  135|  4.00k|            }
  135|     45|        }
  135|      4|                .collect();
  135|      4|                .collect();
  135|  5.48k|                }
  135|      6|                true
  135|      7|        }
  135|      7|                .collect();
  136|       |
  136|       |
  136|       |
  136|       |
  136|       |
  136|       |
  136|       |
  136|       |
  136|       |
  136|       |
  136|       |
  136|       |
  136|       |
  136|       |
  136|       |
  136|       |
  136|       |        
  136|       |                    }
  136|       |                },
  136|       |            >,
  136|       |        }
  136|       |    }
  136|       |    }
  136|       |    }
  136|       |    }
  136|       |    }
  136|       |    }
  136|      0|            }
  136|      0|        }
  136|      0|            elements.sort();
  136|      0|                f,
  136|      1|            }
  136|      1|        }
  136|      1|        }
  136|      1|        }
  136|      1|        }
  136|      1|        }
  136|  10.8k|                result.insert(elem.clone());
  136|    111|                    quick_sort(right);
  136|     11|        result
  136|    134|        }
  136|     14|            }
  136|     16|        where
  136|  1.83k|            result
  136|      1|            intersection.find(&2)
  136|      1|            items
  136|      1|                neighbors.delete(v);
  136|      1|                    new_adj_vec.push(new_neighbors.clone());
  136|      1|            Some(ArraySeqStPerS::from_vec(path))
  136|      1|    where
  136|      2|            }
  136|      2|            }
  136|     20|        }
  136|    204|                out.push(node.key.clone());
  136|    272|                self.num_deleted
  136|  3.45k|        }
  136|     38|            AVLTreeSeqStPerS::from_vec(elements)
  136|      3|            Self::from_sorted_iter(filtered.into_iter())
  136|      3|            Self::from_sorted_iter(filtered.into_iter())
  136|      3|            Self::from_sorted_iter(filtered.into_iter())
  136|      3|            self.memo.clear();
  136|      4|                    }
  136|      4|        }
  136|      4|            Self::from_sorted_iter(filtered.into_iter())
  136|      4|            Self::from_sorted_iter(filtered.into_iter())
  136|      4|                        .unwrap()
  136|    599|                    temp_vec.push(self.elements.nth(i).clone());
  136|     60|            }
  136|      7|                a.nth(0).clone()
  136|      7|            Self::from_sorted_iter(filtered.into_iter())
  136|      8|            }
  137|       |
  137|       |
  137|       |
  137|       |
  137|       |
  137|       |
  137|       |
  137|       |
  137|       |
  137|       |
  137|       |
  137|       |
  137|       |
  137|       |
  137|       |
  137|       |
  137|       |                }
  137|       |                }
  137|       |                }
  137|       |                };
  137|       |            }
  137|       |            }
  137|       |            };
  137|       |        );
  137|       |    }
  137|       |    }
  137|       |    }
  137|       |    }
  137|       |    }
  137|       |    }
  137|       |    }
  137|       |    }
  137|       |}
  137|       |}
  137|       |}
  137|       |}
  137|      0|                    });
  137|      0|            }
  137|      0|            elements.dedup();
  137|      0|            write!(
  137|      1|        }
  137|      1|        }
  137|    105|            }
  137|  10.8k|            }
  137|     11|    }
  137|    111|                });
  137|    127|    }
  137|    132|        }
  137|     15|        }
  137|     16|        where
  137|    170|                            },
  137|  1.83k|        }
  137|     19|        }
  137|     19|                continue;
  137|      2|        }
  137|      2|        }
  137|     23|                    }
  137|     23|        }
  137|      2|                false
  137|      3|            }
  137|      3|        }
  137|      3|        }
  137|      3|        }
  137|      3|        }
  137|     32|                period,
  137|     38|        }
  137|      3|            self.memo.clear();
  137|      4|        }
  137|      4|        }
  137|     42|            }
  137|      4|                        .clone()
  137|    599|                }
  137|      5|                ArraySeqMtEphS::tabulate(
  137|      7|        }
  137|       |    #[macro_export]
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |
  138|       |                    }
  138|       |            )
  138|       |            }
  138|       |            }
  138|       |            }
  138|       |        ///
  138|       |        >;
  138|       |        {
  138|       |        }
  138|       |    {
  138|       |    }
  138|       |    }
  138|       |    }
  138|       |    }
  138|      0|            }
  138|      0|            }
  138|      0|                f,
  138|      0|                        s.insert(arcs[0].1.clone_mt());
  138|     10|        }
  138|  1.05k|            }
  138|  10.8k|            result
  138|     11|            }
  138|    119|                        Some(&node.key)
  138|    170|                            *rb,
  138|      1|                b.nth(0).clone()
  138|      2|
  138|     20|            }
  138|    227|            }
  138|    271|                temp_vec.push(x);
  138|    279|            }
  138|      2|                a.nth_cloned(0)
  138|      2|                    new_adj_vec.push(self.adj.nth(i).clone());
  138|      2|            shortcut.push(start.clone());
  138|      3|        }
  138|      3|        }
  138|     32|                collision_pattern,
  138|      4|                },
  138|     42|        }
  138|     52|            }
  138|  5.81k|                        sort(right);
  138|      6|                    }
  138|      6|                    merged.push(values2[j].clone());
  138|    775|        }
  138|      8|                    return;
  138|       |                self.multiset,
  139|       |
  139|       |
  139|       |
  139|       |
  139|       |
  139|       |
  139|       |
  139|       |
  139|       |
  139|       |
  139|       |
  139|       |
  139|       |
  139|       |
  139|       |
  139|       |
  139|       |
  139|       |
  139|       |
  139|       |
  139|       |                        );
  139|       |                    }
  139|       |                }
  139|       |                }
  139|       |                }
  139|       |                },
  139|       |            };
  139|       |        {
  139|       |}
  139|       |}
  139|      0|        }
  139|      0|                left_result.union(&right_result)
  139|      0|                        s
  139|      0|                        s
  139|      0|                self.memo.len()
  139|      0|            Some(Box::new(node))
  139|      1|            }
  139|      1|        }
  139|      1|        }
  139|    102|        }
  139|    105|            result
  139|  10.8k|        }
  139|     11|        }
  139|     13|                visited,
  139|     15|            vertices.insert(i);
  139|      2|                }
  139|      2|        }
  139|      2|        }
  139|     20|            {
  139|    271|                temp_vec.sort();
  139|      2|Operations:
  139|     31|            }
  139|     32|            }
  139|     33|                    out.push(key);
  139|      4|            }
  139|    483|        }
  139|  5.81k|                    });
  139|      6|                }
  139|  6.54k|        }
  139|    777|        }
  139|      7|        println!("],");
  139|      8|        }
  139|       |    #[macro_export]
  140|       |
  140|       |
  140|       |
  140|       |
  140|       |
  140|       |
  140|       |
  140|       |
  140|       |
  140|       |
  140|       |
  140|       |
  140|       |
  140|       |                }
  140|       |            )
  140|       |            )
  140|       |            }
  140|       |            }
  140|       |            }
  140|       |            }
  140|       |            }
  140|       |        }
  140|       |    }
  140|       |    }
  140|       |    }
  140|       |    }
  140|       |    }
  140|       |}
  140|       |            $crate::Chap06::LabUnDirGraphMtEph::LabUnDirGraphMtEph::LabUnDirGraphMtEph::empty()
  140|      0|            }
  140|      0|        }
  140|      0|                b.nth_cloned(0)
  140|      0|            distances,
  140|      0|                self.keys.len(),
  140|      1|            }
  140|      1|        }
  140|  11.6k|                }
  140|     13|                priorities,
  140|     15|        }
  140|      1|        result.visited
  140|      2|                }
  140|      2|            }
  140|    205|                result
  140|    213|        }
  140|      2|        assert!(set_result.find(&1));
  140|     30|            }
  140|     32|        }
  140|    366|        }
  140|      4|        }
  140|      5|            result
  140|      6|                }
  141|       |
  141|       |
  141|       |
  141|       |
  141|       |
  141|       |
  141|       |
  141|       |
  141|       |
  141|       |
  141|       |
  141|       |
  141|       |
  141|       |
  141|       |
  141|       |
  141|       |
  141|       |
  141|       |
  141|       |
  141|       |
  141|       |
  141|       |
  141|       |
  141|       |                    }
  141|       |            }
  141|       |            }
  141|       |            }
  141|       |            };
  141|       |            };
  141|       |        }};
  141|       |    }
  141|       |    }
  141|       |}
  141|      0|        }
  141|      0|            predecessors,
  141|      0|                self.memo.len()
  141|      0|                        Set::empty()
  141|      0|                        Set::empty()
  141|      0|            write!(
  141|      1|        }
  141|      1|        }
  141|      1|    }
  141|    107|                Self::rotate_left(link);
  141|     12|                .into_iter()
  141|     13|        }
  141|  1.32k|        }
  141|     16|            {
  141|     16|            }
  141|      1|            result
  141|      1|            self.source
  141|      1|            write!(
  141|      2|        }
  141|    205|                    .base_table
  141|      2|        assert!(set_result.find(&2));
  141|      2|        shortcut
  141|     33|                }
  141|      3|                out.push(node.key.clone());
  141|      4|            }
  141|    466|                    seq.nth(j).clone()
  141|      5|        }
  141|      5|        }
  141|     58|            }
  141|    614|        }
  141|      6|                sort(data);
  141|     82|        }
  141|      9|        }
  142|       |
  142|       |
  142|       |
  142|       |
  142|       |
  142|       |
  142|       |
  142|       |
  142|       |
  142|       |
  142|       |
  142|       |
  142|       |
  142|       |
  142|       |
  142|       |
  142|       |
  142|       |
  142|       |
  142|       |
  142|       |
  142|       |                    };
  142|       |                    };
  142|       |                }
  142|       |            )
  142|       |            }
  142|       |        ///
  142|       |        }
  142|       |    }
  142|       |}
  142|      0|                }
  142|      0|        }
  142|      0|                0.0
  142|      0|                f,
  142|      0|            left_result.union(&right_result)
  142|      0|            memo_guard.len()
  142|      0|            n,
  142|      1|            }
  142|      1|        }
  142|      1|    }
  142|    110|                    sv.push(self_seq.nth(i).clone());
  142|     11|        quotient_edges
  142|     12|                .zip(probs.into_iter())
  142|     13|            }
  142|     13|    }
  142|     15|                    },
  142|    158|                        return;
  142|      1|            edges
  142|      1|                f,
  142|      1|                .into_iter()
  142|      2|    }
  142|    275|        }
  142|      2|        assert!(set_result.find(&3));
  142|      3|            self.memo.clear();
  142|      3|        where
  142|      3|        where
  142|    449|        }
  142|      4|                        return;
  142|    512|            }
  142|      6|            });
  142|       |    #[macro_export]
  142|       |#[macro_export]
  143|       |
  143|       |
  143|       |
  143|       |
  143|       |
  143|       |
  143|       |
  143|       |
  143|       |
  143|       |
  143|       |
  143|       |
  143|       |                    }
  143|       |                    }
  143|       |                    }
  143|       |            }
  143|       |            }
  143|       |            }
  143|       |            };
  143|       |        );
  143|       |        );
  143|       |    }
  143|       |    }
  143|      0|                }
  143|      0|                }
  143|      0|                };
  143|      0|        }
  143|      0|        }
  143|      0|        }
  143|      0|        output.push_str("\n");
  143|      1|            }
  143|      1|        }
  143|      1|        }
  143|     11|    }
  143|    110|                }
  143|  1.16M|                }
  143|     13|        }
  143|     15|            }
  143|     16|                memo_guard.clear();
  143|      1|                .zip(self.target.into_iter())
  143|      2|            }
  143|      2|            }
  143|     20|            }
  143|  22.9k|                Self::rotate_left(link);
  143|     23|            }
  143|    231|        }
  143|      2|        assert!(set_result.find(&4));
  143|      3|        }
  143|      3|                out.push(node.key.clone());
  143|      4|        }
  143|    466|                    seq.nth(i).clone()
  143|     51|            }
  143|  5.71k|        }
  143|      5|                    left_seq.length(),
  143|      6|        }
  143|      7|        }
  143|     70|        }
  143|     72|        }
  143|     72|        }
  143|     75|        }
  143|       |    #[macro_export]
  144|       |
  144|       |
  144|       |
  144|       |
  144|       |
  144|       |
  144|       |
  144|       |
  144|       |
  144|       |
  144|       |
  144|       |
  144|       |
  144|       |
  144|       |
  144|       |
  144|       |
  144|       |
  144|       |
  144|       |
  144|       |
  144|       |
  144|       |
  144|       |
  144|       |
  144|       |
  144|       |
  144|       |
  144|       |        
  144|       |                )
  144|       |                }
  144|       |                }
  144|       |                }
  144|       |            }
  144|       |        {
  144|       |        {
  144|       |    }
  144|       |    }
  144|       |    }
  144|       |    }
  144|       |    }
  144|       |}
  144|      0|                }
  144|      0|        }
  144|      0|    }
  144|      0|            &self.data[start_index..end_exclusive]
  144|      0|                self.dimensions.len(),
  144|      1|        }
  144|  1.15k|        }
  144|     12|                .collect();
  144|     16|            }
  144|      1|                self.s_length(),
  144|      2|
  144|      2|            }
  144|      2|        }
  144|     20|            }
  144|     20|            Ok(self)
  144|      3|        }
  144|      3|            result
  144|      4|            }
  144|     40|            }
  144|     87|                        out.push(node.value.clone());
  144|  93.0k|            }
  144|       |        where
  145|       |
  145|       |
  145|       |
  145|       |
  145|       |
  145|       |
  145|       |
  145|       |
  145|       |
  145|       |
  145|       |
  145|       |
  145|       |
  145|       |
  145|       |
  145|       |
  145|       |
  145|       |
  145|       |
  145|       |            }
  145|       |            }
  145|       |        }
  145|       |    ///
  145|       |    }
  145|       |    }
  145|       |    }
  145|       |    }
  145|       |    }
  145|       |}
  145|       |        $crate::Chap49::SubsetSumStPer::SubsetSumStPer::SubsetSumStPerS::from_multiset(
  145|      0|        }
  145|      0|                self.memo.len()
  145|      1|        }
  145|     10|                        }
  145|  10.8k|                    seq.nth(k).clone()
  145|     11|            {
  145|     12|                    left.push(value.clone());
  145|     14|            }
  145|     14|                    left.push(value.clone());
  145|     17|                .into_iter()
  145|     19|                    }
  145|     19|                elements.push(seq.nth(i).clone());
  145|      1|                self.t_length()
  145|  20.0M|                }
  145|     22|        }
  145|     23|                    left.push(value.clone());
  145|     25|    }
  145|    272|            };
  145|      2|Cost Analysis:
  145|      2|            self.labeled_edges()
  145|      3|            }
  145|      3|        }
  145|  37.9k|            false
  145|      4|                c1,
  145|      4|                merged.push(values1[i].clone());
  145|      5|            });
  145|     53|            }
  145|      7|        }
  145|      7|                    left.push(value.clone());
  145|      7|                    left.push(value.clone());
  145|      8|                    left.push(value.clone());
  145|     99|        }
  145|       |            __tree
  146|       |
  146|       |
  146|       |
  146|       |
  146|       |
  146|       |
  146|       |
  146|       |
  146|       |
  146|       |
  146|       |
  146|       |
  146|       |
  146|       |
  146|       |
  146|       |
  146|       |
  146|       |                }
  146|       |                };
  146|       |            )
  146|       |            )
  146|       |            }
  146|       |            }
  146|       |        }};
  146|       |        }};
  146|       |        }};
  146|       |    ///
  146|       |    }
  146|       |    }
  146|       |}
  146|       |            $crate::ArraySeqStPerS![$($x),*]
  146|       |            $crate::Chap50::Probability::Probability::Probability::new($value)
  146|      0|                }
  146|      0|                return;
  146|      1|            }
  146|     11|                    }
  146|     11|        }
  146|     11|                Self::rotate_right(link);
  146|     11|                        Some(&node.key)
  146|     14|            }
  146|     19|            }
  146|     19|            }
  146|      1|                base_table,
  146|       |                2,
  146|      2|            }
  146|     21|        }
  146|     25|        neighbors
  146|      2|                .iter()
  146|  38.2k|        }
  146|    397|        }
  146|      4|            }
  146|      4|                c2,
  146|     53|        }
  146|      7|                visited,
  147|       |
  147|       |
  147|       |
  147|       |
  147|       |
  147|       |
  147|       |
  147|       |
  147|       |
  147|       |
  147|       |
  147|       |
  147|       |
  147|       |
  147|       |
  147|       |
  147|       |
  147|       |                }
  147|       |                }
  147|       |                },
  147|       |            );
  147|       |            }
  147|       |            }
  147|       |        )
  147|       |        };
  147|       |    }
  147|       |    }
  147|       |    }
  147|      0|                }
  147|      0|            }
  147|      0|        }
  147|      0|                return;
  147|      1|                }
  147|      1|        }
  147|     10|                    right.push(value.clone());
  147|    112|                    ov.push(other_seq.nth(i).clone());
  147|     12|                    right.push(value.clone());
  147|     16|                Some(strategy.analyze_secondary_clustering(table))
  147|  1.76k|                    return;
  147|      1|                cached_reduction,
  147|      1|            self.labeled_arcs()
  147|      2|        }
  147|    204|                    return;
  147|     21|        }
  147|     22|                    right.push(value.clone());
  147|     25|    }
  147|      4|            }
  147|     45|        });
  147|      5|            }
  147|   555k|            false
  147|      5|                    right.push(value.clone());
  147|      5|                    right.push(value.clone());
  147|    608|            }
  147|      7|        }
  147|      7|                priorities,
  147|      7|                    right.push(value.clone());
  147|     87|                    }
  147|      8|            result
  148|       |
  148|       |
  148|       |
  148|       |
  148|       |
  148|       |
  148|       |
  148|       |
  148|       |
  148|       |
  148|       |
  148|       |
  148|       |
  148|       |
  148|       |
  148|       |
  148|       |
  148|       |
  148|       |
  148|       |
  148|       |                }
  148|       |                }
  148|       |            }
  148|       |            }
  148|       |            }
  148|       |            }
  148|       |        ///
  148|       |        }
  148|       |        }
  148|       |    ///
  148|       |    ///
  148|       |    }
  148|       |    }
  148|       |    }
  148|       |    }
  148|       |    }
  148|       |    }
  148|       |    };
  148|      0|                memo_guard.len()
  148|      1|        }
  148|    112|                }
  148|     13|                }
  148|     15|        }
  148|      1|                base_table,
  148|      1|                .iter()
  148|      1|            memo_guard.clear();
  148|      1|                reducer,
  148|      1|            self.memo.clear();
  148|      2|            }
  148|     20|        });
  148|     29|                        insert_cost.min(delete_cost).min(substitute_cost)
  148|      4|                }
  148|      5|            }
  148|      5|            }
  148|   556k|        }
  148|      6|                shortcut.push(vertex.clone());
  148|      8|        }
  148|       |    #[macro_export]
  149|       |
  149|       |
  149|       |
  149|       |
  149|       |
  149|       |
  149|       |
  149|       |
  149|       |
  149|       |
  149|       |
  149|       |
  149|       |
  149|       |
  149|       |
  149|       |                    }
  149|       |                }
  149|       |                },
  149|       |            }
  149|       |            }
  149|       |            }
  149|       |            }
  149|       |            };
  149|       |    }
  149|       |    }
  149|       |    }
  149|       |}
  149|       |}
  149|       |}
  149|      0|        }
  149|      0|                None
  149|      0|                        s
  149|      1|        }
  149|      1|        }
  149|      1|        }
  149|    107|        }
  149|     12|            }
  149|    132|                Self::flip_colors(link);
  149|     19|    }
  149|      1|                cached_reduction,
  149|      1|                identity,
  149|      1|            write!(
  149|      2|
  149|      2|        }
  149|      2|        }
  149|      2|        }
  149|      2|            result
  149|     47|                })
  149|      4|                merged.push(values2[j].clone());
  149|      7|            }
  149|      7|        println!("]");
  149|       |    #[macro_export]
  150|       |
  150|       |
  150|       |
  150|       |
  150|       |
  150|       |
  150|       |
  150|       |
  150|       |
  150|       |
  150|       |
  150|       |
  150|       |
  150|       |
  150|       |
  150|       |
  150|       |
  150|       |
  150|       |
  150|       |                }
  150|       |                }
  150|       |                },
  150|       |            }
  150|       |            }
  150|       |            }
  150|       |            };
  150|       |    }
  150|       |    }
  150|       |}
  150|       |        $crate::Chap49::SubsetSumStPer::SubsetSumStPer::SubsetSumStPerS::new()
  150|      0|            }
  150|      0|        }
  150|      0|                0.0
  150|      0|            write!(
  150|      1|            }
  150|      1|            }
  150|  11.0k|            Self::rebalance(link);
  150|     12|        }
  150|     13|                visited,
  150|     16|        }
  150|     17|                .collect();
  150|      1|                f,
  150|      1|            false
  150|      1|                reducer,
  150|      2|            }
  150|      2|            }
  150|      2|        }
  150|     22|                        insert_cost.min(delete_cost).min(substitute_cost)
  150|     25|    }
  150|     30|                });
  150|      3|                        new_row_vec.push(false);
  150|      4|                }
  150|      4|                }
  150|      4|                }
  150|      4|            }
  150|     46|    }
  150|    487|            }
  150|     49|        }
  150|      5|                }
  150|   529k|                values.push(f(i));
  150|      6|                }
  150|      6|                }
  150|      6|            }
  150|     67|            }
  150|      7|        }
  150|      7|        println!(")");
  150|      8|            }
  150|    807|            Self::rebalance(link);
  150|      9|                }
  150|      9|            }
  150|       |            __tree
  150|       |        where
  151|       |
  151|       |
  151|       |
  151|       |
  151|       |
  151|       |
  151|       |
  151|       |
  151|       |
  151|       |
  151|       |
  151|       |
  151|       |
  151|       |
  151|       |
  151|       |
  151|       |
  151|       |
  151|       |
  151|       |                    }
  151|       |                    }
  151|       |            }
  151|       |            }
  151|       |            }
  151|       |            }
  151|       |            }
  151|       |            }
  151|       |            }
  151|       |            }
  151|       |            }
  151|       |            }
  151|       |            };
  151|       |            };
  151|       |            };
  151|       |        ///
  151|       |        }
  151|       |        }
  151|       |        }};
  151|       |        }};
  151|       |    ///
  151|       |    }
  151|       |    };
  151|       |}
  151|       |}
  151|      0|                f,
  151|      0|                        false
  151|      0|        output.push_str("\n");
  151|      0|                        Set::empty()
  151|      0|                        s.insert(edges[0].1.clone_mt());
  151|      1|            }
  151|      1|        }
  151|      1|        }
  151|      1|        }
  151|  1.01k|        }
  151|  12.9k|        }
  151|     13|                priorities,
  151|      1|                identity,
  151|      2|            }
  151|      2|        "#
  151|    220|                }
  151|     27|        }
  151|      3|        }
  151|      4|            }
  151|      4|        }
  151|      4|        }
  151|      5|    }
  151|   529k|            }
  151|     60|            LinkedListStPerS::from_vec(out)
  151|     67|        }
  151|      9|        }
  151|       |            std::iter::Zip<
  151|       |        where
  152|       |
  152|       |
  152|       |
  152|       |
  152|       |
  152|       |
  152|       |
  152|       |
  152|       |
  152|       |
  152|       |
  152|       |
  152|       |
  152|       |
  152|       |
  152|       |
  152|       |
  152|       |
  152|       |        
  152|       |                    }
  152|       |                    };
  152|       |                }
  152|       |                }
  152|       |                }
  152|       |            }
  152|       |        }
  152|       |    }
  152|       |    }
  152|       |    }
  152|       |}
  152|      0|                }
  152|      0|            }
  152|      0|                    new_chain.clone()
  152|      0|            write!(
  152|      1|            }
  152|      1|            }
  152|      1|        }
  152|     19|                },
  152|      1|                self.s_length(),
  152|      1|            true
  152|      1|        true
  152|      2|                }
  152|    213|                    return;
  152|    272|            }
  152|      2|            self.memo.clear();
  152|      2|        .to_string()
  152|    303|                result
  152|    359|        }
  152|  3.87k|            ArraySeqStPerS::from_vec(values)
  152|      4|        }
  152|    466|            result
  152|      5|            (
  152|      5|            (
  152|     53|        }
  152|      6|            (
  152|      6|            (
  152|    619|                Self::update(node);
  152|     65|        }
  152|      6|                        new_row_vec.push(!*row.nth(j));
  152|      7|            (
  152|      7|            (
  152|     72|        }
  153|       |
  153|       |
  153|       |
  153|       |
  153|       |
  153|       |
  153|       |
  153|       |
  153|       |
  153|       |
  153|       |
  153|       |
  153|       |
  153|       |
  153|       |
  153|       |
  153|       |
  153|       |
  153|       |
  153|       |                }
  153|       |            }
  153|       |            }
  153|       |            };
  153|       |        };
  153|       |    }
  153|       |    }
  153|       |    }
  153|      0|                }
  153|      0|            }
  153|      0|                f,
  153|      0|            f.debug_struct("DirGraphStEph")
  153|      1|        }
  153|      1|    }
  153|     13|            }
  153|    183|                        return;
  153|      1|            memo_guard.clear();
  153|      1|                self.t_length()
  153|      1|        true
  153|      2|        }
  153|      2|    }
  153|    208|                }
  153|     22|                .into_iter()
  153|    231|        }
  153|      2|                None
  153|      2|            self.labeled_edges()
  153|      3|            }
  153|      3|        }
  153|    303|                    .base_table
  153|     34|        }
  153|     38|        }
  153|  3.87k|        }
  153|      4|            }
  153|    466|        }
  153|      5|                        }
  153|      5|            });
  153|      5|                right_seq.length(),
  153|      5|                Self::from_sorted_iter(left.into_iter()),
  153|      5|                Self::from_sorted_iter(left.into_iter()),
  153|      6|                    }
  153|    619|            }
  153|      6|                Self::from_sorted_iter(left.into_iter()),
  153|      6|                Self::from_sorted_iter(left.into_iter()),
  153|      7|                Self::from_sorted_iter(left.into_iter()),
  153|      7|                Self::from_sorted_iter(left.into_iter()),
  153|      9|            Ok(self)
  154|       |
  154|       |
  154|       |
  154|       |
  154|       |
  154|       |
  154|       |
  154|       |
  154|       |
  154|       |
  154|       |
  154|       |
  154|       |
  154|       |
  154|       |
  154|       |
  154|       |
  154|       |
  154|       |
  154|       |
  154|       |
  154|       |
  154|       |
  154|       |
  154|       |                }
  154|       |                },
  154|       |            )
  154|       |            )
  154|       |            );
  154|       |            >,
  154|       |        }};
  154|       |    ///
  154|       |}
  154|       |}
  154|       |}
  154|      0|                    self.buckets.nth(i).clone()
  154|      1|        }
  154|      1|    }
  154|    107|                    result
  154|     11|                    }
  154|     11|        }
  154|     13|        }
  154|    134|            }
  154|    158|        }
  154|    178|                    }
  154|     21|                }
  154|     22|                    }
  154|     22|                .zip(probs.into_iter())
  154|    272|            result
  154|      2|                .iter()
  154|      3|            }
  154|     31|        }
  154|    319|        }
  154|     34|                    drop(guard);
  154|     36|            {
  154|      4|        }
  154|     40|        }
  154|     45|        result
  154|      5|                found,
  154|      5|                found,
  154|    619|        }
  154|      6|                found,
  154|      6|                found,
  154|      7|                found,
  154|      7|                found,
  155|       |
  155|       |
  155|       |
  155|       |
  155|       |
  155|       |
  155|       |
  155|       |
  155|       |
  155|       |
  155|       |
  155|       |
  155|       |                    ));
  155|       |                    ));
  155|       |                }
  155|       |                };
  155|       |            )
  155|       |            }
  155|       |            }
  155|       |            }
  155|       |            }
  155|       |            };
  155|       |    }
  155|       |    }
  155|       |}
  155|       |}
  155|      0|                }
  155|      0|        }
  155|      0|                        s.insert(edges[0].0.clone_mt());
  155|      1|            }
  155|      1|        }
  155|      1|        }
  155|    107|                        .base_table
  155|    112|    }
  155|    134|        }
  155|     17|            }
  155|     19|                .into_iter()
  155|      1|            self.labeled_arcs()
  155|     20|        result
  155|    295|        }
  155|      2|            shortcut.push(start.clone());
  155|      2|            .union(&singleton3)
  155|      3|            }
  155|  39.2k|                    }
  155|      3|                new_matrix_vec.push(ArraySeqStPerS::from_vec(new_row_vec));
  155|      5|            }
  155|      5|        }
  155|      5|                Self::from_sorted_iter(right.into_iter()),
  155|      5|                Self::from_sorted_iter(right.into_iter()),
  155|      6|                Self::from_sorted_iter(right.into_iter()),
  155|      6|                Self::from_sorted_iter(right.into_iter()),
  155|      7|                Self::from_sorted_iter(right.into_iter()),
  155|      7|                Self::from_sorted_iter(right.into_iter()),
  155|      7|                visited,
  155|       |                self.source,
  156|       |
  156|       |
  156|       |
  156|       |
  156|       |
  156|       |
  156|       |
  156|       |
  156|       |
  156|       |
  156|       |
  156|       |
  156|       |                }
  156|       |            }
  156|       |            }
  156|       |            }
  156|       |            }
  156|       |        >;
  156|       |        }
  156|       |    }
  156|       |    }
  156|       |    }
  156|       |    }
  156|       |    }
  156|      0|                .finish()
  156|      0|                memo_guard.len()
  156|      1|            }
  156|      1|        }
  156|     10|                Some(seq.nth(0).clone())
  156|     17|        }
  156|      1|                .iter()
  156|      1|                        None
  156|      1|        where
  156|      1|            write!(
  156|      2|        }
  156|     21|            &self,
  156|     22|                .collect();
  156|     22|            result
  156|     27|                }
  156|     29|            {
  156|      2|            .union(&singleton2)
  156|     33|                    vec_elements.push(elem.clone());
  156|      3|            result
  156|      3|            self.memo.clear();
  156|     43|    }
  156|     46|            });
  156|      5|            )
  156|      5|            )
  156|      5|            }
  156|      5|        }
  156|      5|        where
  156|      6|            )
  156|      6|            )
  156|      7|            )
  156|      7|            )
  156|      7|                priorities,
  156|     81|        }
  156|       |                self.target,
  157|       |
  157|       |
  157|       |
  157|       |
  157|       |
  157|       |
  157|       |
  157|       |
  157|       |
  157|       |
  157|       |
  157|       |
  157|       |
  157|       |
  157|       |
  157|       |
  157|       |
  157|       |
  157|       |
  157|       |
  157|       |
  157|       |        
  157|       |                    }
  157|       |                },
  157|       |            )
  157|       |            }
  157|       |            }
  157|       |            };
  157|       |        }
  157|       |}
  157|      0|                    }
  157|      0|        }
  157|      0|                    combined.extend(right.into_vec());
  157|      0|                left_result.union(&right_result)
  157|      0|                left_result.union(&right_result)
  157|      0|                self.memo.len()
  157|      1|        }
  157|    107|                }
  157|    151|        }
  157|     15|            vertices.insert(i);
  157|     18|                        Some(key)
  157|      1|            ArraySeqS::from_vec(segment)
  157|      1|                base_table,
  157|      1|                f,
  157|      1|                    new_chain.clone()
  157|      1|            result
  157|      1|            write!(
  157|      2|        }
  157|      2|        }
  157|     22|        }
  157|    225|            }
  157|      2|        r#"
  157|      3|        }
  157|      3|        }
  157|     36|            }
  157|     42|            }
  157|    463|                Self::rotate_right(link);
  157|     47|                }
  157|      5|        }
  157|      5|        }
  157|      6|        }
  157|      6|        }
  157|      7|        }
  157|      7|        }
  157|      7|                        union_entries.push(pair1.clone());
  157|       |            __set
  158|       |
  158|       |
  158|       |
  158|       |
  158|       |
  158|       |
  158|       |
  158|       |
  158|       |
  158|       |
  158|       |
  158|       |
  158|       |
  158|       |
  158|       |
  158|       |
  158|       |
  158|       |
  158|       |
  158|       |
  158|       |                }
  158|       |            )
  158|       |            }
  158|       |            }
  158|       |            }
  158|       |            }
  158|       |        {
  158|       |        {
  158|       |        }
  158|       |        }};
  158|       |    ///
  158|       |    }
  158|       |    }
  158|       |    }
  158|       |    }
  158|       |    }
  158|      0|            }
  158|      0|            }
  158|      0|            }
  158|      0|            distances,
  158|      0|        output.push_str("\nSummary:\n");
  158|      0|                    PrimTreeSeqStS::from_vec(combined)
  158|      0|            write!(
  158|      1|        }
  158|      1|        }
  158|      1|        }
  158|   115k|            }
  158|     12|        }
  158|     15|        }
  158|     19|    }
  158|      1|                cached_reduction,
  158|      1|                f,
  158|  2.52k|                        Some(&node.key)
  158|    263|                out.push(node.key.clone());
  158|      2|            memo_guard.len()
  158|      2|                None
  158|      2|        shortcut
  158|     38|                        Some(&node.key)
  158|      4|        }
  158|  50.0k|                values.push(f(a.nth(i)));
  158|      7|            }
  158|       |        where
  159|       |
  159|       |
  159|       |
  159|       |
  159|       |
  159|       |
  159|       |
  159|       |
  159|       |
  159|       |
  159|       |
  159|       |
  159|       |
  159|       |
  159|       |
  159|       |
  159|       |
  159|       |
  159|       |
  159|       |
  159|       |
  159|       |                }
  159|       |                },
  159|       |            }
  159|       |    ///
  159|       |    }
  159|       |}
  159|      0|                }
  159|      0|        }
  159|      0|                f,
  159|      0|            predecessors,
  159|      0|            self.source
  159|      1|            }
  159|      1|            }
  159|      1|        }
  159|      1|    }
  159|  10.9k|            t
  159|     16|                        drop(left_guard);
  159|      1|                reducer,
  159|      1|                self.s_length(),
  159|      2|
  159|      2|        }
  159|      2|        }
  159|      2|    }
  159|    218|                }
  159|     21|        where
  159|     29|            }
  159|      2|            .union(&singleton4)
  159|     35|            }
  159|     36|            result
  159|      3|            result
  159|      4|                0.0
  159|  50.0k|            }
  159|     51|                })
  159|     64|            }
  159|      7|                    }
  159|      7|            }
  159|      7|        }
  159|      7|                    self.buckets.nth(i).clone()
  160|       |
  160|       |
  160|       |
  160|       |
  160|       |
  160|       |
  160|       |
  160|       |
  160|       |
  160|       |
  160|       |
  160|       |
  160|       |                }
  160|       |                },
  160|       |                };
  160|       |                };
  160|       |            }
  160|       |            }
  160|       |            };
  160|       |        }
  160|       |    ///
  160|       |    ///
  160|       |    }
  160|       |    }
  160|       |}
  160|       |}
  160|      0|                }
  160|      0|                .clone()
  160|      0|            n,
  160|      1|            }
  160|      1|        }
  160|     10|            }
  160|  10.9k|        }
  160|     10|        where
  160|     14|        }
  160|     16|                        leftmost(&child)
  160|     19|                .collect();
  160|      1|                identity,
  160|      1|                self.s_length(),
  160|      1|                self.t_length(),
  160|      2|            }
  160|    255|            }
  160|    274|            }
  160|     28|            vertices.insert(i);
  160|      3|            }
  160|      3|        }
  160|     48|        }
  160|      4|                        vals.push(elem.clone());
  160|    629|        }
  160|      7|            ArraySeqStPerS::from_vec(values)
  160|     88|        }
  160|       |    #[macro_export]
  160|       |                __s
  161|       |
  161|       |
  161|       |
  161|       |
  161|       |
  161|       |
  161|       |
  161|       |
  161|       |
  161|       |
  161|       |
  161|       |
  161|       |
  161|       |
  161|       |
  161|       |
  161|       |                    }
  161|       |            }
  161|       |            };
  161|       |        {
  161|       |        }
  161|       |        }
  161|       |    ///
  161|       |}
  161|      0|            }
  161|      0|        }
  161|      0|        }
  161|      0|                .into_iter()
  161|      0|        None
  161|      0|                        union_entries.push(pair2.clone());
  161|      1|            }
  161|      1|        }
  161|     10|            }
  161|     10|        }
  161|    129|            }
  161|    135|        }
  161|     17|            roots.len()
  161|      1|            self.memo.clear();
  161|      1|                self.memo_size()
  161|      1|                self.t_length(),
  161|      2|
  161|      2|        }
  161|      2|        }
  161|     20|    }
  161|     22|            }
  161|     28|        }
  161|     29|        }
  161|     29|            result
  161|      3|                Some(seq.nth(0).clone())
  161|      3|        where
  161|      4|                    }
  161|      4|        }
  161|    537|        }
  161|      5|        vertices.insert(n);
  161|      7|        }
  162|       |
  162|       |
  162|       |
  162|       |
  162|       |
  162|       |
  162|       |
  162|       |
  162|       |
  162|       |
  162|       |
  162|       |
  162|       |
  162|       |
  162|       |
  162|       |
  162|       |                }
  162|       |                },
  162|       |            )
  162|       |            )
  162|       |            }
  162|       |        {
  162|       |    ///
  162|       |    ///
  162|       |    }
  162|       |    }
  162|       |    }
  162|       |    }
  162|       |    }
  162|       |    }
  162|       |    }
  162|       |    }
  162|      0|        }
  162|      0|    }
  162|      0|                .zip(self.target.clone().into_iter())
  162|      1|        }
  162|      1|        }
  162|     10|                combined.insert(value);
  162|     15|                entries.push(left_entries.nth_cloned(i));
  162|     16|                load_factor,
  162|     17|        }
  162|      1|            height_rec(&self.root)
  162|      1|                self.memo_size()
  162|     22|        }
  162|     25|            }
  162|     27|                table_size,
  162|      2|            complex_vec.push(doc_id.clone());
  162|     43|    }
  162|      4|                combined.insert(value);
  162|     56|        }
  162|      5|                combined.insert(value);
  162|      5|                combined.insert(value);
  162|      5|                combined.insert(value);
  162|      5|                combined.insert(value);
  162|     67|        }
  162|      7|        println!("]");
  162|       |#[macro_export]
  163|       |
  163|       |
  163|       |
  163|       |
  163|       |
  163|       |
  163|       |
  163|       |
  163|       |
  163|       |
  163|       |
  163|       |
  163|       |
  163|       |
  163|       |
  163|       |
  163|       |                    }
  163|       |                    }
  163|       |            )
  163|       |            }
  163|       |            }
  163|       |            };
  163|       |        {
  163|       |        }};
  163|       |    ///
  163|       |    }
  163|       |    }
  163|       |}
  163|       |}
  163|       |}
  163|       |            $crate::Chap06::LabUnDirGraphStEph::LabUnDirGraphStEph::LabUnDirGraphStEph::empty()
  163|      0|                    }
  163|      0|                }
  163|      0|        }
  163|      1|            }
  163|      1|        }
  163|      1|        }
  163|     10|            }
  163|    112|                handles.push(handle);
  163|     13|        }
  163|     15|            }
  163|      1|                        None
  163|      1|                    return;
  163|      1|                Self::singleton(x.clone())
  163|      1|        total
  163|      2|        }
  163|  20.0k|                }
  163|    222|                }
  163|     27|                probe_sequence,
  163|      2|        assert!(manual_union.find(&1));
  163|      4|            }
  163|      4|                    None
  163|      4|                total_clusters,
  163|      5|            }
  163|      5|            }
  163|      5|            }
  163|      5|            }
  163|      5|        }
  163|     57|                        self_vals
  163|      8|                    }
  164|       |
  164|       |
  164|       |
  164|       |
  164|       |
  164|       |
  164|       |
  164|       |
  164|       |
  164|       |
  164|       |
  164|       |
  164|       |
  164|       |
  164|       |        
  164|       |                    }
  164|       |                }
  164|       |                }
  164|       |                }
  164|       |                }
  164|       |                }
  164|       |                },
  164|       |            }
  164|       |            }
  164|       |            }
  164|       |        }};
  164|       |    ///
  164|       |    ///
  164|       |    }
  164|       |    }
  164|       |    }
  164|       |    }
  164|       |    }
  164|       |    }
  164|       |    }
  164|      0|            };
  164|      0|        }
  164|      1|        }
  164|      1|        }
  164|      1|        }
  164|      1|    }
  164|     10|            {
  164|     10|        vertices.insert(n);
  164|     16|                secondary_clustering,
  164|      1|                    break;
  164|      1|        complex_vec.sort();
  164|      2|            }
  164|     27|                sequence_length,
  164|      2|        assert!(manual_union.find(&2));
  164|      2|            memo_guard.clear();
  164|      2|                None
  164|      2|            Self::from_sorted_iter(combined.into_iter())
  164|     38|        }
  164|      3|            Self::from_sorted_iter(combined.into_iter())
  164|      3|            Self::from_sorted_iter(combined.into_iter())
  164|      3|            Self::from_sorted_iter(combined.into_iter())
  164|      3|            Self::from_sorted_iter(combined.into_iter())
  164|      4|                max_cluster_size,
  164|      5|            Self::from_sorted_iter(combined.into_iter())
  164|      6|                        });
  164|      8|                out.push(node.key.clone());
  164|      9|        }
  165|       |
  165|       |
  165|       |
  165|       |
  165|       |
  165|       |
  165|       |
  165|       |
  165|       |
  165|       |
  165|       |
  165|       |
  165|       |
  165|       |
  165|       |
  165|       |
  165|       |
  165|       |                    ));
  165|       |                }
  165|       |            }
  165|       |            }
  165|       |            }
  165|       |        }
  165|       |    ///
  165|       |    }
  165|       |    }
  165|       |    }
  165|       |    }
  165|       |}
  165|       |}
  165|       |        $crate::Chap49::SubsetSumMtPer::SubsetSumMtPer::SubsetSumMtPerS::from_multiset(
  165|      0|                }
  165|      0|            }
  165|      0|        output
  165|      0|                Self::empty()
  165|      1|                }
  165|      1|            }
  165|     10|            ArraySeqMtEphSliceS::from_vec(data)
  165|    178|        }
  165|     19|            }
  165|     19|                entries.push(right_entries.nth_cloned(i));
  165|      2|            }
  165|      2|        }
  165|      2|        }
  165|  22.1k|                Self::flip_colors(link);
  165|      2|        assert!(manual_union.find(&3));
  165|      3|                };
  165|      3|        }
  165|      3|        }
  165|      3|        }
  165|      3|        }
  165|     33|            }
  165|     35|        }
  165|     38|            }
  165|     38|            }
  165|      4|                avg_cluster_size,
  165|      5|        }
  165|     53|                        Vec::new()
  165|      6|            }
  165|     65|                    vec_elements.push(self.elements.nth(i).clone());
  165|      7|    }
  165|      9|            }
  165|      9|            }
  165|       |            std::iter::Zip<
  166|       |
  166|       |
  166|       |
  166|       |
  166|       |
  166|       |
  166|       |
  166|       |
  166|       |
  166|       |
  166|       |
  166|       |
  166|       |
  166|       |
  166|       |
  166|       |
  166|       |
  166|       |
  166|       |
  166|       |
  166|       |
  166|       |                    );
  166|       |                    };
  166|       |                }
  166|       |            }
  166|       |            }
  166|       |            }
  166|       |            }
  166|       |    }
  166|       |    }
  166|       |}
  166|       |}
  166|       |}
  166|       |            $crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::ArraySeqMtPerS::from_vec(vec![$($x),*])
  166|      0|                }
  166|      0|            }
  166|      0|    }
  166|      0|            self
  166|      1|        }
  166|     10|            }
  166|     10|        }
  166|     10|                memo_guard.clear();
  166|     11|                out.push(node.key.clone());
  166|    136|        }
  166|     19|            }
  166|     19|        }
  166|      1|            result
  166|      1|            write!(
  166|      2|
  166|    213|        }
  166|  2.24M|        }
  166|     25|        }
  166|    263|            }
  166|     27|                period,
  166|      2|            acc
  166|      2|        assert!(manual_union.find(&4));
  166|     36|        }
  166|      4|                clustering_coefficient,
  166|      5|        }
  166|     65|                }
  166|  93.8k|            }
  167|       |
  167|       |
  167|       |
  167|       |
  167|       |
  167|       |
  167|       |
  167|       |
  167|       |
  167|       |
  167|       |
  167|       |
  167|       |
  167|       |
  167|       |
  167|       |
  167|       |
  167|       |
  167|       |
  167|       |
  167|       |            }
  167|       |        )
  167|       |    ///
  167|       |    }
  167|       |    }
  167|       |}
  167|       |}
  167|      0|            }
  167|      0|        }
  167|      0|                left_result.union(&right_result)
  167|      0|            None
  167|      1|        }
  167|      1|        }
  167|     10|            }
  167|    108|                }
  167|     14|            }
  167|     16|                performance_impact,
  167|    174|                return;
  167|     18|        }
  167|      1|                f,
  167|      2|            }
  167|      2|        }
  167|     22|            leftmost(&self.root)
  167|    270|            }
  167|     27|                collision_pattern,
  167|      4|            memo_guard.len()
  167|      4|                Ok(self)
  167|      4|        star_contract_mt(
  167|      7|        }
  167|    734|                out.push(node.key.clone());
  167|       |#[macro_export]
  168|       |
  168|       |
  168|       |
  168|       |
  168|       |
  168|       |
  168|       |
  168|       |
  168|       |
  168|       |
  168|       |
  168|       |
  168|       |
  168|       |
  168|       |
  168|       |
  168|       |
  168|       |
  168|       |
  168|       |
  168|       |
  168|       |
  168|       |                }
  168|       |                }
  168|       |            >,
  168|       |            }
  168|       |            }
  168|       |        );
  168|       |    }
  168|       |    };
  168|       |}
  168|       |}
  168|      0|            }
  168|      0|                .load_factor_manager
  168|      0|            write!(
  168|      1|            }
  168|      1|        }
  168|     14|        }
  168|     16|            }
  168|     16|            }
  168|     17|            }
  168|      2|        }
  168|  20.0M|                    vec_elements.push(self.elements.nth(i).clone());
  168|  2.06M|                values.push(a.nth(i).clone());
  168|     22|        }
  168|    226|        }
  168|     27|            }
  168|      4|            }
  168|      4|        }
  168|      4|            graph,
  168|      5|        }
  168|      9|            {
  168|       |#[macro_export]
  169|       |
  169|       |
  169|       |
  169|       |
  169|       |
  169|       |
  169|       |
  169|       |
  169|       |
  169|       |
  169|       |
  169|       |
  169|       |
  169|       |            }
  169|       |            }
  169|       |        }};
  169|       |    }
  169|       |    }
  169|      0|                f,
  169|      1|        }
  169|      1|        }
  169|   116k|                Self::update(node);
  169|     12|        }
  169|     13|            is_sorted(&self.unsorted_list_result)
  169|     15|            }
  169|     16|        }
  169|  20.0M|                }
  169|  2.06M|            }
  169|     21|        }
  169|     26|                }
  169|     27|        }
  169|     27|        }
  169|      2|                None
  169|      2|                self.add_vertex(v);
  169|      3|                    }
  169|     49|            }
  169|      4|            combined.insert(pivot);
  169|      4|            combined.insert(pivot);
  169|      4|            combined.insert(pivot);
  169|      4|            combined.insert(pivot);
  169|      4|            seed,
  169|      5|            combined.insert(pivot);
  169|    619|            Self::fix_up(link);
  169|      6|            combined.insert(pivot);
  169|    834|            }
  169|       |    #[macro_export]
  169|       |    #[macro_export]
  169|       |#[macro_export]
  170|       |
  170|       |
  170|       |
  170|       |
  170|       |
  170|       |
  170|       |
  170|       |
  170|       |
  170|       |
  170|       |
  170|       |
  170|       |
  170|       |
  170|       |
  170|       |                }
  170|       |            )
  170|       |            }
  170|       |        >;
  170|       |    }
  170|       |    }
  170|       |        $crate::Chap49::SubsetSumMtPer::SubsetSumMtPer::SubsetSumMtPerS::new()
  170|       |        $crate::Chap49::SubsetSumStEph::SubsetSumStEph::SubsetSumStEphS::from_multiset(
  170|      0|            {
  170|      0|            }
  170|      0|                        s.insert(y.clone_mt());
  170|      1|                };
  170|   116k|            }
  170|  1.16k|                    }
  170|     15|            }
  170|    155|                    result
  170|  1.56k|        }
  170|      2|            }
  170|      2|        }
  170|      2|    }
  170|   212k|            self
  170|  2.27k|        }
  170|     34|                }
  170|      5|                }
  170|    511|        }
  170|   555k|                vec_elements.push(x);
  170|     56|                    kept.push(value);
  170|      6|            result
  170|    794|        }
  170|      7|            result
  170|      9|                memo_guard.clear();
  170|       |    #[macro_export]
  170|       |#[macro_export]
  170|       |#[macro_export]
  171|       |
  171|       |
  171|       |
  171|       |
  171|       |
  171|       |
  171|       |
  171|       |
  171|       |
  171|       |
  171|       |
  171|       |
  171|       |                }
  171|       |            }
  171|       |        }
  171|       |    }
  171|       |    };
  171|       |            $crate::ArraySeqStEphS![$($x),*]
  171|       |        $crate::Chap50::OptBinSearchTreeStPer::OptBinSearchTreeStPer::OBSTStPerS::from_keys_probs(
  171|      0|                    });
  171|      0|        }
  171|      0|                        s
  171|      0|                self.keys.len(),
  171|      1|            };
  171|      1|        }
  171|      1|        }
  171|     10|                dimensions_guard.len()
  171|   116k|        }
  171|   117k|                values.push(b.nth(j).clone());
  171|     12|        }
  171|     13|                combined.insert(value);
  171|    155|                        .base_table
  171|    180|                        }
  171|      1|            memo_guard.clear();
  171|      1|                    out_vec.push(self.nth(i).clone());
  171|      2|
  171|     20|                    }
  171|     20|            }
  171|   212k|        }
  171|     23|            array_seq
  171|     23|                combined.insert(value);
  171|    304|                out.push(node.key.clone());
  171|     31|            });
  171|      5|            }
  171|   555k|                vec_elements.sort();
  171|     56|                }
  171|      6|        }
  171|      6|        }
  171|      6|                combined.insert(value);
  171|      6|                combined.insert(value);
  171|      6|                combined.insert(value);
  171|      7|        }
  171|      7|                combined.insert(value);
  171|      9|            }
  171|     92|            Self::size_link(&*guard)
  171|       |        where
  172|       |
  172|       |
  172|       |
  172|       |
  172|       |
  172|       |
  172|       |
  172|       |
  172|       |
  172|       |
  172|       |
  172|       |
  172|       |
  172|       |
  172|       |
  172|       |
  172|       |                    }
  172|       |                },
  172|       |            }
  172|       |            }
  172|       |            };
  172|       |        )
  172|       |        )
  172|       |    }
  172|       |    }
  172|       |}
  172|       |}
  172|       |}
  172|       |            $crate::Chap06::LabDirGraphMtEph::LabDirGraphMtEph::LabDirGraphMtEph::empty()
  172|       |        $crate::Chap49::MinEditDistStPer::MinEditDistStPer::MinEditDistStPerS::from_sequences(
  172|      0|            }
  172|      0|                id
  172|      0|                memo_guard.len()
  172|      0|                self.memo.len()
  172|      1|                }
  172|      1|        }
  172|   117k|            }
  172|     13|            }
  172|     23|            }
  172|     23|        }
  172|     25|        }
  172|    263|            Some(node)
  172|      2|Benefits:
  172|      4|            }
  172|     57|                        neighbors.insert(labeled_arc.0.clone_mt());
  172|      5|                out.push(node.value.clone());
  172|      6|            }
  172|      6|            }
  172|      6|            }
  172|      6|        }
  172|      7|            }
  172|     92|        }
  172|      9|        where
  172|       |            vec![$($k),*],
  173|       |
  173|       |
  173|       |
  173|       |
  173|       |
  173|       |
  173|       |
  173|       |
  173|       |
  173|       |
  173|       |
  173|       |
  173|       |
  173|       |            )
  173|       |            }
  173|       |            }
  173|       |            }
  173|       |            };
  173|       |        }};
  173|       |    }
  173|       |    }
  173|       |    };
  173|       |            $crate::ArraySeqStPerS![$($s),*],
  173|       |        $crate::Chap49::MinEditDistMtPer::MinEditDistMtPer::MinEditDistMtPerS::from_sequences(
  173|       |        $crate::Chap50::MatrixChainStPer::MatrixChainStPer::MatrixChainStPerS::from_dim_pairs(
  173|      0|            }
  173|      0|        }
  173|      0|                left_result.union(&right_result)
  173|      0|            self.source
  173|      0|                        SetLit![]
  173|      0|            write!(
  173|      1|                }
  173|    155|                }
  173|     17|            }
  173|     19|        }
  173|    194|                    }
  173|      2|            }
  173|      2|        }
  173|     24|            }
  173|      3|            }
  173|     34|        left_vec.extend(right_vec);
  173|     35|            }
  173|    379|            }
  173|      4|    }
  173|      4|                all_entries.push(intersection.entries.nth(i).clone());
  173|      4|            Self::from_sorted_iter(combined.into_iter())
  173|      4|            Self::from_sorted_iter(combined.into_iter())
  173|      4|            Self::from_sorted_iter(combined.into_iter())
  173|      4|            Self::from_sorted_iter(combined.into_iter())
  173|      5|            }
  173|      5|        }
  173|    537|        }
  173|      5|            Self::from_sorted_iter(combined.into_iter())
  173|  63.0k|            ArraySeqStPerS::from_vec(values)
  173|      6|            Self::from_sorted_iter(combined.into_iter())
  173|      7|                out.push(node.key.clone());
  173|       |            vec![$(prob!($p)),*]
  174|       |
  174|       |
  174|       |
  174|       |
  174|       |
  174|       |
  174|       |
  174|       |
  174|       |
  174|       |
  174|       |
  174|       |
  174|       |
  174|       |
  174|       |                    };
  174|       |                }
  174|       |                },
  174|       |                },
  174|       |            }
  174|       |            })
  174|       |        )
  174|       |        {
  174|       |        }
  174|       |        }
  174|       |        }};
  174|       |    }
  174|       |}
  174|       |            $crate::ArraySeqStPerS![$($t),*]
  174|       |            $crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::ArraySeqMtPerS::from_vec(vec![$($s),*]),
  174|      0|            }
  174|      0|        }
  174|      0|                f,
  174|      0|                .into_iter()
  174|      0|                out.push(node.key.clone());
  174|      0|            write!(
  174|      1|            }
  174|      1|        }
  174|  1.16M|                    vec_elements.push(self.elements.nth(i).clone());
  174|    120|        }
  174|     13|        }
  174|     16|            &self,
  174|     17|        }
  174|      1|                    out_vec.push(self.nth(i).clone());
  174|      1|            true
  174|      1|            write!(
  174|      2|            }
  174|      3|        }
  174|     34|        ArraySeqStEphS::from_vec(left_vec)
  174|      4|            }
  174|      4|        }
  174|      4|        }
  174|      4|        }
  174|      4|        }
  174|      5|        }
  174|      5|        }
  174|   555k|        }
  174|      6|            }
  174|      6|        }
  174|  63.0k|        }
  174|    683|        }
  174|      7|            result
  174|      9|                a.nth(0).clone()
  174|      9|        total
  174|       |    #[macro_export]
  175|       |
  175|       |
  175|       |
  175|       |
  175|       |
  175|       |
  175|       |
  175|       |
  175|       |
  175|       |
  175|       |
  175|       |
  175|       |
  175|       |
  175|       |
  175|       |
  175|       |
  175|       |
  175|       |
  175|       |
  175|       |            }
  175|       |            }
  175|       |            }
  175|       |            })
  175|       |        )
  175|       |        )
  175|       |        }};
  175|       |    }
  175|       |    }
  175|       |    }
  175|       |    }
  175|       |    };
  175|       |            $crate::Chap18::ArraySeqMtPer::ArraySeqMtPer::ArraySeqMtPerS::from_vec(vec![$($t),*])
  175|       |        $crate::Chap49::SubsetSumStEph::SubsetSumStEph::SubsetSumStEphS::new()
  175|      0|                    });
  175|      0|                }
  175|      0|                f,
  175|      0|                .zip(self.target.into_iter())
  175|      1|                }
  175|      1|        }
  175|      1|        };
  175|     10|        }
  175|     11|        }
  175|  1.16M|                }
  175|     12|                vals.push(self.nth(i).clone());
  175|     14|        }
  175|      1|                f,
  175|      1|                .load_factor_manager
  175|      1|                union_entries.push(self.entries.nth(i).clone());
  175|      2|            }
  175|      2|        }
  175|      2|        }
  175|      3|            result
  175|    578|                        }
  175|      5|                        Self::rotate_right(link);
  175|      6|            }
  175|      7|        }
  175|     72|    }
  175|      8|        }
  175|      9|    }
  176|       |
  176|       |
  176|       |
  176|       |
  176|       |
  176|       |
  176|       |
  176|       |
  176|       |
  176|       |
  176|       |
  176|       |
  176|       |
  176|       |
  176|       |
  176|       |
  176|       |
  176|       |
  176|       |                    }
  176|       |        )
  176|       |        }
  176|       |    }
  176|       |    }
  176|       |    }
  176|       |    };
  176|       |    };
  176|       |    };
  176|       |}
  176|      0|            }
  176|      0|        }
  176|      0|                self.dimensions.len(),
  176|      1|            }
  176|      1|        }
  176|      1|        }
  176|      1|    }
  176|     11|            }
  176|     12|            }
  176|     14|                    }
  176|     15|        }
  176|    190|                    drop(guard);
  176|      1|            memo_guard.clear();
  176|      1|                        None
  176|      1|        true
  176|      2|
  176|     26|            }
  176|     26|        }
  176|     28|        }
  176|  2.84k|        }
  176|      3|        }
  176|      3|        }
  176|  37.6k|                vec_elements.push(x);
  176|     38|        });
  176|      5|        }
  176|      8|            }
  176|     89|            }
  177|       |
  177|       |
  177|       |
  177|       |
  177|       |
  177|       |
  177|       |
  177|       |
  177|       |
  177|       |
  177|       |
  177|       |
  177|       |
  177|       |
  177|       |
  177|       |
  177|       |
  177|       |                    }
  177|       |                {
  177|       |                }
  177|       |                };
  177|       |    }
  177|       |    }
  177|       |    };
  177|       |}
  177|       |}
  177|       |        $crate::Chap50::OptBinSearchTreeStPer::OptBinSearchTreeStPer::OBSTStPerS::new()
  177|      0|            {
  177|      0|            }
  177|      0|            }
  177|      0|        }
  177|      0|                left_result.union(&right_result)
  177|      0|                self.memo.len()
  177|      1|            }
  177|      1|        }
  177|      1|        }
  177|      1|        }
  177|      1|    }
  177|     13|        where
  177|     18|        }
  177|      1|            self.labeled_arcs()
  177|      1|                self.s_length(),
  177|      1|                true
  177|    208|                    quick_sort(right);
  177|    210|                        Some(&node.key)
  177|     25|            }
  177|     26|        }
  177|    263|        }
  177|      2|Costs:
  177|  37.6k|                vec_elements.sort();
  177|      3|                ArraySeqMtPerS::from_vec(kept)
  177|      4|            AVLTreeSeqStEphS::from_vec(vals)
  177|      6|        neighbors
  177|      6|        where
  177|      6|        where
  177|      6|        where
  177|      7|        where
  177|      7|        where
  177|      9|                keys_guard.len()
  178|       |
  178|       |
  178|       |
  178|       |
  178|       |
  178|       |
  178|       |
  178|       |
  178|       |
  178|       |
  178|       |
  178|       |
  178|       |
  178|       |                }
  178|       |            )
  178|       |            )
  178|       |            }
  178|       |            };
  178|       |        }};
  178|       |        }};
  178|       |    ///
  178|       |    }
  178|       |    }
  178|       |    }
  178|       |    }
  178|       |    };
  178|       |        $crate::Chap49::MinEditDistStPer::MinEditDistStPer::MinEditDistStPerS::new()
  178|       |        $crate::Chap50::MatrixChainStPer::MatrixChainStPer::MatrixChainStPerS::new()
  178|      0|            }
  178|      0|        }
  178|      0|        }
  178|      1|            }
  178|    178|                        sort(right);
  178|      1|            ArraySeqStPerS::from_vec(out)
  178|      1|                .iter()
  178|      1|                self.t_length()
  178|    208|                });
  178|     33|                out.push(node.key.clone());
  178|      6|        }
  178|      6|    }
  178|      9|                all_entries.push(left_diff.entries.nth(i).clone());
  178|       |            __set
  179|       |
  179|       |
  179|       |
  179|       |
  179|       |
  179|       |
  179|       |
  179|       |
  179|       |
  179|       |
  179|       |
  179|       |            )
  179|       |            }
  179|       |        {
  179|       |        {
  179|       |        {
  179|       |        {
  179|       |        {
  179|       |        {
  179|       |        }};
  179|       |    }
  179|       |    }
  179|       |    }
  179|       |    }
  179|       |    };
  179|       |    };
  179|       |}
  179|       |        $crate::Chap49::MinEditDistMtPer::MinEditDistMtPer::MinEditDistMtPerS::new()
  179|      0|            }
  179|      0|        }
  179|      0|        }
  179|      0|                false
  179|      0|            memo_guard.len()
  179|      1|        }
  179|      1|        }
  179|  1.06k|                values.push(f(i));
  179|     15|                out.push(node.key.clone());
  179|   171k|            }
  179|    178|                    });
  179|     18|                        Some(key)
  179|    243|            }
  179|    274|            }
  179|     28|        }
  179|      3|        }
  179|    421|            }
  179|      5|    }
  179|      8|            {
  179|      9|            }
  179|       |    #[macro_export]
  180|       |
  180|       |
  180|       |
  180|       |
  180|       |
  180|       |
  180|       |
  180|       |
  180|       |
  180|       |
  180|       |
  180|       |
  180|       |
  180|       |
  180|       |
  180|       |
  180|       |
  180|       |
  180|       |
  180|       |
  180|       |
  180|       |
  180|       |                    };
  180|       |                },
  180|       |            }
  180|       |    }
  180|       |    }
  180|       |    }
  180|       |    }
  180|       |    }
  180|       |    };
  180|       |}
  180|       |}
  180|      0|            }
  180|      0|        }
  180|      0|        where
  180|      1|            }
  180|      1|        }
  180|      1|        }
  180|  1.06k|            }
  180|    108|                    });
  180|     12|            }
  180|  1.85k|            }
  180|    243|        }
  180|    274|        }
  180|      2|        assert!(intersection.find(&4));
  180|    361|                }
  180|  37.6k|                }
  180|     41|                }
  180|      4|            memo_guard.len()
  180|      5|                    return;
  180|      6|                        });
  180|      6|            }
  180|      6|        where
  180|    759|                        .right
  180|      8|                        Some(&node.key)
  181|       |
  181|       |
  181|       |
  181|       |
  181|       |
  181|       |
  181|       |
  181|       |
  181|       |
  181|       |
  181|       |                {
  181|       |                }
  181|       |                }
  181|       |            }
  181|       |            }
  181|       |            };
  181|       |        }
  181|       |        }
  181|       |    }
  181|       |    }
  181|       |    }
  181|       |}
  181|       |}
  181|      0|        }
  181|      0|                    .intersection(&other_right));
  181|      0|            None
  181|      1|                }
  181|      1|        }
  181|      1|        }
  181|     10|        }
  181|     13|                .tree
  181|     16|            }
  181|    172|                        drop(right_guard);
  181|  1.85k|        }
  181|      2|
  181|     20|            ArraySeqMtEphSliceS::from_vec(values)
  181|     23|        }
  181|     26|        }
  181|      2|        assert!(intersection.find(&5));
  181|     35|            }
  181|      3|            acc
  181|      3|            memo_guard.len()
  181|      3|                        Some(self.elements[pos].clone())
  181|      4|        }
  181|      5|                sort(data);
  181|      6|                .tree
  181|      6|                .tree
  181|      6|                .tree
  181|    759|                        .as_ref()
  181|  7.77k|                    values.push(item.clone());
  181|      7|                .tree
  181|      7|                .tree
  181|      7|                union_entries.push(other.entries.nth(j).clone());
  181|      8|                memo_guard.clear();
  181|       |                __s
  182|       |
  182|       |
  182|       |
  182|       |
  182|       |
  182|       |
  182|       |
  182|       |
  182|       |
  182|       |
  182|       |
  182|       |
  182|       |
  182|       |
  182|       |
  182|       |
  182|       |                    }
  182|       |                },
  182|       |            }
  182|       |            };
  182|       |        {
  182|       |    }
  182|       |    }
  182|       |    }
  182|       |    }
  182|       |}
  182|       |}
  182|       |            $crate::Chap06::LabDirGraphStEph::LabDirGraphStEph::LabDirGraphStEph::empty()
  182|      0|                };
  182|      0|        println!("]");
  182|      1|        }
  182|     10|    }
  182|     13|                .in_order()
  182|    156|                        });
  182|     16|            }
  182|    172|                        rightmost(&child)
  182|    180|            }
  182|     20|        }
  182|    229|        }
  182|      2|        assert!(!intersection.find(&1));
  182|      2|Implementation:
  182|      2|            None
  182|      3|        }
  182|      3|        }
  182|     30|        }
  182|     31|        }
  182|  37.6k|        }
  182|      5|            });
  182|  51.6k|                }
  182|     68|        }
  182|      6|                .in_order()
  182|      6|                .in_order()
  182|      6|                .in_order()
  182|      7|                .in_order()
  182|      7|                .in_order()
  182|      8|            }
  182|      8|            }
  183|       |
  183|       |
  183|       |
  183|       |
  183|       |
  183|       |
  183|       |
  183|       |
  183|       |
  183|       |
  183|       |
  183|       |
  183|       |
  183|       |
  183|       |
  183|       |
  183|       |
  183|       |
  183|       |                    }
  183|       |                }
  183|       |            }
  183|       |            }
  183|       |        {
  183|       |        }};
  183|       |    }
  183|       |    }
  183|       |    }
  183|       |                $(
  183|      0|            left_result.union(&right_result)
  183|    108|                result.extend(right_intersect);
  183|     13|                .iter()
  183|     14|        }
  183|    158|                    {
  183|     16|        }
  183|      1|            memo_guard.len()
  183|      1|                        None
  183|      1|                None
  183|     20|            }
  183|      2|        assert!(!intersection.find(&6));
  183|      2|        total
  183|      3|        }
  183|     38|        result
  183|      5|        }
  183|      6|                .iter()
  183|      6|                .iter()
  183|      6|                .iter()
  183|      7|            }
  183|      7|                .iter()
  183|      7|                .iter()
  183|      9|                all_entries.push(right_diff.entries.nth(i).clone());
  183|       |            std::iter::Zip<
  184|       |
  184|       |
  184|       |
  184|       |
  184|       |
  184|       |
  184|       |
  184|       |
  184|       |
  184|       |
  184|       |
  184|       |
  184|       |
  184|       |
  184|       |                    }
  184|       |                    };
  184|       |                }
  184|       |                },
  184|       |                },
  184|       |            }
  184|       |            }
  184|       |        }
  184|       |        }}}
  184|       |    }
  184|       |    }
  184|       |}
  184|      0|                }
  184|      0|                v.clone()
  184|      1|        }
  184|      1|        }
  184|  1.08k|            ArraySeqStPerS::from_vec(values)
  184|    108|                result
  184|    158|                        Self::rotate_left(link);
  184|      1|            ArraySeqStPerS::from_vec(out)
  184|      2|    }
  184|     21|        }
  184|     22|        }
  184|  24.9k|                return;
  184|      3|        }
  184|      5|        }
  184|      8|            height_rec(&*guard)
  184|      9|            }
  184|    929|                elements.push(array_seq.nth(i).clone());
  184|     99|    }
  184|       |    #[macro_export]
  184|       |        where
  185|       |
  185|       |
  185|       |
  185|       |
  185|       |
  185|       |
  185|       |
  185|       |
  185|       |
  185|       |
  185|       |
  185|       |
  185|       |
  185|       |
  185|       |
  185|       |
  185|       |                    }
  185|       |                    }
  185|       |                }
  185|       |            );
  185|       |            }
  185|       |            }
  185|       |            }
  185|       |    }
  185|       |    }
  185|       |    }
  185|       |    }
  185|       |    }
  185|       |}
  185|      0|        }
  185|      0|                return;
  185|      1|        }
  185|     10|            }
  185|     10|        }
  185|  1.08k|        }
  185|  1.19k|        }
  185|     13|                .collect();
  185|    144|            }
  185|     18|            &self.data[s..e]
  185|      1|                a.length(),
  185|      1|            write!(
  185|     20|                }
  185|    218|            }
  185|    233|            }
  185|      4|                    None
  185|    601|                    }
  185|      6|                .collect();
  185|      6|                .collect();
  185|      6|                .collect();
  185|      7|                .collect();
  185|      7|                .collect();
  185|      8|            {
  185|      8|        }
  185|    929|            }
  186|       |
  186|       |
  186|       |
  186|       |
  186|       |
  186|       |
  186|       |
  186|       |
  186|       |
  186|       |
  186|       |
  186|       |
  186|       |
  186|       |
  186|       |
  186|       |
  186|       |
  186|       |
  186|       |                }
  186|       |                }
  186|       |                }
  186|       |                }
  186|       |            )
  186|       |            >,
  186|       |            }
  186|       |            }
  186|       |            }
  186|       |    }
  186|       |    }
  186|       |    }
  186|       |    }
  186|       |}
  186|       |}
  186|      0|                }
  186|      1|        }
  186|      1|        }
  186|   116k|            Self::fix_up(link);
  186|     13|            Self::from_sorted_iter(filtered.into_iter())
  186|    144|        }
  186|     18|        }
  186|      1|                f,
  186|      1|        where
  186|      2|
  186|    233|        }
  186|     26|        }
  186|  2.88k|        }
  186|      3|            result
  186|      4|            }
  186|      6|        }
  186|      6|            Self::from_sorted_iter(filtered.into_iter())
  186|      6|            Self::from_sorted_iter(filtered.into_iter())
  186|      6|            Self::from_sorted_iter(filtered.into_iter())
  186|      7|            Self::from_sorted_iter(filtered.into_iter())
  186|      7|            Self::from_sorted_iter(filtered.into_iter())
  186|     96|            }
  186|     96|            AVLTreeSeqStPerS::from_vec(elements)
  186|       |#[macro_export]
  187|       |
  187|       |
  187|       |
  187|       |
  187|       |
  187|       |
  187|       |
  187|       |
  187|       |
  187|       |
  187|       |
  187|       |
  187|       |
  187|       |
  187|       |
  187|       |                    ));
  187|       |                    }
  187|       |            }
  187|       |            }
  187|       |            }
  187|       |            }
  187|       |    ///
  187|       |    }
  187|       |    }
  187|       |    }
  187|       |    }
  187|       |    }
  187|       |            $crate::Chap06::LabDirGraphMtEph::LabDirGraphMtEph::LabDirGraphMtEph::empty()
  187|      0|                None
  187|      1|            }
  187|      1|        }
  187|     10|        }
  187|     12|            }
  187|     13|        }
  187|   140k|        }
  187|    194|            }
  187|      1|                id
  187|      2|            None
  187|      3|        }
  187|     42|                }
  187|      6|        }
  187|      6|        }
  187|      6|        }
  187|      7|        }
  187|      7|        }
  187|      8|        }
  187|    805|                    }
  187|      8|                memo_guard.clear();
  187|     96|        }
  187|     96|        }
  188|       |
  188|       |
  188|       |
  188|       |
  188|       |
  188|       |
  188|       |
  188|       |
  188|       |
  188|       |
  188|       |
  188|       |
  188|       |
  188|       |
  188|       |
  188|       |
  188|       |
  188|       |
  188|       |
  188|       |
  188|       |
  188|       |
  188|       |
  188|       |
  188|       |                    };
  188|       |                }
  188|       |            };
  188|       |        >;
  188|       |        {
  188|       |        }};
  188|       |        }};
  188|      0|            }
  188|      0|                root
  188|      1|                }
  188|      1|        }
  188|     14|        }
  188|      1|                self.s_length(),
  188|      2|            }
  188|      2|        "#
  188|     20|                unique_probe_positions,
  188|  2.27k|        }
  188|     25|            }
  188|      2|        assert!(difference.find(&1));
  188|      2|            Self::from_seq(AVLTreeSeqStEphS::from_vec(intersect))
  188|     32|        }
  188|      7|        }
  188|      8|            }
  188|       |    #[macro_export]
  189|       |
  189|       |
  189|       |
  189|       |
  189|       |
  189|       |
  189|       |
  189|       |
  189|       |
  189|       |
  189|       |
  189|       |
  189|       |
  189|       |
  189|       |
  189|       |
  189|       |                }
  189|       |            }
  189|       |            }
  189|       |    ///
  189|       |    }
  189|       |    }
  189|       |    }
  189|       |        $crate::Chap49::SubsetSumMtEph::SubsetSumMtEph::SubsetSumMtEphS::from_multiset(
  189|      0|                left_result.union(&right_result)
  189|      1|            }
  189|      1|        }
  189|     10|                a.nth(0).clone()
  189|    135|            }
  189|     15|            vertices.insert(i);
  189|     17|            Self::min_link(&*guard).cloned()
  189|      1|                self.t_length()
  189|      2|        }
  189|      2|        }
  189|      2|        };
  189|     20|                probe_sequence_period,
  189|     22|            rightmost(&self.root)
  189|      2|        assert!(difference.find(&2));
  189|      2|        .to_string()
  189|      3|                }
  189|     62|        }
  189|     80|        }
  189|      8|            dimensions_guard.clone()
  189|       |                    edges.insert(normalized_edge);
  190|       |
  190|       |
  190|       |
  190|       |
  190|       |
  190|       |
  190|       |
  190|       |
  190|       |
  190|       |
  190|       |
  190|       |
  190|       |
  190|       |
  190|       |                )*
  190|       |                }
  190|       |            )
  190|       |            }
  190|       |            }
  190|       |    }
  190|       |            $crate::ArraySeqMtEphSLit![$($x),*]
  190|      0|            }
  190|      0|        }
  190|      0|                        s.insert(arcs[0].0.clone_mt());
  190|    112|            }
  190|    135|        }
  190|     15|        }
  190|     17|        }
  190|     17|        }
  190|      2|    }
  190|     21|            }
  190|     21|        }
  190|     22|        }
  190|      2|        assert!(difference.find(&3));
  190|      3|            }
  190|    315|        }
  190|      4|        where
  190|      4|        where
  190|      4|        where
  190|      4|        where
  190|     50|        }
  190|      5|        where
  190|      8|        }
  190|      9|        where
  191|       |
  191|       |
  191|       |
  191|       |
  191|       |
  191|       |
  191|       |
  191|       |
  191|       |
  191|       |
  191|       |
  191|       |
  191|       |
  191|       |
  191|       |
  191|       |
  191|       |
  191|       |        )
  191|       |        }
  191|       |}
  191|       |}
  191|      0|        }
  191|      0|                        s
  191|      0|            self.source
  191|      1|            }
  191|      1|        }
  191|      1|    }
  191|    165|                out.push(node.key.clone());
  191|      1|                hash1,
  191|      1|            out
  191|    201|            }
  191|     20|                relative_prime_validation,
  191|      2|        assert!(!difference.find(&4));
  191|    305|                out.push(node.key.clone());
  191|     31|            };
  191|      6|            }
  191|      6|            result
  191|    781|                    Self::update_node(node);
  191|      9|        }
  191|      9|                results.push(acc.clone());
  191|       |                edges
  192|       |
  192|       |
  192|       |
  192|       |
  192|       |
  192|       |
  192|       |
  192|       |
  192|       |
  192|       |                }
  192|       |            };
  192|       |        {
  192|       |        {
  192|       |        {
  192|       |        {
  192|       |        {
  192|       |        {
  192|       |        };
  192|       |    }
  192|       |    };
  192|      0|                }
  192|      0|        }
  192|      0|                .clone()
  192|      0|        None
  192|      1|        }
  192|      1|        }
  192|      1|        }
  192|      1|        }
  192|      1|    }
  192|  1.03k|        }
  192|      1|                hash2,
  192|      1|            height_rec(&self.root)
  192|      2|        }
  192|     20|                collision_avoidance_score,
  192|     28|            vertices.insert(i);
  192|      2|        assert!(!difference.find(&5));
  192|     30|            }
  192|     31|            it.push_left(root);
  192|      3|                vals.push(self.nth(i).clone());
  192|      6|        }
  192|      6|        }
  192|  6.36k|                    values.push(inner_seq.nth(j).clone());
  192|    781|                }
  192|      9|            }
  193|       |
  193|       |
  193|       |
  193|       |
  193|       |
  193|       |
  193|       |
  193|       |
  193|       |
  193|       |
  193|       |
  193|       |                },
  193|       |            }
  193|       |        }};
  193|       |    }
  193|       |    }
  193|       |    }
  193|       |}
  193|       |}
  193|      0|                .into_iter()
  193|      0|                        Set::empty()
  193|      1|            {
  193|      1|        }
  193|    144|            }
  193|    173|            }
  193|      1|                memo_guard.len()
  193|      2|            }
  193|     20|            }
  193|  26.3k|        }
  193|     28|        }
  193|      2|                None
  193|      3|            }
  193|      3|    }
  193|     31|            it
  193|    383|            }
  193|      4|            self.tree
  193|      4|            self.tree
  193|      4|            self.tree
  193|      4|            self.tree
  193|     58|        }
  193|  5.80k|            }
  193|      5|            self.tree
  193|  6.36k|                }
  193|      9|            self.tree
  194|       |
  194|       |
  194|       |
  194|       |
  194|       |
  194|       |
  194|       |
  194|       |
  194|       |
  194|       |
  194|       |
  194|       |
  194|       |
  194|       |
  194|       |
  194|       |
  194|       |
  194|       |
  194|       |                    };
  194|       |            }
  194|       |            }
  194|       |            };
  194|       |            };
  194|       |        }};
  194|       |    }
  194|       |    }
  194|       |        $crate::Chap49::SubsetSumMtEph::SubsetSumMtEph::SubsetSumMtEphS::new()
  194|      0|                .zip(self.target.clone().into_iter())
  194|      1|            }
  194|      1|            }
  194|      1|        }
  194|     16|                1.0
  194|     17|            Self::max_link(&*guard).cloned()
  194|      1|        r#"
  194|      1|            Self::from_vec(vals)
  194|     20|        }
  194|      2|            words
  194|     31|        }
  194|    338|        }
  194|    429|                        Some(&node.key)
  194|      4|                .in_order()
  194|      4|                .in_order()
  194|      4|                .in_order()
  194|      4|                .in_order()
  194|     56|            }
  194|  5.80k|        }
  194|      5|                .in_order()
  194|      6|                }
  194|    688|        }
  194|      6|            height_rec(&self.root)
  194|     76|                }
  194|      9|                .in_order()
  195|       |
  195|       |
  195|       |
  195|       |
  195|       |
  195|       |
  195|       |
  195|       |
  195|       |
  195|       |
  195|       |                    }
  195|       |            }
  195|       |            }
  195|       |            }
  195|       |    }
  195|       |    }
  195|       |    }
  195|       |    };
  195|      0|                }
  195|      0|                }
  195|      0|        }
  195|      0|                memo_guard.len()
  195|      0|            new_table
  195|      1|        }
  195|      1|        }
  195|      1|    }
  195|     17|        }
  195|     19|        }
  195|     19|                Some(self.elements.nth(0))
  195|      1|            write!(
  195|      2|        }
  195|      2|        }
  195|    229|            ArraySeqStPerS::from_vec(values)
  195|  4.47k|                values.push(f(i));
  195|      4|                ArraySeqMtEphS::tabulate(
  195|      4|                .iter()
  195|      4|                .iter()
  195|      4|                .iter()
  195|      4|                .iter()
  195|      4|                None
  195|      5|                .iter()
  195|      6|            }
  195|      6|        }
  195|      6|            ArraySeqStPerS::from_vec(out)
  195|     72|            }
  195|      9|                .iter()
  195|      9|            keys_guard.clone()
  196|       |
  196|       |
  196|       |
  196|       |
  196|       |
  196|       |
  196|       |
  196|       |
  196|       |
  196|       |
  196|       |
  196|       |
  196|       |
  196|       |
  196|       |
  196|       |
  196|       |                }
  196|       |                },
  196|       |            }
  196|       |            };
  196|       |        }
  196|       |    ///
  196|       |    }
  196|       |}
  196|       |}
  196|       |}
  196|      0|        }
  196|      0|        }
  196|      1|
  196|      1|            }
  196|     10|                    result.push(key.clone());
  196|    131|            }
  196|    199|            }
  196|      1|                f,
  196|      1|            self.base_table.difference(&other.base_table);
  196|      1|        tokens(&sample_content.to_string())
  196|      2|        }
  196|     21|            Self::from_vec(vals)
  196|    229|        }
  196|     26|        }
  196|      2|            None
  196|      2|        set_delete.delete(&3);
  196|      3|        where
  196|  4.47k|            }
  196|      6|        }
  196|      8|                handles.push(handle);
  196|      9|        }
  196|       |    #[macro_export]
  196|       |            __tree
  197|       |
  197|       |
  197|       |
  197|       |
  197|       |
  197|       |
  197|       |
  197|       |
  197|       |
  197|       |
  197|       |            }
  197|       |            }
  197|       |            }
  197|       |            }
  197|       |            }
  197|       |        }};
  197|       |    }
  197|       |    }
  197|       |    }
  197|       |}
  197|      0|                return;
  197|      0|            write!(
  197|      1|            }
  197|      1|        }
  197|      1|    }
  197|     10|                    result.extend(right.to_vec());
  197|    129|                }
  197|    154|        }
  197|  1.88k|                elements.push(array_seq.nth(i).clone());
  197|      1|                memo_guard.len()
  197|     21|        }
  197|     22|        }
  197|     24|        }
  197|  3.28k|                    sequence.push(pos);
  197|    361|            ArraySeqStEphS::from_vec(values)
  197|      4|        }
  197|      4|        }
  197|      4|        }
  197|      4|        }
  197|      5|        }
  197|      6|        neighbors
  197|      6|                Some(entries.nth(0).0.clone())
  197|      9|        }
  197|    980|        }
  198|       |
  198|       |
  198|       |
  198|       |
  198|       |
  198|       |
  198|       |
  198|       |
  198|       |
  198|       |
  198|       |
  198|       |
  198|       |
  198|       |
  198|       |
  198|       |
  198|       |
  198|       |
  198|       |
  198|       |
  198|       |
  198|       |
  198|       |            }
  198|       |            }
  198|       |            };
  198|       |        {
  198|       |    }
  198|      0|            }
  198|      0|            }
  198|      0|                f,
  198|      0|        where
  198|      1|
  198|      1|        }
  198|     10|                    result
  198|    165|                self.stack.push(node);
  198|    179|        }
  198|     18|        }
  198|  1.88k|            }
  198|      1|                self.dimensions.len(),
  198|      2|        }
  198|  2.59M|                values.push(f(i));
  198|      2|        assert!(!set_delete.find(&3));
  198|     34|        }
  198|    361|        }
  198|      3|                out.push(node.key.clone());
  198|      6|    }
  198|      8|                out.push(node.key.clone());
  198|    907|            }
  199|       |
  199|       |
  199|       |
  199|       |
  199|       |
  199|       |
  199|       |
  199|       |
  199|       |
  199|       |
  199|       |
  199|       |
  199|       |
  199|       |                    }
  199|       |                }
  199|       |    ///
  199|       |    }
  199|       |            $crate::Chap45::UnsortedListPQ::UnsortedListPQ::UnsortedListPQ::empty()
  199|      0|                    }
  199|      0|        }
  199|      0|        where
  199|      0|            write!(
  199|      1|                }
  199|      1|            {
  199|     10|        }
  199|    116|            AVLTreeSeqStPerS::from_vec(elements)
  199|    123|            }
  199|     16|                table_size,
  199|      1|Algorithm:
  199|      1|            memo_guard.clear();
  199|      2|            }
  199|     20|                }
  199|    241|                    drop(guard);
  199|  2.59M|            }
  199|      2|        assert!(set_delete.find(&1));
  199|     62|                pattern
  199|    648|            }
  199|      8|            }
  199|    912|        }
  199|       |    #[macro_export]
  199|       |                memo_size
  200|       |
  200|       |
  200|       |
  200|       |
  200|       |
  200|       |
  200|       |
  200|       |
  200|       |
  200|       |
  200|       |
  200|       |
  200|       |
  200|       |
  200|       |
  200|       |                }
  200|       |            )
  200|       |            }
  200|       |            }
  200|       |            }
  200|       |        {
  200|       |        }
  200|       |        };
  200|       |    }
  200|       |    }
  200|       |    }
  200|       |}
  200|      0|                f,
  200|      1|        }
  200|      1|        }
  200|      1|        }
  200|    116|        }
  200|    117|            }
  200|     15|            }
  200|    165|            }
  200|     16|                load_factor,
  200|    293|                        break;
  200|      2|            acc
  200|      2|        assert!(set_delete.find(&2));
  200|      2|        compare_all_heapsorts(&input)
  200|      2|            values.remove(max_index);
  200|      3|        }
  200|    328|        }
  200|    436|            }
  200|  4.61k|            ArraySeqMtEphS::from_vec(values)
  200|    528|                    },
  200|    648|        }
  200|      6|                        difference_entries.push(pair1.clone());
  200|      7|                        });
  200|      9|            new_table
  201|       |
  201|       |
  201|       |
  201|       |
  201|       |
  201|       |
  201|       |
  201|       |
  201|       |
  201|       |
  201|       |
  201|       |            )
  201|       |            }
  201|       |        {
  201|       |        }
  201|       |    }
  201|       |    }
  201|      0|                "{{{}}}",
  201|      0|        println!("]");
  201|      1|        }
  201|     11|            }
  201|    118|        }
  201|    190|        }
  201|    191|        }
  201|      2|            }
  201|      2|        }
  201|      2|    }
  201|     22|        }
  201|    241|                    out.push(key);
  201|  2.99k|                    }
  201|      2|        assert!(set_delete.find(&4));
  201|      2|            None
  201|     32|        }
  201|  39.5k|            }
  201|      3|            self.data.push(value);
  201|      4|            }
  201|  4.61k|        }
  201|      4|                    left_entries.length(),
  201|     75|            ArraySeqStPerS::from_vec(out)
  201|      9|        }
  201|     90|        }
  202|       |
  202|       |
  202|       |
  202|       |
  202|       |
  202|       |
  202|       |
  202|       |
  202|       |
  202|       |
  202|       |
  202|       |
  202|       |
  202|       |
  202|       |
  202|       |
  202|       |
  202|       |
  202|       |
  202|       |
  202|       |
  202|       |                )
  202|       |                }
  202|       |            }
  202|       |    }
  202|       |    }
  202|       |    }
  202|      0|        }
  202|      0|                (0..self.size())
  202|      1|            }
  202|    121|            }
  202|     19|        }
  202|  1.92k|        }
  202|      1|            self.base_table.restrict(keys);
  202|     24|                }
  202|      2|        assert!(set_delete.find(&5));
  202|  39.5k|        }
  202|      3|            self
  202|      5|                values.push(f(i));
  202|      6|                    }
  202|      7|        }
  202|     75|        }
  202|      8|        }
  202|      8|        result
  202|      8|                results.push(handle.join().unwrap());
  202|       |            std::iter::Zip<
  203|       |
  203|       |
  203|       |
  203|       |
  203|       |
  203|       |
  203|       |
  203|       |
  203|       |
  203|       |
  203|       |
  203|       |
  203|       |
  203|       |
  203|       |
  203|       |
  203|       |                },
  203|       |        };
  203|       |    }
  203|       |    }
  203|       |    }
  203|       |            $(
  203|    103|            Self::size_link(&*guard)
  203|    156|                        });
  203|     15|                values.push(f(a.nth(i)));
  203|     16|                double_hashing_quality,
  203|      2|            }
  203|     24|            }
  203|      3|        }
  203|      3|        }
  203|    301|                probe_sequences.insert(sequence);
  203|    331|                }
  203|      4|            });
  203|      4|        }
  203|    436|            Ok(ArraySeqMtPerS::from_vec(new_data))
  203|      5|            }
  203|      8|            }
  203|      8|    }
  203|     99|            }
  204|       |
  204|       |
  204|       |
  204|       |
  204|       |
  204|       |
  204|       |
  204|       |
  204|       |
  204|       |
  204|       |
  204|       |
  204|       |
  204|       |
  204|       |
  204|       |
  204|       |
  204|       |
  204|       |            }
  204|       |            }
  204|       |        );
  204|       |        }
  204|       |        }
  204|       |    ///
  204|       |    }
  204|       |    }
  204|       |}
  204|      0|            }
  204|      0|                    .collect::<Vec<_>>()
  204|      1|
  204|      1|            {
  204|      1|            }
  204|      1|        }
  204|      1|        }
  204|    103|        }
  204|    134|        }
  204|     15|            }
  204|      1|            ArraySeqS::from_vec(values)
  204|      1|            self.base_table.difference(&other.base_table);
  204|      2|            }
  204|      2|            };
  204|    271|                        Some(&node.value)
  204|    437|        }
  204|      5|    }
  204|     51|            }
  204|    572|            }
  204|      5|        where
  204|    676|            out
  205|       |
  205|       |
  205|       |
  205|       |
  205|       |
  205|       |
  205|       |
  205|       |
  205|       |
  205|       |
  205|       |
  205|       |
  205|       |
  205|       |
  205|       |
  205|       |
  205|       |
  205|       |
  205|       |
  205|       |                    }
  205|       |            )*
  205|       |            >,
  205|       |        }
  205|       |    }
  205|       |    }
  205|      0|                    }
  205|      0|            out
  205|      1|        }
  205|      1|        }
  205|     16|                performance_impact,
  205|     17|        }
  205|      1|Cost Analysis:
  205|      1|            memo_guard.clear();
  205|      2|            ArraySeqMtEphSliceS::<U>::from_vec(results)
  205|      2|                    continue;
  205|      3|            ArraySeqStEphS::from_vec(values)
  205|  50.7k|                    }
  205|    676|        }
  206|       |
  206|       |
  206|       |
  206|       |
  206|       |
  206|       |
  206|       |
  206|       |
  206|       |
  206|       |
  206|       |
  206|       |
  206|       |
  206|       |                }
  206|       |                }
  206|       |                },
  206|       |            )
  206|       |        {
  206|       |    ///
  206|       |    }
  206|       |    }
  206|      0|            }
  206|      0|        }
  206|      1|        }
  206|      1|        }
  206|    121|                vals.extend(other.elements.values_in_order());
  206|     12|            vec![
  206|     16|            }
  206|     17|                                    Entry::Dead
  206|      2|            (
  206|      2|        }
  206|     24|                }
  206|      2|                    break;
  206|      2|        compare_all_heapsorts(&input)
  206|      2|        set_insert.insert(3);
  206|      3|        }
  206|      3|        }
  206|      4|                None
  206|    563|            out
  206|      9|        true
  206|       |#[macro_export]
  206|       |            pq
  207|       |
  207|       |
  207|       |
  207|       |
  207|       |
  207|       |
  207|       |
  207|       |
  207|       |
  207|       |
  207|       |
  207|       |
  207|       |
  207|       |
  207|       |
  207|       |
  207|       |
  207|       |                    ));
  207|       |            }
  207|       |            }
  207|       |        >;
  207|       |        }};
  207|       |}
  207|      0|        }
  207|      0|            result
  207|      1|            }
  207|     10|    }
  207|    121|                vals.sort();
  207|     16|                    }
  207|     16|        }
  207|      2|                }
  207|      2|        }
  207|      2|    }
  207|      3|        }
  207|     38|    }
  207|  3.99k|        where
  207|    563|        }
  207|       |    #[macro_export]
  208|       |
  208|       |
  208|       |
  208|       |
  208|       |
  208|       |
  208|       |
  208|       |
  208|       |
  208|       |
  208|       |
  208|       |
  208|       |
  208|       |
  208|       |                    }
  208|       |            }
  208|       |    }
  208|       |    }
  208|       |    }
  208|       |}
  208|      0|                }
  208|      0|            }
  208|      0|        }
  208|     11|        }
  208|    121|                vals.dedup();
  208|    144|                                    self.table.nth(i).clone()
  208|     16|        }
  208|      1|            ArraySeqStPerS::from_vec(out)
  208|      1|            self.base_table.subtract(keys);
  208|  22.4k|                tree.insert(value);
  208|      2|        assert!(set_insert.find(&3));
  208|     30|                tree.insert(value);
  208|     30|                tree.insert(value);
  208|     30|                tree.insert(value);
  208|     30|                tree.insert(value);
  208|     36|                tree.insert(value);
  208|      3|                None
  208|     42|                        Some(&node.key)
  208|      5|        }
  208|     50|        merged.extend(pair.1);
  208|     90|            ArraySeqStPerS::from_vec(values)
  208|       |            __tree
  209|       |
  209|       |
  209|       |
  209|       |
  209|       |
  209|       |
  209|       |
  209|       |
  209|       |
  209|       |
  209|       |
  209|       |
  209|       |
  209|       |
  209|       |                                };
  209|       |                    }
  209|       |                }
  209|       |            }
  209|       |        {
  209|       |        }};
  209|       |        $crate::Chap50::OptBinSearchTreeStEph::OptBinSearchTreeStEph::OBSTStEphS::from_keys_probs(
  209|      0|            }
  209|      0|                left_result.union(&right_result)
  209|      0|        where
  209|      1|            {
  209|      1|        }
  209|  12.3k|                values.push(f(i));
  209|    145|            }
  209|    160|            self.push_left(&node.right);
  209|      2|                },
  209|  22.4k|            }
  209|      3|                    }
  209|     30|            }
  209|     30|            }
  209|     30|            }
  209|     30|            }
  209|     33|    }
  209|     36|            }
  209|     48|            }
  209|     50|        merged
  209|     90|        }
  209|       |#[macro_export]
  210|       |
  210|       |
  210|       |
  210|       |
  210|       |
  210|       |
  210|       |
  210|       |
  210|       |                }
  210|       |                }
  210|       |                },
  210|       |            ]
  210|       |            }
  210|       |            }
  210|       |    }
  210|       |    }
  210|       |    }
  210|       |            $crate::Chap50::MatrixChainStEph::MatrixChainStEph::MatrixChainStEphS::from_dim_pairs(
  210|      0|            }
  210|      0|            }
  210|      0|            self.source
  210|      1|        }
  210|     10|        }
  210|    120|    }
  210|  12.3k|            }
  210|    145|        }
  210|    160|            Some(value_ref)
  210|      1|            memo_guard.clear();
  210|      1|            self.base_table.restrict(keys);
  210|    280|            tree
  210|      2|                found,
  210|     45|                out.push(node.key.clone());
  210|     48|        }
  210|    528|                },
  210|      5|                Some(entries.nth(0).0.clone())
  210|      6|            }
  210|      6|            tree
  210|      6|            tree
  210|      6|            tree
  210|      6|            tree
  210|      7|            tree
  210|     95|            Self::size_link(&*guard)
  210|       |    #[allow(dead_code)]
  210|       |    #[macro_export]
  210|       |            vec![$($k),*],
  211|       |
  211|       |
  211|       |
  211|       |
  211|       |
  211|       |
  211|       |
  211|       |
  211|       |
  211|       |
  211|       |
  211|       |                    }
  211|       |            }
  211|       |            }
  211|       |            }
  211|       |            }
  211|       |        {
  211|       |        }
  211|       |        }
  211|       |    }
  211|      0|        }
  211|      0|                .clone()
  211|      0|            distances,
  211|      1|
  211|      1|        }
  211|      1|        }
  211|     12|        }
  211|    121|                };
  211|     15|            }
  211|    159|                    sv.push(self_seq.nth(i).clone());
  211|     18|                0
  211|    187|        }
  211|     20|                }
  211|    280|        }
  211|      2|        set_insert.insert(3);
  211|      3|        }
  211|    315|        }
  211|      3|            Ok(self)
  211|      4|                right_entries.length(),
  211|      5|                values.push(f(a.nth(i)));
  211|      6|        }
  211|      6|        }
  211|      6|        }
  211|      6|        }
  211|      7|            }
  211|      7|        }
  211|     82|            ArraySeqMtPerS::from_vec(values)
  211|     95|        }
  211|       |            vec![$(prob!($p)),*]
  212|       |
  212|       |
  212|       |
  212|       |
  212|       |
  212|       |
  212|       |
  212|       |
  212|       |
  212|       |
  212|       |
  212|       |
  212|       |
  212|       |
  212|       |
  212|       |
  212|       |
  212|       |                            }
  212|       |                }
  212|       |            )
  212|       |            );
  212|       |            }
  212|       |            }
  212|       |            };
  212|       |        )
  212|       |    ///
  212|       |    }
  212|       |    }
  212|       |    }
  212|       |    }
  212|       |}
  212|       |        $crate::Chap49::MinEditDistMtEph::MinEditDistMtEph::MinEditDistMtEphS::from_sequences(
  212|      0|            }
  212|      0|        }
  212|      0|                .into_iter()
  212|      0|        None
  212|      0|            predecessors,
  212|      1|            }
  212|      1|        }
  212|     14|                    }
  212|    159|                }
  212|  1.91k|        }
  212|      1|amortized Analysis:
  212|      2|            }
  212|      2|            ArraySeqStPerS::from_vec(out)
  212|      2|        compare_all_heapsorts(&input)
  212|    355|        }
  212|    417|        }
  212|    487|        }
  212|      5|            }
  212|      5|        }
  212|     51|            }
  212|    642|            }
  212|  6.99k|                current_word.push(ch);
  212|      8|        }
  212|     82|        }
  212|       |    #[macro_export]
  212|       |    #[macro_export]
  213|       |
  213|       |
  213|       |
  213|       |
  213|       |
  213|       |
  213|       |
  213|       |
  213|       |
  213|       |
  213|       |
  213|       |
  213|       |
  213|       |
  213|       |
  213|       |
  213|       |
  213|       |
  213|       |
  213|       |                }
  213|       |                }
  213|       |            }
  213|       |            }
  213|       |        };
  213|       |    ///
  213|       |    }
  213|       |    }
  213|       |    };
  213|       |            $crate::ArraySeqMtEphSLit![$($s),*],
  213|      0|        }
  213|      0|            n,
  213|      0|            n,
  213|      0|                result_vec.push(acc.clone());
  213|      0|                .zip(self.target.clone().into_iter())
  213|     13|            result
  213|      1|            ArraySeqS::from_vec(values)
  213|      2|                },
  213|      2|        }
  213|      2|        }
  213|      2|    }
  213|      2|    }
  213|  3.99k|            }
  213|      5|        }
  213|      5|            ArraySeqStPerS::from_vec(out)
  213|      6|    }
  213|    642|        }
  213|     64|                out.push(node.key.clone());
  213|     68|        }
  213|     96|        }
  214|       |
  214|       |
  214|       |
  214|       |
  214|       |
  214|       |
  214|       |
  214|       |
  214|       |
  214|       |
  214|       |
  214|       |
  214|       |
  214|       |            }
  214|       |        );
  214|       |        };
  214|       |    }
  214|       |    }
  214|       |    }
  214|       |}
  214|       |            $crate::ArraySeqMtEphSLit![$($t),*]
  214|      0|        }
  214|      0|        }
  214|      0|    }
  214|      1|        }
  214|     13|        }
  214|    174|        }
  214|    197|                values.push(a.nth(i).clone());
  214|      1|            memo_guard.clear();
  214|      2|            )
  214|     34|        where
  214|     41|        where
  214|     41|        where
  214|     44|        where
  214|     48|        where
  214|     48|        where
  214|      5|        }
  214|      6|            }
  214|    698|            }
  215|       |
  215|       |
  215|       |
  215|       |
  215|       |
  215|       |
  215|       |
  215|       |
  215|       |
  215|       |
  215|       |
  215|       |
  215|       |
  215|       |
  215|       |
  215|       |
  215|       |        )
  215|       |    ///
  215|       |    }
  215|       |    }
  215|       |            $crate::Chap50::MatrixChainStEph::MatrixChainStEph::MatrixChainStEphS::new()
  215|       |        $crate::Chap50::OptBinSearchTreeStEph::OptBinSearchTreeStEph::OBSTStEphS::new()
  215|      0|                }
  215|      0|            }
  215|      0|            }
  215|      0|        }
  215|      0|    }
  215|      1|        }
  215|  1.91k|        }
  215|    197|            }
  215|      1|                difference_entries.push(self.entries.nth(i).clone());
  215|      1|            memo_guard.clear();
  215|      2|        }
  215|     36|            }
  215|      4|            }
  215|     65|            }
  215|      7|            dimensions_guard.len()
  215|       |    #[macro_export]
  216|       |
  216|       |
  216|       |
  216|       |
  216|       |
  216|       |
  216|       |
  216|       |
  216|       |        {
  216|       |        {
  216|       |        {
  216|       |        {
  216|       |        {
  216|       |        {
  216|       |        };
  216|       |        };
  216|       |    ///
  216|       |    ///
  216|       |    }
  216|       |    };
  216|       |    };
  216|       |}
  216|      0|                None
  216|      1|
  216|      1|        }
  216|      1|    }
  216|    129|        }
  216|    160|                    ov.push(other_seq.nth(i).clone());
  216|     18|                0.0
  216|      1|            result
  216|      1|            self.base_table.subtract(keys);
  216|      1|            write!(
  216|      2|        }
  216|      7|        }
  216|      9|        }
  217|       |
  217|       |
  217|       |
  217|       |
  217|       |
  217|       |
  217|       |
  217|       |
  217|       |
  217|       |                }
  217|       |            };
  217|       |    }
  217|       |    }
  217|       |}
  217|       |}
  217|      0|                }
  217|      0|            }
  217|      0|        }
  217|      0|        }
  217|      0|            distances,
  217|      1|            }
  217|      1|            }
  217|      1|        }
  217|      1|    }
  217|      1|    }
  217|     12|            height_rec(&*guard)
  217|  1.34k|            }
  217|     14|                AdvancedLinearProbingStrategy::new(DefaultHashFunction);
  217|    160|                }
  217|    160|                values.push(b.nth(j).clone());
  217|  1.99k|            }
  217|      1|                f,
  217|      1|            f.debug_struct("UnDirGraphMtEph")
  217|      1|Implementation Details:
  217|     65|                }
  217|      7|                out.push(node.key.clone());
  218|       |
  218|       |
  218|       |
  218|       |
  218|       |
  218|       |
  218|       |
  218|       |
  218|       |
  218|       |
  218|       |            }
  218|       |        }
  218|       |    }
  218|       |}
  218|       |}
  218|       |}
  218|       |        $crate::Chap49::MinEditDistMtEph::MinEditDistMtEph::MinEditDistMtEphS::new()
  218|      0|                }
  218|      0|            predecessors,
  218|      1|        }
  218|      1|        }
  218|     10|        where
  218|     12|        }
  218|     13|            t
  218|    160|            }
  218|      1|            ArraySeqStPerS::from_vec(out)
  218|     24|                }
  218|      2|        compare_all_heapsorts(&input)
  218|    359|            }
  218|      4|                    out.push(x.clone());
  218|      7|        }
  218|      8|                }
  218|       |            __set
  218|       |            __tree
  219|       |
  219|       |
  219|       |
  219|       |
  219|       |
  219|       |
  219|       |
  219|       |
  219|       |
  219|       |
  219|       |
  219|       |
  219|       |
  219|       |
  219|       |            }
  219|       |            }
  219|       |            }
  219|       |            }
  219|       |        }
  219|       |        };
  219|       |        }};
  219|       |        }};
  219|       |    ///
  219|       |    }
  219|       |    };
  219|      0|        }
  219|      0|            n,
  219|      0|            writeln!(
  219|      1|        }
  219|     13|        }
  219|    130|            ArraySeqStEphS::from_vec(values)
  219|    132|                tree.insert(value);
  219|     13|            height_rec(&self.root)
  219|    140|                tree.insert(value);
  219|     14|                String,
  219|    153|            }
  219|      2|    }
  219|    281|                tree.insert(value);
  219|      3|                None
  219|      4|                }
  219|    403|            }
  219|      4|            ArraySeqStPerS::from_vec(out)
  219|    528|                mapped_entries.push(left_mapped.nth_cloned(i));
  219|     66|                tree.insert(value);
  219|     91|                tree.insert(value);
  219|     99|                tree.insert(value);
  220|       |
  220|       |
  220|       |
  220|       |
  220|       |
  220|       |
  220|       |
  220|       |
  220|       |
  220|       |
  220|       |                }
  220|       |                },
  220|       |                },
  220|       |            )
  220|       |            }
  220|       |            }
  220|       |            };
  220|       |        {
  220|       |    ///
  220|       |    ///
  220|       |    }
  220|       |    }
  220|       |}
  220|      0|        }
  220|      0|        }
  220|      0|                f,
  220|      0|                out.push(node.key.clone());
  220|      0|        println!("])");
  220|      0|                        s.insert(x.clone_mt());
  220|     13|        }
  220|    130|        }
  220|    132|            }
  220|    140|            }
  220|     14|                String,
  220|    153|        }
  220|     17|                            };
  220|      1|                .finish()
  220|      1|            memo_guard.clear();
  220|   232k|        }
  220|    281|            }
  220|    313|                },
  220|      4|        }
  220|      4|        }
  220|    528|            }
  220|      5|            true
  220|     66|            }
  220|  69.4M|            0
  220|      6|            keys_guard.len()
  220|      9|            }
  220|     91|            }
  220|     99|            }
  220|       |#[macro_export]
  220|       |            __tree
  221|       |
  221|       |
  221|       |
  221|       |
  221|       |
  221|       |
  221|       |
  221|       |
  221|       |
  221|       |
  221|       |
  221|       |
  221|       |            }
  221|       |            }
  221|       |        }
  221|       |        }};
  221|       |    }
  221|       |    }
  221|      0|            }
  221|      0|    }
  221|      0|                        s
  221|      1|        }
  221|      1|        }
  221|      1|        }
  221|      1|        }
  221|     11|                        });
  221|     14|            true
  221|     16|        }
  221|     23|                }
  221|      2|            out
  221|      2|            result
  221|      2|            write!(
  221|    313|            }
  221|      6|        }
  221|      6|        }
  221|    645|            }
  221|      9|            }
  222|       |
  222|       |
  222|       |
  222|       |
  222|       |
  222|       |
  222|       |
  222|       |
  222|       |
  222|       |
  222|       |            }
  222|       |            }
  222|       |    ///
  222|       |    }
  222|       |    }
  222|       |    }
  222|       |    }
  222|       |    }
  222|       |    }
  222|       |}
  222|       |}
  222|      0|                    1.0
  222|      0|                id
  222|      0|            roots.len()
  222|      1|
  222|      1|            }
  222|      1|            }
  222|     15|        }
  222|      2|        }
  222|      2|        }
  222|     20|        }
  222|     25|            Self::min_link(&*guard).cloned()
  222|    299|        }
  222|      2|                f,
  222|   302M|    }
  222|    313|        }
  222|     34|        }
  222|     41|        }
  222|     41|        }
  222|     44|        }
  222|     48|        }
  222|     48|        }
  222|    528|                mapped_entries.push(right_mapped.nth_cloned(i));
  223|       |
  223|       |
  223|       |
  223|       |
  223|       |
  223|       |
  223|       |
  223|       |
  223|       |
  223|       |
  223|       |
  223|       |
  223|       |
  223|       |
  223|       |
  223|       |                }
  223|       |    }
  223|       |    }
  223|       |    }
  223|       |    }
  223|       |    }
  223|       |    }
  223|       |    }
  223|       |        $crate::Chap49::MinEditDistStEph::MinEditDistStEph::MinEditDistStEphS::from_sequences(
  223|      0|            )?;
  223|      0|            }
  223|      0|        }
  223|      0|        }
  223|      0|    }
  223|      0|                        SetLit![]
  223|      1|        }
  223|     10|            }
  223|     12|                keep_results.push(keep);
  223|     25|        }
  223|      3|        }
  223|      3|            None
  223|      4|        }
  223|    528|            }
  223|      8|        }
  223|      9|            }
  223|       |    #[macro_export]
  223|       |            __set
  223|       |            __tree
  224|       |
  224|       |
  224|       |
  224|       |
  224|       |
  224|       |
  224|       |
  224|       |
  224|       |
  224|       |
  224|       |
  224|       |
  224|       |
  224|       |
  224|       |
  224|       |
  224|       |
  224|       |
  224|       |
  224|       |
  224|       |
  224|       |                    };
  224|       |            }
  224|       |        }};
  224|       |        }};
  224|       |    }
  224|       |    }
  224|       |    }
  224|       |    }
  224|       |}
  224|       |}
  224|       |            $crate::ArraySeqStEphS![$($s),*],
  224|      0|        }
  224|      0|            write!(
  224|      1|        "#
  224|    109|                a.nth(0).clone()
  224|     13|            height_rec(&*guard)
  224|    165|        }
  224|     17|                                .load_factor_manager
  224|      2|        }
  224|    214|            }
  224|    271|                        });
  224|      2|        compare_all_heapsorts(&input)
  224|      2|            pq
  224|      9|        }
  224|       |    #[macro_export]
  224|       |                self.clustering_enabled
  225|       |
  225|       |
  225|       |
  225|       |
  225|       |
  225|       |
  225|       |
  225|       |
  225|       |
  225|       |
  225|       |
  225|       |            )
  225|       |            };
  225|       |    ///
  225|       |    ///
  225|       |    }
  225|       |    }
  225|       |    }
  225|       |            $crate::ArraySeqStEphS![$($t),*]
  225|      0|                }
  225|      0|        }
  225|      0|                0.0
  225|      0|                0.0
  225|      0|                f,
  225|     13|        }
  225|     16|            }
  225|      1|            memo_guard.clear();
  225|      1|        .to_string()
  225|      2|        }
  225|      2|    }
  225|      5|                values.push(a.nth(i).clone());
  225|      6|            memo_guard.len()
  225|      6|            merged.extend(other_vals);
  226|       |
  226|       |
  226|       |
  226|       |
  226|       |
  226|       |
  226|       |
  226|       |
  226|       |
  226|       |
  226|       |                    }
  226|       |            };
  226|       |        )
  226|       |    }
  226|       |    }
  226|       |    }
  226|      0|            }
  226|      0|                .union(&other_right));
  226|      1|                            {
  226|      1|        }
  226|      1|    }
  226|  14.5k|                elements.push(array_seq.nth_cloned(i));
  226|     16|        }
  226|      2|        }
  226|      2|        }
  226|   233k|            Self::size_link(&*guard)
  226|    269|        words
  226|      3|            }
  226|      4|        }
  226|      5|            }
  226|      6|        }
  226|      6|            merged.sort();
  226|       |    #[macro_export]
  227|       |
  227|       |
  227|       |
  227|       |
  227|       |
  227|       |
  227|       |
  227|       |
  227|       |
  227|       |
  227|       |
  227|       |
  227|       |
  227|       |
  227|       |
  227|       |
  227|       |
  227|       |
  227|       |
  227|       |
  227|       |                }
  227|       |            }
  227|       |        };
  227|       |    }
  227|       |    }
  227|       |    }
  227|       |    };
  227|       |}
  227|       |}
  227|      0|                        }
  227|      0|                    new_chain.clone()
  227|  14.5k|            }
  227|     14|                AdvancedQuadraticProbingStrategy::new(DefaultHashFunction);
  227|    170|                    kept.push(value.clone());
  227|   233k|        }
  227|     25|            Self::max_link(&*guard).cloned()
  227|    269|    }
  227|  29.2k|                out.push(node.key.clone());
  227|      4|            }
  227|      6|            merged.dedup();
  227|     84|                a.length(),
  228|       |
  228|       |
  228|       |
  228|       |
  228|       |
  228|       |
  228|       |
  228|       |
  228|       |
  228|       |
  228|       |
  228|       |            )
  228|       |            )
  228|       |            );
  228|       |            }
  228|       |            }
  228|       |        }};
  228|       |    }
  228|      0|                    }
  228|      0|            left_result.union(&right_result)
  228|    129|                    new_chain.clone()
  228|     12|        where
  228|    149|            AVLTreeSeqStPerS::from_vec(elements)
  228|    170|                }
  228|     19|                }
  228|     25|        }
  228|      2|                values.push(b.nth(j).clone());
  228|     36|        }
  228|      4|        }
  228|      6|        }
  228|       |    #[macro_export]
  229|       |
  229|       |
  229|       |
  229|       |
  229|       |
  229|       |
  229|       |
  229|       |
  229|       |
  229|       |
  229|       |
  229|       |
  229|       |
  229|       |
  229|       |                    }
  229|       |                    }
  229|       |                }
  229|       |            }
  229|       |            };
  229|       |    }
  229|       |}
  229|       |        $crate::Chap49::MinEditDistStEph::MinEditDistStEph::MinEditDistStEphS::new()
  229|      0|        }
  229|      0|                    self.buckets.nth(i).clone()
  229|      0|        where
  229|    149|        }
  229|     14|                String,
  229|     16|                            }
  229|    197|        }
  229|     19|            Self::min_link(&*guard).cloned()
  229|      2|            }
  229|     25|        }
  229|  29.5k|            }
  229|  5.81k|            }
  229|      6|            Self::from_seq(AVLTreeSeqStEphS::from_vec(merged))
  229|    706|        }
  229|     84|        }
  230|       |
  230|       |
  230|       |
  230|       |
  230|       |
  230|       |
  230|       |
  230|       |
  230|       |
  230|       |
  230|       |
  230|       |
  230|       |
  230|       |
  230|       |
  230|       |
  230|       |                }
  230|       |                }
  230|       |                },
  230|       |                };
  230|       |            }
  230|       |        {
  230|       |        };
  230|       |    ///
  230|       |    }
  230|       |    }
  230|       |    }
  230|       |    };
  230|      1|            }
  230|     14|                String,
  230|   150M|    }
  230|     19|        }
  230|      1|            ArraySeqS::from_vec(values)
  230|      1|        r#"
  230|      2|        compare_all_heapsorts(&input)
  230|      3|                        e.insert(1);
  230|      4|            memo_guard.len()
  230|  5.81k|        }
  230|  58.8k|        }
  230|     58|            ArraySeqStEphS::from_vec(kept)
  230|      6|        }
  230|      6|                    kept_values.push(a.nth_cloned(i));
  230|      7|            }
  230|      8|    }
  230|  8.83k|                    self.buckets.nth(i).clone()
  231|       |
  231|       |
  231|       |
  231|       |
  231|       |
  231|       |
  231|       |
  231|       |
  231|       |
  231|       |
  231|       |
  231|       |
  231|       |
  231|       |
  231|       |
  231|       |
  231|       |                };
  231|       |            }
  231|       |            }
  231|       |            }
  231|       |        {
  231|       |    }
  231|       |}
  231|       |            $crate::Chap50::MatrixChainMtPer::MatrixChainMtPer::MatrixChainMtPerS::from_dim_pairs(
  231|      0|        }
  231|      1|        }
  231|      1|        }
  231|      1|        }
  231|      2|    }
  231|     22|        }
  231|      2|            acc
  231|  3.99k|        }
  231|      3|                        order.push(x.clone());
  231|      4|        }
  231|      4|                    break;
  231|     58|        }
  231|      6|                }
  231|      9|                result.push(self.elements.nth(i).clone());
  231|       |            __tree
  232|       |
  232|       |
  232|       |
  232|       |
  232|       |
  232|       |
  232|       |
  232|       |
  232|       |
  232|       |
  232|       |
  232|       |
  232|       |            }
  232|       |        }};
  232|       |    }
  232|       |    }
  232|       |    }
  232|      0|                        }
  232|      0|                }
  232|      0|            }
  232|      1|
  232|     15|                }
  232|     17|        }
  232|     19|        }
  232|      2|        }
  232|     20|                collision_chains,
  232|      3|                    }
  232|    547|        }
  232|      9|            }
  232|       |    #[macro_export]
  232|       |    #[macro_export]
  233|       |
  233|       |
  233|       |
  233|       |
  233|       |
  233|       |
  233|       |
  233|       |
  233|       |
  233|       |
  233|       |
  233|       |
  233|       |
  233|       |
  233|       |
  233|       |
  233|       |
  233|       |                    }
  233|       |            )
  233|       |            }
  233|       |            }
  233|       |            }
  233|       |    ///
  233|       |    }
  233|       |    }
  233|       |    }
  233|       |    }
  233|       |                $(
  233|      0|        }
  233|      0|    }
  233|      1|            metrics.relative_prime_validation
  233|     20|                max_chain_length,
  233|      3|            result
  233|      3|                Some(val)
  233|      9|            Self::from_seq(range_seq)
  233|       |    #[macro_export]
  234|       |
  234|       |
  234|       |
  234|       |
  234|       |
  234|       |
  234|       |
  234|       |
  234|       |                }
  234|       |            }
  234|       |        };
  234|      0|        };
  234|      0|                return;
  234|      0|            true
  234|      0|            writeln!(f)?;
  234|      1|
  234|    100|            ArraySeqStPerS::from_vec(out)
  234|     16|        }
  234|     19|            Self::max_link(&*guard).cloned()
  234|      1|                a.length(),
  234|      2|            }
  234|     20|                avg_chain_length,
  234|     28|                }
  234|      3|        }
  234|      3|                out.push(node.key.clone());
  234|      3|                        values.push(value.clone());
  234|    605|            inner.find(x)
  234|    693|        }
  234|      6|            false
  234|      9|        }
  234|       |            __tree
  235|       |
  235|       |
  235|       |
  235|       |
  235|       |
  235|       |
  235|       |
  235|       |
  235|       |
  235|       |
  235|       |
  235|       |
  235|       |
  235|       |
  235|       |            )
  235|       |            }
  235|       |        }};
  235|       |}
  235|       |}
  235|      0|        }
  235|      1|        }
  235|      1|        }
  235|    100|        }
  235|  1.29k|            }
  235|     13|        }
  235|     19|        }
  235|      1|                None
  235|      1|```rust
  235|      2|        }
  235|     20|                secondary_clustering_coefficient,
  235|     23|                }
  235|      3|                    }
  235|      3|            }
  235|    605|        }
  235|      8|            ArraySeqStPerS::from_vec(out)
  236|       |
  236|       |
  236|       |
  236|       |
  236|       |
  236|       |
  236|       |
  236|       |
  236|       |
  236|       |
  236|       |
  236|       |
  236|       |
  236|       |                }
  236|       |                }
  236|       |                }
  236|       |            }
  236|       |            }
  236|       |            }
  236|       |        }};
  236|       |    }
  236|       |    }
  236|       |            $crate::Chap50::MatrixChainMtPer::MatrixChainMtPer::MatrixChainMtPerS::new()
  236|      0|            }
  236|      0|                self.num_elements
  236|      1|        }
  236|    106|                });
  236|      1|            f.debug_list().entries(v.iter()).finish()
  236|      2|            }
  236|     20|                probe_sequence_diversity,
  236|      3|        }
  236|      3|            None
  236|      8|        }
  237|       |
  237|       |
  237|       |
  237|       |
  237|       |
  237|       |
  237|       |
  237|       |
  237|       |
  237|       |
  237|       |
  237|       |
  237|       |
  237|       |
  237|       |
  237|       |                );
  237|       |            }
  237|       |            }
  237|       |        };
  237|       |    }
  237|       |    }
  237|      0|                id
  237|      0|                self.num_elements
  237|      0|            write!(
  237|      1|        }
  237|      1|        }
  237|      1|        }
  237|     12|        }
  237|     20|        }
  237|     20|                table_size_is_prime,
  237|    284|            self.meld(&singleton)
  237|      2|                ArraySeqMtEphSliceS::from_vec(kept_values)
  237|    308|            }
  237|      3|                        break;
  237|      3|                None
  237|      3|            None
  237|      4|            }
  237|      4|        }
  237|     56|                out.push(node.key.clone());
  237|       |#[macro_export]
  238|       |
  238|       |
  238|       |
  238|       |
  238|       |
  238|       |
  238|       |
  238|       |                    };
  238|       |            }
  238|       |    }
  238|       |    }
  238|       |    }
  238|       |    }
  238|       |}
  238|       |}
  238|      0|                f,
  238|      0|        update_meta(x.right.as_mut().unwrap());
  238|      0|        where
  238|      0|                writeln!(f)?;
  238|     10|        }
  238|     10|        }
  238|     10|            height_rec(&self.root)
  238|     20|            }
  238|    284|        }
  238|      3|                    }
  238|      3|                    kept.push(value.clone());
  238|    431|            Self::min_link(&*guard).cloned()
  238|     46|                    values.push(inner.nth(j).clone());
  238|      7|        }
  239|       |
  239|       |
  239|       |
  239|       |
  239|       |
  239|       |
  239|       |
  239|       |
  239|       |
  239|       |
  239|       |
  239|       |
  239|       |
  239|       |
  239|       |
  239|       |
  239|       |
  239|       |
  239|       |                }
  239|       |                }
  239|       |            }
  239|       |            };
  239|       |        }};
  239|       |    }
  239|       |}
  239|      0|                left_result.union(&right_result)
  239|      1|            };
  239|      1|        }
  239|     10|        }
  239|      2|        }
  239|     21|        }
  239|  2.10k|            None
  239|     22|        }
  239|     24|            inner.delete(x);
  239|      2|                vals.push(self.nth(i).clone());
  239|      3|        }
  239|      4|                }
  239|      4|        }
  239|    431|        }
  239|     46|                }
  239|      5|        }
  239|      5|                Some(entries.nth(0).0.clone())
  239|     60|            }
  239|      8|                a.nth_cloned(0)
  239|       |                    edges.insert(normalized_edge);
  240|       |
  240|       |
  240|       |
  240|       |
  240|       |
  240|       |
  240|       |
  240|       |
  240|       |
  240|       |
  240|       |
  240|       |
  240|       |                )*
  240|       |            }
  240|       |            }
  240|       |            }
  240|       |            }
  240|       |            };
  240|       |        {
  240|       |    }
  240|       |    }
  240|       |    }
  240|       |        $crate::Chap50::OptBinSearchTreeMtPer::OptBinSearchTreeMtPer::OBSTMtPerS::from_keys_probs(
  240|      0|            }
  240|      0|            }
  240|      0|                self.word_count(),
  240|      0|        x
  240|      1|        }
  240|    116|        }
  240|      2|            }
  240|     21|        }
  240|     24|        }
  240|  2.44k|        }
  241|       |
  241|       |
  241|       |
  241|       |
  241|       |
  241|       |
  241|       |
  241|       |
  241|       |
  241|       |
  241|       |
  241|       |
  241|       |
  241|       |
  241|       |
  241|       |
  241|       |
  241|       |
  241|       |
  241|       |                }
  241|       |        }};
  241|       |    }
  241|      0|                }
  241|      0|        }
  241|      0|        }
  241|      0|    }
  241|      0|            ArraySeqStPerS::from_vec(out)
  241|      0|            height_rec(&self.root)
  241|      0|                self.word_to_docs.size()
  241|     10|        where
  241|     12|            ArraySeqStEphS::from_vec(values)
  241|     14|                result.push(sorted_seq.nth(i).clone());
  241|      1|            ArraySeqS::from_vec(kept)
  241|      1|where
  241|     21|            }
  241|    215|        }
  241|    230|        }
  241|      2|            AVLTreeS::from_vec(vals)
  241|      2|            Self::from_seq(range_seq)
  241|      3|            ArraySeqStPerS::from_vec(out)
  241|     75|            ArraySeqStPerS::from_vec(out)
  241|      8|        }
  241|       |                edges
  241|       |            vec![$($k),*],
  242|       |
  242|       |
  242|       |
  242|       |
  242|       |
  242|       |            )
  242|       |            }
  242|       |            }
  242|       |            };
  242|       |        }
  242|       |    }
  242|       |    }
  242|      0|        }
  242|      0|        }
  242|      0|                return;
  242|      1|        }
  242|  10.9k|                values.push(a.nth_cloned(i));
  242|     12|        }
  242|     12|        }
  242|     14|            }
  242|      2|        }
  242|      3|        }
  242|      4|        result
  242|      6|                }
  242|     75|        }
  242|       |    #[macro_export]
  242|       |            vec![$($crate::Chap50::Probability::Probability::Probability::new($p)),*]
  243|       |
  243|       |
  243|       |
  243|       |
  243|       |
  243|       |
  243|       |
  243|       |
  243|       |
  243|       |
  243|       |
  243|       |
  243|       |
  243|       |
  243|       |
  243|       |
  243|       |
  243|       |
  243|       |
  243|       |            }
  243|       |        )
  243|       |        {
  243|       |    }
  243|       |    }
  243|       |    }
  243|      0|        }
  243|      0|            writeln!(f)?;
  243|      1|            }
  243|      1|{
  243|  10.9k|            }
  243|     14|                (
  243|      2|                    values.remove(i);
  243|      3|            }
  243|  31.7k|        }
  243|      3|            result
  243|      4|    }
  243|    404|        }
  243|    424|                values.push(a.nth(i).clone());
  243|    431|            Self::max_link(&*guard).cloned()
  243|      5|            ArraySeqStPerS::from_vec(v)
  243|      6|        }
  243|      7|        total
  244|       |
  244|       |
  244|       |
  244|       |
  244|       |
  244|       |
  244|       |
  244|       |
  244|       |
  244|       |
  244|       |                }
  244|       |        }};
  244|       |    }
  244|       |    };
  244|       |}
  244|      1|        }
  244|     14|                    "QuadraticProbing".to_string(),
  244|      1|                memo_guard.len()
  244|      1|            write!(
  244|  2.71k|            None
  244|      3|        }
  244|      3|            ArraySeqStPerS::from_vec(groups)
  244|    424|            }
  244|    431|        }
  244|      5|        }
  244|      7|    }
  244|    845|            inner.insert(x);
  245|       |
  245|       |
  245|       |
  245|       |
  245|       |
  245|       |
  245|       |
  245|       |
  245|       |
  245|       |
  245|       |
  245|       |
  245|       |
  245|       |            }
  245|       |            };
  245|       |    }
  245|       |    }
  245|       |}
  245|       |            $crate::Chap17::MathSeq::MathSeq::MathSeqS::empty()
  245|      0|                }
  245|      0|            }
  245|      1|        }
  245|  11.0k|                values.push(b.nth_cloned(j));
  245|     14|                    quadratic_analysis.overall_clustering_score,
  245|    175|            }
  245|      1|                f,
  245|     29|        }
  245|      3|        }
  245|  4.02k|        }
  245|    410|            }
  245|     56|                out.push(node.value.clone());
  245|    845|        }
  245|       |    #[macro_export]
  245|       |    #[macro_export]
  245|       |                __s
  246|       |
  246|       |
  246|       |
  246|       |
  246|       |
  246|       |
  246|       |
  246|       |
  246|       |            }
  246|       |            };
  246|       |        };
  246|       |    }
  246|       |    }
  246|       |}
  246|       |        $crate::Chap50::OptBinSearchTreeMtPer::OptBinSearchTreeMtPer::OBSTMtPerS::new()
  246|      0|            }
  246|      0|        }
  246|      0|        }
  246|      1|            };
  246|     10|        }
  246|  11.0k|            }
  246|     14|                ),
  246|    175|        }
  246|     19|                values.push(f(i));
  246|      1|            AdvancedLinearProbingStrategy::new(hash_fn);
  246|      2|                    };
  246|      2|                }
  246|    223|                values.push(b.nth(j).clone());
  246|      3|            }
  246|    317|            false
  246|    410|        }
  247|       |
  247|       |
  247|       |
  247|       |
  247|       |
  247|       |
  247|       |
  247|       |
  247|       |
  247|       |
  247|       |
  247|       |
  247|       |
  247|       |
  247|       |
  247|       |
  247|       |
  247|       |                }
  247|       |            }
  247|       |    }
  247|       |    }
  247|       |    };
  247|       |}
  247|     19|            }
  247|     19|                    break;
  247|      1|                self.s_length(),
  247|      1|                values.remove(pos);
  247|  2.00k|            ArraySeqMtEphS::from_vec(values)
  247|    223|            }
  247|      4|        }
  247|    493|        }
  247|     60|            }
  248|       |
  248|       |
  248|       |
  248|       |
  248|       |                }
  248|       |            ];
  248|       |        }};
  248|       |    }
  248|       |    }
  248|       |}
  248|      0|        }
  248|      0|        };
  248|      0|            f.debug_struct("DocumentIndex")
  248|      1|        
  248|      1|            }
  248|      1|    }
  248|    116|        }
  248|    129|            }
  248|    150|            ArraySeqMtPerS::from_vec(values)
  248|      1|                dimensions_guard.len()
  248|      1|            result
  248|      1|                self.t_length(),
  248|  2.00k|            }
  248|  2.00k|        }
  248|     27|                }
  248|      2|            ArraySeqStPerS::from_vec(out)
  248|      3|                None
  248|      4|            LinkedListStPerS::from_vec(values)
  248|      5|                }
  248|      9|        }
  249|       |
  249|       |
  249|       |
  249|       |
  249|       |
  249|       |
  249|       |
  249|       |
  249|       |
  249|       |
  249|       |
  249|       |
  249|       |
  249|       |
  249|       |
  249|       |
  249|       |
  249|       |            }
  249|       |            }
  249|       |            };
  249|       |        };
  249|       |        };
  249|       |        };
  249|       |    }
  249|       |    }
  249|       |}
  249|      0|            }
  249|      1|            }
  249|      1|        }
  249|      1|        }
  249|      1|        }
  249|    129|        }
  249|    150|        }
  249|  17.6M|        update_meta(y.left.as_mut().unwrap());
  249|      1|            height_rec(&self.root)
  249|      1|                memo_guard.len()
  249|      1|                self.memo_size()
  249|      2|        }
  249|      4|        }
  249|      4|        }
  249|      5|                    values.push(inner.nth(j).clone());
  249|      8|                results.push(acc.clone());
  250|       |
  250|       |
  250|       |
  250|       |
  250|       |
  250|       |
  250|       |
  250|       |
  250|       |
  250|       |
  250|       |                }
  250|       |            )
  250|       |            };
  250|       |    }
  250|       |    }
  250|       |    }
  250|       |    }
  250|      1|            }
  250|      1|        }
  250|      1|        }
  250|      1|            write!(
  250|     20|            count
  250|      3|            None
  250|      5|                }
  250|      6|                });
  250|     78|            ArraySeqStPerS::from_vec(out)
  250|      8|            }
  250|    982|        }
  251|       |
  251|       |
  251|       |
  251|       |
  251|       |
  251|       |
  251|       |
  251|       |
  251|       |
  251|       |
  251|       |
  251|       |
  251|       |
  251|       |
  251|       |
  251|       |
  251|       |
  251|       |            }
  251|       |            }
  251|       |            }
  251|       |        ];
  251|       |}
  251|       |            $crate::Chap17::MathSeq::MathSeq::MathSeqS::from_vec(vec![$($x),*])
  251|      0|    }
  251|      0|                    break;
  251|      0|                .finish()
  251|      1|        }
  251|      1|        }
  251|      1|        }
  251|     12|        }
  251|     15|            }
  251|  17.6M|        y
  251|    185|                }
  251|      1|                f,
  251|     20|        }
  251|     28|        }
  251|      6|                    left_entries.push(pair.clone());
  251|     78|        }
  252|       |
  252|       |
  252|       |
  252|       |
  252|       |
  252|       |
  252|       |
  252|       |
  252|       |
  252|       |            }
  252|       |        };
  252|       |    }
  252|       |    }
  252|       |    }
  252|       |}
  252|      0|        }
  252|      0|            self
  252|      1|        
  252|      1|            };
  252|    115|        }
  252|  17.6M|    }
  252|      1|            ArraySeqS::from_vec(values)
  252|      1|            write!(
  252|      3|            acc
  252|      5|                }
  252|      5|        }
  252|      8|        }
  252|       |    #[macro_export]
  252|       |    #[macro_export]
  253|       |
  253|       |
  253|       |
  253|       |
  253|       |
  253|       |
  253|       |
  253|       |
  253|       |
  253|       |
  253|       |
  253|       |
  253|       |
  253|       |
  253|       |
  253|       |
  253|       |
  253|       |            }
  253|       |    }
  253|       |    }
  253|       |}
  253|      0|                }
  253|      0|        }
  253|      1|        }
  253|      1|                f,
  253|      1|        inputs
  253|      1|                keys_guard.len()
  253|      1|        where
  253|  24.9k|            }
  253|      2|                        a.nth_cloned(i)
  253|      3|        }
  253|      7|                    right_entries.push(pair.clone());
  253|      8|        }
  253|       |            __tree
  253|       |            __tree
  254|       |
  254|       |
  254|       |
  254|       |
  254|       |
  254|       |
  254|       |
  254|       |
  254|       |
  254|       |                    );
  254|       |            )
  254|       |            }
  254|       |            }
  254|       |            };
  254|       |        }};
  254|       |        }};
  254|      0|                }
  254|      1|            (
  254|      1|    }
  254|      1|    }
  254|     11|                values.push(f(a.nth(i)));
  254|      2|        }
  254|  24.9k|        }
  254|     25|            new_table
  254|    271|                        });
  254|       |    #[macro_export]
  255|       |
  255|       |
  255|       |
  255|       |
  255|       |
  255|       |
  255|       |
  255|       |
  255|       |
  255|       |
  255|       |
  255|       |        {
  255|       |    }
  255|       |    }
  255|       |}
  255|      0|            true
  255|      1|        }
  255|  10.0k|                }
  255|  1.05k|        }
  255|     11|            }
  255|     14|        }
  255|      1|                merged.insert(value);
  255|      1|                self.s_length(),
  255|     25|        }
  255|      3|        }
  255|      5|                    break;
  256|       |
  256|       |
  256|       |
  256|       |
  256|       |
  256|       |
  256|       |
  256|       |
  256|       |
  256|       |
  256|       |                    }
  256|       |                }
  256|       |            }
  256|       |        };
  256|       |    }
  256|      0|        }
  256|      0|            self.load_factor_manager
  256|      1|                }
  256|      1|            }
  256|      1|        }
  256|      1|}
  256|     16|                        left_filtered.push(pair);
  256|      1|                self.t_length(),
  256|      2|            }
  256|      2|            }
  256|      3|            LinkedListStPerS::from_vec(values)
  256|      5|                    kept.push(value);
  256|      5|                    values.push(item.clone());
  256|       |    #[macro_export]
  257|       |
  257|       |
  257|       |
  257|       |
  257|       |
  257|       |
  257|       |
  257|       |
  257|       |            }
  257|       |            }
  257|       |    }
  257|       |    }
  257|       |    }
  257|       |    }
  257|       |}
  257|       |}
  257|      0|            }
  257|      0|            ArraySeqStPerS::from_vec(out)
  257|      1|                },
  257|      1|        }
  257|      1|```
  257|     11|            }
  257|     16|                    }
  257|      1|            ArraySeqStPerS::from_vec(out)
  257|      1|                None
  257|      1|            self.base_table.join_key(other.base_table);
  257|      1|            Self::from_sorted_iter(merged.into_iter())
  257|      1|                self.memo_size()
  257|     28|        }
  257|      3|        }
  257|     32|                    updated_entries.push(filtered.nth(i).clone());
  257|      4|                },
  257|      5|                }
  257|      9|                }
  258|       |
  258|       |
  258|       |
  258|       |
  258|       |
  258|       |
  258|       |
  258|       |
  258|       |
  258|       |
  258|       |
  258|       |
  258|       |                }
  258|       |                }
  258|       |                }
  258|       |            )
  258|       |            }
  258|       |            }
  258|       |    }
  258|       |}
  258|      0|        }
  258|      0|        }
  258|      0|        }
  258|      1|
  258|      1|        }
  258|      1|        }
  258|   100k|            }
  258|     11|        }
  258|      1|                total_len,
  258|    216|            }
  258|     32|                }
  258|    560|                sequence.push(current_pos);
  258|      6|            count
  259|       |
  259|       |
  259|       |
  259|       |
  259|       |
  259|       |
  259|       |
  259|       |
  259|       |
  259|       |
  259|       |            )
  259|       |            }
  259|       |            }
  259|       |    }
  259|       |    }
  259|       |    }
  259|      1|            }
  259|      1|            };
  259|      1|        }
  259|    109|        }
  259|     12|                Some(seq.nth(i).clone())
  259|      1|            ArraySeqMtEphS::from_vec(kept)
  259|      1|Usage:
  259|      2|            ArraySeqMtPerS::from_vec(values)
  259|      3|                left_filtered
  259|    445|        }
  259|      6|        }
  259|     67|                    }
  259|      6|            ArraySeqStPerS::from_vec(out)
  259|       |            #[allow(unused_mut)]
  259|       |                .spawn($left)
  260|       |
  260|       |
  260|       |
  260|       |
  260|       |
  260|       |
  260|       |
  260|       |
  260|       |
  260|       |
  260|       |
  260|       |
  260|       |
  260|       |            }
  260|       |    }
  260|      1|                },
  260|      1|        }
  260|      1|        }
  260|      1|    }
  260|     10|        }
  260|     14|                best_strategy,
  260|      1|            ArraySeqS::from_vec(values)
  260|      2|        }
  260|    216|            vals.push(x);
  260|      2|            PrimeValidator::next_prime(min_size)
  260|      3|            });
  260|    312|            }
  260|     42|        }
  260|      5|                }
  260|    548|        }
  260|    560|            }
  260|      6|        }
  260|      6|        }
  260|       |            __tree
  261|       |
  261|       |
  261|       |
  261|       |
  261|       |
  261|       |
  261|       |
  261|       |
  261|       |
  261|       |
  261|       |
  261|       |
  261|       |
  261|       |
  261|       |
  261|       |
  261|       |
  261|       |
  261|       |
  261|       |            }
  261|       |        }};
  261|       |}
  261|       |}
  261|       |            $(
  261|      0|            }
  261|      0|        }
  261|      1|            )
  261|      1|        }
  261|     13|        }
  261|     14|                worst_strategy,
  261|      2|            }
  261|      2|        }
  261|      3|        }
  261|    312|        }
  261|  50.0k|            }
  261|       |    #[macro_export]
  262|       |
  262|       |
  262|       |
  262|       |
  262|       |
  262|       |
  262|       |
  262|       |
  262|       |
  262|       |
  262|       |    }
  262|       |    }
  262|      0|            }
  262|      1|        }
  262|      1|        }
  262|     13|                values.push(a.nth(i).clone());
  262|     14|                performance_ranking,
  262|      1|            true
  262|     29|            sequence
  262|      3|            (
  262|      5|                self.stack.push(n);
  262|       |    #[macro_export]
  263|       |
  263|       |
  263|       |
  263|       |
  263|       |
  263|       |
  263|       |
  263|       |
  263|       |    }
  263|      0|        }
  263|      0|                0.0
  263|      0|            ArraySeqStPerS::from_vec(out)
  263|      1|
  263|      1|        }
  263|     13|            }
  263|     14|            }
  263|      1|                .tree
  263|      2|        }
  263|    216|            Self::from_seq(AVLTreeSeqMtPerS::from_vec(vals))
  263|     28|                }
  263|     29|        }
  263|      3|                from_sorted_entries(left_seq),
  263|      3|                        group.1.push(value.clone());
  263|    821|                        break;
  263|       |                .spawn($right)
  264|       |
  264|       |
  264|       |
  264|       |
  264|       |
  264|       |            }
  264|       |    }
  264|       |    }
  264|       |    }
  264|       |}
  264|      0|        }
  264|      0|            f.debug_list().entries(elts).finish()
  264|     14|        }
  264|      1|            a
  264|      1|                .in_order()
  264|    232|        }
  264|  3.92k|                    }
  264|      3|                found_value,
  264|      4|                    left_entries.push(pair.clone());
  264|      4|                    range_values.push(current.clone());
  264|      5|            }
  264|     71|                    }
  264|  97.2M|        }
  265|       |
  265|       |
  265|       |
  265|       |
  265|       |
  265|       |
  265|       |
  265|       |
  265|       |
  265|       |                }
  265|       |            )*
  265|       |        };
  265|       |    }
  265|       |    }
  265|       |    }
  265|       |    }
  265|       |    }
  265|       |    }
  265|       |    }
  265|       |            $crate::Chap45::SortedListPQ::SortedListPQ::SortedListPQ::empty()
  265|      0|        }
  265|      1|        "#
  265|      1|        }
  265|     11|                values.push(b.nth(j).clone());
  265|      1|                .iter()
  265|      1|                None
  265|      2|            }
  265|      2|            ArraySeqStPerS::from_vec(out)
  265|      2|            .to_string();
  265|      2|        where
  265|      3|                    }
  265|      3|                from_sorted_entries(right_seq),
  265|      3|            None
  265|    465|            Self::size_link(&*guard)
  265|      6|        }
  266|       |
  266|       |
  266|       |
  266|       |
  266|       |
  266|       |
  266|       |
  266|       |
  266|       |
  266|       |
  266|       |
  266|       |
  266|       |
  266|       |                }
  266|       |            };
  266|       |        };
  266|       |    }
  266|       |    }
  266|      1|            }
  266|     11|            }
  266|     12|        }
  266|     13|                    right_filtered.push(pair);
  266|     18|            }
  266|      1|        .to_string()
  266|      1|        vec![
  266|      2|        }
  266|      3|            )
  266|    465|        }
  266|   551k|                    new_entries.push(self.entries.nth(i).clone());
  266|       |            docs
  266|       |    #[macro_export]
  266|       |    #[macro_export]
  267|       |
  267|       |
  267|       |
  267|       |
  267|       |
  267|       |
  267|       |
  267|       |        {
  267|       |        }};
  267|       |    }
  267|      0|                }
  267|      1|            (
  267|      1|        }
  267|      1|    }
  267|     16|                }
  267|      2|                    break;
  267|      3|        }
  267|    422|        }
  267|      4|            LinkedListStPerS::from_vec(values)
  267|      4|                    right_entries.push(pair.clone());
  267|   551k|                }
  267|      5|                Some(seq.nth(i).clone())
  267|      6|        }
  267|       |    #[macro_export]
  267|       |    #[macro_export]
  267|       |    #[macro_export]
  267|       |    #[macro_export]
  267|       |    #[macro_export]
  267|       |    #[macro_export]
  268|       |
  268|       |
  268|       |
  268|       |
  268|       |
  268|       |
  268|       |
  268|       |
  268|       |            }
  268|       |            }
  268|       |            }
  268|       |        }};
  268|      0|                }
  268|      0|                    dimensions_guard.clone().into_iter()
  268|      1|                }
  268|   100k|        }
  268|     16|                num_elements,
  268|      1|            ArraySeqStPerS::from_vec(out)
  268|      1|                        Some(v.clone())
  268|      1|                "UnsortedListPQ".to_string(),
  268|      3|            }
  268|      4|                }
  268|      4|        }
  269|       |
  269|       |
  269|       |
  269|       |
  269|       |
  269|       |
  269|       |
  269|       |                }
  269|       |            {
  269|       |            }
  269|       |            }
  269|       |    }
  269|       |    }
  269|       |            $(
  269|       |            $crate::Chap19::ArraySeqStPer::ArraySeqStPer::ArraySeqStPerS::empty()
  269|      0|                    keys_guard.clone().into_iter()
  269|      1|        }
  269|    157|                        break;
  269|     16|                table_size,
  269|  17.6M|            }
  269|     18|            ArraySeqMtPerS::from_vec(new_data)
  269|     19|            &self,
  269|      1|                "Θ(n²)".to_string(),
  269|     29|    }
  269|      2|            .to_string();
  269|     35|                    }
  269|     44|            }
  269|      6|        }
  269|     74|                    }
  269|       |    #[macro_export]
  269|       |            __tree
  270|       |
  270|       |
  270|       |
  270|       |
  270|       |
  270|       |
  270|       |
  270|       |
  270|       |
  270|       |
  270|       |
  270|       |
  270|       |                    }
  270|       |                }
  270|       |            }
  270|       |            }
  270|       |        }};
  270|       |        }};
  270|       |        }};
  270|      0|                }
  270|     16|                load_factor,
  270|     19|        }
  270|      1|                        None
  270|      1|            self.base_table.join_key(other.base_table);
  270|      2|                }
  270|      2|        }
  270|      3|                .into_iter()
  270|      6|            }
  270|      9|            }
  271|       |
  271|       |
  271|       |
  271|       |
  271|       |
  271|       |
  271|       |
  271|       |                    }
  271|       |            )*
  271|       |            }
  271|       |            }
  271|       |            }
  271|       |        };
  271|       |        };
  271|       |        };
  271|       |        };
  271|       |        };
  271|       |        };
  271|       |    }
  271|       |    }
  271|       |    }
  271|       |                $(
  271|      0|        }
  271|      1|            ),
  271|    105|                    result
  271|      1|        r#"
  271|      2|            }
  271|      2|            AVLTreeSeqStPerS::from_vec(range_values)
  271|  3.92k|                            updated.entries.nth(i).clone()
  271|  79.5M|        }
  271|       |    #[allow(dead_code)]
  272|       |
  272|       |
  272|       |
  272|       |
  272|       |
  272|       |
  272|       |
  272|       |                }
  272|       |    }
  272|      0|        }
  272|      1|            (
  272|      1|        }
  272|      1|            ArraySeqS::from_vec(values)
  272|      2|                })
  272|      2|        }
  272|      2|        }
  272|  2.00k|        }
  272|      3|                .collect();
  272|     67|                }
  272|  79.5M|        n
  272|       |            pq
  272|       |                    set.insert($x);
  273|       |
  273|       |
  273|       |
  273|       |
  273|       |
  273|       |
  273|       |                )*
  273|       |            }
  273|       |            }
  273|       |        };
  273|       |        }};
  273|       |    }
  273|       |    }
  273|       |    }
  273|       |}
  273|      1|
  273|      1|            };
  273|      1|        }
  273|      1|                .collect();
  273|      1|                self.push_left(cur);
  273|      1|                "SortedListPQ".to_string(),
  273|      3|            ArraySeqStEphS::from_vec(collected)
  273|      3|                Some(a.nth(index).clone())
  273|  97.2M|    }
  273|    973|                            new_pair.clone()
  273|       |    #[allow(dead_code)]
  274|       |
  274|       |
  274|       |
  274|       |
  274|       |
  274|       |
  274|       |
  274|       |    }
  274|      0|                        }
  274|      0|                }
  274|     13|                values.push(f(i));
  274|     16|            }
  274|    170|        }
  274|      1|            Self::from_sorted_iter(filtered.into_iter())
  274|      1|                "Θ(n²)".to_string(),
  274|      2|                }
  274|      2|                .to_string(),
  274|      3|        }
  274|      5|            }
  274|       |            __s
  274|       |                set
  275|       |
  275|       |
  275|       |
  275|       |
  275|       |
  275|       |                    }
  275|       |                }
  275|       |            }
  275|       |            }
  275|       |        }};
  275|       |    }
  275|      0|                }
  275|      1|
  275|      1|        }
  275|      1|        }
  275|     13|            }
  275|     16|        }
  275|     16|                filtered_entries.push(left_filtered[i].clone());
  275|      2|                None
  275|      2|            table_size,
  275|    494|            }
  275|     82|        }
  275|       |            __set
  275|       |            __set
  275|       |            __set
  275|       |            __set
  275|       |            __set
  275|       |            __tree
  276|       |
  276|       |
  276|       |
  276|       |
  276|       |
  276|       |
  276|       |
  276|       |
  276|       |                        }
  276|       |            }
  276|       |        };
  276|       |        }};
  276|       |        }};
  276|       |        }};
  276|       |        }};
  276|       |        }};
  276|       |        }};
  276|       |    }
  276|      0|                    }
  276|      0|    }
  276|      1|            ),
  276|  11.8k|            }
  276|     15|                    1.0
  276|     16|            }
  276|      1|            out
  276|      2|            keys,
  276|      3|            LinkedListStEphS::from_vec(values)
  276|    494|        }
  276|    631|                    out.push(key);
  276|       |    #[allow(dead_code)]
  277|       |
  277|       |
  277|       |
  277|       |
  277|       |
  277|       |                }
  277|       |    }
  277|       |    }
  277|       |    }
  277|       |    }
  277|       |    }
  277|       |    }
  277|       |    }
  277|       |    }
  277|       |    }
  277|      1|            (
  277|      1|        }
  277|     10|        }
  277|     10|                    result.push(seq.nth_cloned(i));
  277|      2|        }
  277|     27|                }
  277|      2|            probe_sequences,
  277|      3|        }
  277|      3|                    Some(b.nth(b_index).clone())
  277|      5|            self.push_left(node.right.as_deref());
  277|  8.29k|                    },
  277|       |            __tree
  278|       |
  278|       |
  278|       |
  278|       |
  278|       |
  278|       |
  278|       |
  278|       |
  278|       |
  278|       |
  278|       |
  278|       |
  278|       |
  278|       |
  278|       |            }
  278|       |            }
  278|       |            }
  278|       |        ];
  278|       |        }};
  278|       |    }
  278|       |}
  278|       |}
  278|      0|        }
  278|     10|                }
  278|     13|                filtered_entries.push(right_filtered[i].clone());
  278|     16|                    values.push(acc.clone());
  278|     18|            height_rec(&*guard)
  278|      1|                "BalancedTreePQ".to_string(),
  278|      2|                0.0
  278|      2|            clustering_analysis,
  278|      3|        }
  278|      4|        }
  278|      5|            Some(value_ref)
  278|    631|                }
  278|      8|                }
  279|       |
  279|       |
  279|       |
  279|       |                );
  279|       |            }
  279|       |            }
  279|       |            }
  279|       |            };
  279|       |    {
  279|       |    }
  279|       |    }
  279|       |}
  279|       |}
  279|       |}
  279|       |}
  279|       |}
  279|       |}
  279|      0|                }
  279|      0|                            break;
  279|      0|                    out.push(key);
  279|      1|            }
  279|     13|            }
  279|     16|                }
  279|     18|        }
  279|      2|                    None
  279|      2|            performance_summary,
  279|      3|            None
  279|     44|        }
  279|      6|        }
  279|      8|            }
  280|       |
  280|       |
  280|       |
  280|       |
  280|       |
  280|       |
  280|       |
  280|       |
  280|       |                }
  280|       |            }
  280|       |            }
  280|       |    }
  280|       |    }
  280|       |}
  280|      0|        }
  280|      0|    }
  280|      0|    }
  280|      0|            dimensions_guard.clone().into_iter()
  280|      1|
  280|      1|            }
  280|      1|            };
  280|      1|        }
  280|     12|        }
  280|  1.27k|        }
  280|     13|                        next_level.push(chunk[0].meld(&chunk[1]));
  280|     18|            }
  280|      1|                .tree
  280|      2|        }
  280|    366|                        }
  280|      4|            }
  280|      4|            result
  280|      8|        }
  280|    803|        }
  281|       |
  281|       |
  281|       |
  281|       |
  281|       |
  281|       |
  281|       |
  281|       |
  281|       |
  281|       |
  281|       |                    }
  281|       |            }
  281|       |            }
  281|       |            }
  281|       |    }
  281|       |    }
  281|       |}
  281|       |}
  281|      0|                }
  281|      0|        }
  281|      1|            ),
  281|    122|        }
  281|     16|            self
  281|      1|                .in_order()
  281|      1|            keys_guard.clone().into_iter()
  281|      1|            result
  281|      2|    }
  281|      2|            ArraySeqMtEphSliceS::from_vec(result)
  281|      4|        }
  281|      4|            acc
  281|     80|                    range_entries.push(pair.clone());
  282|       |
  282|       |
  282|       |
  282|       |
  282|       |
  282|       |
  282|       |
  282|       |
  282|       |                }
  282|       |            }
  282|       |            }
  282|       |    }
  282|      0|                    });
  282|      0|                }
  282|      1|            (
  282|      1|        }
  282|      1|        }
  282|    106|                }
  282|     12|                values.push(f(a.nth(i)));
  282|     16|        }
  282|     19|        }
  282|      1|                .iter()
  282|      2|        }
  282|      3|        }
  282|      3|        }
  282|      4|        }
  282|     46|        }
  282|      5|                        next_level.push(chunk[0].clone());
  282|      8|        }
  282|      8|        }
  282|      9|                total_collisions,
  283|       |
  283|       |
  283|       |
  283|       |
  283|       |
  283|       |
  283|       |
  283|       |
  283|       |
  283|       |
  283|       |
  283|       |            }
  283|       |    }
  283|       |    }
  283|      0|        }
  283|      1|        }
  283|     12|            }
  283|      1|                "BinaryHeapPQ".to_string(),
  283|      5|                    }
  283|     80|            Self::min_link(&*guard).cloned()
  283|      9|                max_chain_length,
  283|       |#[macro_export]
  284|       |
  284|       |
  284|       |
  284|       |
  284|       |
  284|       |
  284|       |
  284|       |                }
  284|       |            }
  284|       |            }
  284|       |    }
  284|      0|                left_result.union(&right_result)
  284|      0|            write!(
  284|      1|            }
  284|     18|            }
  284|      3|        }
  284|      3|            LinkedListStEphS::from_vec(values)
  284|      4|        }
  284|     80|        }
  284|      9|                avg_chain_length,
  285|       |
  285|       |
  285|       |
  285|       |
  285|       |
  285|       |
  285|       |            )
  285|       |    }
  285|      0|                }
  285|      0|            }
  285|      0|                0.0
  285|      0|                f,
  285|      1|
  285|      1|                }
  285|      1|        }
  285|     18|        }
  285|      1|                        Some(v.clone())
  285|      3|        }
  285|    804|        }
  286|       |
  286|       |
  286|       |
  286|       |
  286|       |
  286|       |
  286|       |            };
  286|       |    }
  286|      0|        }
  286|      1|            ),
  286|      2|                left_elements.push(seq.nth(j).clone());
  286|      9|        }
  286|      9|            from_sorted_entries(range_seq)
  287|       |
  287|       |
  287|       |
  287|       |
  287|       |
  287|       |            }
  287|       |            }
  287|       |            }
  287|       |    }
  287|       |    }
  287|       |    }
  287|      1|            (
  287|     16|            &self,
  287|      1|                    group.1.push(value);
  287|      1|                        None
  287|      2|            }
  287|      2|            write!(
  287|      3|        }
  287|      9|            }
  287|      9|        }
  288|       |
  288|       |
  288|       |
  288|       |
  288|       |
  288|       |
  288|       |
  288|       |
  288|       |
  288|       |
  288|       |
  288|       |                    }
  288|       |            )
  288|       |    }
  288|     11|                    values.push(inner.nth_cloned(j));
  288|     14|            }
  288|     17|            }
  288|      1|                "LeftistHeapPQ".to_string(),
  288|      2|            acc
  288|      2|                f,
  288|      3|        }
  288|  5.01k|        }
  288|     80|            Self::max_link(&*guard).cloned()
  289|       |
  289|       |
  289|       |
  289|       |
  289|       |
  289|       |
  289|       |            }
  289|      0|            }
  289|      0|        }
  289|      0|        }
  289|      0|                right.cached_reduction.clone()
  289|      0|                total_collisions,
  289|      1|        }
  289|     11|                }
  289|      2|                })
  289|      2|        }
  289|      3|            heaps.into_iter().next().unwrap_or_else(Self::empty)
  289|      3|                right_elements.push(seq.nth(j).clone());
  289|  4.12k|            }
  289|      5|                    kept.push(value.clone());
  289|      7|            acc
  289|     80|        }
  289|  97.2M|                }
  289|       |    #[macro_export]
  290|       |
  290|       |
  290|       |
  290|       |
  290|       |
  290|       |            }
  290|       |    }
  290|       |    }
  290|       |    }
  290|      0|            dimensions_guard.clone().into_iter()
  290|      0|                max_chain_length,
  290|      0|            pq
  290|      1|
  290|      1|                .collect();
  290|      2|                }
  290|      3|            }
  290|      3|        }
  290|     37|            }
  290|      4|        }
  290|  4.12k|        }
  290|    439|                        break;
  290|      5|                }
  290|      7|        }
  290|  97.2M|                Some(rebalance(n))
  290|       |                self.num_elements,
  291|       |
  291|       |
  291|       |
  291|       |
  291|       |
  291|       |
  291|       |
  291|       |
  291|       |
  291|       |            }
  291|       |            }
  291|       |            }
  291|       |    }
  291|       |    }};
  291|      0|        }
  291|      0|        }
  291|      0|                avg_chain_length,
  291|      0|            keys_guard.clone().into_iter()
  291|      0|                left.cached_reduction.clone()
  291|      1|            ),
  291|      1|            Self::from_sorted_iter(filtered.into_iter())
  291|      3|            ArraySeqMtEphS::from_vec(values)
  291|   513k|                    }
  291|      6|            }
  291|      8|        OrderedSetStPer::from_seq(seq)
  291|       |                self.table_size,
  292|       |
  292|       |
  292|       |
  292|       |
  292|       |                }
  292|       |            )
  292|       |        ]
  292|       |        }
  292|       |    }
  292|      0|        }
  292|      1|        }
  292|     23|            }
  292|      2|            LinkedListStPerS::from_vec(kept)
  292|      3|        }
  292|     33|                }
  292|     51|        }
  292|      8|    }
  292|     89|                    range_entries.push(pair.clone());
  292|      8|                values.push(a.nth(i).clone());
  292|      9|                        .unwrap()
  292|       |                self.load_factor,
  293|       |
  293|       |
  293|       |
  293|       |
  293|       |
  293|       |
  293|       |            }
  293|       |        };
  293|       |    }
  293|       |    }
  293|      0|        }
  293|      1|    }
  293|   117M|    }
  293|      1|                a.length(),
  293|      1|                .into_iter()
  293|      2|        }
  293|    200|                }
  293|     23|        }
  293|     24|        }
  293|      4|                    left_entries.push(pair.clone());
  293|      8|            }
  293|      8|                    break;
  293|      9|                        .clone()
  293|       |    #[macro_export]
  293|       |    #[macro_export]
  293|       |                self.num_collisions,
  294|       |
  294|       |
  294|       |
  294|       |
  294|       |
  294|       |
  294|       |
  294|       |
  294|       |
  294|       |
  294|       |
  294|       |            )
  294|       |            }
  294|       |            };
  294|       |    }
  294|     10|                }
  294|     18|                }
  294|     24|    }
  294|      3|        }
  294|      6|        }
  294|      7|            result
  294|      9|                },
  294|       |                self.max_chain_length,
  295|       |
  295|       |
  295|       |
  295|       |
  295|       |
  295|       |
  295|       |
  295|       |
  295|       |
  295|       |            }
  295|      1|
  295|      1|        }
  295|      1|                .collect();
  295|    358|            ArraySeqStPerS::from_vec(out)
  295|      4|            };
  295|  5.59k|                    self.table.nth(i).clone()
  295|      7|        }
  295|      8|                values.push(b.nth(j).clone());
  295|       |    #[macro_export]
  295|       |                self.avg_chain_length
  296|       |
  296|       |                }
  296|       |                };
  296|       |            )
  296|       |            )
  296|       |            }
  296|       |    }
  296|       |    }
  296|       |    }
  296|       |    }};
  296|       |            $crate::Chap45::BalancedTreePQ::BalancedTreePQ::BalancedTreePQ::empty()
  296|      1|            ArraySeqS::from_vec(grouped)
  296|    358|        }
  296|      4|            it.push_left(root);
  296|      4|                    right_entries.push(pair.clone());
  296|      8|            }
  297|       |
  297|       |
  297|       |
  297|       |
  297|       |
  297|       |
  297|       |        };
  297|       |        };
  297|       |    }
  297|       |}
  297|       |}
  297|      0|                result.push(self.elements.nth(i).clone());
  297|      1|            }
  297|      1|        }
  297|     10|            from_sorted_entries(range_seq)
  297|      2|        }
  297|      2|        }
  297|    205|            }
  297|      3|            LinkedListStEphS::from_vec(values)
  297|      4|            it
  297|       |    #[macro_export]
  297|       |            __set
  298|       |
  298|       |
  298|       |
  298|       |        }};
  298|       |    }
  298|       |            $crate::Chap43::OrderedSetStPer::OrderedSetStPer::OrderedSetStPer::empty()
  298|      0|                }
  298|      0|            }
  298|      0|            writeln!(
  298|     10|        }
  298|      1|            textbook_example(),
  298|      2|        }
  298|      2|        }
  298|      3|        }
  298|      3|            height_rec(&self.root)
  298|      3|            result
  298|      4|        }
  298|   513k|                            self.entries.nth(i).clone()
  298|      8|            }
  298|       |    #[macro_export]
  298|       |    #[macro_export]
  299|       |
  299|       |
  299|       |
  299|       |
  299|       |
  299|       |
  299|       |            }
  299|       |            }
  299|       |        }
  299|       |        };
  299|       |    }
  299|       |    }
  299|      0|                f,
  299|      0|            result
  299|      0|            writeln!(
  299|      1|        }
  299|     14|                    prefixes.push(acc.clone());
  299|      1|            reverse_sorted_example(),
  299|      3|                    }
  299|      3|        }
  299|      3|        }
  300|       |
  300|       |
  300|       |
  300|       |
  300|       |
  300|       |
  300|       |
  300|       |
  300|       |                }
  300|       |            }
  300|       |    }
  300|       |            $(
  300|       |            $crate::Chap42::TableStEph::TableStEph::TableStEph::empty()
  300|      0|        }
  300|      0|                f,
  300|      1|
  300|      1|            };
  300|  10.0k|                }
  300|   121M|        }
  300|     14|                }
  300|     16|        }
  300|      1|            already_sorted_example(),
  300|      1|                    left.push(value.clone());
  300|  2.58k|                            new_pair.clone()
  300|      2|            .to_string();
  300|      2|                    values.push(item.clone());
  300|      5|                values.push(acc.clone());
  300|      7|                    break;
  301|       |
  301|       |
  301|       |
  301|       |
  301|       |
  301|       |
  301|       |                }
  301|       |            }
  301|       |            }
  301|       |        };
  301|       |}
  301|       |            $crate::Chap43::OrderedSetStPer::OrderedSetStPer::from_sorted_elements(vec![$($elem),+])
  301|       |            $crate::Chap50::MatrixChainMtEph::MatrixChainMtEph::MatrixChainMtEphS::from_dim_pairs(
  301|      1|            }
  301|      1|            duplicates_example(),
  301|      5|            }
  301|       |                self.hash_function_independence
  301|       |            __tree
  302|       |
  302|       |
  302|       |
  302|       |            )*
  302|       |            }
  302|       |        };
  302|       |        }};
  302|      0|            )?;
  302|      0|            }
  302|      0|        }
  302|      0|                self.num_elements
  302|      1|        }
  302|      1|            ArraySeqStPerS::from_vec(out)
  302|      1|                    right.push(value.clone());
  302|      1|            single_element_example(),
  302|      2|        }
  302|    450|        }
  302|      6|                    values.push(current);
  302|       |                self.num_elements,
  303|       |
  303|       |
  303|       |
  303|       |
  303|       |
  303|       |                        }
  303|       |            )
  303|       |    }
  303|       |    }
  303|       |    }
  303|       |    }
  303|      0|                self.load_factor()
  303|      1|        "#
  303|      1|        }
  303|      1|        }
  303|     10|                self.stack.push(node);
  303|      1|            empty_example(),
  303|      4|            }
  303|      4|        }
  303|     51|        });
  303|      6|                }
  303|      6|            }
  303|  80.9M|        }
  303|      8|            count
  303|       |            pq
  304|       |
  304|       |
  304|       |
  304|       |
  304|       |
  304|       |
  304|       |
  304|       |            }
  304|       |        ];
  304|       |        };
  304|       |        }};
  304|       |    }
  304|       |    }
  304|       |}
  304|       |}
  304|      0|            )?;
  304|      1|            acc
  304|      1|        .to_string()
  304|    202|        }
  304|   518k|                    },
  304|      6|                    }
  304|      8|        }
  305|       |
  305|       |
  305|       |
  305|       |
  305|       |
  305|       |
  305|       |
  305|       |
  305|       |                }
  305|       |            };
  305|       |    }
  305|       |    }
  305|       |}
  305|       |            $crate::Chap42::TableStEph::TableStEph::from_sorted_entries(entries)
  305|      0|        }
  305|      0|            self.to_vec()
  305|      1|                }
  305|      1|        }
  305|      1|    }
  305|     10|            }
  305|  15.7k|        }
  305|   197M|    }
  305|      2|            LinkedListStPerS::from_vec(values)
  305|      2|            .to_string();
  305|      6|                    kept.push(value.clone());
  305|       |    #[macro_export]
  306|       |
  306|       |
  306|       |
  306|       |
  306|       |
  306|       |
  306|       |
  306|       |
  306|       |                );
  306|       |            }
  306|       |            }
  306|       |        }};
  306|       |    }
  306|       |            $crate::Chap50::MatrixChainMtEph::MatrixChainMtEph::MatrixChainMtEphS::new()
  306|      0|            }
  306|      0|        }
  306|     13|        }
  306|    156|        where
  306|      1|        test_cases
  306|      1|                            values.push(group.1.nth_cloned(j));
  306|      2|        }
  306|      7|                }
  306|       |    #[macro_export]
  306|       |    #[macro_export]
  307|       |
  307|       |
  307|       |
  307|       |
  307|       |
  307|       |
  307|       |
  307|       |
  307|       |
  307|       |            }
  307|       |        };
  307|       |    }
  307|       |    }
  307|       |    }
  307|      0|        }
  307|      1|                        }
  307|      1|            (
  307|      1|            };
  307|      1|                0
  307|     13|        }
  307|      1|            .iter()
  307|       |    #[allow(dead_code)]
  307|       |    #[macro_export]
  308|       |
  308|       |
  308|       |
  308|       |
  308|       |
  308|       |
  308|       |        {
  308|       |    }
  308|       |    }
  308|       |}
  308|     10|                    result.push(element);
  308|      1|                Self::from_sorted_iter(left.into_iter()),
  308|      1|                        values.push(value.clone());
  308|      3|        }
  308|      3|            LinkedListStEphS::from_vec(kept)
  308|      4|            }
  308|      5|        table
  308|      6|                    break;
  309|       |
  309|       |
  309|       |
  309|       |            }
  309|       |        };
  309|       |}
  309|      1|    }
  309|     10|                }
  309|     14|        }
  309|      1|                found,
  309|      3|        }
  309|      4|        }
  309|      5|    }
  309|     51|        left_result
  309|      6|                }
  310|       |
  310|       |
  310|       |
  310|       |
  310|       |
  310|       |
  310|       |
  310|       |
  310|       |            }
  310|       |            }
  310|       |        };
  310|       |}
  310|       |            $crate::Chap50::OptBinSearchTreeMtEph::OptBinSearchTreeMtEph::OBSTMtEphS::from_keys_probs(
  310|      1|        }
  310|    122|    }
  310|    157|                self.num_deleted
  310|      1|                Self::from_sorted_iter(right.into_iter()),
  310|      2|                None
  310|      2|            table_size,
  310|  3.56k|        }
  311|       |
  311|       |
  311|       |
  311|       |
  311|       |            }
  311|       |            };
  311|       |    }
  311|      0|    }
  311|      1|            )
  311|     11|                    break;
  311|    155|            }
  311|      1|                        break;
  311|      2|            keys,
  311|      3|        }
  311|      4|            }
  311|      4|            write!(
  311|       |                vec![$($k),*],
  312|       |
  312|       |
  312|       |
  312|       |
  312|       |
  312|       |
  312|       |
  312|       |                }
  312|      0|                }
  312|      1|                    }
  312|      1|        }
  312|      1|            acc
  312|      2|            probe_sequences,
  312|      4|                f,
  312|      7|                Some(entries.nth(i).0.clone())
  312|       |                vec![$($crate::Chap50::Probability::Probability::Probability::new($p)),*]
  313|       |
  313|       |
  313|       |                }
  313|       |            )
  313|       |            }
  313|       |            }
  313|       |            }
  313|       |    ///
  313|      0|            }
  313|      1|            };
  313|      1|        }
  313|      1|        OrderedSetStEph::from_seq(seq)
  313|      2|            clustering_analysis,
  313|      2|            result
  313|      6|            }
  313|       |    #[allow(dead_code)]
  313|       |            __set
  314|       |
  314|       |
  314|       |        }
  314|       |        };
  314|       |        }};
  314|      1|    }
  314|     11|            count
  314|     16|        }
  314|      2|        }
  314|      2|                LinkedListStEphS::from_vec(vec![x.clone()])
  314|      2|            performance_summary,
  314|      4|            candidate
  314|      7|            }
  314|     73|            }
  314|      9|        }
  314|      9|            self.push_left(&node.right);
  314|       |            __tree
  315|       |
  315|       |
  315|       |
  315|       |
  315|       |
  315|       |
  315|       |
  315|       |            )
  315|       |            }
  315|       |        }};
  315|       |    }
  315|      0|                        }
  315|      0|                }
  315|      0|                }
  315|      1|            }
  315|     11|        }
  315|      2|        }
  315|      2|        }
  315|      3|        }
  315|      4|        }
  315|      4|            ArraySeqStPerS::from_vec(out)
  315|      5|                    seen.insert(idx);
  315|      7|        }
  315|      9|            Some(value_ref)
  316|       |
  316|       |
  316|       |
  316|       |
  316|       |
  316|       |
  316|       |
  316|       |            }
  316|       |    ///
  316|       |    }
  316|       |    }
  316|       |            $crate::Chap50::OptBinSearchTreeMtEph::OptBinSearchTreeMtEph::OBSTMtEphS::new()
  316|     11|        }
  316|      1|                LinkedListStEphS::empty()
  316|      2|                }
  316|      2|        }
  316|      2|    }
  316|      2|        true
  316|      4|        }
  316|      4|        }
  316|      5|                }
  316|      9|                    Ok(())
  317|       |
  317|       |
  317|       |
  317|       |
  317|       |                    }
  317|       |            }
  317|       |            }
  317|       |            }
  317|       |        };
  317|       |    }
  317|       |    }
  317|       |    }
  317|       |}
  317|       |}
  317|      0|            true
  317|      1|                combined.insert(value);
  317|      4|    }
  317|       |    #[macro_export]
  318|       |
  318|       |
  318|       |
  318|       |
  318|       |
  318|       |
  318|       |
  318|       |    }
  318|       |}
  318|      0|        }
  318|      0|    }
  318|      0|                    writeln!(f)?;
  318|      1|            }
  318|     10|        }
  318|      1|            ArraySeqMtEphS::from_vec(groups)
  318|      3|        }
  318|      3|            LinkedListStPerS::from_vec(values)
  319|       |
  319|       |
  319|       |
  319|       |                }
  319|       |    }
  319|       |}
  319|       |}
  319|      0|                }
  319|      1|            }
  319|      1|        }
  319|    157|            }
  319|  1.62k|        }
  319|      1|        output.push_str("\n");
  319|      1|            Self::from_sorted_iter(combined.into_iter())
  319|      3|        }
  319|     51|            &self,
  319|       |    #[macro_export]
  319|       |    #[macro_export]
  320|       |
  320|       |
  320|       |
  320|       |
  320|       |
  320|       |
  320|       |
  320|       |
  320|       |            }
  320|       |            }
  320|       |}
  320|       |            $crate::Chap43::OrderedSetStEph::OrderedSetStEph::OrderedSetStEph::empty()
  320|      1|            };
  320|      1|        }
  320|    157|        }
  320|      3|        }
  320|      5|            }
  320|      7|            range_table.reduce_val()
  321|       |
  321|       |
  321|       |
  321|       |
  321|       |
  321|       |
  321|       |        }
  321|       |        };
  321|       |    ///
  321|       |    }
  321|     10|            }
  321|      1|            pq
  321|      3|                None
  321|      4|            ArraySeqStPerS::from_vec(out)
  321|      4|                prefixes.push(acc.clone());
  321|      7|        }
  322|       |
  322|       |
  322|       |
  322|       |
  322|       |    }
  322|      1|        }
  322|     35|    }
  322|  3.77k|                    range_entries.push(pair.clone());
  322|      4|            }
  322|      4|        }
  323|       |
  323|       |
  323|       |
  323|       |
  323|       |
  323|       |
  323|       |
  323|       |        };
  323|       |    }
  323|       |            $crate::Chap43::OrderedSetStEph::OrderedSetStEph::from_sorted_elements(vec![$($elem),+])
  323|      0|        }
  323|      1|        }
  323|     10|                Some(entries.nth(i).0.clone())
  323|      3|            }
  323|  4.20k|                }
  324|       |
  324|       |
  324|       |
  324|       |
  324|       |
  324|       |            }
  324|       |            }
  324|       |        };
  324|       |    }
  324|       |    }
  324|       |    }
  324|      1|        }
  324|      1|            combined.insert(pivot);
  324|      3|                }
  324|      9|            }
  324|       |    #[macro_export]
  325|       |
  325|       |
  325|       |
  325|       |
  325|       |
  325|       |
  325|       |            }
  325|       |    }
  325|       |    }
  325|     11|                    values.push(inner.nth(j).clone());
  325|     13|        }
  325|      1|            writeln!(
  325|     47|                ClusteringSeverity::Minimal
  325|      7|                        union_entries.push(pair1.clone());
  325|       |    where
  326|       |
  326|       |
  326|       |
  326|       |
  326|       |
  326|       |
  326|       |}
  326|     11|                }
  326|      1|                combined.insert(value);
  326|      1|                f,
  326|      4|                results.push(acc.clone());
  326|      5|            }
  326|     93|            0
  326|       |    #[macro_export]
  326|       |    #[macro_export]
  327|       |
  327|       |
  327|       |
  327|       |            );
  327|       |            }
  327|       |        }
  327|       |    {
  327|      0|                    });
  327|      0|                ClusteringSeverity::Moderate
  327|      1|            }
  327|      1|            acc
  327|     25|            from_sorted_entries(range_seq)
  327|      2|            result
  327|      5|                }
  327|      5|        }
  327|      7|                    }
  327|      8|            }
  328|       |
  328|       |
  328|       |
  328|       |
  328|       |            }
  328|      1|        }
  328|    167|    }
  328|      1|            Self::from_sorted_iter(combined.into_iter())
  328|      2|        }
  328|     25|        }
  328|      3|            LinkedListStEphS::from_vec(values)
  328|      8|                result.push(self.elements.nth(i).clone());
  328|       |                self.secondary_clustering_coefficient
  329|       |
  329|       |
  329|       |
  329|       |
  329|       |
  329|       |
  329|       |
  329|       |    }
  329|       |    }
  329|      0|            )?;
  329|      0|                ClusteringSeverity::Severe
  329|      0|                left_result.union(&right_result)
  329|      0|                        union_entries.push(pair2.clone());
  329|      1|        }
  329|    156|        }
  329|     27|        }
  329|     27|        }
  329|      2|            LinkedListStPerS::from_vec(values)
  329|      3|        }
  329|      3|        }
  329|      4|            }
  329|      4|                left_entries.push(entries.nth(j).clone());
  329|      6|        }
  329|      8|            }
  330|       |
  330|       |
  330|       |
  330|       |
  330|       |
  330|       |
  330|       |
  330|       |
  330|       |
  330|       |        };
  330|      0|            }
  330|      1|        result
  330|      2|        }
  330|     27|    }
  330|      2|            result
  330|      4|            }
  330|       |            t
  331|       |
  331|       |
  331|       |
  331|       |
  331|       |        }};
  331|       |    }
  331|       |    }
  331|       |    }
  331|      0|                    }
  331|      1|    }
  331|      1|    }
  331|      2|        }
  331|  3.99k|        where
  331|      4|                ClusteringSeverity::Critical
  331|      8|        }
  332|       |
  332|       |
  332|       |
  332|       |
  332|       |
  332|       |
  332|       |
  332|       |            };
  332|       |}
  332|      1|        }
  332|     11|                right_entries.push(entries.nth(j).clone());
  332|      1|        where
  332|      5|        }
  332|       |        where
  333|       |
  333|       |
  333|       |        {
  333|       |    }
  333|       |    }
  333|      0|        NestedHashTable::create_table(initial_size)
  333|      1|        }
  333|     11|            }
  333|     19|            range_table.reduce_val()
  333|      1|        output.push_str("\n");
  333|      5|                }
  333|  5.01k|        }
  333|      5|            a
  333|      8|        }
  333|      9|    }
  333|       |    #[macro_export]
  333|       |    #[macro_export]
  334|       |
  334|       |
  334|       |
  334|       |
  334|       |
  334|       |
  334|       |
  334|       |            }
  334|       |        {
  334|       |    }
  334|      0|    }
  334|     19|        }
  334|      2|            .to_string();
  334|      5|        }
  335|       |
  335|       |
  335|       |
  335|       |
  335|       |
  335|       |
  335|       |
  335|       |    }
  335|      1|            };
  335|      7|            true
  335|       |            t
  336|       |
  336|       |
  336|       |
  336|       |
  336|       |        }};
  336|       |    ///
  336|       |            $crate::Chap42::TableStPer::TableStPer::TableStPer::empty()
  336|      1|        }
  336|     11|        }
  336|     12|            }
  336|      1|            self.to_vec()
  336|      2|            }
  336|     38|    }
  336|  3.99k|            }
  336|      5|                values.push(acc.clone());
  336|       |            Vec::new()
  337|       |
  337|       |
  337|       |
  337|       |
  337|       |
  337|       |        };
  337|       |        };
  337|       |    }
  337|       |    }
  337|      1|        }
  337|      1|        output.push_str(&exercise_47_1_nested_implementation());
  337|     23|            }
  337|      3|                    }
  337|      3|            acc
  337|      5|            }
  337|       |    #[macro_export]
  338|       |
  338|       |
  338|       |
  338|       |
  338|       |
  338|       |                }
  338|       |                }
  338|      0|        NestedHashTable::create_table(initial_size)
  338|      1|            }
  338|      1|        output.push_str(&exercise_47_2_size_reduction());
  338|      3|        }
  339|       |
  339|       |
  339|       |
  339|       |            }
  339|      0|    }
  339|      1|        }
  339|  1.99k|            }
  339|      1|        where
  339|      1|            writeln!(
  339|      2|            .to_string();
  339|      4|        }
  340|       |
  340|       |
  340|       |
  340|       |
  340|       |
  340|       |
  340|       |
  340|       |
  340|       |                },
  340|       |        };
  340|       |    }
  340|       |    }
  340|      1|                f,
  340|      1|        output
  341|       |
  341|       |
  341|       |
  341|       |            }
  341|       |        {
  341|       |        };
  341|       |    }
  341|       |            $crate::Chap42::TableStPer::TableStPer::from_sorted_entries(entries)
  341|      1|                }
  341|      1|    }
  341|     11|                    break;
  341|      1|                Self::next_prime(desired_size)
  341|      1|        vec![
  341|      8|            }
  342|       |
  342|       |
  342|       |
  342|       |                }
  342|       |                }
  342|       |        }};
  342|       |}
  342|      1|            };
  342|      2|            acc
  342|      4|                left_entries.push(entries.nth(j).clone());
  342|  5.28k|        }
  342|       |    #[macro_export]
  342|       |                self.num_elements,
  343|       |
  343|       |
  343|       |
  343|       |            }
  343|       |            }
  343|       |            };
  343|       |    }
  343|      0|                }
  343|      1|        }
  343|      1|                self.table.length(),
  343|      1|                union_entries.push(self.entries.nth_cloned(i).clone());
  343|      2|            }
  343|      2|        }
  343|      3|            }
  343|      4|            }
  343|      6|                }
  343|       |    #[macro_export]
  344|       |
  344|       |
  344|       |
  344|       |
  344|       |            }
  344|       |}
  344|      0|            f.debug_struct("DirGraphMtEph")
  344|      1|            }
  344|     11|            count
  344|      1|            result
  344|     28|            }
  344|      2|            table_size,
  344|       |                self.num_deleted
  345|       |            }
  345|       |        }
  345|      0|            )?;
  345|      1|            }
  345|      1|        }
  345|      1|        }
  345|     11|        }
  345|      2|        }
  345|      2|            keys,
  345|      3|            out
  345|    541|            }
  345|      5|                right_entries.push(entries.nth(j).clone());
  345|       |            NestedHashTable::create_table($size)
  345|       |            __tree
  346|       |
  346|       |
  346|       |
  346|       |
  346|       |
  346|       |
  346|       |
  346|       |
  346|       |        };
  346|       |        }};
  346|       |    }
  346|      0|        update_meta(x.right.as_mut().unwrap());
  346|      1|                }
  346|      1|            }
  346|      2|            probe_sequences,
  346|      3|        }
  346|      4|                }
  346|      5|            }
  346|    541|        }
  346|    715|                    values.push(inner_seq.nth(j).clone());
  346|      8|        total
  346|       |            Vec::new()
  347|       |
  347|       |
  347|       |
  347|       |
  347|       |
  347|       |            }
  347|       |        };
  347|       |    }
  347|      0|        }
  347|      0|                .finish()
  347|      1|            }
  347|      1|        }
  347|      2|            clustering_analysis,
  347|    715|                }
  347|      8|    }
  347|      9|                }
  348|       |
  348|       |
  348|       |
  348|       |            }
  348|       |            }
  348|       |    }
  348|       |    }
  348|       |    }
  348|       |}
  348|      0|        }
  348|      0|        x
  348|      2|            performance_summary,
  348|      2|            true
  348|      3|                prefixes.push(acc.clone());
  349|       |
  349|       |
  349|       |
  349|       |
  349|       |
  349|       |    }
  349|       |}
  349|       |            $(
  349|      0|    }
  349|    111|            ArraySeqMtPerS::from_vec(values)
  349|      2|        }
  349|      2|        }
  349|      2|            true
  349|     51|                recommended_action,
  349|      7|                union_entries.push(other.entries.nth_cloned(j).clone());
  349|       |    #[macro_export]
  350|       |
  350|       |
  350|       |
  350|       |
  350|       |
  350|       |        };
  350|      1|                }
  350|    108|                }
  350|    111|        }
  350|      2|    }
  350|      3|            }
  350|      4|                }
  350|      4|        }
  350|     51|            }
  350|       |    #[macro_export]
  351|       |
  351|       |
  351|       |
  351|       |
  351|       |
  351|       |            )*
  351|       |            }
  351|       |    }
  351|       |    }
  351|      1|                seq
  351|      1|                size
  351|      2|                }
  351|      3|                None
  351|     51|        }
  351|      7|            }
  352|       |
  352|       |
  352|       |
  352|       |
  352|       |
  352|       |
  352|       |            );
  352|       |            }
  352|       |            }
  352|       |            }),
  352|       |            $crate::Chap45::BinaryHeapPQ::BinaryHeapPQ::BinaryHeapPQ::empty()
  352|      1|        }
  352|       |            table
  353|       |
  353|       |
  353|       |
  353|       |
  353|       |                }
  353|       |        ]
  353|       |        };
  353|       |        }};
  353|       |    }
  353|       |}
  353|     11|                Some(entries.nth(i).0.clone())
  353|      1|            result
  353|      2|        }
  353|     23|            result
  353|      6|            }
  354|       |
  354|       |
  354|       |
  354|       |            }
  354|       |            }
  354|       |        };
  354|       |    }
  354|       |    }
  354|      1|        }
  354|      1|    }
  354|      1|    }
  354|     23|        }
  354|      2|            out
  354|  3.99k|        }
  354|      6|        }
  355|       |
  355|       |
  355|       |
  355|       |
  355|       |
  355|       |
  355|       |
  355|       |
  355|       |
  355|       |    }
  355|       |    }
  355|       |}
  355|       |}
  355|     14|        }
  355|      2|            }
  355|      2|        }
  355|      2|        }
  355|      6|            range_table.reduce_val()
  356|       |
  356|       |
  356|       |
  356|       |
  356|       |
  356|       |    }
  356|       |            $(
  356|      1|                0
  356|    111|            elements.push(entries.nth(i).clone());
  356|      1|            &self,
  356|      6|        }
  356|       |    #[allow(dead_code)]
  357|       |
  357|       |
  357|       |    }
  357|       |    }
  357|      1|        }
  357|    111|        }
  357|       |    #[macro_export]
  358|       |
  358|       |
  358|       |            )*
  358|       |    }
  358|      1|    }
  358|      4|                }
  358|     65|            }
  358|       |            __set
  358|       |    where
  359|       |
  359|       |
  359|       |
  359|       |
  359|       |
  359|       |            }
  359|       |            }
  359|       |        }};
  359|       |}
  359|      0|    }
  359|      6|        update_meta(y.left.as_mut().unwrap());
  359|       |            pq
  360|       |
  360|       |
  360|       |        }};
  360|       |    {
  360|       |    }
  360|       |}
  360|     22|        }
  360|    233|            }
  360|      4|        }
  360|       |    #[macro_export]
  360|       |    where
  361|       |
  361|       |
  361|       |
  361|       |
  361|       |    }
  361|       |    }
  361|      0|                range_table.reduce_val()
  361|     22|    }
  361|    233|        }
  361|     25|            }
  361|      6|        y
  362|       |
  362|       |
  362|       |
  362|       |
  362|       |            }
  362|       |    {
  362|       |    }
  362|       |    }
  362|       |}
  362|      1|        }
  362|      1|                strategy_name,
  362|      1|            write!(
  362|      2|            }
  362|      3|                }
  362|      5|                values.push(acc.clone());
  362|      6|    }
  363|       |
  363|       |
  363|       |
  363|       |
  363|       |            }
  363|       |    }
  363|       |}
  363|      1|        }
  363|      1|                f,
  363|      1|                table_size,
  363|      2|        }
  363|      4|                        values.push(value.clone());
  363|      5|            }
  363|       |    #[allow(dead_code)]
  364|       |
  364|       |
  364|       |    }
  364|       |    }
  364|      1|                load_factor,
  364|      1|            result
  364|       |    #[macro_export]
  365|       |
  365|       |
  365|      1|        }
  365|      1|        }
  365|      1|                self.size(),
  365|      3|                    existing.push(v);
  366|       |
  366|       |
  366|       |        }};
  366|       |    }
  366|      2|            }
  366|     20|        }
  366|      2|            .to_string();
  366|      4|                        break;
  366|       |                self.cached_reduction
  367|       |
  367|       |
  367|       |
  367|       |
  367|       |
  367|       |            )
  367|       |    }
  367|       |            $crate::Chap43::OrderedTableStPer::OrderedTableStPer::OrderedTableStPer::empty()
  367|      0|    }
  367|      3|                    }
  367|     60|                }
  368|       |
  368|       |
  368|       |
  368|       |                }
  368|       |        };
  368|      1|        }
  368|      4|                }
  368|      5|        }
  368|     69|        }
  369|       |
  369|       |
  369|       |            }
  369|       |    }
  369|       |    }
  369|      6|                        difference_entries.push(pair1.clone());
  370|       |
  370|       |
  370|       |
  370|       |            }
  370|     10|        }
  371|       |
  371|       |
  371|       |
  371|       |        };
  371|      2|                .into_iter()
  371|      4|                }
  371|      6|                    }
  371|       |    #[macro_export]
  372|       |            }
  372|       |    }
  372|       |            $crate::Chap43::OrderedTableStPer::OrderedTableStPer::from_sorted_entries(seq)
  372|    109|            elements.push(entries.nth(i).clone());
  372|      2|            }
  372|     21|            }
  372|      2|                .to_string();
  372|      4|                left_entries.push(entries.nth(j).clone());
  372|       |                __s
  372|       |    where
  373|       |
  373|       |
  373|       |
  373|       |            };
  373|       |        }};
  373|      0|            }
  373|    109|        }
  373|      1|            out
  373|    206|        }
  373|      2|            ArraySeqMtPerS::from_vec(groups)
  373|      2|                .collect();
  373|      4|            }
  373|      9|            }
  374|       |
  374|       |    {
  374|       |    }
  374|       |            $crate::Chap18::ArraySeq::ArraySeq::ArraySeqS::from_vec(Vec::new())
  374|      0|                    }
  374|      1|                },
  374|      1|        }
  374|      2|        }
  374|      2|            LinkedListStEphS::from_vec(pairs)
  374|      3|            }
  374|      6|        }
  374|      9|        }
  375|       |
  375|       |
  375|       |        };
  375|       |        }}}
  375|       |    }
  375|       |    }
  375|       |}
  375|      1|            }
  375|      2|        }
  375|     20|        }
  375|      5|                right_entries.push(entries.nth(j).clone());
  375|       |    impl_hash_function!(
  376|       |
  376|       |
  376|       |
  376|       |
  376|      1|        }
  376|      1|            f.debug_struct("AugOrderedTableStEph")
  376|      1|            String,
  376|     21|        }
  376|     40|            }
  376|      5|            }
  376|       |        SimpleIntegerHash,
  377|       |
  377|       |
  377|       |
  377|       |    }
  377|       |}
  377|      1|            String,
  377|     21|    }
  377|      2|            table_size,
  377|      5|            }
  377|       |        i32,
  377|       |    #[macro_export]
  378|       |
  378|       |
  378|       |        };
  378|      1|            Self::from_seq(&seq)
  378|      4|                    }
  379|       |                }
  379|      1|        }
  379|     11|                prefixes.push(red);
  379|      1|                .finish()
  379|      2|            probe_sequences,
  379|      3|                        Ok(())
  380|       |
  380|       |
  380|       |                    }
  380|       |            }
  380|       |    );
  380|       |            $crate::Chap18::ArraySeq::ArraySeq::ArraySeqS::from_vec(vec![$($elem),+])
  380|      1|        }
  380|     11|            }
  380|      2|            clustering_analysis,
  380|       |    #[macro_export]
  381|       |
  381|       |
  381|       |
  381|       |
  381|       |                }
  381|       |        };
  381|       |    }
  381|     14|            ArraySeqStPerS::from_vec(out)
  381|      2|            }
  381|      2|            performance_summary,
  381|      5|                }
  381|      6|            }
  381|      7|            }
  382|       |
  382|       |            }
  382|       |    }
  382|       |    }
  382|     14|        }
  382|      2|        }
  382|      2|            acc
  382|      7|            }
  383|       |
  383|       |
  383|       |
  383|       |
  383|       |    }
  383|       |            $crate::Chap43::OrderedTableStEph::OrderedTableStEph::OrderedTableStEph::empty()
  383|      0|            writeln!(
  383|      1|    }
  383|     14|        }
  383|      2|        }
  383|      2|        }
  383|      2|    }
  383|      3|        }
  383|      4|        }
  383|    427|                }
  384|       |
  384|       |
  384|       |
  384|       |
  384|       |
  384|       |            }
  384|       |        };
  384|       |    }
  384|       |}
  384|       |}
  384|       |}
  384|      0|                f,
  384|     14|        n
  384|      1|                difference_entries.push(self.entries.nth_cloned(i).clone());
  384|      2|            }
  384|       |    #[allow(dead_code)]
  384|       |    #[macro_export]
  385|       |
  385|      2|        }
  385|     20|    }
  385|      3|                result.push(self.elements.nth(i).clone());
  385|    423|            result
  385|     99|                }
  386|       |
  386|       |
  386|       |            }
  386|      1|            }
  386|      1|        }
  386|      3|            }
  386|    423|        }
  387|       |
  387|       |
  387|       |
  387|       |    }
  387|      0|            )?;
  387|      1|            result
  387|       |    #[doc(hidden)]
  388|       |
  388|       |            $(
  388|       |            $crate::Chap43::OrderedTableStEph::OrderedTableStEph::from_sorted_entries(seq)
  388|      1|        }
  388|      2|        }
  388|     21|            result
  389|       |
  389|       |
  389|       |
  389|       |        }};
  389|       |    }
  389|      0|    }
  389|      0|            writeln!(f)?;
  389|     21|        }
  389|  3.77k|                }
  389|      3|                prefixes.push(acc.clone());
  389|      4|        }
  390|       |
  390|       |
  390|       |
  390|       |            )*
  390|       |            }
  390|       |    }
  390|       |    }
  390|       |}
  390|     13|                    values.push(inner.nth(j).clone());
  390|      4|            }
  390|       |    #[macro_export]
  391|       |
  391|       |
  391|       |
  391|       |    }
  391|       |}
  391|     13|                }
  391|      3|            }
  391|      4|        }
  391|       |            table
  392|       |
  392|       |            }
  392|       |        }};
  392|       |    }
  392|       |}
  392|      2|        where
  392|     40|            result
  393|       |
  393|       |
  393|       |            $crate::Chap45::LeftistHeapPQ::LeftistHeapPQ::LeftistHeapPQ::empty()
  393|      0|                writeln!(f)?;
  393|      1|        }
  393|      3|            LinkedListStPerS::from_vec(values)
  393|     40|        }
  393|       |    where
  394|       |
  394|       |                },
  394|       |        {
  394|       |        };
  394|       |    }
  394|      0|            }
  394|      2|        load_factors
  394|      3|        }
  395|       |
  395|       |
  395|       |
  395|       |            }
  395|       |            }
  395|       |        }};
  395|       |    {
  395|      2|            .into_iter()
  395|      5|                result.push(sorted_seq.nth(i).clone());
  396|       |
  396|       |
  396|       |    }
  396|      1|            f.debug_list()
  396|      5|            }
  396|    799|        }
  397|       |
  397|       |
  397|       |            $crate::Chap45::LeftistHeapPQ::LeftistHeapPQ::LeftistHeapPQ::from_seq(&elements)
  397|      1|                .entries(guard[self.range.start..self.range.end].iter())
  397|      1|            result
  397|      1|            write!(
  397|      5|                }
  398|       |        }};
  398|       |}
  398|      0|                writeln!(f)?;
  398|      1|        }
  398|      1|                f,
  398|      1|                .finish()
  398|      1|            write!(
  399|       |            }
  399|       |    }
  399|       |    }
  399|      0|            }
  399|      1|        }
  399|      1|                f,
  399|     54|            }
  399|      8|            })
  400|       |
  400|       |
  400|       |
  400|       |
  400|       |    }
  400|       |}
  400|      1|                self.size(),
  400|      2|            .collect()
  400|  3.79k|            elements.push(entries.nth(i).clone());
  401|       |
  401|       |
  401|      1|                self.size(),
  401|      2|    }
  401|  3.79k|        }
  401|      6|                }
  401|       |    #[allow(dead_code)]
  401|       |                self.cached_reduction
  402|       |
  402|       |
  402|       |            )
  402|       |            }
  402|     20|                }
  402|     20|            }
  402|       |                self.cached_reduction
  403|       |
  403|       |            )
  403|      0|                writeln!(f)?;
  403|      1|        }
  403|     20|                Some(rebalance(n))
  404|       |            }
  404|       |    }
  404|      0|            }
  404|      1|        }
  404|      1|        }
  404|      2|            result
  404|     36|        }
  404|      3|                    existing.push(v);
  405|       |
  405|       |
  405|       |
  405|       |
  405|       |                }
  405|       |        }
  405|       |    }
  405|      0|    }
  405|      2|        }
  405|     36|    }
  406|       |
  406|       |
  406|       |
  406|       |
  406|       |            }
  406|     59|    }
  407|       |
  407|       |
  407|      0|        }
  407|      4|                }
  407|       |    where
  408|       |
  408|       |            }
  408|       |    }
  408|  4.52k|            None
  409|       |
  409|       |
  409|       |
  409|       |    {
  409|      1|            f.debug_struct("AugOrderedTableMtEph")
  409|      2|        where
  409|  4.74k|        }
  409|     58|        }
  409|       |    #[macro_export]
  410|       |
  410|       |
  410|      1|                }
  410|      2|                .into_iter()
  411|      1|            f.debug_struct("AugOrderedTableStPer")
  412|       |        {
  412|       |            $crate::Chap43::OrderedTableMtEph::OrderedTableMtEph::OrderedTableMtEph::empty()
  412|      1|                .finish()
  412|      2|                .collect();
  413|       |
  413|       |
  413|       |            }
  413|       |        };
  413|      0|            writeln!(
  413|      1|        }
  413|     27|        }
  413|      2|            LinkedListStPerS::from_vec(pairs)
  414|       |
  414|       |
  414|       |    }
  414|       |    }
  414|      0|                f,
  414|      1|                .finish()
  414|      2|        }
  415|       |
  415|       |
  415|       |    }
  415|      1|        }
  415|      1|        }
  415|      3|            }
  415|      5|            }
  416|       |
  416|       |    }
  416|       |    }
  416|      0|                return;
  416|      1|            start.elapsed()
  416|      6|        }
  416|       |                self.expected_successful_probes
  417|       |
  417|       |
  417|       |
  417|       |            $crate::Chap43::OrderedTableMtEph::OrderedTableMtEph::from_sorted_entries(seq)
  417|      0|            )?;
  417|      1|        }
  417|     11|            }
  417|       |    #[macro_export]
  417|       |    #[macro_export]
  418|       |
  418|       |        }};
  418|       |    }
  418|      0|            writeln!(
  418|     30|    }
  419|       |
  419|       |    }
  419|       |}
  419|      0|                f,
  419|      7|            }
  419|       |    #[macro_export]
  420|       |
  420|       |}
  420|     10|                prefixes.push(red);
  421|       |
  421|       |
  421|       |            $(
  421|     10|            }
  421|      2|            result
  421|     38|            data.push(init.clone());
  421|       |                self.expected_unsuccessful_probes
  422|       |    }
  422|      0|            )?;
  422|      2|        }
  422|      2|        };
  422|     38|        }
  423|       |
  423|       |            )*
  423|       |    }
  423|       |}
  423|       |            $(
  423|      2|                }
  423|      9|        data
  424|       |
  424|       |}
  424|      2|                return;
  424|      3|        }
  424|      9|    }
  424|       |            table
  425|       |
  425|       |            )*
  425|       |        }};
  425|       |    }
  425|      0|        }
  425|      2|        where
  425|      9|            }
  426|       |
  426|       |
  426|       |    }
  426|      0|        merged_heap.extract_all_sorted()
  426|       |    #[macro_export]
  426|       |            table
  427|       |
  427|       |
  427|       |        {
  427|       |        }};
  427|      0|    }
  427|       |    #[macro_export]
  428|       |
  428|       |        }};
  429|       |    }
  429|      2|        }
  429|      3|                    Ok(())
  430|       |
  430|       |
  430|       |        }};
  431|       |    }
  431|       |    }
  431|       |}
  432|       |
  432|       |
  432|       |
  432|       |                }
  432|       |    }
  432|      0|        LeftistHeapPQ::from_seq(&elements)
  433|       |            }
  433|       |}
  433|       |}
  433|       |}
  433|      0|    }
  433|      0|            writeln!(f)?;
  434|       |        }
  434|       |}
  435|      7|    }
  436|       |
  436|      0|            ArraySeqStPerS::from_vec(out)
  436|      2|        };
  437|       |
  437|       |            }
  437|      0|        }
  438|       |    }
  438|      0|            writeln!(f)?;
  438|      5|                        left_filtered.push(pair);
  439|       |
  439|      2|    }
  439|      5|                    }
  440|       |                }
  440|       |}
  440|      3|            out.push(n.value);
  440|       |    #[macro_export]
  441|      0|            writeln!(f)?;
  441|      9|                left_filtered
  442|      4|        }
  442|      9|            });
  443|       |
  443|      7|    }
  444|       |        };
  444|       |}
  444|      0|            writeln!(f)?;
  447|      0|        }
  448|       |    }
  448|       |            __tree
  449|       |
  449|       |        }};
  449|     10|                    right_filtered.push(pair);
  450|       |    }
  450|     10|                }
  451|       |
  451|       |            }
  452|       |
  452|       |}
  454|       |
  455|       |
  458|      1|    }
  458|      5|                filtered_entries.push(left_filtered[i].clone());
  459|       |
  459|      5|            }
  461|     10|                filtered_entries.push(right_filtered[i].clone());
  462|     10|            }
  463|       |
  465|     11|        }
  466|       |
  467|       |
  468|      1|        load_factors
  469|      1|            .into_iter()
  471|      1|            .collect()
  472|      1|    }
  473|       |}
  474|       |
  477|      1|                    return;
  478|      2|                }
  479|       |
  486|       |
  488|      2|                    ArraySeqMtEphS::tabulate(
  494|      2|                                pair
  495|       |                            }
  496|      2|                        },
  497|      2|                        left_entries.length(),
  498|       |                    )
  499|      2|                });
  500|       |
  507|      2|                            pair
  508|       |                        }
  509|      4|                    },
  510|      2|                    right_entries.length(),
  511|       |                );
  512|       |
  514|       |
  518|      2|                    updated_entries.push(left_updated.nth_cloned(i));
  519|      2|                }
  521|      4|                    updated_entries.push(right_updated.nth_cloned(i));
  522|      4|                }
  523|       |
  531|  2.58M|                            self.entries.nth_cloned(i)
  533|  4.45k|                            new_pair.clone()
  534|       |                        }
  535|  2.58M|                    },
  537|       |                );
  540|  2.58M|                    entries_vec.push(new_entries.nth_cloned(i));
  541|  2.58M|                }
  544|       |            }
  545|  4.45k|        }
  546|       |
  550|       |
  552|      0|                return;
  553|      4|            }
  554|       |
  559|      0|                }
  560|      0|                return;
  561|      4|            }
  562|       |
  568|       |
  574|      4|                        left_filtered.push(pair);
  575|      6|                    }
  576|       |                }
  577|      4|                left_filtered
  578|      4|            });
  579|       |
  585|      3|                    right_filtered.push(pair);
  586|      7|                }
  587|       |            }
  588|       |
  590|       |
  594|      4|                filtered_entries.push(left_filtered[i].clone());
  595|      4|            }
  597|      3|                filtered_entries.push(right_filtered[i].clone());
  598|      3|            }
  599|       |
  601|      4|        }
  602|       |
  606|       |
  608|      0|                return;
  609|      4|            }
  610|       |
  615|      0|                }
  616|      0|                return;
  617|      4|            }
  618|       |
  624|       |
  630|      6|                        left_filtered.push(pair);
  631|      6|                    }
  632|       |                }
  633|      4|                left_filtered
  634|      4|            });
  635|       |
  641|      7|                    right_filtered.push(pair);
  642|      7|                }
  643|       |            }
  644|       |
  646|       |
  650|      6|                filtered_entries.push(left_filtered[i].clone());
  651|      6|            }
  653|      7|                filtered_entries.push(right_filtered[i].clone());
  654|      7|            }
  655|       |
  657|      4|        }
  658|       |
  660|       |    }
  661|       |
  666|     39|        }
  667|     39|    }
  668|       |
  670|       |    #[macro_export]
  673|       |            $crate::Chap42::TableMtEph::TableMtEph::TableMtEph::empty()
  674|       |        };
  678|       |            $crate::Chap42::TableMtEph::TableMtEph::from_sorted_entries(entries)
  679|       |        }};
  680|       |    }
  681|       |}
